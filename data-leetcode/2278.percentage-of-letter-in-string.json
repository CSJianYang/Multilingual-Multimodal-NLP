[
    {
        "title": "Count Hills and Valleys in an Array",
        "question_content": "You are given a 0-indexed integer array nums. An index i is part of a hill in nums if the closest non-equal neighbors of i are smaller than nums[i]. Similarly, an index i is part of a valley in nums if the closest non-equal neighbors of i are larger than nums[i]. Adjacent indices i and j are part of the same hill or valley if nums[i] == nums[j].\nNote that for an index to be part of a hill or valley, it must have a non-equal neighbor on both the left and right of the index.\nReturn the number of hills and valleys in nums.\n&nbsp;\nExample 1:\n\nInput: nums = [2,4,1,1,6,5]\nOutput: 3\nExplanation:\nAt index 0: There is no non-equal neighbor of 2 on the left, so index 0 is neither a hill nor a valley.\nAt index 1: The closest non-equal neighbors of 4 are 2 and 1. Since 4 > 2 and 4 > 1, index 1 is a hill. \nAt index 2: The closest non-equal neighbors of 1 are 4 and 6. Since 1 < 4 and 1 < 6, index 2 is a valley.\nAt index 3: The closest non-equal neighbors of 1 are 4 and 6. Since 1 < 4 and 1 < 6, index 3 is a valley, but note that it is part of the same valley as index 2.\nAt index 4: The closest non-equal neighbors of 6 are 1 and 5. Since 6 > 1 and 6 > 5, index 4 is a hill.\nAt index 5: There is no non-equal neighbor of 5 on the right, so index 5 is neither a hill nor a valley. \nThere are 3 hills and valleys so we return 3.\n\nExample 2:\n\nInput: nums = [6,6,5,5,4,1]\nOutput: 0\nExplanation:\nAt index 0: There is no non-equal neighbor of 6 on the left, so index 0 is neither a hill nor a valley.\nAt index 1: There is no non-equal neighbor of 6 on the left, so index 1 is neither a hill nor a valley.\nAt index 2: The closest non-equal neighbors of 5 are 6 and 4. Since 5 < 6 and 5 > 4, index 2 is neither a hill nor a valley.\nAt index 3: The closest non-equal neighbors of 5 are 6 and 4. Since 5 < 6 and 5 > 4, index 3 is neither a hill nor a valley.\nAt index 4: The closest non-equal neighbors of 4 are 5 and 1. Since 4 < 5 and 4 > 1, index 4 is neither a hill nor a valley.\nAt index 5: There is no non-equal neighbor of 1 on the right, so index 5 is neither a hill nor a valley.\nThere are 0 hills and valleys so we return 0.\n\n&nbsp;\nConstraints:\n\n\t3 <= nums.length <= 100\n\t1 <= nums[i] <= 100",
        "solutions": [
            {
                "id": 1879182,
                "title": "two-pointers",
                "content": "Duplicates could be tricky to handle. For that, we use a second pointer (`j`), which we update only when we detect a hill or a valley.\\n\\n**C++**\\n```cpp\\nint countHillValley(vector<int>& nums) {\\n    int res = 0;\\n    for (int i = 1, j = 0; i < nums.size() - 1; ++i)\\n        if ((nums[j] < nums[i] && nums[i] > nums [i + 1]) || \\n            (nums[j] > nums[i] && nums[i] < nums [i + 1])) {\\n            ++res;\\n            j = i;\\n        }            \\n    return res;\\n}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```cpp\\nint countHillValley(vector<int>& nums) {\\n    int res = 0;\\n    for (int i = 1, j = 0; i < nums.size() - 1; ++i)\\n        if ((nums[j] < nums[i] && nums[i] > nums [i + 1]) || \\n            (nums[j] > nums[i] && nums[i] < nums [i + 1])) {\\n            ++res;\\n            j = i;\\n        }            \\n    return res;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1865693,
                "title": "java-one-pass-7-lines-o-1-space",
                "content": "```java\\n public int countHillValley(int[] a){\\n        int r = 0, left = a[0];\\n        for(int i = 1; i < a.length - 1; i++)\\n            if(left < a[i] && a[i] > a[i + 1] || left > a[i] && a[i] < a[i + 1]){\\n                r++;\\n                left = a[i];\\n            }\\n        return r;\\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "```java\\n public int countHillValley(int[] a){\\n        int r = 0, left = a[0];\\n        for(int i = 1; i < a.length - 1; i++)\\n            if(left < a[i] && a[i] > a[i + 1] || left > a[i] && a[i] < a[i + 1]){\\n                r++;\\n                left = a[i];\\n            }\\n        return r;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1866831,
                "title": "python-clean-solution-simple-and-easy",
                "content": "We start by taking a for loop which goes from 1 to length of array -1.\\nSince we cannot take 2 adjacent values such that nums[i] == nums[j]. \\nSo, we update the current value to previous value which will help us in counting the next hill or valley. \\n\\nTime complexity = O(n)\\nSpace complexity = O(1)\\n\\n```class Solution:\\n    def countHillValley(self, nums: List[int]) -> int:\\n        hillValley = 0\\n        for i in range(1, len(nums)-1):\\n            if nums[i] == nums[i+1]:\\n                nums[i] = nums[i-1]\\n            if nums[i] > nums[i-1] and nums[i] > nums[i+1]:     #hill check\\n                hillValley += 1\\n            if nums[i] < nums[i-1] and nums[i] < nums[i+1]:     #valley check\\n                hillValley += 1\\n        return hillValley\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```class Solution:\\n    def countHillValley(self, nums: List[int]) -> int:\\n        hillValley = 0\\n        for i in range(1, len(nums)-1):\\n            if nums[i] == nums[i+1]:\\n                nums[i] = nums[i-1]\\n            if nums[i] > nums[i-1] and nums[i] > nums[i+1]:     #hill check\\n                hillValley += 1\\n            if nums[i] < nums[i-1] and nums[i] < nums[i+1]:     #valley check\\n                hillValley += 1\\n        return hillValley\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1865624,
                "title": "count-hills-and-valleys-in-an-array-c-simple-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int countHillValley(vector<int>& nums) {\\n\\t// taking a new vector\\n        vector<int>v;\\n        v.push_back(nums[0]);\\n\\t\\t//pushing unique elements into new vector\\n        for(int i=1;i<nums.size();i++){\\n            if(nums[i]!=nums[i-1]){\\n                v.push_back(nums[i]);\\n            }\\n        }\\n        int c=0;\\n\\t\\t//checking for valley or hill\\n        for(int i=1;i<v.size()-1;i++){\\n            if(v[i]>v[i-1] and v[i]>v[i+1] or v[i]<v[i-1] and v[i]<v[i+1]){\\n                c++;\\n            }\\n        }\\n        return c;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Array"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int countHillValley(vector<int>& nums) {\\n\\t// taking a new vector\\n        vector<int>v;\\n        v.push_back(nums[0]);\\n\\t\\t//pushing unique elements into new vector\\n        for(int i=1;i<nums.size();i++){\\n            if(nums[i]!=nums[i-1]){\\n                v.push_back(nums[i]);\\n            }\\n        }\\n        int c=0;\\n\\t\\t//checking for valley or hill\\n        for(int i=1;i<v.size()-1;i++){\\n            if(v[i]>v[i-1] and v[i]>v[i+1] or v[i]<v[i-1] and v[i]<v[i+1]){\\n                c++;\\n            }\\n        }\\n        return c;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1865635,
                "title": "java-single-pass-solution-with-comments-o-n-time-o-1-space",
                "content": "\\n    class Solution {\\n        public int countHillValley(int[] nums) {\\n            int result = 0;\\n        \\n\\t\\t\\t// Get head start. Find first index for which nums[index] != nums[index-1]\\n\\t\\t\\tint start = 1;\\n\\t\\t\\twhile(start < nums.length && nums[start] == nums[start-1])\\n\\t\\t\\t\\tstart++;\\n\\n\\t\\t\\tint prev = start-1; //index of prev different value num\\n\\t\\t\\tfor(int i=start; i<nums.length-1; i++) {\\n\\t\\t\\t\\tif(nums[i] == nums[i+1]) //If numbers are same, simply ignore them\\n\\t\\t\\t\\t\\tcontinue;\\n\\t\\t\\t\\telse {\\n\\t\\t\\t\\t\\tif(nums[i] > nums[prev] && nums[i] > nums[i+1]) //compare current num with prev number and next number\\n\\t\\t\\t\\t\\t\\tresult++;\\n\\t\\t\\t\\t\\tif(nums[i] < nums[prev] && nums[i] < nums[i+1])\\n\\t\\t\\t\\t\\t\\tresult++;\\n\\t\\t\\t\\t\\tprev = i;   // Now your current number will become prev number.\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn result;\\n\\t\\t}\\n\\t}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n        public int countHillValley(int[] nums) {\\n            int result = 0;\\n        \\n\\t\\t\\t// Get head start. Find first index for which nums[index] != nums[index-1]\\n\\t\\t\\tint start = 1;\\n\\t\\t\\twhile(start < nums.length && nums[start] == nums[start-1])\\n\\t\\t\\t\\tstart++;\\n\\n\\t\\t\\tint prev = start-1; //index of prev different value num\\n\\t\\t\\tfor(int i=start; i<nums.length-1; i++) {\\n\\t\\t\\t\\tif(nums[i] == nums[i+1]) //If numbers are same, simply ignore them\\n\\t\\t\\t\\t\\tcontinue;\\n\\t\\t\\t\\telse {\\n\\t\\t\\t\\t\\tif(nums[i] > nums[prev] && nums[i] > nums[i+1]) //compare current num with prev number and next number\\n\\t\\t\\t\\t\\t\\tresult++;\\n\\t\\t\\t\\t\\tif(nums[i] < nums[prev] && nums[i] < nums[i+1])\\n\\t\\t\\t\\t\\t\\tresult++;\\n\\t\\t\\t\\t\\tprev = i;   // Now your current number will become prev number.\\n\\t\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 1865658,
                "title": "easiest-c-solution-two-pointers",
                "content": "```\\nclass Solution {\\npublic:\\n    int countHillValley(vector<int>& nums) {\\n        int ans = 0, n = nums.size();\\n        for(int i = 1; i < n; i++){\\n            if(nums[i] == nums[i-1]) continue; //  same hill or valley\\n            \\n            int idx = i - 1, jdx = i + 1;\\n            while(idx >= 0 && nums[idx] == nums[i]) idx--;\\n            if(idx < 0) continue; // no left neighbour found\\n\\t\\t\\t\\n            while(jdx < n && nums[jdx] == nums[i]) jdx++;\\n            if(jdx == n) continue; // no right neighbour found\\n            \\n            if(nums[idx] < nums[i] && nums[jdx] < nums[i]) ans++;\\n            else if(nums[idx] > nums[i] && nums[jdx] > nums[i]) ans++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int countHillValley(vector<int>& nums) {\\n        int ans = 0, n = nums.size();\\n        for(int i = 1; i < n; i++){\\n            if(nums[i] == nums[i-1]) continue; //  same hill or valley\\n            \\n            int idx = i - 1, jdx = i + 1;\\n            while(idx >= 0 && nums[idx] == nums[i]) idx--;\\n            if(idx < 0) continue; // no left neighbour found\\n\\t\\t\\t\\n            while(jdx < n && nums[jdx] == nums[i]) jdx++;\\n            if(jdx == n) continue; // no right neighbour found\\n            \\n            if(nums[idx] < nums[i] && nums[jdx] < nums[i]) ans++;\\n            else if(nums[idx] > nums[i] && nums[jdx] > nums[i]) ans++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1866666,
                "title": "count-hills-and-valleys-java-space-o-1-time-o-n-simple-solution",
                "content": "Problem: Finding the non-equal nearest neighbours on both the sides of an array element and comparing those values to decide a peak or valley. It is simple if we there are no duplicate values next to each.\\n\\nFor the adjacent duplicates we have to keep track of the closest neighbour on left and not update it till duplicates are crossed. \\n\\nOnce the adjacent duplicates are done, we can update it for the newer values .\\n\\n```\\npublic int countHillValley(int[] nums) {\\n        int ans = 0;\\n        int prev = nums[0];\\n        for(int i = 1; i < nums.length-1; i++){\\n            if((nums[i] > nums[i+1] && nums[i] > prev || (nums[i] < nums[i+1] && nums[i] < prev)))\\n                ans++;\\n            if(nums[i] != nums[i+1]){\\n                prev = nums[i];\\n            }\\n        }\\n        return ans;\\n    }\\n\\t```",
                "solutionTags": [
                    "Java",
                    "Array"
                ],
                "code": "```\\npublic int countHillValley(int[] nums) {\\n        int ans = 0;\\n        int prev = nums[0];\\n        for(int i = 1; i < nums.length-1; i++){\\n            if((nums[i] > nums[i+1] && nums[i] > prev || (nums[i] < nums[i+1] && nums[i] < prev)))\\n                ans++;\\n            if(nums[i] != nums[i+1]){\\n                prev = nums[i];\\n            }\\n        }\\n        return ans;\\n    }\\n\\t```",
                "codeTag": "Unknown"
            },
            {
                "id": 1865655,
                "title": "python3-single-pass-o-n-time-o-1-space",
                "content": "```\\nclass Solution:\\n    def countHillValley(self, nums: List[int]) -> int:\\n        res = 0\\n        candidate = last_num = None\\n        \\n        for i in range(1, len(nums)):\\n            if nums[i] != nums[i-1]:\\n                if candidate and ((candidate > last_num and candidate > nums[i]) or (candidate < last_num and candidate < nums[i])):\\n                    res += 1\\n                candidate = nums[i]\\n                last_num = nums[i-1]\\n                    \\n        return res\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def countHillValley(self, nums: List[int]) -> int:\\n        res = 0\\n        candidate = last_num = None\\n        \\n        for i in range(1, len(nums)):\\n            if nums[i] != nums[i-1]:\\n                if candidate and ((candidate > last_num and candidate > nums[i]) or (candidate < last_num and candidate < nums[i])):\\n                    res += 1\\n                candidate = nums[i]\\n                last_num = nums[i-1]\\n                    \\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1868487,
                "title": "javascript-filter-loop",
                "content": "By removing side-by-side duplicates, we can shorten the array and remove the need for code that would tell us if a number was part of a previous valley or hill. We then have our loop ignore the edges of the array, as our code tests each number against the one before & after it.\\n\\n```\\nvar countHillValley = function(nums) {\\n    let answer = 0;\\n    nums = nums.filter((a, i, b) => a !== b[i + 1]); // Remove Flatlands\\n    for (let i = 1; i < nums.length - 1; i++) {\\n        if (nums[i - 1] > nums [i] && nums[i] < nums[i + 1]) answer++; // Valley\\n        if (nums[i - 1] < nums [i] && nums[i] > nums[i + 1]) answer++; // Hill\\n    }\\n    return answer;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar countHillValley = function(nums) {\\n    let answer = 0;\\n    nums = nums.filter((a, i, b) => a !== b[i + 1]); // Remove Flatlands\\n    for (let i = 1; i < nums.length - 1; i++) {\\n        if (nums[i - 1] > nums [i] && nums[i] < nums[i + 1]) answer++; // Valley\\n        if (nums[i - 1] < nums [i] && nums[i] > nums[i + 1]) answer++; // Hill\\n    }\\n    return answer;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1865568,
                "title": "c-python-js-simple-explained-o-n-faster-than-100",
                "content": "The idea of this problem is pretty simple, we wish to count the number of Valleys and Hills in the array.\\nThe solution used in this problem is focused on simplicity and being easy to understand.\\nThis is O(n) time complexity, and O(n) memory complexity.\\n\\n**Strategy:**\\n\\nSo, to find if a number is a hill or a valley, we need to see if the neighboring values that aren\\'t the same are both an increase or decrease relative to this number.\\n\\nStep 1:\\n\\nMake sure that there are no neighboring nodes of the same values, so turning something like ``[6,7,7,7,8,8,9,2] -> [6,7,8,9,2]``.\\n\\nStep 2:\\n\\nLoop through the array starting at the 2nd index and up to the 2nd last index, and increase the return value if a nodes neighbors are both greater than or less than the node.\\n\\n**Solution:**\\n\\n**C++**\\n\\n```\\nint countHillValley(vector<int>& ns) {\\n    //Step 1\\n    std::vector<int> nums;\\n    int l = ns[0];\\n    nums.push_back(l);\\n    for (int n : ns) {\\n        if (n != l) {\\n            nums.push_back(n);\\n            l = n;\\n        }\\n    }\\n        \\n    //Step 2.\\n    int ret = 0;\\n    for (int i = 1; i < nums.size() - 1; i++) {\\n        if (nums[i-1] < nums[i] == nums[i+1] < nums[i]) ret++;\\n    }\\n    return ret;\\n}\\n```\\n\\n**Python**\\n\\n```\\ndef countHillValley(self, ns: List[int]) -> int:\\n    #Step 1\\n    nums = []\\n    l = ns[0]\\n    nums.append(l)\\n    for n in ns:\\n        if n != l:\\n            nums.append(n)\\n            l = n\\n                \\n    #Step 2\\n    ret = 0\\n    for i in range (1, len(nums) - 1):\\n        if ((nums[i-1] < nums[i]) == (nums[i+1] < nums[i])):\\n             ret += 1\\n            \\n    return ret\\n```\\n\\n**Javascript**\\n\\n```\\nvar countHillValley = function(ns) {\\n    //Step 1\\n    nums = [];\\n    let l = ns[0];\\n    nums.push(l);\\n    for (let i = 0; i < ns.length; i++) {\\n        n = ns[i];\\n        if (n != l) {\\n            l = n;\\n            nums.push(n);\\n        }\\n    }\\n\\n    \\n    //Step 2\\n    let ret = 0;\\n    for (let i = 1; i < nums.length - 1; i++) {\\n        if (nums[i-1] < nums[i] == nums[i+1] < nums[i]) ret++;\\n    }\\n    \\n    return ret;        \\n};\\n```\\n",
                "solutionTags": [
                    "Python",
                    "C",
                    "JavaScript"
                ],
                "code": "```\\nint countHillValley(vector<int>& ns) {\\n    //Step 1\\n    std::vector<int> nums;\\n    int l = ns[0];\\n    nums.push_back(l);\\n    for (int n : ns) {\\n        if (n != l) {\\n            nums.push_back(n);\\n            l = n;\\n        }\\n    }\\n        \\n    //Step 2.\\n    int ret = 0;\\n    for (int i = 1; i < nums.size() - 1; i++) {\\n        if (nums[i-1] < nums[i] == nums[i+1] < nums[i]) ret++;\\n    }\\n    return ret;\\n}\\n```\n```\\ndef countHillValley(self, ns: List[int]) -> int:\\n    #Step 1\\n    nums = []\\n    l = ns[0]\\n    nums.append(l)\\n    for n in ns:\\n        if n != l:\\n            nums.append(n)\\n            l = n\\n                \\n    #Step 2\\n    ret = 0\\n    for i in range (1, len(nums) - 1):\\n        if ((nums[i-1] < nums[i]) == (nums[i+1] < nums[i])):\\n             ret += 1\\n            \\n    return ret\\n```\n```\\nvar countHillValley = function(ns) {\\n    //Step 1\\n    nums = [];\\n    let l = ns[0];\\n    nums.push(l);\\n    for (let i = 0; i < ns.length; i++) {\\n        n = ns[i];\\n        if (n != l) {\\n            l = n;\\n            nums.push(n);\\n        }\\n    }\\n\\n    \\n    //Step 2\\n    let ret = 0;\\n    for (let i = 1; i < nums.length - 1; i++) {\\n        if (nums[i-1] < nums[i] == nums[i+1] < nums[i]) ret++;\\n    }\\n    \\n    return ret;        \\n};\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1868034,
                "title": "my-easy-java-solution",
                "content": "Only move the previous pointer when we have a hill or valley.\\nElse keep that pointer, never move it.\\n\\n```\\nclass Solution {\\n    public int countHillValley(int[] nums) {\\n        int length = nums.length;\\n        int countHillValley = 0;\\n        int previous = nums[0];\\n        for (int i = 1; i < length - 1; i++) {\\n            if (previous < nums[i] && nums[i] > nums[i + 1] || previous > nums[i] && nums[i] < nums[i + 1]) {\\n                previous = nums[i];\\n                countHillValley++;\\n            }\\n        }\\n        return countHillValley;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int countHillValley(int[] nums) {\\n        int length = nums.length;\\n        int countHillValley = 0;\\n        int previous = nums[0];\\n        for (int i = 1; i < length - 1; i++) {\\n            if (previous < nums[i] && nums[i] > nums[i + 1] || previous > nums[i] && nums[i] < nums[i + 1]) {\\n                previous = nums[i];\\n                countHillValley++;\\n            }\\n        }\\n        return countHillValley;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1867081,
                "title": "java-clean-code",
                "content": "```\\npublic int countHillValley(int[] nums) {\\n        int left = nums[0];\\n        int result = 0;\\n\\n        for (int i = 1; i < nums.length - 1; i++) {\\n            if (isHill(left, nums[i], nums[i + 1]) || isValley(left, nums[i], nums[i + 1])) {\\n                result++;\\n                left = nums[i];\\n            }\\n        }\\n        return result;\\n    }\\n\\n    private boolean isHill(int left, int value, int right) {\\n        return value > left && value > right;\\n    }\\n\\n    private boolean isValley(int left, int value, int right) {\\n        return value < left && value < right;\\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\npublic int countHillValley(int[] nums) {\\n        int left = nums[0];\\n        int result = 0;\\n\\n        for (int i = 1; i < nums.length - 1; i++) {\\n            if (isHill(left, nums[i], nums[i + 1]) || isValley(left, nums[i], nums[i + 1])) {\\n                result++;\\n                left = nums[i];\\n            }\\n        }\\n        return result;\\n    }\\n\\n    private boolean isHill(int left, int value, int right) {\\n        return value > left && value > right;\\n    }\\n\\n    private boolean isValley(int left, int value, int right) {\\n        return value < left && value < right;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1867075,
                "title": "c-6-lines-with-std-erase-and-std-unique-2-lines-using-count-if",
                "content": "```cpp\\nint countHillValley(vector<int>& nums) {\\n\\tnums.erase(unique(nums.begin(), nums.end()), nums.end()); // this removes equal adjacent numbers\\n\\tint n = 0;\\n\\tfor(int i = 1; i < nums.size() -1; ++i)\\n\\t\\tn += (nums[i-1] < nums[i] && nums[i] > nums[i+1])  // hill\\n\\t\\t  || (nums[i-1] > nums[i] && nums[i] < nums[i+1]); // valley\\n\\treturn n;\\n}\\n```\\n\\nAs suggested by @izackwu, detection of hill or valley can be reduced :\\n```cpp\\nint countHillValley(vector<int>& nums) {\\n\\tnums.erase(unique(nums.begin(), nums.end()), nums.end()); // this removes equal adjacent numbers\\n\\tint n = 0;\\n\\tfor(int i = 1; i < nums.size() -1; ++i)\\n\\t\\tn += (nums[i - 1] > nums[i]) == (nums[i] < nums[i + 1]); // hill or valley\\n   return n;\\n}\\n```\\n\\nJust for the fun of ccode golfing, we can even drop it to 2 lines using (or abusing) `std::count_if` :\\n\\n```cpp\\nint countHillValley(vector<int>& nums) {\\n\\tnums.erase(unique(nums.begin(), nums.end()), nums.end()); \\n\\treturn nums.size()>2?count_if(next(nums.begin()), prev(nums.end()),[](const int& a) {return (*(&a-1) > a) == (a < *(&a+1));}):0;\\n}\\n```",
                "solutionTags": [],
                "code": "```cpp\\nint countHillValley(vector<int>& nums) {\\n\\tnums.erase(unique(nums.begin(), nums.end()), nums.end()); // this removes equal adjacent numbers\\n\\tint n = 0;\\n\\tfor(int i = 1; i < nums.size() -1; ++i)\\n\\t\\tn += (nums[i-1] < nums[i] && nums[i] > nums[i+1])  // hill\\n\\t\\t  || (nums[i-1] > nums[i] && nums[i] < nums[i+1]); // valley\\n\\treturn n;\\n}\\n```\n```cpp\\nint countHillValley(vector<int>& nums) {\\n\\tnums.erase(unique(nums.begin(), nums.end()), nums.end()); // this removes equal adjacent numbers\\n\\tint n = 0;\\n\\tfor(int i = 1; i < nums.size() -1; ++i)\\n\\t\\tn += (nums[i - 1] > nums[i]) == (nums[i] < nums[i + 1]); // hill or valley\\n   return n;\\n}\\n```\n```cpp\\nint countHillValley(vector<int>& nums) {\\n\\tnums.erase(unique(nums.begin(), nums.end()), nums.end()); \\n\\treturn nums.size()>2?count_if(next(nums.begin()), prev(nums.end()),[](const int& a) {return (*(&a-1) > a) == (a < *(&a+1));}):0;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2552317,
                "title": "python-clean-concise-short-and-simple",
                "content": "You will be able to understand the solution using the comments. \\nLet me know if any questions. \\n\\n```\\nclass Solution:\\n    def countHillValley(self, nums: List[int]) -> int:\\n        hillValley  = 0 \\n\\t\\t\\n\\t\\t#Here we will keep track of the left neighbour \\n        #Initially left neighbour is the 0th element. \\n        leftNeighbour = nums[0]\\n        \\n        #We will apply a loop from 1st index to second last index becuase for any element to be a \\n        #hill or a valley it must have both neighbours. \\n        for i in range(1, len(nums) - 1):\\n            \\n            #If both the left neighbour and right element are greater that it is a valley.\\n            #We incerement count and also we will update the left neighbour to current element. \\n            if nums[i]<nums[i+1] and nums[i]<leftNeighbour:\\n                leftNeighbour = nums[i]\\n                hillValley  += 1\\n            \\n            #If both the left neighbour and right element are smaller that it is a hill.\\n            #We incerement count and also we will update the left neighbour to current element. \\n            if nums[i]>nums[i+1] and nums[i]>leftNeighbour:\\n                leftNeighbour = nums[i]\\n                hillValley  += 1\\n                \\n        return hillValley\\n```\\n\\nWe can also have another solution in which we update the left neighbour in a different way:\\n\\n```\\nclass Solution:\\n    def countHillValley(self, nums: List[int]) -> int:\\n        #Here we will keep track of the left neighbour \\n        hillValley  = 0 \\n        #Initially left neighbour is the left 0th element. \\n        leftNeighbour = nums[0]\\n        \\n        #We will apply a loop from 1st index to second last index becuase for any element to be a \\n        #hill or a valley it must have both neighbours. \\n        for i in range(1, len(nums) - 1):\\n            \\n            #If both the left neighbour and right element are greater that it is a valley.\\n            if nums[i]<nums[i+1] and nums[i]<leftNeighbour:\\n                hillValley  += 1\\n            \\n            #If both the left neighbour and right element are smaller that it is a hill. \\n            if nums[i]>nums[i+1] and nums[i]>leftNeighbour:\\n                hillValley  += 1\\n            \\n            #If current element and next element are not same then current element will be the \\n            #left neighbour for next element\\n            #If not then the old left neighbour will continue.            \\n            if nums[i] != nums[i+1]:\\n                leftNeighbour = nums[i]\\n                \\n        return hillValley \\n\\t\\t",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def countHillValley(self, nums: List[int]) -> int:\\n        hillValley  = 0 \\n\\t\\t\\n\\t\\t#Here we will keep track of the left neighbour \\n        #Initially left neighbour is the 0th element. \\n        leftNeighbour = nums[0]\\n        \\n        #We will apply a loop from 1st index to second last index becuase for any element to be a \\n        #hill or a valley it must have both neighbours. \\n        for i in range(1, len(nums) - 1):\\n            \\n            #If both the left neighbour and right element are greater that it is a valley.\\n            #We incerement count and also we will update the left neighbour to current element. \\n            if nums[i]<nums[i+1] and nums[i]<leftNeighbour:\\n                leftNeighbour = nums[i]\\n                hillValley  += 1\\n            \\n            #If both the left neighbour and right element are smaller that it is a hill.\\n            #We incerement count and also we will update the left neighbour to current element. \\n            if nums[i]>nums[i+1] and nums[i]>leftNeighbour:\\n                leftNeighbour = nums[i]\\n                hillValley  += 1\\n                \\n        return hillValley\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2528962,
                "title": "python-easy-o-n-solution",
                "content": "```\\nclass Solution:\\n    def countHillValley(self, nums: List[int]) -> int:\\n        increasing, changed = -1, 0\\n        for i in range(1, len(nums)):\\n            if nums[i] > nums[i - 1]:\\n                changed += int(increasing == 0)\\n                increasing = 1\\n            elif nums[i] < nums[i - 1]:\\n                changed += int(increasing == 1)\\n                increasing = 0\\n        return changed\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def countHillValley(self, nums: List[int]) -> int:\\n        increasing, changed = -1, 0\\n        for i in range(1, len(nums)):\\n            if nums[i] > nums[i - 1]:\\n                changed += int(increasing == 0)\\n                increasing = 1\\n            elif nums[i] < nums[i - 1]:\\n                changed += int(increasing == 1)\\n                increasing = 0\\n        return changed\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1865653,
                "title": "python-simple-iteration-o-n",
                "content": "```\\nclass Solution:\\n    def countHillValley(self, nums: List[int]) -> int:\\n        c = 0\\n        i = 1\\n        while i <len(nums)-1:\\n            j = i+1\\n            while j < len(nums)-1 and nums[j] == nums[i]:\\n                j += 1\\n            if (nums[i-1] > nums[i] and nums[j] > nums[i]) or (nums[i-1] < nums[i] and nums[j] < nums[i]):\\n                    c += 1\\n            i = j\\n        return c\\n ```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def countHillValley(self, nums: List[int]) -> int:\\n        c = 0\\n        i = 1\\n        while i <len(nums)-1:\\n            j = i+1\\n            while j < len(nums)-1 and nums[j] == nums[i]:\\n                j += 1\\n            if (nums[i-1] > nums[i] and nums[j] > nums[i]) or (nums[i-1] < nums[i] and nums[j] < nums[i]):\\n                    c += 1\\n            i = j\\n        return c\\n ```",
                "codeTag": "Java"
            },
            {
                "id": 2595420,
                "title": "java-array-faster-than-100-java-submissions",
                "content": "```\\nclass Solution {\\n    public int countHillValley(int[] a){\\n        int r=0,left=a[0];\\n        for(int i=1;i<a.length-1;i++){\\n            if(left<a[i] && a[i]>a[i+1] || left>a[i] && a[i]<a[i+1]){\\n                r++;\\n                left=a[i];\\n            }\\n        }\\n        return r;\\n    }\\n}\\n```\\nKindly upvote if you like the code.",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Counting"
                ],
                "code": "```\\nclass Solution {\\n    public int countHillValley(int[] a){\\n        int r=0,left=a[0];\\n        for(int i=1;i<a.length-1;i++){\\n            if(left<a[i] && a[i]>a[i+1] || left>a[i] && a[i]<a[i+1]){\\n                r++;\\n                left=a[i];\\n            }\\n        }\\n        return r;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1866869,
                "title": "python3-one-pass-o-1-space",
                "content": "```\\nclass Solution:\\n    def countHillValley(self, nums: List[int]) -> int:\\n        \\n        #cnt: An integer to store total hills and valleys\\n        #left: Highest point of hill or lowest point of valley left of the current index\\n        cnt, left = 0, nums[0]\\n        \\n        for i in range(1, len(nums)-1):\\n            if (left<nums[i] and nums[i]>nums[i+1]) or (left>nums[i] and nums[i]<nums[i+1]):\\n                cnt+=1\\n                left=nums[i]\\n        return cnt\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def countHillValley(self, nums: List[int]) -> int:\\n        \\n        #cnt: An integer to store total hills and valleys\\n        #left: Highest point of hill or lowest point of valley left of the current index\\n        cnt, left = 0, nums[0]\\n        \\n        for i in range(1, len(nums)-1):\\n            if (left<nums[i] and nums[i]>nums[i+1]) or (left>nums[i] and nums[i]<nums[i+1]):\\n                cnt+=1\\n                left=nums[i]\\n        return cnt\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1866196,
                "title": "c-easy-to-understand-beginners-friendly-using-pointer",
                "content": "**Please upvote if it helps **\\n\\n```\\nclass Solution {\\npublic:\\n    int countHillValley(vector<int>& nums) \\n    {\\n        int ans = 0;                   // for storing the final result\\n        int k = -1;                    // it is used as a pointer for the new creating nums without duplicaccy\\n        int size = 0;                  // it will store the size of new nums \\n    \\n        //eliminating duplicates from the array\\n        for(int i = 0; i<nums.size(); i++)\\n        {\\n            if(k == -1 or nums[k]!=nums[i])       // k==-1 means first element and if there is no duplicaccy then  \\n            {\\n                size++;                           // increase the size\\n                nums[k+1] = nums[i];              // assign the i to k+1\\n                k++;                              // move pointer to the next\\n            }\\n        }\\n    \\n        for(int i = 1; i<size-1; i++)\\n        {\\n            // H  ills\\n            if((nums[i]>nums[i+1] and nums[i]>nums[i-1]))\\n            {\\n                ans++;\\n            }\\n            \\n            // Valleys\\n            if((nums[i]<nums[i+1] and nums[i]<nums[i-1]))\\n            {\\n                ans++;\\n            }\\n        }\\n    \\n        return ans;\\n    }\\n};\\n```\\n**Please upvote if it helps **",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int countHillValley(vector<int>& nums) \\n    {\\n        int ans = 0;                   // for storing the final result\\n        int k = -1;                    // it is used as a pointer for the new creating nums without duplicaccy\\n        int size = 0;                  // it will store the size of new nums \\n    \\n        //eliminating duplicates from the array\\n        for(int i = 0; i<nums.size(); i++)\\n        {\\n            if(k == -1 or nums[k]!=nums[i])       // k==-1 means first element and if there is no duplicaccy then  \\n            {\\n                size++;                           // increase the size\\n                nums[k+1] = nums[i];              // assign the i to k+1\\n                k++;                              // move pointer to the next\\n            }\\n        }\\n    \\n        for(int i = 1; i<size-1; i++)\\n        {\\n            // H  ills\\n            if((nums[i]>nums[i+1] and nums[i]>nums[i-1]))\\n            {\\n                ans++;\\n            }\\n            \\n            // Valleys\\n            if((nums[i]<nums[i+1] and nums[i]<nums[i-1]))\\n            {\\n                ans++;\\n            }\\n        }\\n    \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3576588,
                "title": "tail-pointer",
                "content": "# \\uD83D\\uDE09Don\\'t just watch & move away, also give an Upvote.\\uD83D\\uDE09\\n\\n# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int countHillValley(vector<int>& nums) {\\n        int n = size(nums);\\n        int count=0;\\n        int i=1,j=0; // j is a tail pointer\\n        for(i=1; i<n-1; i++)\\n        {\\n            if(nums[j] < nums[i] && nums[i] > nums[i+1]){\\n                count++;\\n                j = i;\\n            }\\n            else if(nums[j] > nums[i] && nums[i] < nums[i+1]){\\n                count++;\\n                j = i;\\n            }\\n        }\\n\\n<!-- \\u2705Well before returning answer don\\'t forget to UPVOTE.\\u2705 -->\\n        return count;\\n    }\\n};\\n```\\n![Leetcode Upvote.gif](https://assets.leetcode.com/users/images/ebe03d36-f10f-4b43-aebb-8a3f2c73c77b_1685388122.1682274.gif)\\n\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "C",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int countHillValley(vector<int>& nums) {\\n        int n = size(nums);\\n        int count=0;\\n        int i=1,j=0; // j is a tail pointer\\n        for(i=1; i<n-1; i++)\\n        {\\n            if(nums[j] < nums[i] && nums[i] > nums[i+1]){\\n                count++;\\n                j = i;\\n            }\\n            else if(nums[j] > nums[i] && nums[i] < nums[i+1]){\\n                count++;\\n                j = i;\\n            }\\n        }\\n\\n<!-- \\u2705Well before returning answer don\\'t forget to UPVOTE.\\u2705 -->\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3412861,
                "title": "count-hills-and-valleys-in-an-array-solution-in-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1)\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int countHillValley(vector<int>& nums) {\\n        int i, count=0, hill=0, valley=0;\\n        for(i=1 ; i<nums.size() ; i++)\\n        {\\n            if(nums[i-1]<nums[i] && hill==0)\\n            {\\n                hill=1;\\n                if(valley==1)\\n                {\\n                    count++;\\n                    valley=0;\\n                }\\n            }\\n            else if(nums[i-1]>nums[i])\\n            {\\n                valley=1;\\n                if(hill==1)\\n                {\\n                    count++;\\n                    hill=0;\\n                }\\n            }\\n        }\\n        return count;\\n    }\\n};\\n```\\n![upvote new.jpg](https://assets.leetcode.com/users/images/792a2ee3-fa92-4936-9a87-216cd9a9ac02_1682613207.1269994.jpeg)",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int countHillValley(vector<int>& nums) {\\n        int i, count=0, hill=0, valley=0;\\n        for(i=1 ; i<nums.size() ; i++)\\n        {\\n            if(nums[i-1]<nums[i] && hill==0)\\n            {\\n                hill=1;\\n                if(valley==1)\\n                {\\n                    count++;\\n                    valley=0;\\n                }\\n            }\\n            else if(nums[i-1]>nums[i])\\n            {\\n                valley=1;\\n                if(hill==1)\\n                {\\n                    count++;\\n                    hill=0;\\n                }\\n            }\\n        }\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3169968,
                "title": "python-clean-solution-explanation-of-an-edge-case",
                "content": "# Intuition\\nWe are iterating from 1st to last -1 element.\\nFor each one determine is it hill or velly:\\nelement-1 < element > element + 1 or element-1 > element < element + 1\\n\\n# Approach\\nImportant to not count the same velly [4, ***1,1,1*** ,4] multiple times.\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution:\\n    def countHillValley(self, nums: List[int]) -> int:\\n        result = 0\\n        for i in range(1, len(nums)-1):\\n            # edge case, the same velly!\\n            # adjacent indexes should be considered as one velly or hill\\n            # to handle this, we can check if next value is the same as current\\n            # for example in [4,1,1,6]\\n            # [4, 1(we are here), 1(detected next value), 6]\\n            # replace the first 1 by 4 (4 is a previous value)\\n            # as result we get: [4,4,1,6]\\n            # so thet at the next iteration the second 1 will be detected as a valley\\n            # [4,4,1(we are here),6] \\n            # 4 > 1 < 6\\n            if nums[i] == nums[i+1]:\\n                nums[i] = nums[i-1]\\n            elif nums[i-1] > nums[i] < nums[i+1] or nums[i-1] < nums[i] > nums[i+1]:\\n                result += 1\\n        return result\\n            \\n\\n            \\n\\n\\n            \\n\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Array",
                    "Shortest Path"
                ],
                "code": "```\\nclass Solution:\\n    def countHillValley(self, nums: List[int]) -> int:\\n        result = 0\\n        for i in range(1, len(nums)-1):\\n            # edge case, the same velly!\\n            # adjacent indexes should be considered as one velly or hill\\n            # to handle this, we can check if next value is the same as current\\n            # for example in [4,1,1,6]\\n            # [4, 1(we are here), 1(detected next value), 6]\\n            # replace the first 1 by 4 (4 is a previous value)\\n            # as result we get: [4,4,1,6]\\n            # so thet at the next iteration the second 1 will be detected as a valley\\n            # [4,4,1(we are here),6] \\n            # 4 > 1 < 6\\n            if nums[i] == nums[i+1]:\\n                nums[i] = nums[i-1]\\n            elif nums[i-1] > nums[i] < nums[i+1] or nums[i-1] < nums[i] > nums[i+1]:\\n                result += 1\\n        return result\\n            \\n\\n            \\n\\n\\n            \\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3147988,
                "title": "cool-single-pass-java-solution-beats-100-0ms",
                "content": "\\n# Code\\n```\\nclass Solution {\\n    public int countHillValley(int[] nums) {\\n        int prevDiff = nums[1] - nums[0];\\n        int nextDiff = 0;\\n        int sum = 0;\\n\\n        for(int i = 2; i < nums.length; i++) {\\n            nextDiff = nums[i] - nums[i - 1];\\n            if(nextDiff != 0) {\\n                if(nextDiff * prevDiff < 0) {\\n                    sum += 1;\\n                }\\n                prevDiff = nextDiff;\\n            }\\n        }\\n\\n        return sum;\\n\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Java",
                    "Array"
                ],
                "code": "```\\nclass Solution {\\n    public int countHillValley(int[] nums) {\\n        int prevDiff = nums[1] - nums[0];\\n        int nextDiff = 0;\\n        int sum = 0;\\n\\n        for(int i = 2; i < nums.length; i++) {\\n            nextDiff = nums[i] - nums[i - 1];\\n            if(nextDiff != 0) {\\n                if(nextDiff * prevDiff < 0) {\\n                    sum += 1;\\n                }\\n                prevDiff = nextDiff;\\n            }\\n        }\\n\\n        return sum;\\n\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2950309,
                "title": "java-time-complexity-o-n-space-o-1-easy-solution",
                "content": "```\\nclass Solution {\\n    public int countHillValley(int[] arr) {\\n        int count = 0;\\n        for(int i = 1; i<arr.length-1; i++){\\n            if( arr[i] == arr[i+1]){ \\n                arr[i] = arr[i-1];\\n                continue;\\n            }\\n            if(arr[i]>arr[i-1] && arr[i]>arr[i+1]){\\n                count++;\\n            }else if(arr[i]<arr[i-1] && arr[i]<arr[i+1]){\\n                count++;\\n            }\\n        }\\n        return count;\\n    }\\n}",
                "solutionTags": [
                    "Array"
                ],
                "code": "class Solution {\\n    public int countHillValley(int[] arr) {\\n        int count = 0;\\n        for(int i = 1; i<arr.length-1; i++){\\n            if( arr[i] == arr[i+1]){ \\n                arr[i] = arr[i-1];\\n                continue;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2563706,
                "title": "with-explanation-comments-time-4-ms-61-39-space-9-mb-38-09",
                "content": "**Like it? ->Upvote please!** \\u30C4\\n\\n\\'\\'\\'\\nclass Solution {\\npublic:\\n    int countHillValley(vector<int>& nums) {\\n        \\n        //initialize a counter for both hills and valleys\\n        int counter=0;\\n        \\n        //initialize a new vector for the non-repeated numbers\\n        vector<int> res;\\n        \\n        //save the first array value as the first unique one\\n        res.push_back(nums[0]);\\n        \\n        //loop over the whole array elements\\n        for(int i=1;i<nums.size();i++)\\n            \\n            //check if the current one doesn\\'t equal to the last saved value\\n            if(nums[i]!=nums[i-1]){\\n                //add the non-repeated number to the new array\\n                res.push_back(nums[i]);\\n            }\\n    \\n        //loop over the whole unique array numbers        \\n        for(int i=1;i<res.size()-1;i++)\\n            \\n            //check of the two conditions: if their both neighbors are greater-> hill++ | both are smaller-> valley++ -> or counter++ for simplicity\\n            if(res[i]>res[i+1] && res[i]>res[i-1] || res[i] < res[i+1] && res[i]<res[i-1])\\n                counter++;\\n        \\n        //return the hill+vally values-> general counter value\\n        return counter;\\n    }\\n};\\n\\'\\'\\'\\n\\n**Like it? ->Upvote please!** \\u30C4\\n**If still not understood, feel free to comment. I will help you out**\\n**Happy Coding :)**",
                "solutionTags": [
                    "C++",
                    "C",
                    "Array"
                ],
                "code": "class Solution {\\npublic:\\n    int countHillValley(vector<int>& nums) {\\n        \\n        //initialize a counter for both hills and valleys\\n        int counter=0;\\n        \\n        //initialize a new vector for the non-repeated numbers\\n        vector<int> res;\\n        \\n        //save the first array value as the first unique one\\n        res.push_back(nums[0]);\\n        \\n        //loop over the whole array elements\\n        for(int i=1;i<nums.size();i++)\\n            \\n            //check if the current one doesn\\'t equal to the last saved value\\n            if(nums[i]!=nums[i-1]){\\n                //add the non-repeated number to the new array\\n                res.push_back(nums[i]);\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2272429,
                "title": "easy-to-understand-c-o-n-solution",
                "content": "\\'\\'\\'\\n     //Time Complexity : O(n)  Space Complexity : O(1)\\n   \\n        int countHillValley(vector<int>& nums) {\\n        \\n        int hills=0, valleys=0;\\n\\n        //Index before and after the \\'i\\' th index for which we are checking for hill or valley \\n        int low=0, high=1;\\n        \\n        for(int i=1;i<nums.size()-1;i++){\\n            low=i-1;\\n            high=i+1;\\n            \\n            //Handling Duplicates \\n            while(high<nums.size() && nums[high]==nums[i]) high++;\\n            if(high==nums.size()) break;\\n            \\n\\t\\t\\t//Check for Hill or Valley \\n            if(nums[i]<nums[low] && nums[i]<nums[high]) valleys++;\\n            else if(nums[i]>nums[low] && nums[i]>nums[high]) hills++;\\n            \\n            //Directly jump to high(index) and -1 because i will be incremented in loop itself \\n            i=high-1;\\n        }\\n        \\n        return hills+valleys;\\n    }\\n\\'\\'\\'",
                "solutionTags": [
                    "C"
                ],
                "code": "\\'\\'\\'\\n     //Time Complexity : O(n)  Space Complexity : O(1)\\n   \\n        int countHillValley(vector<int>& nums) {\\n        \\n        int hills=0, valleys=0;\\n\\n        //Index before and after the \\'i\\' th index for which we are checking for hill or valley \\n        int low=0, high=1;\\n        \\n        for(int i=1;i<nums.size()-1;i++){\\n            low=i-1;\\n            high=i+1;\\n            \\n            //Handling Duplicates \\n            while(high<nums.size() && nums[high]==nums[i]) high++;\\n            if(high==nums.size()) break;\\n            \\n\\t\\t\\t//Check for Hill or Valley \\n            if(nums[i]<nums[low] && nums[i]<nums[high]) valleys++;\\n            else if(nums[i]>nums[low] && nums[i]>nums[high]) hills++;\\n            \\n            //Directly jump to high(index) and -1 because i will be incremented in loop itself \\n            i=high-1;\\n        }\\n        \\n        return hills+valleys;\\n    }\\n\\'\\'\\'",
                "codeTag": "Unknown"
            },
            {
                "id": 2160938,
                "title": "typescript-o-n-time-o-1-space",
                "content": "Remember previous status, going up or going down. If current node goes down since previous status is going up, it meas you just past a valley. Or conversely, you just past a hill.\\n```ts\\nfunction countHillValley(nums: number[]): number {\\n  let res = 0, status: boolean;\\n  for (let i = 1; i < nums.length; i++) {\\n    if (nums[i] === nums[i - 1]) continue;\\n    \\n    if (status === undefined) {\\n      if (nums[i] < nums[i - 1]) status = false\\n      else status = true;\\n      \\n      continue;\\n    }\\n    \\n    if (status && nums[i] < nums[i - 1] || !status && nums[i] > nums[i - 1]) res++, status = !status\\n  }\\n  \\n  return res;\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "TypeScript"
                ],
                "code": "```ts\\nfunction countHillValley(nums: number[]): number {\\n  let res = 0, status: boolean;\\n  for (let i = 1; i < nums.length; i++) {\\n    if (nums[i] === nums[i - 1]) continue;\\n    \\n    if (status === undefined) {\\n      if (nums[i] < nums[i - 1]) status = false\\n      else status = true;\\n      \\n      continue;\\n    }\\n    \\n    if (status && nums[i] < nums[i - 1] || !status && nums[i] > nums[i - 1]) res++, status = !status\\n  }\\n  \\n  return res;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2058335,
                "title": "count-hills-and-valleys-in-an-array-java-easy",
                "content": "```\\n\\n       int ans = 0;\\n        int left = arr[0];\\n        for(int i = 1; i < arr.length-1; i++){\\n            if(arr[i] > arr[i+1] && arr[i] > left){\\n                ans++;\\n                left=arr[i];     \\n            }\\n            else if(arr[i] < arr[i+1] && arr[i] < left){\\n                ans++;\\n                left=arr[i];\\n            }\\n        }\\n        return ans;\\n\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n\\n       int ans = 0;\\n        int left = arr[0];\\n        for(int i = 1; i < arr.length-1; i++){\\n            if(arr[i] > arr[i+1] && arr[i] > left){\\n                ans++;\\n                left=arr[i];     \\n            }\\n            else if(arr[i] < arr[i+1] && arr[i] < left){\\n                ans++;\\n                left=arr[i];\\n            }\\n        }\\n        return ans;\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1977956,
                "title": "java-o-n-0ms-faster-than-100",
                "content": "```\\nclass Solution {\\n    public int countHillValley(int[] nums) {\\n        int count = 0;\\n        int leftNeighbour = nums[0];\\n        for(int i = 1; i < nums.length-1; i++){\\n            if(leftNeighbour < nums[i] && nums[i+1] < nums[i])\\n                count++;\\n            if(leftNeighbour > nums[i] && nums[i+1] > nums[i])\\n                count++;\\n            if(nums[i] != nums[i+1])\\n                leftNeighbour = nums[i];\\n        }\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int countHillValley(int[] nums) {\\n        int count = 0;\\n        int leftNeighbour = nums[0];\\n        for(int i = 1; i < nums.length-1; i++){\\n            if(leftNeighbour < nums[i] && nums[i+1] < nums[i])\\n                count++;\\n            if(leftNeighbour > nums[i] && nums[i+1] > nums[i])\\n                count++;\\n            if(nums[i] != nums[i+1])\\n                leftNeighbour = nums[i];\\n        }\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1950026,
                "title": "vert-simple-commented-solution-with-c",
                "content": "```\\nclass Solution {\\npublic:\\n    int countHillValley(vector<int>& nums) {\\n        int answer = 0;\\n         // this removes equal adjacent numbers.\\n     \\tnums.erase(unique(nums.begin(), nums.end()), nums.end());\\n        \\n        //Note the start (1) and the end (size-1) as the first and the last number can\\'t be a valley or a hill.\\n\\tfor(int i = 1; i < nums.size() -1; ++i)\\n\\t\\t  if ((nums[i-1] < nums[i] && nums[i] > nums[i+1])  // if it\\'s a hill\\n\\t\\t  || (nums[i-1] > nums[i] && nums[i] < nums[i+1])) // if it\\'s a valley\\n              answer++;\\n\\treturn answer;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int countHillValley(vector<int>& nums) {\\n        int answer = 0;\\n         // this removes equal adjacent numbers.\\n     \\tnums.erase(unique(nums.begin(), nums.end()), nums.end());\\n        \\n        //Note the start (1) and the end (size-1) as the first and the last number can\\'t be a valley or a hill.\\n\\tfor(int i = 1; i < nums.size() -1; ++i)\\n\\t\\t  if ((nums[i-1] < nums[i] && nums[i] > nums[i+1])  // if it\\'s a hill\\n\\t\\t  || (nums[i-1] > nums[i] && nums[i] < nums[i+1])) // if it\\'s a valley\\n              answer++;\\n\\treturn answer;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1932870,
                "title": "python",
                "content": "```\\ndef countHillValley(self, nums: List[int]) -> int:\\n        nums1 = [nums[0]]\\n        for i in range(1, len(nums)):\\n            if nums[i] != nums1[-1]:\\n                nums1.append(nums[i])\\n        cnt = 0\\n        for i in range(1, len(nums1) - 1):\\n            if nums1[i - 1] < nums1[i] > nums1[i + 1] or nums1[i - 1] > nums1[i] < nums1[i + 1]:\\n                cnt += 1\\n        return cnt\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\ndef countHillValley(self, nums: List[int]) -> int:\\n        nums1 = [nums[0]]\\n        for i in range(1, len(nums)):\\n            if nums[i] != nums1[-1]:\\n                nums1.append(nums[i])\\n        cnt = 0\\n        for i in range(1, len(nums1) - 1):\\n            if nums1[i - 1] < nums1[i] > nums1[i + 1] or nums1[i - 1] > nums1[i] < nums1[i + 1]:\\n                cnt += 1\\n        return cnt\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1870566,
                "title": "c-one-pass-solution",
                "content": "```\\n\\tpublic int CountHillValley(int[] nums) {\\n        var count = 0;\\n        int leftBorder = nums[0];\\n        for (int i=1; i<nums.Length-1; i++) {\\n            if (nums[i] == nums[i+1]) \\n               continue;\\n            if (IsHill(nums[i], leftBorder, nums[i+1]) || IsValley(nums[i], leftBorder, nums[i+1])) \\n                count++;\\n            leftBorder = nums[i];\\n        }\\n        return count;\\n    }\\n\\t\\n\\tbool IsValley(int height, int leftBorder, int rightBorder)\\n        => height < leftBorder && height < rightBorder;\\n                \\n    bool IsHill(int height, int leftBorder, int rightBorder)\\n        => height > leftBorder && height > rightBorder;\\n```",
                "solutionTags": [],
                "code": "```\\n\\tpublic int CountHillValley(int[] nums) {\\n        var count = 0;\\n        int leftBorder = nums[0];\\n        for (int i=1; i<nums.Length-1; i++) {\\n            if (nums[i] == nums[i+1]) \\n               continue;\\n            if (IsHill(nums[i], leftBorder, nums[i+1]) || IsValley(nums[i], leftBorder, nums[i+1])) \\n                count++;\\n            leftBorder = nums[i];\\n        }\\n        return count;\\n    }\\n\\t\\n\\tbool IsValley(int height, int leftBorder, int rightBorder)\\n        => height < leftBorder && height < rightBorder;\\n                \\n    bool IsHill(int height, int leftBorder, int rightBorder)\\n        => height > leftBorder && height > rightBorder;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1868597,
                "title": "easy-solution-with-full-explanation-c-o-n-time-o-n-space",
                "content": "The question would be trivial if duplicate elements cannot be beside each other, as we would only have to compare v[i - 1] and v[i + 1] for i from 1 to N - 1. Therefore, we must come up with a method to remove adjacent elements that are equal. \\n\\nKey Observation: Adjacent duplicates will not affect the result. \\nSuppose there is a valley. Adding another trough beside the lowest element will not change the result, as there will still only be one valley. \\n\\nWithout loss of generality, adding another peak beside the highest element will not change the result, as there will still only be one peak. \\n\\nShown in the image below, adjacent duplicates do not affect the result. \\n![image](https://assets.leetcode.com/users/images/98308d6b-7748-4165-b99d-104c77961a17_1647815885.0251374.png)\\n\\n\\nTherefore, the array can be \"condensed\" by removing adjacement duplicates. \\n\\nImplementation\\nStep 1: make a new array and insert elements from the original array without adjacent duplicates. \\nStep 2. Iterate through 1 ... N - 2 (0 indexed) and count number of hills and valleys. \\n\\nTime Complexity: O(N). Traverse the graph once to make the new array, and once to count the number of peaks and troughs. \\nSpace Complexity: O(N). Insert all elements into new array without adjacent duplicates. \\n\\nC++ Implementation: \\n```\\nclass Solution {\\npublic:\\n    int countHillValley(vector<int>& nums) {\\n        vector<int> v;\\n        for(int i = 0; i < nums.size(); i++){\\n            if(v.size() == 0 || v.back() != nums[i]) v.push_back(nums[i]);\\n        }\\n        int res = 0;\\n        for(int i = 1; i < v.size() - 1; i++){\\n            if(v[i] < v[i - 1] && v[i] < v[i + 1]) res++;\\n            else if(v[i] > v[i - 1] && v[i] > v[i + 1]) res++;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int countHillValley(vector<int>& nums) {\\n        vector<int> v;\\n        for(int i = 0; i < nums.size(); i++){\\n            if(v.size() == 0 || v.back() != nums[i]) v.push_back(nums[i]);\\n        }\\n        int res = 0;\\n        for(int i = 1; i < v.size() - 1; i++){\\n            if(v[i] < v[i - 1] && v[i] < v[i + 1]) res++;\\n            else if(v[i] > v[i - 1] && v[i] > v[i + 1]) res++;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1866016,
                "title": "java-linear-time",
                "content": "```\\nclass Solution {\\n    public int countHillValley(int[] arr) {\\n         int ans = 0;\\n        int left = arr[0];\\n        for(int i = 1; i < arr.length-1; i++){\\n            if(arr[i] > arr[i+1] && arr[i] > left){\\n                ans++;\\n                left = arr[i];\\n            }\\n            else if(arr[i] < arr[i+1] && arr[i] < left){\\n                ans++;\\n                left = arr[i];\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int countHillValley(int[] arr) {\\n         int ans = 0;\\n        int left = arr[0];\\n        for(int i = 1; i < arr.length-1; i++){\\n            if(arr[i] > arr[i+1] && arr[i] > left){\\n                ans++;\\n                left = arr[i];\\n            }\\n            else if(arr[i] < arr[i+1] && arr[i] < left){\\n                ans++;\\n                left = arr[i];\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1865638,
                "title": "0ms-100-faster-o-n-2-solutions-explained-with-steps",
                "content": "If any questions, please let me know.  I will be updating the step-by-step dry run shortly.\\nIf you liked it, pls **Upvote** :)\\n\\n\\n**Solution 1:** \\n## Complexity:\\n\\tTime:  O(n)\\n\\tSpace: O(n)\\n\\n## Dry Run:\\n\\n\\tInitialize res[] =  [\\' \\', \\' \\', \\' \\', \\' \\', \\' \\', \\' \\']\\n\\t\\n\\t                  0  1  2  3  4  5\\n\\t nums[]= \\t     [2, 4, 1, 1, 6, 5]\\n\\ti: 0, res[]:     [ ,  ,  ,  ,  ,  ]\\n\\ti: 1, res[]:     [ , H,  ,  ,  ,  ]               // keep updating \\'res\\' array in each iteration of i\\n\\ti: 2, res[]:     [ , H, v,  ,  ,  ]\\n\\ti: 3, res[]:     [ , H, v, V,  ,  ]\\n\\ti: 4, res[]:     [ , H, v, V, H,  ]\\n\\t\\n\\tNow, count the number of uppercase H & V (and ignore all lowercase h & v).\\n\\tSo, return count = 3   (because, H, V, H)\\n\\n## Code:\\n\\tpublic int countHillValley(int[] nums) {\\n\\t\\t\\tint count = 0;\\n\\t\\t\\tint len = nums.length;\\n\\t\\t\\tchar[] res = new char[len];\\n\\t\\t\\tArrays.fill(res,\\' \\');\\n\\n\\t\\t\\tfor(int i = 1; i < len-1; i++){\\n\\t\\t\\t\\tif(nums[i] > nums[i-1]){                                                 // if... num at i > num at i-1                      \\n\\t\\t\\t\\t\\tif(nums[i] > nums[i+1]){ res[i] = \\'H\\'; }                                 // also, if num at i > num at i+1. => found Hill. Mark as \\'H\\'   \\n\\t\\t\\t\\t\\telse if(nums[i] == nums[i+1]){ res[i] = \\'h\\'; }                           // else, if num at i == num at i+1. Then mark as \\'h\\' instead of \\'H\\'. \\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t    // Means, it may or may not be hill, and will be figured out in next steps.\\n\\t\\t\\t\\t}else if( nums[i] < nums[i-1] ){                                         // Else if....\\n\\t\\t\\t\\t\\tif(nums[i] < nums[i+1]){ res[i] = \\'V\\'; }                                 //  means, found Valley. So, mark as \\'V\\' \\n\\t\\t\\t\\t\\telse if(nums[i] == nums[i+1]){ res[i] = \\'v\\'; }                              // Means, it may or may not be a valley, and will be figured out in next steps.\\n\\t\\t\\t\\t}else{                                                                   // Else.. Here we will figure out if \\'v\\' becomes valley \\'V\\', and if \\'h\\' becomes hill \\'H\\'\\n\\t\\t\\t\\t\\tif( res[i-1] == \\'v\\' && nums[i] < nums[i+1] ){ res[i] = \\'V\\'; }     \\n\\t\\t\\t\\t\\telse if( res[i-1] == \\'h\\' && nums[i] > nums[i+1] ){ res[i] = \\'H\\'; }\\n\\t\\t\\t\\t\\telse{ res[i] = res[i-1]; }\\n\\t\\t\\t\\t}\\n\\t\\t\\t}        \\n\\t\\t\\t\\n\\t\\t\\tfor(int i = 1; i < len-1; i++){                                              // Now, count the number of uppercase H & V (and ignore all lowercase h & v).\\n\\t\\t\\t\\tif(res[i] == \\'H\\' || res[i] == \\'V\\'){ count++; }   \\n\\t\\t\\t}        \\n\\t\\t\\treturn count;\\n\\t\\t}\\n//\\n//\\n//\\n//\\n\\n**Solution 2:**\\n## Complexity:\\n\\tTime:  O(n)\\n\\tSpace: O(1)  // constant\\n## Code:\\t\\n    public int countHillValley(int[] nums) {\\n        int count = 0, prev = 0;\\n        \\n\\t\\tfor(int i=1; i<nums.length-1; i++) {\\n\\t\\t\\tif(nums[i] == nums[i+1]){ continue; }                     // if this and next values are equal, we can not yet confirm if there is Hill or Valley.\\n\\t\\t\\telse{\\n\\t\\t\\t\\tif( (nums[i] > nums[prev] && nums[i] > nums[i+1]) || (nums[i] < nums[prev] && nums[i] < nums[i+1]) ){ \\n                    count++; \\n                }\\n\\t\\t\\t\\tprev = i;  \\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn count;\\n\\t}\\n\\t\\t\\nIf you liked it, pls **Upvote** :)\\n**NOTE:** I mentioned these 2 solutions keeping **coding interviews** in mind, as it may be better to first give a brute-force or sub optimal solution, and then more optimal solution.",
                "solutionTags": [
                    "Java"
                ],
                "code": "If any questions, please let me know.  I will be updating the step-by-step dry run shortly.\\nIf you liked it, pls **Upvote** :)\\n\\n\\n**Solution 1:** \\n## Complexity:\\n\\tTime:  O(n)\\n\\tSpace: O(n)\\n\\n## Dry Run:\\n\\n\\tInitialize res[] =  [\\' \\', \\' \\', \\' \\', \\' \\', \\' \\', \\' \\']\\n\\t\\n\\t                  0  1  2  3  4  5\\n\\t nums[]= \\t     [2, 4, 1, 1, 6, 5]\\n\\ti: 0, res[]:     [ ,  ,  ,  ,  ,  ]\\n\\ti: 1, res[]:     [ , H,  ,  ,  ,  ]               // keep updating \\'res\\' array in each iteration of i\\n\\ti: 2, res[]:     [ , H, v,  ,  ,  ]\\n\\ti: 3, res[]:     [ , H, v, V,  ,  ]\\n\\ti: 4, res[]:     [ , H, v, V, H,  ]\\n\\t\\n\\tNow, count the number of uppercase H & V (and ignore all lowercase h & v).\\n\\tSo, return count = 3   (because, H, V, H)\\n\\n## Code:\\n\\tpublic int countHillValley(int[] nums) {\\n\\t\\t\\tint count = 0;\\n\\t\\t\\tint len = nums.length;\\n\\t\\t\\tchar[] res = new char[len];\\n\\t\\t\\tArrays.fill(res,\\' \\');\\n\\n\\t\\t\\tfor(int i = 1; i < len-1; i++){\\n\\t\\t\\t\\tif(nums[i] > nums[i-1]){                                                 // if... num at i > num at i-1                      \\n\\t\\t\\t\\t\\tif(nums[i] > nums[i+1]){ res[i] = \\'H\\'; }                                 // also, if num at i > num at i+1. => found Hill. Mark as \\'H\\'   \\n\\t\\t\\t\\t\\telse if(nums[i] == nums[i+1]){ res[i] = \\'h\\'; }                           // else, if num at i == num at i+1. Then mark as \\'h\\' instead of \\'H\\'. \\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t    // Means, it may or may not be hill, and will be figured out in next steps.\\n\\t\\t\\t\\t}else if( nums[i] < nums[i-1] ){                                         // Else if....\\n\\t\\t\\t\\t\\tif(nums[i] < nums[i+1]){ res[i] = \\'V\\'; }                                 //  means, found Valley. So, mark as \\'V\\' \\n\\t\\t\\t\\t\\telse if(nums[i] == nums[i+1]){ res[i] = \\'v\\'; }                              // Means, it may or may not be a valley, and will be figured out in next steps.\\n\\t\\t\\t\\t}else{                                                                   // Else.. Here we will figure out if \\'v\\' becomes valley \\'V\\', and if \\'h\\' becomes hill \\'H\\'\\n\\t\\t\\t\\t\\tif( res[i-1] == \\'v\\' && nums[i] < nums[i+1] ){ res[i] = \\'V\\'; }     \\n\\t\\t\\t\\t\\telse if( res[i-1] == \\'h\\' && nums[i] > nums[i+1] ){ res[i] = \\'H\\'; }\\n\\t\\t\\t\\t\\telse{ res[i] = res[i-1]; }\\n\\t\\t\\t\\t}\\n\\t\\t\\t}        \\n\\t\\t\\t\\n\\t\\t\\tfor(int i = 1; i < len-1; i++){                                              // Now, count the number of uppercase H & V (and ignore all lowercase h & v).\\n\\t\\t\\t\\tif(res[i] == \\'H\\' || res[i] == \\'V\\'){ count++; }   \\n\\t\\t\\t}        \\n\\t\\t\\treturn count;\\n\\t\\t}\\n//\\n//\\n//\\n//\\n\\n**Solution 2:**\\n## Complexity:\\n\\tTime:  O(n)\\n\\tSpace: O(1)  // constant\\n## Code:\\t\\n    public int countHillValley(int[] nums) {\\n        int count = 0, prev = 0;\\n        \\n\\t\\tfor(int i=1; i<nums.length-1; i++) {\\n\\t\\t\\tif(nums[i] == nums[i+1]){ continue; }                     // if this and next values are equal, we can not yet confirm if there is Hill or Valley.\\n\\t\\t\\telse{\\n\\t\\t\\t\\tif( (nums[i] > nums[prev] && nums[i] > nums[i+1]) || (nums[i] < nums[prev] && nums[i] < nums[i+1]) ){ \\n                    count++; \\n                }\\n\\t\\t\\t\\tprev = i;  \\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn count;\\n\\t}\\n\\t\\t\\nIf you liked it, pls **Upvote** :)\\n**NOTE:** I mentioned these 2 solutions keeping **coding interviews** in mind, as it may be better to first give a brute-force or sub optimal solution, and then more optimal solution.",
                "codeTag": "Unknown"
            },
            {
                "id": 1865637,
                "title": "c-easy-approach",
                "content": "```\\nclass Solution {\\npublic:\\n    int countHillValley(vector<int>& nums) {\\n        int ans = 0;\\n        \\n        \\n        for(int i=1;i<nums.size()-1;i++){\\n           \\n            if(nums[i]==nums[i-1]) continue; \\n            int l = nums[i-1];\\n            int r = nums[i+1];\\n            \\n            if(l==nums[i]){\\n                int j = i;\\n                while(j>=0 && nums[j]==l){\\n                    j--;\\n                }\\n                if(j<0) continue;\\n                if(nums[j]==l) continue;\\n                else l = nums[j];\\n            }\\n            if(r==nums[i]){\\n                int j = i;\\n                while(j<nums.size() && nums[j]==r){\\n                    j++;\\n                }\\n                if(j==nums.size()) continue;\\n                if(nums[j]==r) continue;\\n                else r = nums[j];\\n            }\\n            \\n            if(nums[i]>l && nums[i]>r) ans++;\\n            else if(l>nums[i] && r>nums[i]) ans++;\\n            \\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int countHillValley(vector<int>& nums) {\\n        int ans = 0;\\n        \\n        \\n        for(int i=1;i<nums.size()-1;i++){\\n           \\n            if(nums[i]==nums[i-1]) continue; \\n            int l = nums[i-1];\\n            int r = nums[i+1];\\n            \\n            if(l==nums[i]){\\n                int j = i;\\n                while(j>=0 && nums[j]==l){\\n                    j--;\\n                }\\n                if(j<0) continue;\\n                if(nums[j]==l) continue;\\n                else l = nums[j];\\n            }\\n            if(r==nums[i]){\\n                int j = i;\\n                while(j<nums.size() && nums[j]==r){\\n                    j++;\\n                }\\n                if(j==nums.size()) continue;\\n                if(nums[j]==r) continue;\\n                else r = nums[j];\\n            }\\n            \\n            if(nums[i]>l && nums[i]>r) ans++;\\n            else if(l>nums[i] && r>nums[i]) ans++;\\n            \\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1865633,
                "title": "simople-c-solution-easy-0-n",
                "content": "```\\nint n=nums.size();\\n    int count=0;\\n    for(int i=0;i<n;i++){\\n        int j=i-1;\\n        int k=i+1;\\n        if(i>0 and i<n-1){\\n            if(nums[i]==nums[j]){\\n                continue;\\n            }\\n        }\\n        while(j>=0 and k<n  and (nums[i]==nums[j] or nums[i]==nums[k])){\\n            if(nums[i]==nums[j])\\n            j--;\\n            if(nums[i]==nums[k])\\n            k++;\\n        }\\n        if(j>=0 and k<n){\\n            if(nums[j]<nums[i] and nums[k]<nums[i])count++;\\n            else if(nums[j]>nums[i]and nums [k]>nums[i])count++;\\n        }\\n    }\\n    return count;\\n```",
                "solutionTags": [],
                "code": "```\\nint n=nums.size();\\n    int count=0;\\n    for(int i=0;i<n;i++){\\n        int j=i-1;\\n        int k=i+1;\\n        if(i>0 and i<n-1){\\n            if(nums[i]==nums[j]){\\n                continue;\\n            }\\n        }\\n        while(j>=0 and k<n  and (nums[i]==nums[j] or nums[i]==nums[k])){\\n            if(nums[i]==nums[j])\\n            j--;\\n            if(nums[i]==nums[k])\\n            k++;\\n        }\\n        if(j>=0 and k<n){\\n            if(nums[j]<nums[i] and nums[k]<nums[i])count++;\\n            else if(nums[j]>nums[i]and nums [k]>nums[i])count++;\\n        }\\n    }\\n    return count;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1865570,
                "title": "simple-c-solution-with-o-n-tc",
                "content": "\\n\\t   \\n\\t   \\n\\t   \\n\\t   \\n\\t   \\n\\t   \\n\\t   \\n\\t   \\n\\t   \\n\\t   \\n\\t   int n=nums.size();\\n        int count=0;\\n        for(int i=0;i<n;i++){\\n            int j=i-1;\\n            int k=i+1;\\n            if(i>0 and i<n-1){\\n                if(nums[i]==nums[j]){\\n                    continue;\\n                }\\n            }\\n            while(j>=0 and k<n  and (nums[i]==nums[j] or nums[i]==nums[k])){\\n                if(nums[i]==nums[j])\\n                j--;\\n                if(nums[i]==nums[k])\\n                k++;\\n            }\\n            if(j>=0 and k<n){\\n                if(nums[j]<nums[i] and nums[k]<nums[i])count++;\\n                else if(nums[j]>nums[i]and nums [k]>nums[i])count++;\\n            }\\n        }\\n        return count;",
                "solutionTags": [
                    "C"
                ],
                "code": "\\n\\t   \\n\\t   \\n\\t   \\n\\t   \\n\\t   \\n\\t   \\n\\t   \\n\\t   \\n\\t   \\n\\t   \\n\\t   int n=nums.size();\\n        int count=0;\\n        for(int i=0;i<n;i++){\\n            int j=i-1;\\n            int k=i+1;\\n            if(i>0 and i<n-1){\\n                if(nums[i]==nums[j]){\\n                    continue;\\n                }\\n            }\\n            while(j>=0 and k<n  and (nums[i]==nums[j] or nums[i]==nums[k])){\\n                if(nums[i]==nums[j])\\n                j--;\\n                if(nums[i]==nums[k])\\n                k++;\\n            }\\n            if(j>=0 and k<n){\\n                if(nums[j]<nums[i] and nums[k]<nums[i])count++;\\n                else if(nums[j]>nums[i]and nums [k]>nums[i])count++;\\n            }\\n        }\\n        return count;",
                "codeTag": "Unknown"
            },
            {
                "id": 3355594,
                "title": "c-golang",
                "content": "# Code\\n```\\n// C++\\nclass Solution {\\npublic:\\n    int countHillValley(vector<int>& nums) {\\n        int n = nums.size(), prev = nums[0], ans = 0;\\n        for(int i = 1; i < n; i++) {\\n            while(i < n && nums[i] == nums[i - 1]) i++;\\n            if(i < n && ((nums[i - 1] > nums[i] && nums[i - 1] > prev) || (nums[i - 1] < nums[i] && nums[i - 1] < prev))) {\\n                ans++;\\n            }\\n            prev = nums[i - 1];\\n        }\\n        return ans;\\n    }\\n};\\n\\n\\n// Golang\\nfunc countHillValley(nums []int) int {\\n    var n, prev, ans int = len(nums), nums[0], 0\\n    for i := 1; i < n; i++ {\\n        for i < n && nums[i] == nums[i - 1] {i++}\\n        if i < n && ((nums[i - 1] > nums[i] && nums[i - 1] > prev) || (nums[i - 1] < nums[i] && nums[i - 1] < prev)) {\\n            ans++\\n        }\\n        prev = nums[i - 1]\\n    }\\n    return ans\\n}\\n```",
                "solutionTags": [
                    "C++",
                    "Go"
                ],
                "code": "```\\n// C++\\nclass Solution {\\npublic:\\n    int countHillValley(vector<int>& nums) {\\n        int n = nums.size(), prev = nums[0], ans = 0;\\n        for(int i = 1; i < n; i++) {\\n            while(i < n && nums[i] == nums[i - 1]) i++;\\n            if(i < n && ((nums[i - 1] > nums[i] && nums[i - 1] > prev) || (nums[i - 1] < nums[i] && nums[i - 1] < prev))) {\\n                ans++;\\n            }\\n            prev = nums[i - 1];\\n        }\\n        return ans;\\n    }\\n};\\n\\n\\n// Golang\\nfunc countHillValley(nums []int) int {\\n    var n, prev, ans int = len(nums), nums[0], 0\\n    for i := 1; i < n; i++ {\\n        for i < n && nums[i] == nums[i - 1] {i++}\\n        if i < n && ((nums[i - 1] > nums[i] && nums[i - 1] > prev) || (nums[i - 1] < nums[i] && nums[i - 1] < prev)) {\\n            ans++\\n        }\\n        prev = nums[i - 1]\\n    }\\n    return ans\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3246224,
                "title": "o-n-tc-o-1-sc-without-filtering",
                "content": "# Code\\n```\\n/**\\n * @param {number[]} nums\\n * @return {number}\\n */\\nvar countHillValley = function(nums) {\\n    let res = 0;\\n    let i = 1;\\n    while (i < nums.length - 1) {\\n        const startIndex = i;\\n        if (nums[i] === nums[i + 1]) {\\n            while (nums[i] === nums[i + 1]) i++;\\n        }\\n        const endIndex = i;\\n        if (\\n            nums[startIndex] > nums[startIndex - 1] && nums[endIndex] > nums[endIndex + 1] ||\\n            nums[startIndex] < nums[startIndex - 1] && nums[endIndex] < nums[endIndex + 1]\\n        ) {\\n            res++;\\n        }\\n        i++;\\n    }\\n    return res;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} nums\\n * @return {number}\\n */\\nvar countHillValley = function(nums) {\\n    let res = 0;\\n    let i = 1;\\n    while (i < nums.length - 1) {\\n        const startIndex = i;\\n        if (nums[i] === nums[i + 1]) {\\n            while (nums[i] === nums[i + 1]) i++;\\n        }\\n        const endIndex = i;\\n        if (\\n            nums[startIndex] > nums[startIndex - 1] && nums[endIndex] > nums[endIndex + 1] ||\\n            nums[startIndex] < nums[startIndex - 1] && nums[endIndex] < nums[endIndex + 1]\\n        ) {\\n            res++;\\n        }\\n        i++;\\n    }\\n    return res;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3243372,
                "title": "c-solution-beats-100-runtime-0ms",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int countHillValley(vector<int>& nums) {\\n\\n    vector<int> v;\\n    v.push_back(nums[0]);\\n    for (int i = 1; i < nums.size(); i++)\\n    {\\n        if (nums[i] != nums[i - 1])\\n            v.push_back(nums[i]);\\n    }\\n    int count=0;\\n    int i = 1;\\n    while (i < v.size() - 1)\\n    {\\n        if (v[i] > v[i - 1] && v[i] > v[i + 1])\\n            count++;\\n        else if (v[i] < v[i - 1] && v[i] < v[i + 1])\\n            count++;\\n        i++;\\n    }\\n    return count;\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int countHillValley(vector<int>& nums) {\\n\\n    vector<int> v;\\n    v.push_back(nums[0]);\\n    for (int i = 1; i < nums.size(); i++)\\n    {\\n        if (nums[i] != nums[i - 1])\\n            v.push_back(nums[i]);\\n    }\\n    int count=0;\\n    int i = 1;\\n    while (i < v.size() - 1)\\n    {\\n        if (v[i] > v[i - 1] && v[i] > v[i + 1])\\n            count++;\\n        else if (v[i] < v[i - 1] && v[i] < v[i + 1])\\n            count++;\\n        i++;\\n    }\\n    return count;\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3170115,
                "title": "hills-and-valleys-js-splice-easy-to-undestand-w-comments",
                "content": "# Code\\n```\\n/**\\n * @param {number[]} nums\\n * @return {number}\\n */\\nvar countHillValley = function(nums) {\\n    let sum = 0                                                 //store sum of hills and valleys\\n    for (let i = 1; i < nums.length - 1; i++) {                 //loop all nums except fist / last\\n        while (nums[i+1] == nums[i])                            //remove same elements in nums\\n            nums.splice(i + 1, 1)                          \\n        if ( nums[i] > nums[i - 1] &&  nums[i] > nums[i + 1] )  //if hill? -> sum ++\\n            sum ++\\n        if ( nums[i] < nums[i - 1] &&  nums[i] < nums[i + 1] )  //if valley? -> sum ++  \\n            sum ++        \\n    }\\n    return sum          //return sum of hills and valleys\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} nums\\n * @return {number}\\n */\\nvar countHillValley = function(nums) {\\n    let sum = 0                                                 //store sum of hills and valleys\\n    for (let i = 1; i < nums.length - 1; i++) {                 //loop all nums except fist / last\\n        while (nums[i+1] == nums[i])                            //remove same elements in nums\\n            nums.splice(i + 1, 1)                          \\n        if ( nums[i] > nums[i - 1] &&  nums[i] > nums[i + 1] )  //if hill? -> sum ++\\n            sum ++\\n        if ( nums[i] < nums[i - 1] &&  nums[i] < nums[i + 1] )  //if valley? -> sum ++  \\n            sum ++        \\n    }\\n    return sum          //return sum of hills and valleys\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2732107,
                "title": "two-pointers-python",
                "content": "Two pointers (Python solution)\\n\\nTime complexity: O(n)\\nSpace complexity: O(1)\\n\\n```\\nclass Solution:\\n    def countHillValley(self, nums: List[int]) -> int:\\n        left, right = 1, 2\\n        total = 0\\n        while right < len(nums):\\n            if nums[left] != nums[right]:\\n                if (nums[left-1] < nums[left] and nums[right] < nums[left]) or (nums[left-1] > nums[left] and nums[right] > nums[left]):\\n                    total += 1\\n                left = right\\n            right += 1\\n        return total\\n```\\nThis is my first post. Please give me feedback about it. Cheers!",
                "solutionTags": [
                    "Python",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution:\\n    def countHillValley(self, nums: List[int]) -> int:\\n        left, right = 1, 2\\n        total = 0\\n        while right < len(nums):\\n            if nums[left] != nums[right]:\\n                if (nums[left-1] < nums[left] and nums[right] < nums[left]) or (nums[left-1] > nums[left] and nums[right] > nums[left]):\\n                    total += 1\\n                left = right\\n            right += 1\\n        return total\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2663165,
                "title": "python3",
                "content": "```\\nclass Solution:\\n    def countHillValley(self, nums: List[int]) -> int:\\n        left = None\\n        right = None\\n        total = 0\\n        for i in range(1, len(nums)-1):\\n\\n            if nums[i] == nums[i+1]:\\n                continue\\n            for j in range(-i+1,1):\\n\\n                if nums[-j] < nums[i]:\\n                    \\n                    left = 0\\n                    break\\n                elif nums[-j] > nums[i]:\\n                    left = 1\\n                    break\\n                else:\\n                    continue\\n            for k in range(i+1,len(nums)):\\n\\n                if nums[k] < nums[i]:\\n                    right = 0\\n                    break\\n                elif nums[k] > nums[i]:\\n                    right = 1\\n                    break\\n                else:\\n                    continue\\n\\n            if left == right:\\n                total += 1\\n\\n        return total\\n                \\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def countHillValley(self, nums: List[int]) -> int:\\n        left = None\\n        right = None\\n        total = 0\\n        for i in range(1, len(nums)-1):\\n\\n            if nums[i] == nums[i+1]:\\n                continue\\n            for j in range(-i+1,1):\\n\\n                if nums[-j] < nums[i]:\\n                    \\n                    left = 0\\n                    break\\n                elif nums[-j] > nums[i]:\\n                    left = 1\\n                    break\\n                else:\\n                    continue\\n            for k in range(i+1,len(nums)):\\n\\n                if nums[k] < nums[i]:\\n                    right = 0\\n                    break\\n                elif nums[k] > nums[i]:\\n                    right = 1\\n                    break\\n                else:\\n                    continue\\n\\n            if left == right:\\n                total += 1\\n\\n        return total\\n                \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2647858,
                "title": "c-fastest-and-easy-to-understand-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int countHillValley(vector<int>& n) {\\n        int a=n.size();\\n        int b=0;\\n        for(int i=0;i<a-1;i++)\\n        {\\n            if(n[i]==n[i+1])\\n            {\\n                n.erase(n.begin()+i);\\n                i=i-1;\\n                a=a-1;\\n            }\\n        }\\n        for(int i=1;i<a-1;i++)\\n        {\\n            if((n[i]>n[i-1]&&n[i]>n[i+1])||(n[i]<n[i-1]&&n[i]<n[i+1]))\\n            {\\n                b++;\\n            }\\n        }\\n        return b;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    int countHillValley(vector<int>& n) {\\n        int a=n.size();\\n        int b=0;\\n        for(int i=0;i<a-1;i++)\\n        {\\n            if(n[i]==n[i+1])\\n            {\\n                n.erase(n.begin()+i);\\n                i=i-1;\\n                a=a-1;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2623247,
                "title": "c",
                "content": "```\\nclass Solution {\\npublic:\\n    int countHillValley(vector<int>& nums) {\\n        if(nums.size()<3)\\n        {\\n            return 0;\\n        }\\n        int ans=0;\\n        for(int i=1;i<nums.size()-1;)\\n        {\\n            int num=nums[i];\\n            int idx1=i+1;\\n            int idx2=i-1;\\n            while(idx1<nums.size() and nums[idx1]==num)\\n            {\\n                idx1++;\\n            }\\n            while(idx2>0 and nums[idx2]==num)\\n            {\\n                idx2--;\\n            }\\n            if(idx1==nums.size() || idx2<0)\\n            {\\n                break;\\n            }\\n            if((nums[i]<nums[idx1] and nums[i]<nums[idx2]) || (nums[i]>nums[idx1] and nums[i]>nums[idx2]))\\n            {\\n                ans++;\\n            }\\n            i=idx1;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int countHillValley(vector<int>& nums) {\\n        if(nums.size()<3)\\n        {\\n            return 0;\\n        }\\n        int ans=0;\\n        for(int i=1;i<nums.size()-1;)\\n        {\\n            int num=nums[i];\\n            int idx1=i+1;\\n            int idx2=i-1;\\n            while(idx1<nums.size() and nums[idx1]==num)\\n            {\\n                idx1++;\\n            }\\n            while(idx2>0 and nums[idx2]==num)\\n            {\\n                idx2--;\\n            }\\n            if(idx1==nums.size() || idx2<0)\\n            {\\n                break;\\n            }\\n            if((nums[i]<nums[idx1] and nums[i]<nums[idx2]) || (nums[i]>nums[idx1] and nums[i]>nums[idx2]))\\n            {\\n                ans++;\\n            }\\n            i=idx1;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2567837,
                "title": "easy-java-solution-beginner-friendly-simple",
                "content": "**If you really found my solution helpful please upvote it, as it motivates me to post such kind of codes and help the coding community, if you have some queries or some improvements please feel free to comment and share your views.**\\n```\\nclass Solution {\\n    public int countHillValley(int[] nums) {\\n        int n = nums.length;\\n        int count = 0;\\n        for(int i = 1;i < n-1; i ++){\\n\\t\\t\\t//assigning the immediate left from the index i\\n            int left = i-1;\\n\\t\\t\\t//assigning the immediate right from the index i\\n            int right = i+1;\\n\\t\\t\\t//Searching for the closest neighbour at the left whose value not equal to the ith index\\n            while(left != 0 && nums[left] == nums[i]){\\n                left--;\\n            }\\n\\t\\t\\t//Searching for the closest neighbour at the right whose value not equal to the ith index and not equal to the left closest neighbour\\n            while(right != n && nums[right] == nums[i] && nums[left] == nums[right]){\\n                right++;\\n            }\\n\\t\\t\\t//checking if any of the left and right index does meet the closest neighbour\\n            if(left == -1 || right == n){\\n                continue;\\n            }\\n\\t\\t\\t//check if its a hill\\n            if(nums[i] > nums[left] && nums[i] > nums[right]){\\n                count++;\\n\\t\\t\\t\\t//if its a hill no need to check if its valley or not\\n                continue;\\n            }\\n\\t\\t\\t//check if its a valley\\n            if(nums[i] < nums[left] && nums[i] < nums[right]){\\n                count++;\\n            }\\n        }\\n        return count;\\n    }\\n}\\n```\\n**Happy Coding**",
                "solutionTags": [
                    "Java",
                    "Array"
                ],
                "code": "```\\nclass Solution {\\n    public int countHillValley(int[] nums) {\\n        int n = nums.length;\\n        int count = 0;\\n        for(int i = 1;i < n-1; i ++){\\n\\t\\t\\t//assigning the immediate left from the index i\\n            int left = i-1;\\n\\t\\t\\t//assigning the immediate right from the index i\\n            int right = i+1;\\n\\t\\t\\t//Searching for the closest neighbour at the left whose value not equal to the ith index\\n            while(left != 0 && nums[left] == nums[i]){\\n                left--;\\n            }\\n\\t\\t\\t//Searching for the closest neighbour at the right whose value not equal to the ith index and not equal to the left closest neighbour\\n            while(right != n && nums[right] == nums[i] && nums[left] == nums[right]){\\n                right++;\\n            }\\n\\t\\t\\t//checking if any of the left and right index does meet the closest neighbour\\n            if(left == -1 || right == n){\\n                continue;\\n            }\\n\\t\\t\\t//check if its a hill\\n            if(nums[i] > nums[left] && nums[i] > nums[right]){\\n                count++;\\n\\t\\t\\t\\t//if its a hill no need to check if its valley or not\\n                continue;\\n            }\\n\\t\\t\\t//check if its a valley\\n            if(nums[i] < nums[left] && nums[i] < nums[right]){\\n                count++;\\n            }\\n        }\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2551677,
                "title": "java-o-n-with-explanation",
                "content": "\\tclass Solution {\\n\\t\\tpublic int countHillValley(int[] nums) {\\n\\t\\t\\tif(nums.length<=2) return 0;\\n\\t\\t\\tint pre = nums[0]; // record the previous num \\n\\t\\t\\tint res = 0;\\n\\n\\t\\t\\tfor(int i=1; i<nums.length-1; ++i){\\n\\t\\t\\t\\tif(nums[i] == nums[i-1]) continue; // find a duplicate, which could be in the same hills or valley as the previous number, we just ignore \\n\\n\\t\\t\\t\\tint cur=nums[i]; // record current num \\n\\t\\t\\t\\tint next=nums[i+1];// record the next num \\n\\t\\t\\t\\tint j=i+1; \\n\\n\\t\\t\\t\\twhile(next==cur){ // if next == cur, we have to skip it \\n\\t\\t\\t\\t\\tj++;\\n\\t\\t\\t\\t\\tif(j>nums.length-1)break; // if next > nums.length-1, we run out of number; \\n\\t\\t\\t\\t\\tnext = nums[j]; // we find a valid number \\n\\t\\t\\t\\t\\ti=j-1; // i should jump to the last duplicate number of cur \\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tif((pre<cur && cur>next) || (pre>cur && next>cur)){ // compute hills or valley \\n\\t\\t\\t\\t\\tres++;\\n\\t\\t\\t\\t} \\n\\t\\t\\t\\tpre = cur; // relocate pre \\n\\t\\t\\t}\\n\\t\\t\\treturn res; \\n\\t\\t}\\n\\t}\\n\\n\\t// time O(n)\\n\\t// space O(1)",
                "solutionTags": [],
                "code": "class Solution {\\n\\t\\tpublic int countHillValley(int[] nums) {\\n\\t\\t\\tif(nums.length<=2) return 0;\\n\\t\\t\\tint pre = nums[0]; // record the previous num \\n\\t\\t\\tint res = 0;\\n\\n\\t\\t\\tfor(int i=1; i<nums.length-1; ++i){\\n\\t\\t\\t\\tif(nums[i] == nums[i-1]) continue; // find a duplicate, which could be in the same hills or valley as the previous number, we just ignore \\n\\n\\t\\t\\t\\tint cur=nums[i]; // record current num \\n\\t\\t\\t\\tint next=nums[i+1];// record the next num \\n\\t\\t\\t\\tint j=i+1; \\n\\n\\t\\t\\t\\twhile(next==cur){ // if next == cur, we have to skip it \\n\\t\\t\\t\\t\\tj++;\\n\\t\\t\\t\\t\\tif(j>nums.length-1)break; // if next > nums.length-1, we run out of number; \\n\\t\\t\\t\\t\\tnext = nums[j]; // we find a valid number \\n\\t\\t\\t\\t\\ti=j-1; // i should jump to the last duplicate number of cur \\n\\t\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 2501526,
                "title": "easy-fast-solution",
                "content": "```\\nPLEASE UPVOTE IF YOU LIKE\\n```\\n```\\n    public int countHillValley(int[] nums) {\\n        int len = nums.length - 1;\\n        int temp = nums[0];\\n        int count = 0;\\n\\t\\t\\n        for (int i = 1; i < len; i++) {\\n            while (i < len && nums[i] == nums[i+1]) i++;\\n            if (i < len && isHillsOrValleys(temp, nums[i], nums[i+1])) count++;\\n            temp = nums[i];\\n        }\\n        return count;\\n    }\\n    \\n    private boolean isHillsOrValleys(int left, int mid, int right){\\n        return (left > mid && mid < right) || (left < mid && mid > right);\\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nPLEASE UPVOTE IF YOU LIKE\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2461987,
                "title": "java-solution-1ms-runtime-easy-to-understand",
                "content": "```\\nclass Solution {\\n    public int countHillValley(int[] arr) {\\n        int cnt = 0;\\n        for (int i = 1; i < arr.length - 1; i++) {\\n            if (arr[i] == arr[i-1]) continue;\\n            if (arr[i] == arr[i+1]) {\\n                int right = getRight(arr, i), left = getLeft(arr, i);\\n                if (right == -1 || left == -1) continue;\\n                if (left > arr[i]) {\\n                    if (arr[i] < right) cnt++;\\n                }\\n                else if (left < arr[i]) {\\n                    if (arr[i] > right) cnt++;\\n                }\\n            }\\n            else if (arr[i-1] > arr[i]) {\\n                if (arr[i] < arr[i+1]) cnt++;\\n            }\\n            else if (arr[i-1] < arr[i]) {\\n                if (arr[i] > arr[i+1]) cnt++;\\n            }\\n        }\\n        return cnt;\\n    }\\n\\n    private static int getLeft(int[] arr, int i) {\\n        for (int k = i-1; k >= 0; k--) {\\n            if (arr[i] != arr[k]) return arr[k];\\n        }\\n        return -1;\\n    }\\n\\n    private static int getRight(int[] arr, int i) {\\n        for (int k = i+1; k < arr.length; k++){\\n            if (arr[i] != arr[k]) return arr[k];\\n        }\\n        return -1;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int countHillValley(int[] arr) {\\n        int cnt = 0;\\n        for (int i = 1; i < arr.length - 1; i++) {\\n            if (arr[i] == arr[i-1]) continue;\\n            if (arr[i] == arr[i+1]) {\\n                int right = getRight(arr, i), left = getLeft(arr, i);\\n                if (right == -1 || left == -1) continue;\\n                if (left > arr[i]) {\\n                    if (arr[i] < right) cnt++;\\n                }\\n                else if (left < arr[i]) {\\n                    if (arr[i] > right) cnt++;\\n                }\\n            }\\n            else if (arr[i-1] > arr[i]) {\\n                if (arr[i] < arr[i+1]) cnt++;\\n            }\\n            else if (arr[i-1] < arr[i]) {\\n                if (arr[i] > arr[i+1]) cnt++;\\n            }\\n        }\\n        return cnt;\\n    }\\n\\n    private static int getLeft(int[] arr, int i) {\\n        for (int k = i-1; k >= 0; k--) {\\n            if (arr[i] != arr[k]) return arr[k];\\n        }\\n        return -1;\\n    }\\n\\n    private static int getRight(int[] arr, int i) {\\n        for (int k = i+1; k < arr.length; k++){\\n            if (arr[i] != arr[k]) return arr[k];\\n        }\\n        return -1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2435109,
                "title": "q2210-accepted-c-sol-using-two-methods-easy-simple",
                "content": "Solution 1 Using Vector Extra Space\\n```\\nclass Solution {\\npublic:\\n    int countHillValley(vector<int>& nums) {\\n        int n=nums.size();\\n        int j=0;\\n        int a=0;\\n        for(int i=1;i<n-1;i++){\\n            if((nums[i]>nums[j] && nums[i]>nums[i+1])|| \\n               (nums[j]>nums[i] && nums[i]<nums[i+1])){\\n                a++;\\n                j=i;\\n            }\\n        }\\n        return a;\\n    }\\n};\\n```\\nSolution 2 Using Two Pointer Approach\\n```\\nclass Solution {\\npublic:\\n    int countHillValley(vector<int>& nums) {\\n        int n=nums.size();\\n        vector <int> v;\\n        v.push_back(nums[0]);\\n        for(int i=1;i<n;i++)\\n            if(nums[i]!=nums[i-1])\\n                v.push_back(nums[i]);\\n        int a=0;\\n        for(int i=1;i<v.size()-1;i++){\\n            if((v[i]>v[i-1] && v[i]>v[i+1])||(v[i]<v[i-1] && v[i]<v[i+1]))\\n                a++;\\n        }\\n        return a;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int countHillValley(vector<int>& nums) {\\n        int n=nums.size();\\n        int j=0;\\n        int a=0;\\n        for(int i=1;i<n-1;i++){\\n            if((nums[i]>nums[j] && nums[i]>nums[i+1])|| \\n               (nums[j]>nums[i] && nums[i]<nums[i+1])){\\n                a++;\\n                j=i;\\n            }\\n        }\\n        return a;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int countHillValley(vector<int>& nums) {\\n        int n=nums.size();\\n        vector <int> v;\\n        v.push_back(nums[0]);\\n        for(int i=1;i<n;i++)\\n            if(nums[i]!=nums[i-1])\\n                v.push_back(nums[i]);\\n        int a=0;\\n        for(int i=1;i<v.size()-1;i++){\\n            if((v[i]>v[i-1] && v[i]>v[i+1])||(v[i]<v[i-1] && v[i]<v[i+1]))\\n                a++;\\n        }\\n        return a;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2411775,
                "title": "java-easy-one",
                "content": "```\\nclass Solution {\\n    public int countHillValley(int[] nums) {\\n        int c=0;\\n        for(int i=1;i<nums.length;i++){\\n            int l=i-1;\\n            int r=i+1;\\n            while(l>=0 && nums[l]==nums[i]) l--;\\n            while(r<nums.length && nums[r]==nums[i]) r++;\\n            if(l<0 || r>=nums.length) continue;\\n            if(nums[i]==nums[i+1]) continue;\\n            if(nums[i]>nums[l] && nums[i]>nums[r]) c++;\\n            if(nums[i]<nums[l] && nums[i]<nums[r]) c++;\\n        }\\n        return c;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int countHillValley(int[] nums) {\\n        int c=0;\\n        for(int i=1;i<nums.length;i++){\\n            int l=i-1;\\n            int r=i+1;\\n            while(l>=0 && nums[l]==nums[i]) l--;\\n            while(r<nums.length && nums[r]==nums[i]) r++;\\n            if(l<0 || r>=nums.length) continue;\\n            if(nums[i]==nums[i+1]) continue;\\n            if(nums[i]>nums[l] && nums[i]>nums[r]) c++;\\n            if(nums[i]<nums[l] && nums[i]<nums[r]) c++;\\n        }\\n        return c;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2316611,
                "title": "simple-traverse-c",
                "content": "**Code :**\\n\\n```\\nclass Solution {\\npublic:\\n    int countHillValley(vector<int>& nums) {\\n        int n = nums.size();\\n        int last = nums[0];\\n        int hills = 0 , valleys = 0;\\n        \\n        for(int i=1; i<n-1; i++){\\n            if(nums[i]==last){\\n                last = nums[i];\\n                continue;\\n            }\\n            \\n            if(nums[i]>last && nums[i]>nums[i+1])\\n                hills++ , last = nums[i];\\n            else if(nums[i]<last && nums[i]<nums[i+1])\\n                valleys++ , last = nums[i];\\n            \\n        }\\n        \\n        return hills+valleys;\\n    }\\n};\\n```\\n\\nThank You!",
                "solutionTags": [
                    "C",
                    "Array"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int countHillValley(vector<int>& nums) {\\n        int n = nums.size();\\n        int last = nums[0];\\n        int hills = 0 , valleys = 0;\\n        \\n        for(int i=1; i<n-1; i++){\\n            if(nums[i]==last){\\n                last = nums[i];\\n                continue;\\n            }\\n            \\n            if(nums[i]>last && nums[i]>nums[i+1])\\n                hills++ , last = nums[i];\\n            else if(nums[i]<last && nums[i]<nums[i+1])\\n                valleys++ , last = nums[i];\\n            \\n        }\\n        \\n        return hills+valleys;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2279305,
                "title": "easy-java-solution-o-n",
                "content": "```\\nclass Solution {\\n    public int countHillValley(int[] nums) {\\n        int count=0;\\n        int prev=nums[0];\\n        \\n        for(int i=1;i<nums.length-1;i++){\\n            if(nums[i]>prev && nums[i]>nums[i+1] || nums[i]<prev && nums[i]<nums[i+1]){\\n                count++;\\n                prev=nums[i];\\n            }\\n        }\\n        return count;\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int countHillValley(int[] nums) {\\n        int count=0;\\n        int prev=nums[0];\\n        \\n        for(int i=1;i<nums.length-1;i++){\\n            if(nums[i]>prev && nums[i]>nums[i+1] || nums[i]<prev && nums[i]<nums[i+1]){\\n                count++;\\n                prev=nums[i];\\n            }\\n        }\\n        return count;\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2242017,
                "title": "java-1-ms-o-n-explained",
                "content": "**The Idea:\\n~ - ~ - ~ -**\\n\\nCreate a \"slopes\" array, in the following manner --->\\n**The first identical digits in nums, will be noted as -1 in the slopes array.**\\nWhen digit is greater than the previous, the \"slope\" will be noted as **1**.\\nWhen digit is smaller than the previous, the \"slope\" will be noted as **0**.\\nWhen digit is equals to the previous, the \"slope\" will be noted **as the previous slope.**\\n\\nThe trick is to count how many times the slope changes, **as long as it not equlas -1.**\\n(Meaning ---> we ignore the beginning).\\n\\nExample:\\n~ - ~ - ~ -\\n\\nArray: >>>>>>>>>>>>>>>>>>>>>>>>>> { 1, 1, 1,  1, 1, 1, 1, 57, 57, 57, 50, 50, 50, 50, 22, 22, 22, 86 }\\nIts corresponding slopes array would be: { -1, -1,-1,-1,-1,-1,-1 ,1   ,1,   1  **(x)**  ,0   ,0  ,0    ,0   ,0   ,0   ,0  **(x)** ,1 }\\nNumber of slope changes (each change designated with x) is **2**.\\n\\nMore examples:\\n~ - ~ - ~ - ~ - ~ -\\n\\n{  6,  5,     10 }\\n{ -1,  0, **(x)** 1 }\\nNumber of slope changes (each change designated with x) is **1**.\\n\\n{ 8, 2,      5, 7, 7,       2,    10,      3,      6,      2}\\n{-1, 0, **(x)** 1, 1, 1, **(x)** 0, **(x)** 1, **(x)** 0, **(x)** 1, **(x)** 0}\\nNumber of slope changes (each change designated with x) is **6**.\\n\\n { 6, 6, 5, 5, 4, 1 }\\n {-1,-1, 0, 0, 0, 0 }\\nNumber of slope changes (each change designated with x) is **0**.\\n\\n{  2, 4,      1, 1,       6,      5 }\\n{ -1, 1, **(x)** 0, 0, **(x)** 1, **(x)** 0 }\\nNumber of slope changes (each change designated with x) is **3**.\\n\\n    public int countHillValley(int[] nums) {\\n        int counter = 0, previous = -1;\\n        int[] slopes = new int[nums.length];\\n        slopes[0] = -1;\\n\\n        if (nums[0] < nums[1]) slopes[1] = 1;\\n        else if (nums[0] > nums[1]) slopes[1] = 0;\\n        else slopes[1] = -1;\\n\\n        for (int i = 2; i < nums.length; i++)\\n            if (nums[i] == nums[i - 1]) slopes[i] = slopes[i - 1];\\n            else if (nums[i] > nums[i - 1]) slopes[i] = 1;\\n            else slopes[i] = 0;\\n\\n        for (int i = 1; i < slopes.length; i++) {\\n            if (previous != -1 && slopes[i] != previous)\\n                counter++;\\n\\n            previous = slopes[i];\\n        }\\n\\n        return counter;\\n    }\\n\\nPlease **upvote** if you liked to solution :)",
                "solutionTags": [
                    "Java"
                ],
                "code": "**The Idea:\\n~ - ~ - ~ -**\\n\\nCreate a \"slopes\" array, in the following manner --->\\n**The first identical digits in nums, will be noted as -1 in the slopes array.**\\nWhen digit is greater than the previous, the \"slope\" will be noted as **1**.\\nWhen digit is smaller than the previous, the \"slope\" will be noted as **0**.\\nWhen digit is equals to the previous, the \"slope\" will be noted **as the previous slope.**\\n\\nThe trick is to count how many times the slope changes, **as long as it not equlas -1.**\\n(Meaning ---> we ignore the beginning).\\n\\nExample:\\n~ - ~ - ~ -\\n\\nArray: >>>>>>>>>>>>>>>>>>>>>>>>>> { 1, 1, 1,  1, 1, 1, 1, 57, 57, 57, 50, 50, 50, 50, 22, 22, 22, 86 }\\nIts corresponding slopes array would be: { -1, -1,-1,-1,-1,-1,-1 ,1   ,1,   1  **(x)**  ,0   ,0  ,0    ,0   ,0   ,0   ,0  **(x)** ,1 }\\nNumber of slope changes (each change designated with x) is **2**.\\n\\nMore examples:\\n~ - ~ - ~ - ~ - ~ -\\n\\n{  6,  5,     10 }\\n{ -1,  0, **(x)** 1 }\\nNumber of slope changes (each change designated with x) is **1**.\\n\\n{ 8, 2,      5, 7, 7,       2,    10,      3,      6,      2}\\n{-1, 0, **(x)** 1, 1, 1, **(x)** 0, **(x)** 1, **(x)** 0, **(x)** 1, **(x)** 0}\\nNumber of slope changes (each change designated with x) is **6**.\\n\\n { 6, 6, 5, 5, 4, 1 }\\n {-1,-1, 0, 0, 0, 0 }\\nNumber of slope changes (each change designated with x) is **0**.\\n\\n{  2, 4,      1, 1,       6,      5 }\\n{ -1, 1, **(x)** 0, 0, **(x)** 1, **(x)** 0 }\\nNumber of slope changes (each change designated with x) is **3**.\\n\\n    public int countHillValley(int[] nums) {\\n        int counter = 0, previous = -1;\\n        int[] slopes = new int[nums.length];\\n        slopes[0] = -1;\\n\\n        if (nums[0] < nums[1]) slopes[1] = 1;\\n        else if (nums[0] > nums[1]) slopes[1] = 0;\\n        else slopes[1] = -1;\\n\\n        for (int i = 2; i < nums.length; i++)\\n            if (nums[i] == nums[i - 1]) slopes[i] = slopes[i - 1];\\n            else if (nums[i] > nums[i - 1]) slopes[i] = 1;\\n            else slopes[i] = 0;\\n\\n        for (int i = 1; i < slopes.length; i++) {\\n            if (previous != -1 && slopes[i] != previous)\\n                counter++;\\n\\n            previous = slopes[i];\\n        }\\n\\n        return counter;\\n    }\\n\\nPlease **upvote** if you liked to solution :)",
                "codeTag": "Unknown"
            },
            {
                "id": 2167204,
                "title": "python-lists-very-easy-to-follow",
                "content": "```\\n def countHillValley(self, nums: List[int]) -> int:\\n        nn=nums.copy()\\n        i = 1\\n        while i < len(nn) and len(nn) > 0:\\n            if nn[i] == nn[i-1]:\\n                nn.pop(i)\\n            else:\\n                i+=1\\n                   \\n        i = 1\\n        count = 0\\n        while i < len(nn)-1:\\n            if nn[i] > nn[i-1] and nn[i] > nn[i+1]:                \\n                count+= 1\\n                i+=1\\n            elif nn[i] < nn[i-1] and nn[i] < nn[i+1]:                \\n                count+= 1\\n                i+=1           \\n            else:                \\n                i+=1\\n                \\n        \\n        return count",
                "solutionTags": [],
                "code": "```\\n def countHillValley(self, nums: List[int]) -> int:\\n        nn=nums.copy()\\n        i = 1\\n        while i < len(nn) and len(nn) > 0:\\n            if nn[i] == nn[i-1]:\\n                nn.pop(i)\\n            else:\\n                i+=1\\n                   \\n        i = 1\\n        count = 0\\n        while i < len(nn)-1:\\n            if nn[i] > nn[i-1] and nn[i] > nn[i+1]:                \\n                count+= 1\\n                i+=1\\n            elif nn[i] < nn[i-1] and nn[i] < nn[i+1]:                \\n                count+= 1\\n                i+=1           \\n            else:                \\n                i+=1\\n                \\n        \\n        return count",
                "codeTag": "Python3"
            },
            {
                "id": 2136198,
                "title": "explained-with-comments-no-extra-space-easy-to-understand-c",
                "content": "**A VERY EASY WAY TO HANDLE DUPLICATES IS TO REPLACE FIRST DUPLICATE WITH IT\\'S PREVIOUS ELEMENT THUS TENDING TO NORMAL CASE!**\\n```\\n  int countHillValley(vector<int>& nums) {\\n        int hv=0;   //hv for total number of hills and valley\\n        int mid=1;     //will do start from index 1 as no need to check for 0th index\\n        while(mid<(nums.size()-1))   //will end with size-2 because last element does not make a hill or valley\\n        {\\n            if((nums[mid]>nums[mid-1] && nums[mid]>nums[mid+1]) || (nums[mid]<nums[mid-1] && nums[mid]<nums[mid+1])) //just put conditions over there for hills and valley\\n                hv++;\\n            else{\\n                if(nums[mid]==nums[mid+1])     //for same element \\n                   nums[mid]= nums[mid-1];       //updating duplicate element with its previous one\\n                }   \\n            mid++;\\n        }\\n        return hv;\\n    }\\n\\t```\\n\\t**PLEASE DO UPVOTE IF YOU UNDERSTAND THE SOLUTION**",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n  int countHillValley(vector<int>& nums) {\\n        int hv=0;   //hv for total number of hills and valley\\n        int mid=1;     //will do start from index 1 as no need to check for 0th index\\n        while(mid<(nums.size()-1))   //will end with size-2 because last element does not make a hill or valley\\n        {\\n            if((nums[mid]>nums[mid-1] && nums[mid]>nums[mid+1]) || (nums[mid]<nums[mid-1] && nums[mid]<nums[mid+1])) //just put conditions over there for hills and valley\\n                hv++;\\n            else{\\n                if(nums[mid]==nums[mid+1])     //for same element \\n                   nums[mid]= nums[mid-1];       //updating duplicate element with its previous one\\n                }   \\n            mid++;\\n        }\\n        return hv;\\n    }\\n\\t```",
                "codeTag": "Unknown"
            },
            {
                "id": 2064402,
                "title": "java-1ms-alternative-solution",
                "content": "```\\nclass Solution {\\n    /** Algorithm\\n        1. For each index 1 .. n-2 try to expand a search window with 2 indexes: left and right.\\n        2. while (i >= 0 and nums[left] == nums[i]) left--;\\n           while (right < nums.length and nums[right] == nums[i]) right++;\\n           EG: [3,1,1,1,1,17];\\n             #1 step 1 will start from index 1\\n             #2 a. first while will stop at 3 since it\\'s the first index != nums[1]\\n                b. second while will stop at 17 since it\\'s the first index != nums[i];\\n        3. If right >= nums.length break immediately as all the numbers are equal and no hill/valley can exist\\n        4. If left >= 0, check if you have a valley or hill between nums[left], nums[i], nums[right].\\n           If yes, increment the count\\n        5. Our index will be updated with the right index, as this is the first non equal i index. \\n           Everything between i and right will be part of the same hill or valley.\\n    */\\n    public int countHillValley(int[] nums) {\\n        int hillsAndValleys = 0;\\n        int i = 0;\\n        int left, right;\\n        while (i < nums.length -1) {\\n            left = i -1;\\n            right = i +1;\\n            while(left >= 0 && nums[left] == nums[i]) {\\n                left--;\\n            }\\n            while(right < nums.length && nums[right] == nums[i]) {\\n                right++;\\n            }\\n            if (right == nums.length) {\\n                break;\\n            }\\n            if (left >= 0) {\\n                if ((nums[left] < nums[i] && nums[i] > nums[right]) || \\n                    (nums[left] > nums[i] && nums[i] < nums[right])) {\\n                    hillsAndValleys++;\\n                }\\n            }\\n            i = right;\\n        }\\n        return hillsAndValleys;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    /** Algorithm\\n        1. For each index 1 .. n-2 try to expand a search window with 2 indexes: left and right.\\n        2. while (i >= 0 and nums[left] == nums[i]) left--;\\n           while (right < nums.length and nums[right] == nums[i]) right++;\\n           EG: [3,1,1,1,1,17];\\n             #1 step 1 will start from index 1\\n             #2 a. first while will stop at 3 since it\\'s the first index != nums[1]\\n                b. second while will stop at 17 since it\\'s the first index != nums[i];\\n        3. If right >= nums.length break immediately as all the numbers are equal and no hill/valley can exist\\n        4. If left >= 0, check if you have a valley or hill between nums[left], nums[i], nums[right].\\n           If yes, increment the count\\n        5. Our index will be updated with the right index, as this is the first non equal i index. \\n           Everything between i and right will be part of the same hill or valley.\\n    */\\n    public int countHillValley(int[] nums) {\\n        int hillsAndValleys = 0;\\n        int i = 0;\\n        int left, right;\\n        while (i < nums.length -1) {\\n            left = i -1;\\n            right = i +1;\\n            while(left >= 0 && nums[left] == nums[i]) {\\n                left--;\\n            }\\n            while(right < nums.length && nums[right] == nums[i]) {\\n                right++;\\n            }\\n            if (right == nums.length) {\\n                break;\\n            }\\n            if (left >= 0) {\\n                if ((nums[left] < nums[i] && nums[i] > nums[right]) || \\n                    (nums[left] > nums[i] && nums[i] < nums[right])) {\\n                    hillsAndValleys++;\\n                }\\n            }\\n            i = right;\\n        }\\n        return hillsAndValleys;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2061606,
                "title": "approach-using-3-pointers-basic-level-logic-beats-100-submissions-0ms",
                "content": "Basic approach: \\nPointers:\\nInitially, \\'prev\\' will point to 0th index\\n\\'current\\' will point to first index, \\n\\'next\\' will point to second index,\\n\\'count\\' to count hills & valleys\\n\\nLoop till your \\'next\\' reached last index.\\n\\n* (EQUAL NEIGHBOURS) check if your values in current is same as next, if yes , move \\'current\\' and \\'next\\' to +1 index and skip the iteration using continue;\\n* (NON EQUAL NEIGHBOURS-VALLEY) If your current value is less than both \\'prev\\' and \\'next\\', increase your count+1\\n* (NON EQUAL NEIGHBOURS-HILL) If your current value is greater than both \\'prev\\' and \\'next\\', increase your count+1\\n* Finally, make \\'prev\\' index to current, \\'current\\' index to next, and increase next+1; \\n\\nNOTE: You can reduce your space complexity by using i+1 instead of defining \\'next\\', but then you have to make amendments to your algorithm. \\n\\n```\\nclass Solution {\\n    public int countHillValley(int[] nums) {\\n        int count=0;\\n        int prev=0;\\n        int next=2;\\n        int current=1;\\n        while(next<nums.length)\\n        {\\n            if(nums[current]==nums[next])\\n            {  \\n             current+=1;next+=1;\\n             continue;\\n            }\\n            \\n            else\\n            {    \\n            if(nums[prev]>nums[current] && nums[next]>nums[current])\\n            {   \\n                count++;\\n                \\n            }\\n            else if(nums[prev]<nums[curent] && nums[next]<nums[current])\\n            {   \\n                count++; \\n             }\\n            }\\n            prev=current;current=next;next++;\\n            \\n            \\n        }\\n        return(count);\\n        \\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int countHillValley(int[] nums) {\\n        int count=0;\\n        int prev=0;\\n        int next=2;\\n        int current=1;\\n        while(next<nums.length)\\n        {\\n            if(nums[current]==nums[next])\\n            {  \\n             current+=1;next+=1;\\n             continue;\\n            }\\n            \\n            else\\n            {    \\n            if(nums[prev]>nums[current] && nums[next]>nums[current])\\n            {   \\n                count++;\\n                \\n            }\\n            else if(nums[prev]<nums[curent] && nums[next]<nums[current])\\n            {   \\n                count++; \\n             }\\n            }\\n            prev=current;current=next;next++;\\n            \\n            \\n        }\\n        return(count);\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2046453,
                "title": "java-0ms-beats-100-dp-approach-with-three-variables",
                "content": "My dynamic programming approach used three values (`left`, `mid`, and `right`) to track the elevation values in the array. `right` represented the current array value, and `mid` and `left` were updated as appropriate to reflect the previous elevation trend. \\n\\n<table>\\n<tr ><th>`left`</th><th>`mid`</th><th>`right`</th><th>Value Diagram</th><th>Meaning</th></tr>\\n<tr><td>low</td><td>high</td><td>low</td><td style=\"text-align: center;\">__\\u203E\\u203E__</td><td>hill</td></tr>\\n<tr><td>high</td><td>low</td><td>high</td><td style=\"text-align: center;\">\\u203E\\u203E__\\u203E\\u203E</td><td>valley</td></tr>\\n<tr><td>low</td><td>equal or lower than `left`</td><td>equal or lower than `mid`</td><td style=\"text-align: center;\">\\u203E\\u203E\\u23AF__</td><td>non-increasing trend</td></tr>\\n<tr><td>high</td><td>equal or higher than `left`</td><td>equal or higher than `mid`</td><td style=\"text-align: center;\">__\\u23AF\\u203E\\u203E</td><td>non-decreasing trend</td></tr>\\n</table>\\n\\n```\\n/*\\nRuntime: 0 ms, faster than 100.00% of Java online submissions for Count Hills and Valleys in an Array.\\nMemory Usage: 40.2 MB, less than 93.01% of Java online submissions for Count Hills and Valleys in an Array.\\nElapsed dev time: 0h:24m\\n*/\\n\\nclass Solution {\\n    public int countHillValley(int[] nums) {\\n        \\n        int numHillsValleys = 0;  // what we\\'ll return\\n        \\n        int left = nums[0];\\n        int mid = nums[0];\\n        int right = nums[0];\\n        \\n        for (int i = 0; i < nums.length; ++i) {\\n            \\n            right = nums[i];\\n            \\n            // case: found valley\\n            if (left > mid && mid < right) {\\n                ++numHillsValleys;\\n                left = mid;\\n                mid = right;\\n            }\\n            // case: on non-increasing slope\\n            if (left >= mid && mid >= right) {\\n                mid = right;  // update mid\\n            }\\n            // case: found hill\\n            if (left < mid && mid > right) {\\n                ++numHillsValleys;\\n                left = mid;\\n                mid = right;\\n            }\\n            // case: on non-decreasing slope\\n            if (left <= mid && mid <= right) {\\n                mid = right;  // update mid\\n            }\\n        }\\n        \\n        return numHillsValleys;\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "```\\n/*\\nRuntime: 0 ms, faster than 100.00% of Java online submissions for Count Hills and Valleys in an Array.\\nMemory Usage: 40.2 MB, less than 93.01% of Java online submissions for Count Hills and Valleys in an Array.\\nElapsed dev time: 0h:24m\\n*/\\n\\nclass Solution {\\n    public int countHillValley(int[] nums) {\\n        \\n        int numHillsValleys = 0;  // what we\\'ll return\\n        \\n        int left = nums[0];\\n        int mid = nums[0];\\n        int right = nums[0];\\n        \\n        for (int i = 0; i < nums.length; ++i) {\\n            \\n            right = nums[i];\\n            \\n            // case: found valley\\n            if (left > mid && mid < right) {\\n                ++numHillsValleys;\\n                left = mid;\\n                mid = right;\\n            }\\n            // case: on non-increasing slope\\n            if (left >= mid && mid >= right) {\\n                mid = right;  // update mid\\n            }\\n            // case: found hill\\n            if (left < mid && mid > right) {\\n                ++numHillsValleys;\\n                left = mid;\\n                mid = right;\\n            }\\n            // case: on non-decreasing slope\\n            if (left <= mid && mid <= right) {\\n                mid = right;  // update mid\\n            }\\n        }\\n        \\n        return numHillsValleys;\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1989771,
                "title": "c-easy-o-n-solution-with-full-explanation",
                "content": "Hey all..\\nI have solved this using 3 Methods in cpp using two pointers and basic traversing and counting.\\nI have commented in the code so that it can be useful..\\nIf you have any doubts be free to ask..\\nand please upvote if you understood or found it useful :)\\n\\nThank you..\\n```\\n// Method 1:- Removing adjacent duplicates and finding.\\nclass Solution {\\npublic:\\n    int countHillValley(vector<int>& nums) {\\n        int count=0,n=nums.size();\\n\\t\\t// Creating a new vector to store elements with no adjacency duplicates.\\n        vector<int> ans;\\n\\t\\t\\n\\t\\t//Traversing vector to remove adjacent duplicates.\\n        for(int i=0;i<n-1;i++){\\n            if(nums[i]!=nums[i+1]){\\n                ans.push_back(nums[i]);\\n            }\\n        }\\n\\t\\t// Adding last element because it was missing in the traversal.\\n        if(nums[n-2]!=nums[n-1]){\\n            ans.push_back(nums[n-1]);\\n        }\\n        \\n\\t\\t//If new vector formed has no elements means its monotonic(Increasing or decreasing or all elements are same)\\n        int l=ans.size();\\n        if(l==0 or l==1){\\n            return 0;\\n        }\\n\\t\\t\\n\\t\\t//This is to just check normally any valley or hill appears in new vector and incrementing every time we get it.\\n        for(int i=1;i<ans.size()-1;i++){\\n            if(ans[i]<ans[i-1] and ans[i]<ans[i+1]){\\n                count++;\\n                continue;\\n            }\\n            if(ans[i]>ans[i-1] and ans[i]>ans[i+1]){\\n                count++;\\n                continue;\\n            }\\n        }\\n        return count;\\n\\n\\n// Method 2:- Same as method 1,but tricky one..\\n           int hills =0;\\n           int valleys = 0;\\n           for(int i=1;i<nums.size()-1;i++){\\n               if(nums[i-1]<nums[i] && nums[i]>nums[i+1])\\n                   hills++;\\n               else if(nums[i-1]>nums[i] && nums[i]<nums[i+1])\\n                   valleys++;\\n\\t\\t\\t  // Same above method,but in this if we find any adjacent duplicates,we just replace first duplicate one by its previous element.\\n              else nums[i]=nums[i-1];\\n           }\\n           return hills+valleys;\\n        \\n// Method 3 :- Two pointers\\n      int countHillValley(vector<int>& nums) {\\n           int count = 0;\\n           for (int i = 1, j = 0; i < nums.size() - 1; ++i)\\n           if ((nums[j] < nums[i] && nums[i] > nums [i + 1]) || \\n               (nums[j] > nums[i] && nums[i] < nums [i + 1])) {\\n               ++count;\\n               j = i;\\n           }            \\n           return count;\\n          }\\n \\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Two Pointers"
                ],
                "code": "```\\n// Method 1:- Removing adjacent duplicates and finding.\\nclass Solution {\\npublic:\\n    int countHillValley(vector<int>& nums) {\\n        int count=0,n=nums.size();\\n\\t\\t// Creating a new vector to store elements with no adjacency duplicates.\\n        vector<int> ans;\\n\\t\\t\\n\\t\\t//Traversing vector to remove adjacent duplicates.\\n        for(int i=0;i<n-1;i++){\\n            if(nums[i]!=nums[i+1]){\\n                ans.push_back(nums[i]);\\n            }\\n        }\\n\\t\\t// Adding last element because it was missing in the traversal.\\n        if(nums[n-2]!=nums[n-1]){\\n            ans.push_back(nums[n-1]);\\n        }\\n        \\n\\t\\t//If new vector formed has no elements means its monotonic(Increasing or decreasing or all elements are same)\\n        int l=ans.size();\\n        if(l==0 or l==1){\\n            return 0;\\n        }\\n\\t\\t\\n\\t\\t//This is to just check normally any valley or hill appears in new vector and incrementing every time we get it.\\n        for(int i=1;i<ans.size()-1;i++){\\n            if(ans[i]<ans[i-1] and ans[i]<ans[i+1]){\\n                count++;\\n                continue;\\n            }\\n            if(ans[i]>ans[i-1] and ans[i]>ans[i+1]){\\n                count++;\\n                continue;\\n            }\\n        }\\n        return count;\\n\\n\\n// Method 2:- Same as method 1,but tricky one..\\n           int hills =0;\\n           int valleys = 0;\\n           for(int i=1;i<nums.size()-1;i++){\\n               if(nums[i-1]<nums[i] && nums[i]>nums[i+1])\\n                   hills++;\\n               else if(nums[i-1]>nums[i] && nums[i]<nums[i+1])\\n                   valleys++;\\n\\t\\t\\t  // Same above method,but in this if we find any adjacent duplicates,we just replace first duplicate one by its previous element.\\n              else nums[i]=nums[i-1];\\n           }\\n           return hills+valleys;\\n        \\n// Method 3 :- Two pointers\\n      int countHillValley(vector<int>& nums) {\\n           int count = 0;\\n           for (int i = 1, j = 0; i < nums.size() - 1; ++i)\\n           if ((nums[j] < nums[i] && nums[i] > nums [i + 1]) || \\n               (nums[j] > nums[i] && nums[i] < nums [i + 1])) {\\n               ++count;\\n               j = i;\\n           }            \\n           return count;\\n          }\\n \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1976013,
                "title": "java-solution",
                "content": "```\\nclass Solution {\\n    public int countHillValley(int[] nums) {\\n        int count = 0;\\n        for(int i=1; i<nums.length-1; i++){\\n            int pre = i-1;\\n            if(nums[i] == nums[i+1]){\\n                while(nums[i]==nums[i+1] && i<nums.length-2){\\n                    i++;\\n                }\\n            }\\n            if((nums[i] > nums[pre] && nums[i] > nums[i+1]) || (nums[i] < nums[pre] && nums[i] < nums[i+1])){\\n                count++;\\n            }\\n        }\\n        return count;\\n    }\\n}",
                "solutionTags": [
                    "Java",
                    "Array"
                ],
                "code": "class Solution {\\n    public int countHillValley(int[] nums) {\\n        int count = 0;\\n        for(int i=1; i<nums.length-1; i++){\\n            int pre = i-1;\\n            if(nums[i] == nums[i+1]){\\n                while(nums[i]==nums[i+1] && i<nums.length-2){\\n                    i++;\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 1959470,
                "title": "simple-java-solution-with-comment-o-n-time-o-1-space",
                "content": "```\\nclass Solution {\\n    //balance will be 1 if hill and -1 if valley, and count will be updated based on the last balance value\\n    public int countHillValley(int[] nums) {\\n        int count = 0;\\n        int balance = 0;\\n        for(int i=1; i<nums.length; i++) {\\n            if(nums[i] > nums[i-1]) {\\n                if(balance == -1)\\n                    count++;\\n                balance = 1;\\n            }\\n            if(nums[i] < nums[i-1]) {\\n                if(balance == 1)\\n                    count++;\\n                balance = -1;\\n            }\\n        }\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    //balance will be 1 if hill and -1 if valley, and count will be updated based on the last balance value\\n    public int countHillValley(int[] nums) {\\n        int count = 0;\\n        int balance = 0;\\n        for(int i=1; i<nums.length; i++) {\\n            if(nums[i] > nums[i-1]) {\\n                if(balance == -1)\\n                    count++;\\n                balance = 1;\\n            }\\n            if(nums[i] < nums[i-1]) {\\n                if(balance == 1)\\n                    count++;\\n                balance = -1;\\n            }\\n        }\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1908197,
                "title": "python-linear-solution",
                "content": "Traverse the array\\'s internal elements (from ``1`` to ``n-1``) and maintaining previous and current values, and comparing to the next value. For the current skipping all values equal to current (since adjacent equal elements are parts pf the same hill or valley).\\n\\n```\\nclass Solution:\\n    def countHillValley(self, nums: List[int]) -> int:\\n        cnt = 0\\n        n = len(nums)\\n        prev = nums[0]\\n        i = 1\\n        while i < n-1:\\n            current = nums[i]\\n            while i < n-1 and nums[i] == nums[i+1]:\\n                i += 1\\n            if i >= n-1:\\n                break\\n            if current < prev and current < nums[i+1] or \\\\\\n               current > prev and current > nums[i+1]:\\n                cnt += 1\\n            prev = current\\n            i += 1\\n        return cnt\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def countHillValley(self, nums: List[int]) -> int:\\n        cnt = 0\\n        n = len(nums)\\n        prev = nums[0]\\n        i = 1\\n        while i < n-1:\\n            current = nums[i]\\n            while i < n-1 and nums[i] == nums[i+1]:\\n                i += 1\\n            if i >= n-1:\\n                break\\n            if current < prev and current < nums[i+1] or \\\\\\n               current > prev and current > nums[i+1]:\\n                cnt += 1\\n            prev = current\\n            i += 1\\n        return cnt\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1903461,
                "title": "easy-javascript",
                "content": "```\\nvar countHillValley = function(nums) {\\n    let arr=[];\\n    for(let i=0; i<nums.length; i++){\\n      if(nums[i]!==nums[i-1]){arr.push(nums[i]);}\\n    }\\n    let count=0;\\n    for(let i=1; i<arr.length-1; i++){\\n      if(arr[i-1]<arr[i] && arr[i+1]<arr[i]){count++;}\\n      else if(arr[i-1]>arr[i] && arr[i+1]>arr[i]){count++;}\\n    }\\n    return count; \\n}; \\n```",
                "solutionTags": [],
                "code": "```\\nvar countHillValley = function(nums) {\\n    let arr=[];\\n    for(let i=0; i<nums.length; i++){\\n      if(nums[i]!==nums[i-1]){arr.push(nums[i]);}\\n    }\\n    let count=0;\\n    for(let i=1; i<arr.length-1; i++){\\n      if(arr[i-1]<arr[i] && arr[i+1]<arr[i]){count++;}\\n      else if(arr[i-1]>arr[i] && arr[i+1]>arr[i]){count++;}\\n    }\\n    return count; \\n}; \\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1894612,
                "title": "2210-count-hills-and-valleys-in-an-array",
                "content": "```\\nclass Solution {\\npublic:\\n    int countHillValley(vector<int>& v) {\\n     \\n        int n = v.size();\\n        \\n        int c = 0;\\n        \\n        for(int i=1;i<n-1;i++){\\n            if(i!=1 && v[i]==v[i-1]) continue;\\n            \\n            int l = i-1 , h = i+1;\\n            \\n            while(l>=0 && v[l]==v[i]) l--;\\n            while(h<n  && v[h]==v[i]) h++;\\n            \\n            if(l<0 || h>=n) continue;\\n            \\n            if(v[i] > v[l] && v[i] > v[h]) c++;\\n            if(v[i] < v[l] && v[i] < v[h]) c++;\\n        }\\n        \\n        return c;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int countHillValley(vector<int>& v) {\\n     \\n        int n = v.size();\\n        \\n        int c = 0;\\n        \\n        for(int i=1;i<n-1;i++){\\n            if(i!=1 && v[i]==v[i-1]) continue;\\n            \\n            int l = i-1 , h = i+1;\\n            \\n            while(l>=0 && v[l]==v[i]) l--;\\n            while(h<n  && v[h]==v[i]) h++;\\n            \\n            if(l<0 || h>=n) continue;\\n            \\n            if(v[i] > v[l] && v[i] > v[h]) c++;\\n            if(v[i] < v[l] && v[i] < v[h]) c++;\\n        }\\n        \\n        return c;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1892793,
                "title": "java-1ms-solution-easy-to-understand",
                "content": "```\\nclass Solution {\\n    public int countHillValley(int[] nums) {\\n        int res=0;\\n        // left pointer will being updated only when is encountered with valley or hill\\n        // to solve the problem with adjent indices since they are the same part of hill or valley \\n       int left=nums[0];\\n        \\n        for(int i=1;i<nums.length-1;i++)\\n        {\\n          \\n            int right = nums[i+1];\\n            int curr = nums[i];\\n          \\n          \\n         \\n          \\n        if((curr>left && curr>right)||(curr<left && curr<right))\\n        {\\n              res++;\\n              left=nums[i];\\n        }\\n                  \\n      \\n        \\n            \\n\\n        }\\n        return res;\\n    }\\n}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    public int countHillValley(int[] nums) {\\n        int res=0;\\n        // left pointer will being updated only when is encountered with valley or hill\\n        // to solve the problem with adjent indices since they are the same part of hill or valley \\n       int left=nums[0];\\n        \\n        for(int i=1;i<nums.length-1;i++)\\n        {\\n          \\n            int right = nums[i+1];\\n            int curr = nums[i];\\n          \\n          \\n         \\n          \\n        if((curr>left && curr>right)||(curr<left && curr<right))\\n        {\\n              res++;\\n              left=nums[i];\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1888448,
                "title": "python-solution-o-n-linear-time-and-space-over-90-faster",
                "content": "First, obtain a new list containing the unique adjacent values only!\\nApply hill and valley checks on each element of new list!\\n```\\ndef countHillValley(self, nums: List[int]) -> int:\\n        uniqs = [nums[0]]\\n        for i in range(1,len(nums)):\\n            if nums[i] != nums[i-1]:\\n                uniqs.append(nums[i])\\n        print(uniqs)\\n        ans = 0\\n        for i in range(1,len(uniqs)-1):\\n            if uniqs[i] > uniqs[i-1] and uniqs[i] > uniqs[i+1]:\\n                # hill case\\n                ans += 1\\n            if uniqs[i] < uniqs[i-1] and uniqs[i] < uniqs[i+1]:\\n                # valley case\\n                ans += 1\\n        return ans\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\ndef countHillValley(self, nums: List[int]) -> int:\\n        uniqs = [nums[0]]\\n        for i in range(1,len(nums)):\\n            if nums[i] != nums[i-1]:\\n                uniqs.append(nums[i])\\n        print(uniqs)\\n        ans = 0\\n        for i in range(1,len(uniqs)-1):\\n            if uniqs[i] > uniqs[i-1] and uniqs[i] > uniqs[i+1]:\\n                # hill case\\n                ans += 1\\n            if uniqs[i] < uniqs[i-1] and uniqs[i] < uniqs[i+1]:\\n                # valley case\\n                ans += 1\\n        return ans\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1886080,
                "title": "python-one-pass-o-n-time-o-1-space",
                "content": "**Algorithm Details**\\n* Keep track of previous potential hill/valley\\n* If flat surface i.e equal elements keep incrementing\\n* Check if new unequal element is same as before or not, if yes increment count\\n\\n```\\nclass Solution:\\n    def countHillValley(self, nums: List[int]) -> int:\\n        prev = None; cnt = 0\\n        for i in range(len(nums)):\\n            while i < len(nums) - 1 and nums[i+1] == nums[i]:\\n                i += 1\\n            \\n\\t\\t\\t# edge case 1: end of array\\n            if i+1 >= len(nums):\\n                break\\n            \\n\\t\\t\\t#edge case 2: start of array\\n            if prev == None:\\n                prev = nums[i]\\n                continue\\n            \\n            if ( prev > nums[i] and nums[i+1] > nums[i] ) or ( prev < nums[i] and nums[i+1] < nums[i] ):\\n                cnt += 1\\n                \\n            prev = nums[i]\\n            \\n        return cnt\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def countHillValley(self, nums: List[int]) -> int:\\n        prev = None; cnt = 0\\n        for i in range(len(nums)):\\n            while i < len(nums) - 1 and nums[i+1] == nums[i]:\\n                i += 1\\n            \\n\\t\\t\\t# edge case 1: end of array\\n            if i+1 >= len(nums):\\n                break\\n            \\n\\t\\t\\t#edge case 2: start of array\\n            if prev == None:\\n                prev = nums[i]\\n                continue\\n            \\n            if ( prev > nums[i] and nums[i+1] > nums[i] ) or ( prev < nums[i] and nums[i+1] < nums[i] ):\\n                cnt += 1\\n                \\n            prev = nums[i]\\n            \\n        return cnt\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1883086,
                "title": "count-hills-and-valleys-in-an-array",
                "content": "int countHillValley(vector<int>& nums) {\\n        int count=0,n=nums.size();\\n        for(int i=1;i<n-1;i++){\\n           \\n            if(nums[i]==nums[i-1]){\\n                continue;\\n            }\\n             int j=i-1,k=i+1;\\n            \\n            while(k<n && nums[i]==nums[k]){\\n                k++;\\n            }\\n            \\n            while(j>=0 && nums[i]==nums[j]){\\n                j--;\\n            }\\n            \\n            if(k>=n || j<0){\\n                continue;\\n            }\\n            \\n            if(nums[i]>nums[k] && nums[i]>nums[j]){\\n                count++;\\n            }\\n            else if(nums[i]<nums[k] && nums[i]<nums[j]){\\n                count++;\\n            }\\n            \\n        }\\n        return count;\\n    }",
                "solutionTags": [
                    "C"
                ],
                "code": "int countHillValley(vector<int>& nums) {\\n        int count=0,n=nums.size();\\n        for(int i=1;i<n-1;i++){\\n           \\n            if(nums[i]==nums[i-1]){\\n                continue;\\n            }\\n             int j=i-1,k=i+1;\\n            \\n            while(k<n && nums[i]==nums[k]){\\n                k++;\\n            }\\n            \\n            while(j>=0 && nums[i]==nums[j]){\\n                j--;\\n            }\\n            \\n            if(k>=n || j<0){\\n                continue;\\n            }\\n            \\n            if(nums[i]>nums[k] && nums[i]>nums[j]){\\n                count++;\\n            }\\n            else if(nums[i]<nums[k] && nums[i]<nums[j]){\\n                count++;\\n            }\\n            \\n        }\\n        return count;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1870613,
                "title": "rust-solution",
                "content": "```\\nimpl Solution {\\n    pub fn count_hill_valley(nums: Vec<i32>) -> i32 {\\n        let mut cur_sign;\\n        let mut count = 0;\\n        let mut prev_sign = 0;\\n        for (&x, &y) in nums.iter().zip(nums[1..].iter()).filter(|(x, y)| x != y) {\\n            cur_sign = (y - x).signum();\\n            if cur_sign != prev_sign && prev_sign != 0 {\\n                count += 1;\\n            }\\n            prev_sign = cur_sign;\\n        }\\n        count\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nimpl Solution {\\n    pub fn count_hill_valley(nums: Vec<i32>) -> i32 {\\n        let mut cur_sign;\\n        let mut count = 0;\\n        let mut prev_sign = 0;\\n        for (&x, &y) in nums.iter().zip(nums[1..].iter()).filter(|(x, y)| x != y) {\\n            cur_sign = (y - x).signum();\\n            if cur_sign != prev_sign && prev_sign != 0 {\\n                count += 1;\\n            }\\n            prev_sign = cur_sign;\\n        }\\n        count\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1870313,
                "title": "a-few-solutions",
                "content": "*Kotlin*\\n```\\nclass Solution {\\n    fun countHillValley(A: IntArray): Int {\\n        var cnt = 0\\n        for (i in 1 until A.size - 1) {\\n            if (A[i] == A[i + 1])\\n                A[i] = A[i - 1]\\n            cnt += if (A[i - 1] < A[i] && A[i] > A[i + 1]) 1 else 0\\n            cnt += if (A[i - 1] > A[i] && A[i] < A[i + 1]) 1 else 0\\n        }\\n        return cnt\\n    }\\n}\\n```\\n\\n*Javascript*\\n```\\nlet countHillValley = (A, cnt = 0) => {\\n    for (let i = 1; i + 1 < A.length; ++i) {\\n        if (A[i] == A[i + 1])\\n            A[i] = A[i - 1];\\n        cnt += Number(A[i - 1] < A[i] && A[i] > A[i + 1]);\\n        cnt += Number(A[i - 1] > A[i] && A[i] < A[i + 1]);\\n    }\\n    return cnt;\\n};\\n```\\n\\n*Python3*\\n```\\nclass Solution:\\n    def countHillValley(self, A: List[int], cnt = 0) -> int:\\n        for i in range(1, len(A) - 1):\\n            if A[i] == A[i + 1]:\\n                A[i] = A[i - 1]\\n            cnt += int(A[i - 1] < A[i] > A[i + 1])\\n            cnt += int(A[i - 1] > A[i] < A[i + 1])\\n        return cnt\\n```\\n\\n*Rust*\\n```\\ntype VI = Vec<i32>;\\nimpl Solution {\\n    pub fn count_hill_valley(A_: VI) -> i32 {\\n        let mut cnt = 0;\\n        let mut A = A_.clone();\\n        for i in 1..A.len() - 1 {\\n            if A[i] == A[i + 1] {\\n                A[i] = A[i - 1];\\n            }\\n            cnt += if A[i - 1] < A[i] && A[i] > A[i + 1] { 1 } else { 0 };\\n            cnt += if A[i - 1] > A[i] && A[i] < A[i + 1] { 1 } else { 0 };\\n        }\\n        return cnt;\\n    }\\n}\\n```\\n\\n*C++*\\n```\\nclass Solution {\\npublic:\\n    using VI = vector<int>;\\n    int countHillValley(VI& A, int cnt = 0) {\\n        for (auto i{ 1 }; i + 1 < A.size(); ++i) {\\n            if (A[i] == A[i + 1])\\n                A[i] = A[i - 1];\\n            cnt += A[i - 1] > A[i] && A[i] < A[i + 1];\\n            cnt += A[i - 1] < A[i] && A[i] > A[i + 1];\\n        }\\n        return cnt;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    fun countHillValley(A: IntArray): Int {\\n        var cnt = 0\\n        for (i in 1 until A.size - 1) {\\n            if (A[i] == A[i + 1])\\n                A[i] = A[i - 1]\\n            cnt += if (A[i - 1] < A[i] && A[i] > A[i + 1]) 1 else 0\\n            cnt += if (A[i - 1] > A[i] && A[i] < A[i + 1]) 1 else 0\\n        }\\n        return cnt\\n    }\\n}\\n```\n```\\nlet countHillValley = (A, cnt = 0) => {\\n    for (let i = 1; i + 1 < A.length; ++i) {\\n        if (A[i] == A[i + 1])\\n            A[i] = A[i - 1];\\n        cnt += Number(A[i - 1] < A[i] && A[i] > A[i + 1]);\\n        cnt += Number(A[i - 1] > A[i] && A[i] < A[i + 1]);\\n    }\\n    return cnt;\\n};\\n```\n```\\nclass Solution:\\n    def countHillValley(self, A: List[int], cnt = 0) -> int:\\n        for i in range(1, len(A) - 1):\\n            if A[i] == A[i + 1]:\\n                A[i] = A[i - 1]\\n            cnt += int(A[i - 1] < A[i] > A[i + 1])\\n            cnt += int(A[i - 1] > A[i] < A[i + 1])\\n        return cnt\\n```\n```\\ntype VI = Vec<i32>;\\nimpl Solution {\\n    pub fn count_hill_valley(A_: VI) -> i32 {\\n        let mut cnt = 0;\\n        let mut A = A_.clone();\\n        for i in 1..A.len() - 1 {\\n            if A[i] == A[i + 1] {\\n                A[i] = A[i - 1];\\n            }\\n            cnt += if A[i - 1] < A[i] && A[i] > A[i + 1] { 1 } else { 0 };\\n            cnt += if A[i - 1] > A[i] && A[i] < A[i + 1] { 1 } else { 0 };\\n        }\\n        return cnt;\\n    }\\n}\\n```\n```\\nclass Solution {\\npublic:\\n    using VI = vector<int>;\\n    int countHillValley(VI& A, int cnt = 0) {\\n        for (auto i{ 1 }; i + 1 < A.size(); ++i) {\\n            if (A[i] == A[i + 1])\\n                A[i] = A[i - 1];\\n            cnt += A[i - 1] > A[i] && A[i] < A[i + 1];\\n            cnt += A[i - 1] < A[i] && A[i] > A[i + 1];\\n        }\\n        return cnt;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1868506,
                "title": "java-solutions",
                "content": "**Time: O(n) Space: O(n)**\\n```\\nclass Solution {\\n  public int countHillValley(int[] nums) {\\n    List<Integer> uniqueVals = new ArrayList<>();\\n    for (int n : nums) {\\n      if (uniqueVals.isEmpty() || uniqueVals.get(uniqueVals.size() - 1) != n) {\\n        uniqueVals.add(n);\\n      }\\n    }\\n    int count = 0;\\n    for (int i = 1; i < uniqueVals.size() - 1; i++) {\\n      if ((uniqueVals.get(i) > uniqueVals.get(i - 1))\\n          == (uniqueVals.get(i) > uniqueVals.get(i + 1))) {\\n        count++;\\n      }\\n    }\\n    return count;\\n  }\\n}\\n```\\n\\nSimple example of uniqueVals:\\n![image](https://assets.leetcode.com/users/images/ad0f1077-c405-4338-98b6-3ffc257527a3_1647811688.047779.png)\\n\\n\\nIt is not necessary to keep track of all the unique values, we can just keep track of three:\\nhttps://leetcode.com/problems/count-hills-and-valleys-in-an-array/discuss/1865658/Easiest-C++-Solution-oror-Two-Pointers/1316542\\n**Time: O(n) Space: O(1)**\\n```\\nclass Solution {\\n  public int countHillValley(int[] nums) {\\n    int unique1 = -1, unique2 = -1, count = 0;\\n    for (int unique3 : nums) {\\n      if (unique3 != unique2) {\\n        if (unique1 != -1 && (unique2 > unique3) == (unique2 > unique1)) count++;\\n        unique1 = unique2;\\n        unique2 = unique3;\\n      }\\n    }\\n    return count;\\n  }\\n}\\n```\\n",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n  public int countHillValley(int[] nums) {\\n    List<Integer> uniqueVals = new ArrayList<>();\\n    for (int n : nums) {\\n      if (uniqueVals.isEmpty() || uniqueVals.get(uniqueVals.size() - 1) != n) {\\n        uniqueVals.add(n);\\n      }\\n    }\\n    int count = 0;\\n    for (int i = 1; i < uniqueVals.size() - 1; i++) {\\n      if ((uniqueVals.get(i) > uniqueVals.get(i - 1))\\n          == (uniqueVals.get(i) > uniqueVals.get(i + 1))) {\\n        count++;\\n      }\\n    }\\n    return count;\\n  }\\n}\\n```\n```\\nclass Solution {\\n  public int countHillValley(int[] nums) {\\n    int unique1 = -1, unique2 = -1, count = 0;\\n    for (int unique3 : nums) {\\n      if (unique3 != unique2) {\\n        if (unique1 != -1 && (unique2 > unique3) == (unique2 > unique1)) count++;\\n        unique1 = unique2;\\n        unique2 = unique3;\\n      }\\n    }\\n    return count;\\n  }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1868455,
                "title": "java-0ms-beats-100",
                "content": "```\\n public int countHillValley(int[] nums) {\\n        int count=0;\\n        int nonEqL=0;\\n        int nonEqR=0;\\n        for(int i=1; i<nums.length-1; i++) {\\n            if(nums[i] != nums[i-1]) {  //set non equal left\\n                nonEqL = nums[i-1];\\n            }\\n            \\n            if(nums[i] != nums[i+1]) {  //set non equal right\\n                nonEqR = nums[i+1];\\n            }\\n            //should either be greater than both non equal left and non eq right to be counted as a hill\\n\\t\\t\\t// OR less than both non equal left and non eq right to be counted as a valley\\n            if((nonEqL != 0 && nonEqR != 0) \\n               && ((nums[i] > nonEqL && nums[i] > nonEqR) \\n                    || (nums[i] < nonEqL && nums[i] < nonEqR))) { \\n                count++;\\n            }\\n        }\\n        \\n        return count;\\n    \\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n public int countHillValley(int[] nums) {\\n        int count=0;\\n        int nonEqL=0;\\n        int nonEqR=0;\\n        for(int i=1; i<nums.length-1; i++) {\\n            if(nums[i] != nums[i-1]) {  //set non equal left\\n                nonEqL = nums[i-1];\\n            }\\n            \\n            if(nums[i] != nums[i+1]) {  //set non equal right\\n                nonEqR = nums[i+1];\\n            }\\n            //should either be greater than both non equal left and non eq right to be counted as a hill\\n\\t\\t\\t// OR less than both non equal left and non eq right to be counted as a valley\\n            if((nonEqL != 0 && nonEqR != 0) \\n               && ((nums[i] > nonEqL && nums[i] > nonEqR) \\n                    || (nums[i] < nonEqL && nums[i] < nonEqR))) { \\n                count++;\\n            }\\n        }\\n        \\n        return count;\\n    \\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1868448,
                "title": "java-easy-o-n-count-hills-and-valleys-with-comments",
                "content": "```\\nclass Solution {\\n    public int countHillValley(int[] nums) {\\n        \\n        int count=0;\\n        \\n        for ( int i=1 ; i < nums.length-1 ; i++)  \\n        {\\n            // 1. find  hill \\n            // left neighbor smaller\\n            if(nums[i-1] < nums[i] ) \\n            {\\n                // skip all equal number \\n                 while(  i < nums.length-1 && (nums[i] == nums[i+1] ))\\n                     i++;\\n                \\n                 // if we get right closest neighbor is smaller , this is hill\\n                 if ( i < nums.length-1 && nums[i+1] < nums[i])\\n                   count++;\\n            }   \\n             // 1. find  Valley\\n              // left neighbor greater\\n            else if(nums[i-1] > nums[i] ) \\n            {\\n                // skip all equal number \\n                 while(i < nums.length-1 && (nums[i] == nums[i+1] ))\\n                     i++;\\n                 // if we get right closest neighbor is greater , this is Valley\\n               if ( i < nums.length-1 && nums[i+1] > nums[i])\\n                   count++;\\n            } \\n        }\\n        \\n        return count;\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int countHillValley(int[] nums) {\\n        \\n        int count=0;\\n        \\n        for ( int i=1 ; i < nums.length-1 ; i++)  \\n        {\\n            // 1. find  hill \\n            // left neighbor smaller\\n            if(nums[i-1] < nums[i] ) \\n            {\\n                // skip all equal number \\n                 while(  i < nums.length-1 && (nums[i] == nums[i+1] ))\\n                     i++;\\n                \\n                 // if we get right closest neighbor is smaller , this is hill\\n                 if ( i < nums.length-1 && nums[i+1] < nums[i])\\n                   count++;\\n            }   \\n             // 1. find  Valley\\n              // left neighbor greater\\n            else if(nums[i-1] > nums[i] ) \\n            {\\n                // skip all equal number \\n                 while(i < nums.length-1 && (nums[i] == nums[i+1] ))\\n                     i++;\\n                 // if we get right closest neighbor is greater , this is Valley\\n               if ( i < nums.length-1 && nums[i+1] > nums[i])\\n                   count++;\\n            } \\n        }\\n        \\n        return count;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1868412,
                "title": "inplace-c-o-n-two-pointer",
                "content": "# Steps\\n* **Remove the duplicates** from the original array.(**using two pointer**)\\n* **Count the Hills and Valleys** `nums[i - 1] >  nums[i] && nums[i] < nums[i + 1])` for valley and `nums[i - 1] <  nums[i] && nums[i] > nums[i + 1]` for Hills.\\n* **Time Complexity is O(n) and space complexity os O(1) so inplace algorithm**\\n```\\nclass Solution {\\npublic:\\n    int countHillValley(vector<int>& nums) {\\n        ios_base::sync_with_stdio(false);\\n        cin.tie(NULL);\\n        cout.tie(NULL);\\n\\n        int count = 0;\\n        int i = 0,j = 1;\\n        while(j != nums.size()){\\n            if(nums[i] != nums[j]){\\n                i++;\\n                nums[i] = nums[j];\\n                j++;\\n            }\\n            else{\\n                j++;\\n            }\\n        }\\n        while(i < nums.size() - 1){\\n            nums.pop_back();\\n        }\\n        for(int i = 1;i < nums.size() - 1;i++){\\n            if(nums[i - 1] >  nums[i] && nums[i] < nums[i + 1]){\\n                count ++;\\n            }\\n            else if(nums[i - 1] <  nums[i] && nums[i] > nums[i + 1]){\\n                count ++;\\n            }\\n        }\\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int countHillValley(vector<int>& nums) {\\n        ios_base::sync_with_stdio(false);\\n        cin.tie(NULL);\\n        cout.tie(NULL);\\n\\n        int count = 0;\\n        int i = 0,j = 1;\\n        while(j != nums.size()){\\n            if(nums[i] != nums[j]){\\n                i++;\\n                nums[i] = nums[j];\\n                j++;\\n            }\\n            else{\\n                j++;\\n            }\\n        }\\n        while(i < nums.size() - 1){\\n            nums.pop_back();\\n        }\\n        for(int i = 1;i < nums.size() - 1;i++){\\n            if(nums[i - 1] >  nums[i] && nums[i] < nums[i + 1]){\\n                count ++;\\n            }\\n            else if(nums[i - 1] <  nums[i] && nums[i] > nums[i + 1]){\\n                count ++;\\n            }\\n        }\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 1868305,
                "title": "cpp-c-easy-to-understand",
                "content": "```\\nclass Solution {\\npublic:\\n    int countHillValley(vector<int>& nums) {\\n        int counter=0;\\n        nums = remove(nums);\\n        for(int i=1;i<nums.size()-1;i++){\\n            if(nums[i] > nums[i+1] && nums[i] > nums[i-1]) { counter++; }\\n            else if(nums[i] < nums[i+1] && nums[i] < nums[i-1]) { counter++; }\\n        }\\n        \\n        return counter;\\n    }\\npublic:\\n    vector<int> remove(vector<int> &temp){\\n        vector<int> ans;\\n        for(int i=0;i<temp.size()-1;i++){\\n            if(temp[i] != temp[i+1])\\n                ans.push_back(temp[i]);\\n        }\\n        ans.push_back(temp[temp.size()-1]);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int countHillValley(vector<int>& nums) {\\n        int counter=0;\\n        nums = remove(nums);\\n        for(int i=1;i<nums.size()-1;i++){\\n            if(nums[i] > nums[i+1] && nums[i] > nums[i-1]) { counter++; }\\n            else if(nums[i] < nums[i+1] && nums[i] < nums[i-1]) { counter++; }\\n        }\\n        \\n        return counter;\\n    }\\npublic:\\n    vector<int> remove(vector<int> &temp){\\n        vector<int> ans;\\n        for(int i=0;i<temp.size()-1;i++){\\n            if(temp[i] != temp[i+1])\\n                ans.push_back(temp[i]);\\n        }\\n        ans.push_back(temp[temp.size()-1]);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1867498,
                "title": "c-soln",
                "content": "```\\nclass Solution {\\npublic:\\n    int countHillValley(vector<int>& nums) \\n    {\\n        int n = nums.size();\\n        int res=0;\\n        \\n        \\n        for(int i=1;i<n-1;i++)\\n        {\\n            //removing duplicates\\n            if(nums[i]==nums[i-1]) continue;\\n            \\n            int left = i-1;\\n            int right = i+1;\\n            \\n            // finding unique number to the left\\n            while(left>0 && nums[left]==nums[i])\\n                left--;\\n            \\n            // finding unique number to the right\\n            while(right<n-1 && nums[right]==nums[i])\\n                right++;\\n            \\n            //hill\\n            if(nums[left] < nums[i] && nums[right] < nums[i])\\n                res++;\\n            //valley\\n            else if(nums[left] > nums[i] && nums[right] > nums[i])\\n                res++;\\n            \\n        }\\n        \\n         return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int countHillValley(vector<int>& nums) \\n    {\\n        int n = nums.size();\\n        int res=0;\\n        \\n        \\n        for(int i=1;i<n-1;i++)\\n        {\\n            //removing duplicates\\n            if(nums[i]==nums[i-1]) continue;\\n            \\n            int left = i-1;\\n            int right = i+1;\\n            \\n            // finding unique number to the left\\n            while(left>0 && nums[left]==nums[i])\\n                left--;\\n            \\n            // finding unique number to the right\\n            while(right<n-1 && nums[right]==nums[i])\\n                right++;\\n            \\n            //hill\\n            if(nums[left] < nums[i] && nums[right] < nums[i])\\n                res++;\\n            //valley\\n            else if(nums[left] > nums[i] && nums[right] > nums[i])\\n                res++;\\n            \\n        }\\n        \\n         return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1866949,
                "title": "simple-cpp-solution-count-hills-and-valleys",
                "content": "class Solution {\\npublic:\\n    int countHillValley(vector<int>& nums) {\\n        vector<int>::iterator it;\\n      \\n        it = std::unique(nums.begin(), nums.begin() + nums.size());\\n        nums.resize(std::distance(nums.begin(), it));\\n        int cnt=0;\\n        for(int i=1;i<nums.size()-1;i++){\\n            if((nums[i]>nums[i-1])&&(nums[i]>nums[i+1])){cnt++;}\\n            else if((nums[i]<nums[i-1])&&(nums[i]<nums[i+1])){cnt++;}\\n          \\n        }\\n        return cnt;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    int countHillValley(vector<int>& nums) {\\n        vector<int>::iterator it;\\n      \\n        it = std::unique(nums.begin(), nums.begin() + nums.size());\\n        nums.resize(std::distance(nums.begin(), it));\\n        int cnt=0;\\n        for(int i=1;i<nums.size()-1;i++){\\n            if((nums[i]>nums[i-1])&&(nums[i]>nums[i+1])){cnt++;}",
                "codeTag": "Java"
            },
            {
                "id": 1866808,
                "title": "5-line-c-solution-unique-function",
                "content": "```\\nclass Solution {\\npublic:\\n    int countHillValley(vector<int>& nums) {\\n        nums.erase(unique(nums.begin(),nums.end()),nums.end());\\n        int n=nums.size(), h=0;\\n        for(int i=0;i<n-2;i++)\\n            if((nums[i]<nums[i+1] and nums[i+1]>nums[i+2]) or (nums[i]>nums[i+1] and nums[i+1]<nums[i+2]))   h++;\\n        return h;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int countHillValley(vector<int>& nums) {\\n        nums.erase(unique(nums.begin(),nums.end()),nums.end());\\n        int n=nums.size(), h=0;\\n        for(int i=0;i<n-2;i++)\\n            if((nums[i]<nums[i+1] and nums[i+1]>nums[i+2]) or (nums[i]>nums[i+1] and nums[i+1]<nums[i+2]))   h++;\\n        return h;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1866756,
                "title": "c-o-n-time-o-1-space-beats-100-c-solutions-easy-solution-with-explaination",
                "content": "**Psuedocode**\\n1-Remove all repeating elements\\n2-Counting hills and valleys is now easy using an ans (count) variable\\n3-Use a for loop and check these conditon\\n\\ta-(nums[i]>nums[i+1] && nums[i]>nums[i-1]) Conditon for valid hill\\n\\tb-(nums[i]<nums[i-1] && nums[i]<nums[i+1]) Condtion for valid valley\\n```\\nclass Solution {\\npublic:\\n    int countHillValley(vector<int>& nums) {\\n\\t\\t//removed repeating numbers using unique stl\\n        vector<int>::iterator ip;\\n        ip=unique(nums.begin(),nums.begin()+nums.size());\\n        nums.resize(distance(nums.begin(),ip));\\n\\t\\t//used ans to count hills and valleys\\n        int ans=0;\\n        for(int i=1;i<nums.size()-1;i++){\\n            if(nums[i]>nums[i+1] && nums[i]>nums[i-1]){\\n                ans++;\\n            }\\n            else if(nums[i]<nums[i-1] && nums[i]<nums[i+1]){\\n                ans++;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int countHillValley(vector<int>& nums) {\\n\\t\\t//removed repeating numbers using unique stl\\n        vector<int>::iterator ip;\\n        ip=unique(nums.begin(),nums.begin()+nums.size());\\n        nums.resize(distance(nums.begin(),ip));\\n\\t\\t//used ans to count hills and valleys\\n        int ans=0;\\n        for(int i=1;i<nums.size()-1;i++){\\n            if(nums[i]>nums[i+1] && nums[i]>nums[i-1]){\\n                ans++;\\n            }\\n            else if(nums[i]<nums[i-1] && nums[i]<nums[i+1]){\\n                ans++;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1866388,
                "title": "c",
                "content": "```\\nclass Solution {\\npublic:\\n    int countHillValley(vector<int>& nums) {\\n          int ans = 0;\\n          int i = 1;\\n          while(i < nums.size() - 1){\\n              int ele = nums[i];\\n              int j = i -1;\\n              bool flag1 = true, flag2 = true;\\n              while(nums[j] == ele){\\n                  j--;\\n                  if(j < 0) {flag1 = false; break;}\\n              }\\n              \\n              int k = i + 1;\\n               while(nums[k] == ele){\\n                  k++;\\n                  if(k >= nums.size()) {flag2 = false; break;}\\n              }\\n              \\n              if(flag1 && flag2){\\n                  if(ele > nums[j] && ele > nums[k]) ans++;\\n                  else if(ele < nums[j] && ele < nums[k]) ans++;\\n              }\\n               // skippings the duplicates \\n                while(nums[i] == ele) i++;\\n          }\\n        return ans;\\n    }\\n};",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n    int countHillValley(vector<int>& nums) {\\n          int ans = 0;\\n          int i = 1;\\n          while(i < nums.size() - 1){\\n              int ele = nums[i];\\n              int j = i -1;\\n              bool flag1 = true, flag2 = true;\\n              while(nums[j] == ele){\\n                  j--;\\n                  if(j < 0) {flag1 = false; break;}",
                "codeTag": "Java"
            },
            {
                "id": 1865900,
                "title": "difference-arrary-to-count-the-flip-direction-o-n-o-1",
                "content": "nums = [2,4,1,1,6,5]\\ndiff_arr=[ 2,-3,0,5,-1]\\nPN = [+,-,0,+,-]\\n\\nthe count equal the positive and negtive flips(+ -> - or - ->+);\\n\\n```\\nclass Solution {\\npublic:\\n    int countHillValley(vector<int>& nums) {\\n        int n = nums.size();\\n        if(n < 2) return 0;\\n\\t\\t\\n        int dif = 0;\\n        int prev = 0;\\n        int count = 0;  // count is the result \\n\\t\\t\\n        for(int i = 1;i < n;i++){\\n            dif = nums[i] - nums[i-1];\\n\\t\\t\\t// if there is flips, count increased\\n            if(dif*prev < 0){\\n                count++;\\n            }\\n\\t\\t\\t// save the cur state(positive or negtive) as prev\\n            if(dif != 0){\\n                prev = dif;\\n            }\\n        }\\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Array"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int countHillValley(vector<int>& nums) {\\n        int n = nums.size();\\n        if(n < 2) return 0;\\n\\t\\t\\n        int dif = 0;\\n        int prev = 0;\\n        int count = 0;  // count is the result \\n\\t\\t\\n        for(int i = 1;i < n;i++){\\n            dif = nums[i] - nums[i-1];\\n\\t\\t\\t// if there is flips, count increased\\n            if(dif*prev < 0){\\n                count++;\\n            }\\n\\t\\t\\t// save the cur state(positive or negtive) as prev\\n            if(dif != 0){\\n                prev = dif;\\n            }\\n        }\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1865672,
                "title": "beginners-friendly-c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int countHillValley(vector<int>& nums) {\\n        int count=0;\\n        for(int i=1;i<nums.size()-1;i++)\\n        {\\n            if(nums[i]==nums[i-1])\\n                continue;\\n            int first=-1;\\n            int second=-1;\\n         \\n            bool temp1=false;\\n            bool temp2=false;\\n           \\n            for(int j=i-1;j>=0;j--)\\n            {\\n                if(nums[j]!=nums[i])\\n                {   \\n                    first=nums[j];\\n                    // cout<<nums[j];\\n                    temp1=true;\\n                     break;\\n                }\\n            }\\n            \\n           \\n            for(int j=i+1;j<nums.size();j++)\\n            {\\n                if(nums[j]!=nums[i])\\n                {   \\n                    second=nums[j];\\n                    temp2=true;\\n                   \\n                    break;\\n                    \\n                }\\n            }\\n            \\n            if(temp1==true&&temp2==true)\\n            {\\n                if(first<nums[i]&&second<nums[i])\\n                {   count+=1;}\\n                else if(first>nums[i]&&second>nums[i])\\n                {  count+=1;}\\n            }\\n        }\\n        return count;\\n    }\\n};\\n```\\n**Like it? Please Upvote ;-)**",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int countHillValley(vector<int>& nums) {\\n        int count=0;\\n        for(int i=1;i<nums.size()-1;i++)\\n        {\\n            if(nums[i]==nums[i-1])\\n                continue;\\n            int first=-1;\\n            int second=-1;\\n         \\n            bool temp1=false;\\n            bool temp2=false;\\n           \\n            for(int j=i-1;j>=0;j--)\\n            {\\n                if(nums[j]!=nums[i])\\n                {   \\n                    first=nums[j];\\n                    // cout<<nums[j];\\n                    temp1=true;\\n                     break;\\n                }\\n            }\\n            \\n           \\n            for(int j=i+1;j<nums.size();j++)\\n            {\\n                if(nums[j]!=nums[i])\\n                {   \\n                    second=nums[j];\\n                    temp2=true;\\n                   \\n                    break;\\n                    \\n                }\\n            }\\n            \\n            if(temp1==true&&temp2==true)\\n            {\\n                if(first<nums[i]&&second<nums[i])\\n                {   count+=1;}\\n                else if(first>nums[i]&&second>nums[i])\\n                {  count+=1;}\\n            }\\n        }\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 1865664,
                "title": "simple-java-solution-o-n-2",
                "content": "```\\nclass Solution {\\n    public int countHillValley(int[] nums) {\\n        int count =0;\\n        for(int i=0;i<nums.length;i++){\\n            Boolean isPrevLower = null;\\n            Boolean isNextLower = null;\\n            int j = i-1;\\n            while(j>=0){ \\n                if(nums[i]!=nums[j]){\\n                    if(nums[i]>nums[j])\\n                        isPrevLower = true;\\n                    else\\n                        isPrevLower = false;\\n\\n                    break;\\n                }\\n                j--;\\n            }\\n            j = i+1;\\n            while(j<nums.length){\\n                if(nums[i]!=nums[j]){\\n                    if(nums[i]>nums[j])\\n                        isNextLower = true;\\n                    else\\n                        isNextLower = false;\\n                    \\n                    break;\\n                }else\\n                    i=j;\\n                j++;\\n            }\\n            if(isPrevLower!=null && isNextLower!=null && isPrevLower == isNextLower)\\n                count++;\\n        }\\n        return count;\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public int countHillValley(int[] nums) {\\n        int count =0;\\n        for(int i=0;i<nums.length;i++){\\n            Boolean isPrevLower = null;\\n            Boolean isNextLower = null;\\n            int j = i-1;\\n            while(j>=0){ \\n                if(nums[i]!=nums[j]){\\n                    if(nums[i]>nums[j])\\n                        isPrevLower = true;\\n                    else\\n                        isPrevLower = false;\\n\\n                    break;\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 1865663,
                "title": "python-sol",
                "content": "```\\nclass Solution:\\n    def countHillValley(self, nums: List[int]) -> int:\\n        hills,valley=0,0\\n        n=len(nums)\\n        if n<3:\\n            return 0\\n        \\n        for i in range(1,len(nums)):\\n            if i==i-1:\\n                continue\\n            for j in range(i,len(nums)):\\n                if i!=j and nums[i]!=nums[j]:\\n                    if nums[i]>nums[i-1] and nums[i]>nums[j] : \\n                        hills+=1\\n                        break\\n                    elif nums[i]<nums[i-1] and nums[i]<nums[j]: \\n                        valley+=1\\n                        break\\n                    elif (nums[i]>nums[i-1] and nums[i]<nums[j])or (nums[i]<nums[i-1] and nums[i]>nums[j]):\\n                        break\\n        return hills+valley\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def countHillValley(self, nums: List[int]) -> int:\\n        hills,valley=0,0\\n        n=len(nums)\\n        if n<3:\\n            return 0\\n        \\n        for i in range(1,len(nums)):\\n            if i==i-1:\\n                continue\\n            for j in range(i,len(nums)):\\n                if i!=j and nums[i]!=nums[j]:\\n                    if nums[i]>nums[i-1] and nums[i]>nums[j] : \\n                        hills+=1\\n                        break\\n                    elif nums[i]<nums[i-1] and nums[i]<nums[j]: \\n                        valley+=1\\n                        break\\n                    elif (nums[i]>nums[i-1] and nums[i]<nums[j])or (nums[i]<nums[i-1] and nums[i]>nums[j]):\\n                        break\\n        return hills+valley\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1865581,
                "title": "java-easy-solution-single-loop",
                "content": "```\\nclass Solution {\\n    public int countHillValley(int[] nums) {\\n        if(nums.length<3){\\n            return 0;\\n        }\\n        int hills = 0;\\n        for(int i=1;i<nums.length-1;i++){\\n            if(nums[i-1]==nums[i] && i>1){\\n                nums[i-1] = nums[i-2];\\n            }\\n            if(nums[i]>nums[i-1] && nums[i]>nums[i+1]){\\n                hills++;\\n            }\\n            else if(nums[i]<nums[i-1] && nums[i]<nums[i+1]){\\n                hills++;\\n            }\\n        }\\n        return hills;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int countHillValley(int[] nums) {\\n        if(nums.length<3){\\n            return 0;\\n        }\\n        int hills = 0;\\n        for(int i=1;i<nums.length-1;i++){\\n            if(nums[i-1]==nums[i] && i>1){\\n                nums[i-1] = nums[i-2];\\n            }\\n            if(nums[i]>nums[i-1] && nums[i]>nums[i+1]){\\n                hills++;\\n            }\\n            else if(nums[i]<nums[i-1] && nums[i]<nums[i+1]){\\n                hills++;\\n            }\\n        }\\n        return hills;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4086393,
                "title": "python-clean-and-easy-to-understand-o-n",
                "content": "\\n# Code\\n```\\nclass Solution(object):\\n    def countHillValley(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: int\\n        \"\"\"\\n        count = 0\\n        length = len(nums)\\n        for i in range(1, length - 1):\\n            if nums[i] == nums[i+1]:\\n                nums[i] = nums[i - 1]\\n                continue\\n            if nums[i - 1] < nums[i] and nums[i] > nums[i + 1]:\\n                count += 1\\n            elif nums[i - 1] > nums[i] and nums[i] < nums[i + 1]:\\n                count += 1\\n            else:\\n                continue\\n        return count\\n\\n\\n        \\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution(object):\\n    def countHillValley(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: int\\n        \"\"\"\\n        count = 0\\n        length = len(nums)\\n        for i in range(1, length - 1):\\n            if nums[i] == nums[i+1]:\\n                nums[i] = nums[i - 1]\\n                continue\\n            if nums[i - 1] < nums[i] and nums[i] > nums[i + 1]:\\n                count += 1\\n            elif nums[i - 1] > nums[i] and nums[i] < nums[i + 1]:\\n                count += 1\\n            else:\\n                continue\\n        return count\\n\\n\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 4085717,
                "title": "beats-100-easy-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int countHillValley(vector<int>& nums) \\n    {\\n        int n =nums.size();\\n        int count=0;\\n        int j=0;\\n        for(int i=1; i<n-1; i++)\\n        {\\n            if(nums[j] < nums[i] && nums[i] > nums[i+1])\\n            {\\n                count++;\\n                j=i;\\n            }\\n            else if(nums[j] > nums[i] && nums[i] < nums[i+1])\\n            {\\n                count++;\\n                j=i;\\n            }\\n            else \\n            continue;\\n        }\\n        return count;\\n    }\\n};    \\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int countHillValley(vector<int>& nums) \\n    {\\n        int n =nums.size();\\n        int count=0;\\n        int j=0;\\n        for(int i=1; i<n-1; i++)\\n        {\\n            if(nums[j] < nums[i] && nums[i] > nums[i+1])\\n            {\\n                count++;\\n                j=i;\\n            }\\n            else if(nums[j] > nums[i] && nums[i] < nums[i+1])\\n            {\\n                count++;\\n                j=i;\\n            }\\n            else \\n            continue;\\n        }\\n        return count;\\n    }\\n};    \\n```",
                "codeTag": "Java"
            },
            {
                "id": 4083954,
                "title": "single-pass-t-o-n-s-o-1",
                "content": "# Complexity\\n- Time complexity: $$O(n)$$\\n- Space complexity: $$O(1)$$\\n\\n# Code\\n```\\nvar countHillValley = function(nums) {\\n    let counter = 0;\\n    let i = 1;\\n\\n    while (i < nums.length - 1) {\\n        const num = nums[i];\\n        const prevNum = nums[i - 1];\\n        const nextNum = (() => {\\n            while (nums[i + 1] === num) {\\n                i += 1;\\n            }\\n            return nums[i + 1];\\n        })();\\n        if ((prevNum < num && nextNum < num) ||\\n            (prevNum > num && nextNum > num)) {\\n            counter += 1;\\n        }\\n        i += 1;\\n    }\\n    return counter;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar countHillValley = function(nums) {\\n    let counter = 0;\\n    let i = 1;\\n\\n    while (i < nums.length - 1) {\\n        const num = nums[i];\\n        const prevNum = nums[i - 1];\\n        const nextNum = (() => {\\n            while (nums[i + 1] === num) {\\n                i += 1;\\n            }\\n            return nums[i + 1];\\n        })();\\n        if ((prevNum < num && nextNum < num) ||\\n            (prevNum > num && nextNum > num)) {\\n            counter += 1;\\n        }\\n        i += 1;\\n    }\\n    return counter;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4081836,
                "title": "cpp-short-simple",
                "content": "---\\n\\n# Complexity\\n- Time complexity:\\n\\uD83D\\uDFE2 $$O(n)$$ \\n\\n- Space complexity:\\n\\uD83D\\uDFE2 $$O(n)$$ \\n---\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int countHillValley(vector<int>& nums) {\\n        int hill = 0; \\n        int valley = 0;\\n        vector<int> nums1;\\n        nums1.push_back(nums[0]);\\n        for(int i=1; i<nums.size(); i++){\\n            if(nums[i] == nums[i-1]) continue;\\n            nums1.push_back(nums[i]);\\n        }\\n        for(int i = 1; i<nums1.size()-1; i++){\\n            if(nums1[i] > nums1[i-1] && nums1[i] > nums1[i+1]) hill++;\\n        }\\n        for(int i = 1; i<nums1.size()-1; i++){\\n            if(nums1[i] < nums1[i-1] && nums1[i] < nums1[i+1]) valley++;\\n        }\\n\\n        return hill+valley;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int countHillValley(vector<int>& nums) {\\n        int hill = 0; \\n        int valley = 0;\\n        vector<int> nums1;\\n        nums1.push_back(nums[0]);\\n        for(int i=1; i<nums.size(); i++){\\n            if(nums[i] == nums[i-1]) continue;\\n            nums1.push_back(nums[i]);\\n        }\\n        for(int i = 1; i<nums1.size()-1; i++){\\n            if(nums1[i] > nums1[i-1] && nums1[i] > nums1[i+1]) hill++;\\n        }\\n        for(int i = 1; i<nums1.size()-1; i++){\\n            if(nums1[i] < nums1[i-1] && nums1[i] < nums1[i+1]) valley++;\\n        }\\n\\n        return hill+valley;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4069204,
                "title": "easy-logic",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(n^2)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def countHillValley(self, nums: List[int]) -> int:\\n        r = []\\n        i = 1\\n        while i < len(nums)-1:\\n            temp = nums[:i][::-1] \\n            for j in temp:                \\n                if (nums[i] != j ) :\\n                    break\\n            for k in nums[i+1:] :\\n                if (nums[i] != k) :\\n                    break\\n            if (nums[i] > j and nums[i] > k) or (nums[i] < j and nums[i] < k) :\\n                l = [j, k]\\n                r += [l]\\n            i += 1\\n        \\n        if r:\\n            c = 0\\n            for i in range(len(r)-1) :\\n                if r[i] != r[i+1] :\\n                    c += 1\\n            return c+1\\n        return 0\\n        \\n```",
                "solutionTags": [
                    "Python3",
                    "Array"
                ],
                "code": "```\\nclass Solution:\\n    def countHillValley(self, nums: List[int]) -> int:\\n        r = []\\n        i = 1\\n        while i < len(nums)-1:\\n            temp = nums[:i][::-1] \\n            for j in temp:                \\n                if (nums[i] != j ) :\\n                    break\\n            for k in nums[i+1:] :\\n                if (nums[i] != k) :\\n                    break\\n            if (nums[i] > j and nums[i] > k) or (nums[i] < j and nums[i] < k) :\\n                l = [j, k]\\n                r += [l]\\n            i += 1\\n        \\n        if r:\\n            c = 0\\n            for i in range(len(r)-1) :\\n                if r[i] != r[i+1] :\\n                    c += 1\\n            return c+1\\n        return 0\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 4067657,
                "title": "ez",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {number[]} nums\\n * @return {number}\\n */\\nvar countHillValley = function(nums) {\\n    const arr=nums.filter((a,i,b)=> a!=b[i+1]);\\n    let flag=0;\\n    \\n    for(i=1;i<=arr.length-1;i++){\\n        if(arr[i-1]<arr[i]&&arr[i+1]<arr[i]){\\n            flag++;\\n        }\\n        else if(arr[i-1]>arr[i]&&arr[i+1]>arr[i]){\\n            flag++;\\n        }\\n    }\\n    \\n   return flag;\\n    \\n\\n    \\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} nums\\n * @return {number}\\n */\\nvar countHillValley = function(nums) {\\n    const arr=nums.filter((a,i,b)=> a!=b[i+1]);\\n    let flag=0;\\n    \\n    for(i=1;i<=arr.length-1;i++){\\n        if(arr[i-1]<arr[i]&&arr[i+1]<arr[i]){\\n            flag++;\\n        }\\n        else if(arr[i-1]>arr[i]&&arr[i+1]>arr[i]){\\n            flag++;\\n        }\\n    }\\n    \\n   return flag;\\n    \\n\\n    \\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4050081,
                "title": "c-easy-worst-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int countHillValley(vector<int>& nums) {\\n        int count=0;\\n        nums.erase(unique(nums.begin(),nums.end()),nums.end());\\n        for(int i=1;i<nums.size()-1;i++)\\n        {\\n          if(nums[i]>nums[i-1]&&nums[i]>nums[i+1] || nums[i]<nums[i-1]&&nums[i]<nums[i+1])\\n          {\\n              count++;\\n          }\\n        }\\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int countHillValley(vector<int>& nums) {\\n        int count=0;\\n        nums.erase(unique(nums.begin(),nums.end()),nums.end());\\n        for(int i=1;i<nums.size()-1;i++)\\n        {\\n          if(nums[i]>nums[i-1]&&nums[i]>nums[i+1] || nums[i]<nums[i-1]&&nums[i]<nums[i+1])\\n          {\\n              count++;\\n          }\\n        }\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4042920,
                "title": "easy-java-solution",
                "content": "```\\n        int count = 0;\\n        int i = 1;\\n        int len = nums.length;\\n\\n        while (i < len - 1) {\\n\\n            if (nums[i] == nums[i + 1]) {\\n                i++;\\n                continue;\\n            }\\n\\n            int j = i - 1;\\n            int k = i + 1;\\n\\n            while (j != 0 && nums[i] == nums[j]) {\\n                j--;\\n            }\\n            while (k < len && nums[i] == nums[k]) {\\n                k++;\\n            }\\n\\n            if (nums[i] > nums[j] && nums[i] > nums[k]) count++;\\n\\n            else if (nums[i] < nums[j] && nums[i] < nums[k]) count++;\\n\\n            i++;\\n\\n\\n        }\\n        return count;\\n```",
                "solutionTags": [
                    "Java",
                    "Two Pointers"
                ],
                "code": "```\\n        int count = 0;\\n        int i = 1;\\n        int len = nums.length;\\n\\n        while (i < len - 1) {\\n\\n            if (nums[i] == nums[i + 1]) {\\n                i++;\\n                continue;\\n            }\\n\\n            int j = i - 1;\\n            int k = i + 1;\\n\\n            while (j != 0 && nums[i] == nums[j]) {\\n                j--;\\n            }\\n            while (k < len && nums[i] == nums[k]) {\\n                k++;\\n            }\\n\\n            if (nums[i] > nums[j] && nums[i] > nums[k]) count++;\\n\\n            else if (nums[i] < nums[j] && nums[i] < nums[k]) count++;\\n\\n            i++;\\n\\n\\n        }\\n        return count;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4006488,
                "title": "simple-approach",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int countHillValley(vector<int>& nums) \\n    {\\n        vector<int> traversal;\\n        traversal.push_back(nums[0]);\\n        for(int i=1;i<nums.size();i++)\\n        {\\n            if(nums[i-1]!=nums[i])\\n            traversal.push_back(nums[i]);\\n        }\\n        bool inc=traversal[0]<traversal[1];\\n        int count=1;\\n        for(int i=0;i<traversal.size()-1;i++)\\n        {\\n            if(traversal[i]<traversal[i+1]&&!inc)\\n            {\\n                inc=true;\\n                count++;\\n            }\\n            if(traversal[i]>traversal[i+1]&&inc)\\n            {\\n                inc=false;\\n                count++;\\n            }\\n        }\\n        return count-1;   \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int countHillValley(vector<int>& nums) \\n    {\\n        vector<int> traversal;\\n        traversal.push_back(nums[0]);\\n        for(int i=1;i<nums.size();i++)\\n        {\\n            if(nums[i-1]!=nums[i])\\n            traversal.push_back(nums[i]);\\n        }\\n        bool inc=traversal[0]<traversal[1];\\n        int count=1;\\n        for(int i=0;i<traversal.size()-1;i++)\\n        {\\n            if(traversal[i]<traversal[i+1]&&!inc)\\n            {\\n                inc=true;\\n                count++;\\n            }\\n            if(traversal[i]>traversal[i+1]&&inc)\\n            {\\n                inc=false;\\n                count++;\\n            }\\n        }\\n        return count-1;   \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3990242,
                "title": "c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n public:\\n  int countHillValley(vector<int>& nums) {\\n    int ans = 0;\\n    int left = nums[0];\\n\\n    for (int i = 1; i + 1 < nums.size(); ++i)\\n      if (left < nums[i] && nums[i] > nums[i + 1] ||  // Hill\\n          left > nums[i] && nums[i] < nums[i + 1]) {  // Valley\\n        ++ans;\\n        left = nums[i];\\n      }\\n\\n    return ans;\\n  }\\n};\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\n public:\\n  int countHillValley(vector<int>& nums) {\\n    int ans = 0;\\n    int left = nums[0];\\n\\n    for (int i = 1; i + 1 < nums.size(); ++i)\\n      if (left < nums[i] && nums[i] > nums[i + 1] ||  // Hill\\n          left > nums[i] && nums[i] < nums[i + 1]) {  // Valley\\n        ++ans;\\n        left = nums[i];\\n      }\\n\\n    return ans;\\n  }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3982923,
                "title": "typescript-javascript-simple-solution",
                "content": "# Code\\n```\\nfunction countHillValley(nums: number[]): number {\\n    let result = 0;\\n    let prev = nums[0];\\n\\n    for (let i = 1; i < nums.length - 1; i++) {\\n        const curr = nums[i];\\n        const next = nums[i + 1];\\n        \\n        if (curr === next) continue;\\n\\n        if (curr > prev && curr > next) {\\n            result++;\\n        }\\n\\n        if (curr < prev && curr < next) {\\n            result++;\\n        }\\n\\n        prev = curr;\\n    }\\n\\n    return result;\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "TypeScript"
                ],
                "code": "```\\nfunction countHillValley(nums: number[]): number {\\n    let result = 0;\\n    let prev = nums[0];\\n\\n    for (let i = 1; i < nums.length - 1; i++) {\\n        const curr = nums[i];\\n        const next = nums[i + 1];\\n        \\n        if (curr === next) continue;\\n\\n        if (curr > prev && curr > next) {\\n            result++;\\n        }\\n\\n        if (curr < prev && curr < next) {\\n            result++;\\n        }\\n\\n        prev = curr;\\n    }\\n\\n    return result;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3972297,
                "title": "easy-to-understand-python3-solution-tc-o-n-sc-o-1",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def countHillValley(self, nums: List[int]) -> int:\\n        position = 1\\n        count = 0\\n\\n        while position < len(nums) - 1:\\n            low = position -1\\n            high = position + 1\\n\\n            while low >= 1:\\n                if nums[low] == nums[position]:\\n                    low -= 1\\n                else:\\n                    break\\n            \\n            while high < len(nums) - 1:\\n                if nums[high] == nums[position]:\\n                    high += 1\\n                else:\\n                    break\\n            \\n            if nums[low] < nums[position] and nums[position] > nums[high]:\\n                count += 1\\n            \\n            if nums[low] > nums[position] and nums[position] < nums[high]:\\n                count += 1\\n            \\n            position = high\\n        \\n        return count\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def countHillValley(self, nums: List[int]) -> int:\\n        position = 1\\n        count = 0\\n\\n        while position < len(nums) - 1:\\n            low = position -1\\n            high = position + 1\\n\\n            while low >= 1:\\n                if nums[low] == nums[position]:\\n                    low -= 1\\n                else:\\n                    break\\n            \\n            while high < len(nums) - 1:\\n                if nums[high] == nums[position]:\\n                    high += 1\\n                else:\\n                    break\\n            \\n            if nums[low] < nums[position] and nums[position] > nums[high]:\\n                count += 1\\n            \\n            if nums[low] > nums[position] and nums[position] < nums[high]:\\n                count += 1\\n            \\n            position = high\\n        \\n        return count\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3946563,
                "title": "java-beat-100-in-time",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int countHillValley(int[] nums) {\\n        int count =0;\\n        for(int i=1; i<nums.length-1; i++) {\\n            int j = i;\\n            while (j<nums.length-2 && nums[j] == nums[j+1]) {\\n                j++;\\n            }\\n            if ((nums[i-1] < nums[i] && nums[i] > nums[j+1]) || (nums[i-1] > nums[i] && nums[i] < nums[j+1])) {\\n                count++;\\n            }\\n            i = j;\\n        }\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int countHillValley(int[] nums) {\\n        int count =0;\\n        for(int i=1; i<nums.length-1; i++) {\\n            int j = i;\\n            while (j<nums.length-2 && nums[j] == nums[j+1]) {\\n                j++;\\n            }\\n            if ((nums[i-1] < nums[i] && nums[i] > nums[j+1]) || (nums[i-1] > nums[i] && nums[i] < nums[j+1])) {\\n                count++;\\n            }\\n            i = j;\\n        }\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3923963,
                "title": "simple-c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int countHillValley(vector<int>& nums) {\\n        \\n        int count=0;\\n        for(int i=1;i<nums.size()-1;i++)\\n        {\\n             int prev=i-1;\\n             int next=i+1;\\n             if(nums[i]==nums[i-1])\\n             {\\n                 continue;\\n             }\\n             while(prev>=0 && nums[prev]==nums[i])\\n             {\\n                prev--;\\n             }\\n             while(next<nums.size() && nums[next]==nums[i])\\n             {\\n                next++;\\n             }\\n             if(prev<0 || next>=nums.size())\\n             {\\n                 continue;\\n             }\\n             if(nums[i]>nums[prev]  && nums[i]>nums[next])\\n             {\\n                 count++;\\n                 \\n             }\\n             if(nums[i]<nums[next] && nums[i]<nums[prev])\\n             {\\n                 count++;\\n             }\\n        }\\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int countHillValley(vector<int>& nums) {\\n        \\n        int count=0;\\n        for(int i=1;i<nums.size()-1;i++)\\n        {\\n             int prev=i-1;\\n             int next=i+1;\\n             if(nums[i]==nums[i-1])\\n             {\\n                 continue;\\n             }\\n             while(prev>=0 && nums[prev]==nums[i])\\n             {\\n                prev--;\\n             }\\n             while(next<nums.size() && nums[next]==nums[i])\\n             {\\n                next++;\\n             }\\n             if(prev<0 || next>=nums.size())\\n             {\\n                 continue;\\n             }\\n             if(nums[i]>nums[prev]  && nums[i]>nums[next])\\n             {\\n                 count++;\\n                 \\n             }\\n             if(nums[i]<nums[next] && nums[i]<nums[prev])\\n             {\\n                 count++;\\n             }\\n        }\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3920918,
                "title": "rust-beats-100-o-n-o-1",
                "content": "# Complexity\\n- Time complexity:\\n$$O(n)$$\\n\\n- Space complexity:\\n$$O(1)$$\\n\\n# Code\\n```\\nimpl Solution {\\n    pub fn count_hill_valley(nums: Vec<i32>) -> i32 {\\n        let mut res = 0;\\n        let mut uphill = nums[1].cmp(&nums[0]);\\n        for i in 1..nums.len() {\\n            match nums[i].cmp(&nums[i - 1]) {\\n                std::cmp::Ordering::Greater => {\\n                    if uphill == std::cmp::Ordering::Less {\\n                        res += 1;\\n                    }\\n                    uphill = std::cmp::Ordering::Greater;\\n                }\\n                std::cmp::Ordering::Equal => (),\\n                std::cmp::Ordering::Less => {\\n                    if uphill == std::cmp::Ordering::Greater {\\n                        res += 1;\\n                    }\\n                    uphill = std::cmp::Ordering::Less;\\n                }\\n            }\\n        }\\n\\n        res\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nimpl Solution {\\n    pub fn count_hill_valley(nums: Vec<i32>) -> i32 {\\n        let mut res = 0;\\n        let mut uphill = nums[1].cmp(&nums[0]);\\n        for i in 1..nums.len() {\\n            match nums[i].cmp(&nums[i - 1]) {\\n                std::cmp::Ordering::Greater => {\\n                    if uphill == std::cmp::Ordering::Less {\\n                        res += 1;\\n                    }\\n                    uphill = std::cmp::Ordering::Greater;\\n                }\\n                std::cmp::Ordering::Equal => (),\\n                std::cmp::Ordering::Less => {\\n                    if uphill == std::cmp::Ordering::Greater {\\n                        res += 1;\\n                    }\\n                    uphill = std::cmp::Ordering::Less;\\n                }\\n            }\\n        }\\n\\n        res\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3914698,
                "title": "python-simple-solution-beats-93-user-in-both-time-and-space",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def countHillValley(self, nums: List[int]) -> int:\\n        arr=[]\\n        left=nums[0]\\n        for i in range(1,len(nums)-1):\\n            j=i+1\\n\\n            if left==nums[i]:\\n                continue\\n            while j<len(nums) and nums[i]==nums[j]:\\n                j+=1\\n            if j>=len(nums):\\n                continue\\n            right=nums[j]\\n            if left<nums[i] and right<nums[i]:\\n                arr.append(\\'hill\\')\\n                left=nums[i]\\n            elif left>nums[i] and right>nums[i]:\\n                arr.append(\\'valley\\')\\n                left=nums[i]\\n    \\n        val=\\'\\'\\n        count=0\\n        for i in range(len(arr)):\\n            if arr[i]!=val:\\n                count+=1\\n            val=arr[i]\\n            \\n        return(count)\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def countHillValley(self, nums: List[int]) -> int:\\n        arr=[]\\n        left=nums[0]\\n        for i in range(1,len(nums)-1):\\n            j=i+1\\n\\n            if left==nums[i]:\\n                continue\\n            while j<len(nums) and nums[i]==nums[j]:\\n                j+=1\\n            if j>=len(nums):\\n                continue\\n            right=nums[j]\\n            if left<nums[i] and right<nums[i]:\\n                arr.append(\\'hill\\')\\n                left=nums[i]\\n            elif left>nums[i] and right>nums[i]:\\n                arr.append(\\'valley\\')\\n                left=nums[i]\\n    \\n        val=\\'\\'\\n        count=0\\n        for i in range(len(arr)):\\n            if arr[i]!=val:\\n                count+=1\\n            val=arr[i]\\n            \\n        return(count)\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3901205,
                "title": "iteration-tracking-last-hill-or-valley-checking-valley-or-hill-iteratively",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int countHillValley(int[] nums) {\\n        if (nums == null || nums.length <= 2) {\\n            return 0;\\n        }\\n        int numberOfHills = 0;\\n        int numberOfValleys = 0;\\n        int indexOfLastHillOrValley = 0;\\n        for (int i = 1; i < nums.length - 1; i++) {\\n            //is Hill?\\n            if (nums[i] > nums[indexOfLastHillOrValley] && nums[i] > nums[i + 1]) {\\n                numberOfHills++;\\n                indexOfLastHillOrValley = i;\\n            } else if (nums[i] < nums[indexOfLastHillOrValley] && nums[i] < nums[i + 1]) {\\n                numberOfValleys++;\\n                indexOfLastHillOrValley = i;\\n            }\\n        }\\n        return numberOfHills + numberOfValleys;        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int countHillValley(int[] nums) {\\n        if (nums == null || nums.length <= 2) {\\n            return 0;\\n        }\\n        int numberOfHills = 0;\\n        int numberOfValleys = 0;\\n        int indexOfLastHillOrValley = 0;\\n        for (int i = 1; i < nums.length - 1; i++) {\\n            //is Hill?\\n            if (nums[i] > nums[indexOfLastHillOrValley] && nums[i] > nums[i + 1]) {\\n                numberOfHills++;\\n                indexOfLastHillOrValley = i;\\n            } else if (nums[i] < nums[indexOfLastHillOrValley] && nums[i] < nums[i + 1]) {\\n                numberOfValleys++;\\n                indexOfLastHillOrValley = i;\\n            }\\n        }\\n        return numberOfHills + numberOfValleys;        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3892683,
                "title": "c-o-n-solution-faster-than-100",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    int countHillValley(vector<int>& nums) {\\n        int c = 0;\\n        int prev = nums[0];\\n        for(int i=1;i<nums.size()-1;i++){\\n            if((nums[i]>prev && nums[i]>nums[i+1]) || \\n                (nums[i]<prev && nums[i]<nums[i+1])){\\n                c++;\\n                prev=nums[i];\\n            }\\n        }\\n        return c;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int countHillValley(vector<int>& nums) {\\n        int c = 0;\\n        int prev = nums[0];\\n        for(int i=1;i<nums.size()-1;i++){\\n            if((nums[i]>prev && nums[i]>nums[i+1]) || \\n                (nums[i]<prev && nums[i]<nums[i+1])){\\n                c++;\\n                prev=nums[i];\\n            }\\n        }\\n        return c;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3879937,
                "title": "count-hills-and-valleys-in-an-array",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int countHillValley(int[] nums) {\\n        int count =0;\\n        ArrayList<Integer> arr = new ArrayList<Integer>();\\n        arr.add(nums[0]);\\n        for(int i=1;i<nums.length;i++)\\n        {\\n            if(nums[i-1]!=nums[i])\\n            arr.add(nums[i]);\\n        }\\n        for(int i=0;i<arr.size();i++)\\n        {\\n            System.out.println(arr.get(i)+\" \");\\n        }\\n        for(int i=1;i<arr.size()-1;i++)\\n        {\\n            if(arr.get(i)>arr.get(i-1)&&arr.get(i)>arr.get(i+1))\\n            count++;\\n            else if(arr.get(i)<arr.get(i-1)&&arr.get(i)<arr.get(i+1))\\n            count++;\\n        }\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int countHillValley(int[] nums) {\\n        int count =0;\\n        ArrayList<Integer> arr = new ArrayList<Integer>();\\n        arr.add(nums[0]);\\n        for(int i=1;i<nums.length;i++)\\n        {\\n            if(nums[i-1]!=nums[i])\\n            arr.add(nums[i]);\\n        }\\n        for(int i=0;i<arr.size();i++)\\n        {\\n            System.out.println(arr.get(i)+\" \");\\n        }\\n        for(int i=1;i<arr.size()-1;i++)\\n        {\\n            if(arr.get(i)>arr.get(i-1)&&arr.get(i)>arr.get(i+1))\\n            count++;\\n            else if(arr.get(i)<arr.get(i-1)&&arr.get(i)<arr.get(i+1))\\n            count++;\\n        }\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3879550,
                "title": "scala",
                "content": "# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nobject Solution {\\n    def countHillValley(nums: Array[Int]): Int = {\\n        var isHill: Option[Boolean] = None\\n        (1 until nums.length).map { i => \\n            val prev = nums(i-1)\\n            val curr = nums(i)\\n            if(prev != curr) {\\n                if (prev > curr) {\\n                    val result = isHill match {\\n                        case Some(true) => 1\\n                        case _ => 0\\n                    }\\n                    isHill = Some(false)\\n                    result\\n                } else {\\n                    val result = isHill match {\\n                        case Some(false) => 1\\n                        case _ => 0\\n                    }\\n                    isHill = Some(true)\\n                    result\\n                }\\n            } else 0\\n        }.sum\\n    }\\n}\\n```",
                "solutionTags": [
                    "Scala"
                ],
                "code": "```\\nobject Solution {\\n    def countHillValley(nums: Array[Int]): Int = {\\n        var isHill: Option[Boolean] = None\\n        (1 until nums.length).map { i => \\n            val prev = nums(i-1)\\n            val curr = nums(i)\\n            if(prev != curr) {\\n                if (prev > curr) {\\n                    val result = isHill match {\\n                        case Some(true) => 1\\n                        case _ => 0\\n                    }\\n                    isHill = Some(false)\\n                    result\\n                } else {\\n                    val result = isHill match {\\n                        case Some(false) => 1\\n                        case _ => 0\\n                    }\\n                    isHill = Some(true)\\n                    result\\n                }\\n            } else 0\\n        }.sum\\n    }\\n}\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3872802,
                "title": "basic-java-soln-100",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int countHillValley(int[] nums) {\\n        int c=0;\\n        for(int i=1;i<nums.length-1;i++){\\n            if((nums[i]>nums[i-1]&&nums[i]>nums[i+1])||(nums[i]<nums[i-1]&&nums[i]<nums[i+1])){\\n                c++;\\n            }\\n            if(nums[i]==nums[i+1])\\n                nums[i]=nums[i-1];\\n        }\\n        return c;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int countHillValley(int[] nums) {\\n        int c=0;\\n        for(int i=1;i<nums.length-1;i++){\\n            if((nums[i]>nums[i-1]&&nums[i]>nums[i+1])||(nums[i]<nums[i-1]&&nums[i]<nums[i+1])){\\n                c++;\\n            }\\n            if(nums[i]==nums[i+1])\\n                nums[i]=nums[i-1];\\n        }\\n        return c;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3858259,
                "title": "count-hills-and-valleys-in-an-array",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(n)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int countHillValley(vector<int>& nums) \\n    {\\n\\n        vector<int> v;\\n        v.push_back(nums[0]);\\n        int j=0;\\n        for(int i=1;i<nums.size();i++)\\n        {\\n            if(nums[i]!=v[j])\\n            {\\n                v.push_back(nums[i]);\\n                j++;\\n            }\\n        }\\n        int cnt=0;\\n        for(int i=1;i<v.size()-1;i++)\\n        {\\n            if(v[i]>v[i-1]&&v[i]>v[i+1])\\n            cnt++;\\n            if(v[i]<v[i-1] && v[i]<v[i+1])\\n            cnt++;\\n        }\\n        return cnt;\\n\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int countHillValley(vector<int>& nums) \\n    {\\n\\n        vector<int> v;\\n        v.push_back(nums[0]);\\n        int j=0;\\n        for(int i=1;i<nums.size();i++)\\n        {\\n            if(nums[i]!=v[j])\\n            {\\n                v.push_back(nums[i]);\\n                j++;\\n            }\\n        }\\n        int cnt=0;\\n        for(int i=1;i<v.size()-1;i++)\\n        {\\n            if(v[i]>v[i-1]&&v[i]>v[i+1])\\n            cnt++;\\n            if(v[i]<v[i-1] && v[i]<v[i+1])\\n            cnt++;\\n        }\\n        return cnt;\\n\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3857687,
                "title": "javasctipt-very-intuitive",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nwe dont care about the number of indeces in valleys and hills, so remove all adjacent elements of same value. Then loop through the resultant array.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. create a new array where no element is of same value and are adjacent. \\n2. iterate starting from idx 1 and till one before last and check if each idx you are at is either bigger or smaller its left and right neighbors. \\n3. if so, add to the result\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n2 * O(n) since we loop through array twice, discard constant -> so O(n)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(n) since we create another array of potentially size equal to the original array.\\n\\n# Code\\n```\\n/**\\n * @param {number[]} nums\\n * @return {number}\\n */\\nvar countHillValley = function(nums) {\\n    let cnt = 0;\\n    const u =  []\\n\\n    for (const n of nums) {\\n        if (u.length === 0 || u.at(-1) !== n) {\\n            u.push(n)\\n        }\\n    }\\n\\n    for (let i = 1; i<u.length-1; i++) {\\n        if (u[i] > u[i-1] && u[i] > u[i+1] ||\\n        u[i] < u[i-1] && u[i] < u[i+1]) {\\n            cnt++;\\n        }\\n    }\\n\\n    return cnt;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} nums\\n * @return {number}\\n */\\nvar countHillValley = function(nums) {\\n    let cnt = 0;\\n    const u =  []\\n\\n    for (const n of nums) {\\n        if (u.length === 0 || u.at(-1) !== n) {\\n            u.push(n)\\n        }\\n    }\\n\\n    for (let i = 1; i<u.length-1; i++) {\\n        if (u[i] > u[i-1] && u[i] > u[i+1] ||\\n        u[i] < u[i-1] && u[i] < u[i+1]) {\\n            cnt++;\\n        }\\n    }\\n\\n    return cnt;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3810778,
                "title": "o-n-solution-in-cpp",
                "content": "\\n# Complexity\\n- Time complexity:```O(n)```\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:  ```O(1)```\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int countHillValley(vector<int>& nums) {\\n        int ans = 0;\\n        for (int i = 1, j = 0; i < nums.size() - 1; ++i)\\n            if ((nums[j] < nums[i] && nums[i] > nums[i + 1]) ||\\n                (nums[j] > nums[i] && nums[i] < nums[i + 1])) {\\n                ++ans;\\n                j = i;\\n            }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```O(n)```\n```O(1)```\n```\\nclass Solution {\\npublic:\\n    int countHillValley(vector<int>& nums) {\\n        int ans = 0;\\n        for (int i = 1, j = 0; i < nums.size() - 1; ++i)\\n            if ((nums[j] < nums[i] && nums[i] > nums[i + 1]) ||\\n                (nums[j] > nums[i] && nums[i] < nums[i + 1])) {\\n                ++ans;\\n                j = i;\\n            }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3808368,
                "title": "java-array-traversal-100-fast-quickest-easy",
                "content": "# Code\\n```\\nclass Solution {\\n    public int countHillValley(int[] nums) {\\n        int ans = 0;\\n        for(int i=1 ; i<nums.length-1; i++){\\n            if(nums[i]==nums[i-1]) {continue;}\\n            int left = closestLeft(i,nums);\\n            int rigt = closestRigt(i,nums);\\n            if(left>nums[i] && rigt>nums[i]) ans++;\\n            if(left<nums[i] && rigt<nums[i]) ans++;\\n        }\\n        return ans;\\n    }\\n    private int closestLeft(int index, int[] arr) {\\n        if(arr[index-1]!=arr[index]) return arr[index-1];\\n        else {\\n            int i = index-1;\\n            while(i>0){\\n                if(arr[i]!=arr[index]) return arr[i];\\n                else i--;\\n            }\\n            return arr[index];\\n        }\\n    }\\n    private int closestRigt(int index, int[] arr) {\\n        if(arr[index+1]!=arr[index]) return arr[index+1];\\n        else {\\n            int i = index+1;\\n            while(i<arr.length){\\n                if(arr[i]!=arr[index]) return arr[i];\\n                else i++;\\n            }\\n            return arr[index];\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int countHillValley(int[] nums) {\\n        int ans = 0;\\n        for(int i=1 ; i<nums.length-1; i++){\\n            if(nums[i]==nums[i-1]) {continue;}\\n            int left = closestLeft(i,nums);\\n            int rigt = closestRigt(i,nums);\\n            if(left>nums[i] && rigt>nums[i]) ans++;\\n            if(left<nums[i] && rigt<nums[i]) ans++;\\n        }\\n        return ans;\\n    }\\n    private int closestLeft(int index, int[] arr) {\\n        if(arr[index-1]!=arr[index]) return arr[index-1];\\n        else {\\n            int i = index-1;\\n            while(i>0){\\n                if(arr[i]!=arr[index]) return arr[i];\\n                else i--;\\n            }\\n            return arr[index];\\n        }\\n    }\\n    private int closestRigt(int index, int[] arr) {\\n        if(arr[index+1]!=arr[index]) return arr[index+1];\\n        else {\\n            int i = index+1;\\n            while(i<arr.length){\\n                if(arr[i]!=arr[index]) return arr[i];\\n                else i++;\\n            }\\n            return arr[index];\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3782614,
                "title": "easy-c-solution",
                "content": "# Intuition\\nLook for closest left and right non-equal numbers\\n# Approach\\nSkip the equal numbers and look for hills and valleys by accessing closest left and right non-equal numbers. Make three variables l,m,r to denote left, middle and right values.\\n# Complexity\\n- Time complexity:\\nO(N)\\n- Space complexity:\\nO(1)\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int countHillValley(vector<int>& nums) {\\n        int count = 0;\\n        int l = 0;\\n        int m = 1;\\n        int r = 2;\\n        while(r<nums.size()){\\n            if((nums[l] > nums[m] && nums[r] > nums[m]) ||\\n                (nums[l] < nums[m] && nums[r] < nums[m])\\n            ){\\n                cout<<nums[l]<<\" \"<<nums[m]<<\" \"<<nums[r]<<endl;\\n                count++;\\n                r++;\\n                m++;\\n                l= m-1;\\n            }else if(nums[l]==nums[m]){\\n                r++;\\n                m++;\\n                l++;\\n            }else if(nums[r]==nums[m]){\\n                r++;\\n                m++;\\n            }else{\\n                r++;\\n                m++;\\n                l++;\\n            }\\n        }\\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int countHillValley(vector<int>& nums) {\\n        int count = 0;\\n        int l = 0;\\n        int m = 1;\\n        int r = 2;\\n        while(r<nums.size()){\\n            if((nums[l] > nums[m] && nums[r] > nums[m]) ||\\n                (nums[l] < nums[m] && nums[r] < nums[m])\\n            ){\\n                cout<<nums[l]<<\" \"<<nums[m]<<\" \"<<nums[r]<<endl;\\n                count++;\\n                r++;\\n                m++;\\n                l= m-1;\\n            }else if(nums[l]==nums[m]){\\n                r++;\\n                m++;\\n                l++;\\n            }else if(nums[r]==nums[m]){\\n                r++;\\n                m++;\\n            }else{\\n                r++;\\n                m++;\\n                l++;\\n            }\\n        }\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3780341,
                "title": "beats-100-memory-java-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int countHillValley(int[] nums) {         \\n         int left=-1;\\n         int count=0;\\n          for (int i=0;i<nums.length-1;i++){\\n            if(nums[i]==nums[i+1]){\\n              continue;\\n            }\\n            int right=nums[i+1];\\n            if(left!=-1 && nums[i]>left && nums[i]>right || nums[i]<left && nums[i]<right)\\n            {\\n                count++;\\n            }\\n\\n            left= nums[i];\\n        }\\n         return count;\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int countHillValley(int[] nums) {         \\n         int left=-1;\\n         int count=0;\\n          for (int i=0;i<nums.length-1;i++){\\n            if(nums[i]==nums[i+1]){\\n              continue;\\n            }\\n            int right=nums[i+1];\\n            if(left!=-1 && nums[i]>left && nums[i]>right || nums[i]<left && nums[i]<right)\\n            {\\n                count++;\\n            }\\n\\n            left= nums[i];\\n        }\\n         return count;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3778163,
                "title": "best-way-to-solve-problem-in-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int countHillValley(vector<int>& nums) {\\n        int i=0,count=0,hill=0,valley=0;\\n        for(int i=1;i<nums.size();i++){\\n            if(nums[i-1]<nums[i] && hill==0){\\n                hill=1;\\n                if(valley==1){\\n                count++;\\n                valley=0;\\n                }\\n            }\\n             else if(nums[i-1]>nums[i] && valley==0)\\n            {\\n                valley=1;\\n                if(hill==1){\\n                count++;\\n                hill=0;\\n                }\\n            }\\n        }\\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int countHillValley(vector<int>& nums) {\\n        int i=0,count=0,hill=0,valley=0;\\n        for(int i=1;i<nums.size();i++){\\n            if(nums[i-1]<nums[i] && hill==0){\\n                hill=1;\\n                if(valley==1){\\n                count++;\\n                valley=0;\\n                }\\n            }\\n             else if(nums[i-1]>nums[i] && valley==0)\\n            {\\n                valley=1;\\n                if(hill==1){\\n                count++;\\n                hill=0;\\n                }\\n            }\\n        }\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3773052,
                "title": "python-3-solution",
                "content": "we first create a new list with no same element in adjacent indices.That will make our calculation easier.and then just by basic comparision with the previous and former element we can calculate the ans.This logic is easy to understand for the beginners.thank you .Happy Coding. If u like this solution plz give an upvote\\n\\n\\n\\n```\\nclass Solution:\\n    def countHillValley(self, nums: List[int]) -> int:\\n        num1=[]\\n        nums.append(0)\\n        \\n        c=0\\n        for i in range (len(nums)-1):\\n            if(nums[i]!=nums[i+1]):\\n                num1.append(nums[i])\\n                \\n                \\n        for i in range(1,len(num1)-1):\\n            if(num1[i]>num1[i+1] and num1[i]>num1[i-1]):\\n                c+=1\\n            elif(num1[i]<num1[i+1] and num1[i]<num1[i-1]):\\n                c+=1\\n            else:\\n                continue\\n        return c\\n            \\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def countHillValley(self, nums: List[int]) -> int:\\n        num1=[]\\n        nums.append(0)\\n        \\n        c=0\\n        for i in range (len(nums)-1):\\n            if(nums[i]!=nums[i+1]):\\n                num1.append(nums[i])\\n                \\n                \\n        for i in range(1,len(num1)-1):\\n            if(num1[i]>num1[i+1] and num1[i]>num1[i-1]):\\n                c+=1\\n            elif(num1[i]<num1[i+1] and num1[i]<num1[i-1]):\\n                c+=1\\n            else:\\n                continue\\n        return c\\n            \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3761858,
                "title": "c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int countHillValley(vector<int>& nums) {\\n        int result = 0;\\n        int idxXtrmStart = 1;\\n        int idxXtrmEnd = idxXtrmStart;\\n        while (idxXtrmEnd < (nums.size() - 1))\\n        {\\n            while ((idxXtrmEnd < (nums.size() - 2)) &&\\n                    (nums[idxXtrmEnd] == nums[idxXtrmEnd+1]))\\n            {\\n                idxXtrmEnd++;\\n            }\\n            if ( ((nums[idxXtrmStart] > nums[idxXtrmStart - 1]) \\n                    && (nums[idxXtrmEnd] > nums[idxXtrmEnd + 1])) ||\\n                 ((nums[idxXtrmStart] < nums[idxXtrmStart - 1]) \\n                    && (nums[idxXtrmEnd] < nums[idxXtrmEnd + 1])))\\n            {\\n                result++;\\n            }\\n            idxXtrmStart = idxXtrmEnd + 1;\\n            idxXtrmEnd = idxXtrmStart;\\n        }\\n        return result;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int countHillValley(vector<int>& nums) {\\n        int result = 0;\\n        int idxXtrmStart = 1;\\n        int idxXtrmEnd = idxXtrmStart;\\n        while (idxXtrmEnd < (nums.size() - 1))\\n        {\\n            while ((idxXtrmEnd < (nums.size() - 2)) &&\\n                    (nums[idxXtrmEnd] == nums[idxXtrmEnd+1]))\\n            {\\n                idxXtrmEnd++;\\n            }\\n            if ( ((nums[idxXtrmStart] > nums[idxXtrmStart - 1]) \\n                    && (nums[idxXtrmEnd] > nums[idxXtrmEnd + 1])) ||\\n                 ((nums[idxXtrmStart] < nums[idxXtrmStart - 1]) \\n                    && (nums[idxXtrmEnd] < nums[idxXtrmEnd + 1])))\\n            {\\n                result++;\\n            }\\n            idxXtrmStart = idxXtrmEnd + 1;\\n            idxXtrmEnd = idxXtrmStart;\\n        }\\n        return result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3754852,
                "title": "easy-to-understand-java-beginner-s-need",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int countHillValley(int[] nums) {\\n        int prev=nums[0];\\n        int count=0,j=0,i=0;\\n        int[] temp=new int[nums.length];\\n        for( i=0;i<nums.length-1;i++)\\n        {\\nif(nums[i]==nums[i+1])\\ncontinue;\\ntemp[j++]=nums[i];\\n        }\\n        temp[j]=nums[i];\\n        for(int k=1;k<j;k++)\\n        {\\n     if(temp[k]<temp[k-1] && temp[k]<temp[k+1])\\n    count++;\\n    if(temp[k]>temp[k-1] && temp[k]>temp[k+1])\\n    count++;\\n        }\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int countHillValley(int[] nums) {\\n        int prev=nums[0];\\n        int count=0,j=0,i=0;\\n        int[] temp=new int[nums.length];\\n        for( i=0;i<nums.length-1;i++)\\n        {\\nif(nums[i]==nums[i+1])\\ncontinue;\\ntemp[j++]=nums[i];\\n        }\\n        temp[j]=nums[i];\\n        for(int k=1;k<j;k++)\\n        {\\n     if(temp[k]<temp[k-1] && temp[k]<temp[k+1])\\n    count++;\\n    if(temp[k]>temp[k-1] && temp[k]>temp[k+1])\\n    count++;\\n        }\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3750511,
                "title": "solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {number[]} nums\\n * @return {number}\\n */\\nvar countHillValley = function(nums) {\\n        // if current >= left && current >= right => hill\\n        // current <= left && current <= right => valley;\\n\\n        let count = 0;\\n        let lastElement = 0;\\n        let current = nums[0];\\n        let lst = [current];\\n\\n        for(let i=1;i<nums.length;i++){\\n            if (current != nums[i])lst.push(nums[i]);\\n            current = nums[i];\\n        }\\n        \\n\\n        for(let i=0;i<lst.length-1;i++){\\n            let current = lst[i];\\n            if (current >= lst[i-1] && current >= lst[i+1])count+=1;\\n            else if (current <= lst[i-1] && current <= lst[i+1])count+=1;            \\n        }\\n\\n        return count;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} nums\\n * @return {number}\\n */\\nvar countHillValley = function(nums) {\\n        // if current >= left && current >= right => hill\\n        // current <= left && current <= right => valley;\\n\\n        let count = 0;\\n        let lastElement = 0;\\n        let current = nums[0];\\n        let lst = [current];\\n\\n        for(let i=1;i<nums.length;i++){\\n            if (current != nums[i])lst.push(nums[i]);\\n            current = nums[i];\\n        }\\n        \\n\\n        for(let i=0;i<lst.length-1;i++){\\n            let current = lst[i];\\n            if (current >= lst[i-1] && current >= lst[i+1])count+=1;\\n            else if (current <= lst[i-1] && current <= lst[i+1])count+=1;            \\n        }\\n\\n        return count;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3748747,
                "title": "java-easy-solution-0-n",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int countHillValley(int[] nums) {\\n      int hill=0;\\n      int valley=0;\\n      int j=0;\\n      for(int i=1;i<nums.length-1;i++)\\n      {\\n          if(nums[j]<nums[i] && nums[i]>nums[i+1])\\n          {\\n              hill++;\\n              j=i;\\n          }\\n          if(nums[j]>nums[i] && nums[i]<nums[i+1])\\n          {\\n              valley++;\\n              j=i;\\n          }\\n      }  \\n      return hill+valley;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int countHillValley(int[] nums) {\\n      int hill=0;\\n      int valley=0;\\n      int j=0;\\n      for(int i=1;i<nums.length-1;i++)\\n      {\\n          if(nums[j]<nums[i] && nums[i]>nums[i+1])\\n          {\\n              hill++;\\n              j=i;\\n          }\\n          if(nums[j]>nums[i] && nums[i]<nums[i+1])\\n          {\\n              valley++;\\n              j=i;\\n          }\\n      }  \\n      return hill+valley;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3748746,
                "title": "java-easy-solution-0-n",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int countHillValley(int[] nums) {\\n      int hill=0;\\n      int valley=0;\\n      int j=0;\\n      for(int i=1;i<nums.length-1;i++)\\n      {\\n          if(nums[j]<nums[i] && nums[i]>nums[i+1])\\n          {\\n              hill++;\\n              j=i;\\n          }\\n          if(nums[j]>nums[i] && nums[i]<nums[i+1])\\n          {\\n              valley++;\\n              j=i;\\n          }\\n      }  \\n      return hill+valley;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int countHillValley(int[] nums) {\\n      int hill=0;\\n      int valley=0;\\n      int j=0;\\n      for(int i=1;i<nums.length-1;i++)\\n      {\\n          if(nums[j]<nums[i] && nums[i]>nums[i+1])\\n          {\\n              hill++;\\n              j=i;\\n          }\\n          if(nums[j]>nums[i] && nums[i]<nums[i+1])\\n          {\\n              valley++;\\n              j=i;\\n          }\\n      }  \\n      return hill+valley;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3730058,
                "title": "using-java",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n     public int countHillValley(int[] a){\\n        int r = 0, left = a[0];\\n        for(int i = 1; i < a.length - 1; i++)\\n            if(left < a[i] && a[i] > a[i + 1] || left > a[i] && a[i] < a[i + 1]){\\n                r++;\\n                left = a[i];\\n            }\\n        return r;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n     public int countHillValley(int[] a){\\n        int r = 0, left = a[0];\\n        for(int i = 1; i < a.length - 1; i++)\\n            if(left < a[i] && a[i] > a[i + 1] || left > a[i] && a[i] < a[i + 1]){\\n                r++;\\n                left = a[i];\\n            }\\n        return r;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3728749,
                "title": "best-solution-in-o-n-time-and-space-complexity-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach \\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int countHillValley(vector<int>& nums) {\\n        int count=0;\\n\\n        vector<int> arr{nums[0]};\\n        \\n        for(int i=1; i<nums.size(); i++){\\n            if(nums[i-1]!=nums[i]){\\n                arr.push_back(nums[i]);\\n            }\\n        }\\n\\n        for(int i=1; i<arr.size()-1; i++){\\n            if(arr[i] > arr[i+1] && arr[i] > arr[i-1]) count++;\\n\\n            else if(arr[i] <arr[i+1] && arr[i]<arr[i-1]) count++;\\n\\n\\n        }\\n\\n        return count;\\n\\n        \\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int countHillValley(vector<int>& nums) {\\n        int count=0;\\n\\n        vector<int> arr{nums[0]};\\n        \\n        for(int i=1; i<nums.size(); i++){\\n            if(nums[i-1]!=nums[i]){\\n                arr.push_back(nums[i]);\\n            }\\n        }\\n\\n        for(int i=1; i<arr.size()-1; i++){\\n            if(arr[i] > arr[i+1] && arr[i] > arr[i-1]) count++;\\n\\n            else if(arr[i] <arr[i+1] && arr[i]<arr[i-1]) count++;\\n\\n\\n        }\\n\\n        return count;\\n\\n        \\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3724501,
                "title": "java-simple-readable",
                "content": "Code is self explanatory, but feel free to ask questions\\n>**T/S:** O(n)/O(1), where n = size(nums)\\n```\\npublic int countHillValley(int[] nums) {\\n\\tvar hilleys = 0;\\n\\tvar prev = nums[0];\\n\\n\\tfor (var i = 1; i + 1 < nums.length; i++) {\\n\\t\\tif (nums[i] == prev)\\n\\t\\t\\tcontinue;\\n\\n\\t\\tvar isHill = prev < nums[i] && nums[i] > nums[i + 1];\\n\\t\\tvar isValley = prev > nums[i] && nums[i] < nums[i + 1];\\n\\n\\t\\tif (isHill || isValley)\\n\\t\\t\\thilleys++;\\n\\t\\tif (nums[i] != nums[i + 1])\\n\\t\\t\\tprev = nums[i];\\n\\t}\\n\\n\\treturn hilleys;\\n}\\n```\\n***Please upvote if this helps***",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\npublic int countHillValley(int[] nums) {\\n\\tvar hilleys = 0;\\n\\tvar prev = nums[0];\\n\\n\\tfor (var i = 1; i + 1 < nums.length; i++) {\\n\\t\\tif (nums[i] == prev)\\n\\t\\t\\tcontinue;\\n\\n\\t\\tvar isHill = prev < nums[i] && nums[i] > nums[i + 1];\\n\\t\\tvar isValley = prev > nums[i] && nums[i] < nums[i + 1];\\n\\n\\t\\tif (isHill || isValley)\\n\\t\\t\\thilleys++;\\n\\t\\tif (nums[i] != nums[i + 1])\\n\\t\\t\\tprev = nums[i];\\n\\t}\\n\\n\\treturn hilleys;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3721426,
                "title": "2-pointers",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int countHillValley(int[] nums) {\\n        int count= 0, left = nums[0];\\n        for(int i = 1; i < nums.length - 1; i++)\\n            if(left < nums[i] && nums[i] > nums[i + 1] || left > nums[i] && nums[i] < nums[i + 1]){\\n                count++;\\n                left = nums[i];\\n            }\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int countHillValley(int[] nums) {\\n        int count= 0, left = nums[0];\\n        for(int i = 1; i < nums.length - 1; i++)\\n            if(left < nums[i] && nums[i] > nums[i + 1] || left > nums[i] && nums[i] < nums[i + 1]){\\n                count++;\\n                left = nums[i];\\n            }\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3711856,
                "title": "java-easy-solution-0ms-beats-100",
                "content": "\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n    Mantain a pointer for the leftmost element of a hill or a valley\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n    O(n)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n    O(1)\\n# Code\\n```\\nclass Solution {\\n    public int countHillValley(int[] nums) {\\n        int pointer=nums[0];\\n        int count=0;\\n        for(int i=1;i<nums.length-1;i++){\\n            if( (pointer<nums[i] && nums[i]>nums[i+1]) || (nums[i]<pointer && nums[i]<nums[i+1]) ){\\n                count++;\\n                pointer=nums[i];\\n            }\\n        }\\n        return count;\\n    }\\n//commment if you like the solution\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array"
                ],
                "code": "```\\nclass Solution {\\n    public int countHillValley(int[] nums) {\\n        int pointer=nums[0];\\n        int count=0;\\n        for(int i=1;i<nums.length-1;i++){\\n            if( (pointer<nums[i] && nums[i]>nums[i+1]) || (nums[i]<pointer && nums[i]<nums[i+1]) ){\\n                count++;\\n                pointer=nums[i];\\n            }\\n        }\\n        return count;\\n    }\\n//commment if you like the solution\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3704360,
                "title": "easy-python-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def countHillValley(self, nums: List[int]) -> int:\\n        counter = 0\\n        temp = nums[0]\\n        for ind, i in enumerate(nums[1:-1], start=1):\\n            if i < temp and i < nums[ind + 1] or i > temp and i > nums[ind+1]:\\n                counter += 1\\n                temp = i\\n        return counter       \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def countHillValley(self, nums: List[int]) -> int:\\n        counter = 0\\n        temp = nums[0]\\n        for ind, i in enumerate(nums[1:-1], start=1):\\n            if i < temp and i < nums[ind + 1] or i > temp and i > nums[ind+1]:\\n                counter += 1\\n                temp = i\\n        return counter       \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3696321,
                "title": "simple-javascript-solution",
                "content": "\\n# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {number[]} nums\\n * @return {number}\\n */\\nvar countHillValley = function(nums) {\\n        let diff = nums[1] - nums[0];\\n        let currDiff = 0;\\n        let count = 0;\\n        for(let i = 2; i < nums.length; i++) {\\n            currDiff = nums[i] - nums[i - 1];\\n            if(currDiff != 0) {\\n                if(currDiff * diff < 0) count++;\\n                diff = currDiff;\\n            }\\n        }\\n        return count;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} nums\\n * @return {number}\\n */\\nvar countHillValley = function(nums) {\\n        let diff = nums[1] - nums[0];\\n        let currDiff = 0;\\n        let count = 0;\\n        for(let i = 2; i < nums.length; i++) {\\n            currDiff = nums[i] - nums[i - 1];\\n            if(currDiff != 0) {\\n                if(currDiff * diff < 0) count++;\\n                diff = currDiff;\\n            }\\n        }\\n        return count;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3690943,
                "title": "c-easy-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nRemove adjecent duplicates and apply the condition \\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\no(1)\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int countHillValley(vector<int>& nums) {\\n        vector<int> res;\\n        res.push_back(nums[0]);\\n        for(int i=1;i<nums.size();i++){\\n            if(nums[i]!=nums[i-1]){\\n                res.push_back(nums[i]);\\n            }\\n        }\\n        nums.clear();\\n      \\n        int count=0;\\n        for(int i=2;i<res.size();i++){\\n            if(res[i-2]>res[i-1] && res[i-1]<res[i]){\\n                count++;\\n            }\\n            else if(res[i-2]<res[i-1] && res[i-1]>res[i]){\\n                count++;\\n            }\\n        }\\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int countHillValley(vector<int>& nums) {\\n        vector<int> res;\\n        res.push_back(nums[0]);\\n        for(int i=1;i<nums.size();i++){\\n            if(nums[i]!=nums[i-1]){\\n                res.push_back(nums[i]);\\n            }\\n        }\\n        nums.clear();\\n      \\n        int count=0;\\n        for(int i=2;i<res.size();i++){\\n            if(res[i-2]>res[i-1] && res[i-1]<res[i]){\\n                count++;\\n            }\\n            else if(res[i-2]<res[i-1] && res[i-1]>res[i]){\\n                count++;\\n            }\\n        }\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3689763,
                "title": "scala-solution",
                "content": "# Code\\n```\\nobject Solution {\\n    def countHillValley(list: Array[Int]): Int = {\\n    var i = 0\\n      var count: Int = 0\\n      while (i < list.length - 1) {\\n        val leftNonEqual = (i - 1 to 0 by -1).collectFirst { case x if list(x) != list(i) => x }\\n        val rightNonEqual = (i + 1 until list.length).collectFirst { case x if list(x) != list(i) => x }\\n\\n        val isHillOrValley = for {\\n          left <- leftNonEqual\\n          right <- rightNonEqual\\n        } yield (list(left) < list(i) && list(i) > list(right)) || (list(left) > list(i) && list(i) < list(right))\\n\\n        i = rightNonEqual.getOrElse(i + 1)\\n        count += (isHillOrValley match {\\n          case Some(true) => 1\\n          case _ => 0\\n        })\\n      }\\n\\n      count\\n    }\\n}\\n```",
                "solutionTags": [
                    "Scala"
                ],
                "code": "```\\nobject Solution {\\n    def countHillValley(list: Array[Int]): Int = {\\n    var i = 0\\n      var count: Int = 0\\n      while (i < list.length - 1) {\\n        val leftNonEqual = (i - 1 to 0 by -1).collectFirst { case x if list(x) != list(i) => x }\\n        val rightNonEqual = (i + 1 until list.length).collectFirst { case x if list(x) != list(i) => x }\\n\\n        val isHillOrValley = for {\\n          left <- leftNonEqual\\n          right <- rightNonEqual\\n        } yield (list(left) < list(i) && list(i) > list(right)) || (list(left) > list(i) && list(i) < list(right))\\n\\n        i = rightNonEqual.getOrElse(i + 1)\\n        count += (isHillOrValley match {\\n          case Some(true) => 1\\n          case _ => 0\\n        })\\n      }\\n\\n      count\\n    }\\n}\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3688446,
                "title": "easy-c-for-beginner",
                "content": "\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(N2) as for every element we are traversing the array for left and right in worst case it can go n2\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1) as we are not using any as such space\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int countHillValley(vector<int>& nums) {\\n        int ans = 0;\\n        int n = nums.size();\\n\\n        for(int i=1;i<n-1;i++){\\n            // if same hill\\n            if(nums[i] == nums[i+1])continue;\\n\\n            // else find the first left index which is not equal\\n            int j = i-1;\\n            int left = -1;\\n            while(j >= 0){\\n                if(nums[j] != nums[i]){\\n                    left = nums[j];\\n                    break;\\n                }\\n                j--;\\n            }\\n\\n            // also find the first right index which is not equal\\n            j=i+1;\\n            int right = -1;\\n            while(j < n){\\n                if(nums[j] != nums[i]){\\n                    right = nums[j];\\n                    break;\\n                }\\n                j++;\\n            }\\n\\n            // if u have both left and right available i.e != -1 then check for hill or valley and increase the ans\\n            if(left != -1 and right != -1 and nums[i] > left and nums[i] > right)ans++;\\n            else if(left != -1 and right != -1 and nums[i] < left and nums[i] < right)ans++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int countHillValley(vector<int>& nums) {\\n        int ans = 0;\\n        int n = nums.size();\\n\\n        for(int i=1;i<n-1;i++){\\n            // if same hill\\n            if(nums[i] == nums[i+1])continue;\\n\\n            // else find the first left index which is not equal\\n            int j = i-1;\\n            int left = -1;\\n            while(j >= 0){\\n                if(nums[j] != nums[i]){\\n                    left = nums[j];\\n                    break;\\n                }\\n                j--;\\n            }\\n\\n            // also find the first right index which is not equal\\n            j=i+1;\\n            int right = -1;\\n            while(j < n){\\n                if(nums[j] != nums[i]){\\n                    right = nums[j];\\n                    break;\\n                }\\n                j++;\\n            }\\n\\n            // if u have both left and right available i.e != -1 then check for hill or valley and increase the ans\\n            if(left != -1 and right != -1 and nums[i] > left and nums[i] > right)ans++;\\n            else if(left != -1 and right != -1 and nums[i] < left and nums[i] < right)ans++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3686323,
                "title": "c-single-pass-elegant-clean-easy-o-1-space-o-n-time",
                "content": "# Intuition\\nIncrement the count in case: \\n    - When we are at the hill and if we have already seen the valley in the past. \\n    - When we are at the Valley and if we have already seen the Hill in the past. \\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\nO(N)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    // last_pos = 0  --> Initial position\\n    // last_pos = 1  --> At the Hill.\\n    // last_pos = 2  --> At the Valley.\\n\\n    #define START   0\\n    #define HILL    1\\n    #define VALLEY  2\\n    int countHillValley(vector<int>& nums) {\\n        int count = 0, last_pos = START;\\n        for (int i = 1; i < nums.size(); i++) {\\n            if (nums[i] > nums[i - 1]) {\\n                count += (last_pos == VALLEY ? 1 : 0);\\n                last_pos = HILL;\\n            } else if (nums[i] < nums[i - 1]) {\\n                count += (last_pos == HILL ? 1 : 0);\\n                last_pos = VALLEY;\\n            }\\n       }\\n       return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    // last_pos = 0  --> Initial position\\n    // last_pos = 1  --> At the Hill.\\n    // last_pos = 2  --> At the Valley.\\n\\n    #define START   0\\n    #define HILL    1\\n    #define VALLEY  2\\n    int countHillValley(vector<int>& nums) {\\n        int count = 0, last_pos = START;\\n        for (int i = 1; i < nums.size(); i++) {\\n            if (nums[i] > nums[i - 1]) {\\n                count += (last_pos == VALLEY ? 1 : 0);\\n                last_pos = HILL;\\n            } else if (nums[i] < nums[i - 1]) {\\n                count += (last_pos == HILL ? 1 : 0);\\n                last_pos = VALLEY;\\n            }\\n       }\\n       return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3678492,
                "title": "easy-o-n-c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int countHillValley(vector<int>& nums) {\\n        int ct=0,n=nums.size();\\n        vector<int> dp1(n,-1),dp2(n,-1);\\n        for(int i=1;i<n;i++){\\n            if(nums[i]==nums[i-1]) dp1[i]=dp1[i-1];\\n            else dp1[i]=nums[i-1];\\n        }\\n        for(int i=n-2;i>=0;i--){\\n            if(nums[i]==nums[i+1]) dp2[i]=dp2[i+1];\\n            else dp2[i]=nums[i+1];\\n        }\\n        for(int i=1;i<n-1;i++){\\n            if(dp1[i]!=-1 && dp2[i]!=-1 && nums[i]>dp1[i] && nums[i]>dp2[i] && nums[i]!=nums[i-1]) ct++;\\n            if(dp1[i]!=-1 && dp2[i]!=-1 && nums[i]<dp1[i] && nums[i]<dp2[i] && nums[i]!=nums[i-1]) ct++;\\n        }\\n        return ct;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int countHillValley(vector<int>& nums) {\\n        int ct=0,n=nums.size();\\n        vector<int> dp1(n,-1),dp2(n,-1);\\n        for(int i=1;i<n;i++){\\n            if(nums[i]==nums[i-1]) dp1[i]=dp1[i-1];\\n            else dp1[i]=nums[i-1];\\n        }\\n        for(int i=n-2;i>=0;i--){\\n            if(nums[i]==nums[i+1]) dp2[i]=dp2[i+1];\\n            else dp2[i]=nums[i+1];\\n        }\\n        for(int i=1;i<n-1;i++){\\n            if(dp1[i]!=-1 && dp2[i]!=-1 && nums[i]>dp1[i] && nums[i]>dp2[i] && nums[i]!=nums[i-1]) ct++;\\n            if(dp1[i]!=-1 && dp2[i]!=-1 && nums[i]<dp1[i] && nums[i]<dp2[i] && nums[i]!=nums[i-1]) ct++;\\n        }\\n        return ct;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3676413,
                "title": "easy-c-solution-beginner-friendly-two-pointer-tail-pointer-approach",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int countHillValley(vector<int>& nums) {\\n    int ans = 0;\\n    for (int i=1, j=0; i<nums.size()-1; i++)\\n        if((nums[j]<nums[i] && nums[i]>nums[i+1]) || (nums[j]>nums[i] && nums[i]<nums[i+1]))\\n        {\\n            ans++;\\n            j = i;\\n        }            \\n    return ans;\\n}\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int countHillValley(vector<int>& nums) {\\n    int ans = 0;\\n    for (int i=1, j=0; i<nums.size()-1; i++)\\n        if((nums[j]<nums[i] && nums[i]>nums[i+1]) || (nums[j]>nums[i] && nums[i]<nums[i+1]))\\n        {\\n            ans++;\\n            j = i;\\n        }            \\n    return ans;\\n}\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3671491,
                "title": "c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(n*n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int countHillValley(vector<int>& nums) {\\n        int ans = 0;\\n\\n        for (int i=1 ; i<nums.size()-1 ; i++){\\n            int left=-1 , right=-1;\\n            int j=i-1 ; \\n            while (j>=0){\\n                if (nums[j] != nums[i]){\\n                    left = j;\\n                    break;\\n                }\\n                j--;\\n            }\\n\\n            j = i+1;\\n            while (j<nums.size()){\\n                if (nums[j] != nums[i]){\\n                    right = j;\\n                    break;\\n                }\\n                j++;\\n            }\\n            if (left == -1 || right == -1)\\n                continue;\\n\\n            if (nums[i]>max(nums[left] , nums[right]) || nums[i]<min(nums[left] , nums[right])){    \\n                if (nums[i] != nums[i-1]) {\\n                    ans++;\\n                }\\n            }\\n        }    \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int countHillValley(vector<int>& nums) {\\n        int ans = 0;\\n\\n        for (int i=1 ; i<nums.size()-1 ; i++){\\n            int left=-1 , right=-1;\\n            int j=i-1 ; \\n            while (j>=0){\\n                if (nums[j] != nums[i]){\\n                    left = j;\\n                    break;\\n                }\\n                j--;\\n            }\\n\\n            j = i+1;\\n            while (j<nums.size()){\\n                if (nums[j] != nums[i]){\\n                    right = j;\\n                    break;\\n                }\\n                j++;\\n            }\\n            if (left == -1 || right == -1)\\n                continue;\\n\\n            if (nums[i]>max(nums[left] , nums[right]) || nums[i]<min(nums[left] , nums[right])){    \\n                if (nums[i] != nums[i-1]) {\\n                    ans++;\\n                }\\n            }\\n        }    \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3665297,
                "title": "1ms-solution-and-100-less-memory-ovecomplicated-solution-rust-tm-noob",
                "content": "# Code\\n```\\nimpl Solution {\\n    pub fn count_hill_valley(nums: Vec<i32>) -> i32 {\\n        let mut count: i32 = 0;\\n        let mut i: usize = 1;\\n        while i < nums.len()-1 {\\n            let mut temp_i: usize = i;\\n            let mut what: u8 = 0;\\n            // o: neither, 1: hill, 2: valley\\n            while temp_i > 0{\\n                temp_i -= 1;\\n                if nums[i] < nums[temp_i]{\\n                    what = 2; // valley\\n                    break;\\n                }\\n                if nums[i] > nums[temp_i]{\\n                    what = 1; // hill\\n                    break;\\n                }\\n                what = 0;\\n                if temp_i == 0 {break;}\\n            }\\n            if what == 0 {\\n                i += 1;\\n                continue;\\n            }\\n            let mut temp_i: usize = i;\\n            while temp_i < nums.len(){\\n                temp_i += 1;\\n                if what == 2 && nums[i] < nums[temp_i]{\\n                    count += 1;\\n                    i = temp_i;\\n                    break;\\n                }\\n                if what == 1 && nums[i] > nums[temp_i]{\\n                    count += 1;\\n                    i = temp_i;\\n                    break;\\n                }\\n                what = 0;\\n            }\\n            if what == 0  {i += 1;}\\n        }\\n\\n        count\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust",
                    "Array"
                ],
                "code": "```\\nimpl Solution {\\n    pub fn count_hill_valley(nums: Vec<i32>) -> i32 {\\n        let mut count: i32 = 0;\\n        let mut i: usize = 1;\\n        while i < nums.len()-1 {\\n            let mut temp_i: usize = i;\\n            let mut what: u8 = 0;\\n            // o: neither, 1: hill, 2: valley\\n            while temp_i > 0{\\n                temp_i -= 1;\\n                if nums[i] < nums[temp_i]{\\n                    what = 2; // valley\\n                    break;\\n                }\\n                if nums[i] > nums[temp_i]{\\n                    what = 1; // hill\\n                    break;\\n                }\\n                what = 0;\\n                if temp_i == 0 {break;}\\n            }\\n            if what == 0 {\\n                i += 1;\\n                continue;\\n            }\\n            let mut temp_i: usize = i;\\n            while temp_i < nums.len(){\\n                temp_i += 1;\\n                if what == 2 && nums[i] < nums[temp_i]{\\n                    count += 1;\\n                    i = temp_i;\\n                    break;\\n                }\\n                if what == 1 && nums[i] > nums[temp_i]{\\n                    count += 1;\\n                    i = temp_i;\\n                    break;\\n                }\\n                what = 0;\\n            }\\n            if what == 0  {i += 1;}\\n        }\\n\\n        count\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3656200,
                "title": "c-easy",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int countHillValley(vector<int>& nums) {\\n        int c=0;\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            int j=i-1,k=i+1;\\n            while(j>=0 && nums[j]==nums[i]) j--;\\n            while(k<nums.size() && nums[k]==nums[i]) k++;\\n            if(j>=0 && k<nums.size())\\n            {\\n                if(nums[i]>nums[j] && nums[i]>nums[k]) c++;\\n                if(nums[i]<nums[j] && nums[i]<nums[k]) c++;\\n                i=k-1;\\n            }\\n        }\\n        return c;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int countHillValley(vector<int>& nums) {\\n        int c=0;\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            int j=i-1,k=i+1;\\n            while(j>=0 && nums[j]==nums[i]) j--;\\n            while(k<nums.size() && nums[k]==nums[i]) k++;\\n            if(j>=0 && k<nums.size())\\n            {\\n                if(nums[i]>nums[j] && nums[i]>nums[k]) c++;\\n                if(nums[i]<nums[j] && nums[i]<nums[k]) c++;\\n                i=k-1;\\n            }\\n        }\\n        return c;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3647317,
                "title": "php-two-pointers-solution",
                "content": "# Complexity\\n- Time complexity: O(n)\\n- Space complexity: O(1)\\n\\n# Code\\n```\\nclass Solution {\\n\\n    /**\\n     * @param Integer[] $nums\\n     * @return Integer\\n     */\\n    function countHillValley($nums) {\\n        $j = 0;\\n        $count = 0;\\n\\n        // Iterate through the array, excluding the first and last elements\\n        for($i = 1; $i < count($nums)-1; $i++) {\\n            \\n            // Check if the current element is part of a hill\\n            if($nums[$i] > $nums[$j] && $nums[$i] > $nums[$i + 1]) {\\n                $count++;\\n                $j = $i;\\n            }\\n            \\n            // Check if the current element is part of a valley\\n            if($nums[$i] < $nums[$j] && $nums[$i] < $nums[$i + 1]) {\\n                $count++;\\n                $j = $i;\\n            }\\n        }\\n\\n        return $count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "PHP",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution {\\n\\n    /**\\n     * @param Integer[] $nums\\n     * @return Integer\\n     */\\n    function countHillValley($nums) {\\n        $j = 0;\\n        $count = 0;\\n\\n        // Iterate through the array, excluding the first and last elements\\n        for($i = 1; $i < count($nums)-1; $i++) {\\n            \\n            // Check if the current element is part of a hill\\n            if($nums[$i] > $nums[$j] && $nums[$i] > $nums[$i + 1]) {\\n                $count++;\\n                $j = $i;\\n            }\\n            \\n            // Check if the current element is part of a valley\\n            if($nums[$i] < $nums[$j] && $nums[$i] < $nums[$i + 1]) {\\n                $count++;\\n                $j = $i;\\n            }\\n        }\\n\\n        return $count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3602803,
                "title": "eliminate-duplicates",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nEliminate Duplicates and check the condition for a hill or a valley. \\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\niterate over the array (after removing duplicates) and compare current elements with the one before and the one after and if the number is smaller than both or greater than both, increase the number of valleys/hills by one.\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\ntime: O(n)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nspace: O(n)\\n# Code\\n```\\nclass Solution:\\n    def countHillValley(self, nums: List[int]) -> int:\\n        res = [nums[0]]\\n        for x in nums[1:]:\\n            if x != res[-1]:\\n                res.append(x)\\n\\n        ans = 0\\n        for i in range(1, len(res) - 1):\\n            if (res[i] > res[i -1] and res[i] > res[i+1]\\n                or res[i] < res[i -1] and res[i] < res[i+1]):\\n                ans += 1    \\n\\n        return ans \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def countHillValley(self, nums: List[int]) -> int:\\n        res = [nums[0]]\\n        for x in nums[1:]:\\n            if x != res[-1]:\\n                res.append(x)\\n\\n        ans = 0\\n        for i in range(1, len(res) - 1):\\n            if (res[i] > res[i -1] and res[i] > res[i+1]\\n                or res[i] < res[i -1] and res[i] < res[i+1]):\\n                ans += 1    \\n\\n        return ans \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3597019,
                "title": "o-n-c-faster-than-100-submissions",
                "content": "```\\nclass Solution {\\npublic:\\n    int countHillValley(vector<int>& nums) {\\n      \\n int i=0,j=i+2;\\n int id=1;\\n   int count=0;\\n while(id<nums.size()-1){\\n   if(nums[id]==nums[j]){\\n     j++;\\n     id++;\\n     continue;\\n     }\\n   \\n     \\n   if(nums[i]<nums[id]&&nums[id]>nums[j])\\n  count++;\\n if(nums[i]>nums[id]&&nums[id]<nums[j])\\n\\n  count++;\\n     \\n \\n i=id,id++,j++;    \\n }    \\n     \\n  return count;\\n    }\\n};[](http://)\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int countHillValley(vector<int>& nums) {\\n      \\n int i=0,j=i+2;\\n int id=1;\\n   int count=0;\\n while(id<nums.size()-1){\\n   if(nums[id]==nums[j]){\\n     j++;\\n     id++;\\n     continue;\\n     }\\n   \\n     \\n   if(nums[i]<nums[id]&&nums[id]>nums[j])\\n  count++;\\n if(nums[i]>nums[id]&&nums[id]<nums[j])\\n\\n  count++;\\n     \\n \\n i=id,id++,j++;    \\n }    \\n     \\n  return count;\\n    }\\n};[](http://)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3590537,
                "title": "python-solution",
                "content": "# Code\\n```\\nclass Solution:\\n    def countHillValley(self, nums: List[int]) -> int:\\n        ans=0\\n        prev=0\\n        for i in range(1,len(nums)-1):\\n            curr=i\\n            if (nums[curr]<nums[prev] and nums[curr]<nums[curr+1]) or (nums[curr]>nums[curr+1] and nums[curr]>nums[prev]):\\n                ans+=1\\n                prev=curr\\n        return ans\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def countHillValley(self, nums: List[int]) -> int:\\n        ans=0\\n        prev=0\\n        for i in range(1,len(nums)-1):\\n            curr=i\\n            if (nums[curr]<nums[prev] and nums[curr]<nums[curr+1]) or (nums[curr]>nums[curr+1] and nums[curr]>nums[prev]):\\n                ans+=1\\n                prev=curr\\n        return ans\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3590450,
                "title": "count-hills-and-valleys-in-an-array-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int countHillValley(vector<int>& nums) {\\n\\n        vector<int> pre, suf;\\n        suf.push_back(0);\\n\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            for(int j=i+1;j<nums.size();j++)\\n            {\\n                if(nums[i]!=nums[j])\\n                {\\n                    pre.push_back(nums[j]);\\n                    break;\\n                }\\n                if(j==nums.size()-1)\\n                pre.push_back(0);\\n            }\\n        }\\n\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            for(int j=i-1;j>=0;j--)\\n            {\\n                if(nums[i]!=nums[j])\\n                {\\n                    suf.push_back(nums[j]);\\n                    break;\\n                }\\n                if(j==0)\\n                suf.push_back(0);\\n            }\\n        }\\n\\n        pre.push_back(0);\\n\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            cout<<pre[i]<<\" \"<<suf[i]<<endl;\\n        }\\n\\n        int hill=0;\\n\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            if(i==0 || i==nums.size()-1)\\n            continue;\\n\\n            cout<<\"nums=\"<<nums[i]<<\" pre=\"<<pre[i]<<\" suf=\"<<suf[i]<<endl;\\n            if(nums[i]==nums[i-1])\\n            continue;\\n\\n            if(nums[i]>pre[i] && nums[i]>suf[i] && pre[i]!=0 && suf[i]!=0)\\n            {hill++;\\n            cout<<hill<<endl;\\n            }\\n            else if(nums[i]<pre[i] && nums[i]<suf[i] && pre[i]!=0 && suf[i]!=0)\\n            {hill++;\\n            cout<<hill<<endl;}\\n        }\\n\\n        return hill;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int countHillValley(vector<int>& nums) {\\n\\n        vector<int> pre, suf;\\n        suf.push_back(0);\\n\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            for(int j=i+1;j<nums.size();j++)\\n            {\\n                if(nums[i]!=nums[j])\\n                {\\n                    pre.push_back(nums[j]);\\n                    break;\\n                }\\n                if(j==nums.size()-1)\\n                pre.push_back(0);\\n            }\\n        }\\n\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            for(int j=i-1;j>=0;j--)\\n            {\\n                if(nums[i]!=nums[j])\\n                {\\n                    suf.push_back(nums[j]);\\n                    break;\\n                }\\n                if(j==0)\\n                suf.push_back(0);\\n            }\\n        }\\n\\n        pre.push_back(0);\\n\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            cout<<pre[i]<<\" \"<<suf[i]<<endl;\\n        }\\n\\n        int hill=0;\\n\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            if(i==0 || i==nums.size()-1)\\n            continue;\\n\\n            cout<<\"nums=\"<<nums[i]<<\" pre=\"<<pre[i]<<\" suf=\"<<suf[i]<<endl;\\n            if(nums[i]==nums[i-1])\\n            continue;\\n\\n            if(nums[i]>pre[i] && nums[i]>suf[i] && pre[i]!=0 && suf[i]!=0)\\n            {hill++;\\n            cout<<hill<<endl;\\n            }\\n            else if(nums[i]<pre[i] && nums[i]<suf[i] && pre[i]!=0 && suf[i]!=0)\\n            {hill++;\\n            cout<<hill<<endl;}\\n        }\\n\\n        return hill;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3580508,
                "title": "beats-100-o-n-vector",
                "content": "\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->O(n)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->O(n)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int countHillValley(vector<int>& nums) {\\n        vector<int>v;\\n        v.push_back(nums[0]);\\n         for(int i=1;i<nums.size();i++)\\n         {\\n             if(nums[i]!=nums[i-1])\\n              v.push_back(nums[i]);\\n         }\\n         int count=0,i=1;\\n         while(i<v.size()-1)\\n         {\\n             if(v[i]<v[i-1]&&v[i]<v[i+1])\\n               count++;\\n             else if(v[i]>v[i-1]&&v[i]>v[i+1])  \\n                 count++;\\n            i++;     \\n         }\\n         return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int countHillValley(vector<int>& nums) {\\n        vector<int>v;\\n        v.push_back(nums[0]);\\n         for(int i=1;i<nums.size();i++)\\n         {\\n             if(nums[i]!=nums[i-1])\\n              v.push_back(nums[i]);\\n         }\\n         int count=0,i=1;\\n         while(i<v.size()-1)\\n         {\\n             if(v[i]<v[i-1]&&v[i]<v[i+1])\\n               count++;\\n             else if(v[i]>v[i-1]&&v[i]>v[i+1])  \\n                 count++;\\n            i++;     \\n         }\\n         return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3567207,
                "title": "beats-72-85-simple-solution-beginner-friendly",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int countHillValley(vector<int>& nums) {\\n        vector<int>ans;\\n        ans.push_back(nums[0]);\\n        for(int i=1;i<nums.size();i++){\\n            if(nums[i]!=nums[i-1]){\\n                ans.push_back(nums[i]);\\n            }\\n        }\\n        int count = 0;\\n        for(int i=1;i<ans.size()-1;i++){\\n            if(ans[i-1]>ans[i] && ans[i]<ans[i+1]){\\n                count ++;\\n            }\\n            else if(ans[i-1]<ans[i] && ans[i]>ans[i+1]){\\n                count ++;\\n            }\\n        }\\n        return count;\\n    }\\n}; \\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int countHillValley(vector<int>& nums) {\\n        vector<int>ans;\\n        ans.push_back(nums[0]);\\n        for(int i=1;i<nums.size();i++){\\n            if(nums[i]!=nums[i-1]){\\n                ans.push_back(nums[i]);\\n            }\\n        }\\n        int count = 0;\\n        for(int i=1;i<ans.size()-1;i++){\\n            if(ans[i-1]>ans[i] && ans[i]<ans[i+1]){\\n                count ++;\\n            }\\n            else if(ans[i-1]<ans[i] && ans[i]>ans[i+1]){\\n                count ++;\\n            }\\n        }\\n        return count;\\n    }\\n}; \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3550699,
                "title": "very-easy-to-read-python-solution-o-n-time-and-o-1-space",
                "content": "\\n# Complexity\\n- Time complexity: O(N) for iterating through nums once\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1) for constants\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def countHillValley(self, nums: List[int]) -> int:\\n        sum = 0\\n        # working with left, middle, and right and passing those values to the left in the loop\\n        # just storing indices\\n        m, r = 0, 1\\n        while True:\\n            # pass values from right to left\\n            l, m = m, r\\n\\n            # find right value and skip duplicates. The prior line passing down values makes it so the duplicates are skipped again.\\n            while r < len(nums)-1 and nums[r] == nums[m]: r += 1\\n\\n            # if left and right are greater than m. hill. OR left and right less than m. valley. increment sum\\n            if nums[l] > nums[m] and nums[r] > nums[m] or nums[l] < nums[m] and nums[r] < nums[m]: sum += 1\\n\\n            # if right has hit end of the list return sum\\n            if r == len(nums)-1: return sum\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def countHillValley(self, nums: List[int]) -> int:\\n        sum = 0\\n        # working with left, middle, and right and passing those values to the left in the loop\\n        # just storing indices\\n        m, r = 0, 1\\n        while True:\\n            # pass values from right to left\\n            l, m = m, r\\n\\n            # find right value and skip duplicates. The prior line passing down values makes it so the duplicates are skipped again.\\n            while r < len(nums)-1 and nums[r] == nums[m]: r += 1\\n\\n            # if left and right are greater than m. hill. OR left and right less than m. valley. increment sum\\n            if nums[l] > nums[m] and nums[r] > nums[m] or nums[l] < nums[m] and nums[r] < nums[m]: sum += 1\\n\\n            # if right has hit end of the list return sum\\n            if r == len(nums)-1: return sum\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3548284,
                "title": "simple-iteration-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n    O(N)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n    O(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int countHillValley(vector<int>& nums) {\\n        int count = 0;\\n        int left = nums[0], right;\\n        for(int i=1; i < nums.size()-1; i++){\\n            if(nums[i]==nums[i+1]) continue;\\n            right = nums[i + 1];\\n            if(left < nums[i] and right < nums[i] or left > nums[i] and right > nums[i]) count++;\\n            left = nums[i];\\n        }\\n        return count;\\n    }\\n};\\n```\\n```\\nclass Solution {\\npublic:\\n    int countHillValley(vector<int>& nums) {\\n        int count = 0;\\n        for(int i=1; i < nums.size()-1; i++){\\n            int left = -1, right = -1;\\n            if(nums[i]==nums[i-1]){\\n                int j = i - 1;\\n                while(j!=-1){\\n                    if(nums[i]!=nums[j]){\\n                        left = nums[j];\\n                        break;\\n                    }\\n                    j--;\\n                }\\n                if(left == -1) continue;\\n            }\\n            else left = nums[i-1];\\n\\n            if(nums[i]==nums[i+1]){\\n                int j = i + 1;\\n                while(j!=nums.size()){\\n                    if(nums[i]!=nums[j]){\\n                        right = nums[j];\\n                        break;\\n                    }\\n                    j++;\\n                }\\n                if(right == -1) continue;\\n            }\\n            else right = nums[i+1];\\n            if(((nums[i] < left and nums[i] < right) or (nums[i] > left and nums[i] > right)) and nums[i]!=nums[i-1]) count++;\\n        }\\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int countHillValley(vector<int>& nums) {\\n        int count = 0;\\n        int left = nums[0], right;\\n        for(int i=1; i < nums.size()-1; i++){\\n            if(nums[i]==nums[i+1]) continue;\\n            right = nums[i + 1];\\n            if(left < nums[i] and right < nums[i] or left > nums[i] and right > nums[i]) count++;\\n            left = nums[i];\\n        }\\n        return count;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int countHillValley(vector<int>& nums) {\\n        int count = 0;\\n        for(int i=1; i < nums.size()-1; i++){\\n            int left = -1, right = -1;\\n            if(nums[i]==nums[i-1]){\\n                int j = i - 1;\\n                while(j!=-1){\\n                    if(nums[i]!=nums[j]){\\n                        left = nums[j];\\n                        break;\\n                    }\\n                    j--;\\n                }\\n                if(left == -1) continue;\\n            }\\n            else left = nums[i-1];\\n\\n            if(nums[i]==nums[i+1]){\\n                int j = i + 1;\\n                while(j!=nums.size()){\\n                    if(nums[i]!=nums[j]){\\n                        right = nums[j];\\n                        break;\\n                    }\\n                    j++;\\n                }\\n                if(right == -1) continue;\\n            }\\n            else right = nums[i+1];\\n            if(((nums[i] < left and nums[i] < right) or (nums[i] > left and nums[i] > right)) and nums[i]!=nums[i-1]) count++;\\n        }\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3542126,
                "title": "nice-and-elegant-solution-in-java-beats-100-rt-and-98-memory",
                "content": "```\\nclass Solution {\\n    public int countHillValley(int[] nums) {\\n        int count = 0;\\n        for(int i = 1, j = 0, k = 2; i < nums.length - 1; i++, j++, k++) {\\n            boolean isTheSameHillOrValley = i > 1 && nums[i] == nums[i - 1];\\n            if (!isTheSameHillOrValley) {\\n                int l = nums[j], m = nums[i], r = nums[k];\\n                if (l == m) {\\n                    int index = j;\\n                    while (index > 0 && l == m) {\\n                        l = nums[--index];\\n                    }\\n                }\\n                if (r == m) {\\n                    int index = k;\\n                    while (index + 1 < nums.length && r == m) {\\n                        r = nums[++index];\\n                    }\\n                }\\n                if ((m > l && m > r) || (m < l && m < r)) {\\n                    count++;\\n                }\\n            }\\n        }\\n        return count;       \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Math"
                ],
                "code": "```\\nclass Solution {\\n    public int countHillValley(int[] nums) {\\n        int count = 0;\\n        for(int i = 1, j = 0, k = 2; i < nums.length - 1; i++, j++, k++) {\\n            boolean isTheSameHillOrValley = i > 1 && nums[i] == nums[i - 1];\\n            if (!isTheSameHillOrValley) {\\n                int l = nums[j], m = nums[i], r = nums[k];\\n                if (l == m) {\\n                    int index = j;\\n                    while (index > 0 && l == m) {\\n                        l = nums[--index];\\n                    }\\n                }\\n                if (r == m) {\\n                    int index = k;\\n                    while (index + 1 < nums.length && r == m) {\\n                        r = nums[++index];\\n                    }\\n                }\\n                if ((m > l && m > r) || (m < l && m < r)) {\\n                    count++;\\n                }\\n            }\\n        }\\n        return count;       \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3525060,
                "title": "trivial-c-beats-100",
                "content": "\\n```\\nclass Solution {\\npublic:\\n    int countHillValley(vector<int>& nums) {\\n        auto result = 0;\\n        for (auto l = 0, m = 1, r = 2; r < nums.size(); ++m, ++r) {\\n            if (nums[m] == nums[r]) continue;\\n            if (nums[l] > nums[m] && nums[m] < nums[r] || nums[l] < nums[m] && nums[m] > nums[r]) ++result;\\n            l = m;\\n        }\\n        return result;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int countHillValley(vector<int>& nums) {\\n        auto result = 0;\\n        for (auto l = 0, m = 1, r = 2; r < nums.size(); ++m, ++r) {\\n            if (nums[m] == nums[r]) continue;\\n            if (nums[l] > nums[m] && nums[m] < nums[r] || nums[l] < nums[m] && nums[m] > nums[r]) ++result;\\n            l = m;\\n        }\\n        return result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3515009,
                "title": "java-beats-100-solution",
                "content": "# Intuition -- Iteration over the array.\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach-- Iterating over the array and checking the conditions according to questions.\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:1\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int countHillValley(int[] nums) {\\n        int count =0;\\n        int left = nums[0];\\n        int end = nums[nums.length-1];\\n        int hill = 0;\\n        int valley=0; \\n        for(int i=1;i<nums.length-1;i++){\\n            if(nums[i]!=left && nums[i]>left && nums[i]>nums[i+1]){\\n                hill++;\\n                left=nums[i];\\n            }else if(nums[i]!=left && nums[i]<left && nums[i]<nums[i+1]){\\n                valley++;\\n                left=nums[i];\\n            }\\n            \\n        }\\n        return hill+valley;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array"
                ],
                "code": "```\\nclass Solution {\\n    public int countHillValley(int[] nums) {\\n        int count =0;\\n        int left = nums[0];\\n        int end = nums[nums.length-1];\\n        int hill = 0;\\n        int valley=0; \\n        for(int i=1;i<nums.length-1;i++){\\n            if(nums[i]!=left && nums[i]>left && nums[i]>nums[i+1]){\\n                hill++;\\n                left=nums[i];\\n            }else if(nums[i]!=left && nums[i]<left && nums[i]<nums[i+1]){\\n                valley++;\\n                left=nums[i];\\n            }\\n            \\n        }\\n        return hill+valley;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3483965,
                "title": "easy-java-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int countHillValley(int[] nums) {\\n        int val=nums[0];\\n        int count=0;\\n        for(int i=1;i<nums.length-1;i++){\\n            if((nums[i]>val&&nums[i]>nums[i+1])||(nums[i]<val&&nums[i]<nums[i+1])){\\n                count++;\\n                 val=nums[i];\\n            }\\n           \\n        }\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int countHillValley(int[] nums) {\\n        int val=nums[0];\\n        int count=0;\\n        for(int i=1;i<nums.length-1;i++){\\n            if((nums[i]>val&&nums[i]>nums[i+1])||(nums[i]<val&&nums[i]<nums[i+1])){\\n                count++;\\n                 val=nums[i];\\n            }\\n           \\n        }\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1846182,
                "content": [
                    {
                        "username": "rohit_adithya",
                        "content": "You can consider to `remove the adjacent equal values` first by transferring elements to another array which are `not equal to immediately preceding element`, which makes it easy to iterate from `second element` to `last second element` and checking the adjacent elements for a valley/hill."
                    },
                    {
                        "username": "yeedaKing",
                        "content": "i didn\\'t think of that.... I solved it by using the original nums array which made things a lot more complicated :("
                    },
                    {
                        "username": "Enkri_",
                        "content": "Feeling defeated by an easy question"
                    },
                    {
                        "username": "Enkri_",
                        "content": "[@curiosity_kids](/curiosity_kids) Thanks for the encouragement! I\\'m feeling defeated coz I\\'m not new to Leetcode and even tho I can solve medium problems, I found myself stuck at this easy one lol, granted that I have to work during the day and it\\'s hard for me to barely squeeze an hour a day to work on leetcode, but still I did fail to solve an easy question, sigh"
                    },
                    {
                        "username": "curiosity_kids",
                        "content": "I know the feeling, I had the same defeated feeling so, so many times in the last 3 months, but now I am much better than when I started, and as long as you continue to work, you will become better too.\\nAlso when I started these easy were no where easy, till you get more practice, you have to look at the solutions and start noting patterns and putting the methods in your toolkit, especially if you want to save time.\\nJust keep on working, it will get better! I can attest to this my own case."
                    },
                    {
                        "username": "JaspreetKaur_leetcode",
                        "content": "class Solution {\\n    public int countHillValley(int[] nums) {\\n        int counter=0;\\n        for(int i=1;i<nums.length-1;i++){\\n            int nearest_r=nearest_right_element(nums, i+1);\\n            int nearest_l=nearest_left_element(nums, i-1);\\n            if(nums[i]!=nums[i-1]){\\n                if((nearest_r !=-1 && nearest_l!=-1 && nums[i] < nearest_r && nums[i] < nearest_l) || \\n                (nearest_r !=-1 && nearest_l!=-1 && nums[i] > nearest_r && nums[i] > nearest_l)){\\n                    counter++;\\n                }\\n            }\\n        }\\n        return counter;\\n    }\\n\\n    public int nearest_right_element(int[] nums, int start){\\n        int nearest_r=-1;\\n        for(int i=start;i<nums.length;i++){\\n            if(nums[i]!=nums[start-1]){\\n                nearest_r=nums[i];\\n                break;\\n            }\\n        }\\n        return nearest_r;\\n    }\\n\\n    public int nearest_left_element(int[] nums, int destination){\\n        int nearest_l=-1;\\n        for(int i=destination;i>=0;i--){\\n            if(nums[i]!=nums[destination+1]){\\n                nearest_l=nums[i];\\n                break;\\n            }\\n        }\\n        return nearest_l;\\n    }\\n}"
                    },
                    {
                        "username": "geekyshark",
                        "content": "A good \\'easy\\' problem i would say, dont get demotivated if you weren\\'t able to come up with the solution, watch my solution for easy understanding"
                    },
                    {
                        "username": "Anonymous_user_79",
                        "content": "Beats 100% CPP Solution:\\n int countHillValley(vector<int>& nums) {\\n        int count=0, n=nums.size();\\n        for(int i=1;i<n-1;i++)\\n        {\\n            if(nums[i]==nums[i-1]) continue;\\n            int j=i-1,k=i+1;\\n\\n            while(k<n && nums[i]==nums[k]) k++;\\n\\n            if(k>=n) continue;\\n            if(nums[i]>nums[j] && nums[i]>nums[k]) count++;\\n            else if(nums[i]<nums[j] && nums[i]<nums[k]) count++;       \\n        }\\n        return count;\\n    }"
                    }
                ]
            },
            {
                "id": 1675543,
                "content": [
                    {
                        "username": "rohit_adithya",
                        "content": "You can consider to `remove the adjacent equal values` first by transferring elements to another array which are `not equal to immediately preceding element`, which makes it easy to iterate from `second element` to `last second element` and checking the adjacent elements for a valley/hill."
                    },
                    {
                        "username": "yeedaKing",
                        "content": "i didn\\'t think of that.... I solved it by using the original nums array which made things a lot more complicated :("
                    },
                    {
                        "username": "Enkri_",
                        "content": "Feeling defeated by an easy question"
                    },
                    {
                        "username": "Enkri_",
                        "content": "[@curiosity_kids](/curiosity_kids) Thanks for the encouragement! I\\'m feeling defeated coz I\\'m not new to Leetcode and even tho I can solve medium problems, I found myself stuck at this easy one lol, granted that I have to work during the day and it\\'s hard for me to barely squeeze an hour a day to work on leetcode, but still I did fail to solve an easy question, sigh"
                    },
                    {
                        "username": "curiosity_kids",
                        "content": "I know the feeling, I had the same defeated feeling so, so many times in the last 3 months, but now I am much better than when I started, and as long as you continue to work, you will become better too.\\nAlso when I started these easy were no where easy, till you get more practice, you have to look at the solutions and start noting patterns and putting the methods in your toolkit, especially if you want to save time.\\nJust keep on working, it will get better! I can attest to this my own case."
                    },
                    {
                        "username": "JaspreetKaur_leetcode",
                        "content": "class Solution {\\n    public int countHillValley(int[] nums) {\\n        int counter=0;\\n        for(int i=1;i<nums.length-1;i++){\\n            int nearest_r=nearest_right_element(nums, i+1);\\n            int nearest_l=nearest_left_element(nums, i-1);\\n            if(nums[i]!=nums[i-1]){\\n                if((nearest_r !=-1 && nearest_l!=-1 && nums[i] < nearest_r && nums[i] < nearest_l) || \\n                (nearest_r !=-1 && nearest_l!=-1 && nums[i] > nearest_r && nums[i] > nearest_l)){\\n                    counter++;\\n                }\\n            }\\n        }\\n        return counter;\\n    }\\n\\n    public int nearest_right_element(int[] nums, int start){\\n        int nearest_r=-1;\\n        for(int i=start;i<nums.length;i++){\\n            if(nums[i]!=nums[start-1]){\\n                nearest_r=nums[i];\\n                break;\\n            }\\n        }\\n        return nearest_r;\\n    }\\n\\n    public int nearest_left_element(int[] nums, int destination){\\n        int nearest_l=-1;\\n        for(int i=destination;i>=0;i--){\\n            if(nums[i]!=nums[destination+1]){\\n                nearest_l=nums[i];\\n                break;\\n            }\\n        }\\n        return nearest_l;\\n    }\\n}"
                    },
                    {
                        "username": "geekyshark",
                        "content": "A good \\'easy\\' problem i would say, dont get demotivated if you weren\\'t able to come up with the solution, watch my solution for easy understanding"
                    },
                    {
                        "username": "Anonymous_user_79",
                        "content": "Beats 100% CPP Solution:\\n int countHillValley(vector<int>& nums) {\\n        int count=0, n=nums.size();\\n        for(int i=1;i<n-1;i++)\\n        {\\n            if(nums[i]==nums[i-1]) continue;\\n            int j=i-1,k=i+1;\\n\\n            while(k<n && nums[i]==nums[k]) k++;\\n\\n            if(k>=n) continue;\\n            if(nums[i]>nums[j] && nums[i]>nums[k]) count++;\\n            else if(nums[i]<nums[j] && nums[i]<nums[k]) count++;       \\n        }\\n        return count;\\n    }"
                    }
                ]
            },
            {
                "id": 1974428,
                "content": [
                    {
                        "username": "rohit_adithya",
                        "content": "You can consider to `remove the adjacent equal values` first by transferring elements to another array which are `not equal to immediately preceding element`, which makes it easy to iterate from `second element` to `last second element` and checking the adjacent elements for a valley/hill."
                    },
                    {
                        "username": "yeedaKing",
                        "content": "i didn\\'t think of that.... I solved it by using the original nums array which made things a lot more complicated :("
                    },
                    {
                        "username": "Enkri_",
                        "content": "Feeling defeated by an easy question"
                    },
                    {
                        "username": "Enkri_",
                        "content": "[@curiosity_kids](/curiosity_kids) Thanks for the encouragement! I\\'m feeling defeated coz I\\'m not new to Leetcode and even tho I can solve medium problems, I found myself stuck at this easy one lol, granted that I have to work during the day and it\\'s hard for me to barely squeeze an hour a day to work on leetcode, but still I did fail to solve an easy question, sigh"
                    },
                    {
                        "username": "curiosity_kids",
                        "content": "I know the feeling, I had the same defeated feeling so, so many times in the last 3 months, but now I am much better than when I started, and as long as you continue to work, you will become better too.\\nAlso when I started these easy were no where easy, till you get more practice, you have to look at the solutions and start noting patterns and putting the methods in your toolkit, especially if you want to save time.\\nJust keep on working, it will get better! I can attest to this my own case."
                    },
                    {
                        "username": "JaspreetKaur_leetcode",
                        "content": "class Solution {\\n    public int countHillValley(int[] nums) {\\n        int counter=0;\\n        for(int i=1;i<nums.length-1;i++){\\n            int nearest_r=nearest_right_element(nums, i+1);\\n            int nearest_l=nearest_left_element(nums, i-1);\\n            if(nums[i]!=nums[i-1]){\\n                if((nearest_r !=-1 && nearest_l!=-1 && nums[i] < nearest_r && nums[i] < nearest_l) || \\n                (nearest_r !=-1 && nearest_l!=-1 && nums[i] > nearest_r && nums[i] > nearest_l)){\\n                    counter++;\\n                }\\n            }\\n        }\\n        return counter;\\n    }\\n\\n    public int nearest_right_element(int[] nums, int start){\\n        int nearest_r=-1;\\n        for(int i=start;i<nums.length;i++){\\n            if(nums[i]!=nums[start-1]){\\n                nearest_r=nums[i];\\n                break;\\n            }\\n        }\\n        return nearest_r;\\n    }\\n\\n    public int nearest_left_element(int[] nums, int destination){\\n        int nearest_l=-1;\\n        for(int i=destination;i>=0;i--){\\n            if(nums[i]!=nums[destination+1]){\\n                nearest_l=nums[i];\\n                break;\\n            }\\n        }\\n        return nearest_l;\\n    }\\n}"
                    },
                    {
                        "username": "geekyshark",
                        "content": "A good \\'easy\\' problem i would say, dont get demotivated if you weren\\'t able to come up with the solution, watch my solution for easy understanding"
                    },
                    {
                        "username": "Anonymous_user_79",
                        "content": "Beats 100% CPP Solution:\\n int countHillValley(vector<int>& nums) {\\n        int count=0, n=nums.size();\\n        for(int i=1;i<n-1;i++)\\n        {\\n            if(nums[i]==nums[i-1]) continue;\\n            int j=i-1,k=i+1;\\n\\n            while(k<n && nums[i]==nums[k]) k++;\\n\\n            if(k>=n) continue;\\n            if(nums[i]>nums[j] && nums[i]>nums[k]) count++;\\n            else if(nums[i]<nums[j] && nums[i]<nums[k]) count++;       \\n        }\\n        return count;\\n    }"
                    }
                ]
            },
            {
                "id": 1942903,
                "content": [
                    {
                        "username": "rohit_adithya",
                        "content": "You can consider to `remove the adjacent equal values` first by transferring elements to another array which are `not equal to immediately preceding element`, which makes it easy to iterate from `second element` to `last second element` and checking the adjacent elements for a valley/hill."
                    },
                    {
                        "username": "yeedaKing",
                        "content": "i didn\\'t think of that.... I solved it by using the original nums array which made things a lot more complicated :("
                    },
                    {
                        "username": "Enkri_",
                        "content": "Feeling defeated by an easy question"
                    },
                    {
                        "username": "Enkri_",
                        "content": "[@curiosity_kids](/curiosity_kids) Thanks for the encouragement! I\\'m feeling defeated coz I\\'m not new to Leetcode and even tho I can solve medium problems, I found myself stuck at this easy one lol, granted that I have to work during the day and it\\'s hard for me to barely squeeze an hour a day to work on leetcode, but still I did fail to solve an easy question, sigh"
                    },
                    {
                        "username": "curiosity_kids",
                        "content": "I know the feeling, I had the same defeated feeling so, so many times in the last 3 months, but now I am much better than when I started, and as long as you continue to work, you will become better too.\\nAlso when I started these easy were no where easy, till you get more practice, you have to look at the solutions and start noting patterns and putting the methods in your toolkit, especially if you want to save time.\\nJust keep on working, it will get better! I can attest to this my own case."
                    },
                    {
                        "username": "JaspreetKaur_leetcode",
                        "content": "class Solution {\\n    public int countHillValley(int[] nums) {\\n        int counter=0;\\n        for(int i=1;i<nums.length-1;i++){\\n            int nearest_r=nearest_right_element(nums, i+1);\\n            int nearest_l=nearest_left_element(nums, i-1);\\n            if(nums[i]!=nums[i-1]){\\n                if((nearest_r !=-1 && nearest_l!=-1 && nums[i] < nearest_r && nums[i] < nearest_l) || \\n                (nearest_r !=-1 && nearest_l!=-1 && nums[i] > nearest_r && nums[i] > nearest_l)){\\n                    counter++;\\n                }\\n            }\\n        }\\n        return counter;\\n    }\\n\\n    public int nearest_right_element(int[] nums, int start){\\n        int nearest_r=-1;\\n        for(int i=start;i<nums.length;i++){\\n            if(nums[i]!=nums[start-1]){\\n                nearest_r=nums[i];\\n                break;\\n            }\\n        }\\n        return nearest_r;\\n    }\\n\\n    public int nearest_left_element(int[] nums, int destination){\\n        int nearest_l=-1;\\n        for(int i=destination;i>=0;i--){\\n            if(nums[i]!=nums[destination+1]){\\n                nearest_l=nums[i];\\n                break;\\n            }\\n        }\\n        return nearest_l;\\n    }\\n}"
                    },
                    {
                        "username": "geekyshark",
                        "content": "A good \\'easy\\' problem i would say, dont get demotivated if you weren\\'t able to come up with the solution, watch my solution for easy understanding"
                    },
                    {
                        "username": "Anonymous_user_79",
                        "content": "Beats 100% CPP Solution:\\n int countHillValley(vector<int>& nums) {\\n        int count=0, n=nums.size();\\n        for(int i=1;i<n-1;i++)\\n        {\\n            if(nums[i]==nums[i-1]) continue;\\n            int j=i-1,k=i+1;\\n\\n            while(k<n && nums[i]==nums[k]) k++;\\n\\n            if(k>=n) continue;\\n            if(nums[i]>nums[j] && nums[i]>nums[k]) count++;\\n            else if(nums[i]<nums[j] && nums[i]<nums[k]) count++;       \\n        }\\n        return count;\\n    }"
                    }
                ]
            },
            {
                "id": 1698914,
                "content": [
                    {
                        "username": "rohit_adithya",
                        "content": "You can consider to `remove the adjacent equal values` first by transferring elements to another array which are `not equal to immediately preceding element`, which makes it easy to iterate from `second element` to `last second element` and checking the adjacent elements for a valley/hill."
                    },
                    {
                        "username": "yeedaKing",
                        "content": "i didn\\'t think of that.... I solved it by using the original nums array which made things a lot more complicated :("
                    },
                    {
                        "username": "Enkri_",
                        "content": "Feeling defeated by an easy question"
                    },
                    {
                        "username": "Enkri_",
                        "content": "[@curiosity_kids](/curiosity_kids) Thanks for the encouragement! I\\'m feeling defeated coz I\\'m not new to Leetcode and even tho I can solve medium problems, I found myself stuck at this easy one lol, granted that I have to work during the day and it\\'s hard for me to barely squeeze an hour a day to work on leetcode, but still I did fail to solve an easy question, sigh"
                    },
                    {
                        "username": "curiosity_kids",
                        "content": "I know the feeling, I had the same defeated feeling so, so many times in the last 3 months, but now I am much better than when I started, and as long as you continue to work, you will become better too.\\nAlso when I started these easy were no where easy, till you get more practice, you have to look at the solutions and start noting patterns and putting the methods in your toolkit, especially if you want to save time.\\nJust keep on working, it will get better! I can attest to this my own case."
                    },
                    {
                        "username": "JaspreetKaur_leetcode",
                        "content": "class Solution {\\n    public int countHillValley(int[] nums) {\\n        int counter=0;\\n        for(int i=1;i<nums.length-1;i++){\\n            int nearest_r=nearest_right_element(nums, i+1);\\n            int nearest_l=nearest_left_element(nums, i-1);\\n            if(nums[i]!=nums[i-1]){\\n                if((nearest_r !=-1 && nearest_l!=-1 && nums[i] < nearest_r && nums[i] < nearest_l) || \\n                (nearest_r !=-1 && nearest_l!=-1 && nums[i] > nearest_r && nums[i] > nearest_l)){\\n                    counter++;\\n                }\\n            }\\n        }\\n        return counter;\\n    }\\n\\n    public int nearest_right_element(int[] nums, int start){\\n        int nearest_r=-1;\\n        for(int i=start;i<nums.length;i++){\\n            if(nums[i]!=nums[start-1]){\\n                nearest_r=nums[i];\\n                break;\\n            }\\n        }\\n        return nearest_r;\\n    }\\n\\n    public int nearest_left_element(int[] nums, int destination){\\n        int nearest_l=-1;\\n        for(int i=destination;i>=0;i--){\\n            if(nums[i]!=nums[destination+1]){\\n                nearest_l=nums[i];\\n                break;\\n            }\\n        }\\n        return nearest_l;\\n    }\\n}"
                    },
                    {
                        "username": "geekyshark",
                        "content": "A good \\'easy\\' problem i would say, dont get demotivated if you weren\\'t able to come up with the solution, watch my solution for easy understanding"
                    },
                    {
                        "username": "Anonymous_user_79",
                        "content": "Beats 100% CPP Solution:\\n int countHillValley(vector<int>& nums) {\\n        int count=0, n=nums.size();\\n        for(int i=1;i<n-1;i++)\\n        {\\n            if(nums[i]==nums[i-1]) continue;\\n            int j=i-1,k=i+1;\\n\\n            while(k<n && nums[i]==nums[k]) k++;\\n\\n            if(k>=n) continue;\\n            if(nums[i]>nums[j] && nums[i]>nums[k]) count++;\\n            else if(nums[i]<nums[j] && nums[i]<nums[k]) count++;       \\n        }\\n        return count;\\n    }"
                    }
                ]
            }
        ]
    },
    {
        "title": "Count Positions on Street With Required Brightness",
        "question_content": null,
        "solutions": [],
        "discussions": []
    },
    {
        "title": "Count Unguarded Cells in the Grid",
        "question_content": "<p>You are given two integers <code>m</code> and <code>n</code> representing a <strong>0-indexed</strong> <code>m x n</code> grid. You are also given two 2D integer arrays <code>guards</code> and <code>walls</code> where <code>guards[i] = [row<sub>i</sub>, col<sub>i</sub>]</code> and <code>walls[j] = [row<sub>j</sub>, col<sub>j</sub>]</code> represent the positions of the <code>i<sup>th</sup></code> guard and <code>j<sup>th</sup></code> wall respectively.</p>\n\n<p>A guard can see <b>every</b> cell in the four cardinal directions (north, east, south, or west) starting from their position unless <strong>obstructed</strong> by a wall or another guard. A cell is <strong>guarded</strong> if there is <strong>at least</strong> one guard that can see it.</p>\n\n<p>Return<em> the number of unoccupied cells that are <strong>not</strong> <strong>guarded</strong>.</em></p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2022/03/10/example1drawio2.png\" style=\"width: 300px; height: 204px;\" />\n<pre>\n<strong>Input:</strong> m = 4, n = 6, guards = [[0,0],[1,1],[2,3]], walls = [[0,1],[2,2],[1,4]]\n<strong>Output:</strong> 7\n<strong>Explanation:</strong> The guarded and unguarded cells are shown in red and green respectively in the above diagram.\nThere are a total of 7 unguarded cells, so we return 7.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2022/03/10/example2drawio.png\" style=\"width: 200px; height: 201px;\" />\n<pre>\n<strong>Input:</strong> m = 3, n = 3, guards = [[1,1]], walls = [[0,1],[1,0],[2,1],[1,2]]\n<strong>Output:</strong> 4\n<strong>Explanation:</strong> The unguarded cells are shown in green in the above diagram.\nThere are a total of 4 unguarded cells, so we return 4.\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= m, n &lt;= 10<sup>5</sup></code></li>\n\t<li><code>2 &lt;= m * n &lt;= 10<sup>5</sup></code></li>\n\t<li><code>1 &lt;= guards.length, walls.length &lt;= 5 * 10<sup>4</sup></code></li>\n\t<li><code>2 &lt;= guards.length + walls.length &lt;= m * n</code></li>\n\t<li><code>guards[i].length == walls[j].length == 2</code></li>\n\t<li><code>0 &lt;= row<sub>i</sub>, row<sub>j</sub> &lt; m</code></li>\n\t<li><code>0 &lt;= col<sub>i</sub>, col<sub>j</sub> &lt; n</code></li>\n\t<li>All the positions in <code>guards</code> and <code>walls</code> are <strong>unique</strong>.</li>\n</ul>\n",
        "solutions": [
            {
                "id": 1994554,
                "title": "easy-c-code-with-explanation",
                "content": "Solving by brute force,\\n\\nWe first create a grid of the given rows & columns and initiliaze every cell to 0. We indicate the walls as -2 and guards as 2.\\nWe iterate over the entire guards, for every guard we traverse in the 4 directions (left,right,up,down) until we find a wall or a guard.\\nUntil we find a wall or guard, we mark the cell as 1 to indicate it can be guarded by the guard.\\n\\nSo finally we just count the elements which are 0, so these are the cells which are not guarded.\\n\\n```\\nclass Solution {\\npublic:\\n    int countUnguarded(int m, int n, vector<vector<int>>& g, vector<vector<int>>& w) {\\n        // m is no. of rows, n is no. of columns, g is guards vector and w is walls vector\\n        vector<vector<int>> v(m, vector<int> (n,0));\\n        int k = w.size();\\n        for(int i=0;i<k;i++){\\n            int x = w[i][0], y = w[i][1];\\n            v[x][y] = -2;\\n        }\\n        k = g.size();\\n        for(int i=0;i<k;i++){\\n            int x = g[i][0], y = g[i][1];\\n            v[x][y] = 2;\\n        }\\n        for(int j=0;j<k;j++){\\n            int x = g[j][0], y = g[j][1];\\n            for(int i=x-1;i>=0;i--){ // up\\n                if(v[i][y]==-2 || v[i][y]==2) break;\\n                v[i][y] = 1;\\n            }\\n            for(int i=x+1;i<m;i++){ // down\\n                if(v[i][y]==-2 || v[i][y]==2) break;\\n                v[i][y] = 1;\\n            }\\n            for(int i=y-1;i>=0;i--){ // left\\n                if(v[x][i]==-2 || v[x][i]==2) break;\\n                v[x][i] = 1;\\n            }\\n            for(int i=y+1;i<n;i++){ // right\\n                if(v[x][i]==-2 || v[x][i]==2) break;\\n                v[x][i] = 1;\\n            }\\n        }\\n        int ans = 0;\\n        for(int i=0;i<m;i++){\\n            for(int j=0;j<n;j++){\\n                if(!v[i][j]) ans++;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```\\n\\n**Reason for solutions which got TLE:**\\nLet\\'s say if m=10^5 and n=1 and g = 10^5-1 guards are present one after another in the same line from first cell.\\nIf we don\\'t mark the guards prior for checking the guarded cells, then you end up travelling the same cell many times as you don\\'t know some other cells of guard.\\nThen time complexity = (g-1) + (g-2) + ... 1 = g*(g-1)/2. So it is nearly equal to 10^9. So it leads to TLE.\\n\\nSo marking the guard cells prior to checking, stops the revisiting of cell as you stop the iteration, whenever you find a guard.\\n\\nThanks to @kurshcise for pointing it out.\\nYou can find out his explanation in the comments.\\n\\n**Upvote if it helps !**\\n",
                "solutionTags": [
                    "C",
                    "Simulation"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int countUnguarded(int m, int n, vector<vector<int>>& g, vector<vector<int>>& w) {\\n        // m is no. of rows, n is no. of columns, g is guards vector and w is walls vector\\n        vector<vector<int>> v(m, vector<int> (n,0));\\n        int k = w.size();\\n        for(int i=0;i<k;i++){\\n            int x = w[i][0], y = w[i][1];\\n            v[x][y] = -2;\\n        }\\n        k = g.size();\\n        for(int i=0;i<k;i++){\\n            int x = g[i][0], y = g[i][1];\\n            v[x][y] = 2;\\n        }\\n        for(int j=0;j<k;j++){\\n            int x = g[j][0], y = g[j][1];\\n            for(int i=x-1;i>=0;i--){ // up\\n                if(v[i][y]==-2 || v[i][y]==2) break;\\n                v[i][y] = 1;\\n            }\\n            for(int i=x+1;i<m;i++){ // down\\n                if(v[i][y]==-2 || v[i][y]==2) break;\\n                v[i][y] = 1;\\n            }\\n            for(int i=y-1;i>=0;i--){ // left\\n                if(v[x][i]==-2 || v[x][i]==2) break;\\n                v[x][i] = 1;\\n            }\\n            for(int i=y+1;i<n;i++){ // right\\n                if(v[x][i]==-2 || v[x][i]==2) break;\\n                v[x][i] = 1;\\n            }\\n        }\\n        int ans = 0;\\n        for(int i=0;i<m;i++){\\n            for(int j=0;j<n;j++){\\n                if(!v[i][j]) ans++;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1994547,
                "title": "java-simulation",
                "content": "Original thought:\\n\\n1. Mark all the walls.\\n2. Mark all the guards, while pushing their position into a queue\\n3. For each entry in the queue, traverse in all 4 directions until a Guard or Wall is reached\\n4. Iterate over the entire grid counting for non Guard(G), Wall(W), Protected(P) cells\\n\\nOptimized: Using existing `guards` array eliminating queue, and reverse counting marked cells(G,W,P) eliminating O(m * n) iteration for counting.\\n\\nThanks @gengineer, @alisol33 and @boolanik for valuable suggestions\\n```\\nclass Solution\\n{\\n    public int countUnguarded(int m, int n, int[][] guards, int[][] walls)\\n    {\\n        int[][] dirs = {{1,0},{-1,0},{0,1},{0,-1}};\\n        char[][] grid= new char[m][n];\\n        int count = m*n - guards.length - walls.length;\\n        for(int[] wall : walls)\\n        {\\n            int x = wall[0], y = wall[1];\\n            grid[x][y] = \\'W\\';\\n        }\\n        for(int[] guard : guards)\\n        {\\n            int x = guard[0], y = guard[1];\\n            grid[x][y] = \\'G\\';\\n        }\\n        for(int[] point : guards)\\n        {\\n            for(int dir[] : dirs)\\n            {\\n                int x = point[0] + dir[0];\\n                int y = point[1] + dir[1];\\n                while(!(x < 0 || y < 0 || x >= m || y >= n || grid[x][y] == \\'G\\' || grid[x][y] == \\'W\\'))\\n                {\\n                    if(grid[x][y] != \\'P\\')\\n                        count--;\\n                    grid[x][y] = \\'P\\';\\n                    x += dir[0];\\n                    y += dir[1];\\n                }\\n            }\\n        }\\n        return count;\\n    }\\n}\\n```\\n\\nOriginal solution\\n```\\nclass Solution\\n{\\n    public int countUnguarded(int m, int n, int[][] guards, int[][] walls)\\n    {\\n        int[][] dirs = {{1,0},{-1,0},{0,1},{0,-1}};\\n        char[][] grid= new char[m][n];\\n        Queue<int[]> queue = new LinkedList<>();\\n        for(int[] wall : walls)\\n        {\\n            int x = wall[0], y = wall[1];\\n            grid[x][y] = \\'W\\';\\n        }\\n        for(int[] guard : guards)\\n        {\\n            int x = guard[0], y = guard[1];\\n            grid[x][y] = \\'G\\';\\n            queue.offer(guard);\\n        }\\n        while(!queue.isEmpty())\\n        {\\n            int[] point = queue.poll();\\n            for(int dir[] : dirs)\\n            {\\n                int x = point[0] + dir[0];\\n                int y = point[1] + dir[1];\\n                while(!(x < 0 || y < 0 || x >= m || y >= n || grid[x][y] == \\'G\\' || grid[x][y] == \\'W\\'))\\n                {\\n                    grid[x][y] = \\'P\\';\\n                    x += dir[0];\\n                    y += dir[1];\\n                }\\n            }\\n        }\\n        \\n        int count = 0;\\n        for(int i = 0; i < m; i++)\\n            for(int j = 0; j < n; j++)\\n                if(grid[i][j] != \\'G\\' && grid[i][j] != \\'W\\' && grid[i][j] != \\'P\\')\\n                    count++;\\n        \\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution\\n{\\n    public int countUnguarded(int m, int n, int[][] guards, int[][] walls)\\n    {\\n        int[][] dirs = {{1,0},{-1,0},{0,1},{0,-1}};\\n        char[][] grid= new char[m][n];\\n        int count = m*n - guards.length - walls.length;\\n        for(int[] wall : walls)\\n        {\\n            int x = wall[0], y = wall[1];\\n            grid[x][y] = \\'W\\';\\n        }\\n        for(int[] guard : guards)\\n        {\\n            int x = guard[0], y = guard[1];\\n            grid[x][y] = \\'G\\';\\n        }\\n        for(int[] point : guards)\\n        {\\n            for(int dir[] : dirs)\\n            {\\n                int x = point[0] + dir[0];\\n                int y = point[1] + dir[1];\\n                while(!(x < 0 || y < 0 || x >= m || y >= n || grid[x][y] == \\'G\\' || grid[x][y] == \\'W\\'))\\n                {\\n                    if(grid[x][y] != \\'P\\')\\n                        count--;\\n                    grid[x][y] = \\'P\\';\\n                    x += dir[0];\\n                    y += dir[1];\\n                }\\n            }\\n        }\\n        return count;\\n    }\\n}\\n```\n```\\nclass Solution\\n{\\n    public int countUnguarded(int m, int n, int[][] guards, int[][] walls)\\n    {\\n        int[][] dirs = {{1,0},{-1,0},{0,1},{0,-1}};\\n        char[][] grid= new char[m][n];\\n        Queue<int[]> queue = new LinkedList<>();\\n        for(int[] wall : walls)\\n        {\\n            int x = wall[0], y = wall[1];\\n            grid[x][y] = \\'W\\';\\n        }\\n        for(int[] guard : guards)\\n        {\\n            int x = guard[0], y = guard[1];\\n            grid[x][y] = \\'G\\';\\n            queue.offer(guard);\\n        }\\n        while(!queue.isEmpty())\\n        {\\n            int[] point = queue.poll();\\n            for(int dir[] : dirs)\\n            {\\n                int x = point[0] + dir[0];\\n                int y = point[1] + dir[1];\\n                while(!(x < 0 || y < 0 || x >= m || y >= n || grid[x][y] == \\'G\\' || grid[x][y] == \\'W\\'))\\n                {\\n                    grid[x][y] = \\'P\\';\\n                    x += dir[0];\\n                    y += dir[1];\\n                }\\n            }\\n        }\\n        \\n        int count = 0;\\n        for(int i = 0; i < m; i++)\\n            for(int j = 0; j < n; j++)\\n                if(grid[i][j] != \\'G\\' && grid[i][j] != \\'W\\' && grid[i][j] != \\'P\\')\\n                    count++;\\n        \\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1994677,
                "title": "python-very-simple-python-solution",
                "content": "**Idea**\\nCreate grid. Map locations of guards and walls and set location to `1`\\nIterate through guard locations and visit horizontal and vertical locations until we hit a wall/guard (**not guard path**) or the end of the map. Set these guard path locations to `2`.  We set this to `2` instead of `1` in order to distinguish guard path and original guard/wall. Count the remaining `0`s (not guard path, guard or wall). \\n\\n```\\nclass Solution:\\n    def countUnguarded(self, m: int, n: int, guards: List[List[int]], walls: List[List[int]]) -> int:\\n        dp = [[0] * n for _ in range(m)]\\n        for x, y in guards+walls:\\n            dp[x][y] = 1\\n               \\n        directions = [(0, 1), (1, 0), (-1, 0), (0, -1)]\\n        \\n        for x, y in guards:\\n            for dx, dy in directions:\\n                curr_x = x\\n                curr_y = y\\n                \\n                while 0 <= curr_x+dx < m and 0 <= curr_y+dy < n and dp[curr_x+dx][curr_y+dy] != 1:\\n                    curr_x += dx\\n                    curr_y += dy\\n                    dp[curr_x][curr_y] = 2\\n                    \\n        return sum(1 for i in range(m) for j in range(n) if dp[i][j] == 0)                    \\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def countUnguarded(self, m: int, n: int, guards: List[List[int]], walls: List[List[int]]) -> int:\\n        dp = [[0] * n for _ in range(m)]\\n        for x, y in guards+walls:\\n            dp[x][y] = 1\\n               \\n        directions = [(0, 1), (1, 0), (-1, 0), (0, -1)]\\n        \\n        for x, y in guards:\\n            for dx, dy in directions:\\n                curr_x = x\\n                curr_y = y\\n                \\n                while 0 <= curr_x+dx < m and 0 <= curr_y+dy < n and dp[curr_x+dx][curr_y+dy] != 1:\\n                    curr_x += dx\\n                    curr_y += dy\\n                    dp[curr_x][curr_y] = 2\\n                    \\n        return sum(1 for i in range(m) for j in range(n) if dp[i][j] == 0)                    \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2001912,
                "title": "bitmask-tracing-vs-binary-search",
                "content": "#### Bitmask Tracing\\nHere, we build a grid to place guards and walls, and trace guarded cells. \\n\\nOne way to avoid TLE is to place all guards first (and walls, of course), and then trace from each guard in four directions until you hit an edge, a wall, or another guard.\\n\\nHere, however, we track the direction for each cell using a bitmask. We stop when we hit a cell that was already traced in the same direction. That way, we do not have to place all guards first.\\n\\n**C++**\\n```cpp\\nint dir[5] = {0, 1, 0, -1, 0};\\nint countUnguarded(int m, int n, vector<vector<int>>& guards, vector<vector<int>>& walls) {\\n    int not_guarded = m * n - walls.size();\\n    vector<vector<int>> g(m, vector<int>(n));\\n    for (const auto &wall : walls)\\n        g[wall[0]][wall[1]] = 15;\\n    for (const auto &gd : guards)\\n        for (int d = 0; d < 4; ++d)\\n            for (int i = gd[0], j = gd[1]; min(i, j) >= 0 && i < m && j < n && (g[i][j] & (1 << d)) == 0; ) {\\n                not_guarded -= g[i][j] == 0;\\n                g[i][j] += (1 << d);\\n                i += dir[d];\\n                j += dir[d + 1];\\n            }\\n    return not_guarded;\\n}\\n```\\n#### Binary Search\\nThis solution is efficient for a large grid with a few guards and walls.\\n\\nFor this solution, we track the position of guards and walls in `rows` and `cols` arrays, sorted. Instead of using a grid to trace guarded cells, we use binary search to find out the closest guard or wall in all four directions.\\n\\nWhen there is a wall in all four directions (or nothing), the cell is not guarded. \\n\\n**C++**\\n```cpp\\nint countUnguarded(int m, int n, vector<vector<int>>& guards, vector<vector<int>>& walls) {\\n    vector<vector<pair<int, int>>> rows(m, vector<pair<int, int>>{{-1, 1}, {n, 1}}), cols(n, vector<pair<int, int>>{{-1, 1}, {m, 1}});\\n    for (auto &g : guards) {\\n        rows[g[0]].push_back({g[1], 0});\\n        cols[g[1]].push_back({g[0], 0});\\n    }\\n    for (auto &w : walls) {\\n        rows[w[0]].push_back({w[1], 1});\\n        cols[w[1]].push_back({w[0], 1});\\n    }\\n    for (auto &r : rows)\\n        sort(begin(r), end(r));\\n    for (auto &c : cols)\\n        sort(begin(c), end(c));\\n    int res = 0;\\n    for (int i = 0; i < m; ++i) {\\n        for (int j = 0; j < n; ++j) {\\n            auto it_r = lower_bound(begin(rows[i]), end(rows[i]), pair<int, int>{j, 0});\\n            auto it_c = lower_bound(begin(cols[j]), end(cols[j]), pair<int, int>{i, 0});\\n            if (it_r->first == j && it_c->first == i)\\n                continue;\\n            if (it_r->second == 0 || it_c->second == 0 || prev(it_r)->second == 0 || prev(it_c)->second == 0)\\n                continue;         \\n            ++res;\\n        }\\n    }\\n    return res;\\n}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```cpp\\nint dir[5] = {0, 1, 0, -1, 0};\\nint countUnguarded(int m, int n, vector<vector<int>>& guards, vector<vector<int>>& walls) {\\n    int not_guarded = m * n - walls.size();\\n    vector<vector<int>> g(m, vector<int>(n));\\n    for (const auto &wall : walls)\\n        g[wall[0]][wall[1]] = 15;\\n    for (const auto &gd : guards)\\n        for (int d = 0; d < 4; ++d)\\n            for (int i = gd[0], j = gd[1]; min(i, j) >= 0 && i < m && j < n && (g[i][j] & (1 << d)) == 0; ) {\\n                not_guarded -= g[i][j] == 0;\\n                g[i][j] += (1 << d);\\n                i += dir[d];\\n                j += dir[d + 1];\\n            }\\n    return not_guarded;\\n}\\n```\n```cpp\\nint countUnguarded(int m, int n, vector<vector<int>>& guards, vector<vector<int>>& walls) {\\n    vector<vector<pair<int, int>>> rows(m, vector<pair<int, int>>{{-1, 1}, {n, 1}}), cols(n, vector<pair<int, int>>{{-1, 1}, {m, 1}});\\n    for (auto &g : guards) {\\n        rows[g[0]].push_back({g[1], 0});\\n        cols[g[1]].push_back({g[0], 0});\\n    }\\n    for (auto &w : walls) {\\n        rows[w[0]].push_back({w[1], 1});\\n        cols[w[1]].push_back({w[0], 1});\\n    }\\n    for (auto &r : rows)\\n        sort(begin(r), end(r));\\n    for (auto &c : cols)\\n        sort(begin(c), end(c));\\n    int res = 0;\\n    for (int i = 0; i < m; ++i) {\\n        for (int j = 0; j < n; ++j) {\\n            auto it_r = lower_bound(begin(rows[i]), end(rows[i]), pair<int, int>{j, 0});\\n            auto it_c = lower_bound(begin(cols[j]), end(cols[j]), pair<int, int>{i, 0});\\n            if (it_r->first == j && it_c->first == i)\\n                continue;\\n            if (it_r->second == 0 || it_c->second == 0 || prev(it_r)->second == 0 || prev(it_c)->second == 0)\\n                continue;         \\n            ++res;\\n        }\\n    }\\n    return res;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1994758,
                "title": "c-runtime-o-m-n-explained-solution",
                "content": "### Structures used:\\n* mat - 2D vector of size *m* x *n* - Used to mark gaurds(denoted by 2) and walls(denoted by 1)\\n* arr - 3D vector of size *m* x *n* x *4* - marks the position of gaurd in all four positions with respect to the current position.\\n\\n### Explanation\\n* Section 1\\n\\tInitialises the Guards and walls in *mat*\\n* Section 2\\n\\tThe 4 loops check for guards/walls(if any) at current location in all 4 directions. And sets the value of *vector arr*\\n* Section 3\\n\\tfor any position (i, j) to be unguarded, there shouldnt be any gaurd in 4 directions wrt to (i, j). So last loop check for the same and increments *ans* if cell (i, j) is found to be free\\n\\n```\\nint countUnguarded(int m, int n, vector<vector<int>>& g, vector<vector<int>>& w) \\n{  \\n    vector<vector<int> > mat(m, vector<int> (n, 0));\\n    vector<vector<vector<int> > > arr(m, vector<vector<int>> (n, vector<int> (4, 0)));\\n    \\n    \\n    //SECTION 1\\n    //Setting up the walls\\n    for(int i = 0; i<w.size(); i++)\\n        mat[w[i][0]][w[i][1]] = -1;\\n\\n    //Setting up the gaurds\\n    for(int i = 0; i<g.size(); i++)\\n        mat[g[i][0]][g[i][1]] = 2; \\n\\n   \\n    //SECTION 2\\n    int left = 0, right = 1, up = 2, down = 3; \\n    //Guards to the left of (i, j)\\n    for(int i =0; i<m; i++)\\n    {\\n        int gg = -1; \\n        for(int j = 0; j< n; j++)\\n        {\\n            if(mat[i][j] == -1)\\n                gg = -1; \\n            else if(mat[i][j] == 2)\\n                gg = j;\\n            else if(mat[i][j] == 0)\\n                arr[i][j][left] = gg; \\n        }\\n    }\\n    \\n    //Guards to the right of (i, j) \\n    for(int i = 0; i<m; i++)\\n    {\\n        int gg = -1; \\n        for(int j = n-1; j>-1; j--)\\n        {\\n            if(mat[i][j] == -1)\\n                gg = -1; \\n            else if(mat[i][j] == 2)\\n                gg = j;\\n            else if(mat[i][j] == 0)\\n                arr[i][j][right] = gg;\\n        }\\n    }\\n    \\n    //Guards above (i, j)\\n    for(int j = 0; j < n; j++)\\n    {\\n        int gg = -1; \\n        for(int i = 0; i < m; i++)\\n        {\\n            if(mat[i][j] == -1)\\n                gg = -1; \\n            else if(mat[i][j] == 2)\\n                gg = j;\\n            else if(mat[i][j] == 0)\\n                arr[i][j][up] = gg; \\n        }\\n    }\\n    \\n    //Guards below (i, j)\\n    for(int j = 0; j < n; j++)\\n    {\\n        int gg = -1; \\n        for(int i = m-1; i > -1; i--)\\n        {\\n            if(mat[i][j] == -1)\\n                gg = -1; \\n            else if(mat[i][j] == 2)\\n                gg = j;\\n            else if(mat[i][j] == 0)\\n                arr[i][j][down] = gg; \\n        }\\n    }\\n    \\n\\n    //SECTION 3\\n    int ans = 0; \\n    \\n    for(int i =0; i<m; i++)\\n    {\\n        for(int j = 0; j < n; j++)\\n        {\\n            if(arr[i][j][left] == -1 and arr[i][j][right] == -1 and arr[i][j][up] == -1 and arr[i][j][down] == -1)\\n                ans++;\\n        }\\n    }\\n    \\n    return ans;        \\n}\\n```",
                "solutionTags": [
                    "C++",
                    "Iterator"
                ],
                "code": "```\\nint countUnguarded(int m, int n, vector<vector<int>>& g, vector<vector<int>>& w) \\n{  \\n    vector<vector<int> > mat(m, vector<int> (n, 0));\\n    vector<vector<vector<int> > > arr(m, vector<vector<int>> (n, vector<int> (4, 0)));\\n    \\n    \\n    //SECTION 1\\n    //Setting up the walls\\n    for(int i = 0; i<w.size(); i++)\\n        mat[w[i][0]][w[i][1]] = -1;\\n\\n    //Setting up the gaurds\\n    for(int i = 0; i<g.size(); i++)\\n        mat[g[i][0]][g[i][1]] = 2; \\n\\n   \\n    //SECTION 2\\n    int left = 0, right = 1, up = 2, down = 3; \\n    //Guards to the left of (i, j)\\n    for(int i =0; i<m; i++)\\n    {\\n        int gg = -1; \\n        for(int j = 0; j< n; j++)\\n        {\\n            if(mat[i][j] == -1)\\n                gg = -1; \\n            else if(mat[i][j] == 2)\\n                gg = j;\\n            else if(mat[i][j] == 0)\\n                arr[i][j][left] = gg; \\n        }\\n    }\\n    \\n    //Guards to the right of (i, j) \\n    for(int i = 0; i<m; i++)\\n    {\\n        int gg = -1; \\n        for(int j = n-1; j>-1; j--)\\n        {\\n            if(mat[i][j] == -1)\\n                gg = -1; \\n            else if(mat[i][j] == 2)\\n                gg = j;\\n            else if(mat[i][j] == 0)\\n                arr[i][j][right] = gg;\\n        }\\n    }\\n    \\n    //Guards above (i, j)\\n    for(int j = 0; j < n; j++)\\n    {\\n        int gg = -1; \\n        for(int i = 0; i < m; i++)\\n        {\\n            if(mat[i][j] == -1)\\n                gg = -1; \\n            else if(mat[i][j] == 2)\\n                gg = j;\\n            else if(mat[i][j] == 0)\\n                arr[i][j][up] = gg; \\n        }\\n    }\\n    \\n    //Guards below (i, j)\\n    for(int j = 0; j < n; j++)\\n    {\\n        int gg = -1; \\n        for(int i = m-1; i > -1; i--)\\n        {\\n            if(mat[i][j] == -1)\\n                gg = -1; \\n            else if(mat[i][j] == 2)\\n                gg = j;\\n            else if(mat[i][j] == 0)\\n                arr[i][j][down] = gg; \\n        }\\n    }\\n    \\n\\n    //SECTION 3\\n    int ans = 0; \\n    \\n    for(int i =0; i<m; i++)\\n    {\\n        for(int j = 0; j < n; j++)\\n        {\\n            if(arr[i][j][left] == -1 and arr[i][j][right] == -1 and arr[i][j][up] == -1 and arr[i][j][down] == -1)\\n                ans++;\\n        }\\n    }\\n    \\n    return ans;        \\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1994782,
                "title": "simulation",
                "content": "**Mark all the unguarded cells upward, downward, right and left of a guarded cell until Guarded or Walled Cell is found.**\\n\\n**Where :**\\n```\\ng -> cell with a guard\\nw -> cell with a wall\\nd -> guarded cells\\nu -> unguarded cells\\n```\\n```\\nclass Solution {\\npublic:\\n    \\n    void markThem(vector<vector<char>>& prison, int r, int c, int m, int n) {\\n\\n\\t\\t// marking Unguarded Cell in the Right as Guarded until a Guarded or Walled Cell is found.\\n        for (int j=c+1; j<n; j++) {\\n\\t\\t\\t// breaking if wall is found as guard cannot see past that wall.\\n\\t\\t\\t// breaking if cell has a guard as that guard will mark the rest of cells.\\n            if (prison[r][j] == \\'w\\' or prison[r][j] == \\'g\\')    break;\\n            prison[r][j] = \\'d\\'; // marking unguarded cell as guarded.\\n        }\\n\\t\\t\\n\\t\\t// marking Unguarded Cell in the Left as Guarded until a Guarded or Walled Cell is found.\\n        for (int j=c-1; j>=0; j--) {\\n            if (prison[r][j] == \\'w\\' or prison[r][j] == \\'g\\')    break;\\n            prison[r][j] = \\'d\\';\\n        }\\n        \\n\\t\\t// marking Unguarded Cell in the Downward as Guarded until a Guarded or Walled Cell is found.\\n        for (int i=r+1; i<m; i++) {\\n            if (prison[i][c] == \\'w\\' or prison[i][c] == \\'g\\')    break;\\n            prison[i][c] = \\'d\\';\\n        }\\n\\t\\t\\n\\t\\t// marking Unguarded Cell Upward as Guarded until a Guarded or Walled Cell is found.\\n        for (int i=r-1; i>=0; i--) {\\n            if (prison[i][c] == \\'w\\' or prison[i][c] == \\'g\\')    break;\\n            prison[i][c] = \\'d\\';\\n        }\\n    }\\n    \\n    int countUnguarded(int m, int n, vector<vector<int>>& guards, vector<vector<int>>& walls) {\\n        \\n        int res = 0;\\n        vector<vector<char>> prison(m, vector<char>(n, \\'u\\'));\\n        \\n        for (auto& g : guards)  prison[g[0]][g[1]] = \\'g\\';\\n        for (auto& w : walls)    prison[w[0]][w[1]] = \\'w\\';\\n        \\n\\t\\tfor (auto& g : guards)\\n             markThem(prison, g[0], g[1], m, n);\\n        \\n        for (auto& row : prison)\\n            for (auto& cell : row)\\n                if (cell == \\'u\\') res++;\\n\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\ng -> cell with a guard\\nw -> cell with a wall\\nd -> guarded cells\\nu -> unguarded cells\\n```\n```\\nclass Solution {\\npublic:\\n    \\n    void markThem(vector<vector<char>>& prison, int r, int c, int m, int n) {\\n\\n\\t\\t// marking Unguarded Cell in the Right as Guarded until a Guarded or Walled Cell is found.\\n        for (int j=c+1; j<n; j++) {\\n\\t\\t\\t// breaking if wall is found as guard cannot see past that wall.\\n\\t\\t\\t// breaking if cell has a guard as that guard will mark the rest of cells.\\n            if (prison[r][j] == \\'w\\' or prison[r][j] == \\'g\\')    break;\\n            prison[r][j] = \\'d\\'; // marking unguarded cell as guarded.\\n        }\\n\\t\\t\\n\\t\\t// marking Unguarded Cell in the Left as Guarded until a Guarded or Walled Cell is found.\\n        for (int j=c-1; j>=0; j--) {\\n            if (prison[r][j] == \\'w\\' or prison[r][j] == \\'g\\')    break;\\n            prison[r][j] = \\'d\\';\\n        }\\n        \\n\\t\\t// marking Unguarded Cell in the Downward as Guarded until a Guarded or Walled Cell is found.\\n        for (int i=r+1; i<m; i++) {\\n            if (prison[i][c] == \\'w\\' or prison[i][c] == \\'g\\')    break;\\n            prison[i][c] = \\'d\\';\\n        }\\n\\t\\t\\n\\t\\t// marking Unguarded Cell Upward as Guarded until a Guarded or Walled Cell is found.\\n        for (int i=r-1; i>=0; i--) {\\n            if (prison[i][c] == \\'w\\' or prison[i][c] == \\'g\\')    break;\\n            prison[i][c] = \\'d\\';\\n        }\\n    }\\n    \\n    int countUnguarded(int m, int n, vector<vector<int>>& guards, vector<vector<int>>& walls) {\\n        \\n        int res = 0;\\n        vector<vector<char>> prison(m, vector<char>(n, \\'u\\'));\\n        \\n        for (auto& g : guards)  prison[g[0]][g[1]] = \\'g\\';\\n        for (auto& w : walls)    prison[w[0]][w[1]] = \\'w\\';\\n        \\n\\t\\tfor (auto& g : guards)\\n             markThem(prison, g[0], g[1], m, n);\\n        \\n        for (auto& row : prison)\\n            for (auto& cell : row)\\n                if (cell == \\'u\\') res++;\\n\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1994568,
                "title": "c-dfs",
                "content": "```\\nclass Solution {\\npublic:\\n    void dfs( vector<vector<int>> &grid,int x,int y,int m,int n,int dir){\\n        if(x<0 || y<0 || x>=m || y>=n) return;\\n        if(grid[x][y]==2 || grid[x][y]==1) return;\\n        grid[x][y]=3;\\n        if(dir==1){\\n            dfs(grid,x+1,y,m,n,dir);\\n        }\\n        else if(dir==2){\\n            dfs(grid,x,y+1,m,n,dir);\\n        }\\n        else if(dir==3){\\n            dfs(grid,x-1,y,m,n,dir);\\n        }\\n        else{\\n            dfs(grid,x,y-1,m,n,dir);\\n        }\\n    }\\n    int countUnguarded(int m, int n, vector<vector<int>>& guards, vector<vector<int>>& walls) {\\n         vector<vector<int>> grid(m,vector<int>(n,0));\\n        //marking guards\\n        for(int i=0;i<guards.size();i++){\\n            int x=guards[i][0];\\n            int y=guards[i][1];\\n            grid[x][y]=1;\\n        }\\n        // marking walls\\n         for(int i=0;i<walls.size();i++){\\n            int x=walls[i][0];\\n            int y=walls[i][1];\\n            grid[x][y]=2;\\n        }\\n        // dfs in each of 4 directions\\n          for(int i=0;i<guards.size();i++){\\n            int x=guards[i][0];\\n            int y=guards[i][1];\\n              dfs(grid,x+1,y,m,n,1);\\n              dfs(grid,x,y+1,m,n,2);\\n              dfs(grid,x-1,y,m,n,3);\\n              dfs(grid,x,y-1,m,n,4);\\n          }\\n        long long int cnt=0;\\n        for(int i=0;i<m;i++){\\n            for(int j=0;j<n;j++){\\n                if(grid[i][j]==0) cnt++;\\n            }\\n        }\\n        return cnt;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void dfs( vector<vector<int>> &grid,int x,int y,int m,int n,int dir){\\n        if(x<0 || y<0 || x>=m || y>=n) return;\\n        if(grid[x][y]==2 || grid[x][y]==1) return;\\n        grid[x][y]=3;\\n        if(dir==1){\\n            dfs(grid,x+1,y,m,n,dir);\\n        }\\n        else if(dir==2){\\n            dfs(grid,x,y+1,m,n,dir);\\n        }\\n        else if(dir==3){\\n            dfs(grid,x-1,y,m,n,dir);\\n        }\\n        else{\\n            dfs(grid,x,y-1,m,n,dir);\\n        }\\n    }\\n    int countUnguarded(int m, int n, vector<vector<int>>& guards, vector<vector<int>>& walls) {\\n         vector<vector<int>> grid(m,vector<int>(n,0));\\n        //marking guards\\n        for(int i=0;i<guards.size();i++){\\n            int x=guards[i][0];\\n            int y=guards[i][1];\\n            grid[x][y]=1;\\n        }\\n        // marking walls\\n         for(int i=0;i<walls.size();i++){\\n            int x=walls[i][0];\\n            int y=walls[i][1];\\n            grid[x][y]=2;\\n        }\\n        // dfs in each of 4 directions\\n          for(int i=0;i<guards.size();i++){\\n            int x=guards[i][0];\\n            int y=guards[i][1];\\n              dfs(grid,x+1,y,m,n,1);\\n              dfs(grid,x,y+1,m,n,2);\\n              dfs(grid,x-1,y,m,n,3);\\n              dfs(grid,x,y-1,m,n,4);\\n          }\\n        long long int cnt=0;\\n        for(int i=0;i<m;i++){\\n            for(int j=0;j<n;j++){\\n                if(grid[i][j]==0) cnt++;\\n            }\\n        }\\n        return cnt;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1994620,
                "title": "c-quick-code-easy-to-understand-dfs-o-m-n",
                "content": "### DFS Solution ~ O(M*N)\\n- This is a basic DFS question, but with few extra condition checks.\\n- Initially we mark the existence of \\n\\t- **`walls`** as **`2`** \\n\\t- **`guards`** as **`3`**\\n\\t- **`vison of guards`** as **`1`**.\\n- Here we don\\'t require `visited` array, since we can do it using the `walls` and other `guards` in adjacent cell. \\n- Keep track of the changes using the `occupied` count and our answer would be the remaining  count.\\n\\n![image](https://assets.leetcode.com/users/images/f9ea4a0a-c03b-4c39-b305-30e97d8aa513_1651334847.8484206.png)\\n\\n```cpp\\nint countUnguarded(int m, int n, vector<vector<int>>& guards, vector<vector<int>>& walls) {\\n    int dir[][2] = {{1,0},{0,1},{-1,0},{0,-1}};\\n    \\n\\tvector<vector<int>> grid(m, vector<int>(n, 0));\\n    int occupied = walls.size() + guards.size();\\n\\t\\n    for(auto& w: walls)\\n        grid[w[0]][w[1]] = 2;\\n\\n    for(auto& g: guards)\\n        grid[g[0]][g[1]] = 3;\\n\\n\\t// DFS from each guards position\\n    for(auto& g: guards){\\n        int x = g[0], y = g[1];\\n\\n        for(int k=0; k<4; k++){\\n            int dx = x, dy = y;\\n            while(true){\\n                dx += dir[k][0];   \\n                dy += dir[k][1];\\n\\n\\t\\t\\t\\t// break if you see a wall, or if another guard is standing infront of you. (\"not vision\")\\n                if(min(dx, dy) < 0 || dx == m || dy == n || grid[dx][dy] == 2 || grid[dx][dy] == 3)\\n                    break;\\n\\n\\t\\t\\t\\t// if two guards can vision the same cell (1,0) or (1, 3) in example, dont occupy++\\n                if(grid[dx][dy] != 1){\\n                    grid[dx][dy] = 1;\\n                    occupied++;\\n                }\\n            }\\n        }\\n    }\\n    return m*n - occupied;\\n}\\n```\\n\\n**Upvote and let\\'s make all others read :)**",
                "solutionTags": [
                    "C"
                ],
                "code": "```cpp\\nint countUnguarded(int m, int n, vector<vector<int>>& guards, vector<vector<int>>& walls) {\\n    int dir[][2] = {{1,0},{0,1},{-1,0},{0,-1}};\\n    \\n\\tvector<vector<int>> grid(m, vector<int>(n, 0));\\n    int occupied = walls.size() + guards.size();\\n\\t\\n    for(auto& w: walls)\\n        grid[w[0]][w[1]] = 2;\\n\\n    for(auto& g: guards)\\n        grid[g[0]][g[1]] = 3;\\n\\n\\t// DFS from each guards position\\n    for(auto& g: guards){\\n        int x = g[0], y = g[1];\\n\\n        for(int k=0; k<4; k++){\\n            int dx = x, dy = y;\\n            while(true){\\n                dx += dir[k][0];   \\n                dy += dir[k][1];\\n\\n\\t\\t\\t\\t// break if you see a wall, or if another guard is standing infront of you. (\"not vision\")\\n                if(min(dx, dy) < 0 || dx == m || dy == n || grid[dx][dy] == 2 || grid[dx][dy] == 3)\\n                    break;\\n\\n\\t\\t\\t\\t// if two guards can vision the same cell (1,0) or (1, 3) in example, dont occupy++\\n                if(grid[dx][dy] != 1){\\n                    grid[dx][dy] = 1;\\n                    occupied++;\\n                }\\n            }\\n        }\\n    }\\n    return m*n - occupied;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1994570,
                "title": "c-easy-o-m-n-with-inline-explanation",
                "content": "```\\n //function to check Wall and Guard \\n    bool check(int i,int j,vector<vector<int>> &vec){\\n        if(vec[i][j]==0 || vec[i][j]==1) return false;\\n        return true;\\n    }\\n    \\n    \\n    int countUnguarded(int m, int n, vector<vector<int>>& g, vector<vector<int>>& w) {\\n        //Wall=0, Guard=1, Red=2, Green=3 \\n        vector<vector<int>> vec (m,vector<int>(n,3)); //grid with all green visit\\n        \\n        //fill the wall and Guard in grid \\n        for(int i=0;i<g.size();i++) vec[g[i][0]][g[i][1]]=1;\\n        for(int i=0;i<w.size();i++) vec[w[i][0]][w[i][1]]=0;\\n        \\n        //visit all cell\\n        for(int i=0;i<m;i++){\\n            for(int j=0;j<n;j++){\\n                if(vec[i][j]==1){       //consider each Guard\\n                    for(int up=i-1;up>=0;up--){  // check vertically up column\\n                        if(!check(up,j,vec))break;\\n                        vec[up][j]=2;\\n                    }\\n                    for(int down=i+1;down<m;down++){ // check vertically down column\\n                        if(!check(down,j,vec))break;\\n                        vec[down][j]=2;\\n                    }\\n                    for(int left=j-1;left>=0;left--){  // check horizontally left row\\n                        if(!check(i,left,vec))break;\\n                        vec[i][left]=2;\\n                    }\\n                    for(int rt=j+1;rt<n;rt++){   // check horizontally right row\\n                        if(!check(i,rt,vec))break;\\n                        vec[i][rt]=2;\\n                    }\\n                }\\n            }\\n        }\\n        int cnt=0;\\n        for(int i=0;i<m;i++){\\n            for(int j=0;j<n;j++){\\n                if(vec[i][j]==3) cnt++;  // Count Green region\\n            }\\n        }\\n        return cnt;\\n    }\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n //function to check Wall and Guard \\n    bool check(int i,int j,vector<vector<int>> &vec){\\n        if(vec[i][j]==0 || vec[i][j]==1) return false;\\n        return true;\\n    }\\n    \\n    \\n    int countUnguarded(int m, int n, vector<vector<int>>& g, vector<vector<int>>& w) {\\n        //Wall=0, Guard=1, Red=2, Green=3 \\n        vector<vector<int>> vec (m,vector<int>(n,3)); //grid with all green visit\\n        \\n        //fill the wall and Guard in grid \\n        for(int i=0;i<g.size();i++) vec[g[i][0]][g[i][1]]=1;\\n        for(int i=0;i<w.size();i++) vec[w[i][0]][w[i][1]]=0;\\n        \\n        //visit all cell\\n        for(int i=0;i<m;i++){\\n            for(int j=0;j<n;j++){\\n                if(vec[i][j]==1){       //consider each Guard\\n                    for(int up=i-1;up>=0;up--){  // check vertically up column\\n                        if(!check(up,j,vec))break;\\n                        vec[up][j]=2;\\n                    }\\n                    for(int down=i+1;down<m;down++){ // check vertically down column\\n                        if(!check(down,j,vec))break;\\n                        vec[down][j]=2;\\n                    }\\n                    for(int left=j-1;left>=0;left--){  // check horizontally left row\\n                        if(!check(i,left,vec))break;\\n                        vec[i][left]=2;\\n                    }\\n                    for(int rt=j+1;rt<n;rt++){   // check horizontally right row\\n                        if(!check(i,rt,vec))break;\\n                        vec[i][rt]=2;\\n                    }\\n                }\\n            }\\n        }\\n        int cnt=0;\\n        for(int i=0;i<m;i++){\\n            for(int j=0;j<n;j++){\\n                if(vec[i][j]==3) cnt++;  // Count Green region\\n            }\\n        }\\n        return cnt;\\n    }\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1995164,
                "title": "easy-to-understand-c-solution",
                "content": "i have included my code with comments that are easy to understand......feel free to comment your queries......thanks\\n\\n```\\nclass Solution {\\npublic:\\n    int countUnguarded(int m, int n, vector<vector<int>>& g, vector<vector<int>>& walls) {\\n        set<pair<int,int>> settu;//stores walls\\n        set<pair<int,int>> gua;//stores guards\\n        \\n        for(int i=0;i<walls.size();i++){\\n            settu.insert({walls[i][0],walls[i][1]});\\n        }\\n        \\n        for(int i=0;i<g.size();i++){\\n            gua.insert({g[i][0],g[i][1]});\\n        }\\n        \\n        set<pair<int,int>> unq;//stores cells that are guarded.\\n        \\n        for(auto it : g){\\n            int i = it[0]-1;\\n            int j = it[1];\\n            //below while loop is to move from i-1 to 0. that is moving up from the guard\\n            while(i>=0){\\n                if(gua.find({i,j})!=gua.end()){\\n                    break;//breaking if we found a guard.\\n                }\\n                if(settu.find({i,j})==settu.end()){\\n                    unq.insert({i,j});//include current cell if it is not a wall\\n                    i--;\\n                }else{\\n                    break;//break if it is a wall\\n                }\\n            }\\n            i = it[0]+1;\\n            //below while loop is to move from i+1 to m. that is moving down from the guard\\n            while(i<m){\\n                if(gua.find({i,j})!=gua.end()){\\n                    break;//breaking if we found a guard.\\n                }\\n                if(settu.find({i,j})==settu.end()){\\n                    unq.insert({i,j});//include current cell if it is not a wall\\n                    i++;\\n                }else{\\n                    break;//break if it is a wall\\n                }\\n            }\\n            j = it[1]-1;\\n            i = it[0];\\n            //below while loop is to move from j-1 to 0. that is moving left from the guard\\n            while(j>=0){\\n                if(gua.find({i,j})!=gua.end()){\\n                    break;//breaking if we found a guard.\\n                }\\n                if(settu.find({i,j})==settu.end()){\\n                    unq.insert({i,j});//include current cell if it is not a wall\\n                    j--;\\n                }else{\\n                    break;//break if it is a wall\\n                }\\n            }\\n            j = it[1]+1;\\n            //below while loop is to move from j+1 to n. that is moving right from the guard\\n            while(j<n){\\n                if(gua.find({i,j})!=gua.end()){\\n                    break;//breaking if we found a guard.\\n                }\\n                if(settu.find({i,j})==settu.end()){\\n                    unq.insert({i,j});//include current cell if it is not a wall\\n                    j++;\\n                }else{\\n                    break;//break if it is a wall\\n                }\\n            }\\n            \\n        }\\n        \\n        return m*n-settu.size()-gua.size()-unq.size();//finally return the remaining cells which are not guarded, guards, walls;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Ordered Set"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int countUnguarded(int m, int n, vector<vector<int>>& g, vector<vector<int>>& walls) {\\n        set<pair<int,int>> settu;//stores walls\\n        set<pair<int,int>> gua;//stores guards\\n        \\n        for(int i=0;i<walls.size();i++){\\n            settu.insert({walls[i][0],walls[i][1]});\\n        }\\n        \\n        for(int i=0;i<g.size();i++){\\n            gua.insert({g[i][0],g[i][1]});\\n        }\\n        \\n        set<pair<int,int>> unq;//stores cells that are guarded.\\n        \\n        for(auto it : g){\\n            int i = it[0]-1;\\n            int j = it[1];\\n            //below while loop is to move from i-1 to 0. that is moving up from the guard\\n            while(i>=0){\\n                if(gua.find({i,j})!=gua.end()){\\n                    break;//breaking if we found a guard.\\n                }\\n                if(settu.find({i,j})==settu.end()){\\n                    unq.insert({i,j});//include current cell if it is not a wall\\n                    i--;\\n                }else{\\n                    break;//break if it is a wall\\n                }\\n            }\\n            i = it[0]+1;\\n            //below while loop is to move from i+1 to m. that is moving down from the guard\\n            while(i<m){\\n                if(gua.find({i,j})!=gua.end()){\\n                    break;//breaking if we found a guard.\\n                }\\n                if(settu.find({i,j})==settu.end()){\\n                    unq.insert({i,j});//include current cell if it is not a wall\\n                    i++;\\n                }else{\\n                    break;//break if it is a wall\\n                }\\n            }\\n            j = it[1]-1;\\n            i = it[0];\\n            //below while loop is to move from j-1 to 0. that is moving left from the guard\\n            while(j>=0){\\n                if(gua.find({i,j})!=gua.end()){\\n                    break;//breaking if we found a guard.\\n                }\\n                if(settu.find({i,j})==settu.end()){\\n                    unq.insert({i,j});//include current cell if it is not a wall\\n                    j--;\\n                }else{\\n                    break;//break if it is a wall\\n                }\\n            }\\n            j = it[1]+1;\\n            //below while loop is to move from j+1 to n. that is moving right from the guard\\n            while(j<n){\\n                if(gua.find({i,j})!=gua.end()){\\n                    break;//breaking if we found a guard.\\n                }\\n                if(settu.find({i,j})==settu.end()){\\n                    unq.insert({i,j});//include current cell if it is not a wall\\n                    j++;\\n                }else{\\n                    break;//break if it is a wall\\n                }\\n            }\\n            \\n        }\\n        \\n        return m*n-settu.size()-gua.size()-unq.size();//finally return the remaining cells which are not guarded, guards, walls;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1994551,
                "title": "c-easy-to-understand-simple-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int countUnguarded(int m, int n, vector<vector<int>>& guards, vector<vector<int>>& walls) {\\n        vector<vector<int>> grid(m,vector<int>(n,-1));\\n        int l=guards.size();\\n        \\n        for(int i=0;i<l;i++)\\n        {\\n            grid[guards[i][0]][guards[i][1]]=0;\\n        }\\n        \\n        int l2=walls.size();\\n        for(int i=0;i<l2;i++)\\n        {\\n            grid[walls[i][0]][walls[i][1]]=2;\\n        }\\n        \\n        for(int i=0;i<l;i++)\\n        {\\n           int x,y;\\n            x=guards[i][0];\\n            y=guards[i][1];\\n            int p;\\n            p=x+1;\\n            \\n            while(p<m)\\n            {\\n\\n                if(grid[p][y]==2||grid[p][y]==0)\\n                {\\n                    break;\\n                }                \\n                grid[p][y]=1;\\n                p++;\\n            }\\n            \\n            p=x-1;\\n            while(p>=0)\\n            {\\n                  if(grid[p][y]==2||grid[p][y]==0)\\n                {\\n                    break;\\n                }                \\n                grid[p][y]=1;\\n                p--;\\n            }\\n             p=y-1;\\n            while(p>=0)\\n            {\\n                  if(grid[x][p]==2||grid[x][p]==0)\\n                {\\n                    break;\\n                }                \\n                grid[x][p]=1;\\n                p--;\\n            }\\n             p=y+1;\\n            while(p<n)\\n            {\\n                  if(grid[x][p]==2||grid[x][p]==0)\\n                {\\n                    break;\\n                }                \\n                grid[x][p]=1;\\n                p++;\\n            }\\n        }\\n        int ans=0;\\n        for(int i=0;i<m;i++)\\n        {\\n            for(int j=0;j<n;j++)\\n            {\\n                if(grid[i][j]==-1)\\n                ans++;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int countUnguarded(int m, int n, vector<vector<int>>& guards, vector<vector<int>>& walls) {\\n        vector<vector<int>> grid(m,vector<int>(n,-1));\\n        int l=guards.size();\\n        \\n        for(int i=0;i<l;i++)\\n        {\\n            grid[guards[i][0]][guards[i][1]]=0;\\n        }\\n        \\n        int l2=walls.size();\\n        for(int i=0;i<l2;i++)\\n        {\\n            grid[walls[i][0]][walls[i][1]]=2;\\n        }\\n        \\n        for(int i=0;i<l;i++)\\n        {\\n           int x,y;\\n            x=guards[i][0];\\n            y=guards[i][1];\\n            int p;\\n            p=x+1;\\n            \\n            while(p<m)\\n            {\\n\\n                if(grid[p][y]==2||grid[p][y]==0)\\n                {\\n                    break;\\n                }                \\n                grid[p][y]=1;\\n                p++;\\n            }\\n            \\n            p=x-1;\\n            while(p>=0)\\n            {\\n                  if(grid[p][y]==2||grid[p][y]==0)\\n                {\\n                    break;\\n                }                \\n                grid[p][y]=1;\\n                p--;\\n            }\\n             p=y-1;\\n            while(p>=0)\\n            {\\n                  if(grid[x][p]==2||grid[x][p]==0)\\n                {\\n                    break;\\n                }                \\n                grid[x][p]=1;\\n                p--;\\n            }\\n             p=y+1;\\n            while(p<n)\\n            {\\n                  if(grid[x][p]==2||grid[x][p]==0)\\n                {\\n                    break;\\n                }                \\n                grid[x][p]=1;\\n                p++;\\n            }\\n        }\\n        int ans=0;\\n        for(int i=0;i<m;i++)\\n        {\\n            for(int j=0;j<n;j++)\\n            {\\n                if(grid[i][j]==-1)\\n                ans++;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1995423,
                "title": "java-easy-clear-solution-step-by-step",
                "content": "# | JAVA | Step by step Solution -->\\n1. We wil create a matrix call `res` with dimensions (`m`,`n`). When created, the matrix will contain only zeros.\\n    Zeros represent unguarded cells.\\n\\n2. We add the walls to the correct positions in `res`, the same case for the guards. \\n    Walls will be represented in `res` with the number 2 and guards using the number 1.\\n\\t\\n3. We start parsing the matrix, if we find a 1 (guard), we try to change the respective cells \\n    affected in `res` with the number 3 until we face a wall or another guard.\\n\\t\\n4. Once all the guards have guarded their respective cells, we parse the matrix again, if we find\\n    a zero (unguarded cell) we add one to the counter (`result`).\\n\\n5. We return `result` :). Hope you have understand it!! \\n\\nLeave a like and a comment if you have any question.\\n\\n```\\nclass Solution {\\n    public int countUnguarded(int m, int n, int[][] guards, int[][] walls) {\\n        int[][] res = new int[m][n];   //We create the matrix with the proper dimension\\n        int result = 0, cnti, cntj;\\n        for(int[] i : walls){       //We insert all the walls\\n            res[i[0]][i[1]] = 2;\\n        }\\n        for(int[] i : guards){      //We insert all the guards\\n            res[i[0]][i[1]] = 1;  \\n        }\\n        for(int i = 0; i < res.length;i++){\\n            for(int j = 0; j < res[i].length;j++){\\n                if(res[i][j] == 1){     //If we found a guard...\\n                    cnti = i;   //Position of the guard\\n                    cntj = j;   //Position of the guard\\n                    while(cnti-1 != -1 && res[cnti-1][cntj] != 2 && res[cnti-1][cntj] != 1){  //If we can go up in the matrix...\\n                        res[cnti-1][cntj] = 3;\\n                        cnti--;\\n                    }\\n                    cnti = i;  //We reset the value to the initial one\\n                    while(cnti+1 != m && res[cnti+1][cntj] != 2 && res[cnti+1][cntj] != 1){   //If we can go down in the matrix...\\n                        res[cnti+1][cntj] = 3;\\n                        cnti++;\\n                    }\\n                    cnti = i;  //We reset the value to the initial one\\n                    while(cntj-1 != -1 && res[cnti][cntj-1] != 2 && res[cnti][cntj-1] != 1){  //If we can go to left in the matrix...\\n                        res[cnti][cntj-1] = 3;\\n                        cntj--;\\n                    }\\n                    cntj = j;  //We reset the value to the initial one\\n                    while(cntj+1 != n && res[cnti][cntj+1] != 2 && res[cnti][cntj+1] != 1){  //If we can go to rigth in the matrix...\\n                        res[cnti][cntj+1] = 3;\\n                        cntj++;\\n                    }\\n                }\\n            }\\n        }\\n        for(int[] i : res){   //Once we have marked the correct squares in the matrix...\\n            for(int j : i){\\n                if(j == 0){   //If we find a \\'0\\', we add one to the counter as it is an unguarded cell\\n                    result++;\\n                }\\n            }\\n        }\\n        return result;  //We return the number of unguarded cells\\n    }\\n}\\n```\\n\\n",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int countUnguarded(int m, int n, int[][] guards, int[][] walls) {\\n        int[][] res = new int[m][n];   //We create the matrix with the proper dimension\\n        int result = 0, cnti, cntj;\\n        for(int[] i : walls){       //We insert all the walls\\n            res[i[0]][i[1]] = 2;\\n        }\\n        for(int[] i : guards){      //We insert all the guards\\n            res[i[0]][i[1]] = 1;  \\n        }\\n        for(int i = 0; i < res.length;i++){\\n            for(int j = 0; j < res[i].length;j++){\\n                if(res[i][j] == 1){     //If we found a guard...\\n                    cnti = i;   //Position of the guard\\n                    cntj = j;   //Position of the guard\\n                    while(cnti-1 != -1 && res[cnti-1][cntj] != 2 && res[cnti-1][cntj] != 1){  //If we can go up in the matrix...\\n                        res[cnti-1][cntj] = 3;\\n                        cnti--;\\n                    }\\n                    cnti = i;  //We reset the value to the initial one\\n                    while(cnti+1 != m && res[cnti+1][cntj] != 2 && res[cnti+1][cntj] != 1){   //If we can go down in the matrix...\\n                        res[cnti+1][cntj] = 3;\\n                        cnti++;\\n                    }\\n                    cnti = i;  //We reset the value to the initial one\\n                    while(cntj-1 != -1 && res[cnti][cntj-1] != 2 && res[cnti][cntj-1] != 1){  //If we can go to left in the matrix...\\n                        res[cnti][cntj-1] = 3;\\n                        cntj--;\\n                    }\\n                    cntj = j;  //We reset the value to the initial one\\n                    while(cntj+1 != n && res[cnti][cntj+1] != 2 && res[cnti][cntj+1] != 1){  //If we can go to rigth in the matrix...\\n                        res[cnti][cntj+1] = 3;\\n                        cntj++;\\n                    }\\n                }\\n            }\\n        }\\n        for(int[] i : res){   //Once we have marked the correct squares in the matrix...\\n            for(int j : i){\\n                if(j == 0){   //If we find a \\'0\\', we add one to the counter as it is an unguarded cell\\n                    result++;\\n                }\\n            }\\n        }\\n        return result;  //We return the number of unguarded cells\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1995003,
                "title": "easy-bfs-approach-with-c-code-with-explanation",
                "content": "# Logic: - \\n**Step 1** : Construct 2D matrix ,iterate through guards and wall vectors and fill them in our 2D matrix\\nFew conventions i used for identifying each of them\\nEmpty Space -> 0\\nGuard -> -1\\nWall -> 1\\n**Step 2**: Fill index of all guards in queue (we will pick each one of them and make them travel in all 4 directions)\\n**Step 3**: Pick one index and from that index travel in all 4 directions and mark the cell as 2(personal convention to identify places already visited by a Guard). keep on picking till we make queue empty\\n**Step4**: In the end count all cell still having value as 0\\n```\\nclass Solution {\\npublic:\\n    int countUnguarded(int m, int n, vector<vector<int>>& guards, vector<vector<int>>& walls) \\n    {\\n       swap(n,m);  // did this so that n can denote rows and m can denote coloumns\\n\\t   // Step 1\\n       vector<vector<int>> mat(n,vector<int>(m));\\n      // filling matrix with 0 for all places\\n       for(int i=0;i<n;i++)\\n       {\\n         for(int j=0;j<m;j++)\\n         {\\n           mat[i][j]=0;\\n         }\\n       }\\n      \\n       queue<pair<int,int>>q;\\n      \\n\\t  // Step 2\\n      // marking -1 at all pos where guard is present and pushing that index to queue\\n       for(int i=0;i<guards.size();i++)\\n       {\\n         int x=guards[i][0];\\n         int y=guards[i][1];\\n         mat[x][y]=-1;\\n         q.push({x,y});\\n       }\\n      \\n      // marking 1 at all places where there\\'s a wall\\n       for(int i=0;i<walls.size();i++)\\n       {\\n         int x=walls[i][0];\\n         int y=walls[i][1];\\n         mat[x][y]=1;\\n       }\\n      \\n       \\n        // made for travelling top,down,left,right\\n        vector<int>dx={-1,+1,0,0};\\n        vector<int>dy={0,0,-1,+1};\\n      \\n\\t   // Step 3\\n\\t   \\n         while(q.size())\\n        {\\n            pair<int,int>p=q.front();\\n            q.pop();\\n            int x=p.first;\\n            int y=p.second;\\n            for(int i=0;i<4;i++)\\n            {\\n\\t\\t\\t   // nx is new value of x ,ny is new value of y \\n                int nx=x+dx[i];\\n                int ny=y+dy[i];\\n                // keep on moving in that direction uptill we encounter wall or guard , we have marked\\n                // 2 as place thats already visited by other guard\\n                while(nx>=0 and nx<n and ny>=0 and ny<m and (mat[nx][ny]==0 or mat[nx][ny]==2))\\n                {\\n                    mat[nx][ny]=2;\\n                    nx+=dx[i];\\n                    ny+=dy[i];\\n                }\\n                     \\n             }\\n        }\\n         // Step 4  \\n        // in the end just count the places which are still 0 (empty)\\n          int cnt=0;\\n          for(int i=0;i<n;i++)\\n          {\\n            for(int j=0;j<m;j++)\\n            {\\n              if(mat[i][j]==0)\\n              {\\n                cnt++;\\n              }\\n            }\\n          }\\n                      \\n           return cnt;           \\n      \\n       \\n      \\n      \\n      \\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int countUnguarded(int m, int n, vector<vector<int>>& guards, vector<vector<int>>& walls) \\n    {\\n       swap(n,m);  // did this so that n can denote rows and m can denote coloumns\\n\\t   // Step 1\\n       vector<vector<int>> mat(n,vector<int>(m));\\n      // filling matrix with 0 for all places\\n       for(int i=0;i<n;i++)\\n       {\\n         for(int j=0;j<m;j++)\\n         {\\n           mat[i][j]=0;\\n         }\\n       }\\n      \\n       queue<pair<int,int>>q;\\n      \\n\\t  // Step 2\\n      // marking -1 at all pos where guard is present and pushing that index to queue\\n       for(int i=0;i<guards.size();i++)\\n       {\\n         int x=guards[i][0];\\n         int y=guards[i][1];\\n         mat[x][y]=-1;\\n         q.push({x,y});\\n       }\\n      \\n      // marking 1 at all places where there\\'s a wall\\n       for(int i=0;i<walls.size();i++)\\n       {\\n         int x=walls[i][0];\\n         int y=walls[i][1];\\n         mat[x][y]=1;\\n       }\\n      \\n       \\n        // made for travelling top,down,left,right\\n        vector<int>dx={-1,+1,0,0};\\n        vector<int>dy={0,0,-1,+1};\\n      \\n\\t   // Step 3\\n\\t   \\n         while(q.size())\\n        {\\n            pair<int,int>p=q.front();\\n            q.pop();\\n            int x=p.first;\\n            int y=p.second;\\n            for(int i=0;i<4;i++)\\n            {\\n\\t\\t\\t   // nx is new value of x ,ny is new value of y \\n                int nx=x+dx[i];\\n                int ny=y+dy[i];\\n                // keep on moving in that direction uptill we encounter wall or guard , we have marked\\n                // 2 as place thats already visited by other guard\\n                while(nx>=0 and nx<n and ny>=0 and ny<m and (mat[nx][ny]==0 or mat[nx][ny]==2))\\n                {\\n                    mat[nx][ny]=2;\\n                    nx+=dx[i];\\n                    ny+=dy[i];\\n                }\\n                     \\n             }\\n        }\\n         // Step 4  \\n        // in the end just count the places which are still 0 (empty)\\n          int cnt=0;\\n          for(int i=0;i<n;i++)\\n          {\\n            for(int j=0;j<m;j++)\\n            {\\n              if(mat[i][j]==0)\\n              {\\n                cnt++;\\n              }\\n            }\\n          }\\n                      \\n           return cnt;           \\n      \\n       \\n      \\n      \\n      \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2037652,
                "title": "c-o-mn-beats-96-18-simple-dfs-with-explanation-and-comments",
                "content": "```\\nclass Solution {\\npublic:\\n    int countUnguarded(int m, int n, vector<vector<int>>& guards, vector<vector<int>>& walls) {\\n        vector<vector<char>> g(m,vector<char>(n,\\'0\\'));\\n        \\n        //fill the position of guards.\\n        for(int i=0;i<guards.size();i++){\\n            int x=guards[i][0],y=guards[i][1];\\n            g[x][y]=\\'g\\';\\n        }\\n        \\n        //fill the position of walls\\n        for(int i=0;i<walls.size();i++){\\n            int x=walls[i][0],y=walls[i][1];\\n            g[x][y]=\\'w\\';\\n        }\\n        \\n        for(int i=0;i<guards.size();i++){\\n            int x=guards[i][0],y=guards[i][1];\\n            \\n            //check for guards or walls in upper direction.\\n            for(int j=x-1;j>=0;j--){\\n                if(g[j][y]==\\'g\\' or g[j][y]==\\'w\\'){\\n                    break;\\n                }\\n                g[j][y] = \\'1\\'; //fill the cell as guarded\\n            }\\n            \\n            //check for guards or walls in right direction.\\n            for(int j=y+1;j<n;j++){\\n                if(g[x][j]==\\'g\\' or g[x][j]==\\'w\\'){\\n                    break;\\n                }\\n                g[x][j] = \\'1\\';\\n            }\\n            \\n            //check for guards or walls in downward direction.\\n            for(int j=x+1;j<m;j++){\\n                if(g[j][y]==\\'g\\' or g[j][y]==\\'w\\'){\\n                    break;\\n                }\\n                g[j][y] = \\'1\\';\\n            }\\n            \\n            //check for guards or walls in left direction.\\n            for(int j=y-1;j>=0;j--){\\n                if(g[x][j]==\\'g\\' or g[x][j]==\\'w\\'){\\n                    break;\\n                }\\n                g[x][j] = \\'1\\';\\n            }\\n        }\\n        \\n        int res=0;\\n        \\n        for(int i=0;i<m;i++){\\n            for(int j=0;j<n;j++){\\n                //if g[i][j] is \\'0\\' it means the cell is not guarded.\\n                if(g[i][j]==\\'0\\'){\\n                    res++;\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int countUnguarded(int m, int n, vector<vector<int>>& guards, vector<vector<int>>& walls) {\\n        vector<vector<char>> g(m,vector<char>(n,\\'0\\'));\\n        \\n        //fill the position of guards.\\n        for(int i=0;i<guards.size();i++){\\n            int x=guards[i][0],y=guards[i][1];\\n            g[x][y]=\\'g\\';\\n        }\\n        \\n        //fill the position of walls\\n        for(int i=0;i<walls.size();i++){\\n            int x=walls[i][0],y=walls[i][1];\\n            g[x][y]=\\'w\\';\\n        }\\n        \\n        for(int i=0;i<guards.size();i++){\\n            int x=guards[i][0],y=guards[i][1];\\n            \\n            //check for guards or walls in upper direction.\\n            for(int j=x-1;j>=0;j--){\\n                if(g[j][y]==\\'g\\' or g[j][y]==\\'w\\'){\\n                    break;\\n                }\\n                g[j][y] = \\'1\\'; //fill the cell as guarded\\n            }\\n            \\n            //check for guards or walls in right direction.\\n            for(int j=y+1;j<n;j++){\\n                if(g[x][j]==\\'g\\' or g[x][j]==\\'w\\'){\\n                    break;\\n                }\\n                g[x][j] = \\'1\\';\\n            }\\n            \\n            //check for guards or walls in downward direction.\\n            for(int j=x+1;j<m;j++){\\n                if(g[j][y]==\\'g\\' or g[j][y]==\\'w\\'){\\n                    break;\\n                }\\n                g[j][y] = \\'1\\';\\n            }\\n            \\n            //check for guards or walls in left direction.\\n            for(int j=y-1;j>=0;j--){\\n                if(g[x][j]==\\'g\\' or g[x][j]==\\'w\\'){\\n                    break;\\n                }\\n                g[x][j] = \\'1\\';\\n            }\\n        }\\n        \\n        int res=0;\\n        \\n        for(int i=0;i<m;i++){\\n            for(int j=0;j<n;j++){\\n                //if g[i][j] is \\'0\\' it means the cell is not guarded.\\n                if(g[i][j]==\\'0\\'){\\n                    res++;\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1997416,
                "title": "simple-java-solution",
                "content": "```\\nclass Solution {\\n    public int countUnguarded(int m, int n, int[][] g, int[][] w) {\\n        int a[][]=new int[m][n];\\n        for(int i=0;i<g.length;i++)\\n        {\\n            a[g[i][0]][g[i][1]]=1;\\n        }\\n        for(int i=0;i<w.length;i++)\\n        {\\n            a[w[i][0]][w[i][1]]=2;\\n        }\\n        for(int i=0;i<m;i++)\\n        {\\n            for(int j=0;j<n;j++)\\n            {\\n                if(a[i][j]==1)\\n                {\\n                    for(int k=j-1;k>=0;k--)\\n                    {\\n                        if(a[i][k]==2||a[i][k]==1)\\n                            break;\\n                        else\\n                            a[i][k]=3;\\n                    }\\n                    for(int k=j+1;k<n;k++)\\n                    {\\n                        if(a[i][k]==2||a[i][k]==1)\\n                            break;\\n                        else\\n                            a[i][k]=3;\\n                    }\\n                    for(int k=i-1;k>=0;k--)\\n                    {\\n                        if(a[k][j]==2||a[k][j]==1)\\n                            break;\\n                        else\\n                            a[k][j]=3;\\n                    }\\n                    for(int k=i+1;k<m;k++)\\n                    {\\n                        if(a[k][j]==2||a[k][j]==1)\\n                            break;\\n                        else\\n                            a[k][j]=3;\\n                    }\\n                }\\n            }\\n        }\\n        int c=0;\\n        for(int i=0;i<m;i++)\\n        {\\n            for(int j=0;j<n;j++)\\n            {\\n                if(a[i][j]==0)\\n                    c++;\\n            }\\n        }\\n        return c;\\n    }\\n}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    public int countUnguarded(int m, int n, int[][] g, int[][] w) {\\n        int a[][]=new int[m][n];\\n        for(int i=0;i<g.length;i++)\\n        {\\n            a[g[i][0]][g[i][1]]=1;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1995512,
                "title": "easy-to-understand-cpp-code-with-explanation",
                "content": "```\\nSolving by brute force,\\n\\nWe first create a grid of the given rows & columns and initiliaze every cell to 0. We indicate the walls as 2  and guards as 1.\\nWe iterate over the entire guards, for every guard we traverse in the 4 directions (left,right,up,down) until we find a wall or a guard.\\nUntil we find a wall or guard, we mark the cell as -1 to indicate it can be guarded by the guard.\\n\\nSo finally we just count the elements which are 0, so these are the cells which are not guarded.\\n\\nclass Solution {\\npublic:\\n    int countUnguarded(int m, int n, vector<vector<int>>& guards, vector<vector<int>>& walls) {\\n        vector<vector<int>> v(m, vector<int>(n, 0));\\n        for(auto arr : guards){\\n            int r = arr[0];\\n            int c = arr[1];\\n            v[r][c] = 1;\\n        }\\n        for(auto arr : walls){\\n            int r = arr[0];\\n            int c = arr[1];\\n            v[r][c] = 2;\\n        }\\n        \\n        for(int i = 0; i < m; i++){\\n            for(int j = 0; j < n; j++){\\n                if(v[i][j] == 1){\\n                    int k = i + 1;\\n                    while((k < m && v[k][j] != 1 && v[k][j] != 2)){//down\\n                        v[k][j] = -1;\\n                        k++;\\n                    }\\n                    k = i - 1;\\n                    while((k >= 0 && v[k][j] != 1 && v[k][j] != 2)){//up\\n                        v[k][j] = -1;\\n                        k--;\\n                    }\\n                    k = j - 1;\\n                    while((k >= 0 && v[i][k] != 1 && v[i][k] != 2)){//left\\n                        v[i][k] = -1;\\n                        k--;\\n                    }\\n                    k = j + 1;\\n                    while((k < n && v[i][k] != 1  && v[i][k] != 2)){//right\\n                        v[i][k] = -1;\\n                        k++;\\n                    }\\n                }\\n            }\\n        }\\n        \\n        int cnt = 0;\\n        for(int i = 0; i < m; i++){\\n            for(int j = 0; j < n; j++){\\n                if(v[i][j] == 0) cnt++;\\n                // cout << v[i][j] << \" \";\\n            }\\n            cout << endl;\\n        }\\n        \\n        return cnt;\\n    }\\n};\\n\\nplease upvote if it helps!!\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nSolving by brute force,\\n\\nWe first create a grid of the given rows & columns and initiliaze every cell to 0. We indicate the walls as 2  and guards as 1.\\nWe iterate over the entire guards, for every guard we traverse in the 4 directions (left,right,up,down) until we find a wall or a guard.\\nUntil we find a wall or guard, we mark the cell as -1 to indicate it can be guarded by the guard.\\n\\nSo finally we just count the elements which are 0, so these are the cells which are not guarded.\\n\\nclass Solution {\\npublic:\\n    int countUnguarded(int m, int n, vector<vector<int>>& guards, vector<vector<int>>& walls) {\\n        vector<vector<int>> v(m, vector<int>(n, 0));\\n        for(auto arr : guards){\\n            int r = arr[0];\\n            int c = arr[1];\\n            v[r][c] = 1;\\n        }\\n        for(auto arr : walls){\\n            int r = arr[0];\\n            int c = arr[1];\\n            v[r][c] = 2;\\n        }\\n        \\n        for(int i = 0; i < m; i++){\\n            for(int j = 0; j < n; j++){\\n                if(v[i][j] == 1){\\n                    int k = i + 1;\\n                    while((k < m && v[k][j] != 1 && v[k][j] != 2)){//down\\n                        v[k][j] = -1;\\n                        k++;\\n                    }\\n                    k = i - 1;\\n                    while((k >= 0 && v[k][j] != 1 && v[k][j] != 2)){//up\\n                        v[k][j] = -1;\\n                        k--;\\n                    }\\n                    k = j - 1;\\n                    while((k >= 0 && v[i][k] != 1 && v[i][k] != 2)){//left\\n                        v[i][k] = -1;\\n                        k--;\\n                    }\\n                    k = j + 1;\\n                    while((k < n && v[i][k] != 1  && v[i][k] != 2)){//right\\n                        v[i][k] = -1;\\n                        k++;\\n                    }\\n                }\\n            }\\n        }\\n        \\n        int cnt = 0;\\n        for(int i = 0; i < m; i++){\\n            for(int j = 0; j < n; j++){\\n                if(v[i][j] == 0) cnt++;\\n                // cout << v[i][j] << \" \";\\n            }\\n            cout << endl;\\n        }\\n        \\n        return cnt;\\n    }\\n};\\n\\nplease upvote if it helps!!\\n```",
                "codeTag": "C++"
            },
            {
                "id": 1994734,
                "title": "straighforward-one-direction-dfs-solution-python",
                "content": "Idea is to mark all locations which the guard can see with some arbitrary value. Then later just count the non marked cells.\\n\\nSimply initiate **4** DFS on each of the guard. Each for top, right, bottom, left. And mark that 1-Direction Path.\\n\\n```\\ndef countUnguarded(self, m: int, n: int, guards: List[List[int]], walls: List[List[int]]) -> int:\\n\\t# step1: Build matrix\\n    mat = [[0] * n for i in range(m)]\\n\\n    for i, j in guards:\\n        mat[i][j] = \"G\"\\n\\n    for i, j in walls:\\n        mat[i][j] = \"W\"\\n\\n\\t# TOP, RIGHT, BOTTOM, LEFT\\n    directions = [(-1, 0), (0, 1), (1, 0), (0, -1)]\\n\\n    def isValid(i, j):\\n        if i < 0 or j < 0 or i >= m or j >= n:\\n            return False\\n        return True\\n\\n    def dfs(i, j, direction):\\n        if not isValid(i, j):\\n            return\\n\\n        if mat[i][j] == \"W\" or mat[i][j] == \"G\" :\\n            return\\n\\n        mat[i][j] = \"X\"\\n\\n        x, y = direction\\n        new_i = i + x\\n        new_j = j + y\\n        if isValid(new_i, new_j):\\n            dfs(new_i, new_j, direction)\\n\\n\\t# do dfs on each direction, and keep going in that direction\\n    for i in range(m):\\n        for j in range(n):\\n            if mat[i][j] == \"G\":\\n                dfs(i - 1, j, directions[0]) # always go up\\n                dfs(i, j + 1, directions[1]) # always go right\\n                dfs(i + 1, j, directions[2]) # always go down\\n                dfs(i, j - 1, directions[3]) # always go left\\n\\n\\t# count unmarked cells as safe\\n    c = 0\\n    for i in range(m):\\n        for j in range(n):\\n            if mat[i][j] == 0:\\n                c += 1\\n\\n    return c\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\ndef countUnguarded(self, m: int, n: int, guards: List[List[int]], walls: List[List[int]]) -> int:\\n\\t# step1: Build matrix\\n    mat = [[0] * n for i in range(m)]\\n\\n    for i, j in guards:\\n        mat[i][j] = \"G\"\\n\\n    for i, j in walls:\\n        mat[i][j] = \"W\"\\n\\n\\t# TOP, RIGHT, BOTTOM, LEFT\\n    directions = [(-1, 0), (0, 1), (1, 0), (0, -1)]\\n\\n    def isValid(i, j):\\n        if i < 0 or j < 0 or i >= m or j >= n:\\n            return False\\n        return True\\n\\n    def dfs(i, j, direction):\\n        if not isValid(i, j):\\n            return\\n\\n        if mat[i][j] == \"W\" or mat[i][j] == \"G\" :\\n            return\\n\\n        mat[i][j] = \"X\"\\n\\n        x, y = direction\\n        new_i = i + x\\n        new_j = j + y\\n        if isValid(new_i, new_j):\\n            dfs(new_i, new_j, direction)\\n\\n\\t# do dfs on each direction, and keep going in that direction\\n    for i in range(m):\\n        for j in range(n):\\n            if mat[i][j] == \"G\":\\n                dfs(i - 1, j, directions[0]) # always go up\\n                dfs(i, j + 1, directions[1]) # always go right\\n                dfs(i + 1, j, directions[2]) # always go down\\n                dfs(i, j - 1, directions[3]) # always go left\\n\\n\\t# count unmarked cells as safe\\n    c = 0\\n    for i in range(m):\\n        for j in range(n):\\n            if mat[i][j] == 0:\\n                c += 1\\n\\n    return c\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2111213,
                "title": "easy-to-understand-c-iterative",
                "content": "```\\nclass Solution {\\npublic:\\n    void helper(int m, int n, vector <vector <int>>& grid, int& count, int r, int c) {\\n        for (int i = r+1; i < m; i++) {\\n            if (grid[i][c] == 1 || grid[i][c] == 2) break;\\n            if (grid[i][c] == 0) {\\n                count++;\\n                grid[i][c] = 3;\\n            }\\n        }\\n        for (int i = r-1; i >= 0; i--) {\\n            if (grid[i][c] == 1 || grid[i][c] == 2) break;\\n            if (grid[i][c] == 0) {\\n                count++;\\n                grid[i][c] = 3;\\n            }\\n        }\\n        for (int i = c+1; i < n; i++) {\\n            if (grid[r][i] == 1 || grid[r][i] == 2) break;\\n            if (grid[r][i] == 0) {\\n                count++;\\n                grid[r][i] = 3;\\n            }\\n        }\\n        for (int i = c-1; i >= 0; i--) {\\n            if (grid[r][i] == 1 || grid[r][i] == 2) break;\\n            if (grid[r][i] == 0) {\\n                count++;\\n                grid[r][i] = 3;\\n            }\\n        }\\n        \\n    }\\n    int countUnguarded(int m, int n, vector<vector<int>>& guards, vector<vector<int>>& walls) {\\n        vector <vector <int>> grid(m, vector <int>(n, 0));\\n        // 0: free cell\\n        // 1: guard\\n        // 2: wall\\n        // 3: visited\\n        for (auto g : guards) {\\n            grid[g[0]][g[1]] = 1;\\n        }\\n        for (auto w : walls) {\\n            grid[w[0]][w[1]] = 2;\\n        }\\n        int count = 0;\\n        for (int i = 0; i < m; i++) {\\n            for (int j = 0; j < n; j++) {\\n                if (grid[i][j] == 1) {\\n                    helper(m, n, grid, count, i, j);\\n                }\\n            }\\n        }\\n        return m*n - guards.size() - walls.size() - count;\\n    }\\n};",
                "solutionTags": [
                    "C",
                    "Depth-First Search",
                    "Iterator"
                ],
                "code": "class Solution {\\npublic:\\n    void helper(int m, int n, vector <vector <int>>& grid, int& count, int r, int c) {\\n        for (int i = r+1; i < m; i++) {\\n            if (grid[i][c] == 1 || grid[i][c] == 2) break;\\n            if (grid[i][c] == 0) {\\n                count++;\\n                grid[i][c] = 3;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2017228,
                "title": "java-dfs-based-solution",
                "content": "```\\nclass Solution {\\n    public int countUnguarded(int m, int n, int[][] guards, int[][] walls) {\\n        int castle[][]=new int[m][n];\\n        for(int guard[]:guards){\\n            castle[guard[0]][guard[1]]=1;\\n        }\\n        for(int wall[]:walls){\\n            castle[wall[0]][wall[1]]=2;\\n        }\\n        for(int guard[]:guards){\\n            dfs(castle, guard[0]-1, guard[1], m, n, 1);\\n            dfs(castle, guard[0], guard[1]+1, m, n, 2);\\n            dfs(castle, guard[0]+1, guard[1], m, n, 3);\\n            dfs(castle, guard[0], guard[1]-1, m, n, 4);\\n        }\\n        int count=0;\\n        for(int i=0;i<m;i++){\\n            for(int j=0;j<n;j++){\\n                if(castle[i][j]==0){\\n                    count++;\\n                }\\n            }\\n        }\\n        return count;\\n        \\n    }\\n    public void dfs(int castle[][], int i, int j, int m, int n, int dir){\\n        if(i<0||j<0||i>=m||j>=n||castle[i][j]==2||castle[i][j]==1){\\n            return;\\n        }\\n        castle[i][j]=3;\\n        if(dir==1){\\n            dfs(castle, i-1, j, m, n, 1);\\n        }\\n        else if(dir==2){\\n            dfs(castle, i, j+1, m, n, 2);\\n        }\\n        else if(dir==3){\\n            dfs(castle, i+1, j, m, n, 3);\\n        }\\n        else{\\n            dfs(castle, i, j-1, m, n, 4);\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\n    public int countUnguarded(int m, int n, int[][] guards, int[][] walls) {\\n        int castle[][]=new int[m][n];\\n        for(int guard[]:guards){\\n            castle[guard[0]][guard[1]]=1;\\n        }\\n        for(int wall[]:walls){\\n            castle[wall[0]][wall[1]]=2;\\n        }\\n        for(int guard[]:guards){\\n            dfs(castle, guard[0]-1, guard[1], m, n, 1);\\n            dfs(castle, guard[0], guard[1]+1, m, n, 2);\\n            dfs(castle, guard[0]+1, guard[1], m, n, 3);\\n            dfs(castle, guard[0], guard[1]-1, m, n, 4);\\n        }\\n        int count=0;\\n        for(int i=0;i<m;i++){\\n            for(int j=0;j<n;j++){\\n                if(castle[i][j]==0){\\n                    count++;\\n                }\\n            }\\n        }\\n        return count;\\n        \\n    }\\n    public void dfs(int castle[][], int i, int j, int m, int n, int dir){\\n        if(i<0||j<0||i>=m||j>=n||castle[i][j]==2||castle[i][j]==1){\\n            return;\\n        }\\n        castle[i][j]=3;\\n        if(dir==1){\\n            dfs(castle, i-1, j, m, n, 1);\\n        }\\n        else if(dir==2){\\n            dfs(castle, i, j+1, m, n, 2);\\n        }\\n        else if(dir==3){\\n            dfs(castle, i+1, j, m, n, 3);\\n        }\\n        else{\\n            dfs(castle, i, j-1, m, n, 4);\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2010759,
                "title": "c-dfs-clean-and-concise",
                "content": "```\\nclass Solution {\\npublic:\\n    void dfs(int x,int y,vector<vector<int>>&grid,int dir,int m,int n)\\n    {\\n        if(x<0 or y<0 or x>=m or y>=n)\\n            return;\\n        if(grid[x][y]==2 or grid[x][y]==1)\\n            return;\\n        grid[x][y]=3;\\n        \\n        if(dir==1)\\n            dfs(x+1,y,grid,dir,m,n);\\n        else if(dir==2)\\n            dfs(x,y+1,grid,2,m,n);\\n        else if(dir==3)\\n            dfs(x-1,y,grid,3,m,n);\\n        else\\n            dfs(x,y-1,grid,4,m,n);\\n            \\n            \\n    }\\n    int countUnguarded(int m, int n, vector<vector<int>>& guards, vector<vector<int>>& walls) {\\n        \\n        vector<vector<int>>grid(m,vector<int>(n,0));\\n        \\n        int i,j;\\n        for(auto i:guards)\\n        {\\n            grid[i[0]][i[1]]=1;\\n        }\\n        for(auto i:walls)\\n        {\\n            grid[i[0]][i[1]]=2;\\n        }\\n        \\n        for(auto i:guards)\\n        {\\n            int x=i[0];\\n            int y=i[1];\\n            dfs(x+1,y,grid,1,m,n);\\n            dfs(x,y+1,grid,2,m,n);\\n            dfs(x-1,y,grid,3,m,n);\\n            dfs(x,y-1,grid,4,m,n);\\n            \\n        }\\n        int count=0;\\n        for(i=0;i<m;i++)\\n        {\\n            for(j=0;j<n;j++)\\n            {\\n                if(grid[i][j]==0)\\n                    count++;\\n            }\\n        }\\n        return count;\\n        \\n    }\\n};\\n```\\n\\n**Pls upvote the solution if you found helpful, it means a lot.\\nAlso comment down your doubts.\\nHappy Coding : )**",
                "solutionTags": [
                    "C++",
                    "C",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void dfs(int x,int y,vector<vector<int>>&grid,int dir,int m,int n)\\n    {\\n        if(x<0 or y<0 or x>=m or y>=n)\\n            return;\\n        if(grid[x][y]==2 or grid[x][y]==1)\\n            return;\\n        grid[x][y]=3;\\n        \\n        if(dir==1)\\n            dfs(x+1,y,grid,dir,m,n);\\n        else if(dir==2)\\n            dfs(x,y+1,grid,2,m,n);\\n        else if(dir==3)\\n            dfs(x-1,y,grid,3,m,n);\\n        else\\n            dfs(x,y-1,grid,4,m,n);\\n            \\n            \\n    }\\n    int countUnguarded(int m, int n, vector<vector<int>>& guards, vector<vector<int>>& walls) {\\n        \\n        vector<vector<int>>grid(m,vector<int>(n,0));\\n        \\n        int i,j;\\n        for(auto i:guards)\\n        {\\n            grid[i[0]][i[1]]=1;\\n        }\\n        for(auto i:walls)\\n        {\\n            grid[i[0]][i[1]]=2;\\n        }\\n        \\n        for(auto i:guards)\\n        {\\n            int x=i[0];\\n            int y=i[1];\\n            dfs(x+1,y,grid,1,m,n);\\n            dfs(x,y+1,grid,2,m,n);\\n            dfs(x-1,y,grid,3,m,n);\\n            dfs(x,y-1,grid,4,m,n);\\n            \\n        }\\n        int count=0;\\n        for(i=0;i<m;i++)\\n        {\\n            for(j=0;j<n;j++)\\n            {\\n                if(grid[i][j]==0)\\n                    count++;\\n            }\\n        }\\n        return count;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1998029,
                "title": "c-2-approach-iterative-dfs",
                "content": "*for reference:* \\n**cell[ i ][ j ]=**\\n0-> not guarded zone\\n1-> can be watched [guarded zone]\\n2-> guards \\n3-> walls\\n\\n\\n**Iterative:**\\n```\\nclass Solution {\\npublic:\\n    void traverse(int i,int j,vector<vector<int>>& cell){\\n        for(int k=i-1;k>=0;k--){ // up side traverse\\n            if(cell[k][j]==3 or cell[k][j]==2) break;\\n            else cell[k][j]=1;\\n        }\\n        for(int k=i+1;k<cell.size();k++){ //down side traverse\\n            if(cell[k][j]==3 or cell[k][j]==2) break;\\n            else cell[k][j]=1;\\n        }\\n        for(int k=j-1;k>=0;k--){ //left side traverse\\n            if(cell[i][k]==3 or cell[i][k]==2) break;\\n            else cell[i][k]=1;\\n        }\\n        for(int k=j+1;k<cell[i].size();k++){ //right side traverse\\n            if(cell[i][k]==3 or cell[i][k]==2) break;\\n            else cell[i][k]=1;\\n        }\\n    }\\n    \\n    int countUnguarded(int m, int n, vector<vector<int>>& guards, vector<vector<int>>& walls) {\\n        vector<vector<int>> cell(m, vector<int>(n));\\n        for(int i=0;i<guards.size();i++){\\n            cell[guards[i][0]][guards[i][1]]=2;\\n        }\\n        for(int i=0;i<walls.size();i++){\\n            cell[walls[i][0]][walls[i][1]]=3;\\n        }\\n        for(int i=0;i<guards.size();i++){\\n            traverse(guards[i][0],guards[i][1],cell);\\n        }\\n        int count=0;\\n        for(auto x:cell){\\n            for(auto y:x)\\n                if(y==0) count++;\\n        }\\n        return count;\\n    }\\n};\\n```\\n\\n\\n**DFS:**\\n```\\nclass Solution {\\npublic:\\n    void dfs(int i,int j,vector<vector<int>>& cell, char direction){\\n        if(i<0 or i>=cell.size() or j<0 or j>=cell[i].size() or cell[i][j]==2 or cell[i][j]==3)\\n            return;\\n        cell[i][j]=1;\\n        if(direction==\\'U\\')\\n            dfs(i-1,j,cell,\\'U\\');\\n        if(direction==\\'D\\')\\n            dfs(i+1,j,cell,\\'D\\');\\n        if(direction==\\'L\\')\\n            dfs(i,j-1,cell,\\'L\\');\\n        if(direction==\\'R\\')\\n            dfs(i,j+1,cell,\\'R\\');\\n    }\\n    \\n    int countUnguarded(int m, int n, vector<vector<int>>& guards, vector<vector<int>>& walls) {\\n        vector<vector<int>> cell(m, vector<int>(n));\\n        for(int i=0;i<guards.size();i++){\\n            cell[guards[i][0]][guards[i][1]]=2;\\n        }\\n        for(int i=0;i<walls.size();i++){\\n            cell[walls[i][0]][walls[i][1]]=3;\\n        }\\n        for(int i=0;i<guards.size();i++){\\n            dfs(guards[i][0]-1,guards[i][1],cell,\\'U\\'); // up\\n            dfs(guards[i][0]+1,guards[i][1],cell,\\'D\\'); // down\\n            dfs(guards[i][0],guards[i][1]-1,cell,\\'L\\'); // left\\n            dfs(guards[i][0],guards[i][1]+1,cell,\\'R\\'); // right\\n        }\\n        int count=0;\\n        for(auto x:cell){\\n            for(auto y:x)\\n                if(y==0) count++;\\n        }\\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void traverse(int i,int j,vector<vector<int>>& cell){\\n        for(int k=i-1;k>=0;k--){ // up side traverse\\n            if(cell[k][j]==3 or cell[k][j]==2) break;\\n            else cell[k][j]=1;\\n        }\\n        for(int k=i+1;k<cell.size();k++){ //down side traverse\\n            if(cell[k][j]==3 or cell[k][j]==2) break;\\n            else cell[k][j]=1;\\n        }\\n        for(int k=j-1;k>=0;k--){ //left side traverse\\n            if(cell[i][k]==3 or cell[i][k]==2) break;\\n            else cell[i][k]=1;\\n        }\\n        for(int k=j+1;k<cell[i].size();k++){ //right side traverse\\n            if(cell[i][k]==3 or cell[i][k]==2) break;\\n            else cell[i][k]=1;\\n        }\\n    }\\n    \\n    int countUnguarded(int m, int n, vector<vector<int>>& guards, vector<vector<int>>& walls) {\\n        vector<vector<int>> cell(m, vector<int>(n));\\n        for(int i=0;i<guards.size();i++){\\n            cell[guards[i][0]][guards[i][1]]=2;\\n        }\\n        for(int i=0;i<walls.size();i++){\\n            cell[walls[i][0]][walls[i][1]]=3;\\n        }\\n        for(int i=0;i<guards.size();i++){\\n            traverse(guards[i][0],guards[i][1],cell);\\n        }\\n        int count=0;\\n        for(auto x:cell){\\n            for(auto y:x)\\n                if(y==0) count++;\\n        }\\n        return count;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    void dfs(int i,int j,vector<vector<int>>& cell, char direction){\\n        if(i<0 or i>=cell.size() or j<0 or j>=cell[i].size() or cell[i][j]==2 or cell[i][j]==3)\\n            return;\\n        cell[i][j]=1;\\n        if(direction==\\'U\\')\\n            dfs(i-1,j,cell,\\'U\\');\\n        if(direction==\\'D\\')\\n            dfs(i+1,j,cell,\\'D\\');\\n        if(direction==\\'L\\')\\n            dfs(i,j-1,cell,\\'L\\');\\n        if(direction==\\'R\\')\\n            dfs(i,j+1,cell,\\'R\\');\\n    }\\n    \\n    int countUnguarded(int m, int n, vector<vector<int>>& guards, vector<vector<int>>& walls) {\\n        vector<vector<int>> cell(m, vector<int>(n));\\n        for(int i=0;i<guards.size();i++){\\n            cell[guards[i][0]][guards[i][1]]=2;\\n        }\\n        for(int i=0;i<walls.size();i++){\\n            cell[walls[i][0]][walls[i][1]]=3;\\n        }\\n        for(int i=0;i<guards.size();i++){\\n            dfs(guards[i][0]-1,guards[i][1],cell,\\'U\\'); // up\\n            dfs(guards[i][0]+1,guards[i][1],cell,\\'D\\'); // down\\n            dfs(guards[i][0],guards[i][1]-1,cell,\\'L\\'); // left\\n            dfs(guards[i][0],guards[i][1]+1,cell,\\'R\\'); // right\\n        }\\n        int count=0;\\n        for(auto x:cell){\\n            for(auto y:x)\\n                if(y==0) count++;\\n        }\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1995531,
                "title": "java-brute-force-matrix-filling-simulation-no-bfs-dfs-anything",
                "content": "The problem looks complex at first. But look at the constraints:\\n```\\n1 <= m, n <= 100,000\\n2 <= m * n <= 100,000\\n```\\ni.e. matrix max size is 100,000. Cosnidering using a char matrix - so size is ~ 100kb * 4 bytes of char = 400kb. Not much. If you use char array, you reduce the size.\\nAlso, 100,000 iterations is not much.\\nSo I thought that \"Let me try brute force first\". I did bruteforce, but hit TLE. That was because of the way I laid out my code. Eventually I got it working.\\n\\nSome basic stuff\\n1. Each wall is a blocker.\\n2. Each guard is a blocker. Although he can also see other cells.\\n\\t- so solve guard in 2 steps.\\n\\t- Step 1: Mark him as a block\\n\\t- Step 2: Mark the area he can view\\n3. Area blocked by a guard\\'s view is different than one blocked by Wall/Guard. Why? Because a guard\\'s view can cross this block in any direction.\\n4. So we end up with two kind of blocks \\n\\t- full block - wall/guard\\n\\t- view block - guard\\'s view\\n\\tLet\\'s denote these by 1 and 2 respectively.\\n5. So we store 3 states\\n\\t- un-blocked - 0\\n\\t- full blocked - 1\\n\\t- view blocked - 2\\nNote: These can also be represented by Boolean as it has 3 states (null, true, false) to optimize space usage and reduce it to 100kb. But I am not going to do that.\\n6. Finally - we can either parse whole prison again to get a count of free cells. Or just do this count while filling up. In my code I am counting it when filling up the prison. You could do it after filling up too - to make your code simpler.\\n7. Time Complexity = O ( guards * (ROWS + COLS)).\\n\\t- For each guard, I am marking row & col as view blocked - hence ROWS + COLS\\n\\t- So guard * (ROWS + COLS)\\n8. Code has a print() to show state of prison after calculation of every guard. This shall let you visualize how the code is working.\\n\\nHere is a simulation of example of question.\\nRemember\\n* 0 = un-blocked\\n* 1 = fully blocked\\n* 2 = view blocked\\n```\\nAfter filling walls and guards\\n  1  1  0  0  0  0\\n  0  1  0  0  1  0\\n  0  0  1  1  0  0\\n  0  0  0  0  0  0\\nAfter solving guard[0][0]\\n  1  1  0  0  0  0\\n  2  1  0  0  1  0\\n  2  0  1  1  0  0\\n  2  0  0  0  0  0\\nAfter solving guard[1][1]\\n  1  1  0  0  0  0\\n  2  1  2  2  1  0\\n  2  2  1  1  0  0\\n  2  2  0  0  0  0\\nAfter solving guard[2][3]\\n  1  1  0  2  0  0\\n  2  1  2  2  1  0\\n  2  2  1  1  2  2\\n  2  2  0  2  0  0\\n```\\n\\n\\nFinally the code\\n```\\nclass Solution {\\n    public int countUnguarded(int ROWS, int COLS, int[][] guards, int[][] walls) {\\n        int[][] prison = new int[ROWS][COLS];\\n        \\n        int prisonCells = ROWS * COLS;\\n        \\n        // Filling up prison with walls\\n        int walledCells = walls.length;\\n        for(int[] wall: walls) {\\n            prison[wall[0]][wall[1]] = 1;\\n        }\\n        \\n        // Filling up prison with guards\\n        int guardedCells = guards.length;\\n        for(int[] guard: guards) {\\n            prison[guard[0]][guard[1]] = 1;\\n        }\\n        \\n        // For each guard, marking view path\\n        for(int[] guard: guards) {\\n            int guardRow = guard[0];\\n            int guardCol = guard[1];\\n\\n            // run to top, not counting guard\\'s cell\\n            for(int row = guardRow - 1, col = guardCol; row >= 0 && prison[row][col] != 1;  row--) {\\n                if(prison[row][col] != 2) {  // to avoid counting view block cell twice\\n                    guardedCells++;\\n                }\\n                prison[row][col] = 2;\\n            }\\n            \\n            // run to bottom, not counting guard\\'s cell\\n            for(int row = guardRow + 1, col = guardCol; row < ROWS && prison[row][col] != 1; row++) {\\n                if(prison[row][col] != 2) {  // to avoid counting view block cell twice\\n                    guardedCells++;\\n                }\\n                prison[row][col] = 2;\\n            }\\n            \\n            // run to left, not counting guard\\'s cell\\n            for(int row = guardRow, col = guardCol - 1; col >= 0 && prison[row][col] != 1; col--) {\\n                if(prison[row][col] != 2) {  // to avoid counting view block cell twice\\n                    guardedCells++;\\n                }\\n                prison[row][col] = 2;\\n            }\\n            \\n            // run to right, not counting guard\\'s cell\\n            for(int row = guardRow, col = guardCol + 1; col < COLS && prison[row][col] != 1; col++) {\\n                if(prison[row][col] != 2) {  // to avoid counting view block cell twice\\n                    guardedCells++;\\n                }\\n                prison[row][col] = 2;\\n            }\\n            \\n            // Comment out this line before submission - only for simulation\\n            print(prison, \"After solving guard[\"+guard[0]+\"][\"+guard[1]+\"]\");\\n            \\n        }\\n        \\n        return prisonCells - (guardedCells + walledCells);\\n    }\\n    \\n    \\n    private void print(int[][] arr, String message) {\\n        System.out.println(message);\\n        for(int r = 0; r < arr.length; r++) {\\n            for(int c = 0; c < arr[0].length; c++) {\\n                System.out.print(\"  \" + arr[r][c]);\\n            }\\n            System.out.println(\"\");\\n        }\\n    }\\n}\\n```\\n\\nRemember to remove the call to print(arr) before submitting. \\n\\n",
                "solutionTags": [
                    "Simulation"
                ],
                "code": "```\\n1 <= m, n <= 100,000\\n2 <= m * n <= 100,000\\n```\n```\\nAfter filling walls and guards\\n  1  1  0  0  0  0\\n  0  1  0  0  1  0\\n  0  0  1  1  0  0\\n  0  0  0  0  0  0\\nAfter solving guard[0][0]\\n  1  1  0  0  0  0\\n  2  1  0  0  1  0\\n  2  0  1  1  0  0\\n  2  0  0  0  0  0\\nAfter solving guard[1][1]\\n  1  1  0  0  0  0\\n  2  1  2  2  1  0\\n  2  2  1  1  0  0\\n  2  2  0  0  0  0\\nAfter solving guard[2][3]\\n  1  1  0  2  0  0\\n  2  1  2  2  1  0\\n  2  2  1  1  2  2\\n  2  2  0  2  0  0\\n```\n```\\nclass Solution {\\n    public int countUnguarded(int ROWS, int COLS, int[][] guards, int[][] walls) {\\n        int[][] prison = new int[ROWS][COLS];\\n        \\n        int prisonCells = ROWS * COLS;\\n        \\n        // Filling up prison with walls\\n        int walledCells = walls.length;\\n        for(int[] wall: walls) {\\n            prison[wall[0]][wall[1]] = 1;\\n        }\\n        \\n        // Filling up prison with guards\\n        int guardedCells = guards.length;\\n        for(int[] guard: guards) {\\n            prison[guard[0]][guard[1]] = 1;\\n        }\\n        \\n        // For each guard, marking view path\\n        for(int[] guard: guards) {\\n            int guardRow = guard[0];\\n            int guardCol = guard[1];\\n\\n            // run to top, not counting guard\\'s cell\\n            for(int row = guardRow - 1, col = guardCol; row >= 0 && prison[row][col] != 1;  row--) {\\n                if(prison[row][col] != 2) {  // to avoid counting view block cell twice\\n                    guardedCells++;\\n                }\\n                prison[row][col] = 2;\\n            }\\n            \\n            // run to bottom, not counting guard\\'s cell\\n            for(int row = guardRow + 1, col = guardCol; row < ROWS && prison[row][col] != 1; row++) {\\n                if(prison[row][col] != 2) {  // to avoid counting view block cell twice\\n                    guardedCells++;\\n                }\\n                prison[row][col] = 2;\\n            }\\n            \\n            // run to left, not counting guard\\'s cell\\n            for(int row = guardRow, col = guardCol - 1; col >= 0 && prison[row][col] != 1; col--) {\\n                if(prison[row][col] != 2) {  // to avoid counting view block cell twice\\n                    guardedCells++;\\n                }\\n                prison[row][col] = 2;\\n            }\\n            \\n            // run to right, not counting guard\\'s cell\\n            for(int row = guardRow, col = guardCol + 1; col < COLS && prison[row][col] != 1; col++) {\\n                if(prison[row][col] != 2) {  // to avoid counting view block cell twice\\n                    guardedCells++;\\n                }\\n                prison[row][col] = 2;\\n            }\\n            \\n            // Comment out this line before submission - only for simulation\\n            print(prison, \"After solving guard[\"+guard[0]+\"][\"+guard[1]+\"]\");\\n            \\n        }\\n        \\n        return prisonCells - (guardedCells + walledCells);\\n    }\\n    \\n    \\n    private void print(int[][] arr, String message) {\\n        System.out.println(message);\\n        for(int r = 0; r < arr.length; r++) {\\n            for(int c = 0; c < arr[0].length; c++) {\\n                System.out.print(\"  \" + arr[r][c]);\\n            }\\n            System.out.println(\"\");\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1995260,
                "title": "explained-an-elegant-simple-approach-100-faster-and-100-better-space",
                "content": "Just a couple of points to consider, and its a piece of cake;\\n> 1. We begin by marking Guard and Wall on a grid to do our analysis.\\n> 2. Then iteratively, we will go to each guard and see how far it can see in all 4 cardinal directions. We will keep looking until we find a wall (or a guard, explained later).\\nHere is the Code;\\n\\n```\\nclass Solution {\\npublic:\\n    int countUnguarded(int m, int n, vector<vector<int>>& g, vector<vector<int>>& w) {\\n        vector<vector<int>> grid(m, vector<int> (n, 0));\\n        for(int i=0; i<g.size(); i++){\\n            grid[g[i][0]][g[i][1]]=2;\\n        }\\n\\t\\t\\n        for(int i=0; i<w.size(); i++){\\n            grid[w[i][0]][w[i][1]]=-2;\\n        }\\n        \\n        for(int i=0; i<g.size(); i++){\\n            int cx = g[i][0];\\n            int cy = g[i][1];\\n            for(int i=cx+1; i<m; i++){\\n                if(grid[i][cy]==2 || grid[i][cy]==-2) break;\\n                grid[i][cy]=1;\\n            }\\n            for(int i=cx-1; i>=0; i--){\\n                if(grid[i][cy]==2 || grid[i][cy]==-2) break;\\n                grid[i][cy]=1;\\n            }\\n            for(int j=cy+1; j<n; j++){\\n                if(grid[cx][j]==2 || grid[cx][j]==-2) break;\\n                grid[cx][j]=1;\\n            }\\n            for(int j=cy-1; j>=0; j--){\\n                if(grid[cx][j]==2 || grid[cx][j]==-2) break;\\n                grid[cx][j]=1;\\n            }\\n        }\\n        \\n        int ct=0;\\n        for(int i=0; i<m; i++){\\n            for(int j=0; j<n; j++){\\n                if(grid[i][j]==0) ct++;\\n            }\\n        }\\n        \\n        return ct;\\n    }\\n};\\n```\\n\\n\\nNow, One interesting thing is, We can optimize this code (slightly) by eliminating the redundant calculations. Here\\'s how;\\n> 1. In a manner of speaking, wall and guard are almost same when it comes to obstructing the view of a guard. If there is a wall (or a guard) in the view-line of a guard, we can stop looking more for it. Why? Because wall is obstructing guard\\'s view (obviously!) and the other guard will perform the same way as the first guard\\'s sight.\\nSo, we can update the code as;\\n\\n\\n```\\nclass Solution {\\npublic:\\n    int countUnguarded(int m, int n, vector<vector<int>>& g, vector<vector<int>>& w) {\\n        vector<vector<int>> grid(m, vector<int> (n, 0));\\n        \\n        for(int i=0; i<g.size(); i++){\\n            grid[g[i][0]][g[i][1]]=2;\\n        }\\n        \\n        for(int i=0; i<w.size(); i++){\\n            grid[w[i][0]][w[i][1]]=2;\\n        }\\n        \\n        for(int i=0; i<g.size(); i++){\\n            int cx = g[i][0];\\n            int cy = g[i][1];\\n            for(int i=cx+1; i<m; i++){\\n                if(grid[i][cy]==2) break;\\n                grid[i][cy]=1;\\n            }\\n            for(int i=cx-1; i>=0; i--){\\n                if(grid[i][cy]==2) break;\\n                grid[i][cy]=1;\\n            }\\n            for(int j=cy+1; j<n; j++){\\n                if(grid[cx][j]==2) break;\\n                grid[cx][j]=1;\\n            }\\n            for(int j=cy-1; j>=0; j--){\\n                if(grid[cx][j]==2) break;\\n                grid[cx][j]=1;\\n            }\\n        }\\n        \\n        int ct=0;\\n        for(int i=0; i<m; i++){\\n            for(int j=0; j<n; j++){\\n                if(grid[i][j]==0) ct++;\\n            }\\n        }\\n        \\n        return ct;\\n    }\\n};\\n```\\n\\nLet me know if you\\'d like to add any point of if I have missed anything.\\nHappy Coding!",
                "solutionTags": [
                    "C++",
                    "C",
                    "Simulation"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int countUnguarded(int m, int n, vector<vector<int>>& g, vector<vector<int>>& w) {\\n        vector<vector<int>> grid(m, vector<int> (n, 0));\\n        for(int i=0; i<g.size(); i++){\\n            grid[g[i][0]][g[i][1]]=2;\\n        }\\n\\t\\t\\n        for(int i=0; i<w.size(); i++){\\n            grid[w[i][0]][w[i][1]]=-2;\\n        }\\n        \\n        for(int i=0; i<g.size(); i++){\\n            int cx = g[i][0];\\n            int cy = g[i][1];\\n            for(int i=cx+1; i<m; i++){\\n                if(grid[i][cy]==2 || grid[i][cy]==-2) break;\\n                grid[i][cy]=1;\\n            }\\n            for(int i=cx-1; i>=0; i--){\\n                if(grid[i][cy]==2 || grid[i][cy]==-2) break;\\n                grid[i][cy]=1;\\n            }\\n            for(int j=cy+1; j<n; j++){\\n                if(grid[cx][j]==2 || grid[cx][j]==-2) break;\\n                grid[cx][j]=1;\\n            }\\n            for(int j=cy-1; j>=0; j--){\\n                if(grid[cx][j]==2 || grid[cx][j]==-2) break;\\n                grid[cx][j]=1;\\n            }\\n        }\\n        \\n        int ct=0;\\n        for(int i=0; i<m; i++){\\n            for(int j=0; j<n; j++){\\n                if(grid[i][j]==0) ct++;\\n            }\\n        }\\n        \\n        return ct;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int countUnguarded(int m, int n, vector<vector<int>>& g, vector<vector<int>>& w) {\\n        vector<vector<int>> grid(m, vector<int> (n, 0));\\n        \\n        for(int i=0; i<g.size(); i++){\\n            grid[g[i][0]][g[i][1]]=2;\\n        }\\n        \\n        for(int i=0; i<w.size(); i++){\\n            grid[w[i][0]][w[i][1]]=2;\\n        }\\n        \\n        for(int i=0; i<g.size(); i++){\\n            int cx = g[i][0];\\n            int cy = g[i][1];\\n            for(int i=cx+1; i<m; i++){\\n                if(grid[i][cy]==2) break;\\n                grid[i][cy]=1;\\n            }\\n            for(int i=cx-1; i>=0; i--){\\n                if(grid[i][cy]==2) break;\\n                grid[i][cy]=1;\\n            }\\n            for(int j=cy+1; j<n; j++){\\n                if(grid[cx][j]==2) break;\\n                grid[cx][j]=1;\\n            }\\n            for(int j=cy-1; j>=0; j--){\\n                if(grid[cx][j]==2) break;\\n                grid[cx][j]=1;\\n            }\\n        }\\n        \\n        int ct=0;\\n        for(int i=0; i<m; i++){\\n            for(int j=0; j<n; j++){\\n                if(grid[i][j]==0) ct++;\\n            }\\n        }\\n        \\n        return ct;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1995166,
                "title": "java-easy-commented-iterative",
                "content": "```\\nclass Solution {\\n    public int countUnguarded(int n, int m, int[][] guards, int[][] walls) {\\n        int[][] grid = new int[n][m];\\n        //1-> guard\\n        //2-> walls \\n        //3-> guarded\\n        //0-> not guarded\\n\\t\\t\\n\\t\\t//putting values for guard\\n        for(int[] i : guards) {\\n            grid[i[0]][i[1]] = 1;\\n        }\\n        \\n\\t\\t//putting values for walls\\n        for(int[] i : walls) {\\n            grid[i[0]][i[1]] = 2;\\n        }\\n        \\n\\t\\t//traversing guards\\n        for(int j = 0; j < guards.length; j++) {\\n\\t\\t\\t//x and y co ordinate for guard\\n            int x = guards[j][0], y = guards[j][1];\\n            \\n\\t\\t\\t//traversing right side of guard\\n            for(int i = x+1; i < n; i++) {\\n\\t\\t\\t\\n\\t\\t\\t\\t//if not guarded, guard the walls\\n                if(grid[i][y] == 0) grid[i][y] = 3;\\n\\t\\t\\t\\t\\n\\t\\t\\t\\t//breaking if encountered a wall or guard (as we will be traversing for that guard while traversing \"guards\" array)\\n                else if(grid[i][y] == 2 || grid[i][y] == 1) break;\\n            }\\n            \\n\\t\\t\\t//traversing left side of guard\\n            for(int i = x-1; i >= 0; i--) {\\n\\t\\t\\t\\n\\t\\t\\t\\t//if not guarded, guard the walls\\n                if(grid[i][y] == 0) grid[i][y] = 3;\\n\\t\\t\\t\\t\\n\\t\\t\\t\\t//breaking if encountered a wall or guard (as we will be traversing for that guard while traversing \"guards\" array)\\n                else if(grid[i][y] == 2 || grid[i][y] == 1) break;\\n            }\\n            \\n\\t\\t\\t//traversing upper side of guard\\n            for(int i = y+1; i < m; i++) {\\n\\t\\t\\t\\n\\t\\t\\t\\t//if not guarded, guard the walls\\n                if(grid[x][i] == 0) grid[x][i] = 3;\\n\\t\\t\\t\\t\\n\\t\\t\\t\\t//breaking if encountered a wall or guard (as we will be traversing for that guard while traversing \"guards\" array)\\n                else if(grid[x][i] == 2 || grid[x][i] == 1) break;\\n            }\\n            \\n\\t\\t\\t//traversing lower side fo guard\\n            for(int i = y-1; i >= 0; i--) {\\n\\t\\t\\t\\n\\t\\t\\t\\t//if not guarded, guard the walls\\n                if(grid[x][i] == 0) grid[x][i] = 3;\\n\\t\\t\\t\\t\\n\\t\\t\\t\\t//breaking if encountered a wall or guard (as we will be traversing for that guard while traversing \"guards\" array)\\n                else if(grid[x][i] == 2 || grid[x][i] == 1) break;\\n            }\\n        }\\n        \\n        int ans = 0;\\n        for(int i =0; i < n; i++) {\\n            for(int j = 0; j < m; j++) {\\n                if(grid[i][j] == 0) ans++;\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```\\nDo upvote if the solution helped \\u270C",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int countUnguarded(int n, int m, int[][] guards, int[][] walls) {\\n        int[][] grid = new int[n][m];\\n        //1-> guard\\n        //2-> walls \\n        //3-> guarded\\n        //0-> not guarded\\n\\t\\t\\n\\t\\t//putting values for guard\\n        for(int[] i : guards) {\\n            grid[i[0]][i[1]] = 1;\\n        }\\n        \\n\\t\\t//putting values for walls\\n        for(int[] i : walls) {\\n            grid[i[0]][i[1]] = 2;\\n        }\\n        \\n\\t\\t//traversing guards\\n        for(int j = 0; j < guards.length; j++) {\\n\\t\\t\\t//x and y co ordinate for guard\\n            int x = guards[j][0], y = guards[j][1];\\n            \\n\\t\\t\\t//traversing right side of guard\\n            for(int i = x+1; i < n; i++) {\\n\\t\\t\\t\\n\\t\\t\\t\\t//if not guarded, guard the walls\\n                if(grid[i][y] == 0) grid[i][y] = 3;\\n\\t\\t\\t\\t\\n\\t\\t\\t\\t//breaking if encountered a wall or guard (as we will be traversing for that guard while traversing \"guards\" array)\\n                else if(grid[i][y] == 2 || grid[i][y] == 1) break;\\n            }\\n            \\n\\t\\t\\t//traversing left side of guard\\n            for(int i = x-1; i >= 0; i--) {\\n\\t\\t\\t\\n\\t\\t\\t\\t//if not guarded, guard the walls\\n                if(grid[i][y] == 0) grid[i][y] = 3;\\n\\t\\t\\t\\t\\n\\t\\t\\t\\t//breaking if encountered a wall or guard (as we will be traversing for that guard while traversing \"guards\" array)\\n                else if(grid[i][y] == 2 || grid[i][y] == 1) break;\\n            }\\n            \\n\\t\\t\\t//traversing upper side of guard\\n            for(int i = y+1; i < m; i++) {\\n\\t\\t\\t\\n\\t\\t\\t\\t//if not guarded, guard the walls\\n                if(grid[x][i] == 0) grid[x][i] = 3;\\n\\t\\t\\t\\t\\n\\t\\t\\t\\t//breaking if encountered a wall or guard (as we will be traversing for that guard while traversing \"guards\" array)\\n                else if(grid[x][i] == 2 || grid[x][i] == 1) break;\\n            }\\n            \\n\\t\\t\\t//traversing lower side fo guard\\n            for(int i = y-1; i >= 0; i--) {\\n\\t\\t\\t\\n\\t\\t\\t\\t//if not guarded, guard the walls\\n                if(grid[x][i] == 0) grid[x][i] = 3;\\n\\t\\t\\t\\t\\n\\t\\t\\t\\t//breaking if encountered a wall or guard (as we will be traversing for that guard while traversing \"guards\" array)\\n                else if(grid[x][i] == 2 || grid[x][i] == 1) break;\\n            }\\n        }\\n        \\n        int ans = 0;\\n        for(int i =0; i < n; i++) {\\n            for(int j = 0; j < m; j++) {\\n                if(grid[i][j] == 0) ans++;\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1994806,
                "title": "simple-python-code",
                "content": "```\\nclass Solution:\\n    def countUnguarded(self, m: int, n: int, guards: List[List[int]], walls: List[List[int]]) -> int:\\n        vis = [[0]*n for _ in range(m)]\\n        # i - rows, j - colums\\n        # sum(row.count(\\'hit\\') for row in grid)\\n        for i,j in walls:\\n            vis[i][j] = 2\\n        for i,j in guards:\\n            vis[i][j] = 2\\n        for i,j in guards:\\n            for l in range(j-1,-1,-1):\\n                if self.checkWall(i,l,vis):\\n                    break    \\n                vis[i][l] = 1\\n            for r in range(j+1,n):\\n                if self.checkWall(i,r,vis):\\n                    break\\n                vis[i][r] = 1\\n            for u in range(i-1,-1,-1):\\n                if self.checkWall(u,j,vis):\\n                    break\\n                vis[u][j] = 1\\n            for d in range(i+1,m):\\n                if self.checkWall(d,j, vis):\\n                    break\\n                vis[d][j] = 1\\n        return sum(row.count(0) for row in vis)\\n        \\n    def checkWall(self, i, j, vis):\\n        if vis[i][j] ==2:\\n            return True\\n            \\n```",
                "solutionTags": [
                    "Python3",
                    "Array"
                ],
                "code": "```\\nclass Solution:\\n    def countUnguarded(self, m: int, n: int, guards: List[List[int]], walls: List[List[int]]) -> int:\\n        vis = [[0]*n for _ in range(m)]\\n        # i - rows, j - colums\\n        # sum(row.count(\\'hit\\') for row in grid)\\n        for i,j in walls:\\n            vis[i][j] = 2\\n        for i,j in guards:\\n            vis[i][j] = 2\\n        for i,j in guards:\\n            for l in range(j-1,-1,-1):\\n                if self.checkWall(i,l,vis):\\n                    break    \\n                vis[i][l] = 1\\n            for r in range(j+1,n):\\n                if self.checkWall(i,r,vis):\\n                    break\\n                vis[i][r] = 1\\n            for u in range(i-1,-1,-1):\\n                if self.checkWall(u,j,vis):\\n                    break\\n                vis[u][j] = 1\\n            for d in range(i+1,m):\\n                if self.checkWall(d,j, vis):\\n                    break\\n                vis[d][j] = 1\\n        return sum(row.count(0) for row in vis)\\n        \\n    def checkWall(self, i, j, vis):\\n        if vis[i][j] ==2:\\n            return True\\n            \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1994707,
                "title": "solved-why-my-code-gives-tle",
                "content": "```\\nclass Solution {\\npublic:\\n    \\n    void help(vector<vector<int>> &mat,vector<int> g){\\n        // below\\n        for(int i=g[0];i<mat.size();i++){\\n            if(mat[i][g[1]]==-1){\\n                break;\\n            }else{\\n                mat[i][g[1]] = 1;\\n            }\\n        }\\n        // above\\n        for(int i=g[0];i>=0;i--){\\n            if(mat[i][g[1]]==-1){\\n                break;\\n            }else{\\n                mat[i][g[1]] = 1;\\n            }\\n        }\\n        //left\\n        for(int i=g[1];i>=0;i--){\\n            if(mat[g[0]][i]==-1){\\n                break;\\n            }else{\\n                mat[g[0]][i] = 1;\\n            }\\n        }\\n        // right\\n        for(int i=g[1];i<mat[0].size();i++){\\n            if(mat[g[0]][i]==-1){\\n                break;\\n            }else{\\n                mat[g[0]][i] = 1;\\n            }\\n        }\\n    }\\n    \\n    int countUnguarded(int m, int n, vector<vector<int>>& guards, vector<vector<int>>& walls) {\\n        vector<vector<int>> mat(m,vector<int>(n,0));\\n        for(int i=0;i<guards.size();i++){\\n            mat[guards[i][0]][guards[i][1]] = 1;\\n        }\\n        for(int i=0;i<walls.size();i++){\\n            mat[walls[i][0]][walls[i][1]] = -1;\\n        }\\n        for(int i=0;i<guards.size();i++){\\n            help(mat,guards[i]);\\n        }\\n        int cnt=0;\\n        for(int i=0;i<m;i++){\\n            for(int j=0;j<n;j++){\\n                if(mat[i][j]==0) cnt++;\\n            }\\n        }\\n        return cnt;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    void help(vector<vector<int>> &mat,vector<int> g){\\n        // below\\n        for(int i=g[0];i<mat.size();i++){\\n            if(mat[i][g[1]]==-1){\\n                break;\\n            }else{\\n                mat[i][g[1]] = 1;\\n            }\\n        }\\n        // above\\n        for(int i=g[0];i>=0;i--){\\n            if(mat[i][g[1]]==-1){\\n                break;\\n            }else{\\n                mat[i][g[1]] = 1;\\n            }\\n        }\\n        //left\\n        for(int i=g[1];i>=0;i--){\\n            if(mat[g[0]][i]==-1){\\n                break;\\n            }else{\\n                mat[g[0]][i] = 1;\\n            }\\n        }\\n        // right\\n        for(int i=g[1];i<mat[0].size();i++){\\n            if(mat[g[0]][i]==-1){\\n                break;\\n            }else{\\n                mat[g[0]][i] = 1;\\n            }\\n        }\\n    }\\n    \\n    int countUnguarded(int m, int n, vector<vector<int>>& guards, vector<vector<int>>& walls) {\\n        vector<vector<int>> mat(m,vector<int>(n,0));\\n        for(int i=0;i<guards.size();i++){\\n            mat[guards[i][0]][guards[i][1]] = 1;\\n        }\\n        for(int i=0;i<walls.size();i++){\\n            mat[walls[i][0]][walls[i][1]] = -1;\\n        }\\n        for(int i=0;i<guards.size();i++){\\n            help(mat,guards[i]);\\n        }\\n        int cnt=0;\\n        for(int i=0;i<m;i++){\\n            for(int j=0;j<n;j++){\\n                if(mat[i][j]==0) cnt++;\\n            }\\n        }\\n        return cnt;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1994704,
                "title": "easy-brute-force-c-with-comments",
                "content": "```\\nclass Solution {\\npublic:\\n    int countUnguarded(int m, int n, vector<vector<int>>& g, vector<vector<int>>& w) {\\n        vector<vector<short int>> vec(m,vector<short int>(n,0));\\n\\t\\t// to check all directions in which we have already travelled\\n        bool vis[m][n][4];\\n        memset(vis,false,sizeof(vis));\\n        for(auto i:w)\\n            vec[i[0]][i[1]]=-1;\\n        \\n        for(auto i:g)\\n        {\\n\\t\\t\\t// marking true at 0 index of vec[i][j] -> upward direction from this point is visited\\n            for(int j=i[0];j>=0;j--)\\n\\t\\t\\t{\\n\\t\\t\\t\\tif(vec[j][i[1]]!=-1 && !vis[j][i[1]][0])\\n\\t\\t\\t\\t\\tvec[j][i[1]]=1,vis[j][i[1]][0]=1;\\n\\t\\t\\t\\telse\\n\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t}\\n\\t\\t\\t// marking true at 1 index of vec[i][j] -> left direction from this point is visited\\n            for(int j=i[1]-1;j>=0;j--)\\n\\t\\t\\t{\\n\\t\\t\\t\\tif(vec[i[0]][j]!=-1  && !vis[i[0]][j][1])\\n\\t\\t\\t\\t\\tvec[i[0]][j]=1,vis[i[0]][j][1]=1;\\n\\t\\t\\t\\telse\\n\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t}\\n\\t\\t\\t// marking true at 2 index of vec[i][j] -> downward direction from this point is visited\\n            for(int j=i[0]+1;j<m;j++)\\n\\t\\t\\t{\\n\\t\\t\\t\\tif(vec[j][i[1]]!=-1 && !vis[j][i[1]][2])\\n\\t\\t\\t\\t\\tvec[j][i[1]]=1,vis[j][i[1]][2]=1;\\n\\t\\t\\t\\telse\\n\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t}\\n\\t\\t\\t// marking true at 3 index of vec[i][j] -> right direction from this point is visited\\n            for(int j=i[1]+1;j<n;j++)\\n\\t\\t\\t{\\n\\t\\t\\t\\tif(vec[i[0]][j]!=-1 && !vis[i[0]][j][3])\\n\\t\\t\\t\\t\\tvec[i[0]][j]=1,vis[i[0]][j][3]=1;\\n\\t\\t\\t\\telse\\n\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t}\\n        }\\n        int c=0;\\n        for(int i=0;i<m;i++)\\n            for(int j=0;j<n;j++)\\n                if(vec[i][j]==0)\\n                    c++;\\n        return c;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int countUnguarded(int m, int n, vector<vector<int>>& g, vector<vector<int>>& w) {\\n        vector<vector<short int>> vec(m,vector<short int>(n,0));\\n\\t\\t// to check all directions in which we have already travelled\\n        bool vis[m][n][4];\\n        memset(vis,false,sizeof(vis));\\n        for(auto i:w)\\n            vec[i[0]][i[1]]=-1;\\n        \\n        for(auto i:g)\\n        {\\n\\t\\t\\t// marking true at 0 index of vec[i][j] -> upward direction from this point is visited\\n            for(int j=i[0];j>=0;j--)\\n\\t\\t\\t{\\n\\t\\t\\t\\tif(vec[j][i[1]]!=-1 && !vis[j][i[1]][0])\\n\\t\\t\\t\\t\\tvec[j][i[1]]=1,vis[j][i[1]][0]=1;\\n\\t\\t\\t\\telse\\n\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t}\\n\\t\\t\\t// marking true at 1 index of vec[i][j] -> left direction from this point is visited\\n            for(int j=i[1]-1;j>=0;j--)\\n\\t\\t\\t{\\n\\t\\t\\t\\tif(vec[i[0]][j]!=-1  && !vis[i[0]][j][1])\\n\\t\\t\\t\\t\\tvec[i[0]][j]=1,vis[i[0]][j][1]=1;\\n\\t\\t\\t\\telse\\n\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t}\\n\\t\\t\\t// marking true at 2 index of vec[i][j] -> downward direction from this point is visited\\n            for(int j=i[0]+1;j<m;j++)\\n\\t\\t\\t{\\n\\t\\t\\t\\tif(vec[j][i[1]]!=-1 && !vis[j][i[1]][2])\\n\\t\\t\\t\\t\\tvec[j][i[1]]=1,vis[j][i[1]][2]=1;\\n\\t\\t\\t\\telse\\n\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t}\\n\\t\\t\\t// marking true at 3 index of vec[i][j] -> right direction from this point is visited\\n            for(int j=i[1]+1;j<n;j++)\\n\\t\\t\\t{\\n\\t\\t\\t\\tif(vec[i[0]][j]!=-1 && !vis[i[0]][j][3])\\n\\t\\t\\t\\t\\tvec[i[0]][j]=1,vis[i[0]][j][3]=1;\\n\\t\\t\\t\\telse\\n\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t}\\n        }\\n        int c=0;\\n        for(int i=0;i<m;i++)\\n            for(int j=0;j<n;j++)\\n                if(vec[i][j]==0)\\n                    c++;\\n        return c;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1994669,
                "title": "c-o-4-n-n",
                "content": "```\\nclass Solution {\\npublic:\\n    int countUnguarded(int m, int n, vector<vector<int>>& guards, vector<vector<int>>& walls) {\\n        vector<vector<int>> mat(m,vector<int>(n,0));\\n        int cnt=0;\\n        for(int i=0;i<walls.size();i++){\\n            mat[walls[i][0]][walls[i][1]]=1;\\n        }\\n        \\n        for(int i=0;i<guards.size();i++){\\n            mat[guards[i][0]][guards[i][1]]=2;\\n        }\\n        \\n        \\n        //row-wise left iterating\\n        for(int i=0;i<m;i++){\\n            bool guard=false;\\n            for(int j=0;j<n;j++){\\n                if(mat[i][j]==1){\\n                    guard=false;\\n                }else if(mat[i][j]==0 and guard==true){\\n                    mat[i][j]=3;\\n                }else if(mat[i][j]==2){\\n                    guard=true;\\n                }\\n            }\\n        }\\n        \\n        //row-wise right iterating\\n        for(int i=0;i<m;i++){\\n            bool guard=false;\\n            for(int j=n-1;j>=0;j--){\\n                if(mat[i][j]==1){\\n                    guard=false;\\n                }else if(mat[i][j]==0 and guard==true){\\n                    mat[i][j]=3;\\n                }else if(mat[i][j]==2){\\n                    guard=true;\\n                }\\n            }\\n        }\\n        \\n        \\n        for(int i=0;i<n;i++){\\n            bool guard=false;\\n            for(int j=0;j<m;j++){\\n                if(mat[j][i]==1){\\n                    guard=false;\\n                }else if(mat[j][i]==0 and guard==true){\\n                    mat[j][i]=3;\\n                }else if(mat[j][i]==2){\\n                    guard=true;\\n                }\\n                // cout<<j<<\" \"<<i<<\" \"<<guard<<endl;\\n            }\\n        }\\n        \\n        \\n        for(int i=0;i<n;i++){\\n            bool guard=false;\\n            for(int j=m-1;j>=0;j--){\\n                if(mat[j][i]==1){\\n                    guard=false;\\n                }else if(mat[j][i]==0 and guard==true){\\n                    mat[j][i]=3;\\n                }else if(mat[j][i]==2){\\n                    guard=true;\\n                }\\n                // cout<<j<<\" \"<<i<<\" \"<<guard<<endl;\\n            }\\n        }\\n        \\n        \\n        \\n        \\n        for(int i=0;i<m;i++){\\n            for(int j=0;j<n;j++){\\n                if(mat[i][j]==0){\\n                    cnt++;\\n                }\\n                // cout<<mat[i][j]<<\" \";\\n            }\\n            // cout<<endl;\\n        }\\n        \\n        return cnt;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int countUnguarded(int m, int n, vector<vector<int>>& guards, vector<vector<int>>& walls) {\\n        vector<vector<int>> mat(m,vector<int>(n,0));\\n        int cnt=0;\\n        for(int i=0;i<walls.size();i++){\\n            mat[walls[i][0]][walls[i][1]]=1;\\n        }\\n        \\n        for(int i=0;i<guards.size();i++){\\n            mat[guards[i][0]][guards[i][1]]=2;\\n        }\\n        \\n        \\n        //row-wise left iterating\\n        for(int i=0;i<m;i++){\\n            bool guard=false;\\n            for(int j=0;j<n;j++){\\n                if(mat[i][j]==1){\\n                    guard=false;\\n                }else if(mat[i][j]==0 and guard==true){\\n                    mat[i][j]=3;\\n                }else if(mat[i][j]==2){\\n                    guard=true;\\n                }\\n            }\\n        }\\n        \\n        //row-wise right iterating\\n        for(int i=0;i<m;i++){\\n            bool guard=false;\\n            for(int j=n-1;j>=0;j--){\\n                if(mat[i][j]==1){\\n                    guard=false;\\n                }else if(mat[i][j]==0 and guard==true){\\n                    mat[i][j]=3;\\n                }else if(mat[i][j]==2){\\n                    guard=true;\\n                }\\n            }\\n        }\\n        \\n        \\n        for(int i=0;i<n;i++){\\n            bool guard=false;\\n            for(int j=0;j<m;j++){\\n                if(mat[j][i]==1){\\n                    guard=false;\\n                }else if(mat[j][i]==0 and guard==true){\\n                    mat[j][i]=3;\\n                }else if(mat[j][i]==2){\\n                    guard=true;\\n                }\\n                // cout<<j<<\" \"<<i<<\" \"<<guard<<endl;\\n            }\\n        }\\n        \\n        \\n        for(int i=0;i<n;i++){\\n            bool guard=false;\\n            for(int j=m-1;j>=0;j--){\\n                if(mat[j][i]==1){\\n                    guard=false;\\n                }else if(mat[j][i]==0 and guard==true){\\n                    mat[j][i]=3;\\n                }else if(mat[j][i]==2){\\n                    guard=true;\\n                }\\n                // cout<<j<<\" \"<<i<<\" \"<<guard<<endl;\\n            }\\n        }\\n        \\n        \\n        \\n        \\n        for(int i=0;i<m;i++){\\n            for(int j=0;j<n;j++){\\n                if(mat[i][j]==0){\\n                    cnt++;\\n                }\\n                // cout<<mat[i][j]<<\" \";\\n            }\\n            // cout<<endl;\\n        }\\n        \\n        return cnt;\\n        \\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 1994653,
                "title": "c-solution-traverse-in-all-direction",
                "content": "```cpp\\nclass Solution {\\npublic:\\n    int countUnguarded(int m, int n, vector<vector<int>>& guards, vector<vector<int>>& walls) {\\n        vector<vector<int>> grid(m,vector<int>(n));\\n        for(int i=0;i<guards.size();i++){\\n            grid[guards[i][0]][guards[i][1]]=1;\\n        }\\n        for(int i=0;i<walls.size();i++){\\n            grid[walls[i][0]][walls[i][1]]=2;\\n        }\\n//         left to right\\n        auto temp1=grid,temp2=grid,temp3=grid,temp4=grid;\\n        for(int i=0;i<m;i++){\\n            for(int j=0;j<n;j++){\\n                if(temp1[i][j]==2 || temp1[i][j]==1)\\n                    continue;\\n                if(j>0 && temp1[i][j-1]==1)\\n                    temp1[i][j]=1;\\n            }\\n        }\\n//      right to left\\n        for(int i=m-1;i>=0;i--){\\n            for(int j=n-1;j>=0;j--){\\n                if(temp2[i][j]==2 || temp2[i][j]==1)\\n                    continue;\\n                if(j<n-1 && temp2[i][j+1]==1)\\n                    temp2[i][j]=1;\\n            }\\n        }\\n//       top to down\\n        for(int i=0;i<m;i++){\\n            for(int j=0;j<n;j++){\\n                if(temp3[i][j]==2 ||  temp3[i][j]==1)\\n                    continue;\\n                if(i>0 && temp3[i-1][j]==1)\\n                    temp3[i][j]=1;\\n            }\\n        }\\n//        down to top\\n        for(int i=m-1;i>=0;i--){\\n            for(int j=n-1;j>=0;j--){\\n                if(temp4[i][j]==2 || temp4[i][j]==1)\\n                    continue;\\n                if(i<m-1 && temp4[i+1][j]==1)\\n                    temp4[i][j]=1;\\n            }\\n        }\\n        int ans=0;\\n        for(int i=0;i<m;i++){\\n            for(int j=0;j<n;j++){\\n                if(temp1[i][j]==0 && temp2[i][j]==0 && temp3[i][j]==0 && temp4[i][j]==0)\\n                    ans++;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```cpp\\nclass Solution {\\npublic:\\n    int countUnguarded(int m, int n, vector<vector<int>>& guards, vector<vector<int>>& walls) {\\n        vector<vector<int>> grid(m,vector<int>(n));\\n        for(int i=0;i<guards.size();i++){\\n            grid[guards[i][0]][guards[i][1]]=1;\\n        }\\n        for(int i=0;i<walls.size();i++){\\n            grid[walls[i][0]][walls[i][1]]=2;\\n        }\\n//         left to right\\n        auto temp1=grid,temp2=grid,temp3=grid,temp4=grid;\\n        for(int i=0;i<m;i++){\\n            for(int j=0;j<n;j++){\\n                if(temp1[i][j]==2 || temp1[i][j]==1)\\n                    continue;\\n                if(j>0 && temp1[i][j-1]==1)\\n                    temp1[i][j]=1;\\n            }\\n        }\\n//      right to left\\n        for(int i=m-1;i>=0;i--){\\n            for(int j=n-1;j>=0;j--){\\n                if(temp2[i][j]==2 || temp2[i][j]==1)\\n                    continue;\\n                if(j<n-1 && temp2[i][j+1]==1)\\n                    temp2[i][j]=1;\\n            }\\n        }\\n//       top to down\\n        for(int i=0;i<m;i++){\\n            for(int j=0;j<n;j++){\\n                if(temp3[i][j]==2 ||  temp3[i][j]==1)\\n                    continue;\\n                if(i>0 && temp3[i-1][j]==1)\\n                    temp3[i][j]=1;\\n            }\\n        }\\n//        down to top\\n        for(int i=m-1;i>=0;i--){\\n            for(int j=n-1;j>=0;j--){\\n                if(temp4[i][j]==2 || temp4[i][j]==1)\\n                    continue;\\n                if(i<m-1 && temp4[i+1][j]==1)\\n                    temp4[i][j]=1;\\n            }\\n        }\\n        int ans=0;\\n        for(int i=0;i<m;i++){\\n            for(int j=0;j<n;j++){\\n                if(temp1[i][j]==0 && temp2[i][j]==0 && temp3[i][j]==0 && temp4[i][j]==0)\\n                    ans++;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1994573,
                "title": "c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int countUnguarded(int m, int n, vector<vector<int>>& guards, vector<vector<int>>& walls) {\\n        vector<vector<int>> v(m,vector<int>(n,-1));\\n        \\n        int n1=walls.size();\\n        \\n        for(int i=0;i<n1;i++)\\n        {\\n            v[walls[i][0]][walls[i][1]]=2;\\n        }\\n        \\n        //***************************************\\n        \\n        n1=guards.size();\\n        \\n        for(int i=0;i<n1;i++)\\n        {\\n            int x=guards[i][0];\\n            int y=guards[i][1];\\n            \\n            v[x][y]=0;\\n        }\\n        \\n        for(int i=0;i<n1;i++)\\n        {\\n            int x=guards[i][0];\\n            int y=guards[i][1];\\n            \\n            \\n            int p=y+1;\\n            while(p<n)\\n            {\\n                if(v[x][p]==0 || v[x][p]==2)\\n                {\\n                    break;\\n                }\\n                v[x][p]=1;\\n                p++;\\n            }\\n            p=y-1;\\n            while(p>=0)\\n            {\\n                if(v[x][p]==0 || v[x][p]==2)\\n                {\\n                    break;\\n                }\\n                v[x][p]=1;\\n                p--;\\n            }\\n            int q=x+1;\\n            while(q<m)\\n            {\\n                if(v[q][y]==0 || v[q][y]==2)\\n                {\\n                    break;\\n                }\\n                v[q][y]=1;\\n                q++;\\n            }\\n            q=x-1;\\n            while(q>=0)\\n            {\\n                if(v[q][y]==0 || v[q][y]==2)\\n                {\\n                    break;\\n                }\\n                v[q][y]=1;\\n                q--;\\n            }\\n            \\n        }\\n        int res=0;\\n        \\n        for(int i=0;i<m;i++)\\n        {\\n            for(int j=0;j<n;j++)\\n            {\\n                // cout<<v[i][j]<<\" \";\\n                if(v[i][j]==-1) res++;\\n            }\\n            // cout<<endl;\\n        }\\n        \\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int countUnguarded(int m, int n, vector<vector<int>>& guards, vector<vector<int>>& walls) {\\n        vector<vector<int>> v(m,vector<int>(n,-1));\\n        \\n        int n1=walls.size();\\n        \\n        for(int i=0;i<n1;i++)\\n        {\\n            v[walls[i][0]][walls[i][1]]=2;\\n        }\\n        \\n        //***************************************\\n        \\n        n1=guards.size();\\n        \\n        for(int i=0;i<n1;i++)\\n        {\\n            int x=guards[i][0];\\n            int y=guards[i][1];\\n            \\n            v[x][y]=0;\\n        }\\n        \\n        for(int i=0;i<n1;i++)\\n        {\\n            int x=guards[i][0];\\n            int y=guards[i][1];\\n            \\n            \\n            int p=y+1;\\n            while(p<n)\\n            {\\n                if(v[x][p]==0 || v[x][p]==2)\\n                {\\n                    break;\\n                }\\n                v[x][p]=1;\\n                p++;\\n            }\\n            p=y-1;\\n            while(p>=0)\\n            {\\n                if(v[x][p]==0 || v[x][p]==2)\\n                {\\n                    break;\\n                }\\n                v[x][p]=1;\\n                p--;\\n            }\\n            int q=x+1;\\n            while(q<m)\\n            {\\n                if(v[q][y]==0 || v[q][y]==2)\\n                {\\n                    break;\\n                }\\n                v[q][y]=1;\\n                q++;\\n            }\\n            q=x-1;\\n            while(q>=0)\\n            {\\n                if(v[q][y]==0 || v[q][y]==2)\\n                {\\n                    break;\\n                }\\n                v[q][y]=1;\\n                q--;\\n            }\\n            \\n        }\\n        int res=0;\\n        \\n        for(int i=0;i<m;i++)\\n        {\\n            for(int j=0;j<n;j++)\\n            {\\n                // cout<<v[i][j]<<\" \";\\n                if(v[i][j]==-1) res++;\\n            }\\n            // cout<<endl;\\n        }\\n        \\n        return res;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3491880,
                "title": "bfs-java-easy-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Pair{\\n    int first;\\n    int second;\\n    Pair(int first,int second){\\n        this.first=first;\\n        this.second=second;\\n    }\\n}\\n\\nclass Solution {\\n    public int countUnguarded(int m, int n, int[][] guards, int[][] walls) {\\n        int visit[][]=new int[m][n];\\n        int delRow[]={0,0,1,-1};\\n        int delCol[]={1,-1,0,0};\\n        //\\'G\\'=1, \\'W=2\\'\\n        \\n        for(int i=0;i<walls.length;i++){\\n            visit[walls[i][0]][walls[i][1]]=1;\\n        }\\n        Queue<Pair>q=new LinkedList<>();\\n        \\n        \\n        for(int i=0;i<guards.length;i++){\\n            int start=guards[i][0];\\n            int end=guards[i][1];\\n            q.add(new Pair(start,end));\\n            visit[start][end]=2;\\n        }\\n        \\n        \\n        while(!q.isEmpty()){\\n            Pair pr=q.poll();\\n            int row=pr.first;\\n            int col=pr.second;\\n            \\n            for(int i=0;i<4;i++){\\n                int nrow=row+delRow[i];\\n                int ncol=col+delCol[i];\\n                \\n                while(nrow<m && nrow>=0 && ncol<n && ncol>=0 && visit[nrow][ncol]!=1 && visit[nrow][ncol]!=2){\\n                    visit[nrow][ncol]=-1;\\n                    nrow+=delRow[i];\\n                    ncol+=delCol[i];\\n                }\\n            }\\n        }\\n        \\n        int ans=0;\\n        for(int i=0;i<m;i++){\\n            for(int j=0;j<n;j++){\\n                if(visit[i][j]==0){\\n                    ans++;\\n                }\\n            }\\n        }\\n        return ans;\\n        \\n        \\n    }\\n    \\n    public void bfs(int start,int end,int visit[][],int delRow[],int delCol[],int m,int n){\\n        \\n        \\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Pair{\\n    int first;\\n    int second;\\n    Pair(int first,int second){\\n        this.first=first;\\n        this.second=second;\\n    }\\n}\\n\\nclass Solution {\\n    public int countUnguarded(int m, int n, int[][] guards, int[][] walls) {\\n        int visit[][]=new int[m][n];\\n        int delRow[]={0,0,1,-1};\\n        int delCol[]={1,-1,0,0};\\n        //\\'G\\'=1, \\'W=2\\'\\n        \\n        for(int i=0;i<walls.length;i++){\\n            visit[walls[i][0]][walls[i][1]]=1;\\n        }\\n        Queue<Pair>q=new LinkedList<>();\\n        \\n        \\n        for(int i=0;i<guards.length;i++){\\n            int start=guards[i][0];\\n            int end=guards[i][1];\\n            q.add(new Pair(start,end));\\n            visit[start][end]=2;\\n        }\\n        \\n        \\n        while(!q.isEmpty()){\\n            Pair pr=q.poll();\\n            int row=pr.first;\\n            int col=pr.second;\\n            \\n            for(int i=0;i<4;i++){\\n                int nrow=row+delRow[i];\\n                int ncol=col+delCol[i];\\n                \\n                while(nrow<m && nrow>=0 && ncol<n && ncol>=0 && visit[nrow][ncol]!=1 && visit[nrow][ncol]!=2){\\n                    visit[nrow][ncol]=-1;\\n                    nrow+=delRow[i];\\n                    ncol+=delCol[i];\\n                }\\n            }\\n        }\\n        \\n        int ans=0;\\n        for(int i=0;i<m;i++){\\n            for(int j=0;j<n;j++){\\n                if(visit[i][j]==0){\\n                    ans++;\\n                }\\n            }\\n        }\\n        return ans;\\n        \\n        \\n    }\\n    \\n    public void bfs(int start,int end,int visit[][],int delRow[],int delCol[],int m,int n){\\n        \\n        \\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3185282,
                "title": "python-dfs-solution-with-explaination",
                "content": "Idea is to mark all locations which the guard can see with \\'X\\' value. Then later just count the non marked cells.\\n\\nDefines a named tuple called \"Directions\" with two fields x and y, which represents the movement directions on a 2D grid.\\n\\n\\nCreates a matrix with zeros of size m x n and fills it with \\'G\\' and \\'W\\' for the guard and wall locations, respectively.\\n\\nIt then performs a depth-first search starting from each guard location, moving in each of the four directions specified by the Directions named tuple.\\n\\nDuring the depth-first search, if the search goes out of bounds, hits a wall or another guard, it stops. Otherwise, it marks the current cell as \\'X\\' to indicate it has been visited and continues the search in the specified direction.\\n\\nAfter the search is complete, the method counts the number of cells in the matrix that are still 0 (i.e., unguarded) and returns the count.\\n\\n\\n```\\nfrom collections import namedtuple\\nfrom typing import List\\n\\nDirections = namedtuple(\\'Directions\\', [\\'x\\', \\'y\\'])\\nup = Directions(-1, 0)\\ndown = Directions(1, 0)\\nleft = Directions(0, -1)\\nright = Directions(0, 1)\\n\\n\\ndef countUnguarded(m: int, n: int, guards: List[List[int]], walls: List[List[int]]) -> int:\\n    matrix = [[0 for _ in range(n)] for _ in range(m)]\\n    for x, y in guards:\\n        matrix[x][y] = \\'G\\'\\n    for x, y in walls:\\n        matrix[x][y] = \\'W\\'\\n\\n    def dfs(row, col, direction):\\n        if row < 0 or row >= m or col < 0 or col >= n or matrix[row][col] == \\'W\\' or matrix[row][col] == \\'G\\':\\n            return\\n\\n        matrix[row][col] = \\'X\\'\\n        dfs(row + direction.x, col + direction.y, direction)\\n\\n    for x in range(m):\\n        for y in range(n):\\n            if matrix[x][y] == \\'G\\':\\n                dfs(x + 1, y, down)\\n                dfs(x - 1, y, up)\\n                dfs(x, y + 1, right)\\n                dfs(x, y - 1, left)\\n\\n    counter = 0\\n    for x in range(m):\\n        for y in range(n):\\n            if matrix[x][y] == 0:\\n                counter += 1\\n\\n    return counter\\n\\n\\n```\\n",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Depth-First Search"
                ],
                "code": "```\\nfrom collections import namedtuple\\nfrom typing import List\\n\\nDirections = namedtuple(\\'Directions\\', [\\'x\\', \\'y\\'])\\nup = Directions(-1, 0)\\ndown = Directions(1, 0)\\nleft = Directions(0, -1)\\nright = Directions(0, 1)\\n\\n\\ndef countUnguarded(m: int, n: int, guards: List[List[int]], walls: List[List[int]]) -> int:\\n    matrix = [[0 for _ in range(n)] for _ in range(m)]\\n    for x, y in guards:\\n        matrix[x][y] = \\'G\\'\\n    for x, y in walls:\\n        matrix[x][y] = \\'W\\'\\n\\n    def dfs(row, col, direction):\\n        if row < 0 or row >= m or col < 0 or col >= n or matrix[row][col] == \\'W\\' or matrix[row][col] == \\'G\\':\\n            return\\n\\n        matrix[row][col] = \\'X\\'\\n        dfs(row + direction.x, col + direction.y, direction)\\n\\n    for x in range(m):\\n        for y in range(n):\\n            if matrix[x][y] == \\'G\\':\\n                dfs(x + 1, y, down)\\n                dfs(x - 1, y, up)\\n                dfs(x, y + 1, right)\\n                dfs(x, y - 1, left)\\n\\n    counter = 0\\n    for x in range(m):\\n        for y in range(n):\\n            if matrix[x][y] == 0:\\n                counter += 1\\n\\n    return counter\\n\\n\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2278891,
                "title": "95-faster-python-solution",
                "content": "```\\nclass Solution:\\n    def countUnguarded(self, m: int, n: int, guards: List[List[int]], walls: List[List[int]]) -> int:\\n        def moveLeft(r, c):\\n            r, c = r, c-1\\n            if c<0 or grid[r][c] == \"W\" or grid[r][c] ==\"G\":\\n                return\\n            grid[r][c]=True\\n            moveLeft(r, c)\\n        def moveRight(r, c):\\n            r, c = r, c+1\\n            if c>=n or grid[r][c] == \"W\" or grid[r][c] ==\"G\":\\n                return\\n            grid[r][c]=True\\n            moveRight(r, c)\\n        def moveTop(r, c):\\n            r, c = r-1, c\\n            if r<0 or grid[r][c] == \"W\" or grid[r][c] ==\"G\":\\n                return\\n            grid[r][c]=True\\n            moveTop(r, c)\\n        def moveBot(r, c):\\n            r, c = r+1, c\\n            if r>=m or grid[r][c] == \"W\" or grid[r][c] ==\"G\":\\n                return\\n            grid[r][c]=True\\n            moveBot(r,c)\\n        grid = []\\n        \\n        \\n        for i in range(m):\\n            grid.append([False]*n)\\n        for r, c in guards:\\n            grid[r][c] = \"G\"\\n        for r, c in walls:\\n            grid[r][c] = \"W\"\\n        for r, c in guards:\\n            moveTop(r, c)\\n            moveBot(r,c)\\n            moveLeft(r, c)\\n            moveRight(r, c)\\n        count = 0\\n        for i in range(m):\\n            for j in range(n):\\n                if grid[i][j] == False:\\n                    count+=1\\n        return count\\n```",
                "solutionTags": [
                    "Array",
                    "Recursion"
                ],
                "code": "```\\nclass Solution:\\n    def countUnguarded(self, m: int, n: int, guards: List[List[int]], walls: List[List[int]]) -> int:\\n        def moveLeft(r, c):\\n            r, c = r, c-1\\n            if c<0 or grid[r][c] == \"W\" or grid[r][c] ==\"G\":\\n                return\\n            grid[r][c]=True\\n            moveLeft(r, c)\\n        def moveRight(r, c):\\n            r, c = r, c+1\\n            if c>=n or grid[r][c] == \"W\" or grid[r][c] ==\"G\":\\n                return\\n            grid[r][c]=True\\n            moveRight(r, c)\\n        def moveTop(r, c):\\n            r, c = r-1, c\\n            if r<0 or grid[r][c] == \"W\" or grid[r][c] ==\"G\":\\n                return\\n            grid[r][c]=True\\n            moveTop(r, c)\\n        def moveBot(r, c):\\n            r, c = r+1, c\\n            if r>=m or grid[r][c] == \"W\" or grid[r][c] ==\"G\":\\n                return\\n            grid[r][c]=True\\n            moveBot(r,c)\\n        grid = []\\n        \\n        \\n        for i in range(m):\\n            grid.append([False]*n)\\n        for r, c in guards:\\n            grid[r][c] = \"G\"\\n        for r, c in walls:\\n            grid[r][c] = \"W\"\\n        for r, c in guards:\\n            moveTop(r, c)\\n            moveBot(r,c)\\n            moveLeft(r, c)\\n            moveRight(r, c)\\n        count = 0\\n        for i in range(m):\\n            for j in range(n):\\n                if grid[i][j] == False:\\n                    count+=1\\n        return count\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2244039,
                "title": "python3-simple-logic-memory-efficient",
                "content": "```\\nclass Solution:\\n    def countUnguarded(self, m: int, n: int, guards: List[List[int]], walls: List[List[int]]) -> int:\\n        ROWS = m; COLS = n\\n        guarded = set()\\n        guards = set((r,c) for r,c in guards)\\n        walls = set((r,c) for r,c in walls)\\n        \\n        for R,C in guards:\\n            \\n            #right\\n            for c in range(C+1,COLS):\\n                if (R,c) in guards or (R,c) in walls:\\n                    break\\n                guarded.add((R,c))\\n            #left\\n            for c in range(C-1,-1,-1):\\n                if (R,c) in guards or (R,c) in walls:\\n                    break\\n                guarded.add((R,c))\\n            #up\\n            for r in range(R-1,-1,-1):\\n                if (r,C) in guards or (r,C) in walls:\\n                    break\\n                guarded.add((r,C))\\n            #down\\n            for r in range(R+1,ROWS):\\n                if (r,C) in guards or (r,C) in walls:\\n                    break\\n                guarded.add((r,C))\\n        \\n        return ROWS*COLS - len(guards) - len(walls) - len(guarded)\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def countUnguarded(self, m: int, n: int, guards: List[List[int]], walls: List[List[int]]) -> int:\\n        ROWS = m; COLS = n\\n        guarded = set()\\n        guards = set((r,c) for r,c in guards)\\n        walls = set((r,c) for r,c in walls)\\n        \\n        for R,C in guards:\\n            \\n            #right\\n            for c in range(C+1,COLS):\\n                if (R,c) in guards or (R,c) in walls:\\n                    break\\n                guarded.add((R,c))\\n            #left\\n            for c in range(C-1,-1,-1):\\n                if (R,c) in guards or (R,c) in walls:\\n                    break\\n                guarded.add((R,c))\\n            #up\\n            for r in range(R-1,-1,-1):\\n                if (r,C) in guards or (r,C) in walls:\\n                    break\\n                guarded.add((r,C))\\n            #down\\n            for r in range(R+1,ROWS):\\n                if (r,C) in guards or (r,C) in walls:\\n                    break\\n                guarded.add((r,C))\\n        \\n        return ROWS*COLS - len(guards) - len(walls) - len(guarded)\\n",
                "codeTag": "Java"
            },
            {
                "id": 2166638,
                "title": "a-few-solutions",
                "content": "`walk` in all four cardinal directions (up, right, down, left) from guard cell `i`,`j` to mark `seen` cells.  Then return the cardinality of the matrix `M * N` minus the cardinality of the `seen` set.\\n\\n---\\n\\n*Kotlin*\\n```\\nclass Solution {\\n    fun countUnguarded(M: Int, N: Int, G_: Array<IntArray>, W_: Array<IntArray>): Int {\\n        var seen = mutableSetOf<String>()\\n        var key = { i: Int, j: Int -> \"$i,$j\" }\\n        var G = G_.map{ key(it[0], it[1]) }.toSet()\\n        var W = W_.map{ key(it[0], it[1]) }.toSet()\\n        fun walk(row: Int, col: Int) {\\n            for ((di, dj) in listOf(Pair(-1, 0), Pair(0, 1), Pair(1, 0), Pair(0, -1))) {\\n                var i = row\\n                var j = col\\n                while (0 <= i + di && i + di < M && 0 <= j + dj && j + dj < N) {\\n                    i += di\\n                    j += dj\\n                    var k = key(i, j)\\n                    if (G.contains(k) || W.contains(k))\\n                        break\\n                    seen.add(k)\\n                }\\n            }\\n        }\\n        for (i in 0 until M) {\\n            for (j in 0 until N) {\\n                var k = key(i, j)\\n                if (G.contains(k)) { seen.add(k); walk(i, j) }\\n                if (W.contains(k)) { seen.add(k) }\\n            }\\n        }\\n        return M * N - seen.size\\n    }\\n}\\n```\\n\\n*Javascript*\\n```\\nlet countUnguarded = (M, N, G_, W_, seen = new Set()) => {\\n    let key = (i, j) => `${i},${j}`;\\n    let G = new Set([...G_].map(([i, j]) => key(i, j))),\\n        W = new Set([...W_].map(([i, j]) => key(i, j)));\\n    let walk = (row, col) => {\\n        for (let [di, dj] of [[-1, 0], [0, 1], [1, 0], [0, -1]]) {\\n            let i = row,\\n                j = col;\\n            while (0 <= i + di && i + di < M && 0 <= j + dj && j + dj < N) {\\n                i += di;\\n                j += dj;\\n                k = key(i, j);\\n                if (G.has(k) || W.has(k))\\n                    break;\\n                seen.add(k);\\n            }\\n        }\\n    };\\n    for (let i = 0; i < M; ++i) {\\n        for (let j = 0; j < N; ++j) {\\n            let k = key(i, j);\\n            if (G.has(k)) seen.add(k), walk(i, j);\\n            if (W.has(k)) seen.add(k);\\n        }\\n    }\\n    return M * N - seen.size;\\n};\\n```\\n\\n*Python3*\\n```\\nclass Solution:\\n    def countUnguarded(self, M: int, N: int, G: List[List[int]], W: List[List[int]]) -> int:\\n        seen = set()\\n        G = set([(i, j) for i, j in G])\\n        W = set([(i, j) for i, j in W])\\n        def walk(row, col):\\n            for di, dj in [[-1, 0], [0, 1], [1, 0], [0, -1]]:\\n                i = row\\n                j = col\\n                while 0 <= i + di < M and 0 <= j + dj < N:\\n                    i += di\\n                    j += dj\\n                    if (i, j) in G or (i, j) in W:\\n                        break\\n                    seen.add((i, j))\\n        for i in range(M):\\n            for j in range(N):\\n                if (i, j) in G: seen.add((i, j)); walk(i, j)\\n                if (i, j) in W: seen.add((i, j))\\n        return M * N - len(seen)\\n```\\n\\n*Rust*\\n```\\ntype VI = Vec<i32>;\\ntype VVI = Vec<VI>;\\nuse std::collections::HashSet;\\nimpl Solution {\\n    pub fn count_unguarded(M: i32, N: i32, G_: VVI, W_: VVI) -> i32 {\\n        let mut G = HashSet::new();\\n        let mut W = HashSet::new();\\n        let mut seen = HashSet::new();\\n        let key = (|i, j| format!(\"{},{}\", i, j));\\n        for pair in G_ { G.insert(key(pair[0], pair[1])); }\\n        for pair in W_ { W.insert(key(pair[0], pair[1])); }\\n        let mut walk = (|row, col| {\\n            let k = key(row, col);\\n            seen.insert(k.clone());\\n            if W.contains(&k) {\\n                return;\\n            }\\n            for (di, dj) in vec![(-1, 0), (0, 1), (1, 0), (0, -1)] {\\n                let mut i = row;\\n                let mut j = col;\\n                while 0 <= i + di && i + di < M && 0 <= j + dj && j + dj < N {\\n                    i += di;\\n                    j += dj;\\n                    let k = key(i, j);\\n                    if G.contains(&k) || W.contains(&k) {\\n                        break;\\n                    }\\n                    seen.insert(k.clone());\\n                }\\n            }\\n        });\\n        for i in 0..M {\\n            for j in 0..N {\\n                let k = key(i, j);\\n                if G.contains(&k) || W.contains(&k) {\\n                    walk(i as i32, j as i32);\\n                }\\n            }\\n        }\\n        return M * N - seen.len() as i32;\\n    }\\n}\\n```\\n\\n*C++*\\n```\\nclass Solution {\\npublic:\\n    using VI = vector<int>;\\n    using VVI = vector<VI>;\\n    using Pair = pair<int, int>;\\n    using Pairs = vector<Pair>;\\n    using Set = unordered_set<string>;\\n    int countUnguarded(int M, int N, VVI& G_, VVI& W_, Set G = {}, Set W = {}, Set seen = {}) {\\n        auto key = [](auto i, auto j) {\\n            stringstream ss; ss << i << \",\" << j;\\n            return ss.str();\\n        };\\n        for (auto& pair: G_) G.insert(key(pair[0], pair[1]));\\n        for (auto& pair: W_) W.insert(key(pair[0], pair[1]));\\n        auto walk = [&](auto row, auto col) {\\n            for (auto [di, dj]: Pairs{{-1, 0}, {0, 1}, {1, 0}, {0, -1}}) {\\n                auto i = row,\\n                     j = col;\\n                while (0 <= i + di && i + di < M && 0 <= j + dj && j + dj < N) {\\n                    i += di;\\n                    j += dj;\\n                    auto k = key(i, j);\\n                    if (G.find(k) != G.end() || W.find(k) != W.end())\\n                        break;\\n                    seen.insert(k);\\n                }\\n            }\\n        };\\n        for (auto i{ 0 }; i < M; ++i) {\\n            for (auto j{ 0 }; j < N; ++j) {\\n                auto k = key(i, j);\\n                if (G.find(k) != G.end()) seen.insert(k), walk(i, j);\\n                if (W.find(k) != W.end()) seen.insert(k);\\n            }\\n        }\\n        return M * N - seen.size();\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    fun countUnguarded(M: Int, N: Int, G_: Array<IntArray>, W_: Array<IntArray>): Int {\\n        var seen = mutableSetOf<String>()\\n        var key = { i: Int, j: Int -> \"$i,$j\" }\\n        var G = G_.map{ key(it[0], it[1]) }.toSet()\\n        var W = W_.map{ key(it[0], it[1]) }.toSet()\\n        fun walk(row: Int, col: Int) {\\n            for ((di, dj) in listOf(Pair(-1, 0), Pair(0, 1), Pair(1, 0), Pair(0, -1))) {\\n                var i = row\\n                var j = col\\n                while (0 <= i + di && i + di < M && 0 <= j + dj && j + dj < N) {\\n                    i += di\\n                    j += dj\\n                    var k = key(i, j)\\n                    if (G.contains(k) || W.contains(k))\\n                        break\\n                    seen.add(k)\\n                }\\n            }\\n        }\\n        for (i in 0 until M) {\\n            for (j in 0 until N) {\\n                var k = key(i, j)\\n                if (G.contains(k)) { seen.add(k); walk(i, j) }\\n                if (W.contains(k)) { seen.add(k) }\\n            }\\n        }\\n        return M * N - seen.size\\n    }\\n}\\n```\n```\\nlet countUnguarded = (M, N, G_, W_, seen = new Set()) => {\\n    let key = (i, j) => `${i},${j}`;\\n    let G = new Set([...G_].map(([i, j]) => key(i, j))),\\n        W = new Set([...W_].map(([i, j]) => key(i, j)));\\n    let walk = (row, col) => {\\n        for (let [di, dj] of [[-1, 0], [0, 1], [1, 0], [0, -1]]) {\\n            let i = row,\\n                j = col;\\n            while (0 <= i + di && i + di < M && 0 <= j + dj && j + dj < N) {\\n                i += di;\\n                j += dj;\\n                k = key(i, j);\\n                if (G.has(k) || W.has(k))\\n                    break;\\n                seen.add(k);\\n            }\\n        }\\n    };\\n    for (let i = 0; i < M; ++i) {\\n        for (let j = 0; j < N; ++j) {\\n            let k = key(i, j);\\n            if (G.has(k)) seen.add(k), walk(i, j);\\n            if (W.has(k)) seen.add(k);\\n        }\\n    }\\n    return M * N - seen.size;\\n};\\n```\n```\\nclass Solution:\\n    def countUnguarded(self, M: int, N: int, G: List[List[int]], W: List[List[int]]) -> int:\\n        seen = set()\\n        G = set([(i, j) for i, j in G])\\n        W = set([(i, j) for i, j in W])\\n        def walk(row, col):\\n            for di, dj in [[-1, 0], [0, 1], [1, 0], [0, -1]]:\\n                i = row\\n                j = col\\n                while 0 <= i + di < M and 0 <= j + dj < N:\\n                    i += di\\n                    j += dj\\n                    if (i, j) in G or (i, j) in W:\\n                        break\\n                    seen.add((i, j))\\n        for i in range(M):\\n            for j in range(N):\\n                if (i, j) in G: seen.add((i, j)); walk(i, j)\\n                if (i, j) in W: seen.add((i, j))\\n        return M * N - len(seen)\\n```\n```\\ntype VI = Vec<i32>;\\ntype VVI = Vec<VI>;\\nuse std::collections::HashSet;\\nimpl Solution {\\n    pub fn count_unguarded(M: i32, N: i32, G_: VVI, W_: VVI) -> i32 {\\n        let mut G = HashSet::new();\\n        let mut W = HashSet::new();\\n        let mut seen = HashSet::new();\\n        let key = (|i, j| format!(\"{},{}\", i, j));\\n        for pair in G_ { G.insert(key(pair[0], pair[1])); }\\n        for pair in W_ { W.insert(key(pair[0], pair[1])); }\\n        let mut walk = (|row, col| {\\n            let k = key(row, col);\\n            seen.insert(k.clone());\\n            if W.contains(&k) {\\n                return;\\n            }\\n            for (di, dj) in vec![(-1, 0), (0, 1), (1, 0), (0, -1)] {\\n                let mut i = row;\\n                let mut j = col;\\n                while 0 <= i + di && i + di < M && 0 <= j + dj && j + dj < N {\\n                    i += di;\\n                    j += dj;\\n                    let k = key(i, j);\\n                    if G.contains(&k) || W.contains(&k) {\\n                        break;\\n                    }\\n                    seen.insert(k.clone());\\n                }\\n            }\\n        });\\n        for i in 0..M {\\n            for j in 0..N {\\n                let k = key(i, j);\\n                if G.contains(&k) || W.contains(&k) {\\n                    walk(i as i32, j as i32);\\n                }\\n            }\\n        }\\n        return M * N - seen.len() as i32;\\n    }\\n}\\n```\n```\\nclass Solution {\\npublic:\\n    using VI = vector<int>;\\n    using VVI = vector<VI>;\\n    using Pair = pair<int, int>;\\n    using Pairs = vector<Pair>;\\n    using Set = unordered_set<string>;\\n    int countUnguarded(int M, int N, VVI& G_, VVI& W_, Set G = {}, Set W = {}, Set seen = {}) {\\n        auto key = [](auto i, auto j) {\\n            stringstream ss; ss << i << \",\" << j;\\n            return ss.str();\\n        };\\n        for (auto& pair: G_) G.insert(key(pair[0], pair[1]));\\n        for (auto& pair: W_) W.insert(key(pair[0], pair[1]));\\n        auto walk = [&](auto row, auto col) {\\n            for (auto [di, dj]: Pairs{{-1, 0}, {0, 1}, {1, 0}, {0, -1}}) {\\n                auto i = row,\\n                     j = col;\\n                while (0 <= i + di && i + di < M && 0 <= j + dj && j + dj < N) {\\n                    i += di;\\n                    j += dj;\\n                    auto k = key(i, j);\\n                    if (G.find(k) != G.end() || W.find(k) != W.end())\\n                        break;\\n                    seen.insert(k);\\n                }\\n            }\\n        };\\n        for (auto i{ 0 }; i < M; ++i) {\\n            for (auto j{ 0 }; j < N; ++j) {\\n                auto k = key(i, j);\\n                if (G.find(k) != G.end()) seen.insert(k), walk(i, j);\\n                if (W.find(k) != W.end()) seen.insert(k);\\n            }\\n        }\\n        return M * N - seen.size();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2118234,
                "title": "simple-java-simulation",
                "content": "```\\nclass Solution {\\n    public int countUnguarded(int m, int n, int[][] guards, int[][] walls) {\\n        int[][] mat=new int[m][n];\\n        for(int[] d:walls){\\n            mat[d[0]][d[1]]=1;\\n        }\\n        for(int[] d:guards){\\n            mat[d[0]][d[1]]=2;\\n        }\\n        for(int[] d:guards){\\n            bfs(mat,d[0],d[1]);\\n        }\\n        int cnt=0;\\n        for(int[] d:mat){\\n            for(int num:d){\\n                if(num==0)cnt++;\\n            }\\n        }\\n        return cnt;\\n    }\\n    int[][] dir=new int[][]{{1,0},{-1,0},{0,1},{0,-1}};\\n    public void bfs(int[][] mat,int i,int j){\\n        mat[i][j]=2;\\n        for(int k=0;k<4;k++){\\n            int r=i,c=j;\\n            \\n            while(r+dir[k][0]>=0 && r+dir[k][0]<mat.length && c+dir[k][1]>=0 && c+dir[k][1]<mat[0].length && mat[r+dir[k][0]][c+dir[k][1]]!=1 && mat[r+dir[k][0]][c+dir[k][1]]!=2){\\n                r+=dir[k][0];\\n                c+=dir[k][1];\\n                mat[r][c]=-1;\\n            }\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Simulation"
                ],
                "code": "```\\nclass Solution {\\n    public int countUnguarded(int m, int n, int[][] guards, int[][] walls) {\\n        int[][] mat=new int[m][n];\\n        for(int[] d:walls){\\n            mat[d[0]][d[1]]=1;\\n        }\\n        for(int[] d:guards){\\n            mat[d[0]][d[1]]=2;\\n        }\\n        for(int[] d:guards){\\n            bfs(mat,d[0],d[1]);\\n        }\\n        int cnt=0;\\n        for(int[] d:mat){\\n            for(int num:d){\\n                if(num==0)cnt++;\\n            }\\n        }\\n        return cnt;\\n    }\\n    int[][] dir=new int[][]{{1,0},{-1,0},{0,1},{0,-1}};\\n    public void bfs(int[][] mat,int i,int j){\\n        mat[i][j]=2;\\n        for(int k=0;k<4;k++){\\n            int r=i,c=j;\\n            \\n            while(r+dir[k][0]>=0 && r+dir[k][0]<mat.length && c+dir[k][1]>=0 && c+dir[k][1]<mat[0].length && mat[r+dir[k][0]][c+dir[k][1]]!=1 && mat[r+dir[k][0]][c+dir[k][1]]!=2){\\n                r+=dir[k][0];\\n                c+=dir[k][1];\\n                mat[r][c]=-1;\\n            }\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2076774,
                "title": "java-solution-with-explanation",
                "content": "1. THe max ans can be m * n (no of cells)\\n2. We label guard cells  as  \\'G\\' and  walls cell as \\'W\\' and remove those from ans\\n3. THen we lable every other cell as \\'U\\' -> unguarded\\n4. Then we run loop four time for every direction - Left,Right,Top, Bottom.\\n5. In each loop for every cell we check if this cell is unnguarded and if the surronding of the cell is directly guard cell or indirectly guarded. If it is the case we remove this from our ans. \\n\\n **Here surronding is important. If we are checking for left then we should check only left and not worrying about what on it\\'s top or bottom or right and if it guarded by someone then we label it as \\'L\\'  (Symbol for Guarded by someone in left) resetting the character there if any bcz once we done for checking one direction it won\\'t matter for next direction**\\n\\n```\\nclass Solution {\\n    int m;\\n    int n;\\n    public int countUnguarded(int m, int n, int[][] guards, int[][] walls) {\\n        m = m;\\n        n = n;\\n        int ans = m * n;\\n        char[][] visisted = new char[m][n];\\n        for(int[] wall:walls){\\n            visisted[wall[0]][wall[1]] = \\'W\\';\\n            ans--;\\n        }\\n        for(int[] wall:guards){\\n            visisted[wall[0]][wall[1]] = \\'G\\';\\n            ans--;\\n        }\\n        for(int i=0;i<m;i++){\\n            for(int j=0;j<n;j++){\\n                if(visisted[i][j] == \\'G\\' || visisted[i][j] == \\'W\\') continue;\\n                visisted[i][j] = \\'U\\';\\n            }\\n        }\\n        for(int i=0;i<m;i++){\\n            for(int j=0;j<n;j++){\\n                if(visisted[i][j] == \\'G\\' || visisted[i][j] == \\'W\\') continue;\\n                if(j == 0) continue;\\n                \\n                if(visisted[i][j-1] == \\'G\\' || visisted[i][j-1] == \\'L\\'){\\n                    ans--;\\n                    visisted[i][j] = \\'L\\';\\n                }\\n            }\\n        }\\n        for(int i=0;i<m;i++){\\n            for(int j=n-1;j>=0;j--){\\n                if(visisted[i][j] == \\'G\\' || visisted[i][j] == \\'W\\') continue;\\n                if(j == n-1) continue;\\n                if(visisted[i][j+1] == \\'G\\' || visisted[i][j+1] == \\'R\\'){\\n                    if(visisted[i][j] == \\'U\\') ans--;\\n                    visisted[i][j] = \\'R\\';\\n                }\\n            }\\n        }\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                if(visisted[j][i] == \\'G\\' || visisted[j][i] == \\'W\\') continue;\\n                if(j == 0) continue;\\n                if(visisted[j-1][i] == \\'G\\' || visisted[j-1][i] == \\'T\\'){\\n                    if(visisted[j][i] == \\'U\\') ans--;\\n                    visisted[j][i] = \\'T\\';\\n                }\\n            }\\n        }\\n        for(int i=0;i<n;i++){\\n            for(int j=m-1;j>=0;j--){\\n                if(visisted[j][i] == \\'G\\' || visisted[j][i] == \\'W\\') continue;\\n                if(j == m-1) continue;\\n                if(visisted[j+1][i] == \\'G\\' || visisted[j+1][i] == \\'B\\'){\\n                    if(visisted[j][i] == \\'U\\') ans--;\\n                    visisted[j][i] = \\'B\\';\\n                }\\n            }\\n        }\\n\\n        return ans;\\n    }\\n\\n}\\n```\\n\\nPls upvote if helpful. Thanks\\n",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    int m;\\n    int n;\\n    public int countUnguarded(int m, int n, int[][] guards, int[][] walls) {\\n        m = m;\\n        n = n;\\n        int ans = m * n;\\n        char[][] visisted = new char[m][n];\\n        for(int[] wall:walls){\\n            visisted[wall[0]][wall[1]] = \\'W\\';\\n            ans--;\\n        }\\n        for(int[] wall:guards){\\n            visisted[wall[0]][wall[1]] = \\'G\\';\\n            ans--;\\n        }\\n        for(int i=0;i<m;i++){\\n            for(int j=0;j<n;j++){\\n                if(visisted[i][j] == \\'G\\' || visisted[i][j] == \\'W\\') continue;\\n                visisted[i][j] = \\'U\\';\\n            }\\n        }\\n        for(int i=0;i<m;i++){\\n            for(int j=0;j<n;j++){\\n                if(visisted[i][j] == \\'G\\' || visisted[i][j] == \\'W\\') continue;\\n                if(j == 0) continue;\\n                \\n                if(visisted[i][j-1] == \\'G\\' || visisted[i][j-1] == \\'L\\'){\\n                    ans--;\\n                    visisted[i][j] = \\'L\\';\\n                }\\n            }\\n        }\\n        for(int i=0;i<m;i++){\\n            for(int j=n-1;j>=0;j--){\\n                if(visisted[i][j] == \\'G\\' || visisted[i][j] == \\'W\\') continue;\\n                if(j == n-1) continue;\\n                if(visisted[i][j+1] == \\'G\\' || visisted[i][j+1] == \\'R\\'){\\n                    if(visisted[i][j] == \\'U\\') ans--;\\n                    visisted[i][j] = \\'R\\';\\n                }\\n            }\\n        }\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                if(visisted[j][i] == \\'G\\' || visisted[j][i] == \\'W\\') continue;\\n                if(j == 0) continue;\\n                if(visisted[j-1][i] == \\'G\\' || visisted[j-1][i] == \\'T\\'){\\n                    if(visisted[j][i] == \\'U\\') ans--;\\n                    visisted[j][i] = \\'T\\';\\n                }\\n            }\\n        }\\n        for(int i=0;i<n;i++){\\n            for(int j=m-1;j>=0;j--){\\n                if(visisted[j][i] == \\'G\\' || visisted[j][i] == \\'W\\') continue;\\n                if(j == m-1) continue;\\n                if(visisted[j+1][i] == \\'G\\' || visisted[j+1][i] == \\'B\\'){\\n                    if(visisted[j][i] == \\'U\\') ans--;\\n                    visisted[j][i] = \\'B\\';\\n                }\\n            }\\n        }\\n\\n        return ans;\\n    }\\n\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2023384,
                "title": "javascript-solution-with-explanation-o-m-n-time-space",
                "content": "**Main Idea**\\n1. Create the grid with m rows and n columns\\n2. Fill the grid with the given guards\\n3. Fill the grid with the given walls\\n4. Loop through the guards and move up, left, down, right from each guard marking their view keeping in mind that other guards can overwrite this view.\\n5. Count the free cells.\\n\\n```\\nvar countUnguarded = function(m, n, guards, walls) {\\n    let board = new Array(m).fill(0).map(_=>new Array(n).fill(0))\\n    \\n    // 0 - Empty\\n    // 1 - Guard\\n    // 2 - Wall\\n    // 3 - Guard view\\n    \\n    const DIRECTIONS = [\\n        [-1, 0],\\n        [0, 1],\\n        [1, 0],\\n        [0, -1]\\n    ]\\n    \\n    for(let [guardRow, guardCol] of guards) board[guardRow][guardCol] = 1\\n    \\n    for(let [wallRow, wallCol] of walls) board[wallRow][wallCol] = 2\\n    \\n    for(let [guardRow, guardCol] of guards){\\n        //Loop through row with the same col\\n        //Go down from current row\\n        let row = guardRow + 1\\n        while(row < m){\\n            //Stop if you encounter a wall or guard\\n            if(board[row][guardCol] == 1 || board[row][guardCol] == 2) break\\n            board[row][guardCol] = 3\\n            row++\\n        }\\n        //Go up from current row\\n        row = guardRow - 1\\n        while(row >= 0){\\n            if(board[row][guardCol] == 1 || board[row][guardCol] == 2) break\\n            board[row][guardCol] = 3\\n            row--\\n        }\\n        \\n        \\n        //Loop through col with the same row\\n        //Go right from current col\\n        let col = guardCol + 1\\n        while(col < n){\\n            if(board[guardRow][col] == 1 || board[guardRow][col] == 2) break\\n            board[guardRow][col] = 3\\n            col++\\n        }\\n        \\n        //Go left from current col\\n        col = guardCol - 1\\n        while(col >= 0){\\n            if(board[guardRow][col] == 1 || board[guardRow][col] == 2) break\\n            board[guardRow][col] = 3\\n            col--\\n        }\\n    }\\n    \\n\\t//Count the free cells\\n    let freeCount = 0\\n    for(let i = 0; i < m; i++){\\n        for(let j = 0; j < n; j++){\\n            if(board[i][j] == 0) freeCount++\\n        }\\n    }\\n    \\n    return freeCount\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Breadth-First Search"
                ],
                "code": "```\\nvar countUnguarded = function(m, n, guards, walls) {\\n    let board = new Array(m).fill(0).map(_=>new Array(n).fill(0))\\n    \\n    // 0 - Empty\\n    // 1 - Guard\\n    // 2 - Wall\\n    // 3 - Guard view\\n    \\n    const DIRECTIONS = [\\n        [-1, 0],\\n        [0, 1],\\n        [1, 0],\\n        [0, -1]\\n    ]\\n    \\n    for(let [guardRow, guardCol] of guards) board[guardRow][guardCol] = 1\\n    \\n    for(let [wallRow, wallCol] of walls) board[wallRow][wallCol] = 2\\n    \\n    for(let [guardRow, guardCol] of guards){\\n        //Loop through row with the same col\\n        //Go down from current row\\n        let row = guardRow + 1\\n        while(row < m){\\n            //Stop if you encounter a wall or guard\\n            if(board[row][guardCol] == 1 || board[row][guardCol] == 2) break\\n            board[row][guardCol] = 3\\n            row++\\n        }\\n        //Go up from current row\\n        row = guardRow - 1\\n        while(row >= 0){\\n            if(board[row][guardCol] == 1 || board[row][guardCol] == 2) break\\n            board[row][guardCol] = 3\\n            row--\\n        }\\n        \\n        \\n        //Loop through col with the same row\\n        //Go right from current col\\n        let col = guardCol + 1\\n        while(col < n){\\n            if(board[guardRow][col] == 1 || board[guardRow][col] == 2) break\\n            board[guardRow][col] = 3\\n            col++\\n        }\\n        \\n        //Go left from current col\\n        col = guardCol - 1\\n        while(col >= 0){\\n            if(board[guardRow][col] == 1 || board[guardRow][col] == 2) break\\n            board[guardRow][col] = 3\\n            col--\\n        }\\n    }\\n    \\n\\t//Count the free cells\\n    let freeCount = 0\\n    for(let i = 0; i < m; i++){\\n        for(let j = 0; j < n; j++){\\n            if(board[i][j] == 0) freeCount++\\n        }\\n    }\\n    \\n    return freeCount\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2011574,
                "title": "count-unguarded-cells-in-grid",
                "content": "class Solution {\\npublic:\\n    int countUnguarded(int m, int n, vector<vector<int>>& guards, vector<vector<int>>& walls) \\n    {\\n        \\n        \\n        vector<vector<int>> g(m,vector<int> (n,0));\\n        \\n        \\n        for(int i=0;i<guards.size();i++)\\n        {\\n            g[guards[i][0]][guards[i][1]]=2;\\n        }\\n        \\n         for(int i=0;i<walls.size();i++)\\n        {\\n            g[walls[i][0]][walls[i][1]]=2;\\n        }\\n        \\n          for(int i=0;i<guards.size();i++)\\n        {\\n            int x=guards[i][0],y=guards[i][1];\\n              \\n              \\n              for(int i=x+1;i<m;i++)\\n              {\\n                  if(g[i][y]==2)\\n                  {\\n                      break;\\n                  }\\n                  else\\n                  {\\n                      g[i][y]=1;\\n                  }\\n              }\\n              \\n              for(int i=x-1;i>=0;i--)\\n              {\\n                  if(g[i][y]==2)\\n                  {\\n                      break;\\n                  }\\n                  else\\n                  {\\n                      g[i][y]=1;\\n                  }\\n              }\\n              \\n              for(int i=y+1;i<n;i++)\\n              {\\n                  if(g[x][i]==2)\\n                  {\\n                      break;\\n                  }\\n                  else\\n                  {\\n                      g[x][i]=1;\\n                  }\\n              }\\n              \\n               for(int i=y-1;i>=0;i--)\\n              {\\n                  if(g[x][i]==2)\\n                  {\\n                      break;\\n                  }\\n                  else\\n                  {\\n                      g[x][i]=1;\\n                  }\\n              }\\n        }\\n        \\n        \\n        int ans=0;\\n        \\n        for(int i=0;i<m;i++)\\n        {\\n            for(int j=0;j<n;j++)\\n            {\\n                if(g[i][j]==0)\\n                {\\n                    ans++;\\n                }\\n            }\\n        }\\n        \\n        \\n        \\n        return ans;\\n        \\n        \\n        \\n    }\\n};",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n    int countUnguarded(int m, int n, vector<vector<int>>& guards, vector<vector<int>>& walls) \\n    {\\n        \\n        \\n        vector<vector<int>> g(m,vector<int> (n,0));\\n        \\n        \\n        for(int i=0;i<guards.size();i++)\\n        {\\n            g[guards[i][0]][guards[i][1]]=2;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1998683,
                "title": "python-3-o-m-n-simulation",
                "content": "```\\nclass Solution:\\n    def countUnguarded(self, m: int, n: int, guards: List[List[int]], walls: List[List[int]]) -> int:\\n        # U -> Unguarded\\n        # O -> Wall/Guard position\\n        # G -> Guarded/Within sight of Guard\\n        grid = [[\\'U\\' for _ in range(n)] for _ in range(m)]\\n        \\n        def traverse_and_mark(x: int, y:int, di:Tuple[int, int]) -> None:\\n            r, c = di\\n            x += r\\n            y += c\\n            while x >= 0 and x < m and y >= 0 and y < n and grid[x][y] != \\'O\\':\\n                grid[x][y] = \\'G\\'\\n                x += r\\n                y += c\\n                \\n        for x, y in chain(guards, walls):\\n            grid[x][y] = \\'O\\'\\n            \\n        for x, y in guards:\\n            # left\\n            traverse_and_mark(x, y, (0, -1))\\n            # right\\n            traverse_and_mark(x, y, (0, 1))\\n            # up\\n            traverse_and_mark(x, y, (-1, 0))\\n            # down\\n            traverse_and_mark(x, y, (1, 0))\\n\\n        return list(chain(*grid)).count(\\'U\\')\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def countUnguarded(self, m: int, n: int, guards: List[List[int]], walls: List[List[int]]) -> int:\\n        # U -> Unguarded\\n        # O -> Wall/Guard position\\n        # G -> Guarded/Within sight of Guard\\n        grid = [[\\'U\\' for _ in range(n)] for _ in range(m)]\\n        \\n        def traverse_and_mark(x: int, y:int, di:Tuple[int, int]) -> None:\\n            r, c = di\\n            x += r\\n            y += c\\n            while x >= 0 and x < m and y >= 0 and y < n and grid[x][y] != \\'O\\':\\n                grid[x][y] = \\'G\\'\\n                x += r\\n                y += c\\n                \\n        for x, y in chain(guards, walls):\\n            grid[x][y] = \\'O\\'\\n            \\n        for x, y in guards:\\n            # left\\n            traverse_and_mark(x, y, (0, -1))\\n            # right\\n            traverse_and_mark(x, y, (0, 1))\\n            # up\\n            traverse_and_mark(x, y, (-1, 0))\\n            # down\\n            traverse_and_mark(x, y, (1, 0))\\n\\n        return list(chain(*grid)).count(\\'U\\')\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1998018,
                "title": "traverse-rows-l-r-r-l-and-cols-u-d-d-p",
                "content": "```\\nclass Solution {\\n    public int countUnguarded(int m, int n, int[][] guards, int[][] walls) {\\n        int res=m*n-walls.length-guards.length;\\n        int a[][]=new int[m][n];\\n        for(int i[]:walls) a[i[0]][i[1]]=1;\\n        for(int i[]:guards) a[i[0]][i[1]]=2;\\n        for(int i=0;i<m;i++){\\n            int prev=0;\\n            for(int j=0;j<n;j++){\\n                if(a[i][j]==1 || a[i][j]==2) prev=a[i][j];\\n                else if(a[i][j]==0 && prev==2){\\n                     a[i][j]=3;\\n                     res--;\\n                }\\n            }\\n            prev=0;\\n            for(int j=n-1;j>=0;j--){\\n                if(a[i][j]==1 || a[i][j]==2) prev=a[i][j];\\n                else if(a[i][j]==0 && prev==2){\\n                        a[i][j]=3;\\n                        res--;\\n                }\\n            } \\n        }\\n        \\n        for(int i=0;i<n;i++){\\n            int prev=0;\\n            for(int j=0;j<m;j++){\\n                if(a[j][i]==1 || a[j][i]==2) prev=a[j][i];\\n                else if(a[j][i]==0 && prev==2){\\n                     a[j][i]=3;\\n                     res--;\\n                }\\n            }\\n            prev=0;\\n            for(int j=m-1;j>=0;j--){\\n                if(a[j][i]==1 || a[j][i]==2) prev=a[j][i];\\n                else if(a[j][i]==0 && prev==2){\\n                    a[j][i]=3;\\n                    res--;\\n                }\\n            }   \\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int countUnguarded(int m, int n, int[][] guards, int[][] walls) {\\n        int res=m*n-walls.length-guards.length;\\n        int a[][]=new int[m][n];\\n        for(int i[]:walls) a[i[0]][i[1]]=1;\\n        for(int i[]:guards) a[i[0]][i[1]]=2;\\n        for(int i=0;i<m;i++){\\n            int prev=0;\\n            for(int j=0;j<n;j++){\\n                if(a[i][j]==1 || a[i][j]==2) prev=a[i][j];\\n                else if(a[i][j]==0 && prev==2){\\n                     a[i][j]=3;\\n                     res--;\\n                }\\n            }\\n            prev=0;\\n            for(int j=n-1;j>=0;j--){\\n                if(a[i][j]==1 || a[i][j]==2) prev=a[i][j];\\n                else if(a[i][j]==0 && prev==2){\\n                        a[i][j]=3;\\n                        res--;\\n                }\\n            } \\n        }\\n        \\n        for(int i=0;i<n;i++){\\n            int prev=0;\\n            for(int j=0;j<m;j++){\\n                if(a[j][i]==1 || a[j][i]==2) prev=a[j][i];\\n                else if(a[j][i]==0 && prev==2){\\n                     a[j][i]=3;\\n                     res--;\\n                }\\n            }\\n            prev=0;\\n            for(int j=m-1;j>=0;j--){\\n                if(a[j][i]==1 || a[j][i]==2) prev=a[j][i];\\n                else if(a[j][i]==0 && prev==2){\\n                    a[j][i]=3;\\n                    res--;\\n                }\\n            }   \\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1997129,
                "title": "python-easy-solution",
                "content": "All i did is just made a two dimensional array in which i put the walls already and just track the coordinate whether it\\'s left right up or down is already visited or not . if not then just traverse through all it\\'s possible left right up and down positions.\\nsorry for bad english.\\n```\\nclass Solution:\\n    def countUnguarded(self, m: int, n: int, g: List[List[int]], w: List[List[int]]) -> int:\\n        ans = []\\n        arr=[[[-1,-1]]*(n) for i in range(m)]\\n        for i,j in w:\\n            arr[i][j] = [\"w\",\"w\"]\\n        g.sort()\\n        for i,j in g:\\n            p,q = i,j\\n            r,s = i,j\\n            while(p<m and arr[p][j][0]!=\"w\" and arr[p][j][1]!=\"r\"):\\n                arr[p][j] = [1,\"r\"]\\n                p+=1\\n            while(q<n and arr[i][q][0]!=\"w\" and arr[i][q][1]!=\"d\"):\\n                arr[i][q] = [1,\"d\"]\\n                q+=1\\n            while(r>=0 and arr[r][j][0]!=\"w\" and arr[r][j][1]!=\"l\"):\\n                arr[r][j] = [1,\"l\"]\\n                r-=1\\n            while(s>=0 and arr[i][s][0]!=\"w\" and arr[i][s][1]!=\"u\"):\\n                arr[i][s] = [1,\"u\"]\\n                s-=1\\n        ans=0\\n        for i in range(m):\\n            for j in range(n):\\n                if arr[i][j]==[-1,-1]:\\n                    ans+=1\\n        return ans",
                "solutionTags": [
                    "Python",
                    "Greedy",
                    "Sorting"
                ],
                "code": "All i did is just made a two dimensional array in which i put the walls already and just track the coordinate whether it\\'s left right up or down is already visited or not . if not then just traverse through all it\\'s possible left right up and down positions.\\nsorry for bad english.\\n```\\nclass Solution:\\n    def countUnguarded(self, m: int, n: int, g: List[List[int]], w: List[List[int]]) -> int:\\n        ans = []\\n        arr=[[[-1,-1]]*(n) for i in range(m)]\\n        for i,j in w:\\n            arr[i][j] = [\"w\",\"w\"]\\n        g.sort()\\n        for i,j in g:\\n            p,q = i,j\\n            r,s = i,j\\n            while(p<m and arr[p][j][0]!=\"w\" and arr[p][j][1]!=\"r\"):\\n                arr[p][j] = [1,\"r\"]\\n                p+=1\\n            while(q<n and arr[i][q][0]!=\"w\" and arr[i][q][1]!=\"d\"):\\n                arr[i][q] = [1,\"d\"]\\n                q+=1\\n            while(r>=0 and arr[r][j][0]!=\"w\" and arr[r][j][1]!=\"l\"):\\n                arr[r][j] = [1,\"l\"]\\n                r-=1\\n            while(s>=0 and arr[i][s][0]!=\"w\" and arr[i][s][1]!=\"u\"):\\n                arr[i][s] = [1,\"u\"]\\n                s-=1\\n        ans=0\\n        for i in range(m):\\n            for j in range(n):\\n                if arr[i][j]==[-1,-1]:\\n                    ans+=1\\n        return ans",
                "codeTag": "Java"
            },
            {
                "id": 1995806,
                "title": "easy-java-implementation",
                "content": "```\\nclass Solution {\\n    public int countUnguarded(int m, int n, int[][] guards, int[][] walls) {\\n        \\n        int[][] result = new int[m][n];\\n        //guards = 1, walls 2 // checked = 3\\n        \\n        for(int i=0;i<guards.length;i++)\\n            result[guards[i][0]][guards[i][1]] = 1;\\n        \\n        \\n        for(int i=0;i<walls.length;i++)\\n            result[walls[i][0]][walls[i][1]] =2;\\n        \\n        \\n        for(int i = 0;i<m;i++){\\n            for(int j=0;j<n;j++){\\n \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0if(result[i][j]==1)guard(result, i, j,m,n);\\n \\xA0 \\xA0 \\xA0 \\xA0 \\xA0}\\n        }\\n        \\n        int count =0;\\n        for(int i = 0;i<m;i++){\\n            for(int j=0;j<n;j++){\\n                if(result[i][j] ==0) count++;\\n                \\n            }\\n        }\\n        \\n        return count;\\n        \\n    }\\n    \\n    public static void guard(int[][] result, int row, int col,int m,int n){\\n        \\n        int i = row;\\n        //check up\\n        while(i >0 ){\\n            i--;\\n            if(result[i][col] == 2 || result[i][col] == 1) break;\\n            result[i][col] =3;\\n            \\n        }\\n        \\n        //check down\\n        i=row;\\n        \\n        while(i< m-1){\\n            i++;\\n            if(result[i][col]==2 || result[i][col] == 1) break;\\n            result[i][col] = 3;\\n        }\\n \\xA0 \\xA0 \\xA0 \\n \\xA0 \\xA0 \\xA0 \\xA0//check left\\n \\xA0 \\xA0 \\xA0 \\xA0int j = col;\\n \\xA0 \\xA0 \\xA0 \\xA0while(j>0){\\n            j--;\\n            if(result[row][j]==2 || result[row][j] == 1) break;\\n            result[row][j] = 3;\\n        }\\n        \\n        //check right\\n        j = col;\\n        while(j < n-1){\\n            j++;\\n            if(result[row][j]==2 || result[row][j] == 1) break;\\n            result[row][j] = 3;\\n        }      \\n            \\n    }\\n    \\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int countUnguarded(int m, int n, int[][] guards, int[][] walls) {\\n        \\n        int[][] result = new int[m][n];\\n        //guards = 1, walls 2 // checked = 3\\n        \\n        for(int i=0;i<guards.length;i++)\\n            result[guards[i][0]][guards[i][1]] = 1;\\n        \\n        \\n        for(int i=0;i<walls.length;i++)\\n            result[walls[i][0]][walls[i][1]] =2;\\n        \\n        \\n        for(int i = 0;i<m;i++){\\n            for(int j=0;j<n;j++){\\n \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0if(result[i][j]==1)guard(result, i, j,m,n);\\n \\xA0 \\xA0 \\xA0 \\xA0 \\xA0}\\n        }\\n        \\n        int count =0;\\n        for(int i = 0;i<m;i++){\\n            for(int j=0;j<n;j++){\\n                if(result[i][j] ==0) count++;\\n                \\n            }\\n        }\\n        \\n        return count;\\n        \\n    }\\n    \\n    public static void guard(int[][] result, int row, int col,int m,int n){\\n        \\n        int i = row;\\n        //check up\\n        while(i >0 ){\\n            i--;\\n            if(result[i][col] == 2 || result[i][col] == 1) break;\\n            result[i][col] =3;\\n            \\n        }\\n        \\n        //check down\\n        i=row;\\n        \\n        while(i< m-1){\\n            i++;\\n            if(result[i][col]==2 || result[i][col] == 1) break;\\n            result[i][col] = 3;\\n        }\\n \\xA0 \\xA0 \\xA0 \\n \\xA0 \\xA0 \\xA0 \\xA0//check left\\n \\xA0 \\xA0 \\xA0 \\xA0int j = col;\\n \\xA0 \\xA0 \\xA0 \\xA0while(j>0){\\n            j--;\\n            if(result[row][j]==2 || result[row][j] == 1) break;\\n            result[row][j] = 3;\\n        }\\n        \\n        //check right\\n        j = col;\\n        while(j < n-1){\\n            j++;\\n            if(result[row][j]==2 || result[row][j] == 1) break;\\n            result[row][j] = 3;\\n        }      \\n            \\n    }\\n    \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1995296,
                "title": "easy-c-code-beats-100-tc-memory",
                "content": "```\\n int countUnguarded(int m, int n, vector<vector<int>>& guards, vector<vector<int>>& walls) {\\n\\t\\t  int gr[m][n];\\n        memset(gr,0,sizeof(gr));\\n        for(auto& x : walls){\\n            gr[x[0]][x[1]] = -2;\\n        }\\n        for(auto& x : guards){\\n            gr[x[0]][x[1]] = -1;\\n        }\\n     \\n        for(int i = 0 ; i < m ; i++){\\n            int count = 1;\\n            for(int j = 0 ;j < n ; j++){\\n                if(gr[i][j] == -2){\\n                    count = 1;\\n                    continue;\\n                } \\n                if(gr[i][j] == -1) count = 0;\\n                gr[i][j]+=count;\\n            }\\n            count = 1;\\n            for(int j = n-1 ;j >= 0 ; j--){\\n                 if(gr[i][j] == -2){\\n                    count = 1;\\n                    continue;\\n                }\\n                if(gr[i][j] == -1) count = 0;\\n                gr[i][j]+=count;\\n            }\\n        }\\n        \\n        for(int i = 0 ; i < n ; i++){\\n            int count = 1;\\n            for(int j = 0 ;j < m ; j++){\\n                 if(gr[j][i] == -2){\\n                    count = 1;\\n                    continue;\\n                }\\n                if(gr[j][i] == -1) count = 0;\\n                gr[j][i]+=count;\\n            }\\n            count = 1;\\n            for(int j = m-1 ;j >= 0 ; j--){\\n                 if(gr[j][i] == -2){\\n                    count = 1;\\n                    continue;\\n                }\\n                if(gr[j][i] == -1) count = 0;\\n                gr[j][i]+=count;\\n            }\\n        }\\n    \\n       \\n        int ans = 0;\\n        for(int i = 0 ; i < m ; i++){\\n            for(int j = 0 ; j < n ;j++) ans+=(gr[i][j] == 4);\\n        }\\n        return ans;\\n            \\n    }\\n```",
                "solutionTags": [
                    "C",
                    "Simulation"
                ],
                "code": "```\\n int countUnguarded(int m, int n, vector<vector<int>>& guards, vector<vector<int>>& walls) {\\n\\t\\t  int gr[m][n];\\n        memset(gr,0,sizeof(gr));\\n        for(auto& x : walls){\\n            gr[x[0]][x[1]] = -2;\\n        }\\n        for(auto& x : guards){\\n            gr[x[0]][x[1]] = -1;\\n        }\\n     \\n        for(int i = 0 ; i < m ; i++){\\n            int count = 1;\\n            for(int j = 0 ;j < n ; j++){\\n                if(gr[i][j] == -2){\\n                    count = 1;\\n                    continue;\\n                } \\n                if(gr[i][j] == -1) count = 0;\\n                gr[i][j]+=count;\\n            }\\n            count = 1;\\n            for(int j = n-1 ;j >= 0 ; j--){\\n                 if(gr[i][j] == -2){\\n                    count = 1;\\n                    continue;\\n                }\\n                if(gr[i][j] == -1) count = 0;\\n                gr[i][j]+=count;\\n            }\\n        }\\n        \\n        for(int i = 0 ; i < n ; i++){\\n            int count = 1;\\n            for(int j = 0 ;j < m ; j++){\\n                 if(gr[j][i] == -2){\\n                    count = 1;\\n                    continue;\\n                }\\n                if(gr[j][i] == -1) count = 0;\\n                gr[j][i]+=count;\\n            }\\n            count = 1;\\n            for(int j = m-1 ;j >= 0 ; j--){\\n                 if(gr[j][i] == -2){\\n                    count = 1;\\n                    continue;\\n                }\\n                if(gr[j][i] == -1) count = 0;\\n                gr[j][i]+=count;\\n            }\\n        }\\n    \\n       \\n        int ans = 0;\\n        for(int i = 0 ; i < m ; i++){\\n            for(int j = 0 ; j < n ;j++) ans+=(gr[i][j] == 4);\\n        }\\n        return ans;\\n            \\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1995217,
                "title": "c-hash-map-binary-search-accepted",
                "content": "Time complexity - ```O(M*N*log(max(M,N)))```\\nSpace complexity - ```O(M*N)```\\n```\\nclass Solution {\\npublic:\\n    int countUnguarded(int m, int n, vector<vector<int>>& guards, vector<vector<int>>& walls) {\\n        \\n        unordered_map<int, vector<int>> guardsRowMap, wallsRowMap, guardsColMap, wallsColMap;\\n        \\n        for (vector<int> guard : guards) {\\n            guardsRowMap[guard[0]].push_back(guard[1]);\\n            guardsColMap[guard[1]].push_back(guard[0]);\\n        }\\n        for (vector<int> wall : walls) {\\n            wallsRowMap[wall[0]].push_back(wall[1]);\\n            wallsColMap[wall[1]].push_back(wall[0]);\\n        }\\n        \\n        for (auto& item : guardsRowMap) {\\n            sort(item.second.begin(), item.second.end());\\n        }\\n        for (auto& item : wallsRowMap) {\\n            sort(item.second.begin(), item.second.end());\\n        }\\n        for (auto& item : guardsColMap) {\\n            sort(item.second.begin(), item.second.end());\\n        }\\n        for (auto& item : wallsColMap) {\\n            sort(item.second.begin(), item.second.end());\\n        }\\n        \\n        \\n        int count = 0;\\n        for (int row=0; row<m; row++) {\\n            for (int col=0; col<n; col++) {\\n                \\n                int guard_idx, wall_idx;\\n                \\n                guard_idx = lower_bound(guardsColMap[col].begin(), guardsColMap[col].end(), row) - guardsColMap[col].begin();\\n                if (guard_idx != guardsColMap[col].size() and guardsColMap[col][guard_idx] == row)    continue;\\n                \\n                wall_idx = lower_bound(wallsColMap[col].begin(), wallsColMap[col].end(), row) - wallsColMap[col].begin();\\n                if (wall_idx != wallsColMap[col].size() and wallsColMap[col][wall_idx] == row)  continue;\\n                \\n                if (guard_idx != 0 and \\n                    (wall_idx == 0 or guardsColMap[col][guard_idx-1] > wallsColMap[col][wall_idx-1]))\\n                    continue;\\n                if (guard_idx != guardsColMap[col].size() and \\n                    (wall_idx == wallsColMap[col].size() or guardsColMap[col][guard_idx] < wallsColMap[col][wall_idx]))\\n                    continue;\\n                \\n                guard_idx = lower_bound(guardsRowMap[row].begin(), guardsRowMap[row].end(), col) - guardsRowMap[row].begin();\\n                wall_idx = lower_bound(wallsRowMap[row].begin(), wallsRowMap[row].end(), col) - wallsRowMap[row].begin();\\n                \\n                if (guard_idx != 0 and \\n                    (wall_idx == 0 or guardsRowMap[row][guard_idx-1] > wallsRowMap[row][wall_idx-1]))\\n                    continue;\\n                if (guard_idx != guardsRowMap[row].size() and \\n                    (wall_idx == wallsRowMap[row].size() or guardsRowMap[row][guard_idx] < wallsRowMap[row][wall_idx]))\\n                    continue;\\n                count++;\\n            }\\n        }\\n        \\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Binary Tree"
                ],
                "code": "```O(M*N*log(max(M,N)))```\n```O(M*N)```\n```\\nclass Solution {\\npublic:\\n    int countUnguarded(int m, int n, vector<vector<int>>& guards, vector<vector<int>>& walls) {\\n        \\n        unordered_map<int, vector<int>> guardsRowMap, wallsRowMap, guardsColMap, wallsColMap;\\n        \\n        for (vector<int> guard : guards) {\\n            guardsRowMap[guard[0]].push_back(guard[1]);\\n            guardsColMap[guard[1]].push_back(guard[0]);\\n        }\\n        for (vector<int> wall : walls) {\\n            wallsRowMap[wall[0]].push_back(wall[1]);\\n            wallsColMap[wall[1]].push_back(wall[0]);\\n        }\\n        \\n        for (auto& item : guardsRowMap) {\\n            sort(item.second.begin(), item.second.end());\\n        }\\n        for (auto& item : wallsRowMap) {\\n            sort(item.second.begin(), item.second.end());\\n        }\\n        for (auto& item : guardsColMap) {\\n            sort(item.second.begin(), item.second.end());\\n        }\\n        for (auto& item : wallsColMap) {\\n            sort(item.second.begin(), item.second.end());\\n        }\\n        \\n        \\n        int count = 0;\\n        for (int row=0; row<m; row++) {\\n            for (int col=0; col<n; col++) {\\n                \\n                int guard_idx, wall_idx;\\n                \\n                guard_idx = lower_bound(guardsColMap[col].begin(), guardsColMap[col].end(), row) - guardsColMap[col].begin();\\n                if (guard_idx != guardsColMap[col].size() and guardsColMap[col][guard_idx] == row)    continue;\\n                \\n                wall_idx = lower_bound(wallsColMap[col].begin(), wallsColMap[col].end(), row) - wallsColMap[col].begin();\\n                if (wall_idx != wallsColMap[col].size() and wallsColMap[col][wall_idx] == row)  continue;\\n                \\n                if (guard_idx != 0 and \\n                    (wall_idx == 0 or guardsColMap[col][guard_idx-1] > wallsColMap[col][wall_idx-1]))\\n                    continue;\\n                if (guard_idx != guardsColMap[col].size() and \\n                    (wall_idx == wallsColMap[col].size() or guardsColMap[col][guard_idx] < wallsColMap[col][wall_idx]))\\n                    continue;\\n                \\n                guard_idx = lower_bound(guardsRowMap[row].begin(), guardsRowMap[row].end(), col) - guardsRowMap[row].begin();\\n                wall_idx = lower_bound(wallsRowMap[row].begin(), wallsRowMap[row].end(), col) - wallsRowMap[row].begin();\\n                \\n                if (guard_idx != 0 and \\n                    (wall_idx == 0 or guardsRowMap[row][guard_idx-1] > wallsRowMap[row][wall_idx-1]))\\n                    continue;\\n                if (guard_idx != guardsRowMap[row].size() and \\n                    (wall_idx == wallsRowMap[row].size() or guardsRowMap[row][guard_idx] < wallsRowMap[row][wall_idx]))\\n                    continue;\\n                count++;\\n            }\\n        }\\n        \\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1995141,
                "title": "c-o-n-27-lines-simple-code",
                "content": "In this algorithm every cell will be travel at most 4 times.\\nSo, the time complexity is 4 * N  (assume N = m * n here)\\n\\n```C++\\nclass Solution {\\npublic:\\n    int countUnguarded(int m, int n, vector<vector<int>>& guards, vector<vector<int>>& walls) {\\n        int cnt=0; //the counter of the number of guarded place\\n        vector<vector<int>> grid = vector<vector<int>>(m, vector<int>(n, 0));\\n        //no-guarded 0, guarded 1.  , guards 2, walls 3, \\n        for(auto&g : guards) grid[g[0]][g[1]] = 2;\\n        for(auto&w : walls) grid[w[0]][w[1]] = 3;\\n        \\n        //configure guarded place\\n        vector<vector<int>> dirs = {{-1,0},{1,0},{0,-1},{0,1}};\\n        for(auto&g: guards) {            \\n            for(auto& dir:dirs) {\\n                int i = g[0], j = g[1];       \\n                while(true) {\\n                    i += dir[0];\\n                    j += dir[1];                \\n                    if(i<0 || i>=m || j<0 || j>=n || grid[i][j]>1) break;\\n                    cnt += (grid[i][j] == 0);\\n                    grid[i][j] = 1;\\n                }                \\n            }\\n        }\\n        return m*n-cnt-guards.size()-walls.size();        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```C++\\nclass Solution {\\npublic:\\n    int countUnguarded(int m, int n, vector<vector<int>>& guards, vector<vector<int>>& walls) {\\n        int cnt=0; //the counter of the number of guarded place\\n        vector<vector<int>> grid = vector<vector<int>>(m, vector<int>(n, 0));\\n        //no-guarded 0, guarded 1.  , guards 2, walls 3, \\n        for(auto&g : guards) grid[g[0]][g[1]] = 2;\\n        for(auto&w : walls) grid[w[0]][w[1]] = 3;\\n        \\n        //configure guarded place\\n        vector<vector<int>> dirs = {{-1,0},{1,0},{0,-1},{0,1}};\\n        for(auto&g: guards) {            \\n            for(auto& dir:dirs) {\\n                int i = g[0], j = g[1];       \\n                while(true) {\\n                    i += dir[0];\\n                    j += dir[1];                \\n                    if(i<0 || i>=m || j<0 || j>=n || grid[i][j]>1) break;\\n                    cnt += (grid[i][j] == 0);\\n                    grid[i][j] = 1;\\n                }                \\n            }\\n        }\\n        return m*n-cnt-guards.size()-walls.size();        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1995124,
                "title": "c-explanation-with-code",
                "content": "here we will first intialize the walls and then guards.Then we will check in all direction in matrix if there is another guard or wall present .if yes then we will stop else\\nwe intialize other the column which are gaurded with some value.\\n```\\nclass Solution {\\npublic:\\nint countUnguarded(int m, int n, vector& guards, vector& walls) {vector matrix(m,vector(n,0));int x=0;\\n\\n//Intialize walls\\nfor(int i=0;i<walls.size();i++)\\n{\\nmatrix[walls[i][0]][walls[i][1]]=2;\\n}\\n//Intialize guards\\nfor(int i=0;i<guards.size();i++)\\n{\\nmatrix[guards[i][0]][guards[i][1]]=1;\\n}\\n//Now check for walls or other guards in all direction\\nfor(int i=0;i<guards.size();i++)\\n{ //Move right\\nfor(int j=guards[i][1]+1;j<n;j++)\\n{if(matrix[guards[i][0]][j]==2 ||matrix[guards[i][0]][j]==1 )break;\\nmatrix[guards[i][0]][j]=5;\\n}\\n//Move left\\nfor(int j=guards[i][1]-1;j>=0;j--)\\n{if(matrix[guards[i][0]][j]==2||matrix[guards[i][0]][j]==1)break;\\nmatrix[guards[i][0]][j]=5;\\n}\\n//Move down\\nfor(int j=guards[i][0]+1;j<m;j++)\\n{if( matrix[j][guards[i][1]]==2 || matrix[j][guards[i][1]]==1)break;\\nmatrix[j][guards[i][1]]=5;\\n}\\n//Move up\\nfor(int j=guards[i][0]-1;j>=0;j--)\\n{if( matrix[j][guards[i][1]]==2 || matrix[j][guards[i][1]]==1)break;\\nmatrix[j][guards[i][1]]=5;\\n}\\n\\n}\\nfor(int i=0;i<m;i++)\\n{\\nfor(int j=0;j<n;j++)\\n{//Print matrix for better understanding.\\n//cout<<matrix[i][j]<<\" \";\\nif(matrix[i][j]==0)x++;\\n}cout<<endl;\\n}\\nreturn x;\\n}\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Matrix"
                ],
                "code": "```\\nclass Solution {\\npublic:\\nint countUnguarded(int m, int n, vector& guards, vector& walls) {vector matrix(m,vector(n,0));int x=0;\\n\\n//Intialize walls\\nfor(int i=0;i<walls.size();i++)\\n{\\nmatrix[walls[i][0]][walls[i][1]]=2;\\n}\\n//Intialize guards\\nfor(int i=0;i<guards.size();i++)\\n{\\nmatrix[guards[i][0]][guards[i][1]]=1;\\n}\\n//Now check for walls or other guards in all direction\\nfor(int i=0;i<guards.size();i++)\\n{ //Move right\\nfor(int j=guards[i][1]+1;j<n;j++)\\n{if(matrix[guards[i][0]][j]==2 ||matrix[guards[i][0]][j]==1 )break;\\nmatrix[guards[i][0]][j]=5;\\n}\\n//Move left\\nfor(int j=guards[i][1]-1;j>=0;j--)\\n{if(matrix[guards[i][0]][j]==2||matrix[guards[i][0]][j]==1)break;\\nmatrix[guards[i][0]][j]=5;\\n}\\n//Move down\\nfor(int j=guards[i][0]+1;j<m;j++)\\n{if( matrix[j][guards[i][1]]==2 || matrix[j][guards[i][1]]==1)break;\\nmatrix[j][guards[i][1]]=5;\\n}\\n//Move up\\nfor(int j=guards[i][0]-1;j>=0;j--)\\n{if( matrix[j][guards[i][1]]==2 || matrix[j][guards[i][1]]==1)break;\\nmatrix[j][guards[i][1]]=5;\\n}\\n\\n}\\nfor(int i=0;i<m;i++)\\n{\\nfor(int j=0;j<n;j++)\\n{//Print matrix for better understanding.\\n//cout<<matrix[i][j]<<\" \";\\nif(matrix[i][j]==0)x++;\\n}cout<<endl;\\n}\\nreturn x;\\n}\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 1995090,
                "title": "c-easy-dfs-in-4-directions-100-faster",
                "content": "**PLEASE UPVOTE IF U FIND MY SOLUTION HELPFUL**\\n\\n```\\nclass Solution {\\n    bool valid(int i,int j,int &n,int &m)\\n    {\\n        return i>=0&&j>=0&&i<n&&j<m;\\n    }\\npublic:\\n    int countUnguarded(int n, int m, vector<vector<int>>& guards, vector<vector<int>>& walls) \\n    {\\n        vector<vector<char>>grid(n,vector<char>(m,\\'.\\'));\\n        \\n        for(auto &w:walls)\\n            grid[w[0]][w[1]]=\\'b\\';\\n        \\n        for(auto &g:guards)\\n            grid[g[0]][g[1]]=\\'b\\';\\n        \\n        int dir[4][2]={{1,0},{0,1},{-1,0},{0,-1}};\\n        for(auto &g:guards)\\n        {\\n            int i=g[0],j=g[1];\\n            for(int k=0;k<4;k++)\\n            {\\n                i=g[0]+dir[k][0];\\n                j=g[1]+dir[k][1];\\n                while(valid(i,j,n,m)&&grid[i][j]!=\\'b\\')\\n                {\\n                    grid[i][j]=\\'m\\';\\n                    i+=dir[k][0];\\n                    j+=dir[k][1];\\n                }\\n            }\\n        }\\n        \\n        int res=0;\\n        for(auto &x:grid)\\n        {\\n            for(auto &y:x)\\n            {\\n               res+=(y==\\'.\\'); \\n            }\\n        }\\n        \\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\n    bool valid(int i,int j,int &n,int &m)\\n    {\\n        return i>=0&&j>=0&&i<n&&j<m;\\n    }\\npublic:\\n    int countUnguarded(int n, int m, vector<vector<int>>& guards, vector<vector<int>>& walls) \\n    {\\n        vector<vector<char>>grid(n,vector<char>(m,\\'.\\'));\\n        \\n        for(auto &w:walls)\\n            grid[w[0]][w[1]]=\\'b\\';\\n        \\n        for(auto &g:guards)\\n            grid[g[0]][g[1]]=\\'b\\';\\n        \\n        int dir[4][2]={{1,0},{0,1},{-1,0},{0,-1}};\\n        for(auto &g:guards)\\n        {\\n            int i=g[0],j=g[1];\\n            for(int k=0;k<4;k++)\\n            {\\n                i=g[0]+dir[k][0];\\n                j=g[1]+dir[k][1];\\n                while(valid(i,j,n,m)&&grid[i][j]!=\\'b\\')\\n                {\\n                    grid[i][j]=\\'m\\';\\n                    i+=dir[k][0];\\n                    j+=dir[k][1];\\n                }\\n            }\\n        }\\n        \\n        int res=0;\\n        for(auto &x:grid)\\n        {\\n            for(auto &y:x)\\n            {\\n               res+=(y==\\'.\\'); \\n            }\\n        }\\n        \\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1995079,
                "title": "python-beats-100-very-concise",
                "content": "![image](https://assets.leetcode.com/users/images/b18687df-bcf9-46b8-8d0f-ba2493928aea_1651340009.2805262.png)\\n\\n\\n```\\n\\n\\n\\n\\n\\n\\ndef countUnguarded(self, m: int, n: int, guards: List[List[int]], walls: List[List[int]]) -> int:\\n        \\n        nums = [[1]*n for i in range(m)]\\n        for i , j in walls+guards:\\n            nums[i][j] = 0\\n            \\n        dir = [(1 , 0) , (-1 , 0) , (0 , 1) , (0 , -1)]\\n        for di , dj in guards:\\n            #nums[di][dj] = 0\\n            \\n            for x , y in dir:\\n                i = di\\n                j = dj\\n                while 0 <= i+x < m and 0 <= j+y < n and nums[i+x][j+y] != 0:\\n                    i +=x\\n                    j +=y\\n                    nums[i][j] = 2\\n                    \\n        return sum(1 for i in range(m) for j in range(n) if nums[i][j] == 1) \\n        \\n```",
                "solutionTags": [
                    "Python",
                    "Matrix"
                ],
                "code": "```\\n\\n\\n\\n\\n\\n\\ndef countUnguarded(self, m: int, n: int, guards: List[List[int]], walls: List[List[int]]) -> int:\\n        \\n        nums = [[1]*n for i in range(m)]\\n        for i , j in walls+guards:\\n            nums[i][j] = 0\\n            \\n        dir = [(1 , 0) , (-1 , 0) , (0 , 1) , (0 , -1)]\\n        for di , dj in guards:\\n            #nums[di][dj] = 0\\n            \\n            for x , y in dir:\\n                i = di\\n                j = dj\\n                while 0 <= i+x < m and 0 <= j+y < n and nums[i+x][j+y] != 0:\\n                    i +=x\\n                    j +=y\\n                    nums[i][j] = 2\\n                    \\n        return sum(1 for i in range(m) for j in range(n) if nums[i][j] == 1) \\n        \\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1994790,
                "title": "java-100-fastest-two-treemaps-solution",
                "content": "```\\nclass Solution {\\n    public int countUnguarded(int m, int n, int[][] guards, int[][] walls) {\\n        // 1 -> guard, 2 -> wall\\n        int count = 0;\\n        TreeMap<Integer, Integer>[] row = new TreeMap[m];\\n        TreeMap<Integer, Integer>[] col = new TreeMap[n];\\n        Set<List<Integer>> set = new HashSet<>();\\n        \\n        for(int i = 0; i < m; i++) row[i] = new TreeMap<>();\\n        for(int i = 0; i < n; i++) col[i] = new TreeMap<>();\\n        \\n        for(int[] i : guards) {\\n            row[i[0]].put(i[1], 1);  \\n            col[i[1]].put(i[0], 1);\\n        }\\n        \\n        for(int[] i : walls) {\\n            row[i[0]].put(i[1], 2);\\n            col[i[1]].put(i[0], 2);\\n            set.add(List.of(i[0], i[1]));\\n        }\\n        \\n        for(int i = 0; i < m; i++){\\n            for(int j = 0; j < n; j++){\\n                if(set.contains(List.of(i, j))) continue;\\n                if((row[i].floorEntry(j) == null || row[i].floorEntry(j).getValue() == 2) &&\\n                    (row[i].ceilingEntry(j) == null || row[i].ceilingEntry(j).getValue() == 2) &&\\n                    (col[j].floorEntry(i) == null || col[j].floorEntry(i).getValue() == 2) &&\\n                   (col[j].ceilingEntry(i) == null || col[j].ceilingEntry(i).getValue() == 2))\\n                       count++;\\n            }\\n        }\\n        \\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Tree"
                ],
                "code": "```\\nclass Solution {\\n    public int countUnguarded(int m, int n, int[][] guards, int[][] walls) {\\n        // 1 -> guard, 2 -> wall\\n        int count = 0;\\n        TreeMap<Integer, Integer>[] row = new TreeMap[m];\\n        TreeMap<Integer, Integer>[] col = new TreeMap[n];\\n        Set<List<Integer>> set = new HashSet<>();\\n        \\n        for(int i = 0; i < m; i++) row[i] = new TreeMap<>();\\n        for(int i = 0; i < n; i++) col[i] = new TreeMap<>();\\n        \\n        for(int[] i : guards) {\\n            row[i[0]].put(i[1], 1);  \\n            col[i[1]].put(i[0], 1);\\n        }\\n        \\n        for(int[] i : walls) {\\n            row[i[0]].put(i[1], 2);\\n            col[i[1]].put(i[0], 2);\\n            set.add(List.of(i[0], i[1]));\\n        }\\n        \\n        for(int i = 0; i < m; i++){\\n            for(int j = 0; j < n; j++){\\n                if(set.contains(List.of(i, j))) continue;\\n                if((row[i].floorEntry(j) == null || row[i].floorEntry(j).getValue() == 2) &&\\n                    (row[i].ceilingEntry(j) == null || row[i].ceilingEntry(j).getValue() == 2) &&\\n                    (col[j].floorEntry(i) == null || col[j].floorEntry(i).getValue() == 2) &&\\n                   (col[j].ceilingEntry(i) == null || col[j].ceilingEntry(i).getValue() == 2))\\n                       count++;\\n            }\\n        }\\n        \\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1994773,
                "title": "java-brute-force-solution",
                "content": "**Explanation**\\n\\n* We first place the walls and guards in our answer array with -1 for walls and 1 for guards. \\n* After that we traverse in all four directions for every guard and keep marking the traversed positions as 2 until we either encounter a guard or a wall.\\n* In the end, traverse the answer array and count the 0\\'s, the number of 0\\'s is the answer.\\n\\n```\\npublic int countUnguarded(int m, int n, int[][] guards, int[][] walls) {\\n        int[][] ans = new int[m][n];\\n        int x = 0, y = 0;\\n        \\n        for (int[] wall : walls) {\\n            x = wall[0];\\n            y = wall[1];\\n            \\n            ans[x][y] = -1;  \\n        }\\n    \\n        for (int[] grd : guards) {\\n            x = grd[0];\\n            y = grd[1];\\n            \\n            ans[x][y] = 1;\\n        }\\n        \\n        for (int[] grd : guards) {\\n            x = grd[0];\\n            y = grd[1];\\n            \\n            for (int i = y + 1; i < n; i++) {\\n                if (ans[x][i] == -1 || ans[x][i] == 1) {\\n                    break;\\n                }\\n                ans[x][i] = 2;\\n            }\\n            \\n            for (int i = x + 1; i < m; i++) {\\n                if (ans[i][y] == -1 || ans[i][y] == 1) {\\n                    break;\\n                }\\n                ans[i][y] = 2;\\n            }\\n            \\n            for (int i = y - 1; i >= 0; i--) {\\n                if (ans[x][i] == -1 || ans[x][i] == 1) {\\n                    break;\\n                }\\n                ans[x][i] = 2;\\n            }\\n            \\n            for (int i = x - 1; i >= 0; i--) {\\n                if (ans[i][y] == -1 || ans[i][y] == 1) {\\n                    break;\\n                }\\n                ans[i][y] = 2;\\n            }\\n        }\\n        \\n        int c = 0;\\n        \\n        for (int[] arr : ans) {\\n            for (int i : arr) {\\n                if (i == 0) {\\n                    c++;\\n                }\\n            }\\n        }\\n        \\n        return c;\\n    }\\n```\\n\\n**Bonus Tip**\\n* Don\\'t try to place guards while solving for every guard, do it before only, to avoid TLE\\n",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\npublic int countUnguarded(int m, int n, int[][] guards, int[][] walls) {\\n        int[][] ans = new int[m][n];\\n        int x = 0, y = 0;\\n        \\n        for (int[] wall : walls) {\\n            x = wall[0];\\n            y = wall[1];\\n            \\n            ans[x][y] = -1;  \\n        }\\n    \\n        for (int[] grd : guards) {\\n            x = grd[0];\\n            y = grd[1];\\n            \\n            ans[x][y] = 1;\\n        }\\n        \\n        for (int[] grd : guards) {\\n            x = grd[0];\\n            y = grd[1];\\n            \\n            for (int i = y + 1; i < n; i++) {\\n                if (ans[x][i] == -1 || ans[x][i] == 1) {\\n                    break;\\n                }\\n                ans[x][i] = 2;\\n            }\\n            \\n            for (int i = x + 1; i < m; i++) {\\n                if (ans[i][y] == -1 || ans[i][y] == 1) {\\n                    break;\\n                }\\n                ans[i][y] = 2;\\n            }\\n            \\n            for (int i = y - 1; i >= 0; i--) {\\n                if (ans[x][i] == -1 || ans[x][i] == 1) {\\n                    break;\\n                }\\n                ans[x][i] = 2;\\n            }\\n            \\n            for (int i = x - 1; i >= 0; i--) {\\n                if (ans[i][y] == -1 || ans[i][y] == 1) {\\n                    break;\\n                }\\n                ans[i][y] = 2;\\n            }\\n        }\\n        \\n        int c = 0;\\n        \\n        for (int[] arr : ans) {\\n            for (int i : arr) {\\n                if (i == 0) {\\n                    c++;\\n                }\\n            }\\n        }\\n        \\n        return c;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1994764,
                "title": "found-something-new-about-submission-brute-force-simplest-solution",
                "content": "**Approach**\\nConsidering every guard position as strarting cell. Iterate in all four directions/moves(up, right, down, left) on that cell following given constraints i.e. if any wall appears then don\\'t iterate further.\\n\\n**Update**\\nI got AC in same solution by a small change.\\n\\nInstead of using two unordered_map (umm and gmm) I have used only one and it got accepted ;)\\n\\n**Initial Doubt**\\nCan anyone expain why this solution giving TLE for large test cases?\\n\\nThis code passed 37/47 testcases.\\n```\\nclass Solution {\\npublic:\\n    int countUnguarded(int m, int n, vector<vector<int>>& guards, vector<vector<int>>& walls) {\\n        \\n        using pi = pair<int, int>;\\n        vector<vector<int>> visited(m, vector<int>(n, 1));\\n    \\n        unordered_map<int, unordered_map<int, int>> umm, gmm;\\n        \\n        for(auto x: walls){\\n            umm[x[0]][x[1]] = 1;\\n            visited[x[0]][x[1]] = -1;\\n        }\\n        for(auto x: guards){\\n            gmm[x[0]][x[1]] = 1;\\n            visited[x[0]][x[1]] = -1;\\n        }\\n        \\n        for(auto guard: guards) {\\n            int gx = guard[0];\\n            int gy = guard[1];\\n            \\n                // visited[gx][gy] = -1;\\n                \\n                \\n                // moving up\\n                for(int upx = gx-1; upx >= 0; upx--) {\\n                    if(umm[upx][gy] == 1 or gmm[upx][gy] == 1) {\\n                        break;\\n                    }\\n                    visited[upx][gy] = -1;\\n                }\\n                \\n                // right\\n                for(int rx = gy+1; rx <n; ++rx){\\n                    if(umm[gx][rx] == 1 or gmm[gx][rx] == 1) {\\n                        break;\\n                    }\\n                    visited[gx][rx] = -1;\\n                }\\n                \\n                // down\\n                for(int dx = gx+1; dx<m; dx++){\\n                    if(umm[dx][gy] == 1 or gmm[dx][gy] == 1){\\n                        break;\\n                    }\\n                    visited[dx][gy] = -1;\\n                }\\n                \\n                // left\\n                for(int lx = gy - 1; lx >= 0; lx--) {\\n                    if(umm[gx][lx] == 1 or gmm[gx][lx] == 1) {\\n                        break;\\n                    }\\n                    visited[gx][lx] = -1;\\n                }\\n                \\n                \\n        }\\n        \\n        int cnt = 0;\\n        \\n        for(int i=0; i<m; ++i){\\n            for(int j=0; j<n; ++j) {\\n                if(visited[i][j] == 1){\\n                    cnt++;\\n                } \\n            }\\n        }\\n        \\n        return cnt;\\n    }\\n};\\n```\\n\\n\\nIn the contest my submission passed 32/47 testcases while second submission passed 37/47 testcases.\\nThe difference between two is, I have console output some values for debug in former which I removed in second submission.\\n\\nAlso, after clubbing two unordered_map into I got AC.\\n```\\nclass Solution {\\npublic:\\n    int countUnguarded(int m, int n, vector<vector<int>>& guards, vector<vector<int>>& walls) {\\n        \\n        using pi = pair<int, int>;\\n        vector<vector<int>> visited(m, vector<int>(n, 1));\\n        unordered_map<int, unordered_map<int, int>> umm;\\n        \\n        for(auto x: walls){\\n            umm[x[0]][x[1]] = 1;\\n            visited[x[0]][x[1]] = -1;\\n        }\\n        for(auto x: guards){\\n            umm[x[0]][x[1]] = 1;\\n            visited[x[0]][x[1]] = -1;\\n        }\\n        \\n        for(auto guard: guards) {\\n            int gx = guard[0];\\n            int gy = guard[1];\\n            \\n               \\n                \\n                // moving up\\n                for(int upx = gx-1; upx >= 0; upx--) {\\n                    if(umm[upx][gy] == 1) {\\n                        break;\\n                    }\\n                    visited[upx][gy] = -1;\\n                }\\n                \\n                // right\\n                for(int rx = gy+1; rx <n; ++rx){\\n                    if(umm[gx][rx] == 1) {\\n                        break;\\n                    }\\n                    visited[gx][rx] = -1;\\n                }\\n                \\n                // down\\n                for(int dx = gx+1; dx<m; dx++){\\n                    if(umm[dx][gy] == 1){\\n                        break;\\n                    }\\n                    visited[dx][gy] = -1;\\n                }\\n                \\n                // left\\n                for(int lx = gy - 1; lx >= 0; lx--) {\\n                    if(umm[gx][lx] == 1) {\\n                        break;\\n                    }\\n                    visited[gx][lx] = -1;\\n                }\\n                \\n                \\n        }\\n        \\n        int cnt = 0;\\n        \\n        for(int i=0; i<m; ++i){\\n            for(int j=0; j<n; ++j) {\\n                // cout << visited[i][j] << \" \";\\n                if(visited[i][j] == 1){\\n                    cnt++;\\n                } \\n            }\\n            // cout << endl;\\n        }\\n        \\n        return cnt;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int countUnguarded(int m, int n, vector<vector<int>>& guards, vector<vector<int>>& walls) {\\n        \\n        using pi = pair<int, int>;\\n        vector<vector<int>> visited(m, vector<int>(n, 1));\\n    \\n        unordered_map<int, unordered_map<int, int>> umm, gmm;\\n        \\n        for(auto x: walls){\\n            umm[x[0]][x[1]] = 1;\\n            visited[x[0]][x[1]] = -1;\\n        }\\n        for(auto x: guards){\\n            gmm[x[0]][x[1]] = 1;\\n            visited[x[0]][x[1]] = -1;\\n        }\\n        \\n        for(auto guard: guards) {\\n            int gx = guard[0];\\n            int gy = guard[1];\\n            \\n                // visited[gx][gy] = -1;\\n                \\n                \\n                // moving up\\n                for(int upx = gx-1; upx >= 0; upx--) {\\n                    if(umm[upx][gy] == 1 or gmm[upx][gy] == 1) {\\n                        break;\\n                    }\\n                    visited[upx][gy] = -1;\\n                }\\n                \\n                // right\\n                for(int rx = gy+1; rx <n; ++rx){\\n                    if(umm[gx][rx] == 1 or gmm[gx][rx] == 1) {\\n                        break;\\n                    }\\n                    visited[gx][rx] = -1;\\n                }\\n                \\n                // down\\n                for(int dx = gx+1; dx<m; dx++){\\n                    if(umm[dx][gy] == 1 or gmm[dx][gy] == 1){\\n                        break;\\n                    }\\n                    visited[dx][gy] = -1;\\n                }\\n                \\n                // left\\n                for(int lx = gy - 1; lx >= 0; lx--) {\\n                    if(umm[gx][lx] == 1 or gmm[gx][lx] == 1) {\\n                        break;\\n                    }\\n                    visited[gx][lx] = -1;\\n                }\\n                \\n                \\n        }\\n        \\n        int cnt = 0;\\n        \\n        for(int i=0; i<m; ++i){\\n            for(int j=0; j<n; ++j) {\\n                if(visited[i][j] == 1){\\n                    cnt++;\\n                } \\n            }\\n        }\\n        \\n        return cnt;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int countUnguarded(int m, int n, vector<vector<int>>& guards, vector<vector<int>>& walls) {\\n        \\n        using pi = pair<int, int>;\\n        vector<vector<int>> visited(m, vector<int>(n, 1));\\n        unordered_map<int, unordered_map<int, int>> umm;\\n        \\n        for(auto x: walls){\\n            umm[x[0]][x[1]] = 1;\\n            visited[x[0]][x[1]] = -1;\\n        }\\n        for(auto x: guards){\\n            umm[x[0]][x[1]] = 1;\\n            visited[x[0]][x[1]] = -1;\\n        }\\n        \\n        for(auto guard: guards) {\\n            int gx = guard[0];\\n            int gy = guard[1];\\n            \\n               \\n                \\n                // moving up\\n                for(int upx = gx-1; upx >= 0; upx--) {\\n                    if(umm[upx][gy] == 1) {\\n                        break;\\n                    }\\n                    visited[upx][gy] = -1;\\n                }\\n                \\n                // right\\n                for(int rx = gy+1; rx <n; ++rx){\\n                    if(umm[gx][rx] == 1) {\\n                        break;\\n                    }\\n                    visited[gx][rx] = -1;\\n                }\\n                \\n                // down\\n                for(int dx = gx+1; dx<m; dx++){\\n                    if(umm[dx][gy] == 1){\\n                        break;\\n                    }\\n                    visited[dx][gy] = -1;\\n                }\\n                \\n                // left\\n                for(int lx = gy - 1; lx >= 0; lx--) {\\n                    if(umm[gx][lx] == 1) {\\n                        break;\\n                    }\\n                    visited[gx][lx] = -1;\\n                }\\n                \\n                \\n        }\\n        \\n        int cnt = 0;\\n        \\n        for(int i=0; i<m; ++i){\\n            for(int j=0; j<n; ++j) {\\n                // cout << visited[i][j] << \" \";\\n                if(visited[i][j] == 1){\\n                    cnt++;\\n                } \\n            }\\n            // cout << endl;\\n        }\\n        \\n        return cnt;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 1994737,
                "title": "javascript-java-direct-way",
                "content": "Main idea:\\n(1) set walls and guards in grid\\n(2) for each guard, check 4 directions, if find obstacle, stop\\n\\njavascript: 707ms\\n```\\nconst initialize2DArray = (n, m) => { let d = []; for (let i = 0; i < n; i++) { let t = Array(m).fill(0); d.push(t); } return d; };\\n\\nconst hit = (cur) => {\\n    if (cur == \\'W\\') return true;\\n    if (cur == \\'G\\') return true;\\n    return false;\\n}\\n\\nconst countUnguarded = (n, m, guards, walls) => {\\n    let visit = initialize2DArray(n, m), cnt = 0;\\n    for (const [x, y] of walls) visit[x][y] = \\'W\\';\\n    for (const [x, y] of guards) visit[x][y] = \\'G\\';\\n    for (const [x, y] of guards) {\\n        for (let j = y + 1; j < m; j++) { // right\\n            if (hit(visit[x][j])) break;\\n            visit[x][j] = \"R\";\\n        }\\n        for (let j = y - 1; j >= 0; j--) { // left\\n            if (hit(visit[x][j])) break;\\n            visit[x][j] = \"R\";\\n        }\\n        for (let i = x + 1; i < n; i++) { // down\\n            if (hit(visit[i][y])) break;\\n            visit[i][y] = \"R\";\\n        }\\n        for (let i = x - 1; i >= 0; i--) { // up\\n            if (hit(visit[i][y])) break;\\n            visit[i][y] = \"R\";\\n        }\\n    }\\n    for (let i = 0; i < n; i++) {\\n        for (let j = 0; j < m; j++) {\\n            if (visit[i][j] == 0) cnt++;\\n        }\\n    }\\n    return cnt;\\n};\\n```\\njava: 26ms\\n```\\nclass Solution {\\n     public int countUnguarded(int n, int m, int[][] guards, int[][] walls) {\\n        char[][] visit = new char[n][m];\\n        int cnt = 0;\\n        for (int[] wall : walls) visit[wall[0]][wall[1]] = \\'W\\';\\n        for (int[] guard : guards) visit[guard[0]][guard[1]] = \\'G\\';\\n        for (int[] guard : guards) {\\n            int x = guard[0], y = guard[1];\\n            for (int j = y + 1; j < m; j++) { // right\\n                if (hit(visit[x][j])) break;\\n                visit[x][j] = \\'R\\';\\n            }\\n            for (int j = y - 1; j >= 0; j--) { // left\\n                if (hit(visit[x][j])) break;\\n                visit[x][j] = \\'R\\';\\n            }\\n            for (int i = x + 1; i < n; i++) { // down\\n                if (hit(visit[i][y])) break;\\n                visit[i][y] = \\'R\\';\\n            }\\n            for (int i = x - 1; i >= 0; i--) { // up\\n                if (hit(visit[i][y])) break;\\n                visit[i][y] = \\'R\\';\\n            }\\n        }\\n        for (int i = 0; i < n; i++) {\\n            for (int j = 0; j < m; j++) {\\n                if (visit[i][j] == 0) cnt++;\\n            }\\n        }\\n        return cnt;\\n    }\\n\\n    boolean hit(char cur) {\\n        if (cur == \\'W\\') return true;\\n        if (cur == \\'G\\') return true;\\n        return false;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "JavaScript"
                ],
                "code": "```\\nconst initialize2DArray = (n, m) => { let d = []; for (let i = 0; i < n; i++) { let t = Array(m).fill(0); d.push(t); } return d; };\\n\\nconst hit = (cur) => {\\n    if (cur == \\'W\\') return true;\\n    if (cur == \\'G\\') return true;\\n    return false;\\n}\\n\\nconst countUnguarded = (n, m, guards, walls) => {\\n    let visit = initialize2DArray(n, m), cnt = 0;\\n    for (const [x, y] of walls) visit[x][y] = \\'W\\';\\n    for (const [x, y] of guards) visit[x][y] = \\'G\\';\\n    for (const [x, y] of guards) {\\n        for (let j = y + 1; j < m; j++) { // right\\n            if (hit(visit[x][j])) break;\\n            visit[x][j] = \"R\";\\n        }\\n        for (let j = y - 1; j >= 0; j--) { // left\\n            if (hit(visit[x][j])) break;\\n            visit[x][j] = \"R\";\\n        }\\n        for (let i = x + 1; i < n; i++) { // down\\n            if (hit(visit[i][y])) break;\\n            visit[i][y] = \"R\";\\n        }\\n        for (let i = x - 1; i >= 0; i--) { // up\\n            if (hit(visit[i][y])) break;\\n            visit[i][y] = \"R\";\\n        }\\n    }\\n    for (let i = 0; i < n; i++) {\\n        for (let j = 0; j < m; j++) {\\n            if (visit[i][j] == 0) cnt++;\\n        }\\n    }\\n    return cnt;\\n};\\n```\n```\\nclass Solution {\\n     public int countUnguarded(int n, int m, int[][] guards, int[][] walls) {\\n        char[][] visit = new char[n][m];\\n        int cnt = 0;\\n        for (int[] wall : walls) visit[wall[0]][wall[1]] = \\'W\\';\\n        for (int[] guard : guards) visit[guard[0]][guard[1]] = \\'G\\';\\n        for (int[] guard : guards) {\\n            int x = guard[0], y = guard[1];\\n            for (int j = y + 1; j < m; j++) { // right\\n                if (hit(visit[x][j])) break;\\n                visit[x][j] = \\'R\\';\\n            }\\n            for (int j = y - 1; j >= 0; j--) { // left\\n                if (hit(visit[x][j])) break;\\n                visit[x][j] = \\'R\\';\\n            }\\n            for (int i = x + 1; i < n; i++) { // down\\n                if (hit(visit[i][y])) break;\\n                visit[i][y] = \\'R\\';\\n            }\\n            for (int i = x - 1; i >= 0; i--) { // up\\n                if (hit(visit[i][y])) break;\\n                visit[i][y] = \\'R\\';\\n            }\\n        }\\n        for (int i = 0; i < n; i++) {\\n            for (int j = 0; j < m; j++) {\\n                if (visit[i][j] == 0) cnt++;\\n            }\\n        }\\n        return cnt;\\n    }\\n\\n    boolean hit(char cur) {\\n        if (cur == \\'W\\') return true;\\n        if (cur == \\'G\\') return true;\\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1994725,
                "title": "python-dfs",
                "content": "We iterate through the whole matrix.\\nWhenever we come across a guard , we start the `dfs` operation in all the 4 directions.\\nDuring the operation , we set the cells in those directions to `0` .\\nWe stop the operation when:\\n* We go out of matrix bound\\n* We encounter a wall or another guard\\n* We come across a `0` cell WHICH has been set to `0` by a operation in similar direction i.e horizontal (East and West) or vertical (North and South)\\n\\nFinally we count the number of unguarded cells \\n\\n\\n\\n```py\\nclass Solution:\\n    def countUnguarded(self, r: int, c: int, guards: List[List[int]], walls: List[List[int]]) -> int:\\n        arr = [[(1, (1, 1))] * c for _ in range(r)]\\n        for x, y in guards:\\n            arr[x][y] = \"G\"\\n        for x, y in walls:\\n            arr[x][y] = \"W\"\\n        dirs = [(1, 0), (-1, 0), (0, 1), (0, -1)]\\n\\n        def dfs(x, y, dx, dy):\\n            if x >= r or y >= c or x < 0 or y < 0 \\\\\\n                    or (arr[x][y][0] == 0 and (arr[x][y][1][0] == dx or arr[x][y][1][1] == dy)) \\\\\\n                    or arr[x][y] == \"W\" or arr[x][y] == \"G\":\\n                return\\n\\n            arr[x][y] = (0, (dx, dy))\\n            dfs(x + dx, y + dy, dx, dy)\\n\\n        for x, y in product(range(r), range(c)):\\n            if arr[x][y] == \"G\":\\n                for dx, dy in dirs:\\n                    dfs(x + dx, y + dy, dx, dy)\\n        sol = 0\\n        for x, y in product(range(r), range(c)):\\n            if arr[x][y][0] == 1:\\n                sol += 1\\n\\n        return sol\\n\\n\\n\\n```\\n\\nIf you have any questions , feel free to ask\\n\\n**Happy Coding !!**",
                "solutionTags": [
                    "Python",
                    "Depth-First Search"
                ],
                "code": "```py\\nclass Solution:\\n    def countUnguarded(self, r: int, c: int, guards: List[List[int]], walls: List[List[int]]) -> int:\\n        arr = [[(1, (1, 1))] * c for _ in range(r)]\\n        for x, y in guards:\\n            arr[x][y] = \"G\"\\n        for x, y in walls:\\n            arr[x][y] = \"W\"\\n        dirs = [(1, 0), (-1, 0), (0, 1), (0, -1)]\\n\\n        def dfs(x, y, dx, dy):\\n            if x >= r or y >= c or x < 0 or y < 0 \\\\\\n                    or (arr[x][y][0] == 0 and (arr[x][y][1][0] == dx or arr[x][y][1][1] == dy)) \\\\\\n                    or arr[x][y] == \"W\" or arr[x][y] == \"G\":\\n                return\\n\\n            arr[x][y] = (0, (dx, dy))\\n            dfs(x + dx, y + dy, dx, dy)\\n\\n        for x, y in product(range(r), range(c)):\\n            if arr[x][y] == \"G\":\\n                for dx, dy in dirs:\\n                    dfs(x + dx, y + dy, dx, dy)\\n        sol = 0\\n        for x, y in product(range(r), range(c)):\\n            if arr[x][y][0] == 1:\\n                sol += 1\\n\\n        return sol\\n\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1994710,
                "title": "java-one-direction-at-a-time-linear-time",
                "content": "Other appraoches that i have seen are not linear. We are visiting one cell by multiple wall query. here we are iterating 4 time for each direction.\\n```\\nclass Solution {\\n    public int countUnguarded(int m, int n, int[][] guards, int[][] walls) {\\n        //  guard right\\n        int[][] a = new int[m][n];\\n        //  guard left\\n        int[][] b = new int[m][n];\\n        //  guard top\\n        int[][] c = new int[m][n];\\n        //  guard bottom\\n        int[][] d = new int[m][n];\\n        \\n        //  making walls\\n        for (int[] p : walls) {\\n            a[p[0]][p[1]] = -1;\\n            b[p[0]][p[1]] = -1;\\n            c[p[0]][p[1]] = -1;\\n            d[p[0]][p[1]] = -1;\\n        }\\n        \\n        //  making guards\\n        for (int[] p : guards) {\\n            a[p[0]][p[1]] = 1;\\n            b[p[0]][p[1]] = 1;\\n            c[p[0]][p[1]] = 1;\\n            d[p[0]][p[1]] = 1;\\n        }\\n        \\n        //  right\\n        for (int j = 1; j < n; j++) {\\n            for (int i = 0; i < m; i++) {\\n                if (a[i][j] == 0) {\\n                    if (a[i][j - 1] == 1) {\\n                        a[i][j] = 1;\\n                    } else {\\n                        a[i][j] = 0;\\n                    }\\n                }\\n            }\\n        }\\n        \\n        //  left\\n        for (int j = n - 2; j >= 0; j--) {\\n            for (int i = 0; i < m; i++) {\\n                if (b[i][j] == 0) {\\n                    if (b[i][j + 1] == 1) {\\n                        b[i][j] = 1;\\n                    } else {\\n                        b[i][j] = 0;\\n                    }\\n                }\\n            }\\n        }\\n        \\n        \\n        //  top\\n        for (int i = 1; i < m; i++) {\\n            for (int j = 0; j < n; j++) {\\n                if (c[i][j] == 0) {\\n                    if (c[i - 1][j] == 1) {\\n                        c[i][j] = 1;\\n                    } else {\\n                        c[i][j] = 0;\\n                    }\\n                }\\n            }\\n        }\\n        \\n        // bottom\\n        for (int i = m - 2; i >= 0; i--) {\\n            for (int j = 0; j < n; j++) {\\n                if (d[i][j] == 0) {\\n                    if (d[i + 1][j] == 1) {\\n                        d[i][j] = 1;\\n                    } else {\\n                        d[i][j] = 0;\\n                    }\\n                }\\n            }\\n        }\\n        \\n        int answer = 0;\\n        for (int i = 0; i < m; i++) {\\n            for (int j = 0; j < n; j++) {\\n                if (a[i][j] == 0 && b[i][j] == 0 && c[i][j] == 0 && d[i][j] == 0) {\\n                    answer++;\\n                }\\n            }\\n        }\\n        return answer;\\n    }\\n}\\n\\n```\\n```\\nTime : O(4*m*n)\\nSpace : O(4*m*n)\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int countUnguarded(int m, int n, int[][] guards, int[][] walls) {\\n        //  guard right\\n        int[][] a = new int[m][n];\\n        //  guard left\\n        int[][] b = new int[m][n];\\n        //  guard top\\n        int[][] c = new int[m][n];\\n        //  guard bottom\\n        int[][] d = new int[m][n];\\n        \\n        //  making walls\\n        for (int[] p : walls) {\\n            a[p[0]][p[1]] = -1;\\n            b[p[0]][p[1]] = -1;\\n            c[p[0]][p[1]] = -1;\\n            d[p[0]][p[1]] = -1;\\n        }\\n        \\n        //  making guards\\n        for (int[] p : guards) {\\n            a[p[0]][p[1]] = 1;\\n            b[p[0]][p[1]] = 1;\\n            c[p[0]][p[1]] = 1;\\n            d[p[0]][p[1]] = 1;\\n        }\\n        \\n        //  right\\n        for (int j = 1; j < n; j++) {\\n            for (int i = 0; i < m; i++) {\\n                if (a[i][j] == 0) {\\n                    if (a[i][j - 1] == 1) {\\n                        a[i][j] = 1;\\n                    } else {\\n                        a[i][j] = 0;\\n                    }\\n                }\\n            }\\n        }\\n        \\n        //  left\\n        for (int j = n - 2; j >= 0; j--) {\\n            for (int i = 0; i < m; i++) {\\n                if (b[i][j] == 0) {\\n                    if (b[i][j + 1] == 1) {\\n                        b[i][j] = 1;\\n                    } else {\\n                        b[i][j] = 0;\\n                    }\\n                }\\n            }\\n        }\\n        \\n        \\n        //  top\\n        for (int i = 1; i < m; i++) {\\n            for (int j = 0; j < n; j++) {\\n                if (c[i][j] == 0) {\\n                    if (c[i - 1][j] == 1) {\\n                        c[i][j] = 1;\\n                    } else {\\n                        c[i][j] = 0;\\n                    }\\n                }\\n            }\\n        }\\n        \\n        // bottom\\n        for (int i = m - 2; i >= 0; i--) {\\n            for (int j = 0; j < n; j++) {\\n                if (d[i][j] == 0) {\\n                    if (d[i + 1][j] == 1) {\\n                        d[i][j] = 1;\\n                    } else {\\n                        d[i][j] = 0;\\n                    }\\n                }\\n            }\\n        }\\n        \\n        int answer = 0;\\n        for (int i = 0; i < m; i++) {\\n            for (int j = 0; j < n; j++) {\\n                if (a[i][j] == 0 && b[i][j] == 0 && c[i][j] == 0 && d[i][j] == 0) {\\n                    answer++;\\n                }\\n            }\\n        }\\n        return answer;\\n    }\\n}\\n\\n```\n```\\nTime : O(4*m*n)\\nSpace : O(4*m*n)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1994701,
                "title": "c-binary-search",
                "content": "```\\nclass Solution {\\npublic:\\n    \\n    static bool comp(pair<int,int> &a,pair<int,int> &b) {\\n        if(a.first!=b.first) return a.first<b.first;\\n        return a.second<b.second;\\n   \\n}\\n\\n    int countUnguarded(int m, int n, vector<vector<int>>& guards, vector<vector<int>>& walls) {\\n        \\n        vector<vector<pair<int,int>>> p_row(m);\\n        vector<vector<pair<int,int>>> p_col(n);\\n        \\n        \\n        vector<vector<int>> v(m,vector<int> (n,1));\\n        \\n        for(int i=0;i<guards.size();i++){\\n            p_row[guards[i][0]].push_back({guards[i][1],0});\\n            p_col[guards[i][1]].push_back({guards[i][0],0}); \\n            \\n            v[guards[i][0]][guards[i][1]]=-1;\\n        }\\n        \\n        for(int i=0;i<walls.size();i++){\\n            p_row[walls[i][0]].push_back({walls[i][1],1});\\n            p_col[walls[i][1]].push_back({walls[i][0],1}); \\n            \\n            v[walls[i][0]][walls[i][1]]=-1;\\n            \\n        }\\n       \\n        for(int i=0;i<p_row.size();i++){\\n            sort(p_row[i].begin(),p_row[i].end());\\n            \\n        }\\n        for(int i=0;i<p_col.size();i++){\\n            sort(p_col[i].begin(),p_col[i].end());\\n            \\n        }\\n\\n        \\n        long long count=0;\\n        \\n        \\n        for(int i=0;i<m;i++){\\n            \\n            for(int j=0;j<n;j++){\\n                \\n                int row=i;\\n                int col=j;\\n                if(v[row][col]==-1) continue;\\n                \\n                bool f=1;\\n                pair p={col,-1};\\n                int ind=lower_bound(p_row[row].begin(),p_row[row].end(),p)-p_row[row].begin();\\n                if(!(ind==p_row[row].size() || p_row[row][ind].second==1))\\n                    continue;\\n                \\n                ind=lower_bound(p_row[row].begin(),p_row[row].end(),p)-p_row[row].begin()-1;\\n                \\n                if(ind>-1 && ind<col && p_row[row][ind].second==0)\\n                    continue;\\n                \\n                p={row,-1};\\n                \\n                ind=lower_bound(p_col[col].begin(),p_col[col].end(),p)-p_col[col].begin();\\n                if(!(ind==p_col[col].size() || p_col[col][ind].second==1))\\n                    continue;\\n                \\n                ind=lower_bound(p_col[col].begin(),p_col[col].end(),p)-p_col[col].begin()-1;\\n                if(ind>-1 && ind<row && p_col[col][ind].second==0)\\n                    continue;\\n                \\n\\n                count++;\\n               \\n            }\\n            \\n        }\\n        \\n        return count;\\n        \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    static bool comp(pair<int,int> &a,pair<int,int> &b) {\\n        if(a.first!=b.first) return a.first<b.first;\\n        return a.second<b.second;\\n   \\n}\\n\\n    int countUnguarded(int m, int n, vector<vector<int>>& guards, vector<vector<int>>& walls) {\\n        \\n        vector<vector<pair<int,int>>> p_row(m);\\n        vector<vector<pair<int,int>>> p_col(n);\\n        \\n        \\n        vector<vector<int>> v(m,vector<int> (n,1));\\n        \\n        for(int i=0;i<guards.size();i++){\\n            p_row[guards[i][0]].push_back({guards[i][1],0});\\n            p_col[guards[i][1]].push_back({guards[i][0],0}); \\n            \\n            v[guards[i][0]][guards[i][1]]=-1;\\n        }\\n        \\n        for(int i=0;i<walls.size();i++){\\n            p_row[walls[i][0]].push_back({walls[i][1],1});\\n            p_col[walls[i][1]].push_back({walls[i][0],1}); \\n            \\n            v[walls[i][0]][walls[i][1]]=-1;\\n            \\n        }\\n       \\n        for(int i=0;i<p_row.size();i++){\\n            sort(p_row[i].begin(),p_row[i].end());\\n            \\n        }\\n        for(int i=0;i<p_col.size();i++){\\n            sort(p_col[i].begin(),p_col[i].end());\\n            \\n        }\\n\\n        \\n        long long count=0;\\n        \\n        \\n        for(int i=0;i<m;i++){\\n            \\n            for(int j=0;j<n;j++){\\n                \\n                int row=i;\\n                int col=j;\\n                if(v[row][col]==-1) continue;\\n                \\n                bool f=1;\\n                pair p={col,-1};\\n                int ind=lower_bound(p_row[row].begin(),p_row[row].end(),p)-p_row[row].begin();\\n                if(!(ind==p_row[row].size() || p_row[row][ind].second==1))\\n                    continue;\\n                \\n                ind=lower_bound(p_row[row].begin(),p_row[row].end(),p)-p_row[row].begin()-1;\\n                \\n                if(ind>-1 && ind<col && p_row[row][ind].second==0)\\n                    continue;\\n                \\n                p={row,-1};\\n                \\n                ind=lower_bound(p_col[col].begin(),p_col[col].end(),p)-p_col[col].begin();\\n                if(!(ind==p_col[col].size() || p_col[col][ind].second==1))\\n                    continue;\\n                \\n                ind=lower_bound(p_col[col].begin(),p_col[col].end(),p)-p_col[col].begin()-1;\\n                if(ind>-1 && ind<row && p_col[col][ind].second==0)\\n                    continue;\\n                \\n\\n                count++;\\n               \\n            }\\n            \\n        }\\n        \\n        return count;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1994691,
                "title": "java-easy-understanding",
                "content": "```\\npublic int countUnguarded(int m, int n, int[][] guards, int[][] walls) {\\n        HashSet<String> wSet = new HashSet();\\n        HashSet<String> gSet = new HashSet();\\n        HashSet<String> vis = new HashSet();\\n        \\n        for(int []wall:walls){\\n            int x=wall[0];\\n            int y=wall[1];\\n            String str=x+\",\"+y;\\n            wSet.add(str);\\n            vis.add(str);\\n        }\\n        \\n        for(int []guard:guards){\\n            int x=guard[0];\\n            int y=guard[1];\\n            String str=x+\",\"+y;\\n            gSet.add(str);\\n            vis.add(str);\\n        }\\n        \\n        for(int []guard:guards){\\n            int x=guard[0];\\n            int y=guard[1];\\n            \\n            for(int i=x+1;i<m;i++){\\n                String str=i+\",\"+y;\\n                if(wSet.contains(str) || gSet.contains(str)){\\n                    break;\\n                }\\n                vis.add(str);\\n            }\\n            \\n            for(int i=x-1;i>=0;i--){\\n                String str=i+\",\"+y;\\n                if(wSet.contains(str) || gSet.contains(str)){\\n                    break;\\n                }\\n                vis.add(str);\\n            }\\n            \\n            for(int j=y+1;j<n;j++){\\n                String str=x+\",\"+j;\\n                if(wSet.contains(str) || gSet.contains(str)){\\n                    break;\\n                }\\n                vis.add(str);\\n            }\\n            \\n            for(int j=y-1;j>=0;j--){\\n                String str=x+\",\"+j;\\n                if(wSet.contains(str) || gSet.contains(str)){\\n                    break;\\n                }\\n                vis.add(str);\\n            }\\n        }\\n        \\n        return (m*n-vis.size());\\n    }\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\npublic int countUnguarded(int m, int n, int[][] guards, int[][] walls) {\\n        HashSet<String> wSet = new HashSet();\\n        HashSet<String> gSet = new HashSet();\\n        HashSet<String> vis = new HashSet();\\n        \\n        for(int []wall:walls){\\n            int x=wall[0];\\n            int y=wall[1];\\n            String str=x+\",\"+y;\\n            wSet.add(str);\\n            vis.add(str);\\n        }\\n        \\n        for(int []guard:guards){\\n            int x=guard[0];\\n            int y=guard[1];\\n            String str=x+\",\"+y;\\n            gSet.add(str);\\n            vis.add(str);\\n        }\\n        \\n        for(int []guard:guards){\\n            int x=guard[0];\\n            int y=guard[1];\\n            \\n            for(int i=x+1;i<m;i++){\\n                String str=i+\",\"+y;\\n                if(wSet.contains(str) || gSet.contains(str)){\\n                    break;\\n                }\\n                vis.add(str);\\n            }\\n            \\n            for(int i=x-1;i>=0;i--){\\n                String str=i+\",\"+y;\\n                if(wSet.contains(str) || gSet.contains(str)){\\n                    break;\\n                }\\n                vis.add(str);\\n            }\\n            \\n            for(int j=y+1;j<n;j++){\\n                String str=x+\",\"+j;\\n                if(wSet.contains(str) || gSet.contains(str)){\\n                    break;\\n                }\\n                vis.add(str);\\n            }\\n            \\n            for(int j=y-1;j>=0;j--){\\n                String str=x+\",\"+j;\\n                if(wSet.contains(str) || gSet.contains(str)){\\n                    break;\\n                }\\n                vis.add(str);\\n            }\\n        }\\n        \\n        return (m*n-vis.size());\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1994648,
                "title": "simple-just-see-from-all-4-directions",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> vis;\\n    int countUnguarded(int m, int n, vector<vector<int>>& guards, vector<vector<int>>& walls) {\\n             vector<vector<int>>vis(m,vector<int>(n,0));\\n             vector<vector<int>> g(m,vector<int>(n,0));\\n             // guards as 2 , walls as 1 \\n             for(int i=0; i<walls.size(); i++) g[walls[i][0]][walls[i][1]]=1;\\n             for(int i=0; i<guards.size(); i++) g[guards[i][0]][guards[i][1]]=2;\\n             // see from all four directions\\n             for(int i=0; i<n; i++) {\\n                 int see=0;\\n                 for(int j=0; j<m; j++) {\\n                       if(g[j][i]==2) {\\n                           see=1;\\n                            vis[j][i]=1;\\n                       }else if(g[j][i]==1) {\\n                           see=0;\\n                            vis[j][i]=1;\\n                       }else {\\n                           vis[j][i]=max(vis[j][i],see);\\n                       }\\n                 }\\n             }\\n             for(int i=0; i<n; i++) {\\n                 int see=0;\\n                 for(int j=m-1; j>=0; j--) {\\n                       if(g[j][i]==2) {\\n                           see=1;\\n                       }else if(g[j][i]==1) {\\n                           see=0;\\n                           vis[j][i]=1;\\n                       }else {\\n                           vis[j][i]=max(vis[j][i],see);\\n                       }\\n                 }\\n             }\\n             for(int i=0; i<m; i++) {\\n                 int see=0;\\n                 for(int j=0; j<n; j++) {\\n                      if(g[i][j]==2) {\\n                           see=1;\\n                           vis[i][j]=1;\\n                      }else if(g[i][j]==1) {\\n                           see=0;\\n                           vis[i][j]=1;\\n                      }else {\\n                          vis[i][j]=max(vis[i][j],see);\\n                      }\\n                 }\\n             }\\n            for(int i=0; i<m; i++) {\\n                 int see=0;\\n                 for(int j=n-1; j>=0; j--) {\\n                      if(g[i][j]==2) {\\n                           see=1;\\n                           vis[i][j]=1;\\n                      }else if(g[i][j]==1) {\\n                           see=0;\\n                           vis[i][j]=1;\\n                      }else {\\n                          vis[i][j]=max(vis[i][j],see);\\n                      }\\n                 }\\n             }\\n        \\n        int cnt=0;\\n        for(int i=0; i<m; i++) {\\n            for(int j=0; j<n; j++) cnt+=vis[i][j]==0;\\n        }\\n        return cnt;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Simulation"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> vis;\\n    int countUnguarded(int m, int n, vector<vector<int>>& guards, vector<vector<int>>& walls) {\\n             vector<vector<int>>vis(m,vector<int>(n,0));\\n             vector<vector<int>> g(m,vector<int>(n,0));\\n             // guards as 2 , walls as 1 \\n             for(int i=0; i<walls.size(); i++) g[walls[i][0]][walls[i][1]]=1;\\n             for(int i=0; i<guards.size(); i++) g[guards[i][0]][guards[i][1]]=2;\\n             // see from all four directions\\n             for(int i=0; i<n; i++) {\\n                 int see=0;\\n                 for(int j=0; j<m; j++) {\\n                       if(g[j][i]==2) {\\n                           see=1;\\n                            vis[j][i]=1;\\n                       }else if(g[j][i]==1) {\\n                           see=0;\\n                            vis[j][i]=1;\\n                       }else {\\n                           vis[j][i]=max(vis[j][i],see);\\n                       }\\n                 }\\n             }\\n             for(int i=0; i<n; i++) {\\n                 int see=0;\\n                 for(int j=m-1; j>=0; j--) {\\n                       if(g[j][i]==2) {\\n                           see=1;\\n                       }else if(g[j][i]==1) {\\n                           see=0;\\n                           vis[j][i]=1;\\n                       }else {\\n                           vis[j][i]=max(vis[j][i],see);\\n                       }\\n                 }\\n             }\\n             for(int i=0; i<m; i++) {\\n                 int see=0;\\n                 for(int j=0; j<n; j++) {\\n                      if(g[i][j]==2) {\\n                           see=1;\\n                           vis[i][j]=1;\\n                      }else if(g[i][j]==1) {\\n                           see=0;\\n                           vis[i][j]=1;\\n                      }else {\\n                          vis[i][j]=max(vis[i][j],see);\\n                      }\\n                 }\\n             }\\n            for(int i=0; i<m; i++) {\\n                 int see=0;\\n                 for(int j=n-1; j>=0; j--) {\\n                      if(g[i][j]==2) {\\n                           see=1;\\n                           vis[i][j]=1;\\n                      }else if(g[i][j]==1) {\\n                           see=0;\\n                           vis[i][j]=1;\\n                      }else {\\n                          vis[i][j]=max(vis[i][j],see);\\n                      }\\n                 }\\n             }\\n        \\n        int cnt=0;\\n        for(int i=0; i<m; i++) {\\n            for(int j=0; j<n; j++) cnt+=vis[i][j]==0;\\n        }\\n        return cnt;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1994621,
                "title": "simple-efficient-code",
                "content": "```\\nclass Solution {\\npublic:\\ntypedef long long ll;\\n#define endl \\'\\\\n\\'\\nconst ll mod = 1e9 + 7;\\n\\nvoid dfs(vector<vector<ll>>& v, ll i = 0, ll j = 0, char dir = \\'u\\') {\\n    ll m = v.size(), n = v[0].size();\\n    if (i < 0 || j < 0 || i >= m || j >= n || v[i][j]>0) return;\\n    v[i][j] = -1;\\n    if (dir == \\'u\\') dfs(v, i - 1, j, \\'u\\');\\n    if (dir == \\'d\\') dfs(v, i + 1, j, \\'d\\');\\n    if (dir == \\'l\\') dfs(v, i, j - 1, \\'l\\');\\n    if (dir == \\'r\\') dfs(v, i, j + 1, \\'r\\');\\n}\\n\\n// -1gd 0uo 1 g 2 w\\nint countUnguarded(int m, int n, vector<vector<int>>& g, vector<vector<int>>& w) {\\n    vector<vector<ll>>v(m, vector<ll>(n, 0));\\n    for (const auto& it : g)\\n        v[it[0]][it[1]] = 1;\\n    for (const auto& it : w)\\n        v[it[0]][it[1]] = 2;\\n    for (ll i = 0;i < m;++i) {\\n        for (ll j = 0;j < n;++j) {\\n            if (v[i][j] == 1) {\\n                dfs(v, i + 1, j, \\'d\\');\\n                dfs(v, i - 1, j, \\'u\\');\\n                dfs(v, i, j + 1, \\'r\\');\\n                dfs(v, i, j - 1, \\'l\\');\\n            }\\n        }\\n    }\\n    ll res = 0;\\n    for (ll i = 0;i < m;++i) {\\n        for (ll j = 0;j < n;++j) {\\n            if (v[i][j] == 0) {\\n                res++;\\n            }\\n        }\\n    }\\n    return res;\\n}\\n\\n};\\n```",
                "solutionTags": [
                    "Depth-First Search",
                    "Graph"
                ],
                "code": "```\\nclass Solution {\\npublic:\\ntypedef long long ll;\\n#define endl \\'\\\\n\\'\\nconst ll mod = 1e9 + 7;\\n\\nvoid dfs(vector<vector<ll>>& v, ll i = 0, ll j = 0, char dir = \\'u\\') {\\n    ll m = v.size(), n = v[0].size();\\n    if (i < 0 || j < 0 || i >= m || j >= n || v[i][j]>0) return;\\n    v[i][j] = -1;\\n    if (dir == \\'u\\') dfs(v, i - 1, j, \\'u\\');\\n    if (dir == \\'d\\') dfs(v, i + 1, j, \\'d\\');\\n    if (dir == \\'l\\') dfs(v, i, j - 1, \\'l\\');\\n    if (dir == \\'r\\') dfs(v, i, j + 1, \\'r\\');\\n}\\n\\n// -1gd 0uo 1 g 2 w\\nint countUnguarded(int m, int n, vector<vector<int>>& g, vector<vector<int>>& w) {\\n    vector<vector<ll>>v(m, vector<ll>(n, 0));\\n    for (const auto& it : g)\\n        v[it[0]][it[1]] = 1;\\n    for (const auto& it : w)\\n        v[it[0]][it[1]] = 2;\\n    for (ll i = 0;i < m;++i) {\\n        for (ll j = 0;j < n;++j) {\\n            if (v[i][j] == 1) {\\n                dfs(v, i + 1, j, \\'d\\');\\n                dfs(v, i - 1, j, \\'u\\');\\n                dfs(v, i, j + 1, \\'r\\');\\n                dfs(v, i, j - 1, \\'l\\');\\n            }\\n        }\\n    }\\n    ll res = 0;\\n    for (ll i = 0;i < m;++i) {\\n        for (ll j = 0;j < n;++j) {\\n            if (v[i][j] == 0) {\\n                res++;\\n            }\\n        }\\n    }\\n    return res;\\n}\\n\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1994595,
                "title": "scala",
                "content": "```scala\\ndef countUnguarded(m: Int, n: Int, guards: Array[Array[Int]], walls: Array[Array[Int]]): Int = {\\n  val arr = Array.fill(m)(Array.fill(n)(\\'o\\'))\\n\\n  def isObstacle(i: Int, j: Int): Boolean = arr(i)(j) == \\'G\\' || arr(i)(j) == \\'W\\'\\n\\n  def markIPlus(i: Int, j: Int): Unit =\\n    if(i < m && !isObstacle(i, j)) {\\n      arr(i)(j) = \\'g\\'\\n      markIPlus(i + 1, j)\\n    }\\n\\n  def markIMinus(i: Int, j: Int): Unit =\\n    if(i >= 0 && !isObstacle(i, j)) {\\n      arr(i)(j) = \\'g\\'\\n      markIMinus(i - 1, j)\\n    }\\n\\n  def markJPlus(i: Int, j: Int): Unit =\\n    if(j < n && !isObstacle(i, j)) {\\n      arr(i)(j) = \\'g\\'\\n      markJPlus(i, j + 1)\\n    }\\n\\n  def markJMinus(i: Int, j: Int): Unit =\\n    if(j >= 0 && !isObstacle(i, j)) {\\n      arr(i)(j) = \\'g\\'\\n      markJMinus(i, j - 1)\\n    }\\n\\n  guards.foreach { case Array(i, j) => arr(i)(j) = \\'G\\' }\\n  walls.foreach { case Array(i, j) => arr(i)(j) = \\'W\\' }\\n\\n  guards.foreach { case Array(i, j) =>\\n    markIPlus(i + 1, j)\\n    markIMinus(i - 1, j)\\n    markJPlus(i, j + 1)\\n    markJMinus(i, j - 1)\\n  }\\n\\n  var cnt = 0\\n  for {\\n    i <- 0 until m\\n    j <- 0 until n\\n  } if(arr(i)(j) == \\'o\\') cnt += 1\\n\\n  cnt\\n}\\n```",
                "solutionTags": [
                    "Scala"
                ],
                "code": "```scala\\ndef countUnguarded(m: Int, n: Int, guards: Array[Array[Int]], walls: Array[Array[Int]]): Int = {\\n  val arr = Array.fill(m)(Array.fill(n)(\\'o\\'))\\n\\n  def isObstacle(i: Int, j: Int): Boolean = arr(i)(j) == \\'G\\' || arr(i)(j) == \\'W\\'\\n\\n  def markIPlus(i: Int, j: Int): Unit =\\n    if(i < m && !isObstacle(i, j)) {\\n      arr(i)(j) = \\'g\\'\\n      markIPlus(i + 1, j)\\n    }\\n\\n  def markIMinus(i: Int, j: Int): Unit =\\n    if(i >= 0 && !isObstacle(i, j)) {\\n      arr(i)(j) = \\'g\\'\\n      markIMinus(i - 1, j)\\n    }\\n\\n  def markJPlus(i: Int, j: Int): Unit =\\n    if(j < n && !isObstacle(i, j)) {\\n      arr(i)(j) = \\'g\\'\\n      markJPlus(i, j + 1)\\n    }\\n\\n  def markJMinus(i: Int, j: Int): Unit =\\n    if(j >= 0 && !isObstacle(i, j)) {\\n      arr(i)(j) = \\'g\\'\\n      markJMinus(i, j - 1)\\n    }\\n\\n  guards.foreach { case Array(i, j) => arr(i)(j) = \\'G\\' }\\n  walls.foreach { case Array(i, j) => arr(i)(j) = \\'W\\' }\\n\\n  guards.foreach { case Array(i, j) =>\\n    markIPlus(i + 1, j)\\n    markIMinus(i - 1, j)\\n    markJPlus(i, j + 1)\\n    markJMinus(i, j - 1)\\n  }\\n\\n  var cnt = 0\\n  for {\\n    i <- 0 until m\\n    j <- 0 until n\\n  } if(arr(i)(j) == \\'o\\') cnt += 1\\n\\n  cnt\\n}\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1994591,
                "title": "python-solution-using-dfs",
                "content": "\\n```\\nclass Solution:\\n    def countUnguarded(self, m: int, n: int, guards: List[List[int]], walls: List[List[int]]) -> int:\\n        \\n        #Create a matrix, hint from question\\n        mat = [[0 for _ in range(n)] for _ in range(m)] \\n        \\n        for [i,j] in guards:\\n            mat[i][j] = 1   \\n        for [i,j] in walls:\\n            mat[i][j] = -1\\n        \\n        #dfs for marking paths.\\n        def dfs(i,j,di):\\n            if i<0 or i>=m or j<0 or j>=n or mat[i][j] == 1 or mat[i][j] == -1:\\n                return\\n            else:\\n                mat[i][j] = 2\\n            i = i + lst[di]\\n            j = j + lst[di+1]\\n            dfs(i,j,di)\\n        \\n        lst = [1,0,-1,0,1]\\n        for [i,j] in guards:\\n            for idx in range(4):  \\n                k = i + lst[idx]\\n                l = j + lst[idx+1]\\n                dfs(k,l,idx)\\n        \\n        #count uncovered cells.\\n        count = 0\\n        for i in range(m):\\n            for j in range(n):\\n                if mat[i][j]==0:\\n                    count +=1\\n        return count\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution:\\n    def countUnguarded(self, m: int, n: int, guards: List[List[int]], walls: List[List[int]]) -> int:\\n        \\n        #Create a matrix, hint from question\\n        mat = [[0 for _ in range(n)] for _ in range(m)] \\n        \\n        for [i,j] in guards:\\n            mat[i][j] = 1   \\n        for [i,j] in walls:\\n            mat[i][j] = -1\\n        \\n        #dfs for marking paths.\\n        def dfs(i,j,di):\\n            if i<0 or i>=m or j<0 or j>=n or mat[i][j] == 1 or mat[i][j] == -1:\\n                return\\n            else:\\n                mat[i][j] = 2\\n            i = i + lst[di]\\n            j = j + lst[di+1]\\n            dfs(i,j,di)\\n        \\n        lst = [1,0,-1,0,1]\\n        for [i,j] in guards:\\n            for idx in range(4):  \\n                k = i + lst[idx]\\n                l = j + lst[idx+1]\\n                dfs(k,l,idx)\\n        \\n        #count uncovered cells.\\n        count = 0\\n        for i in range(m):\\n            for j in range(n):\\n                if mat[i][j]==0:\\n                    count +=1\\n        return count\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1994587,
                "title": "java-easy-approach-simple-solution",
                "content": "```\\nclass Solution {\\nint[] x = {-1,0,0,1};\\n    int[] y = {0,1,-1,0};\\n    public int countUnguarded(int m, int n, int[][] guards, int[][] walls) {\\n        char[][] visited = new char[m][n];\\n        for(char[] ch : visited){\\n            Arrays.fill(ch, \\'X\\');\\n        }\\n        for(int[] g : guards){\\n            visited[g[0]][g[1]] = \\'G\\';\\n        }\\n        for(int[] w : walls){\\n            visited[w[0]][w[1]] = \\'W\\';\\n        }\\n        for(int i = 0; i < visited.length; i++){\\n            for(int j = 0; j < visited[0].length; j++){\\n                if(visited[i][j] == \\'G\\'){\\n                    dfsLeft(m, n, visited, i, j);\\n                }\\n            }\\n        }\\n        int count = 0;\\n        for(int i = 0; i < m; i++){\\n            for(int j = 0; j < n; j++){\\n                 //System.out.print(visited[i][j] + \" \");\\n                if(visited[i][j] == \\'X\\'){\\n                   \\n                    count++;\\n                }\\n            }\\n            //System.out.println();\\n        }\\n        return count;\\n    }\\n    \\n    public void dfsLeft(int m, int n, char[][] visited, int i, int j){\\n        int ab = j;\\n        while(ab >= 0 && !(visited[i][ab]== \\'W\\')) {\\n            if(j == ab){\\n                ab--;\\n                continue;\\n            }\\n            if(visited[i][ab] == \\'G\\') {\\n            \\tbreak;\\n            }\\n            visited[i][ab] = \\'A\\';\\n            ab--;\\n        }\\n        ab = j;\\n        while(ab < n && !(visited[i][ab] == \\'W\\') ){\\n            if(j == ab){\\n                ab++;\\n                continue;\\n            }\\n            if(visited[i][ab] == \\'G\\') {\\n            \\tbreak;\\n            }\\n            visited[i][ab] = \\'A\\';\\n            ab++;\\n        }\\n        ab = i;\\n        while(ab >= 0 && !(visited[ab][j] == \\'W\\')  ){\\n            if(i == ab){\\n                ab--;\\n                continue;\\n            }\\n            if(visited[ab][j] == \\'G\\') {\\n            \\tbreak;\\n            }\\n            visited[ab][j] = \\'A\\';\\n            ab--;\\n        }\\n        ab = i;\\n        while(ab < m && !(visited[ab][j] == \\'W\\')){\\n            if(i == ab){\\n                ab++;\\n                continue;\\n            }\\n            if(visited[ab][j] == \\'G\\') {\\n            \\tbreak;\\n            }\\n            visited[ab][j] = \\'A\\';\\n            ab++;\\n        }\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Java",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\nint[] x = {-1,0,0,1};\\n    int[] y = {0,1,-1,0};\\n    public int countUnguarded(int m, int n, int[][] guards, int[][] walls) {\\n        char[][] visited = new char[m][n];\\n        for(char[] ch : visited){\\n            Arrays.fill(ch, \\'X\\');\\n        }\\n        for(int[] g : guards){\\n            visited[g[0]][g[1]] = \\'G\\';\\n        }\\n        for(int[] w : walls){\\n            visited[w[0]][w[1]] = \\'W\\';\\n        }\\n        for(int i = 0; i < visited.length; i++){\\n            for(int j = 0; j < visited[0].length; j++){\\n                if(visited[i][j] == \\'G\\'){\\n                    dfsLeft(m, n, visited, i, j);\\n                }\\n            }\\n        }\\n        int count = 0;\\n        for(int i = 0; i < m; i++){\\n            for(int j = 0; j < n; j++){\\n                 //System.out.print(visited[i][j] + \" \");\\n                if(visited[i][j] == \\'X\\'){\\n                   \\n                    count++;\\n                }\\n            }\\n            //System.out.println();\\n        }\\n        return count;\\n    }\\n    \\n    public void dfsLeft(int m, int n, char[][] visited, int i, int j){\\n        int ab = j;\\n        while(ab >= 0 && !(visited[i][ab]== \\'W\\')) {\\n            if(j == ab){\\n                ab--;\\n                continue;\\n            }\\n            if(visited[i][ab] == \\'G\\') {\\n            \\tbreak;\\n            }\\n            visited[i][ab] = \\'A\\';\\n            ab--;\\n        }\\n        ab = j;\\n        while(ab < n && !(visited[i][ab] == \\'W\\') ){\\n            if(j == ab){\\n                ab++;\\n                continue;\\n            }\\n            if(visited[i][ab] == \\'G\\') {\\n            \\tbreak;\\n            }\\n            visited[i][ab] = \\'A\\';\\n            ab++;\\n        }\\n        ab = i;\\n        while(ab >= 0 && !(visited[ab][j] == \\'W\\')  ){\\n            if(i == ab){\\n                ab--;\\n                continue;\\n            }\\n            if(visited[ab][j] == \\'G\\') {\\n            \\tbreak;\\n            }\\n            visited[ab][j] = \\'A\\';\\n            ab--;\\n        }\\n        ab = i;\\n        while(ab < m && !(visited[ab][j] == \\'W\\')){\\n            if(i == ab){\\n                ab++;\\n                continue;\\n            }\\n            if(visited[ab][j] == \\'G\\') {\\n            \\tbreak;\\n            }\\n            visited[ab][j] = \\'A\\';\\n            ab++;\\n        }\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1994578,
                "title": "c-easy-with-comments",
                "content": "```\\nclass Solution {\\npublic:\\n    // In this question, we first create the matrix and try to mark all the cells which are gaurded and at the end we count all the empty cells.\\n    // implementation is pretty straight forward.\\n    int countUnguarded(int m, int n, vector<vector<int>>& guards, vector<vector<int>>& walls) {\\n        vector<vector<int>> mat(m, vector<int>(n, 0)); // empty cell 0, guard 1, and walls 2, gaurded 3\\n        for(auto guard : guards) {\\n            mat[guard[0]][guard[1]] = 1;\\n        }\\n        for(auto wall : walls) {\\n            mat[wall[0]][wall[1]] = 2;\\n        }\\n        bool isGaurded = false;\\n        // for rows\\n        for(int i=0;i<m;i++) {\\n            isGaurded = false;\\n            for(int j=0;j<n;j++) { // left --> right\\n                if(mat[i][j] == 2) { // it is a wall\\n                    isGaurded = false;\\n                    continue;\\n                }\\n                if(isGaurded and mat[i][j] != 1)\\n                    mat[i][j] = 3;\\n                if(mat[i][j] == 1)\\n                    isGaurded = true;\\n            }\\n            isGaurded = false;\\n            for(int j=n-1;j>=0;j--) { // right --> left\\n                if(mat[i][j] == 2) {\\n                    isGaurded = false;\\n                    continue;\\n                }\\n                if(isGaurded and mat[i][j] != 1)\\n                    mat[i][j] = 3;\\n                if(mat[i][j] == 1)\\n                    isGaurded = true;\\n            }\\n        }\\n        isGaurded = false;\\n        // for columns\\n        for(int i=0;i<n;i++) {\\n            isGaurded = false;\\n            for(int j=0;j<m;j++) { // up to bottom\\n                if(mat[j][i] == 2) { // it is a wall\\n                    isGaurded = false;\\n                    continue;\\n                }\\n                if(isGaurded and mat[j][i] != 1)\\n                    mat[j][i] = 3;\\n                if(mat[j][i] == 1)\\n                    isGaurded = true;\\n            }\\n            isGaurded = false;\\n            for(int j=m-1;j>=0;j--) { // bottom to ip\\n                if(mat[j][i] == 2) {\\n                    isGaurded = false;\\n                    continue;\\n                }\\n                if(isGaurded and mat[j][i] != 1)\\n                    mat[j][i] = 3;\\n                if(mat[j][i] == 1)\\n                    isGaurded = true;\\n            }\\n        }\\n        int ans = 0;\\n        for(int i=0;i<m;i++) {\\n            for(int j=0;j<n;j++) {\\n                if(mat[i][j] == 0) ans++; // counting empty cells\\n            }\\n        }\\n        return ans;\\n        // upvote if you find it helpful. Thanks\\n    }\\n};",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n    // In this question, we first create the matrix and try to mark all the cells which are gaurded and at the end we count all the empty cells.\\n    // implementation is pretty straight forward.\\n    int countUnguarded(int m, int n, vector<vector<int>>& guards, vector<vector<int>>& walls) {\\n        vector<vector<int>> mat(m, vector<int>(n, 0)); // empty cell 0, guard 1, and walls 2, gaurded 3\\n        for(auto guard : guards) {\\n            mat[guard[0]][guard[1]] = 1;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1994560,
                "title": "python-dfs-greedy-o-mn",
                "content": "The solution is simple. We have to consider position of all guards and do a depth first search in either direction (left,, right, top, bottom) only and check if we encounter wall or another guard. If yes, we stop otherwise we add the solution to the guarded set. \\n\\nOnce we have all the cells that are guarded, we can find the unguarded by checking all cells, if they exist in guarded or guard or wall list in O(mn). \\n\\n\\n```\\nclass Solution:\\n    def countUnguarded(self, m: int, n: int, guards: List[List[int]], walls: List[List[int]]) -> int:\\n        guarded = set()\\n        guard_set = set()\\n        wall_set = set()\\n        \\n\\t\\tfor guard in guards:  guard_set.add((guard[0], guard[1]))\\n        for wall in walls: wall_set.add((wall[0], wall[1]))\\n\\t\\t\\n\\t\\t# left, right, bottom, top\\n        directions = [(1, 0), (-1, 0), (0, -1), (0, 1)]\\n\\t\\t\\n        # find all guarded\\n        for guard in guards:\\n            for dx, dy in directions:\\n                x, y = guard\\n                \\n\\t\\t\\t\\t# travel one direction\\n                while 0 <= x + dx < m and 0 <= y + dy < n:\\n                    x, y = x + dx , y + dy\\n                    if (x, y) in guard_set or (x, y) in wall_set: break\\n                    guarded.add((x, y))\\n         \\n\\t\\t# count unguarded\\n        not_guarded_count = 0\\n        for i in range(m):\\n            for j in range(n):\\n                if (i,j) not in guarded and (i, j) not in wall_set and (i, j) not in guard_set:\\n                    not_guarded_count += 1\\n        \\n        return not_guarded_count\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def countUnguarded(self, m: int, n: int, guards: List[List[int]], walls: List[List[int]]) -> int:\\n        guarded = set()\\n        guard_set = set()\\n        wall_set = set()\\n        \\n\\t\\tfor guard in guards:  guard_set.add((guard[0], guard[1]))\\n        for wall in walls: wall_set.add((wall[0], wall[1]))\\n\\t\\t\\n\\t\\t# left, right, bottom, top\\n        directions = [(1, 0), (-1, 0), (0, -1), (0, 1)]\\n\\t\\t\\n        # find all guarded\\n        for guard in guards:\\n            for dx, dy in directions:\\n                x, y = guard\\n                \\n\\t\\t\\t\\t# travel one direction\\n                while 0 <= x + dx < m and 0 <= y + dy < n:\\n                    x, y = x + dx , y + dy\\n                    if (x, y) in guard_set or (x, y) in wall_set: break\\n                    guarded.add((x, y))\\n         \\n\\t\\t# count unguarded\\n        not_guarded_count = 0\\n        for i in range(m):\\n            for j in range(n):\\n                if (i,j) not in guarded and (i, j) not in wall_set and (i, j) not in guard_set:\\n                    not_guarded_count += 1\\n        \\n        return not_guarded_count\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1994557,
                "title": "simple-commented-solution-o-m-n-easy-to-understand-c",
                "content": "```\\nclass Solution {\\npublic:\\n    //Traverse in all four directions, if possible then visit and mark them as guarded\\n        void traverse(vector<vector<int>> &mat, int i, int j) {\\n            int k;\\n            //right\\n            k = j+1;\\n            while(k < mat[0].size()) {\\n                if(mat[i][k] == 1 || mat[i][k] == 2) //If wall or guard we can\\'t go furthur\\n                    break;\\n                mat[i][k] = 3;\\n                ++k;\\n            }\\n            //left\\n            k = j-1;\\n            while(k >= 0) {\\n                if(mat[i][k] == 1 || mat[i][k] == 2) //If wall or guard we can\\'t go furthur\\n                    break;\\n                mat[i][k] = 3;\\n                --k;\\n            }\\n            \\n            //down\\n            k = i+1;\\n            while(k < mat.size()) {\\n                if(mat[k][j] == 1 || mat[k][j] == 2) //If wall or guard we can\\'t go furthur\\n                    break;\\n                mat[k][j] = 3;\\n                ++k;\\n            }\\n            \\n            //up\\n            k = i-1;\\n            while(k >= 0) {\\n                if(mat[k][j] == 1 || mat[k][j] == 2) //If wall or guard we can\\'t go furthur\\n                    break;\\n                mat[k][j] = 3;\\n                --k;\\n            }\\n        }\\n    \\n    int countUnguarded(int m, int n, vector<vector<int>>& guards, vector<vector<int>>& walls) {\\n        //0 means unoccupied\\n        //1 means guard\\n        //2 means wall\\n        //3 means guarded\\n        \\n        vector<vector<int>> mat(m, vector<int>(n, 0));\\n        \\n        //Mark all the guards\\n        for(int i = 0; i < guards.size(); ++i) {\\n            mat[guards[i][0]][guards[i][1]] = 1;\\n        }\\n        \\n        //Mark all the walls\\n        for(int i = 0; i < walls.size(); ++i) {\\n            mat[walls[i][0]][walls[i][1]] = 2;\\n        }\\n        \\n       //For each guard, try to guard cells by traversing in all four diections \\n       for(int i = 0; i < m; ++i) {\\n            for(int j = 0; j < n; ++j) {\\n                if(mat[i][j] == 1) {\\n                    traverse(mat, i, j);\\n                }\\n               \\n            } \\n        }\\n        \\n        //Count all the remaing cells, that cannot be guarded\\n        int unguarded = 0;\\n        for(int i = 0; i < m; ++i) {\\n            for(int j = 0; j < n; ++j) {\\n                if(mat[i][j] == 0) {\\n                    unguarded++;\\n                }\\n            }\\n        }\\n        \\n        return unguarded;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    //Traverse in all four directions, if possible then visit and mark them as guarded\\n        void traverse(vector<vector<int>> &mat, int i, int j) {\\n            int k;\\n            //right\\n            k = j+1;\\n            while(k < mat[0].size()) {\\n                if(mat[i][k] == 1 || mat[i][k] == 2) //If wall or guard we can\\'t go furthur\\n                    break;\\n                mat[i][k] = 3;\\n                ++k;\\n            }\\n            //left\\n            k = j-1;\\n            while(k >= 0) {\\n                if(mat[i][k] == 1 || mat[i][k] == 2) //If wall or guard we can\\'t go furthur\\n                    break;\\n                mat[i][k] = 3;\\n                --k;\\n            }\\n            \\n            //down\\n            k = i+1;\\n            while(k < mat.size()) {\\n                if(mat[k][j] == 1 || mat[k][j] == 2) //If wall or guard we can\\'t go furthur\\n                    break;\\n                mat[k][j] = 3;\\n                ++k;\\n            }\\n            \\n            //up\\n            k = i-1;\\n            while(k >= 0) {\\n                if(mat[k][j] == 1 || mat[k][j] == 2) //If wall or guard we can\\'t go furthur\\n                    break;\\n                mat[k][j] = 3;\\n                --k;\\n            }\\n        }\\n    \\n    int countUnguarded(int m, int n, vector<vector<int>>& guards, vector<vector<int>>& walls) {\\n        //0 means unoccupied\\n        //1 means guard\\n        //2 means wall\\n        //3 means guarded\\n        \\n        vector<vector<int>> mat(m, vector<int>(n, 0));\\n        \\n        //Mark all the guards\\n        for(int i = 0; i < guards.size(); ++i) {\\n            mat[guards[i][0]][guards[i][1]] = 1;\\n        }\\n        \\n        //Mark all the walls\\n        for(int i = 0; i < walls.size(); ++i) {\\n            mat[walls[i][0]][walls[i][1]] = 2;\\n        }\\n        \\n       //For each guard, try to guard cells by traversing in all four diections \\n       for(int i = 0; i < m; ++i) {\\n            for(int j = 0; j < n; ++j) {\\n                if(mat[i][j] == 1) {\\n                    traverse(mat, i, j);\\n                }\\n               \\n            } \\n        }\\n        \\n        //Count all the remaing cells, that cannot be guarded\\n        int unguarded = 0;\\n        for(int i = 0; i < m; ++i) {\\n            for(int j = 0; j < n; ++j) {\\n                if(mat[i][j] == 0) {\\n                    unguarded++;\\n                }\\n            }\\n        }\\n        \\n        return unguarded;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4090677,
                "title": "c-a-somewhat-different-approach",
                "content": "# Intuition\\nI wanted to avoid holding full grid in memory. So I look at the problem from a bit different perspective - how to check if particular square is *safe* or not.\\n\\n# Approach\\n- To speed up checks build Column and Row dictionaries for guards and walls.\\n- Values in Dictionaries hold sorted list of object\\'s coordinates.\\n- To check - find the closest guards in 4 directions by using binary search.\\n- Check if any walls block you from the found guards sight - again binary search.\\n\\n# Complexity\\n- Time complexity:\\n$O(m*n*(log(walls+guards))$\\n\\n- Space complexity:\\n$O(mn)$\\n\\n# Code\\n```\\npublic class Solution\\n{\\n    //guards positions for rows and columns\\n    Dictionary<int, List<int>> rowGuard = new();\\n    Dictionary<int, List<int>> colGuard = new();\\n    //wall positions for rows and columns\\n    Dictionary<int, List<int>> rowWall = new();\\n    Dictionary<int, List<int>> colWall = new();\\n\\n    void sort(Dictionary<int, List<int>> info)\\n    {\\n        foreach (var kv in info)\\n            kv.Value.Sort();\\n    }\\n    // fill row and column dictionaries for guards/walls\\n    void prepareDictionaries(int[][] g, Dictionary<int, List<int>> rowInfo, Dictionary<int, List<int>> colInfo)\\n    {\\n        foreach (var yx in g)\\n        {\\n            var y = yx[0];\\n            var x = yx[1];\\n\\n            rowInfo.TryAdd(y, new());\\n            rowInfo[y].Add(x);\\n\\n            colInfo.TryAdd(x, new());\\n            colInfo[x].Add(y);\\n        }\\n        sort(rowInfo);\\n        sort(colInfo);\\n    }\\n\\n    bool checkDir(int pos, List<int> guards, List<int>? walls)\\n    {\\n        // Locate nearby guards\\n        var guardIndex = ~guards.BinarySearch(pos);\\n\\n        int? leftGuard = (guardIndex > 0) ? guards[guardIndex - 1] : null;\\n        int? rightGuard = (guardIndex < guards.Count) ? guards[guardIndex] : null;\\n        // Any guard from \"left/up\" or \"right/down\" present\\n        if (leftGuard.HasValue || rightGuard.HasValue)\\n        {\\n            int leftWall = -1;\\n            int rightWall = int.MaxValue;\\n\\n            if (walls != null)\\n            {\\n                // Check if maybe theres a wall nearby\\n                var wallIndex = ~walls.BinarySearch(pos);\\n                leftWall = (wallIndex > 0) ? walls[wallIndex - 1] : -1;\\n                rightWall = (wallIndex < walls.Count) ? walls[wallIndex] : int.MaxValue;\\n            }\\n            // check if guard to the \"left\" is present and not blocked by a wall\\n            if (leftGuard.HasValue && leftGuard.Value > leftWall)\\n                return false;\\n            // check if guard to the \"right\" is present and not blocked by a wall\\n            if (rightGuard.HasValue && rightGuard.Value < rightWall)\\n                return false;\\n        }\\n        // we are in a safe cell\\n        return true;\\n    }\\n\\n    bool isSafe(int col, int row)\\n    {\\n        bool XdirOK = true;\\n        bool YDirOK = true;\\n        // If we are on top of a wall\\n        if (colWall.ContainsKey(col) && colWall[col].BinarySearch(row) >= 0)\\n            return false;\\n        // If we are on top of a guard\\n        if (colGuard.ContainsKey(col) && colGuard[col].BinarySearch(row) >= 0)\\n            return false;\\n\\n        // Check if theres a guard on current row\\n        if (rowGuard.ContainsKey(row))\\n        {\\n            // pass a wall information, if there is one\\n            XdirOK = checkDir(col, rowGuard[row], rowWall.ContainsKey(row) ? rowWall[row] : null);\\n        }\\n        // Bother checking for guard in current column only if it makes ense\\n        if (XdirOK && colGuard.ContainsKey(col))\\n        {\\n            YDirOK = checkDir(row, colGuard[col], colWall.ContainsKey(col) ? colWall[col] : null);\\n        }\\n\\n        return XdirOK && YDirOK;\\n    }\\n\\n\\n    public int CountUnguarded(int m, int n, int[][] guards, int[][] walls)\\n    {\\n        prepareDictionaries(guards, rowGuard, colGuard);\\n        prepareDictionaries(walls, rowWall, colWall);\\n\\n        int free = 0;\\n        // Just check each square is it safe\\n        for (int r = 0; r < m; r++)\\n        {\\n            for (int c = 0; c < n; c++)\\n            {\\n                if (isSafe(c, r))\\n                    free++;\\n            }\\n        }\\n\\n        return free;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#",
                    "Hash Table",
                    "Binary Search"
                ],
                "code": "```\\npublic class Solution\\n{\\n    //guards positions for rows and columns\\n    Dictionary<int, List<int>> rowGuard = new();\\n    Dictionary<int, List<int>> colGuard = new();\\n    //wall positions for rows and columns\\n    Dictionary<int, List<int>> rowWall = new();\\n    Dictionary<int, List<int>> colWall = new();\\n\\n    void sort(Dictionary<int, List<int>> info)\\n    {\\n        foreach (var kv in info)\\n            kv.Value.Sort();\\n    }\\n    // fill row and column dictionaries for guards/walls\\n    void prepareDictionaries(int[][] g, Dictionary<int, List<int>> rowInfo, Dictionary<int, List<int>> colInfo)\\n    {\\n        foreach (var yx in g)\\n        {\\n            var y = yx[0];\\n            var x = yx[1];\\n\\n            rowInfo.TryAdd(y, new());\\n            rowInfo[y].Add(x);\\n\\n            colInfo.TryAdd(x, new());\\n            colInfo[x].Add(y);\\n        }\\n        sort(rowInfo);\\n        sort(colInfo);\\n    }\\n\\n    bool checkDir(int pos, List<int> guards, List<int>? walls)\\n    {\\n        // Locate nearby guards\\n        var guardIndex = ~guards.BinarySearch(pos);\\n\\n        int? leftGuard = (guardIndex > 0) ? guards[guardIndex - 1] : null;\\n        int? rightGuard = (guardIndex < guards.Count) ? guards[guardIndex] : null;\\n        // Any guard from \"left/up\" or \"right/down\" present\\n        if (leftGuard.HasValue || rightGuard.HasValue)\\n        {\\n            int leftWall = -1;\\n            int rightWall = int.MaxValue;\\n\\n            if (walls != null)\\n            {\\n                // Check if maybe theres a wall nearby\\n                var wallIndex = ~walls.BinarySearch(pos);\\n                leftWall = (wallIndex > 0) ? walls[wallIndex - 1] : -1;\\n                rightWall = (wallIndex < walls.Count) ? walls[wallIndex] : int.MaxValue;\\n            }\\n            // check if guard to the \"left\" is present and not blocked by a wall\\n            if (leftGuard.HasValue && leftGuard.Value > leftWall)\\n                return false;\\n            // check if guard to the \"right\" is present and not blocked by a wall\\n            if (rightGuard.HasValue && rightGuard.Value < rightWall)\\n                return false;\\n        }\\n        // we are in a safe cell\\n        return true;\\n    }\\n\\n    bool isSafe(int col, int row)\\n    {\\n        bool XdirOK = true;\\n        bool YDirOK = true;\\n        // If we are on top of a wall\\n        if (colWall.ContainsKey(col) && colWall[col].BinarySearch(row) >= 0)\\n            return false;\\n        // If we are on top of a guard\\n        if (colGuard.ContainsKey(col) && colGuard[col].BinarySearch(row) >= 0)\\n            return false;\\n\\n        // Check if theres a guard on current row\\n        if (rowGuard.ContainsKey(row))\\n        {\\n            // pass a wall information, if there is one\\n            XdirOK = checkDir(col, rowGuard[row], rowWall.ContainsKey(row) ? rowWall[row] : null);\\n        }\\n        // Bother checking for guard in current column only if it makes ense\\n        if (XdirOK && colGuard.ContainsKey(col))\\n        {\\n            YDirOK = checkDir(row, colGuard[col], colWall.ContainsKey(col) ? colWall[col] : null);\\n        }\\n\\n        return XdirOK && YDirOK;\\n    }\\n\\n\\n    public int CountUnguarded(int m, int n, int[][] guards, int[][] walls)\\n    {\\n        prepareDictionaries(guards, rowGuard, colGuard);\\n        prepareDictionaries(walls, rowWall, colWall);\\n\\n        int free = 0;\\n        // Just check each square is it safe\\n        for (int r = 0; r < m; r++)\\n        {\\n            for (int c = 0; c < n; c++)\\n            {\\n                if (isSafe(c, r))\\n                    free++;\\n            }\\n        }\\n\\n        return free;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4085417,
                "title": "27-lines-easy-to-understand",
                "content": "# Intuition\\nThe usual walk in 4 directions from each guard and mark space as guarded.\\n\\nHowever, can optimise time by stopping the walk when you encounter a guard (and of course wall).\\n\\nTo avoid the final extra iteration over the space grid to count unguarded cells, can include a counter of empty space that is decremented as spaces are marked as guarded.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def countUnguarded(self, m: int, n: int, guards: List[List[int]], walls: List[List[int]]) -> int:\\n        space = [[\\'e\\' for _ in range(n)] for _ in range(m)]\\n        empty = m*n - len(guards) - len(walls)\\n        for guard in guards:\\n            space[guard[0]][guard[1]] = \\'o\\'\\n\\n        for wall in walls:\\n            space[wall[0]][wall[1]] = \\'o\\'\\n\\n        def walk(r, c):\\n            for dx, dy in [(0, -1), (0, 1), (1, 0), (-1, 0)]:\\n                row, col = r + dy, c + dx\\n\\n                while row >= 0 and row < m and col >= 0 and col < n:\\n                    if space[row][col] == \\'e\\':\\n                        space[row][col] = \\'g\\'\\n                        nonlocal empty\\n                        empty -= 1\\n                    elif space[row][col] == \\'o\\':\\n                        break\\n                    row, col = row + dy, col + dx\\n\\n        for guard in guards:\\n            walk(guard[0], guard[1])\\n\\n        return empty\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def countUnguarded(self, m: int, n: int, guards: List[List[int]], walls: List[List[int]]) -> int:\\n        space = [[\\'e\\' for _ in range(n)] for _ in range(m)]\\n        empty = m*n - len(guards) - len(walls)\\n        for guard in guards:\\n            space[guard[0]][guard[1]] = \\'o\\'\\n\\n        for wall in walls:\\n            space[wall[0]][wall[1]] = \\'o\\'\\n\\n        def walk(r, c):\\n            for dx, dy in [(0, -1), (0, 1), (1, 0), (-1, 0)]:\\n                row, col = r + dy, c + dx\\n\\n                while row >= 0 and row < m and col >= 0 and col < n:\\n                    if space[row][col] == \\'e\\':\\n                        space[row][col] = \\'g\\'\\n                        nonlocal empty\\n                        empty -= 1\\n                    elif space[row][col] == \\'o\\':\\n                        break\\n                    row, col = row + dy, col + dx\\n\\n        for guard in guards:\\n            walk(guard[0], guard[1])\\n\\n        return empty\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4044107,
                "title": "a-good-greedy-question-c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int countUnguarded(int m, int n, vector<vector<int>>& guards, vector<vector<int>>& walls) {\\n        int count = 0;\\n        vector<vector<int>>grid(m,vector<int>(n,0));\\n        for(int i=0;i<walls.size();i++){\\n            int r =  walls[i][0];\\n            int c = walls[i][1];\\n            grid[r][c] = 2;\\n        }\\n        for(int i=0;i<guards.size();i++){\\n            int r = guards[i][0];\\n            int c = guards[i][1];\\n            grid[r][c] = 1;\\n        }\\n        for(int i=0;i<guards.size();i++){\\n            int r = guards[i][0];\\n            int c = guards[i][1];\\n            int r1 = r,c1 = c;\\n            c--;\\n            while(c>=0 && grid[r][c] !=2  && grid[r][c]!=1){\\n                grid[r][c] = -1;\\n                c--;\\n            }\\n            r = r1,c = c1;\\n            c++;\\n            while(c<n && grid[r][c] !=2   && grid[r][c]!=1){\\n                grid[r][c] = -1;\\n                c++;\\n            }\\n            r = r1,c = c1;\\n            r--;\\n            while(r>=0 && grid[r][c] != 2 && grid[r][c]!=1){\\n                grid[r][c] = -1;\\n                r--;\\n            }\\n            r = r1,c = c1;\\n            r++;\\n            while(r<m && grid[r][c] != 2 && grid[r][c]!=1){\\n                grid[r][c] = -1;\\n                r++;\\n            }\\n        }\\n        for(int i=0;i<m;i++){\\n            for(int j=0;j<n;j++){\\n                if(grid[i][j] == 0)count++;\\n\\n              //  cout<<grid[i][j]<<\" \";\\n            }\\n         //   cout<<endl;\\n        }\\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int countUnguarded(int m, int n, vector<vector<int>>& guards, vector<vector<int>>& walls) {\\n        int count = 0;\\n        vector<vector<int>>grid(m,vector<int>(n,0));\\n        for(int i=0;i<walls.size();i++){\\n            int r =  walls[i][0];\\n            int c = walls[i][1];\\n            grid[r][c] = 2;\\n        }\\n        for(int i=0;i<guards.size();i++){\\n            int r = guards[i][0];\\n            int c = guards[i][1];\\n            grid[r][c] = 1;\\n        }\\n        for(int i=0;i<guards.size();i++){\\n            int r = guards[i][0];\\n            int c = guards[i][1];\\n            int r1 = r,c1 = c;\\n            c--;\\n            while(c>=0 && grid[r][c] !=2  && grid[r][c]!=1){\\n                grid[r][c] = -1;\\n                c--;\\n            }\\n            r = r1,c = c1;\\n            c++;\\n            while(c<n && grid[r][c] !=2   && grid[r][c]!=1){\\n                grid[r][c] = -1;\\n                c++;\\n            }\\n            r = r1,c = c1;\\n            r--;\\n            while(r>=0 && grid[r][c] != 2 && grid[r][c]!=1){\\n                grid[r][c] = -1;\\n                r--;\\n            }\\n            r = r1,c = c1;\\n            r++;\\n            while(r<m && grid[r][c] != 2 && grid[r][c]!=1){\\n                grid[r][c] = -1;\\n                r++;\\n            }\\n        }\\n        for(int i=0;i<m;i++){\\n            for(int j=0;j<n;j++){\\n                if(grid[i][j] == 0)count++;\\n\\n              //  cout<<grid[i][j]<<\" \";\\n            }\\n         //   cout<<endl;\\n        }\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 4015711,
                "title": "direction-based-dfs-cpp",
                "content": "## Intuition\\nThe intuition behind the solution is to use DFS to mark all the cells that are guarded by the guards and then count the unguarded cells.\\n\\n## Approach\\n1. Initialize a 2D grid `dp` with dimensions `m x n` and initialize all cells to -1. This grid will be used to mark cells that are guarded by guards.\\n\\n2. Iterate through the `guards` array and set the corresponding cells in the `dp` grid to 0 to mark them as guarded.\\n\\n3. Iterate through the `walls` array and set the corresponding cells in the `dp` grid to 0 to mark them as well. Walls also obstruct the view.\\n\\n4. For each guard position in `guards`, perform DFS in all four cardinal directions (north, south, east, and west) to mark all the cells that can be seen by that guard. The DFS function `dfs` takes the guard\\'s position and direction as parameters.\\n\\n5. After marking all the cells that are guarded, count the number of unmarked cells (cells with -1 in the `dp` grid) and return the count as the result.\\n\\n## Complexity\\n- Time complexity: The DFS traversal visits each cell at most once, so the time complexity is O(m * n), where m is the number of rows and n is the number of columns in the grid.\\n- Space complexity: The space complexity is O(m * n) due to the `dp` grid used to mark cells.\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    void dfs(int i,int j,int m,int n,vector<vector<int>>&grid,int d){\\n        if(i<0 or j<0 or j>=n or i>=m or grid[i][j]==0) return;\\n        grid[i][j]=1;\\n        if(d==1) dfs(i+1,j,m,n,grid,1);\\n        else if(d==2) dfs(i-1,j,m,n,grid,2);\\n        else if(d==3) dfs(i,j+1,m,n,grid,3);\\n        else dfs(i,j-1,m,n,grid,4);\\n    }\\n    int countUnguarded(int m, int n, vector<vector<int>>& g, vector<vector<int>>& w) {\\n        vector<vector<int>>dp(m,vector<int>(n,-1));\\n        int ans=0;\\n        for(auto i:g) dp[i[0]][i[1]]=0;\\n        for(auto i:w) dp[i[0]][i[1]]=0;\\n        for(auto i:g){\\n            int s=i[0];\\n            int e=i[1];\\n            dfs(s+1,e,m,n,dp,1);\\n            dfs(s-1,e,m,n,dp,2);\\n            dfs(s,e+1,m,n,dp,3);\\n            dfs(s,e-1,m,n,dp,4);\\n        }\\n        for(auto i:dp) for(auto j:i) if(j==-1) ans++;\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void dfs(int i,int j,int m,int n,vector<vector<int>>&grid,int d){\\n        if(i<0 or j<0 or j>=n or i>=m or grid[i][j]==0) return;\\n        grid[i][j]=1;\\n        if(d==1) dfs(i+1,j,m,n,grid,1);\\n        else if(d==2) dfs(i-1,j,m,n,grid,2);\\n        else if(d==3) dfs(i,j+1,m,n,grid,3);\\n        else dfs(i,j-1,m,n,grid,4);\\n    }\\n    int countUnguarded(int m, int n, vector<vector<int>>& g, vector<vector<int>>& w) {\\n        vector<vector<int>>dp(m,vector<int>(n,-1));\\n        int ans=0;\\n        for(auto i:g) dp[i[0]][i[1]]=0;\\n        for(auto i:w) dp[i[0]][i[1]]=0;\\n        for(auto i:g){\\n            int s=i[0];\\n            int e=i[1];\\n            dfs(s+1,e,m,n,dp,1);\\n            dfs(s-1,e,m,n,dp,2);\\n            dfs(s,e+1,m,n,dp,3);\\n            dfs(s,e-1,m,n,dp,4);\\n        }\\n        for(auto i:dp) for(auto j:i) if(j==-1) ans++;\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4015258,
                "title": "c-bit-manipulation",
                "content": "# Intuition\\nFirst we need init matrix with information about guards and walls. First we need insert walls there. Then we may insert guards one by one and after every insertion, mark cells guarded until we met another wall or guard.\\nTo avoid TLE we may stop marking cell guarded in this row or column if it was already marked guarded by another guard cell in the same row or column.\\nTo mark that the current cell is guarded by a guard in its row, I set its `1`-bit, to mark cell guarded by a column I used another bit, `2`.\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int countUnguarded(int m, int n, vector<vector<int>>& guards, vector<vector<int>>& walls) {\\n        auto mat = vector(m, vector<int>(n, 0));\\n        for (const auto& w : walls)\\n            mat[w[0]][w[1]] = -1;\\n        for (const auto& g : guards) {\\n            mat[g[0]][g[1]] = -1;\\n            for (int i = g[0] - 1; i >= 0 && !(mat[i][g[1]] & 1); --i)\\n                mat[i][g[1]] |= 1;\\n            for (int i = g[0] + 1; i < m && !(mat[i][g[1]] & 1); ++i)\\n                mat[i][g[1]] |= 1;\\n            for (int i = g[1] - 1; i >= 0  && !(mat[g[0]][i] & 2); --i)\\n                mat[g[0]][i] |= 2;\\n            for (int i = g[1] + 1; i < n  && !(mat[g[0]][i] & 2); ++i)\\n                mat[g[0]][i] |= 2;\\n        }\\n        return accumulate(mat.begin(), mat.end(), 0, [](int r, const auto& v) {\\n            return r + count(v.begin(), v.end(), 0);\\n        });\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int countUnguarded(int m, int n, vector<vector<int>>& guards, vector<vector<int>>& walls) {\\n        auto mat = vector(m, vector<int>(n, 0));\\n        for (const auto& w : walls)\\n            mat[w[0]][w[1]] = -1;\\n        for (const auto& g : guards) {\\n            mat[g[0]][g[1]] = -1;\\n            for (int i = g[0] - 1; i >= 0 && !(mat[i][g[1]] & 1); --i)\\n                mat[i][g[1]] |= 1;\\n            for (int i = g[0] + 1; i < m && !(mat[i][g[1]] & 1); ++i)\\n                mat[i][g[1]] |= 1;\\n            for (int i = g[1] - 1; i >= 0  && !(mat[g[0]][i] & 2); --i)\\n                mat[g[0]][i] |= 2;\\n            for (int i = g[1] + 1; i < n  && !(mat[g[0]][i] & 2); ++i)\\n                mat[g[0]][i] |= 2;\\n        }\\n        return accumulate(mat.begin(), mat.end(), 0, [](int r, const auto& v) {\\n            return r + count(v.begin(), v.end(), 0);\\n        });\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4005574,
                "title": "better-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n$$O(mn)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n$$O(mn)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int countUnguarded(int m, int n, vector<vector<int>>& guards, vector<vector<int>>& walls) \\n    {\\n        vector<vector<Units>> objects (m, vector<Units>(n, Units::GREEN));\\n        vector<vector<Units>> grids (m, vector<Units>(n, Units::GREEN));\\n\\n        for (const auto& aWall : walls) {\\n            objects[aWall[0]][aWall[1]] = Units::WALL;\\n        }\\n\\n        for (const auto& aGuard : guards) {\\n            objects[aGuard[0]][aGuard[1]] = Units::GUARD;\\n        }\\n\\n        for (int i = 0; i < m; ++i) {\\n            Units lastCell = Units::GREEN;\\n            for (int j = 0; j < n; ++j)\\n            {\\n                recordOrFill(objects[i][j], lastCell, grids[i][j]);\\n            }\\n\\n            lastCell = Units::GREEN;\\n            for (int j = n - 1; j >= 0; --j)\\n            {\\n                recordOrFill(objects[i][j], lastCell, grids[i][j]);\\n            }\\n        }\\n\\n        for (int j = 0; j < n; ++j) {\\n            Units lastCell = Units::GREEN;\\n            for (int i = 0; i < m; ++i)\\n            {\\n                recordOrFill(objects[i][j], lastCell, grids[i][j]);\\n            }\\n\\n            lastCell = Units::GREEN;\\n            for (int i = m - 1; i >= 0; --i)\\n            {\\n                recordOrFill(objects[i][j], lastCell, grids[i][j]);\\n            }\\n        }\\n\\n        int result = 0;\\n        for (int i = 0; i < m; ++i) {\\n            for (int j = 0; j < n; ++j)\\n            {\\n                if (objects[i][j] == Units::GREEN && grids[i][j] == Units::GREEN)\\n                    ++result;\\n            }\\n        }\\n\\n        return result;\\n    }\\n\\nprivate:\\n    enum class Units : unsigned char {\\n        GREEN = 0,\\n        RED,\\n        GUARD,\\n        WALL\\n    };\\n\\n    void recordOrFill(Units currCell, Units& lastCell, Units& gridCell) {\\n        if (currCell == Units::GUARD)\\n            lastCell = Units::GUARD;\\n        else if (currCell == Units::WALL)\\n            lastCell = Units::GREEN;\\n\\n        if (lastCell == Units::GUARD)\\n            gridCell = Units::GUARD;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int countUnguarded(int m, int n, vector<vector<int>>& guards, vector<vector<int>>& walls) \\n    {\\n        vector<vector<Units>> objects (m, vector<Units>(n, Units::GREEN));\\n        vector<vector<Units>> grids (m, vector<Units>(n, Units::GREEN));\\n\\n        for (const auto& aWall : walls) {\\n            objects[aWall[0]][aWall[1]] = Units::WALL;\\n        }\\n\\n        for (const auto& aGuard : guards) {\\n            objects[aGuard[0]][aGuard[1]] = Units::GUARD;\\n        }\\n\\n        for (int i = 0; i < m; ++i) {\\n            Units lastCell = Units::GREEN;\\n            for (int j = 0; j < n; ++j)\\n            {\\n                recordOrFill(objects[i][j], lastCell, grids[i][j]);\\n            }\\n\\n            lastCell = Units::GREEN;\\n            for (int j = n - 1; j >= 0; --j)\\n            {\\n                recordOrFill(objects[i][j], lastCell, grids[i][j]);\\n            }\\n        }\\n\\n        for (int j = 0; j < n; ++j) {\\n            Units lastCell = Units::GREEN;\\n            for (int i = 0; i < m; ++i)\\n            {\\n                recordOrFill(objects[i][j], lastCell, grids[i][j]);\\n            }\\n\\n            lastCell = Units::GREEN;\\n            for (int i = m - 1; i >= 0; --i)\\n            {\\n                recordOrFill(objects[i][j], lastCell, grids[i][j]);\\n            }\\n        }\\n\\n        int result = 0;\\n        for (int i = 0; i < m; ++i) {\\n            for (int j = 0; j < n; ++j)\\n            {\\n                if (objects[i][j] == Units::GREEN && grids[i][j] == Units::GREEN)\\n                    ++result;\\n            }\\n        }\\n\\n        return result;\\n    }\\n\\nprivate:\\n    enum class Units : unsigned char {\\n        GREEN = 0,\\n        RED,\\n        GUARD,\\n        WALL\\n    };\\n\\n    void recordOrFill(Units currCell, Units& lastCell, Units& gridCell) {\\n        if (currCell == Units::GUARD)\\n            lastCell = Units::GUARD;\\n        else if (currCell == Units::WALL)\\n            lastCell = Units::GREEN;\\n\\n        if (lastCell == Units::GUARD)\\n            gridCell = Units::GUARD;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3963756,
                "title": "c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n public:\\n  int countUnguarded(int m, int n, vector<vector<int>>& guards,\\n                     vector<vector<int>>& walls) {\\n    int ans = 0;\\n    vector<vector<char>> grid(m, vector<char>(n));\\n    vector<vector<char>> left(m, vector<char>(n));\\n    vector<vector<char>> right(m, vector<char>(n));\\n    vector<vector<char>> up(m, vector<char>(n));\\n    vector<vector<char>> down(m, vector<char>(n));\\n\\n    for (const vector<int>& guard : guards)\\n      grid[guard[0]][guard[1]] = \\'G\\';\\n\\n    for (const vector<int>& wall : walls)\\n      grid[wall[0]][wall[1]] = \\'W\\';\\n\\n    for (int i = 0; i < m; ++i) {\\n      char lastCell = 0;\\n      for (int j = 0; j < n; ++j)\\n        recordOrFill(grid[i][j], lastCell, left[i][j]);\\n      lastCell = 0;\\n      for (int j = n - 1; j >= 0; --j)\\n        recordOrFill(grid[i][j], lastCell, right[i][j]);\\n    }\\n\\n    for (int j = 0; j < n; ++j) {\\n      char lastCell = 0;\\n      for (int i = 0; i < m; ++i)\\n        recordOrFill(grid[i][j], lastCell, up[i][j]);\\n      lastCell = 0;\\n      for (int i = m - 1; i >= 0; --i)\\n        recordOrFill(grid[i][j], lastCell, down[i][j]);\\n    }\\n\\n    for (int i = 0; i < m; ++i)\\n      for (int j = 0; j < n; ++j)\\n        if (grid[i][j] == 0 && left[i][j] != \\'G\\' && right[i][j] != \\'G\\' &&\\n            up[i][j] != \\'G\\' && down[i][j] != \\'G\\')\\n          ++ans;\\n\\n    return ans;\\n  }\\n\\n private:\\n  void recordOrFill(char currCell, char& lastCell, char& infoCell) {\\n    if (currCell == \\'G\\' || currCell == \\'W\\')\\n      lastCell = currCell;\\n    else\\n      infoCell = lastCell;\\n  }\\n};\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\n public:\\n  int countUnguarded(int m, int n, vector<vector<int>>& guards,\\n                     vector<vector<int>>& walls) {\\n    int ans = 0;\\n    vector<vector<char>> grid(m, vector<char>(n));\\n    vector<vector<char>> left(m, vector<char>(n));\\n    vector<vector<char>> right(m, vector<char>(n));\\n    vector<vector<char>> up(m, vector<char>(n));\\n    vector<vector<char>> down(m, vector<char>(n));\\n\\n    for (const vector<int>& guard : guards)\\n      grid[guard[0]][guard[1]] = \\'G\\';\\n\\n    for (const vector<int>& wall : walls)\\n      grid[wall[0]][wall[1]] = \\'W\\';\\n\\n    for (int i = 0; i < m; ++i) {\\n      char lastCell = 0;\\n      for (int j = 0; j < n; ++j)\\n        recordOrFill(grid[i][j], lastCell, left[i][j]);\\n      lastCell = 0;\\n      for (int j = n - 1; j >= 0; --j)\\n        recordOrFill(grid[i][j], lastCell, right[i][j]);\\n    }\\n\\n    for (int j = 0; j < n; ++j) {\\n      char lastCell = 0;\\n      for (int i = 0; i < m; ++i)\\n        recordOrFill(grid[i][j], lastCell, up[i][j]);\\n      lastCell = 0;\\n      for (int i = m - 1; i >= 0; --i)\\n        recordOrFill(grid[i][j], lastCell, down[i][j]);\\n    }\\n\\n    for (int i = 0; i < m; ++i)\\n      for (int j = 0; j < n; ++j)\\n        if (grid[i][j] == 0 && left[i][j] != \\'G\\' && right[i][j] != \\'G\\' &&\\n            up[i][j] != \\'G\\' && down[i][j] != \\'G\\')\\n          ++ans;\\n\\n    return ans;\\n  }\\n\\n private:\\n  void recordOrFill(char currCell, char& lastCell, char& infoCell) {\\n    if (currCell == \\'G\\' || currCell == \\'W\\')\\n      lastCell = currCell;\\n    else\\n      infoCell = lastCell;\\n  }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3890427,
                "title": "solution-using-simulation",
                "content": "```\\nclass Solution {\\npublic:\\n    int countUnguarded(int m, int n, vector<vector<int>>& g, vector<vector<int>>& w) {\\n        vector<vector<int>> grid( m, vector<int>(n , 0));\\n        // cantSee =0 , g = 1 , w =2 ,CanSee =3 \\n\\n        for( int i =0; i<g.size()  ; i++){\\n            grid[g[i][0]][g[i][1]] =1;\\n        }\\n         for( int i =0; i<w.size()  ; i++){\\n            grid[w[i][0]][w[i][1]] =2;\\n        }\\n        for( int ii =0; ii< g.size(); ii++)\\n        {\\n            int x =g[ii][0] , y = g[ii][1];\\n            for( int i =x-1 ; i >=0 ; i--){\\n                if( grid[i][y]==2 or grid[i][y]==1)break;\\n                grid[i][y] =3;\\n            }\\n             for( int i =x+1 ; i <m ; i++){\\n                if( grid[i][y]==2 or grid[i][y]==1)break;\\n                grid[i][y] =3;\\n            }\\n            for( int i =y-1 ; i >=0 ; i--){\\n                if( grid[x][i]==2 or grid[x][i]==1)break;\\n                grid[x][i] =3;\\n            }\\n             for( int i =y+1 ; i <n ; i++){\\n                if( grid[x][i]==2 or grid[x][i]==1)break;\\n                grid[x][i] =3;\\n            }\\n        }\\n\\n\\n    int ans =0;\\n    for( int i =0; i <  m ;i ++){\\n        for( int j =0; j < n ; j++){\\n            // cout<<grid[i][j]<<\" \";\\n            if( grid[i][j]==0) ans ++;\\n        }\\n        // cout<<endl;\\n    }\\n    return ans ;    \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Matrix",
                    "Simulation"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int countUnguarded(int m, int n, vector<vector<int>>& g, vector<vector<int>>& w) {\\n        vector<vector<int>> grid( m, vector<int>(n , 0));\\n        // cantSee =0 , g = 1 , w =2 ,CanSee =3 \\n\\n        for( int i =0; i<g.size()  ; i++){\\n            grid[g[i][0]][g[i][1]] =1;\\n        }\\n         for( int i =0; i<w.size()  ; i++){\\n            grid[w[i][0]][w[i][1]] =2;\\n        }\\n        for( int ii =0; ii< g.size(); ii++)\\n        {\\n            int x =g[ii][0] , y = g[ii][1];\\n            for( int i =x-1 ; i >=0 ; i--){\\n                if( grid[i][y]==2 or grid[i][y]==1)break;\\n                grid[i][y] =3;\\n            }\\n             for( int i =x+1 ; i <m ; i++){\\n                if( grid[i][y]==2 or grid[i][y]==1)break;\\n                grid[i][y] =3;\\n            }\\n            for( int i =y-1 ; i >=0 ; i--){\\n                if( grid[x][i]==2 or grid[x][i]==1)break;\\n                grid[x][i] =3;\\n            }\\n             for( int i =y+1 ; i <n ; i++){\\n                if( grid[x][i]==2 or grid[x][i]==1)break;\\n                grid[x][i] =3;\\n            }\\n        }\\n\\n\\n    int ans =0;\\n    for( int i =0; i <  m ;i ++){\\n        for( int j =0; j < n ; j++){\\n            // cout<<grid[i][j]<<\" \";\\n            if( grid[i][j]==0) ans ++;\\n        }\\n        // cout<<endl;\\n    }\\n    return ans ;    \\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3809864,
                "title": "python-easy-solution-using-dfs-beats-100",
                "content": "# Code\\n```\\nclass Solution:\\n    def countUnguarded(self, m: int, n: int, guards: List[List[int]], walls: List[List[int]]) -> int:\\n        visited = [[0] * n for _ in range(m)]\\n        for i, j in walls:\\n            visited[i][j] = -1\\n        for i, j in guards:\\n            visited[i][j] = -1\\n        def search(i, j):\\n            ans = 0\\n            #up\\n            r = i - 1\\n            while r >= 0 and visited[r][j] != -1:\\n                if visited[r][j] == 0:\\n                    visited[r][j] = 1\\n                    ans += 1\\n                r -= 1\\n            #down\\n            r = i + 1\\n            while r < m and visited[r][j] != -1:\\n                if visited[r][j] == 0:\\n                    visited[r][j] = 1\\n                    ans += 1\\n                r += 1\\n            #left\\n            c = j - 1\\n            while c >= 0 and visited[i][c] != -1:\\n                if visited[i][c] == 0:\\n                    visited[i][c] = 1\\n                    ans += 1\\n                c -= 1\\n            #right\\n            c = j + 1\\n            while c < n and visited[i][c] != -1:\\n                if visited[i][c] == 0:\\n                    visited[i][c] = 1\\n                    ans += 1\\n                c += 1\\n            return ans\\n        ans = m*n\\n        for i, j in guards:\\n            ans -= search(i, j)\\n        return ans - len(guards) - len(walls) \\n\\n\\n```",
                "solutionTags": [
                    "Python3",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution:\\n    def countUnguarded(self, m: int, n: int, guards: List[List[int]], walls: List[List[int]]) -> int:\\n        visited = [[0] * n for _ in range(m)]\\n        for i, j in walls:\\n            visited[i][j] = -1\\n        for i, j in guards:\\n            visited[i][j] = -1\\n        def search(i, j):\\n            ans = 0\\n            #up\\n            r = i - 1\\n            while r >= 0 and visited[r][j] != -1:\\n                if visited[r][j] == 0:\\n                    visited[r][j] = 1\\n                    ans += 1\\n                r -= 1\\n            #down\\n            r = i + 1\\n            while r < m and visited[r][j] != -1:\\n                if visited[r][j] == 0:\\n                    visited[r][j] = 1\\n                    ans += 1\\n                r += 1\\n            #left\\n            c = j - 1\\n            while c >= 0 and visited[i][c] != -1:\\n                if visited[i][c] == 0:\\n                    visited[i][c] = 1\\n                    ans += 1\\n                c -= 1\\n            #right\\n            c = j + 1\\n            while c < n and visited[i][c] != -1:\\n                if visited[i][c] == 0:\\n                    visited[i][c] = 1\\n                    ans += 1\\n                c += 1\\n            return ans\\n        ans = m*n\\n        for i, j in guards:\\n            ans -= search(i, j)\\n        return ans - len(guards) - len(walls) \\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3714076,
                "title": "o-n-m-2",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\nHere for every cell i will define two types of scans up-down scan (zero) and left-right scan (one)\\n\\nThis way i will tend to reduce the redendency.\\n# Complexity\\n- Time complexity:O(2mn)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(2mn)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int countUnguarded(int m, int n, vector<vector<int>>& guards, vector<vector<int>>& walls) {\\n        map<pair<int,int>,bool>mp;\\n        //mapping coordinates for walls;\\n        for(auto e:walls){\\n            mp[{e[0],e[1]}] = true;\\n        }\\n\\n        //make a vis array of m*n*2;\\n        //the state 0 is for up-down explore and 1 is for left-right explore;\\n        bool vis[m][n][2];\\n        \\n        memset(vis,false,sizeof(vis));\\n        for(auto e:guards){\\n            for(int i = 0;i<2;i++){\\n                int x = e[0],y = e[1];\\n                if(vis[x][y][i])continue;\\n                //if i == 1  then explore possible left-right;\\n                //if i == 0 then explore possible up-down;\\n                if(i == 0){\\n                    vis[x][y][i] = true;\\n                    for(int k = x - 1;k>=0;k--){\\n                        if(mp[{k,y}])break;\\n                        vis[k][y][i] = true;\\n                    }\\n                    for(int k = x + 1;k<m;k++){\\n                        if(mp[{k,y}])break;\\n                        vis[k][y][i] = true;\\n                    }\\n                }\\n                else{\\n                    vis[x][y][i] = true;\\n                    for(int k = y - 1;k>=0;k--){\\n                        if(mp[{x,k}])break;\\n                        vis[x][k][i] = true;\\n                    }\\n                    for(int k = y + 1;k<n;k++){\\n                        if(mp[{x,k}])break;\\n                        vis[x][k][i] = true;\\n                    }\\n                }\\n            }\\n        }\\n        int ans = 0;\\n\\n        for(int i = 0;i<m;i++){\\n            for(int j = 0;j<n;j++){\\n                if(mp[{i,j}])continue;\\n                if(!(vis[i][j][0] || vis[i][j][1]))ans++;\\n            }\\n        }\\n        return ans;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int countUnguarded(int m, int n, vector<vector<int>>& guards, vector<vector<int>>& walls) {\\n        map<pair<int,int>,bool>mp;\\n        //mapping coordinates for walls;\\n        for(auto e:walls){\\n            mp[{e[0],e[1]}] = true;\\n        }\\n\\n        //make a vis array of m*n*2;\\n        //the state 0 is for up-down explore and 1 is for left-right explore;\\n        bool vis[m][n][2];\\n        \\n        memset(vis,false,sizeof(vis));\\n        for(auto e:guards){\\n            for(int i = 0;i<2;i++){\\n                int x = e[0],y = e[1];\\n                if(vis[x][y][i])continue;\\n                //if i == 1  then explore possible left-right;\\n                //if i == 0 then explore possible up-down;\\n                if(i == 0){\\n                    vis[x][y][i] = true;\\n                    for(int k = x - 1;k>=0;k--){\\n                        if(mp[{k,y}])break;\\n                        vis[k][y][i] = true;\\n                    }\\n                    for(int k = x + 1;k<m;k++){\\n                        if(mp[{k,y}])break;\\n                        vis[k][y][i] = true;\\n                    }\\n                }\\n                else{\\n                    vis[x][y][i] = true;\\n                    for(int k = y - 1;k>=0;k--){\\n                        if(mp[{x,k}])break;\\n                        vis[x][k][i] = true;\\n                    }\\n                    for(int k = y + 1;k<n;k++){\\n                        if(mp[{x,k}])break;\\n                        vis[x][k][i] = true;\\n                    }\\n                }\\n            }\\n        }\\n        int ans = 0;\\n\\n        for(int i = 0;i<m;i++){\\n            for(int j = 0;j<n;j++){\\n                if(mp[{i,j}])continue;\\n                if(!(vis[i][j][0] || vis[i][j][1]))ans++;\\n            }\\n        }\\n        return ans;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3583883,
                "title": "python-solution",
                "content": "\\n# Code\\n```\\nclass Solution:\\n    def countUnguarded(self, m: int, n: int, guards: List[List[int]], walls: List[List[int]]) -> int:\\n        import numpy as np\\n        self.matrix = [[0 for i in range(n)] for j in range(m)]\\n        wall_set = set()\\n        for a,b in walls:\\n            wall_set.add((a,b))\\n        @cache\\n        def dfs(i,j, flag, direct):\\n            if i<0 or j<0 or i>=m or j>=n:\\n                return \\n            if flag == False:\\n\\n                if (i,j) in wall_set:\\n                    self.matrix[i][j] = 1\\n                    flag = True\\n                else:\\n                    self.matrix[i][j] = 1\\n                    if direct == \\'up\\':\\n                        dfs(i-1,j, flag, direct)\\n                    if direct == \\'left\\':\\n                        dfs(i,j-1, flag, direct)\\n                    if direct == \\'right\\':\\n                        dfs(i,j+1, flag, direct)\\n                    if direct == \\'down\\':\\n                        dfs(i+1,j, flag, direct)\\n\\n            else:\\n                return \\n            return \\n        \\n        for r, c in guards:\\n            up = dfs(r,c, False, \\'up\\')\\n            left = dfs(r,c, False, \\'left\\')\\n            right = dfs(r,c, False, \\'right\\')\\n            down = dfs(r,c, False, \\'down\\')\\n\\n        c=0\\n        for i in range(len(self.matrix)):\\n            for j in range(len(self.matrix[0])):\\n                if (i,j) in wall_set:\\n                    continue\\n                if self.matrix[i][j] == 0:\\n                    c+=1\\n        return c\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def countUnguarded(self, m: int, n: int, guards: List[List[int]], walls: List[List[int]]) -> int:\\n        import numpy as np\\n        self.matrix = [[0 for i in range(n)] for j in range(m)]\\n        wall_set = set()\\n        for a,b in walls:\\n            wall_set.add((a,b))\\n        @cache\\n        def dfs(i,j, flag, direct):\\n            if i<0 or j<0 or i>=m or j>=n:\\n                return \\n            if flag == False:\\n\\n                if (i,j) in wall_set:\\n                    self.matrix[i][j] = 1\\n                    flag = True\\n                else:\\n                    self.matrix[i][j] = 1\\n                    if direct == \\'up\\':\\n                        dfs(i-1,j, flag, direct)\\n                    if direct == \\'left\\':\\n                        dfs(i,j-1, flag, direct)\\n                    if direct == \\'right\\':\\n                        dfs(i,j+1, flag, direct)\\n                    if direct == \\'down\\':\\n                        dfs(i+1,j, flag, direct)\\n\\n            else:\\n                return \\n            return \\n        \\n        for r, c in guards:\\n            up = dfs(r,c, False, \\'up\\')\\n            left = dfs(r,c, False, \\'left\\')\\n            right = dfs(r,c, False, \\'right\\')\\n            down = dfs(r,c, False, \\'down\\')\\n\\n        c=0\\n        for i in range(len(self.matrix)):\\n            for j in range(len(self.matrix[0])):\\n                if (i,j) in wall_set:\\n                    continue\\n                if self.matrix[i][j] == 0:\\n                    c+=1\\n        return c\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3579998,
                "title": "c-using-specific-direction-traversal",
                "content": "# Intuition\\nThink in terms of blocked cells(Guard facing another guard or any wall).\\n\\n# Approach\\nRun BFS from any guard in a specific direction(up,down,right,left) until another blocked cell is faced.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(M . N + guard.length . log(map.size()))\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(N*M)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<pair<int,int>>traverse = {{-1,0},{0,1},{0,-1},{1,0}};\\n    bool isValid(int a,int b, int m,int n,map<pair<int,int>,int>&w,map<pair<int,int>,int>&v){\\n        return a>=0 and b>=0 and a<m and b<n and w.find({a,b})==w.end() and v.find({a,b})==v.end();\\n        \\n    }\\n\\n    int countUnguarded(int m, int n, vector<vector<int>>& guards, vector<vector<int>>& walls) {\\n        vector<vector<bool>>vis(m,vector<bool>(n,false));\\n        pair<int,int> i = traverse[0], j = traverse[1];\\n        pair<int,int> x = traverse[2], y = traverse[3];\\n        map<pair<int,int>,int>w,v;\\n        for(auto i:walls){\\n           w[{i[0],i[1]}]++;\\n        }\\n        for(auto i:guards){\\n           w[{i[0],i[1]}]++;\\n        }\\n        for(auto c:guards){\\n            vis[c[0]][c[1]] = true;\\n        }\\n        for(auto c:walls){\\n            vis[c[0]][c[1]] = true;\\n        }\\n        for(auto c:guards){\\n            int a = i.first+c[0], b = i.second+c[1];\\n            while(isValid(a,b,m,n,w,v)){\\n            vis[a][b] = true;\\n            a += i.first, b+= i.second;\\n            \\n            }\\n             a = j.first+c[0], b = j.second+c[1];\\n            while(isValid(a,b,m,n,w,v)){\\n            vis[a][b] = true;\\n            a += j.first, b+= j.second;\\n            \\n            }\\n             a = x.first+c[0], b = x.second+c[1];\\n            while(isValid(a,b,m,n,w,v)){\\n                vis[a][b] = true;\\n            a += x.first, b+= x.second;\\n           \\n            }\\n             a = y.first+c[0], b = y.second+c[1];\\n            while(isValid(a,b,m,n,w,v)){\\n                vis[a][b] = true;\\n            a += y.first, b+= y.second;\\n            \\n            }\\n        }\\n        int ans = 0;\\n        for(int i=0;i<m;++i){\\n            for(int j=0;j<n;++j){\\n                if(!vis[i][j]){ans++;}\\n            }\\n        }\\n        return ans;\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Hash Table",
                    "Breadth-First Search",
                    "Brainteaser"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<pair<int,int>>traverse = {{-1,0},{0,1},{0,-1},{1,0}};\\n    bool isValid(int a,int b, int m,int n,map<pair<int,int>,int>&w,map<pair<int,int>,int>&v){\\n        return a>=0 and b>=0 and a<m and b<n and w.find({a,b})==w.end() and v.find({a,b})==v.end();\\n        \\n    }\\n\\n    int countUnguarded(int m, int n, vector<vector<int>>& guards, vector<vector<int>>& walls) {\\n        vector<vector<bool>>vis(m,vector<bool>(n,false));\\n        pair<int,int> i = traverse[0], j = traverse[1];\\n        pair<int,int> x = traverse[2], y = traverse[3];\\n        map<pair<int,int>,int>w,v;\\n        for(auto i:walls){\\n           w[{i[0],i[1]}]++;\\n        }\\n        for(auto i:guards){\\n           w[{i[0],i[1]}]++;\\n        }\\n        for(auto c:guards){\\n            vis[c[0]][c[1]] = true;\\n        }\\n        for(auto c:walls){\\n            vis[c[0]][c[1]] = true;\\n        }\\n        for(auto c:guards){\\n            int a = i.first+c[0], b = i.second+c[1];\\n            while(isValid(a,b,m,n,w,v)){\\n            vis[a][b] = true;\\n            a += i.first, b+= i.second;\\n            \\n            }\\n             a = j.first+c[0], b = j.second+c[1];\\n            while(isValid(a,b,m,n,w,v)){\\n            vis[a][b] = true;\\n            a += j.first, b+= j.second;\\n            \\n            }\\n             a = x.first+c[0], b = x.second+c[1];\\n            while(isValid(a,b,m,n,w,v)){\\n                vis[a][b] = true;\\n            a += x.first, b+= x.second;\\n           \\n            }\\n             a = y.first+c[0], b = y.second+c[1];\\n            while(isValid(a,b,m,n,w,v)){\\n                vis[a][b] = true;\\n            a += y.first, b+= y.second;\\n            \\n            }\\n        }\\n        int ans = 0;\\n        for(int i=0;i<m;++i){\\n            for(int j=0;j<n;++j){\\n                if(!vis[i][j]){ans++;}\\n            }\\n        }\\n        return ans;\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3480032,
                "title": "easy-comprehension-is-facilitated-by-a-comprehensive-elucidation-provided-alongside",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nWe perform a depth-first search (DFS) for each guard in all four possible directions.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. Establish a temporary map for the purpose of tracking unguarded blocks.\\n2. Designate and categorize all locations of both guards and walls.\\n3. Conduct a Depth-First Search (DFS) on each guard\\'s four directional possibilities.\\n4. Appropriately identify and mark all cells that have been covered.\\n5. Tally the total count of unguarded cells.\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(max(m,n)G) where G is the number of guards\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(mn)\\n# Code\\n```\\nclass Solution:\\n    def countUnguarded(self, m: int, n: int, guards: List[List[int]], walls: List[List[int]]) -> int:\\n        # tmp map to keep track on which block is not guarded\\n        tmp_map = [[0 for _ in range(n)] for _ in range(m)] \\n        # label all guards with 1\\n        for [i,j] in guards:\\n            tmp_map[i][j] = 1\\n        # label all walls with -1   \\n        for [i,j] in walls:\\n            tmp_map[i][j] = -1\\n        \\n        # dfs to label all the cells that are guarded by guards\\n        def dfs(i, j, di):\\n            if i<0 or i>=m or j<0 or j>=n or tmp_map[i][j] == 1 or tmp_map[i][j] == -1:\\n                # if out of bound or guarded or wall, return\\n                return\\n            else:\\n                tmp_map[i][j] = 2\\n            # di is the direction of the guard\\n            i = i + lst[di]\\n            j = j + lst[di+1]\\n            dfs(i,j,di)\\n        \\n        # 4 directions\\n        lst = [1, 0, -1, 0, 1]\\n        for [i, j] in guards:\\n            # dfs to label all the cells that are guarded by guards in 4 directions\\n            for idx in range(4):  \\n                k = i + lst[idx]\\n                l = j + lst[idx+1]\\n                dfs(k, l, idx)\\n        \\n        # count uncovered cells.\\n        count = 0\\n        for i in range(m):\\n            for j in range(n):\\n                if tmp_map[i][j] == 0:\\n                    count += 1\\n        return count\\n\\n                    \\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def countUnguarded(self, m: int, n: int, guards: List[List[int]], walls: List[List[int]]) -> int:\\n        # tmp map to keep track on which block is not guarded\\n        tmp_map = [[0 for _ in range(n)] for _ in range(m)] \\n        # label all guards with 1\\n        for [i,j] in guards:\\n            tmp_map[i][j] = 1\\n        # label all walls with -1   \\n        for [i,j] in walls:\\n            tmp_map[i][j] = -1\\n        \\n        # dfs to label all the cells that are guarded by guards\\n        def dfs(i, j, di):\\n            if i<0 or i>=m or j<0 or j>=n or tmp_map[i][j] == 1 or tmp_map[i][j] == -1:\\n                # if out of bound or guarded or wall, return\\n                return\\n            else:\\n                tmp_map[i][j] = 2\\n            # di is the direction of the guard\\n            i = i + lst[di]\\n            j = j + lst[di+1]\\n            dfs(i,j,di)\\n        \\n        # 4 directions\\n        lst = [1, 0, -1, 0, 1]\\n        for [i, j] in guards:\\n            # dfs to label all the cells that are guarded by guards in 4 directions\\n            for idx in range(4):  \\n                k = i + lst[idx]\\n                l = j + lst[idx+1]\\n                dfs(k, l, idx)\\n        \\n        # count uncovered cells.\\n        count = 0\\n        for i in range(m):\\n            for j in range(n):\\n                if tmp_map[i][j] == 0:\\n                    count += 1\\n        return count\\n\\n                    \\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3470072,
                "title": "easy-java-begineer-solution",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\n    int ans[][];\\n    public int countUnguarded(int m, int n, int[][] guards, int[][] walls) {\\n        int mat[][]=new int[m][n];\\n        ans=new int[m][n];\\n        for(int i=0;i<guards.length;i++){\\n            mat[guards[i][0]][guards[i][1]]=1;\\n            ans[guards[i][0]][guards[i][1]]=1;\\n        }\\n        for(int i=0;i<walls.length;i++){\\n            mat[walls[i][0]][walls[i][1]]=-1;\\n            ans[walls[i][0]][walls[i][1]]=-1;\\n        }\\n        for(int i=0;i<m;i++){\\n            for(int j=0;j<n;j++){\\n                if(mat[i][j]==1){\\n                    dfs(i,j,m,n,mat);\\n                }\\n            }\\n        }\\n        int res=0;\\n        for(int i=0;i<m;i++){\\n            for(int j=0;j<n;j++){\\n                if(ans[i][j]==0)res++;\\n            }\\n        }\\n        return res;\\n    }\\n    public void dfs(int r,int c,int m,int n,int mat[][]){\\n        int r1=r+1;\\n        int r2=r-1;\\n        int c1=c+1;\\n        int c2=c-1;\\n        while(c1<n){\\n            if(mat[r][c1]==1)break;\\n            else if(mat[r][c1]==-1)break;\\n            ans[r][c1]=1;\\n            c1++;\\n        }\\n        while(c2>=0){\\n            if(mat[r][c2]==1)break;\\n            else if(mat[r][c2]==-1)break;\\n            ans[r][c2]=1;\\n            c2--;\\n        }\\n        while(r1<m){\\n            if(mat[r1][c]==1)break;\\n            else if(mat[r1][c]==-1)break;\\n            ans[r1][c]=1;\\n            r1++;\\n        }\\n        while(r2>=0){\\n            if(mat[r2][c]==1)break;\\n            else if(mat[r2][c]==-1)break;\\n            ans[r2][c]=1;\\n            r2--;\\n        }\\n    }\\n}\\n//guard-1\\n//not guard-0\\n//wall--1\\n```",
                "solutionTags": [
                    "Java",
                    "Matrix",
                    "Simulation"
                ],
                "code": "```\\nclass Solution {\\n    int ans[][];\\n    public int countUnguarded(int m, int n, int[][] guards, int[][] walls) {\\n        int mat[][]=new int[m][n];\\n        ans=new int[m][n];\\n        for(int i=0;i<guards.length;i++){\\n            mat[guards[i][0]][guards[i][1]]=1;\\n            ans[guards[i][0]][guards[i][1]]=1;\\n        }\\n        for(int i=0;i<walls.length;i++){\\n            mat[walls[i][0]][walls[i][1]]=-1;\\n            ans[walls[i][0]][walls[i][1]]=-1;\\n        }\\n        for(int i=0;i<m;i++){\\n            for(int j=0;j<n;j++){\\n                if(mat[i][j]==1){\\n                    dfs(i,j,m,n,mat);\\n                }\\n            }\\n        }\\n        int res=0;\\n        for(int i=0;i<m;i++){\\n            for(int j=0;j<n;j++){\\n                if(ans[i][j]==0)res++;\\n            }\\n        }\\n        return res;\\n    }\\n    public void dfs(int r,int c,int m,int n,int mat[][]){\\n        int r1=r+1;\\n        int r2=r-1;\\n        int c1=c+1;\\n        int c2=c-1;\\n        while(c1<n){\\n            if(mat[r][c1]==1)break;\\n            else if(mat[r][c1]==-1)break;\\n            ans[r][c1]=1;\\n            c1++;\\n        }\\n        while(c2>=0){\\n            if(mat[r][c2]==1)break;\\n            else if(mat[r][c2]==-1)break;\\n            ans[r][c2]=1;\\n            c2--;\\n        }\\n        while(r1<m){\\n            if(mat[r1][c]==1)break;\\n            else if(mat[r1][c]==-1)break;\\n            ans[r1][c]=1;\\n            r1++;\\n        }\\n        while(r2>=0){\\n            if(mat[r2][c]==1)break;\\n            else if(mat[r2][c]==-1)break;\\n            ans[r2][c]=1;\\n            r2--;\\n        }\\n    }\\n}\\n//guard-1\\n//not guard-0\\n//wall--1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3459614,
                "title": "simple-java-solution",
                "content": "# Tip\\nYou Should stop seeing perticular direction if you came across any gaurd or wall\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nif gaurd ==> cell be 1;\\nif wall ==> cell be 2;\\nif the cell can be seen by any gaurd then ==> cell be 3;\\nyou can check that by looping through all the four directions\\n\\nAt the end the answer will be no of cells with \"-1\".\\n\\n# Code\\n```\\nclass Solution {\\n    public int countUnguarded(int m, int n, int[][] guards, int[][] walls) {\\n        int[][] grid = new int[m][n];\\n        for(int[] i:grid){\\n            Arrays.fill(i,-1);\\n        }\\n        for(int i[]:guards){\\n            grid[i[0]][i[1]] = 1;\\n        }\\n        for(int i[]:walls){\\n            grid[i[0]][i[1]] = 2;\\n        }\\n        for(int i=0;i<m;i++){\\n            for(int j=0;j<n;j++){\\n                if(grid[i][j]==1) helper(i,j,grid);\\n            }\\n        }\\n        int answer = 0;\\n        for(int i=0;i<m;i++){\\n            for(int j=0;j<n;j++) if(grid[i][j]==-1) answer++;\\n        }\\n        return answer;\\n    }\\n    public void helper(int row,int col,int[][] grid){\\n        int m = grid.length;\\n        int n = grid[0].length;\\n        for(int i=col+1;i<n;i++){\\n            if(grid[row][i]==-1) grid[row][i] = 3;\\n            if(grid[row][i]==2||grid[row][i]==1) break;\\n        }\\n        for(int i=col-1;i>=0;i--){\\n            if(grid[row][i]==-1) grid[row][i] = 3;\\n            if(grid[row][i]==2||grid[row][i]==1) break;\\n        }\\n        for(int i=row+1;i<m;i++){\\n            if(grid[i][col]==-1) grid[i][col] = 3;\\n            if(grid[i][col]==2||grid[i][col]==1) break;\\n        }\\n        for(int i=row-1;i>=0;i--){\\n            if(grid[i][col]==-1) grid[i][col] = 3;\\n            if(grid[i][col]==2||grid[i][col]==1) break;\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Matrix"
                ],
                "code": "```\\nclass Solution {\\n    public int countUnguarded(int m, int n, int[][] guards, int[][] walls) {\\n        int[][] grid = new int[m][n];\\n        for(int[] i:grid){\\n            Arrays.fill(i,-1);\\n        }\\n        for(int i[]:guards){\\n            grid[i[0]][i[1]] = 1;\\n        }\\n        for(int i[]:walls){\\n            grid[i[0]][i[1]] = 2;\\n        }\\n        for(int i=0;i<m;i++){\\n            for(int j=0;j<n;j++){\\n                if(grid[i][j]==1) helper(i,j,grid);\\n            }\\n        }\\n        int answer = 0;\\n        for(int i=0;i<m;i++){\\n            for(int j=0;j<n;j++) if(grid[i][j]==-1) answer++;\\n        }\\n        return answer;\\n    }\\n    public void helper(int row,int col,int[][] grid){\\n        int m = grid.length;\\n        int n = grid[0].length;\\n        for(int i=col+1;i<n;i++){\\n            if(grid[row][i]==-1) grid[row][i] = 3;\\n            if(grid[row][i]==2||grid[row][i]==1) break;\\n        }\\n        for(int i=col-1;i>=0;i--){\\n            if(grid[row][i]==-1) grid[row][i] = 3;\\n            if(grid[row][i]==2||grid[row][i]==1) break;\\n        }\\n        for(int i=row+1;i<m;i++){\\n            if(grid[i][col]==-1) grid[i][col] = 3;\\n            if(grid[i][col]==2||grid[i][col]==1) break;\\n        }\\n        for(int i=row-1;i>=0;i--){\\n            if(grid[i][col]==-1) grid[i][col] = 3;\\n            if(grid[i][col]==2||grid[i][col]==1) break;\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3446868,
                "title": "100-fast-simple-java-solution-with-intuition-and-code",
                "content": "# Intuition\\nIntuition in simple, we have to find the number of unseen cells, i.e. the number of cells not seen by any guards, For that we need to create a matrix of size =m*n; now instead of taking it an integer matrix , I took a character matrix as it takes lesser space as compared to an integer matrix.\\n\\n# Approach\\n\\nI will createa matrix to mark the position of walls, guards and cells.I will store count= m*n as the number of cells. I will subtract the position of guards and walls while I mark their positions. Once I marked, I will place the index of all the guards as a pair {row,col} in a queue dataStructure. Take out one pair out one by one , Each time we will go in all the 4 directions until I get to a wall or a guard or onr of the 4 ends. In this traversal I will subtract each time I find an unvisited cell as that cell will be converted into a visited cell \\'R\\'.\\nAt the end of the day I will be left with the count of all remaining safe cells unseen by the guads.\\n\\n# Complexity\\n- Time complexity:\\nO(n*4)\\n- Space complexity:\\nO(m*n);\\n# Code\\n```\\nclass Solution {\\n    private class pair{\\n        int r;int c;\\n        public pair(int r,int c){\\n            this.r=r;\\n            this.c=c;\\n        }\\n    }\\n    public int countUnguarded(int m, int n, int[][] guards, int[][] walls) {\\n        char[][]grid=new char[m][n];\\n        Queue<pair>q=new LinkedList<pair>();\\n        int count=m*n;\\n        for(int i=0;i<guards.length;i++){\\n            grid[guards[i][0]][guards[i][1]]=\\'G\\';\\n            q.add(new pair(guards[i][0],guards[i][1]));\\n            count--;\\n        }\\n        for(int i=0;i<walls.length;i++){\\n            grid[walls[i][0]][walls[i][1]]=\\'W\\';\\n            count--;\\n        } \\n        int delRow[]={-1,0,1,0};      \\n        int delCol[]={0,1,0,-1};\\n        while(!q.isEmpty()){\\n            int r=q.peek().r;\\n            int c=q.peek().c;\\n            q.remove();\\n            for(int i=0;i<4;i++){\\n                int nrow=r+delRow[i];\\n                int ncol=c+delCol[i];\\n                while(nrow>=0&&nrow<m&&ncol>=0&&ncol<n&&(grid[nrow][ncol]!=\\'W\\'&&grid[nrow][ncol]!=\\'G\\')){\\n                    if(grid[nrow][ncol]!=\\'R\\'){\\n                        count--;\\n                    }\\n                    grid[nrow][ncol]=\\'R\\';\\n                    nrow+=delRow[i];\\n                    ncol+=delCol[i];\\n                }\\n            }\\n            \\n        }\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Graph"
                ],
                "code": "```\\nclass Solution {\\n    private class pair{\\n        int r;int c;\\n        public pair(int r,int c){\\n            this.r=r;\\n            this.c=c;\\n        }\\n    }\\n    public int countUnguarded(int m, int n, int[][] guards, int[][] walls) {\\n        char[][]grid=new char[m][n];\\n        Queue<pair>q=new LinkedList<pair>();\\n        int count=m*n;\\n        for(int i=0;i<guards.length;i++){\\n            grid[guards[i][0]][guards[i][1]]=\\'G\\';\\n            q.add(new pair(guards[i][0],guards[i][1]));\\n            count--;\\n        }\\n        for(int i=0;i<walls.length;i++){\\n            grid[walls[i][0]][walls[i][1]]=\\'W\\';\\n            count--;\\n        } \\n        int delRow[]={-1,0,1,0};      \\n        int delCol[]={0,1,0,-1};\\n        while(!q.isEmpty()){\\n            int r=q.peek().r;\\n            int c=q.peek().c;\\n            q.remove();\\n            for(int i=0;i<4;i++){\\n                int nrow=r+delRow[i];\\n                int ncol=c+delCol[i];\\n                while(nrow>=0&&nrow<m&&ncol>=0&&ncol<n&&(grid[nrow][ncol]!=\\'W\\'&&grid[nrow][ncol]!=\\'G\\')){\\n                    if(grid[nrow][ncol]!=\\'R\\'){\\n                        count--;\\n                    }\\n                    grid[nrow][ncol]=\\'R\\';\\n                    nrow+=delRow[i];\\n                    ncol+=delCol[i];\\n                }\\n            }\\n            \\n        }\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3434656,
                "title": "accepted-swift",
                "content": "```\\nclass Solution {\\n    func countUnguarded(_ m: Int, _ n: Int, _ guards: [[Int]], _ walls: [[Int]]) -> Int {\\n        \\n        var cells = Array(repeating: Array(repeating: 1, count: n), count: m)\\n\\n        for w in walls { cells[w[0]][w[1]] = -1 }\\n        for g in guards { cells[g[0]][g[1]] = -1 }\\n\\n        for g in guards {\\n\\n            for x in (0..<g[0]).reversed() {\\n                guard cells[x][g[1]] != -1 else { break }\\n                cells[x][g[1]] = 0\\n            }\\n\\n            for x in (g[0]..<m).dropFirst() {\\n                guard cells[x][g[1]] != -1 else { break }\\n                cells[x][g[1]] = 0\\n            }\\n\\n            for y in (0..<g[1]).reversed() {\\n                guard cells[g[0]][y] != -1 else { break }\\n                cells[g[0]][y] = 0\\n            }\\n\\n            for y in (g[1]..<n).dropFirst() {\\n                guard cells[g[0]][y] != -1 else { break }\\n                cells[g[0]][y] = 0\\n            }\\n        }\\n\\n        return cells\\n            .map { $0.reduce(0) { $0 + max($1, 0) } }\\n            .reduce(0, +)\\n    }\\n}\\n```",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nclass Solution {\\n    func countUnguarded(_ m: Int, _ n: Int, _ guards: [[Int]], _ walls: [[Int]]) -> Int {\\n        \\n        var cells = Array(repeating: Array(repeating: 1, count: n), count: m)\\n\\n        for w in walls { cells[w[0]][w[1]] = -1 }\\n        for g in guards { cells[g[0]][g[1]] = -1 }\\n\\n        for g in guards {\\n\\n            for x in (0..<g[0]).reversed() {\\n                guard cells[x][g[1]] != -1 else { break }\\n                cells[x][g[1]] = 0\\n            }\\n\\n            for x in (g[0]..<m).dropFirst() {\\n                guard cells[x][g[1]] != -1 else { break }\\n                cells[x][g[1]] = 0\\n            }\\n\\n            for y in (0..<g[1]).reversed() {\\n                guard cells[g[0]][y] != -1 else { break }\\n                cells[g[0]][y] = 0\\n            }\\n\\n            for y in (g[1]..<n).dropFirst() {\\n                guard cells[g[0]][y] != -1 else { break }\\n                cells[g[0]][y] = 0\\n            }\\n        }\\n\\n        return cells\\n            .map { $0.reduce(0) { $0 + max($1, 0) } }\\n            .reduce(0, +)\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3416939,
                "title": "c-brute-force-ac",
                "content": "# Intuition\\nVisit all 4 directions of a guard which can be visited.\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int countUnguarded(int n, int m, vector<vector<int>>& guards, vector<vector<int>>& walls) {\\n        vector<vector<char>> grid(n,vector<char>(m,\\'0\\'));\\n        for(int i=0;i<guards.size();i++)\\n        {\\n            int r = guards[i][0];\\n            int c = guards[i][1];\\n            grid[r][c] = \\'G\\';\\n        }\\n        for(int i=0;i<walls.size();i++)\\n        {\\n            int r = walls[i][0];\\n            int c = walls[i][1];\\n            grid[r][c] = \\'W\\';\\n        }\\n        for(int i=0;i<guards.size();i++)\\n        {\\n            int r = guards[i][0];\\n            int c = guards[i][1];\\n            for(int j=c-1;j>=0;j--)\\n            {\\n                if(grid[r][j]==\\'W\\' || grid[r][j]==\\'G\\')\\n                break;\\n                if(grid[r][j]==\\'0\\')\\n                grid[r][j] = \\'1\\';\\n            }\\n            for(int j=c+1;j<m;j++)\\n            {\\n                if(grid[r][j]==\\'W\\' || grid[r][j]==\\'G\\')\\n                break;\\n                if(grid[r][j]==\\'0\\')\\n                grid[r][j] = \\'1\\';\\n            }\\n            for(int j=r-1;j>=0;j--)\\n            {\\n                if(grid[j][c]==\\'W\\' || grid[j][c]==\\'G\\')\\n                break;\\n                if(grid[j][c]==\\'0\\')\\n                grid[j][c] = \\'1\\';\\n            }\\n            for(int j=r+1;j<n;j++)\\n            {\\n                if(grid[j][c]==\\'W\\' || grid[j][c]==\\'G\\')\\n                break;\\n                if(grid[j][c]==\\'0\\')\\n                grid[j][c] = \\'1\\';\\n            }\\n        }\\n        int cnt=0;\\n        for(int i=0;i<n;i++)\\n        {\\n            for(int j=0;j<m;j++)\\n            {\\n                if(grid[i][j]==\\'0\\')\\n                cnt++;\\n            }\\n        }\\n        return cnt;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int countUnguarded(int n, int m, vector<vector<int>>& guards, vector<vector<int>>& walls) {\\n        vector<vector<char>> grid(n,vector<char>(m,\\'0\\'));\\n        for(int i=0;i<guards.size();i++)\\n        {\\n            int r = guards[i][0];\\n            int c = guards[i][1];\\n            grid[r][c] = \\'G\\';\\n        }\\n        for(int i=0;i<walls.size();i++)\\n        {\\n            int r = walls[i][0];\\n            int c = walls[i][1];\\n            grid[r][c] = \\'W\\';\\n        }\\n        for(int i=0;i<guards.size();i++)\\n        {\\n            int r = guards[i][0];\\n            int c = guards[i][1];\\n            for(int j=c-1;j>=0;j--)\\n            {\\n                if(grid[r][j]==\\'W\\' || grid[r][j]==\\'G\\')\\n                break;\\n                if(grid[r][j]==\\'0\\')\\n                grid[r][j] = \\'1\\';\\n            }\\n            for(int j=c+1;j<m;j++)\\n            {\\n                if(grid[r][j]==\\'W\\' || grid[r][j]==\\'G\\')\\n                break;\\n                if(grid[r][j]==\\'0\\')\\n                grid[r][j] = \\'1\\';\\n            }\\n            for(int j=r-1;j>=0;j--)\\n            {\\n                if(grid[j][c]==\\'W\\' || grid[j][c]==\\'G\\')\\n                break;\\n                if(grid[j][c]==\\'0\\')\\n                grid[j][c] = \\'1\\';\\n            }\\n            for(int j=r+1;j<n;j++)\\n            {\\n                if(grid[j][c]==\\'W\\' || grid[j][c]==\\'G\\')\\n                break;\\n                if(grid[j][c]==\\'0\\')\\n                grid[j][c] = \\'1\\';\\n            }\\n        }\\n        int cnt=0;\\n        for(int i=0;i<n;i++)\\n        {\\n            for(int j=0;j<m;j++)\\n            {\\n                if(grid[i][j]==\\'0\\')\\n                cnt++;\\n            }\\n        }\\n        return cnt;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3413013,
                "title": "highly-explained-entire-thought-process-c-o-n-m-space-and-time",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nI thought for a long time, how to do it better than brute force solution, but anything didn\\'t came in my mind. So, i decided to write the brute force solution.So, while writing i came up with a thought that if a guard has already visited a particular cell in that direction, then the cell is guarded, if any others guard is present in the path in that direction, so he need not to visit all the cells in that direction, G----G----- i.e if the path is visited by one guard while in that direction, other guard need not to travel in the same direction as all path are already visited by first guard\\n\\n\\nLet us try to understand it!\\nG..........\\nthe path first guard visited in that direction.\\nif after, there is also a guard in that path\\nG...G...... he need not to visit the cell in that direction\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. A matrix of size m*n is created and intialised to 0\\n2. To check for the walls, it is marked as 1\\n3. We start iterate over the guards\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n*m)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(n*m)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int countUnguarded(int m, int n, vector<vector<int>>& guards, vector<vector<int>>& walls) {\\n        int arr[m][n], count = 0;\\n        for(int i = 0 ; i < m ; i++){\\n            for(int j = 0 ; j < n ; j++) arr[i][j] = 0;\\n        }\\n\\n        for(auto &it : walls){\\n            arr[it[0]][it[1]] = 1;\\n        }\\n\\n        // if left = 3, right = 4, top = 5, bottom = 6;\\n\\n        for(auto &it : guards){\\n            int row = it[0], col = it[1];\\n            arr[row][col] = 2;\\n            //travelling towards upward, break if guard is present, wall, already traverse by some guard in that direction.\\n            for(int i = row-1 ; i >= 0 ; i--){\\n                if(arr[i][col] == 1 || arr[i][col] == 2 || arr[i][col] == 5) break;\\n                arr[i][col] = 5; \\n            }\\n            //traversing towards downward\\n            for(int i = row+1 ; i < m ; i++){\\n                if(arr[i][col] == 1 || arr[i][col] == 2 || arr[i][col] == 6) break;\\n                arr[i][col] = 6;\\n            }\\n            //traversing towards left\\n            for(int j = col-1; j >= 0 ; j--){\\n                if(arr[row][j] == 1 || arr[row][j] == 2 || arr[row][j] == 3) break;\\n                arr[row][j] = 3;\\n            }\\n            //traversing towards right\\n            for(int j = col+1; j < n ; j++){\\n                if(arr[row][j] == 1 || arr[row][j] == 2 || arr[row][j] == 4) break;\\n                arr[row][j] = 4;\\n            }\\n        }\\n        \\n        for(int i = 0; i < m ; i++){\\n            for(int j = 0 ; j < n ; j++){\\n                if(arr[i][j] == 0) count++;\\n            }\\n        }\\n        return count;\\n    }\\n};\\n```\\n\\nIf you find it useful, please upvote it!",
                "solutionTags": [
                    "C++",
                    "Greedy",
                    "Matrix",
                    "Simulation"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int countUnguarded(int m, int n, vector<vector<int>>& guards, vector<vector<int>>& walls) {\\n        int arr[m][n], count = 0;\\n        for(int i = 0 ; i < m ; i++){\\n            for(int j = 0 ; j < n ; j++) arr[i][j] = 0;\\n        }\\n\\n        for(auto &it : walls){\\n            arr[it[0]][it[1]] = 1;\\n        }\\n\\n        // if left = 3, right = 4, top = 5, bottom = 6;\\n\\n        for(auto &it : guards){\\n            int row = it[0], col = it[1];\\n            arr[row][col] = 2;\\n            //travelling towards upward, break if guard is present, wall, already traverse by some guard in that direction.\\n            for(int i = row-1 ; i >= 0 ; i--){\\n                if(arr[i][col] == 1 || arr[i][col] == 2 || arr[i][col] == 5) break;\\n                arr[i][col] = 5; \\n            }\\n            //traversing towards downward\\n            for(int i = row+1 ; i < m ; i++){\\n                if(arr[i][col] == 1 || arr[i][col] == 2 || arr[i][col] == 6) break;\\n                arr[i][col] = 6;\\n            }\\n            //traversing towards left\\n            for(int j = col-1; j >= 0 ; j--){\\n                if(arr[row][j] == 1 || arr[row][j] == 2 || arr[row][j] == 3) break;\\n                arr[row][j] = 3;\\n            }\\n            //traversing towards right\\n            for(int j = col+1; j < n ; j++){\\n                if(arr[row][j] == 1 || arr[row][j] == 2 || arr[row][j] == 4) break;\\n                arr[row][j] = 4;\\n            }\\n        }\\n        \\n        for(int i = 0; i < m ; i++){\\n            for(int j = 0 ; j < n ; j++){\\n                if(arr[i][j] == 0) count++;\\n            }\\n        }\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3329202,
                "title": "c-golang-simulation",
                "content": "# Code\\n```\\n// C++\\nclass Solution {\\npublic:\\n    int countUnguarded(int m, int n, vector<vector<int>>& guards, vector<vector<int>>& walls) {\\n        vector<vector<char>> grid(m, vector<char>(n, -1));\\n        int cannotVisit = walls.size() + guards.size();\\n        for(vector<int> wall: walls) {\\n            grid[wall[0]][wall[1]] = 0;\\n        }\\n        for(vector<int> guard: guards) {\\n            grid[guard[0]][guard[1]] = 0;\\n        }\\n        int dirs[4][2] = {{-1, 0}, {1, 0}, {0, -1}, {0, 1}};\\n        for(vector<int> guard: guards) {\\n            for(auto dir: dirs) {\\n                for(int i = 1; ; i++) {\\n                    int x = guard[0] + i * dir[0];\\n                    int y = guard[1] + i * dir[1];\\n                    if(x < 0 || x >= m || y < 0 || y >= n || grid[x][y] == 0) break;\\n                    cannotVisit += grid[x][y] == -1;\\n                    grid[x][y] = 1;\\n                }\\n            }\\n        }\\n        return m * n - cannotVisit;\\n    }\\n};\\n\\n\\n// Golang\\nfunc countUnguarded(m int, n int, guards [][]int, walls [][]int) int {\\n    grid := make([][]int, m)\\n    for i := 0; i < m; i++ {grid[i] = make([]int, n)} \\n    for _, wall := range walls {\\n        grid[wall[0]][wall[1]] = 1\\n    }\\n    for _, guard := range guards {\\n        grid[guard[0]][guard[1]] = 1\\n    }\\n    dirs := [][]int{{-1, 0}, {1, 0}, {0, -1}, {0, 1}}\\n    cannotVisit := len(guards) + len(walls)\\n    for _, guard := range guards {\\n        for _, dir := range dirs {\\n            for i := 1; ; i++ {\\n                x := guard[0] + i * dir[0]\\n                y := guard[1] + i * dir[1]\\n                if x < 0 || x >= m || y < 0 || y >= n || grid[x][y] == 1 {break}\\n                if grid[x][y] == 0 {cannotVisit++}\\n                grid[x][y] = 2\\n            }\\n        }\\n    }\\n    return m * n - cannotVisit\\n}\\n```",
                "solutionTags": [
                    "C++",
                    "Go",
                    "Matrix",
                    "Simulation"
                ],
                "code": "```\\n// C++\\nclass Solution {\\npublic:\\n    int countUnguarded(int m, int n, vector<vector<int>>& guards, vector<vector<int>>& walls) {\\n        vector<vector<char>> grid(m, vector<char>(n, -1));\\n        int cannotVisit = walls.size() + guards.size();\\n        for(vector<int> wall: walls) {\\n            grid[wall[0]][wall[1]] = 0;\\n        }\\n        for(vector<int> guard: guards) {\\n            grid[guard[0]][guard[1]] = 0;\\n        }\\n        int dirs[4][2] = {{-1, 0}, {1, 0}, {0, -1}, {0, 1}};\\n        for(vector<int> guard: guards) {\\n            for(auto dir: dirs) {\\n                for(int i = 1; ; i++) {\\n                    int x = guard[0] + i * dir[0];\\n                    int y = guard[1] + i * dir[1];\\n                    if(x < 0 || x >= m || y < 0 || y >= n || grid[x][y] == 0) break;\\n                    cannotVisit += grid[x][y] == -1;\\n                    grid[x][y] = 1;\\n                }\\n            }\\n        }\\n        return m * n - cannotVisit;\\n    }\\n};\\n\\n\\n// Golang\\nfunc countUnguarded(m int, n int, guards [][]int, walls [][]int) int {\\n    grid := make([][]int, m)\\n    for i := 0; i < m; i++ {grid[i] = make([]int, n)} \\n    for _, wall := range walls {\\n        grid[wall[0]][wall[1]] = 1\\n    }\\n    for _, guard := range guards {\\n        grid[guard[0]][guard[1]] = 1\\n    }\\n    dirs := [][]int{{-1, 0}, {1, 0}, {0, -1}, {0, 1}}\\n    cannotVisit := len(guards) + len(walls)\\n    for _, guard := range guards {\\n        for _, dir := range dirs {\\n            for i := 1; ; i++ {\\n                x := guard[0] + i * dir[0]\\n                y := guard[1] + i * dir[1]\\n                if x < 0 || x >= m || y < 0 || y >= n || grid[x][y] == 1 {break}\\n                if grid[x][y] == 0 {cannotVisit++}\\n                grid[x][y] = 2\\n            }\\n        }\\n    }\\n    return m * n - cannotVisit\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3321844,
                "title": "very-simple-python-just-made-the-given-picture-still-beats-98",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nCould definiently make this faster, it does only check one given direction at a time, but it still gets the job done, and is pretty easy to follow.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def countUnguarded(self, m: int, n: int, guards: List[List[int]], walls: List[List[int]]) -> int:\\n        matrix = [[\\'g\\' for i in range(n)] for i in range(m)]\\n        for i in guards:\\n            matrix[i[0]][i[1]] = \\'G\\'\\n        for i in walls:\\n            matrix[i[0]][i[1]] = \\'W\\' \\n        \\n        \\'\\'\\'\\n        matrix = [[\\'G\\',\\'W\\',\\'g\\',\\'g\\',\\'g\\',\\'g\\'],\\n                  [\\'g\\',\\'G\\',\\'g\\',\\'g\\',\\'W\\',\\'g\\'],\\n                  [\\'g\\',\\'g\\',\\'W\\',\\'G\\',\\'g\\',\\'g\\'],\\n                  [\\'g\\',\\'g\\',\\'g\\',\\'g\\',\\'g\\',\\'g\\']]\\n        wanted to match the picture\\n\\n        \\'G\\' = Guard\\n        \\'W\\' = Wall\\n        \\'g\\' = green, not seen by guard\\n        \\'r\\' = red, seen by guard\\n        \\'\\'\\'\\n\\n        count = 0\\n        for x,y in guards:\\n            if x > 0: # checks left of the current guard\\n                for j in range(x-1,-1,-1):\\n                    curr = matrix[j][y]\\n                    if curr == \\'W\\' or curr == \\'G\\':\\n                        break\\n                    else:\\n                        matrix[j][y]=\\'r\\'\\n\\n            if x < m-1: # checks right of the current guard\\n                for j in range(x+1,m):\\n                    curr = matrix[j][y]\\n                    if curr == \\'W\\' or curr == \\'G\\':\\n                        break\\n                    else:\\n                        matrix[j][y]=\\'r\\'\\n            \\n            if y > 0: # checks above of the current guard\\n                for j in range(y-1,-1,-1):\\n                    curr = matrix[x][j]\\n                    if curr == \\'W\\' or curr == \\'G\\':\\n                        break\\n                    else:\\n                        matrix[x][j]=\\'r\\'\\n            \\n            if y < n-1: # checks below of the current guard\\n                for j in range(y+1,n):\\n                    curr = matrix[x][j]\\n                    if curr == \\'W\\' or curr == \\'G\\':\\n                        break\\n                    else:\\n                        matrix[x][j]=\\'r\\'\\n        \\n        for i in matrix: # goes through matrix counting green boxes\\n            for j in i:\\n                if j == \\'g\\':\\n                    count += 1       \\n        return count\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def countUnguarded(self, m: int, n: int, guards: List[List[int]], walls: List[List[int]]) -> int:\\n        matrix = [[\\'g\\' for i in range(n)] for i in range(m)]\\n        for i in guards:\\n            matrix[i[0]][i[1]] = \\'G\\'\\n        for i in walls:\\n            matrix[i[0]][i[1]] = \\'W\\' \\n        \\n        \\'\\'\\'\\n        matrix = [[\\'G\\',\\'W\\',\\'g\\',\\'g\\',\\'g\\',\\'g\\'],\\n                  [\\'g\\',\\'G\\',\\'g\\',\\'g\\',\\'W\\',\\'g\\'],\\n                  [\\'g\\',\\'g\\',\\'W\\',\\'G\\',\\'g\\',\\'g\\'],\\n                  [\\'g\\',\\'g\\',\\'g\\',\\'g\\',\\'g\\',\\'g\\']]\\n        wanted to match the picture\\n\\n        \\'G\\' = Guard\\n        \\'W\\' = Wall\\n        \\'g\\' = green, not seen by guard\\n        \\'r\\' = red, seen by guard\\n        \\'\\'\\'\\n\\n        count = 0\\n        for x,y in guards:\\n            if x > 0: # checks left of the current guard\\n                for j in range(x-1,-1,-1):\\n                    curr = matrix[j][y]\\n                    if curr == \\'W\\' or curr == \\'G\\':\\n                        break\\n                    else:\\n                        matrix[j][y]=\\'r\\'\\n\\n            if x < m-1: # checks right of the current guard\\n                for j in range(x+1,m):\\n                    curr = matrix[j][y]\\n                    if curr == \\'W\\' or curr == \\'G\\':\\n                        break\\n                    else:\\n                        matrix[j][y]=\\'r\\'\\n            \\n            if y > 0: # checks above of the current guard\\n                for j in range(y-1,-1,-1):\\n                    curr = matrix[x][j]\\n                    if curr == \\'W\\' or curr == \\'G\\':\\n                        break\\n                    else:\\n                        matrix[x][j]=\\'r\\'\\n            \\n            if y < n-1: # checks below of the current guard\\n                for j in range(y+1,n):\\n                    curr = matrix[x][j]\\n                    if curr == \\'W\\' or curr == \\'G\\':\\n                        break\\n                    else:\\n                        matrix[x][j]=\\'r\\'\\n        \\n        for i in matrix: # goes through matrix counting green boxes\\n            for j in i:\\n                if j == \\'g\\':\\n                    count += 1       \\n        return count\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3314900,
                "title": "python-simple-clean-and-commented-code-o-n-2",
                "content": "```\\nclass Solution:\\n    def countUnguarded(self, m: int, n: int, guards: List[List[int]], walls: List[List[int]]) -> int:\\n        res = [[1]*n for _ in range(m)]\\n        cnt = 0 # count of guarded cells\\n        \\n        # mark all the walls\\n        for wall in walls:\\n            r, c = wall[0], wall[1]\\n            res[r][c] = -1\\n            # every wall is a guarded cell\\n            cnt += 1\\n        \\n        # mark all the guards\\n        for guard in guards:\\n            r, c = guard[0], guard[1]\\n            res[r][c] = -1\\n            # every guard is a guarded cell\\n            cnt += 1\\n            \\n        # check if a point is within the bounds of the grid\\n        def is_valid(r, c):\\n            if r < 0 or r >= m or c < 0 or c >= n: return False\\n            return True\\n        \\n        # function to mark the guarded cells\\n        def mark_cells(x, y, r, c, cnt):\\n            while is_valid(r+x, c+y):\\n                r += x\\n                c += y\\n                # if cell is a wall or guard, return the same count\\n                if res[r][c] == -1:\\n                    return cnt\\n                \\n                # if cell is not a wall or not a guard\\n                # and you visit it for the same time, increase the count of guarded cells\\n                if res[r][c] != 0: \\n                    cnt += 1\\n                \\n                # mark the cell as guarded\\n                res[r][c] = 0\\n            return cnt\\n        \\n        \\n        # 4 cardinal directions\\n        dirs = [[-1, 0], [0, 1], [1, 0], [0, -1]]\\n        \\n        # for every guard,\\n        # mark cells in all 4 cardnal directions\\n        for guard in guards:\\n            for cord in dirs:\\n                cnt = mark_cells(cord[0], cord[1], guard[0], guard[1], cnt)\\n        \\n        # unguarded cells = total cells - guarded cells\\n        unguarded = (m*n) - cnt\\n        return unguarded\\n```",
                "solutionTags": [
                    "Matrix"
                ],
                "code": "```\\nclass Solution:\\n    def countUnguarded(self, m: int, n: int, guards: List[List[int]], walls: List[List[int]]) -> int:\\n        res = [[1]*n for _ in range(m)]\\n        cnt = 0 # count of guarded cells\\n        \\n        # mark all the walls\\n        for wall in walls:\\n            r, c = wall[0], wall[1]\\n            res[r][c] = -1\\n            # every wall is a guarded cell\\n            cnt += 1\\n        \\n        # mark all the guards\\n        for guard in guards:\\n            r, c = guard[0], guard[1]\\n            res[r][c] = -1\\n            # every guard is a guarded cell\\n            cnt += 1\\n            \\n        # check if a point is within the bounds of the grid\\n        def is_valid(r, c):\\n            if r < 0 or r >= m or c < 0 or c >= n: return False\\n            return True\\n        \\n        # function to mark the guarded cells\\n        def mark_cells(x, y, r, c, cnt):\\n            while is_valid(r+x, c+y):\\n                r += x\\n                c += y\\n                # if cell is a wall or guard, return the same count\\n                if res[r][c] == -1:\\n                    return cnt\\n                \\n                # if cell is not a wall or not a guard\\n                # and you visit it for the same time, increase the count of guarded cells\\n                if res[r][c] != 0: \\n                    cnt += 1\\n                \\n                # mark the cell as guarded\\n                res[r][c] = 0\\n            return cnt\\n        \\n        \\n        # 4 cardinal directions\\n        dirs = [[-1, 0], [0, 1], [1, 0], [0, -1]]\\n        \\n        # for every guard,\\n        # mark cells in all 4 cardnal directions\\n        for guard in guards:\\n            for cord in dirs:\\n                cnt = mark_cells(cord[0], cord[1], guard[0], guard[1], cnt)\\n        \\n        # unguarded cells = total cells - guarded cells\\n        unguarded = (m*n) - cnt\\n        return unguarded\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3308178,
                "title": "c-solution-95-faster-detailed-comments-included",
                "content": "**Please do upvote \\u2B06\\uFE0F the solution to keep me motivated :)**\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int countUnguarded(int m, int n, vector<vector<int>>& guards, vector<vector<int>>& walls) {\\n        int cnt = 0;\\n\\n        // create a visited array to mark those cells which are guarded by the guards.\\n        vector<vector<int>> vis(m,vector<int>(n,0));\\n\\n        // mark the guard\\'s positions as 2\\n        for(auto& it:guards) {\\n            vis[it[0]][it[1]] = 2;\\n        }\\n\\n        // mark the walls\\'s positions as 3    \\n        for(auto& it:walls) {\\n            vis[it[0]][it[1]] = 3;\\n        }\\n\\n        for(auto& it:guards) {\\n            // mark row if possible\\n            // mark left part\\n            int r,c;\\n            r = it[0];\\n            c = it[1]-1;\\n            while(c>=0) {\\n                if(vis[r][c]==2 || vis[r][c]==3) break;\\n                else if(vis[r][c]==0) vis[r][c]=1;\\n                c--;\\n            }\\n\\n            // mark right part\\n            c = it[1]+1;\\n            while(c<n) {\\n                if(vis[r][c]==2 || vis[r][c]==3) break;\\n                else if(vis[r][c]==0) vis[r][c]=1;\\n                c++;\\n            }\\n\\n            // mark top part\\n            r = it[0]-1;\\n            c = it[1];\\n            while(r>=0) {\\n                if(vis[r][c]==2 || vis[r][c]==3) break;\\n                else if(vis[r][c]==0) vis[r][c]=1;\\n                r--;\\n            }\\n\\n            // mark bottom part\\n            r = it[0]+1;\\n            c = it[1];\\n            while(r<m) {\\n                if(vis[r][c]==2 || vis[r][c]==3) break;\\n                else if(vis[r][c]==0) vis[r][c]=1;\\n                r++;\\n            }\\n        }\\n\\n        // count unguarded cells\\n        for(int i=0;i<m;i++) {\\n            for(int j=0;j<n;j++) {\\n                if(vis[i][j]==0) cnt++;\\n            }\\n        }\\n        return cnt;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int countUnguarded(int m, int n, vector<vector<int>>& guards, vector<vector<int>>& walls) {\\n        int cnt = 0;\\n\\n        // create a visited array to mark those cells which are guarded by the guards.\\n        vector<vector<int>> vis(m,vector<int>(n,0));\\n\\n        // mark the guard\\'s positions as 2\\n        for(auto& it:guards) {\\n            vis[it[0]][it[1]] = 2;\\n        }\\n\\n        // mark the walls\\'s positions as 3    \\n        for(auto& it:walls) {\\n            vis[it[0]][it[1]] = 3;\\n        }\\n\\n        for(auto& it:guards) {\\n            // mark row if possible\\n            // mark left part\\n            int r,c;\\n            r = it[0];\\n            c = it[1]-1;\\n            while(c>=0) {\\n                if(vis[r][c]==2 || vis[r][c]==3) break;\\n                else if(vis[r][c]==0) vis[r][c]=1;\\n                c--;\\n            }\\n\\n            // mark right part\\n            c = it[1]+1;\\n            while(c<n) {\\n                if(vis[r][c]==2 || vis[r][c]==3) break;\\n                else if(vis[r][c]==0) vis[r][c]=1;\\n                c++;\\n            }\\n\\n            // mark top part\\n            r = it[0]-1;\\n            c = it[1];\\n            while(r>=0) {\\n                if(vis[r][c]==2 || vis[r][c]==3) break;\\n                else if(vis[r][c]==0) vis[r][c]=1;\\n                r--;\\n            }\\n\\n            // mark bottom part\\n            r = it[0]+1;\\n            c = it[1];\\n            while(r<m) {\\n                if(vis[r][c]==2 || vis[r][c]==3) break;\\n                else if(vis[r][c]==0) vis[r][c]=1;\\n                r++;\\n            }\\n        }\\n\\n        // count unguarded cells\\n        for(int i=0;i<m;i++) {\\n            for(int j=0;j<n;j++) {\\n                if(vis[i][j]==0) cnt++;\\n            }\\n        }\\n        return cnt;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3296117,
                "title": "easy-to-understand-c-solution",
                "content": "# Code\\n```\\nclass Solution \\n{\\npublic:\\n    int countUnguarded(int m, int n, vector<vector<int>>& guards, vector<vector<int>>& walls) \\n    {\\n        vector<vector<int>> grid(m, vector<int> (n,0));\\n        for(auto guard: guards)\\n        {\\n            grid[guard[0]][guard[1]]=2;\\n        }\\n        for(auto wall: walls)\\n        {\\n            grid[wall[0]][wall[1]]=3;\\n        }\\n        for(auto guard: guards)\\n        {\\n            int r=guard[0], c=guard[1];\\n            int x=r-1, y=c;\\n            while(x>=0 && grid[x][y]!=2 && grid[x][y]!=3) grid[x--][y]=1;\\n            x=r+1;\\n            while(x<m && grid[x][y]!=2 && grid[x][y]!=3) grid[x++][y]=1;\\n            x=r,y=c-1;\\n            while(y>=0 && grid[x][y]!=2 && grid[x][y]!=3) grid[x][y--]=1;\\n            y=c+1;\\n            while(y<n && grid[x][y]!=2 && grid[x][y]!=3) grid[x][y++]=1;\\n        }\\n        int ans=0;\\n        for(int x=0; x<m; x++)\\n        {\\n            for(int y=0; y<n; y++) if(!grid[x][y]) ans++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution \\n{\\npublic:\\n    int countUnguarded(int m, int n, vector<vector<int>>& guards, vector<vector<int>>& walls) \\n    {\\n        vector<vector<int>> grid(m, vector<int> (n,0));\\n        for(auto guard: guards)\\n        {\\n            grid[guard[0]][guard[1]]=2;\\n        }\\n        for(auto wall: walls)\\n        {\\n            grid[wall[0]][wall[1]]=3;\\n        }\\n        for(auto guard: guards)\\n        {\\n            int r=guard[0], c=guard[1];\\n            int x=r-1, y=c;\\n            while(x>=0 && grid[x][y]!=2 && grid[x][y]!=3) grid[x--][y]=1;\\n            x=r+1;\\n            while(x<m && grid[x][y]!=2 && grid[x][y]!=3) grid[x++][y]=1;\\n            x=r,y=c-1;\\n            while(y>=0 && grid[x][y]!=2 && grid[x][y]!=3) grid[x][y--]=1;\\n            y=c+1;\\n            while(y<n && grid[x][y]!=2 && grid[x][y]!=3) grid[x][y++]=1;\\n        }\\n        int ans=0;\\n        for(int x=0; x<m; x++)\\n        {\\n            for(int y=0; y<n; y++) if(!grid[x][y]) ans++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3279777,
                "title": "c-easy-implementation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int countUnguarded(int m, int n, vector<vector<int>>& guards, vector<vector<int>>& walls) {\\n        vector<vector<int>> space( m , vector<int> (n, 0));\\n        \\n        for(int i=0;i<walls.size();i++) {\\n            vector<int> v = walls[i];\\n            space[v[0]][v[1]]=-1;\\n        }\\n        for(int i=0;i<guards.size();i++) {\\n            vector<int> v = guards[i];\\n            space[v[0]][v[1]]=1;\\n        }\\n        for(int i=0;i<guards.size();i++) {\\n            int x = guards[i][0];\\n            int y = guards[i][1];\\n            \\n            \\n            for(int j=x-1;j>=0;j--) {\\n                if(space[j][y]==-1 || space[j][y]==1) {\\n                    break;\\n                }\\n                space[j][y]=5;\\n            }\\n\\n            for(int j=x+1;j<m;j++) {\\n                if(space[j][y]==-1 || space[j][y]==1) {\\n                    break;\\n                }\\n                space[j][y]=5;\\n            }\\n\\n            for(int j=y-1;j>=0;j--) {\\n                if(space[x][j]==-1 || space[x][j]==1) {\\n                    break;\\n                }\\n                space[x][j]=5;\\n            }\\n            for(int j=y+1;j<n;j++) {\\n                if(space[x][j]==-1 || space[x][j]==1) {\\n                    break;\\n                }\\n                space[x][j]=5;\\n            }\\n        }\\n        int count =0;\\n        for(int i=0;i<m;i++) {\\n            for(int j = 0;j<n;j++) {\\n                if(space[i][j]==0) {\\n                    count++;\\n                }\\n            }\\n        }\\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int countUnguarded(int m, int n, vector<vector<int>>& guards, vector<vector<int>>& walls) {\\n        vector<vector<int>> space( m , vector<int> (n, 0));\\n        \\n        for(int i=0;i<walls.size();i++) {\\n            vector<int> v = walls[i];\\n            space[v[0]][v[1]]=-1;\\n        }\\n        for(int i=0;i<guards.size();i++) {\\n            vector<int> v = guards[i];\\n            space[v[0]][v[1]]=1;\\n        }\\n        for(int i=0;i<guards.size();i++) {\\n            int x = guards[i][0];\\n            int y = guards[i][1];\\n            \\n            \\n            for(int j=x-1;j>=0;j--) {\\n                if(space[j][y]==-1 || space[j][y]==1) {\\n                    break;\\n                }\\n                space[j][y]=5;\\n            }\\n\\n            for(int j=x+1;j<m;j++) {\\n                if(space[j][y]==-1 || space[j][y]==1) {\\n                    break;\\n                }\\n                space[j][y]=5;\\n            }\\n\\n            for(int j=y-1;j>=0;j--) {\\n                if(space[x][j]==-1 || space[x][j]==1) {\\n                    break;\\n                }\\n                space[x][j]=5;\\n            }\\n            for(int j=y+1;j<n;j++) {\\n                if(space[x][j]==-1 || space[x][j]==1) {\\n                    break;\\n                }\\n                space[x][j]=5;\\n            }\\n        }\\n        int count =0;\\n        for(int i=0;i<m;i++) {\\n            for(int j = 0;j<n;j++) {\\n                if(space[i][j]==0) {\\n                    count++;\\n                }\\n            }\\n        }\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3244933,
                "title": "c-dfs",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    int countUnguarded(int m, int n, vector<vector<int>>& guards, vector<vector<int>>& walls) {\\n        int res = 0, used = walls.size() + guards.size();\\n        \\n        vector<vector<int>> dir = {{0, 1}, {1, 0}, {0, -1}, {-1, 0}};\\n        vector<vector<int>> grid(m, vector<int>(n, 0));\\n\\n        for (auto& g : guards) {\\n            grid[g[0]][g[1]] = 2;\\n        }\\n\\n        for (auto& w : walls) {\\n            grid[w[0]][w[1]] = 3;\\n        }\\n\\n        for (auto& d : dir) {\\n            for (auto& g : guards) {\\n                for (int i = g[0] + d[0], j = g[1] + d[1]; i >= 0 && i < m && j >= 0 && j < n; i += d[0], j += d[1]) {\\n                    if (grid[i][j] == 2 || grid[i][j] == 3) break;\\n                    if (grid[i][j] == 0) {\\n                        used++;\\n                        grid[i][j] = 1;\\n                    }\\n                }\\n            }\\n        }\\n        return m * n - used;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int countUnguarded(int m, int n, vector<vector<int>>& guards, vector<vector<int>>& walls) {\\n        int res = 0, used = walls.size() + guards.size();\\n        \\n        vector<vector<int>> dir = {{0, 1}, {1, 0}, {0, -1}, {-1, 0}};\\n        vector<vector<int>> grid(m, vector<int>(n, 0));\\n\\n        for (auto& g : guards) {\\n            grid[g[0]][g[1]] = 2;\\n        }\\n\\n        for (auto& w : walls) {\\n            grid[w[0]][w[1]] = 3;\\n        }\\n\\n        for (auto& d : dir) {\\n            for (auto& g : guards) {\\n                for (int i = g[0] + d[0], j = g[1] + d[1]; i >= 0 && i < m && j >= 0 && j < n; i += d[0], j += d[1]) {\\n                    if (grid[i][j] == 2 || grid[i][j] == 3) break;\\n                    if (grid[i][j] == 0) {\\n                        used++;\\n                        grid[i][j] = 1;\\n                    }\\n                }\\n            }\\n        }\\n        return m * n - used;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3199180,
                "title": "c",
                "content": "```\\n\\n\\nint countUnguarded(int m, int n, int** guards, int guardsSize, int* guardsColSize, int** walls, int wallsSize, int* wallsColSize){\\n    int i, j, k;\\n    int** data = (int**)malloc(m * sizeof(int*));\\n    for(i = 0; i < m ; i++){\\n        data[i] = calloc(n , sizeof(int));\\n    }\\n    int dir[4][2] = {{0,1},{0,-1},{1,0},{-1,0}} ;\\n\\n    for(int i = 0 ; i < guardsSize; i++){\\n        int r = guards[i][0] ;\\n        int c = guards[i][1] ;\\n        data[r][c] = 1 ;\\n    }\\n    \\n    for(int i = 0 ; i < wallsSize; i++){\\n        int r = walls[i][0] ;\\n        int c = walls[i][1] ;\\n        data[r][c] = 2 ;\\n    }\\n    \\n    for(int i = 0; i < guardsSize; i++){\\n        int r = guards[i][0] ;\\n        int c = guards[i][1] ;\\n        for(int k = 0; k < 4; k++){\\n            for(int j = 1; ; j++){\\n                int rr = r + dir[k][0]* j ;\\n                int cc = c + dir[k][1]* j ;\\n                if(rr < 0 || cc < 0 || rr >= m || cc >= n)\\n                    break ;\\n                if(data[rr][cc] == 2 || data[rr][cc] == 1)\\n                    break ;\\n                data[rr][cc] = 3 ;\\n            }\\n        }\\n    }\\n    \\n    int ans = 0 ;\\n    for(int i = 0; i < m ;i++){\\n        for(int j = 0; j < n; j++){\\n            if(data[i][j] == 0)\\n                ans++ ;\\n        }\\n        free(data[i]) ;\\n    }\\n    free(data) ;\\n    return ans;\\n}\\n```",
                "solutionTags": [],
                "code": "```\\n\\n\\nint countUnguarded(int m, int n, int** guards, int guardsSize, int* guardsColSize, int** walls, int wallsSize, int* wallsColSize){\\n    int i, j, k;\\n    int** data = (int**)malloc(m * sizeof(int*));\\n    for(i = 0; i < m ; i++){\\n        data[i] = calloc(n , sizeof(int));\\n    }\\n    int dir[4][2] = {{0,1},{0,-1},{1,0},{-1,0}} ;\\n\\n    for(int i = 0 ; i < guardsSize; i++){\\n        int r = guards[i][0] ;\\n        int c = guards[i][1] ;\\n        data[r][c] = 1 ;\\n    }\\n    \\n    for(int i = 0 ; i < wallsSize; i++){\\n        int r = walls[i][0] ;\\n        int c = walls[i][1] ;\\n        data[r][c] = 2 ;\\n    }\\n    \\n    for(int i = 0; i < guardsSize; i++){\\n        int r = guards[i][0] ;\\n        int c = guards[i][1] ;\\n        for(int k = 0; k < 4; k++){\\n            for(int j = 1; ; j++){\\n                int rr = r + dir[k][0]* j ;\\n                int cc = c + dir[k][1]* j ;\\n                if(rr < 0 || cc < 0 || rr >= m || cc >= n)\\n                    break ;\\n                if(data[rr][cc] == 2 || data[rr][cc] == 1)\\n                    break ;\\n                data[rr][cc] = 3 ;\\n            }\\n        }\\n    }\\n    \\n    int ans = 0 ;\\n    for(int i = 0; i < m ;i++){\\n        for(int j = 0; j < n; j++){\\n            if(data[i][j] == 0)\\n                ans++ ;\\n        }\\n        free(data[i]) ;\\n    }\\n    free(data) ;\\n    return ans;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3182552,
                "title": "rare-top-1-approach",
                "content": "\\n```\\nclass Solution {\\n    enum class CellState {\\n        Guard,\\n        Wall,\\n        GuardedV,\\n        GuardedH,\\n        GuardedBoth,\\n        Unguarded\\n    }\\n    \\n    fun countUnguarded(m: Int, n: Int, guards: Array<IntArray>, walls: Array<IntArray>): Int {\\n\\t\\t// Simulated grid\\n        val grid = Array<Array<CellState>>(m) { Array<CellState>(n) { CellState.Unguarded } }\\n        \\n\\t\\t// Placing walls\\n        for (wall in walls) grid[wall[0]][wall[1]] = CellState.Wall\\n\\t\\t\\n\\t\\t// Traversing the row\\n        fun guardHorizontal(x: Int, y: Int) {\\n\\t\\t\\t// Ensure we are within bounds\\n            if (x < 0 || x >= grid.size) return\\n            if (y < 0 || y >= grid[x].size) return\\n\\t\\t\\t\\n\\t\\t\\t// Stop moving when hit another guard or wall\\n            if (grid[x][y] == CellState.Guard || grid[x][y] == CellState.Wall) return\\n\\t\\t\\t\\n\\t\\t\\t// If the cell is already guarded by a guard on this row, we can stop moving\\n            if (grid[x][y] == CellState.GuardedH || grid[x][y] == CellState.GuardedBoth) return\\n            \\n\\t\\t\\t// If the cell is guarded by a guard on the crossing column mark cell as guarded both horizontally and vertically\\n\\t\\t\\t// Otherwise mark cell as guarded only horizontally\\n            grid[x][y] = if (grid[x][y] == CellState.Unguarded) CellState.GuardedH else CellState.GuardedBoth\\n\\t\\t\\t\\n\\t\\t\\t// Move both left and right from current cell\\n            guardHorizontal(x, y - 1)\\n            guardHorizontal(x, y + 1)\\n        }\\n        \\n\\t\\t// Traversing the column\\n        fun guardVertical(x: Int, y: Int) {\\n\\t\\t\\t// Ensure we are within bounds\\n            if (x < 0 || x >= grid.size) return\\n            if (y < 0 || y >= grid[x].size) return\\n\\t\\t\\t\\n\\t\\t\\t// Stop moving when hit another guard or wall\\n            if (grid[x][y] == CellState.Guard || grid[x][y] == CellState.Wall) return\\n\\t\\t\\t\\n\\t\\t\\t// If the cell is already guarded by a guard on this column, we can stop moving\\n            if (grid[x][y] == CellState.GuardedV || grid[x][y] == CellState.GuardedBoth) return\\n            \\n\\t\\t\\t// If the cell is already guarded by a guard on the crossing row mark cell as guarded both horizontally and vertically\\n\\t\\t\\t// Otherwise mark cell as guarded only vertically\\n            grid[x][y] = if (grid[x][y] == CellState.Unguarded) CellState.GuardedV else CellState.GuardedBoth\\n\\t\\t\\t\\n\\t\\t\\t// Move both up and down from current cell\\n            guardVertical(x + 1, y)\\n            guardVertical(x - 1, y)\\n        }\\n        \\n        // Guarding cells\\n        for (guard in guards) {\\n            grid[guard[0]][guard[1]] = CellState.Guard\\n\\t\\t\\t\\n\\t\\t\\t// Move up and down from guard\\'s position to mark cells as guarded\\n            guardVertical(guard[0] - 1, guard[1])\\n            guardVertical(guard[0] + 1, guard[1])\\n\\t\\t\\t\\n\\t\\t\\t// Move left and right from guard\\'s position to mark cells as guarded\\n            guardHorizontal(guard[0], guard[1] - 1)\\n            guardHorizontal(guard[0], guard[1] + 1)\\n        }\\n        \\n        // Counting unguarded cells\\n        var count = 0\\n        for (x in grid.indices)\\n            for (y in grid[x].indices) if (grid[x][y] == CellState.Unguarded) count++\\n        return count\\n    }\\n}\\n```",
                "solutionTags": [
                    "Kotlin"
                ],
                "code": "```\\nclass Solution {\\n    enum class CellState {\\n        Guard,\\n        Wall,\\n        GuardedV,\\n        GuardedH,\\n        GuardedBoth,\\n        Unguarded\\n    }\\n    \\n    fun countUnguarded(m: Int, n: Int, guards: Array<IntArray>, walls: Array<IntArray>): Int {\\n\\t\\t// Simulated grid\\n        val grid = Array<Array<CellState>>(m) { Array<CellState>(n) { CellState.Unguarded } }\\n        \\n\\t\\t// Placing walls\\n        for (wall in walls) grid[wall[0]][wall[1]] = CellState.Wall\\n\\t\\t\\n\\t\\t// Traversing the row\\n        fun guardHorizontal(x: Int, y: Int) {\\n\\t\\t\\t// Ensure we are within bounds\\n            if (x < 0 || x >= grid.size) return\\n            if (y < 0 || y >= grid[x].size) return\\n\\t\\t\\t\\n\\t\\t\\t// Stop moving when hit another guard or wall\\n            if (grid[x][y] == CellState.Guard || grid[x][y] == CellState.Wall) return\\n\\t\\t\\t\\n\\t\\t\\t// If the cell is already guarded by a guard on this row, we can stop moving\\n            if (grid[x][y] == CellState.GuardedH || grid[x][y] == CellState.GuardedBoth) return\\n            \\n\\t\\t\\t// If the cell is guarded by a guard on the crossing column mark cell as guarded both horizontally and vertically\\n\\t\\t\\t// Otherwise mark cell as guarded only horizontally\\n            grid[x][y] = if (grid[x][y] == CellState.Unguarded) CellState.GuardedH else CellState.GuardedBoth\\n\\t\\t\\t\\n\\t\\t\\t// Move both left and right from current cell\\n            guardHorizontal(x, y - 1)\\n            guardHorizontal(x, y + 1)\\n        }\\n        \\n\\t\\t// Traversing the column\\n        fun guardVertical(x: Int, y: Int) {\\n\\t\\t\\t// Ensure we are within bounds\\n            if (x < 0 || x >= grid.size) return\\n            if (y < 0 || y >= grid[x].size) return\\n\\t\\t\\t\\n\\t\\t\\t// Stop moving when hit another guard or wall\\n            if (grid[x][y] == CellState.Guard || grid[x][y] == CellState.Wall) return\\n\\t\\t\\t\\n\\t\\t\\t// If the cell is already guarded by a guard on this column, we can stop moving\\n            if (grid[x][y] == CellState.GuardedV || grid[x][y] == CellState.GuardedBoth) return\\n            \\n\\t\\t\\t// If the cell is already guarded by a guard on the crossing row mark cell as guarded both horizontally and vertically\\n\\t\\t\\t// Otherwise mark cell as guarded only vertically\\n            grid[x][y] = if (grid[x][y] == CellState.Unguarded) CellState.GuardedV else CellState.GuardedBoth\\n\\t\\t\\t\\n\\t\\t\\t// Move both up and down from current cell\\n            guardVertical(x + 1, y)\\n            guardVertical(x - 1, y)\\n        }\\n        \\n        // Guarding cells\\n        for (guard in guards) {\\n            grid[guard[0]][guard[1]] = CellState.Guard\\n\\t\\t\\t\\n\\t\\t\\t// Move up and down from guard\\'s position to mark cells as guarded\\n            guardVertical(guard[0] - 1, guard[1])\\n            guardVertical(guard[0] + 1, guard[1])\\n\\t\\t\\t\\n\\t\\t\\t// Move left and right from guard\\'s position to mark cells as guarded\\n            guardHorizontal(guard[0], guard[1] - 1)\\n            guardHorizontal(guard[0], guard[1] + 1)\\n        }\\n        \\n        // Counting unguarded cells\\n        var count = 0\\n        for (x in grid.indices)\\n            for (y in grid[x].indices) if (grid[x][y] == CellState.Unguarded) count++\\n        return count\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3143075,
                "title": "c-simulation",
                "content": "```\\nclass Solution {\\nprivate:\\n    int move(vector<vector<int>> &grid, vector<vector<bool>> &visited, int i, int j, string dir) {\\n        if(i < 0 || i >= grid.size() || j < 0 || j >= grid.at(i).size()) return 0;\\n\\n        // see a wall, go back\\n        if(grid.at(i).at(j) == 2) return 0;\\n\\n        // see a guard, go back\\n        if(grid.at(i).at(j) == 1) return 0;\\n\\n        // used to make sure we\\'re not over-counting already visited cells\\n        int num = visited.at(i).at(j) == false ? 1 : 0;\\n\\n        // cell is now visited\\n        visited.at(i).at(j) = true;\\n\\n        if(dir == \"up\")    return num + move(grid, visited, i - 1, j, dir);\\n        if(dir == \"down\")  return num + move(grid, visited, i + 1, j, dir);\\n        if(dir == \"left\")  return num + move(grid, visited, i, j - 1, dir);\\n        if(dir == \"right\") return num + move(grid, visited, i, j + 1, dir);\\n\\n        return 0; \\n    }\\n\\npublic:\\n    int countUnguarded(int m, int n, vector<vector<int>>& guards, vector<vector<int>>& walls) {\\n        vector<vector<int>> grid(m, vector<int>(n, 0));\\n\\n        vector<vector<bool>> visited(m, vector<bool>(n, false));\\n        \\n        // come across a guard\\n        for(vector<int> &coords : guards) \\n            grid.at(coords.at(0)).at(coords.at(1)) = 1;\\n\\n        // come across a wall\\n        for(vector<int> &coords : walls) \\n            grid.at(coords.at(0)).at(coords.at(1)) = 2;\\n\\n        // we do not count the guard nor the wall cells in our grid\\n        int totalCells = m * n - (guards.size() + walls.size());\\n\\n        // traversing grid based on simulation\\n        for(int i = 0; i < grid.size(); i++)\\n            for(int j = 0; j < grid.at(i).size(); j++)\\n                if(grid.at(i).at(j) == 1) { \\n                    totalCells -= move(grid, visited, i - 1, j, \"up\");\\n                    totalCells -= move(grid, visited, i + 1, j, \"down\");\\n                    totalCells -= move(grid, visited, i, j - 1, \"left\");\\n                    totalCells -= move(grid, visited, i, j + 1, \"right\");\\n                }\\n        \\n\\n\\n        return totalCells;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\nprivate:\\n    int move(vector<vector<int>> &grid, vector<vector<bool>> &visited, int i, int j, string dir) {\\n        if(i < 0 || i >= grid.size() || j < 0 || j >= grid.at(i).size()) return 0;\\n\\n        // see a wall, go back\\n        if(grid.at(i).at(j) == 2) return 0;\\n\\n        // see a guard, go back\\n        if(grid.at(i).at(j) == 1) return 0;\\n\\n        // used to make sure we\\'re not over-counting already visited cells\\n        int num = visited.at(i).at(j) == false ? 1 : 0;\\n\\n        // cell is now visited\\n        visited.at(i).at(j) = true;\\n\\n        if(dir == \"up\")    return num + move(grid, visited, i - 1, j, dir);\\n        if(dir == \"down\")  return num + move(grid, visited, i + 1, j, dir);\\n        if(dir == \"left\")  return num + move(grid, visited, i, j - 1, dir);\\n        if(dir == \"right\") return num + move(grid, visited, i, j + 1, dir);\\n\\n        return 0; \\n    }\\n\\npublic:\\n    int countUnguarded(int m, int n, vector<vector<int>>& guards, vector<vector<int>>& walls) {\\n        vector<vector<int>> grid(m, vector<int>(n, 0));\\n\\n        vector<vector<bool>> visited(m, vector<bool>(n, false));\\n        \\n        // come across a guard\\n        for(vector<int> &coords : guards) \\n            grid.at(coords.at(0)).at(coords.at(1)) = 1;\\n\\n        // come across a wall\\n        for(vector<int> &coords : walls) \\n            grid.at(coords.at(0)).at(coords.at(1)) = 2;\\n\\n        // we do not count the guard nor the wall cells in our grid\\n        int totalCells = m * n - (guards.size() + walls.size());\\n\\n        // traversing grid based on simulation\\n        for(int i = 0; i < grid.size(); i++)\\n            for(int j = 0; j < grid.at(i).size(); j++)\\n                if(grid.at(i).at(j) == 1) { \\n                    totalCells -= move(grid, visited, i - 1, j, \"up\");\\n                    totalCells -= move(grid, visited, i + 1, j, \"down\");\\n                    totalCells -= move(grid, visited, i, j - 1, \"left\");\\n                    totalCells -= move(grid, visited, i, j + 1, \"right\");\\n                }\\n        \\n\\n\\n        return totalCells;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3135379,
                "title": "java-simple-solution",
                "content": "\\n# Code\\n```\\nclass Solution {\\n    public int countUnguarded(int m, int n, int[][] guards, int[][] walls) {\\n        int[][] ground = new int[m][n];\\n\\n        for(int[] guard : guards){\\n            ground[guard[0]][guard[1]] = 1;\\n        }\\n        for(int[] wall : walls){\\n            ground[wall[0]][wall[1]] = 2;\\n        }\\n        \\n        for(int[] guard : guards){\\n            processGround(guard[0], guard[1], ground, m, n);\\n        }\\n        int count = 0;\\n\\n        for(int i = 0; i < m; i++){\\n            for(int j = 0; j < n; j++){\\n                if(ground[i][j] == 0)\\n                    count++;\\n            }\\n        }\\n\\n        return count;\\n    }\\n\\n    void processGround(int i, int j, int[][] ground, int m, int n){\\n        //Process TOP\\n        int tempI = i - 1; \\n        while(tempI >= 0){\\n            if(ground[tempI][j] == 0){\\n                ground[tempI][j] = 3;\\n            } else if(ground[tempI][j] != 3){\\n                break;\\n            }\\n            tempI--;\\n        }\\n\\n        //Process DOWN\\n        tempI = i + 1; \\n        while(tempI < m){\\n            if(ground[tempI][j] == 0){\\n                ground[tempI][j] = 3;\\n            } else if(ground[tempI][j] != 3){\\n                break;\\n            }\\n            tempI++;\\n        }\\n\\n        //Process LEFT\\n        int tempJ = j - 1; \\n        while(tempJ >= 0){\\n            if(ground[i][tempJ] == 0){\\n                ground[i][tempJ] = 3;\\n            } else if(ground[i][tempJ] != 3){\\n                break;\\n            }\\n            tempJ--;\\n        }\\n\\n        //Process RIGHT\\n        tempJ = j + 1; \\n        while(tempJ < n){\\n            if(ground[i][tempJ] == 0){\\n                ground[i][tempJ] = 3;\\n            } else if(ground[i][tempJ] != 3){\\n                break;\\n            }\\n            tempJ++;\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int countUnguarded(int m, int n, int[][] guards, int[][] walls) {\\n        int[][] ground = new int[m][n];\\n\\n        for(int[] guard : guards){\\n            ground[guard[0]][guard[1]] = 1;\\n        }\\n        for(int[] wall : walls){\\n            ground[wall[0]][wall[1]] = 2;\\n        }\\n        \\n        for(int[] guard : guards){\\n            processGround(guard[0], guard[1], ground, m, n);\\n        }\\n        int count = 0;\\n\\n        for(int i = 0; i < m; i++){\\n            for(int j = 0; j < n; j++){\\n                if(ground[i][j] == 0)\\n                    count++;\\n            }\\n        }\\n\\n        return count;\\n    }\\n\\n    void processGround(int i, int j, int[][] ground, int m, int n){\\n        //Process TOP\\n        int tempI = i - 1; \\n        while(tempI >= 0){\\n            if(ground[tempI][j] == 0){\\n                ground[tempI][j] = 3;\\n            } else if(ground[tempI][j] != 3){\\n                break;\\n            }\\n            tempI--;\\n        }\\n\\n        //Process DOWN\\n        tempI = i + 1; \\n        while(tempI < m){\\n            if(ground[tempI][j] == 0){\\n                ground[tempI][j] = 3;\\n            } else if(ground[tempI][j] != 3){\\n                break;\\n            }\\n            tempI++;\\n        }\\n\\n        //Process LEFT\\n        int tempJ = j - 1; \\n        while(tempJ >= 0){\\n            if(ground[i][tempJ] == 0){\\n                ground[i][tempJ] = 3;\\n            } else if(ground[i][tempJ] != 3){\\n                break;\\n            }\\n            tempJ--;\\n        }\\n\\n        //Process RIGHT\\n        tempJ = j + 1; \\n        while(tempJ < n){\\n            if(ground[i][tempJ] == 0){\\n                ground[i][tempJ] = 3;\\n            } else if(ground[i][tempJ] != 3){\\n                break;\\n            }\\n            tempJ++;\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3115079,
                "title": "python-dfs",
                "content": "```\\nclass Solution:\\n    def countUnguarded(self, m, n, guards, walls):\\n        def goLeft(i, j):\\n            if j < 0 or (i, j) in walls or (i, j) in guards:\\n                return\\n            seen.add((i, j))\\n            goLeft(i, j - 1)\\n        def goRight(i, j):\\n            if j >= n or (i, j) in walls or (i, j) in guards:\\n                return\\n            seen.add((i, j))\\n            goRight(i, j + 1)\\n        def goBottom(i, j):\\n            if i >= m or (i, j) in walls or (i, j) in guards:\\n                return\\n            seen.add((i, j))\\n            goBottom(i + 1, j)\\n        def goUp(i, j):\\n            if i < 0 or (i, j) in walls or (i, j) in guards:\\n                return\\n            seen.add((i, j))\\n            goUp(i - 1, j)\\n        walls = set((i, j) for i, j in walls)\\n        guards = set((i, j) for i, j in guards)\\n        seen = set()\\n        for i, j in guards:\\n            goLeft(i, j - 1)\\n            goRight(i, j + 1)\\n            goBottom(i + 1, j)\\n            goUp(i - 1, j)\\n        return (m * n) - len(walls) - len(guards) - len(seen)\\n\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def countUnguarded(self, m, n, guards, walls):\\n        def goLeft(i, j):\\n            if j < 0 or (i, j) in walls or (i, j) in guards:\\n                return\\n            seen.add((i, j))\\n            goLeft(i, j - 1)\\n        def goRight(i, j):\\n            if j >= n or (i, j) in walls or (i, j) in guards:\\n                return\\n            seen.add((i, j))\\n            goRight(i, j + 1)\\n        def goBottom(i, j):\\n            if i >= m or (i, j) in walls or (i, j) in guards:\\n                return\\n            seen.add((i, j))\\n            goBottom(i + 1, j)\\n        def goUp(i, j):\\n            if i < 0 or (i, j) in walls or (i, j) in guards:\\n                return\\n            seen.add((i, j))\\n            goUp(i - 1, j)\\n        walls = set((i, j) for i, j in walls)\\n        guards = set((i, j) for i, j in guards)\\n        seen = set()\\n        for i, j in guards:\\n            goLeft(i, j - 1)\\n            goRight(i, j + 1)\\n            goBottom(i + 1, j)\\n            goUp(i - 1, j)\\n        return (m * n) - len(walls) - len(guards) - len(seen)\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3111093,
                "title": "python-binary-search",
                "content": "Step 1. Setup the grid assigning walls and guards to their respective positions\\nStep 2. Loop through the grid and append to our lists so that each of our row and column lists are in sorted order\\nStep 3. Loop through the grid again and if we see and empty column binary search for guards left/right and up/down from our posion using the lists we setup in step 2\\nStep 4. If we do not see any guards add 1 to the result. At the end return our result\\n\\n\\n```\\nclass Solution:\\n    def countUnguarded(self, m: int, n: int, guards: List[List[int]], walls: List[List[int]]) -> int:\\n        \\n        \\n        gMap = defaultdict(list)\\n        \\n        grid = [[0 for j in range(n)] for i in range(m)]\\n        \\n        \\n        for x,y in guards:\\n            \\n            grid[x][y] = \\'G\\'\\n\\n\\n        for x,y in walls:\\n            \\n            grid[x][y] = \\'W\\'\\n\\n\\n        for r in range(m):\\n            for c in range(n):\\n                if grid[r][c] != 0:\\n                    val = grid[r][c]\\n                    gMap[\\'r\\' + str(r)].append((c,val))\\n                    gMap[\\'c\\' + str(c)].append((r,val))\\n        \\n  \\n        res = 0\\n        for r in range(m):\\n            for c in range(n):\\n                if grid[r][c] == 0:\\n                    #scan for closest between row/col up/down left/right if all W or out of bounds its good\\n                    #if any are guards its not good\\n                    arrC = gMap[\\'r\\' + str(r)]\\n                    arrR = gMap[\\'c\\' + str(c)]\\n                    cIdx = 0\\n                    rIdx = 0\\n                    \\n                    #scan for guards watching us\\n                    if len(arrC) > 0:\\n                        cIdx = bisect.bisect_left(arrC, c,key=lambda i: i[0])\\n                        cIdx -=1\\n                        if cIdx >= 0 and arrC[cIdx][1] == \\'G\\' or cIdx + 1 < len(arrC) and arrC[cIdx+1][1] == \\'G\\':\\n                            continue\\n                            \\n                    if len(arrR) > 0:\\n                        rIdx = bisect.bisect_left(arrR, r,key=lambda i: i[0])\\n                        rIdx -=1\\n                        if rIdx >= 0 and arrR[rIdx][1] == \\'G\\' or rIdx + 1 < len(arrR) and arrR[rIdx+1][1] == \\'G\\':\\n                            continue\\n\\n                    res +=1\\n        \\n        \\n        return res\\n                \\n\\t\\t\\t\\t",
                "solutionTags": [
                    "Python",
                    "Binary Search"
                ],
                "code": "Step 1. Setup the grid assigning walls and guards to their respective positions\\nStep 2. Loop through the grid and append to our lists so that each of our row and column lists are in sorted order\\nStep 3. Loop through the grid again and if we see and empty column binary search for guards left/right and up/down from our posion using the lists we setup in step 2\\nStep 4. If we do not see any guards add 1 to the result. At the end return our result\\n\\n\\n```\\nclass Solution:\\n    def countUnguarded(self, m: int, n: int, guards: List[List[int]], walls: List[List[int]]) -> int:\\n        \\n        \\n        gMap = defaultdict(list)\\n        \\n        grid = [[0 for j in range(n)] for i in range(m)]\\n        \\n        \\n        for x,y in guards:\\n            \\n            grid[x][y] = \\'G\\'\\n\\n\\n        for x,y in walls:\\n            \\n            grid[x][y] = \\'W\\'\\n\\n\\n        for r in range(m):\\n            for c in range(n):\\n                if grid[r][c] != 0:\\n                    val = grid[r][c]\\n                    gMap[\\'r\\' + str(r)].append((c,val))\\n                    gMap[\\'c\\' + str(c)].append((r,val))\\n        \\n  \\n        res = 0\\n        for r in range(m):\\n            for c in range(n):\\n                if grid[r][c] == 0:\\n                    #scan for closest between row/col up/down left/right if all W or out of bounds its good\\n                    #if any are guards its not good\\n                    arrC = gMap[\\'r\\' + str(r)]\\n                    arrR = gMap[\\'c\\' + str(c)]\\n                    cIdx = 0\\n                    rIdx = 0\\n                    \\n                    #scan for guards watching us\\n                    if len(arrC) > 0:\\n                        cIdx = bisect.bisect_left(arrC, c,key=lambda i: i[0])\\n                        cIdx -=1\\n                        if cIdx >= 0 and arrC[cIdx][1] == \\'G\\' or cIdx + 1 < len(arrC) and arrC[cIdx+1][1] == \\'G\\':\\n                            continue\\n                            \\n                    if len(arrR) > 0:\\n                        rIdx = bisect.bisect_left(arrR, r,key=lambda i: i[0])\\n                        rIdx -=1\\n                        if rIdx >= 0 and arrR[rIdx][1] == \\'G\\' or rIdx + 1 < len(arrR) and arrR[rIdx+1][1] == \\'G\\':\\n                            continue\\n\\n                    res +=1\\n        \\n        \\n        return res\\n                \\n\\t\\t\\t\\t",
                "codeTag": "Java"
            },
            {
                "id": 3104334,
                "title": "c-easy-to-understand-code",
                "content": "# Approach\\n- Create a grid or visited matrix of m rows and n columns \\nInitialise it to 0 \\n- Now traverse and mark guards cell with 2 and walls cell with -2\\n- Now traverse the grid cell with value 2\\nand traverse linerally uptil maximum row/column value \\nand mark the cell as 1 i.e they are visited, guarded by gurad.\\n- Now count all the remaining cells with 0. This will give the cells which remain unguarded.\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n\\n    vector<int> dx={0,-1,1,0};\\n    vector<int> dy={-1,0,0,1};\\n\\n    \\n    int countUnguarded(int m, int n, vector<vector<int>>& guards, vector<vector<int>>& walls) {\\n        \\n        vector<vector<int>> grid(m,vector<int>(n,0));\\n\\n        for(int i=0;i<guards.size();i++){\\n            int x=guards[i][0];\\n            int y=guards[i][1];\\n            grid[x][y]=2;\\n        }\\n\\n        for(int i=0;i<walls.size();i++){\\n            int x=walls[i][0];\\n            int y=walls[i][1];\\n            grid[x][y]=-2;\\n        }\\n\\n        for(int i=0;i<m;i++){\\n            for(int j=0;j<n;j++){\\n                if(grid[i][j]==2){                    \\n                    for(int k=0;k<4;k++){\\n                        int nx=i+dx[k];\\n                        int ny=j+dy[k];\\n                            while(nx>=0 && nx<m && ny>=0 && ny<n && (grid[nx][ny]==0 ||grid[nx][ny]==1)){\\n                                grid[nx][ny]=1;\\n                                nx+=dx[k];\\n                                ny+=dy[k];\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n\\n        int count=0;\\n        for(int i=0;i<m;i++){\\n            for(int j=0;j<n;j++){\\n                if(grid[i][j]==0)count++;\\n            }\\n        }\\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Graph"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\n    vector<int> dx={0,-1,1,0};\\n    vector<int> dy={-1,0,0,1};\\n\\n    \\n    int countUnguarded(int m, int n, vector<vector<int>>& guards, vector<vector<int>>& walls) {\\n        \\n        vector<vector<int>> grid(m,vector<int>(n,0));\\n\\n        for(int i=0;i<guards.size();i++){\\n            int x=guards[i][0];\\n            int y=guards[i][1];\\n            grid[x][y]=2;\\n        }\\n\\n        for(int i=0;i<walls.size();i++){\\n            int x=walls[i][0];\\n            int y=walls[i][1];\\n            grid[x][y]=-2;\\n        }\\n\\n        for(int i=0;i<m;i++){\\n            for(int j=0;j<n;j++){\\n                if(grid[i][j]==2){                    \\n                    for(int k=0;k<4;k++){\\n                        int nx=i+dx[k];\\n                        int ny=j+dy[k];\\n                            while(nx>=0 && nx<m && ny>=0 && ny<n && (grid[nx][ny]==0 ||grid[nx][ny]==1)){\\n                                grid[nx][ny]=1;\\n                                nx+=dx[k];\\n                                ny+=dy[k];\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n\\n        int count=0;\\n        for(int i=0;i<m;i++){\\n            for(int j=0;j<n;j++){\\n                if(grid[i][j]==0)count++;\\n            }\\n        }\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3077764,
                "title": "beats-98-easy-java-solution",
                "content": "\\n\\n# Complexity\\n- Time complexity:\\nO(N^2)\\n\\n- Space complexity:\\nO(N)\\n\\n# Code\\n```\\nclass Solution {\\n    public int countUnguarded(int m, int n, int[][] guards, int[][] walls) {\\n        \\n    //2 is for guards\\n    //1 is for walls\\n\\n    int[][]grid=new int[m][n];\\n\\n    //filling up the coordinates of guarded cell\\n    for(int i=0;i<guards.length;i++){\\n        grid[guards[i][0]][guards[i][1]]=2;\\n    }\\n    //filling up the coordinates of walls cell\\n    for(int i=0;i<walls.length;i++){\\n        grid[walls[i][0]][walls[i][1]]=1;\\n    }\\n\\n    for(int i=0;i<grid.length;i++){\\n\\n        for(int j=0;j<grid[0].length;j++){\\n\\n        if(grid[i][j]==2){\\n        \\n        //for up\\n        int p=i-1;\\n        int o=j;\\n        while(p>=0&&(grid[p][o]==0||grid[p][o]==-1)){\\n            grid[p][o]=-1;\\n            p--;\\n        }\\n        //for down\\n        p=i+1;\\n        o=j;\\n        while(p<grid.length&&(grid[p][o]==0||grid[p][o]==-1)){\\n            grid[p][o]=-1;\\n            p++;\\n        }\\n        //for left\\n        p=i;\\n        o=j-1;\\n        while(o>=0&&(grid[p][o]==0||grid[p][o]==-1)){\\n            grid[p][o]=-1;\\n            o--;\\n        }\\n        //for right\\n        p=i;\\n        o=j+1;\\n        while(o<grid[0].length&&(grid[p][o]==0||grid[p][o]==-1))\\n        {\\n            grid[p][o]=-1;\\n            o++;\\n        }\\n\\n        }\\n\\n        }\\n    }\\n\\n    int count=0;\\n\\n    for(int i=0;i<grid.length;i++){\\n        for(int j=0;j<grid[0].length;j++){\\n            if(grid[i][j]==0)count++;\\n        }\\n    }\\n\\n    return count;\\n\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Matrix",
                    "Simulation"
                ],
                "code": "```\\nclass Solution {\\n    public int countUnguarded(int m, int n, int[][] guards, int[][] walls) {\\n        \\n    //2 is for guards\\n    //1 is for walls\\n\\n    int[][]grid=new int[m][n];\\n\\n    //filling up the coordinates of guarded cell\\n    for(int i=0;i<guards.length;i++){\\n        grid[guards[i][0]][guards[i][1]]=2;\\n    }\\n    //filling up the coordinates of walls cell\\n    for(int i=0;i<walls.length;i++){\\n        grid[walls[i][0]][walls[i][1]]=1;\\n    }\\n\\n    for(int i=0;i<grid.length;i++){\\n\\n        for(int j=0;j<grid[0].length;j++){\\n\\n        if(grid[i][j]==2){\\n        \\n        //for up\\n        int p=i-1;\\n        int o=j;\\n        while(p>=0&&(grid[p][o]==0||grid[p][o]==-1)){\\n            grid[p][o]=-1;\\n            p--;\\n        }\\n        //for down\\n        p=i+1;\\n        o=j;\\n        while(p<grid.length&&(grid[p][o]==0||grid[p][o]==-1)){\\n            grid[p][o]=-1;\\n            p++;\\n        }\\n        //for left\\n        p=i;\\n        o=j-1;\\n        while(o>=0&&(grid[p][o]==0||grid[p][o]==-1)){\\n            grid[p][o]=-1;\\n            o--;\\n        }\\n        //for right\\n        p=i;\\n        o=j+1;\\n        while(o<grid[0].length&&(grid[p][o]==0||grid[p][o]==-1))\\n        {\\n            grid[p][o]=-1;\\n            o++;\\n        }\\n\\n        }\\n\\n        }\\n    }\\n\\n    int count=0;\\n\\n    for(int i=0;i<grid.length;i++){\\n        for(int j=0;j<grid[0].length;j++){\\n            if(grid[i][j]==0)count++;\\n        }\\n    }\\n\\n    return count;\\n\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3050780,
                "title": "linear-array-representation-strategy",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nGuards shouldn\\'t make attempts in directions they can\\'t visit (borders/walls/other guards). Should iterate and observe through all the guards.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nEventually got to an idea to decrease the time complexity to represent the matrix as a **linear Array**. This strategy helped a lot where each column and row cell can be defined by multiplying on either `m` or `n`. All the description of my approach in details can be found inside comments of the code itself.\\n\\n# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\ntype Guard = number[]\\ntype Guards = Guard[]\\ntype Cells = Map<number, boolean | null>\\n\\nfunction getCell(posM: number, posN: number, n: number): number {\\n    return posM * n + posN\\n}\\n\\nfunction guardObserve(guard: Guard, m: number, n: number, cells: Cells): void {\\n    // A dictionary of possible directions\\n    // As well an initial state\\n    const directionsVisited = {\\n        top: false,\\n        right: false,\\n        bottom: false,\\n        left: false\\n    }\\n\\n    const [gM, gN] = guard\\n    const guardCell = getCell(gM, gN, n)\\n\\n    // define the directions we don\\'t need to visit if it hits the border\\n    if(gM === 0) directionsVisited.top = true\\n    if(gN === 0) directionsVisited.left = true\\n    if(gM === m - 1) directionsVisited.bottom = true\\n    if(gN === n - 1) directionsVisited.right = true\\n\\n    const directions = (Object.keys(directionsVisited) as [keyof typeof  directionsVisited]).filter(d => !directionsVisited[d])\\n\\n    dLoop: for(let direction of directions) {\\n        let cell = guardCell\\n        let isBorder = false\\n        let nextCell: boolean | null | undefined;\\n\\n        // Goes through all the cells till it reaches the border OR next guard OR wall\\n        // Then we start over with another direction (that\\'s why we need for loop label)\\n        while(!isBorder) {\\n            switch(direction) {\\n                case \\'top\\':\\n                    cell -= n\\n                    nextCell = cells.get(cell)\\n                    isBorder = !(cell >= 0) || nextCell === null\\n\\n                    if(isBorder) continue dLoop\\n\\n                    if(nextCell !== null) {\\n                        cells.set(cell, true)\\n                    }\\n                    break;\\n                case \\'right\\':\\n                    cell++\\n                    nextCell = cells.get(cell)\\n                    isBorder = (cell + 1) % n === 0 || nextCell === null\\n\\n                    if(nextCell !== null) {\\n                        cells.set(cell, true)\\n                    }\\n\\n                    if(isBorder) continue dLoop\\n                    break;\\n                case \\'bottom\\':\\n                    cell += n\\n                    nextCell = cells.get(cell)\\n                    isBorder = !(cell <= cells.size) || nextCell === null\\n\\n                    if(isBorder) continue dLoop\\n\\n                    if(nextCell !== null) {\\n                        cells.set(cell, true)\\n                    }\\n                    break;\\n                case \\'left\\':\\n                    cell--\\n                    nextCell = cells.get(cell)\\n                    isBorder = cell % n === 0 || nextCell === null\\n\\n                    if(nextCell !== null) {\\n                        cells.set(cell, true)\\n                    }\\n\\n                    if(isBorder) continue dLoop\\n                    break;\\n            }\\n        }\\n    }\\n\\n}\\n\\n\\nfunction countUnguarded(m: number, n: number, guards: Guards, walls: number[][]): number {\\n//    Strategy:\\n// - create map of visits\\n// - apply walls & guards as null in visits\\n// - make a function that will move guards with constraints\\n// - calculate unvisited\\n    let cells: Cells = new Map([...Array(m * n).keys()].map(key => ([key, false])))\\n\\n    // Mark the cells with wall or guards to use them as boundaries\\n    // in further calculations\\n    for(let [wM, wN] of [...walls, ...guards]) {\\n        cells.set(getCell(wM, wN, n), null)\\n    }\\n\\n    // Iterate through each guard and calculate visits\\n    for(let guard of guards) {\\n        guardObserve(guard, m, n, cells)\\n    }\\n\\n    // Simply return all the unvisited cells\\n    return [...cells].reduce((counter, [_, flag]) => flag !== null && !flag ? ++counter : counter, 0)\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "TypeScript",
                    "Array",
                    "Dynamic Programming"
                ],
                "code": "```\\ntype Guard = number[]\\ntype Guards = Guard[]\\ntype Cells = Map<number, boolean | null>\\n\\nfunction getCell(posM: number, posN: number, n: number): number {\\n    return posM * n + posN\\n}\\n\\nfunction guardObserve(guard: Guard, m: number, n: number, cells: Cells): void {\\n    // A dictionary of possible directions\\n    // As well an initial state\\n    const directionsVisited = {\\n        top: false,\\n        right: false,\\n        bottom: false,\\n        left: false\\n    }\\n\\n    const [gM, gN] = guard\\n    const guardCell = getCell(gM, gN, n)\\n\\n    // define the directions we don\\'t need to visit if it hits the border\\n    if(gM === 0) directionsVisited.top = true\\n    if(gN === 0) directionsVisited.left = true\\n    if(gM === m - 1) directionsVisited.bottom = true\\n    if(gN === n - 1) directionsVisited.right = true\\n\\n    const directions = (Object.keys(directionsVisited) as [keyof typeof  directionsVisited]).filter(d => !directionsVisited[d])\\n\\n    dLoop: for(let direction of directions) {\\n        let cell = guardCell\\n        let isBorder = false\\n        let nextCell: boolean | null | undefined;\\n\\n        // Goes through all the cells till it reaches the border OR next guard OR wall\\n        // Then we start over with another direction (that\\'s why we need for loop label)\\n        while(!isBorder) {\\n            switch(direction) {\\n                case \\'top\\':\\n                    cell -= n\\n                    nextCell = cells.get(cell)\\n                    isBorder = !(cell >= 0) || nextCell === null\\n\\n                    if(isBorder) continue dLoop\\n\\n                    if(nextCell !== null) {\\n                        cells.set(cell, true)\\n                    }\\n                    break;\\n                case \\'right\\':\\n                    cell++\\n                    nextCell = cells.get(cell)\\n                    isBorder = (cell + 1) % n === 0 || nextCell === null\\n\\n                    if(nextCell !== null) {\\n                        cells.set(cell, true)\\n                    }\\n\\n                    if(isBorder) continue dLoop\\n                    break;\\n                case \\'bottom\\':\\n                    cell += n\\n                    nextCell = cells.get(cell)\\n                    isBorder = !(cell <= cells.size) || nextCell === null\\n\\n                    if(isBorder) continue dLoop\\n\\n                    if(nextCell !== null) {\\n                        cells.set(cell, true)\\n                    }\\n                    break;\\n                case \\'left\\':\\n                    cell--\\n                    nextCell = cells.get(cell)\\n                    isBorder = cell % n === 0 || nextCell === null\\n\\n                    if(nextCell !== null) {\\n                        cells.set(cell, true)\\n                    }\\n\\n                    if(isBorder) continue dLoop\\n                    break;\\n            }\\n        }\\n    }\\n\\n}\\n\\n\\nfunction countUnguarded(m: number, n: number, guards: Guards, walls: number[][]): number {\\n//    Strategy:\\n// - create map of visits\\n// - apply walls & guards as null in visits\\n// - make a function that will move guards with constraints\\n// - calculate unvisited\\n    let cells: Cells = new Map([...Array(m * n).keys()].map(key => ([key, false])))\\n\\n    // Mark the cells with wall or guards to use them as boundaries\\n    // in further calculations\\n    for(let [wM, wN] of [...walls, ...guards]) {\\n        cells.set(getCell(wM, wN, n), null)\\n    }\\n\\n    // Iterate through each guard and calculate visits\\n    for(let guard of guards) {\\n        guardObserve(guard, m, n, cells)\\n    }\\n\\n    // Simply return all the unvisited cells\\n    return [...cells].reduce((counter, [_, flag]) => flag !== null && !flag ? ++counter : counter, 0)\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3049746,
                "title": "c-dfs",
                "content": "```\\nclass Solution {\\npublic:\\n    void right(int i,int j,int m,int n,vector<vector<char>>&arr,vector<vector<bool>>&visited){\\n        \\n        if(i<0 || j<0 || i>=m || j>=n || arr[i][j]==\\'W\\' || arr[i][j]==\\'G\\'){\\n            return;\\n        }\\n        visited[i][j]=true;\\n        right(i,j+1,m,n,arr,visited);\\n    }\\n    void left(int i,int j,int m,int n,vector<vector<char>>&arr,vector<vector<bool>>&visited){\\n       \\n        if(i<0 || j<0 || i>=m || j>=n || arr[i][j]==\\'W\\' || arr[i][j]==\\'G\\'){\\n            return;\\n        }\\n        visited[i][j]=true;\\n        left(i,j-1,m,n,arr,visited);\\n    }\\n    void down(int i,int j,int m,int n,vector<vector<char>>&arr,vector<vector<bool>>&visited){\\n        \\n        if(i<0 || j<0 || i>=m || j>=n || arr[i][j]==\\'W\\' || arr[i][j]==\\'G\\'){\\n            return;\\n        }\\n        visited[i][j]=true;\\n        down(i+1,j,m,n,arr,visited);\\n    }\\n    void up(int i,int j,int m,int n,vector<vector<char>>&arr,vector<vector<bool>>&visited){\\n        \\n        if(i<0 || j<0 || i>=m || j>=n || arr[i][j]==\\'W\\' || arr[i][j]==\\'G\\'){\\n            return;\\n        }\\n        visited[i][j]=true;\\n        up(i-1,j,m,n,arr,visited);\\n    }\\n    int countUnguarded(int m, int n, vector<vector<int>>& guards, vector<vector<int>>& walls) {\\n        \\n        vector<vector<char>> arr(m,vector<char>(n,\\'.\\'));\\n        for(int i=0;i<guards.size();i++){\\n            \\n            int row=guards[i][0];\\n            int col=guards[i][1];\\n            arr[row][col]=\\'G\\';\\n        }\\n        for(int i=0;i<walls.size();i++){\\n            \\n            int row=walls[i][0];\\n            int col=walls[i][1];\\n            arr[row][col]=\\'W\\';\\n        }\\n        vector<vector<bool>> visited(m,vector<bool>(n,false));\\n        for(int i=0;i<m;i++){\\n            for(int j=0;j<n;j++){\\n                \\n                if(arr[i][j]==\\'G\\'){\\n                    \\n                    up(i-1,j,m,n,arr,visited);\\n                    down(i+1,j,m,n,arr,visited);\\n                    left(i,j-1,m,n,arr,visited);\\n                    right(i,j+1,m,n,arr,visited);\\n                }\\n            }\\n        }\\n        long long count=0;\\n        for(int i=0;i<m;i++){\\n            for(int j=0;j<n;j++){\\n                \\n                if(arr[i][j]!=\\'G\\' && arr[i][j]!=\\'W\\' && visited[i][j]!=true){\\n                    count++;\\n                }\\n            }\\n        }\\n        return count;\\n    }\\n};",
                "solutionTags": [
                    "Depth-First Search",
                    "Matrix"
                ],
                "code": "class Solution {\\npublic:\\n    void right(int i,int j,int m,int n,vector<vector<char>>&arr,vector<vector<bool>>&visited){\\n        \\n        if(i<0 || j<0 || i>=m || j>=n || arr[i][j]==\\'W\\' || arr[i][j]==\\'G\\'){\\n            return;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 3023734,
                "title": "c-faster-than-99-loop-through-guards",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nSimply loop thourgh all guards to see how many cells are watched. \\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nUse a ```vector<string> cells``` to store the states of cells: \\n- \\'w\\': cell occupied by a wall\\n- \\'g\\': cell occupied by a guard\\n- \\'h\\': cell watched horizonally\\n- \\'v\\': cell watched vertically\\n- \\'b\\': cell watched both horizonally & vertically\\n- \\'u\\': cell unwatched and unoccupied\\n\\n\\'h\\' and \\'v\\' are defined to reduce redundant check.  \\n\\nWe assume that all cells are \\'u\\' at first. Thus the result would be initialized as ```int res = m * n;```\\n\\nFirst step, mark all walls and guards. Everytime a cell is occupied, ```--res;```\\n\\nSecond step, go through all ```guards``` to mark watched cells. When going vertically, switch case the cell\\n- \\'u\\': subtract ```res``` and mark it as \\'v\\';\\n- \\'v\\' or \\'b\\': cell has been checked by another guard, so this cell and all other cells vertically after it do not need to be checked\\n- \\'w\\': there is a wall, so this cell and all cells vertically after it are not watched by this guard\\n- \\'h\\': this cell is watched horizonally, so ```res``` should not decrease by 1; despite, we are not sure whether the cells vertically after it is checked, so the loop should go on\\n\\nThe horizonal checking is similar to the steps above. \\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nWorst case $O(m*n)$: when guards are placed across all rows and columns\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n$O(m*n)$, the recording strings\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int countUnguarded(int m, int n, vector<vector<int>>& guards, vector<vector<int>>& walls) {\\n        vector<string> cells(m, string(n, \\'u\\')); // unguarded\\n        int res = m*n;\\n        for ( vector<int>& w: walls ){\\n            --res;\\n            cells[w[0]][w[1]] = \\'w\\';\\n        }\\n        for ( vector<int>& g: guards ){\\n            --res;\\n            cells[g[0]][g[1]] = \\'g\\';\\n        }\\n        for ( vector<int>& g: guards ){\\n            bool stop = false;\\n            for ( int i = g[0]-1; ~i && !stop ; --i ){\\n                char& c = cells[i][g[1]];\\n                switch ( c ){\\n                    case \\'u\\': {--res; c = \\'v\\';} break;\\n                    case \\'h\\': c = \\'b\\'; break;\\n                    default: stop = true;\\n                }\\n            }\\n            stop = false;\\n            for ( int i = g[0]+1; i != m && !stop ; ++i ){\\n                char& c = cells[i][g[1]];\\n                switch ( c ){\\n                    case \\'u\\': {--res; c = \\'v\\';} break;\\n                    case \\'h\\': c = \\'b\\'; break;\\n                    default: stop = true;\\n                }\\n            }\\n            stop = false;\\n            for ( int j = g[1]-1; ~j && !stop ; --j ){\\n                char& c = cells[g[0]][j];\\n                switch ( c ){\\n                    case \\'u\\': {--res; c = \\'h\\';} break;\\n                    case \\'v\\': c = \\'b\\'; break;\\n                    default: stop = true;\\n                }\\n            }\\n            stop = false;\\n            for ( int j = g[1]+1; j != n && !stop ; ++j ){\\n                char& c = cells[g[0]][j];\\n                switch ( c ){\\n                    case \\'u\\': {--res; c = \\'h\\';} break;\\n                    case \\'v\\': c = \\'b\\'; break;\\n                    default: stop = true;\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```vector<string> cells```\n```int res = m * n;```\n```--res;```\n```guards```\n```res```\n```res```\n```\\nclass Solution {\\npublic:\\n    int countUnguarded(int m, int n, vector<vector<int>>& guards, vector<vector<int>>& walls) {\\n        vector<string> cells(m, string(n, \\'u\\')); // unguarded\\n        int res = m*n;\\n        for ( vector<int>& w: walls ){\\n            --res;\\n            cells[w[0]][w[1]] = \\'w\\';\\n        }\\n        for ( vector<int>& g: guards ){\\n            --res;\\n            cells[g[0]][g[1]] = \\'g\\';\\n        }\\n        for ( vector<int>& g: guards ){\\n            bool stop = false;\\n            for ( int i = g[0]-1; ~i && !stop ; --i ){\\n                char& c = cells[i][g[1]];\\n                switch ( c ){\\n                    case \\'u\\': {--res; c = \\'v\\';} break;\\n                    case \\'h\\': c = \\'b\\'; break;\\n                    default: stop = true;\\n                }\\n            }\\n            stop = false;\\n            for ( int i = g[0]+1; i != m && !stop ; ++i ){\\n                char& c = cells[i][g[1]];\\n                switch ( c ){\\n                    case \\'u\\': {--res; c = \\'v\\';} break;\\n                    case \\'h\\': c = \\'b\\'; break;\\n                    default: stop = true;\\n                }\\n            }\\n            stop = false;\\n            for ( int j = g[1]-1; ~j && !stop ; --j ){\\n                char& c = cells[g[0]][j];\\n                switch ( c ){\\n                    case \\'u\\': {--res; c = \\'h\\';} break;\\n                    case \\'v\\': c = \\'b\\'; break;\\n                    default: stop = true;\\n                }\\n            }\\n            stop = false;\\n            for ( int j = g[1]+1; j != n && !stop ; ++j ){\\n                char& c = cells[g[0]][j];\\n                switch ( c ){\\n                    case \\'u\\': {--res; c = \\'h\\';} break;\\n                    case \\'v\\': c = \\'b\\'; break;\\n                    default: stop = true;\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3015518,
                "title": "c-easy-to-understand-simple-solution",
                "content": "\\n# Code\\n```\\npublic class Solution {\\n    int[][] grid;\\n    int maxRow;\\n    int maxCol;\\n    int freeSpace;\\n    //1 = Guard\\n    //2 = Wall\\n    //0 = Free Space\\n  \\n    public int CountUnguarded(int maxRow, int maxCol, int[][] guards, int[][] walls) {\\n      grid = new int[maxRow][];\\n      this.maxRow = maxRow;\\n      this.maxCol = maxCol;\\n      freeSpace = maxRow * maxCol;\\n      \\n      for(int r=0;r<maxRow;r++){\\n        grid[r] = new int[maxCol];\\n      }\\n      \\n      foreach(var wall in walls){\\n        grid[wall[0]][wall[1]] = 2;\\n        freeSpace--;\\n      }\\n      \\n      foreach(var guard in guards){\\n        grid[guard[0]][guard[1]] = 1;\\n        freeSpace--;\\n      }\\n      \\n      foreach(var guard in guards){\\n        Guard(guard[0], guard[1]);\\n      }\\n      \\n      return freeSpace;\\n    }\\n  \\n    private void Guard(int row, int col){\\n      Up(row,col);\\n      Down(row,col);\\n      Left(row,col);\\n      Right(row,col);\\n    }\\n  \\n    private void Up(int row, int col){\\n      while(true){\\n        var nextRow = --row;\\n        var nextCol = col;\\n        \\n        if(OutOfBound(nextRow,nextCol)) return;\\n        if(grid[nextRow][nextCol] == 2) return;\\n        if(grid[nextRow][nextCol] == 1) return;\\n        \\n        if(grid[nextRow][nextCol] == 0){\\n          freeSpace--;\\n          grid[nextRow][nextCol] = -1;\\n        }        \\n      }\\n    }\\n  \\n    private void Down(int row, int col){\\n      while(true){\\n        var nextRow = ++row;\\n        var nextCol = col;\\n        \\n        if(OutOfBound(nextRow,nextCol)) return;\\n        if(grid[nextRow][nextCol] == 2) return;\\n        if(grid[nextRow][nextCol] == 1) return;\\n        \\n        if(grid[nextRow][nextCol] == 0){\\n          freeSpace--;\\n          grid[nextRow][nextCol] = -1;\\n        }     \\n      }\\n    }\\n  \\n    private void Left(int row, int col){\\n      while(true){\\n        var nextRow = row;\\n        var nextCol = --col;\\n        \\n        if(OutOfBound(nextRow,nextCol)) return;\\n        if(grid[nextRow][nextCol] == 2) return;\\n        if(grid[nextRow][nextCol] == 1) return;\\n        \\n        if(grid[nextRow][nextCol] == 0){\\n          freeSpace--;\\n          grid[nextRow][nextCol] = -1;\\n        }     \\n      }\\n    }\\n  \\n    private void Right(int row, int col){\\n      while(true){\\n        var nextRow = row;\\n        var nextCol = ++col;\\n        \\n        if(OutOfBound(nextRow,nextCol)) return;\\n        if(grid[nextRow][nextCol] == 2) return;\\n        if(grid[nextRow][nextCol] == 1) return;\\n        \\n        if(grid[nextRow][nextCol] == 0){\\n          freeSpace--;\\n          grid[nextRow][nextCol] = -1;\\n        }     \\n      }\\n    }\\n  \\n    private bool OutOfBound(int row, int col){\\n      return row >= maxRow || row < 0 || col >= maxCol || col < 0;\\n    }\\n  \\n}\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution {\\n    int[][] grid;\\n    int maxRow;\\n    int maxCol;\\n    int freeSpace;\\n    //1 = Guard\\n    //2 = Wall\\n    //0 = Free Space\\n  \\n    public int CountUnguarded(int maxRow, int maxCol, int[][] guards, int[][] walls) {\\n      grid = new int[maxRow][];\\n      this.maxRow = maxRow;\\n      this.maxCol = maxCol;\\n      freeSpace = maxRow * maxCol;\\n      \\n      for(int r=0;r<maxRow;r++){\\n        grid[r] = new int[maxCol];\\n      }\\n      \\n      foreach(var wall in walls){\\n        grid[wall[0]][wall[1]] = 2;\\n        freeSpace--;\\n      }\\n      \\n      foreach(var guard in guards){\\n        grid[guard[0]][guard[1]] = 1;\\n        freeSpace--;\\n      }\\n      \\n      foreach(var guard in guards){\\n        Guard(guard[0], guard[1]);\\n      }\\n      \\n      return freeSpace;\\n    }\\n  \\n    private void Guard(int row, int col){\\n      Up(row,col);\\n      Down(row,col);\\n      Left(row,col);\\n      Right(row,col);\\n    }\\n  \\n    private void Up(int row, int col){\\n      while(true){\\n        var nextRow = --row;\\n        var nextCol = col;\\n        \\n        if(OutOfBound(nextRow,nextCol)) return;\\n        if(grid[nextRow][nextCol] == 2) return;\\n        if(grid[nextRow][nextCol] == 1) return;\\n        \\n        if(grid[nextRow][nextCol] == 0){\\n          freeSpace--;\\n          grid[nextRow][nextCol] = -1;\\n        }        \\n      }\\n    }\\n  \\n    private void Down(int row, int col){\\n      while(true){\\n        var nextRow = ++row;\\n        var nextCol = col;\\n        \\n        if(OutOfBound(nextRow,nextCol)) return;\\n        if(grid[nextRow][nextCol] == 2) return;\\n        if(grid[nextRow][nextCol] == 1) return;\\n        \\n        if(grid[nextRow][nextCol] == 0){\\n          freeSpace--;\\n          grid[nextRow][nextCol] = -1;\\n        }     \\n      }\\n    }\\n  \\n    private void Left(int row, int col){\\n      while(true){\\n        var nextRow = row;\\n        var nextCol = --col;\\n        \\n        if(OutOfBound(nextRow,nextCol)) return;\\n        if(grid[nextRow][nextCol] == 2) return;\\n        if(grid[nextRow][nextCol] == 1) return;\\n        \\n        if(grid[nextRow][nextCol] == 0){\\n          freeSpace--;\\n          grid[nextRow][nextCol] = -1;\\n        }     \\n      }\\n    }\\n  \\n    private void Right(int row, int col){\\n      while(true){\\n        var nextRow = row;\\n        var nextCol = ++col;\\n        \\n        if(OutOfBound(nextRow,nextCol)) return;\\n        if(grid[nextRow][nextCol] == 2) return;\\n        if(grid[nextRow][nextCol] == 1) return;\\n        \\n        if(grid[nextRow][nextCol] == 0){\\n          freeSpace--;\\n          grid[nextRow][nextCol] = -1;\\n        }     \\n      }\\n    }\\n  \\n    private bool OutOfBound(int row, int col){\\n      return row >= maxRow || row < 0 || col >= maxCol || col < 0;\\n    }\\n  \\n}\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2942345,
                "title": "golang-294-ms-13-1-mb",
                "content": "```\\nconst Unguarded = 0\\nconst (\\n\\tGuardedHorizontally = 1 << iota\\n\\tGuardedVertically   = 1 << iota\\n)\\n\\nfunc countUnguarded(m int, n int, guards [][]int, walls [][]int) int {\\n\\tgrid := make([][]byte, m)\\n\\tfor i := 0; i < m; i++ {\\n\\t\\tgrid[i] = make([]byte, n)\\n\\t}\\n\\tfor _, wall := range walls {\\n\\t\\tgrid[wall[0]][wall[1]] = GuardedHorizontally | GuardedVertically\\n\\t}\\n\\tfor _, guard := range guards {\\n\\t\\ti, j := guard[0], guard[1]\\n\\t\\tgrid[i][j] = GuardedHorizontally | GuardedVertically\\n\\t\\tfor i := i - 1; i >= 0 && grid[i][j]&GuardedVertically == Unguarded; i-- {\\n\\t\\t\\tgrid[i][j] |= GuardedVertically\\n\\t\\t}\\n\\t\\tfor i := i + 1; i < m && grid[i][j]&GuardedVertically == Unguarded; i++ {\\n\\t\\t\\tgrid[i][j] |= GuardedVertically\\n\\t\\t}\\n\\t\\tfor j := j - 1; j >= 0 && grid[i][j]&GuardedHorizontally == Unguarded; j-- {\\n\\t\\t\\tgrid[i][j] |= GuardedHorizontally\\n\\t\\t}\\n\\t\\tfor j := j + 1; j < n && grid[i][j]&GuardedHorizontally == Unguarded; j++ {\\n\\t\\t\\tgrid[i][j] |= GuardedHorizontally\\n\\t\\t}\\n\\t}\\n\\tvar result int\\n\\tfor _, row := range grid {\\n\\t\\tfor _, cell := range row {\\n\\t\\t\\tif cell == Unguarded {\\n\\t\\t\\t\\tresult++\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\treturn result\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nconst Unguarded = 0\\nconst (\\n\\tGuardedHorizontally = 1 << iota\\n\\tGuardedVertically   = 1 << iota\\n)\\n\\nfunc countUnguarded(m int, n int, guards [][]int, walls [][]int) int {\\n\\tgrid := make([][]byte, m)\\n\\tfor i := 0; i < m; i++ {\\n\\t\\tgrid[i] = make([]byte, n)\\n\\t}\\n\\tfor _, wall := range walls {\\n\\t\\tgrid[wall[0]][wall[1]] = GuardedHorizontally | GuardedVertically\\n\\t}\\n\\tfor _, guard := range guards {\\n\\t\\ti, j := guard[0], guard[1]\\n\\t\\tgrid[i][j] = GuardedHorizontally | GuardedVertically\\n\\t\\tfor i := i - 1; i >= 0 && grid[i][j]&GuardedVertically == Unguarded; i-- {\\n\\t\\t\\tgrid[i][j] |= GuardedVertically\\n\\t\\t}\\n\\t\\tfor i := i + 1; i < m && grid[i][j]&GuardedVertically == Unguarded; i++ {\\n\\t\\t\\tgrid[i][j] |= GuardedVertically\\n\\t\\t}\\n\\t\\tfor j := j - 1; j >= 0 && grid[i][j]&GuardedHorizontally == Unguarded; j-- {\\n\\t\\t\\tgrid[i][j] |= GuardedHorizontally\\n\\t\\t}\\n\\t\\tfor j := j + 1; j < n && grid[i][j]&GuardedHorizontally == Unguarded; j++ {\\n\\t\\t\\tgrid[i][j] |= GuardedHorizontally\\n\\t\\t}\\n\\t}\\n\\tvar result int\\n\\tfor _, row := range grid {\\n\\t\\tfor _, cell := range row {\\n\\t\\t\\tif cell == Unguarded {\\n\\t\\t\\t\\tresult++\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\treturn result\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2890864,
                "title": "c-beats-98",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nTry to solve problem in $$O(m*n)$$ time complexity.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nCreate matrix, a, and first add 16 in cell where are the guards and 23 in cells where are the walls. Set 0 to the rest of the cells. Iterate through matrix from left, right, top, bottom, and remember did we encouter Wall or Guard in that row/ column.\\nIf we last encountered Guard that means that that cell is guarded. We use different number to clarify from which side the cell is guarded: 0x1000 from left, 0b0100 from right, 0b0010 from top, 0b0001 from bottom. Add the end we count unguarded cells.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n$$O(m*n)$$\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n$$O(m*n)$$\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int countUnguarded(int m, int n, vector<vector<int>>& guards, vector<vector<int>>& walls) {\\n        int a[m][n];\\n        for (int i = 0; i < m; ++i) {\\n            for (int j = 0; j < n; ++j) {\\n                a[i][j] = 0;\\n            }\\n        }\\n        for (auto& g : guards) {\\n            a[g[0]][g[1]] = 16;\\n        }\\n        for (auto& w : walls) {\\n            a[w[0]][w[1]] = 32;\\n        }\\n        char cur = \\'X\\';\\n        // pass from left\\n        for (int i = 0; i < m; ++i) {\\n            cur = \\'X\\';\\n            for (int j = 0; j < n; ++j) {\\n                if (a[i][j] == 16) {\\n                    cur = \\'G\\';\\n                }\\n                else if (a[i][j] == 32) {\\n                    cur = \\'W\\';\\n                }\\n                else {\\n                    if (cur == \\'G\\') {\\n                        a[i][j] = a[i][j] | 0b1000;\\n                    }\\n                }\\n            }\\n        }\\n\\n        // pass from right\\n        for (int i = 0; i < m; ++i) {\\n            cur = \\'X\\';\\n            for (int j = n - 1; j >= 0; --j) {\\n                if (a[i][j] == 16) {\\n                    cur = \\'G\\';\\n                }\\n                else if (a[i][j] == 32) {\\n                    cur = \\'W\\';\\n                }\\n                else {\\n                    if (cur == \\'G\\') {\\n                        a[i][j] = a[i][j] | 0b0100;\\n                    }\\n                }\\n            }\\n        }\\n\\n        // pass from top\\n        for (int i = 0; i < n; ++i) {\\n            cur = \\'X\\';\\n            for (int j = 0; j < m; ++j) {\\n                if (a[j][i] == 16) {\\n                    cur = \\'G\\';\\n                }\\n                else if (a[j][i] == 32) {\\n                    cur = \\'W\\';\\n                }\\n                else {\\n                    if (cur == \\'G\\') {\\n                        a[j][i] = a[j][i] | 0b0010;\\n                    }\\n                }\\n            }\\n        }\\n\\n        // pass from bottom\\n        for (int i = 0; i < n; ++i) {\\n            cur = \\'X\\';\\n            for (int j = m - 1; j >= 0; --j) {\\n                if (a[j][i] == 16) {\\n                    cur = \\'G\\';\\n                }\\n                else if (a[j][i] == 32) {\\n                    cur = \\'W\\';\\n                }\\n                else {\\n                    if (cur == \\'G\\') {\\n                        a[j][i] = a[j][i] | 0b0001;\\n                    }\\n                }\\n            }\\n        }\\n\\n        int count = 0;\\n        for (int i = 0; i < m; ++i) {\\n            for (int j = 0; j < n; ++j) {\\n                if (a[i][j] == 0) {\\n                    ++count;\\n                }\\n            }\\n        }\\n\\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int countUnguarded(int m, int n, vector<vector<int>>& guards, vector<vector<int>>& walls) {\\n        int a[m][n];\\n        for (int i = 0; i < m; ++i) {\\n            for (int j = 0; j < n; ++j) {\\n                a[i][j] = 0;\\n            }\\n        }\\n        for (auto& g : guards) {\\n            a[g[0]][g[1]] = 16;\\n        }\\n        for (auto& w : walls) {\\n            a[w[0]][w[1]] = 32;\\n        }\\n        char cur = \\'X\\';\\n        // pass from left\\n        for (int i = 0; i < m; ++i) {\\n            cur = \\'X\\';\\n            for (int j = 0; j < n; ++j) {\\n                if (a[i][j] == 16) {\\n                    cur = \\'G\\';\\n                }\\n                else if (a[i][j] == 32) {\\n                    cur = \\'W\\';\\n                }\\n                else {\\n                    if (cur == \\'G\\') {\\n                        a[i][j] = a[i][j] | 0b1000;\\n                    }\\n                }\\n            }\\n        }\\n\\n        // pass from right\\n        for (int i = 0; i < m; ++i) {\\n            cur = \\'X\\';\\n            for (int j = n - 1; j >= 0; --j) {\\n                if (a[i][j] == 16) {\\n                    cur = \\'G\\';\\n                }\\n                else if (a[i][j] == 32) {\\n                    cur = \\'W\\';\\n                }\\n                else {\\n                    if (cur == \\'G\\') {\\n                        a[i][j] = a[i][j] | 0b0100;\\n                    }\\n                }\\n            }\\n        }\\n\\n        // pass from top\\n        for (int i = 0; i < n; ++i) {\\n            cur = \\'X\\';\\n            for (int j = 0; j < m; ++j) {\\n                if (a[j][i] == 16) {\\n                    cur = \\'G\\';\\n                }\\n                else if (a[j][i] == 32) {\\n                    cur = \\'W\\';\\n                }\\n                else {\\n                    if (cur == \\'G\\') {\\n                        a[j][i] = a[j][i] | 0b0010;\\n                    }\\n                }\\n            }\\n        }\\n\\n        // pass from bottom\\n        for (int i = 0; i < n; ++i) {\\n            cur = \\'X\\';\\n            for (int j = m - 1; j >= 0; --j) {\\n                if (a[j][i] == 16) {\\n                    cur = \\'G\\';\\n                }\\n                else if (a[j][i] == 32) {\\n                    cur = \\'W\\';\\n                }\\n                else {\\n                    if (cur == \\'G\\') {\\n                        a[j][i] = a[j][i] | 0b0001;\\n                    }\\n                }\\n            }\\n        }\\n\\n        int count = 0;\\n        for (int i = 0; i < m; ++i) {\\n            for (int j = 0; j < n; ++j) {\\n                if (a[i][j] == 0) {\\n                    ++count;\\n                }\\n            }\\n        }\\n\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2876688,
                "title": "count-unguarded-cells-in-the-grid",
                "content": "# Intuition\\nthe main problem is about to count the cells which are guarded by any of the guards\\n\\n# Approach\\nwe will count the number of guarded cells by iterating every guard\\'s four direction path until we encounter any wall or guard\\n\\n# Complexity\\n- Time complexity:over all time complexity is O(m*n)\\n\\n- Space complexity:we are using 2D array of m*n size ,so O(m*n)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int countUnguarded(int m, int n, vector<vector<int>>& guards, vector<vector<int>>& walls) {\\n        vector<vector<char>> v(m,vector<char>(n,\\'0\\'));\\n        int a=guards.size();\\n        for(int i=0;i<a;i++){\\n              v[guards[i][0]][guards[i][1]]=\\'G\\';\\n        }\\n        int b=walls.size();\\n        for(int i=0;i<b;i++){\\n              v[walls[i][0]][walls[i][1]]=\\'W\\';\\n        }\\n        int ct(0);\\n        for(int i=0;i<a;i++){\\n              int x=guards[i][0];\\n              int y=guards[i][1];\\n              int s=x+1,o=x-1,ss=y+1,oo=y-1;\\n//downward path\\n              while(s<m && (v[s][y]!=\\'W\\' && v[s][y]!=\\'G\\')){\\n                  if(v[s][y]==\\'0\\') ct++;\\n                  v[s][y]=\\'1\\';\\n                  s++;\\n              }\\n//upward path\\n              while(o>=0 && (v[o][y]!=\\'W\\' && v[o][y]!=\\'G\\')){\\n                  if(v[o][y]==\\'0\\') ct++;\\n                  v[o][y]=\\'1\\';\\n                  o--;\\n              }\\n//rightward path\\n              while(ss<n && (v[x][ss]!=\\'W\\' && v[x][ss]!=\\'G\\')){\\n                  if(v[x][ss]==\\'0\\') ct++;\\n                  v[x][ss]=\\'1\\';\\n                  ss++;\\n              }\\n//leftward path\\n              while(oo>=0 && (v[x][oo]!=\\'W\\' && v[x][oo]!=\\'G\\')){\\n                  if(v[x][oo]==\\'0\\') ct++;\\n                  v[x][oo]=\\'1\\';\\n                  oo--;\\n              }\\n        }\\n//total cells - aquired cells\\n        return m*n-a-b-ct;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int countUnguarded(int m, int n, vector<vector<int>>& guards, vector<vector<int>>& walls) {\\n        vector<vector<char>> v(m,vector<char>(n,\\'0\\'));\\n        int a=guards.size();\\n        for(int i=0;i<a;i++){\\n              v[guards[i][0]][guards[i][1]]=\\'G\\';\\n        }\\n        int b=walls.size();\\n        for(int i=0;i<b;i++){\\n              v[walls[i][0]][walls[i][1]]=\\'W\\';\\n        }\\n        int ct(0);\\n        for(int i=0;i<a;i++){\\n              int x=guards[i][0];\\n              int y=guards[i][1];\\n              int s=x+1,o=x-1,ss=y+1,oo=y-1;\\n//downward path\\n              while(s<m && (v[s][y]!=\\'W\\' && v[s][y]!=\\'G\\')){\\n                  if(v[s][y]==\\'0\\') ct++;\\n                  v[s][y]=\\'1\\';\\n                  s++;\\n              }\\n//upward path\\n              while(o>=0 && (v[o][y]!=\\'W\\' && v[o][y]!=\\'G\\')){\\n                  if(v[o][y]==\\'0\\') ct++;\\n                  v[o][y]=\\'1\\';\\n                  o--;\\n              }\\n//rightward path\\n              while(ss<n && (v[x][ss]!=\\'W\\' && v[x][ss]!=\\'G\\')){\\n                  if(v[x][ss]==\\'0\\') ct++;\\n                  v[x][ss]=\\'1\\';\\n                  ss++;\\n              }\\n//leftward path\\n              while(oo>=0 && (v[x][oo]!=\\'W\\' && v[x][oo]!=\\'G\\')){\\n                  if(v[x][oo]==\\'0\\') ct++;\\n                  v[x][oo]=\\'1\\';\\n                  oo--;\\n              }\\n        }\\n//total cells - aquired cells\\n        return m*n-a-b-ct;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2876586,
                "title": "java-dfs-with-some-comments",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\n    public int countUnguarded(int n, int m, int[][] guards, int[][] walls) {\\n        int grid[][]=new int[n][m];\\n        for(int guard[]:guards)\\n            grid[guard[0]][guard[1]]=2;\\n        for(int wall[]:walls)\\n            grid[wall[0]][wall[1]]=-2;\\n        for(int guard[]:guards){\\n                dfs(guard[0]-1, guard[1],grid,n,m,1);\\n                dfs(guard[0],guard[1]+1,grid,n,m, 2);\\n                dfs(guard[0]+1, guard[1],grid,n,m,3);\\n                dfs(guard[0], guard[1]-1,grid,n,m,4);\\n        }\\n       int count = 0;\\n        for(int i = 0; i < n; i++)\\n            for(int j = 0; j < m; j++)\\n                if(grid[i][j]!=-1 && grid[i][j] != -2 && grid[i][j] != 2)\\n                    count++;\\n        \\n        return count;\\n    }\\n    void dfs(int i,int j,int grid[][],int n,int m,int val){\\n        if(i>=n ||i<0||j<0||j>=m ||grid[i][j]==2||grid[i][j]==-2)\\n            return ;\\n        // if(grid[i][j]==-1)\\n        //     return;\\n        //we are not writing the above statement as\\n          /////    -1\\n        // G -1 -1 -1 -1 -1 W\\n        //         -1\\n        //(when we reach the mid point if we return we will not go down)\\n        grid[i][j]=-1;//marking it visited\\n        if(val==1)\\n            dfs(i-1,j,grid,n,m,1);\\n        else if(val==2)\\n            dfs(i,j+1,grid,n,m,2);\\n        else if(val==3)\\n            dfs(i+1,j,grid,n,m,3);\\n        else\\n            dfs(i,j-1,grid,n,m,4);\\n            return ;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int countUnguarded(int n, int m, int[][] guards, int[][] walls) {\\n        int grid[][]=new int[n][m];\\n        for(int guard[]:guards)\\n            grid[guard[0]][guard[1]]=2;\\n        for(int wall[]:walls)\\n            grid[wall[0]][wall[1]]=-2;\\n        for(int guard[]:guards){\\n                dfs(guard[0]-1, guard[1],grid,n,m,1);\\n                dfs(guard[0],guard[1]+1,grid,n,m, 2);\\n                dfs(guard[0]+1, guard[1],grid,n,m,3);\\n                dfs(guard[0], guard[1]-1,grid,n,m,4);\\n        }\\n       int count = 0;\\n        for(int i = 0; i < n; i++)\\n            for(int j = 0; j < m; j++)\\n                if(grid[i][j]!=-1 && grid[i][j] != -2 && grid[i][j] != 2)\\n                    count++;\\n        \\n        return count;\\n    }\\n    void dfs(int i,int j,int grid[][],int n,int m,int val){\\n        if(i>=n ||i<0||j<0||j>=m ||grid[i][j]==2||grid[i][j]==-2)\\n            return ;\\n        // if(grid[i][j]==-1)\\n        //     return;\\n        //we are not writing the above statement as\\n          /////    -1\\n        // G -1 -1 -1 -1 -1 W\\n        //         -1\\n        //(when we reach the mid point if we return we will not go down)\\n        grid[i][j]=-1;//marking it visited\\n        if(val==1)\\n            dfs(i-1,j,grid,n,m,1);\\n        else if(val==2)\\n            dfs(i,j+1,grid,n,m,2);\\n        else if(val==3)\\n            dfs(i+1,j,grid,n,m,3);\\n        else\\n            dfs(i,j-1,grid,n,m,4);\\n            return ;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2875447,
                "title": "simple-c-solution-dfs",
                "content": "\\n# Code\\n```\\nclass Solution {\\n\\npublic:\\n    int total ;\\n    int countUnguarded(int m, int n, vector<vector<int>>& guards, vector<vector<int>>& walls) {\\n\\n        total = 0 ;\\n        vector<vector<int>>mat(m,vector<int>(n,0)) ;\\n\\n        for(auto&k:guards)\\n            mat[k[0]][k[1]] = 1 ;\\n        \\n        for(auto&k:walls)\\n            mat[k[0]][k[1]] = 2 ;\\n\\n        for(int i=0;i<m;i++)\\n        {\\n            for(int j=0;j<n;j++)\\n            {\\n                if( mat[i][j] == 1 )\\n                {\\n                    dfs(mat,i+1,j,m,n,1) ;\\n                    dfs(mat,i-1,j,m,n,2) ;\\n                    dfs(mat,i,j+1,m,n,3) ;\\n                    dfs(mat,i,j-1,m,n,4) ;\\n                    \\n                }\\n                \\n            }\\n        }\\n        \\n        for(int i=0;i<m;i++)\\n        {\\n            for(int j=0;j<n;j++)\\n            {\\n                if( mat[i][j] == 0 )\\n                    total++ ;\\n                //cout<<mat[i][j]<<\"  \" ;\\n            }\\n            //cout<<endl ;\\n        }\\n\\n        return total ;\\n    }\\n    \\n\\n   void dfs(vector<vector<int>>&mat,int x,int y,int m,int n,int dir)\\n    {\\n        if( min(x,y) < 0 || x >= m || y >= n )\\n            return ;\\n\\n        if( mat[x][y] == 2 || mat[x][y] == 1 )\\n            return ;\\n\\n        mat[x][y] = 3 ;\\n        \\n        if( dir == 1 )\\n            dfs(mat,x+1,y,m,n,1) ;\\n        if( dir == 2 )\\n            dfs(mat,x-1,y,m,n,2) ;\\n        if( dir == 3 )\\n            dfs(mat,x,y+1,m,n,3) ;\\n        if( dir == 4 )\\n            dfs(mat,x,y-1,m,n,4) ;\\n        \\n        return ;\\n    }\\n\\n};\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\n\\npublic:\\n    int total ;\\n    int countUnguarded(int m, int n, vector<vector<int>>& guards, vector<vector<int>>& walls) {\\n\\n        total = 0 ;\\n        vector<vector<int>>mat(m,vector<int>(n,0)) ;\\n\\n        for(auto&k:guards)\\n            mat[k[0]][k[1]] = 1 ;\\n        \\n        for(auto&k:walls)\\n            mat[k[0]][k[1]] = 2 ;\\n\\n        for(int i=0;i<m;i++)\\n        {\\n            for(int j=0;j<n;j++)\\n            {\\n                if( mat[i][j] == 1 )\\n                {\\n                    dfs(mat,i+1,j,m,n,1) ;\\n                    dfs(mat,i-1,j,m,n,2) ;\\n                    dfs(mat,i,j+1,m,n,3) ;\\n                    dfs(mat,i,j-1,m,n,4) ;\\n                    \\n                }\\n                \\n            }\\n        }\\n        \\n        for(int i=0;i<m;i++)\\n        {\\n            for(int j=0;j<n;j++)\\n            {\\n                if( mat[i][j] == 0 )\\n                    total++ ;\\n                //cout<<mat[i][j]<<\"  \" ;\\n            }\\n            //cout<<endl ;\\n        }\\n\\n        return total ;\\n    }\\n    \\n\\n   void dfs(vector<vector<int>>&mat,int x,int y,int m,int n,int dir)\\n    {\\n        if( min(x,y) < 0 || x >= m || y >= n )\\n            return ;\\n\\n        if( mat[x][y] == 2 || mat[x][y] == 1 )\\n            return ;\\n\\n        mat[x][y] = 3 ;\\n        \\n        if( dir == 1 )\\n            dfs(mat,x+1,y,m,n,1) ;\\n        if( dir == 2 )\\n            dfs(mat,x-1,y,m,n,2) ;\\n        if( dir == 3 )\\n            dfs(mat,x,y+1,m,n,3) ;\\n        if( dir == 4 )\\n            dfs(mat,x,y-1,m,n,4) ;\\n        \\n        return ;\\n    }\\n\\n};\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2863588,
                "title": "simple-solution-using-traversing-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(N^2)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(N^2)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n\\n    void seeall(int i,int j, vector<vector<char>> &g){\\n        // go up\\n        for(int r = i-1;r>=0;r--){\\n            if(g[r][j] == \\'N\\' || g[r][j] == \\'V\\'){\\n                g[r][j] = \\'V\\';\\n            }else break;\\n        }\\n        // go down\\n        for(int r = i+1;r<g.size();r++){\\n            if(g[r][j] == \\'N\\' || g[r][j] == \\'V\\'){\\n                g[r][j] = \\'V\\';\\n            }else break;\\n        }\\n        // go left\\n        for(int c = j-1;c>=0;c--){\\n            if(g[i][c] == \\'N\\' || g[i][c] == \\'V\\'){\\n                g[i][c] = \\'V\\';\\n            }else break;\\n        }\\n        // go right\\n        for(int c = j+1;c<g[0].size();c++){\\n            if(g[i][c] == \\'N\\' || g[i][c] == \\'V\\'){\\n                g[i][c] = \\'V\\';\\n            }else break;\\n        }\\n    }\\n\\n    int countUnguarded(int m, int n, vector<vector<int>>& guards, vector<vector<int>>& walls) {\\n        vector<vector<char>> grid(m,vector<char>(n,\\'N\\'));\\n        // Now fill with wall and gaurd\\n        for(auto x: guards){\\n            grid[x[0]][x[1]] = \\'G\\';\\n        }\\n        for(auto x: walls){\\n            grid[x[0]][x[1]] = \\'W\\';\\n        }\\n        // Now for each gaurd mark every cell V\\n        for(auto x: guards){\\n            seeall(x[0],x[1],grid);\\n        }\\n        int ans = 0 ;\\n        for(auto x: grid){\\n            for(auto c: x) if(c == \\'N\\') ans++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Simulation"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\n    void seeall(int i,int j, vector<vector<char>> &g){\\n        // go up\\n        for(int r = i-1;r>=0;r--){\\n            if(g[r][j] == \\'N\\' || g[r][j] == \\'V\\'){\\n                g[r][j] = \\'V\\';\\n            }else break;\\n        }\\n        // go down\\n        for(int r = i+1;r<g.size();r++){\\n            if(g[r][j] == \\'N\\' || g[r][j] == \\'V\\'){\\n                g[r][j] = \\'V\\';\\n            }else break;\\n        }\\n        // go left\\n        for(int c = j-1;c>=0;c--){\\n            if(g[i][c] == \\'N\\' || g[i][c] == \\'V\\'){\\n                g[i][c] = \\'V\\';\\n            }else break;\\n        }\\n        // go right\\n        for(int c = j+1;c<g[0].size();c++){\\n            if(g[i][c] == \\'N\\' || g[i][c] == \\'V\\'){\\n                g[i][c] = \\'V\\';\\n            }else break;\\n        }\\n    }\\n\\n    int countUnguarded(int m, int n, vector<vector<int>>& guards, vector<vector<int>>& walls) {\\n        vector<vector<char>> grid(m,vector<char>(n,\\'N\\'));\\n        // Now fill with wall and gaurd\\n        for(auto x: guards){\\n            grid[x[0]][x[1]] = \\'G\\';\\n        }\\n        for(auto x: walls){\\n            grid[x[0]][x[1]] = \\'W\\';\\n        }\\n        // Now for each gaurd mark every cell V\\n        for(auto x: guards){\\n            seeall(x[0],x[1],grid);\\n        }\\n        int ans = 0 ;\\n        for(auto x: grid){\\n            for(auto c: x) if(c == \\'N\\') ans++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2844859,
                "title": "row-sweeping-and-rotating-matrix",
                "content": "# Intuition\\nFirstly I thought of making something like bruteforce, for each guard mark every node which is under his supervision, but that will take $$O(n*m*(n+ m))$$ complexity, since for each guard n*m we are going to mark n + m places visited by him. \\n    2nd Solution can be by sweeping on matrix from top row to bottom marking nodes which are guarded by some upper guard. \\n# Approach\\nFor that we needs to be done for all 4 directions, to make implementation easy I choose to rotate matrix and then always sweeping from top to bottom marking guards supervision. \\n\\n# Complexity\\n- Time complexity:  $$O(n*m)$$ to make matrix and operating on it\\n<!-- Add your time complexity here, e.g. -->\\n\\n- Space complexity: $$O(n*m)$$ some constant steps are done on matrix n*m \\n<!-- Add your space complexity here, e.g.  -->\\n\\n# Code\\n```\\nclass Solution {\\n    void sweep(vector<vector<char> > &matrix){\\n        vector<char> prev(matrix[0].size(),\\'U\\'); \\n        for(int i=0;i<matrix.size();i+=1){\\n            for(int j=0;j<matrix[0].size();j+=1){\\n                auto &ch = matrix[i][j]; \\n                if(ch == \\'W\\') // means remove any previous guarding being done \\n                    prev[j] = \\'U\\'; \\n                else if(ch == \\'U\\') // check if someone above it guards it \\n                    ch = prev[j]; \\n                else if(ch == \\'G\\')// this is guard mark it as saviour of others  \\n                    prev[j] = \\'P\\'; \\n            }\\n        }\\n        return; \\n    }\\n    vector<vector<char> >  rotate(vector<vector<char> > &matrix){ // anticloclwise movement \\n        // just by looking at what index value going where after rotation is implemeted in code \\n        int n = matrix.size(); \\n        int m = matrix[0].size(); \\n        vector<vector<char> > res(m,vector<char>(n,\\'U\\')); \\n        int x = m-1,y = 0; \\n        for(int i=0,y = 0;i<n;i+=1,y+=1){\\n            for(int j=0,x = m-1;j<m;j+=1,x-=1){\\n                res[x][y] = matrix[i][j]; \\n            }\\n        }\\n        return res; \\n    }\\npublic:\\n    int countUnguarded(int m, int n, vector<vector<int>>& guards, vector<vector<int>>& walls) {\\n        vector<vector<char> > matrix(m,vector<char>(n,\\'U\\')); \\n        for(auto &elm: guards){\\n            matrix[elm[0]][elm[1]] = \\'G\\'; \\n        }\\n        for(auto &elm: walls){\\n            matrix[elm[0]][elm[1]] = \\'W\\'; \\n        }\\n        for(int i=0;i<4;i+=1){\\n            sweep(matrix); \\n            matrix = rotate(matrix); \\n        }\\n        int count = 0; \\n        for(auto &v : matrix){\\n            for(auto &elm: v){\\n                count += (elm == \\'U\\'); \\n            }\\n        }\\n        return count; \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\n    void sweep(vector<vector<char> > &matrix){\\n        vector<char> prev(matrix[0].size(),\\'U\\'); \\n        for(int i=0;i<matrix.size();i+=1){\\n            for(int j=0;j<matrix[0].size();j+=1){\\n                auto &ch = matrix[i][j]; \\n                if(ch == \\'W\\') // means remove any previous guarding being done \\n                    prev[j] = \\'U\\'; \\n                else if(ch == \\'U\\') // check if someone above it guards it \\n                    ch = prev[j]; \\n                else if(ch == \\'G\\')// this is guard mark it as saviour of others  \\n                    prev[j] = \\'P\\'; \\n            }\\n        }\\n        return; \\n    }\\n    vector<vector<char> >  rotate(vector<vector<char> > &matrix){ // anticloclwise movement \\n        // just by looking at what index value going where after rotation is implemeted in code \\n        int n = matrix.size(); \\n        int m = matrix[0].size(); \\n        vector<vector<char> > res(m,vector<char>(n,\\'U\\')); \\n        int x = m-1,y = 0; \\n        for(int i=0,y = 0;i<n;i+=1,y+=1){\\n            for(int j=0,x = m-1;j<m;j+=1,x-=1){\\n                res[x][y] = matrix[i][j]; \\n            }\\n        }\\n        return res; \\n    }\\npublic:\\n    int countUnguarded(int m, int n, vector<vector<int>>& guards, vector<vector<int>>& walls) {\\n        vector<vector<char> > matrix(m,vector<char>(n,\\'U\\')); \\n        for(auto &elm: guards){\\n            matrix[elm[0]][elm[1]] = \\'G\\'; \\n        }\\n        for(auto &elm: walls){\\n            matrix[elm[0]][elm[1]] = \\'W\\'; \\n        }\\n        for(int i=0;i<4;i+=1){\\n            sweep(matrix); \\n            matrix = rotate(matrix); \\n        }\\n        int count = 0; \\n        for(auto &v : matrix){\\n            for(auto &elm: v){\\n                count += (elm == \\'U\\'); \\n            }\\n        }\\n        return count; \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2807659,
                "title": "cpp-easy-to-understand-4-dirn-from-every-guard",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\nvector<vector<char>>mat;\\nint count;\\nint countUnguarded(int m, int n, vector<vector<int>>& guards, vector<vector<int>>& walls)    \\n{\\n\\tcount=0;\\n    mat.resize(m,vector<char>(n,\\' \\'));\\n\\tfor(int i=0;i<guards.size();i++)\\n\\t{\\n\\t    int r = guards[i][0];\\n\\t    int c = guards[i][1];\\n\\t    mat[r][c] = \\'g\\';\\n    }\\n\\tfor(int i=0;i<walls.size();i++)\\n\\t{\\n\\t    int r = walls[i][0];\\n\\t    int c = walls[i][1];\\n\\t    mat[r][c] = \\'w\\';\\n    }       \\n\\t//if some empty cell is being guarded by some other guard it would mark it as \\'*\"   \\n    for(int i=0;i<mat.size();i++)\\n    {\\n    \\tfor(int j=0;j<mat[i].size();j++)\\n    \\t{\\n    \\t\\tif(mat[i][j]==\\' \\' or  mat[i][j]==\\'*\\' or mat[i][j]==\\'w\\')\\n    \\t\\t{\\n    \\t\\t\\tcontinue;\\n\\t\\t\\t}\\n\\t\\t\\telse if(mat[i][j] == \\'g\\')\\n\\t\\t\\t{\\n\\t\\t\\t    fun(i,j);\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\tfor(int i=0;i<mat.size();i++)\\n\\t{\\n\\t\\tfor(int j=0;j<mat[i].size();j++)\\n\\t\\t{\\n\\t\\t\\tif(mat[i][j] == \\' \\')\\n\\t\\t\\t{\\n\\t\\t\\t\\tcount++;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\treturn count;\\n}\\nvoid fun(int row,int col)\\n{\\n\\tint temp_row;\\n\\tint temp_col;\\n\\t\\n\\t//checking up\\n\\ttemp_row = row;\\n\\ttemp_col = col;\\n\\n\\twhile(temp_row >= 0)\\n\\t{\\n        temp_row--;\\n         \\n        if(temp_row < 0)\\n        break;\\n\\n        if((temp_row!=row or temp_col!=col) and (mat[temp_row][temp_col]==\\'g\\' or mat[temp_row][temp_col]==\\'w\\'))\\n\\t\\tbreak;\\n\\n\\t\\tmat[temp_row][temp_col] = \\'*\\';\\n\\t}\\n\\t\\n\\t//checking down\\n\\ttemp_row = row;\\n\\ttemp_col = col;\\n\\twhile(temp_row < mat.size())\\n\\t{\\n        temp_row++;\\n\\t\\t\\n        if(temp_row >= mat.size())\\n        break;\\n\\n\\t\\tif((temp_row!=row or temp_col!=col) and (mat[temp_row][temp_col]==\\'g\\' or mat[temp_row][temp_col]==\\'w\\'))\\n\\t\\tbreak;\\n\\n        mat[temp_row][temp_col] = \\'*\\';\\n\\t}\\n\\t\\n\\t//checking left\\n\\ttemp_row = row;\\n\\ttemp_col = col;\\n\\twhile(temp_col>=0)\\n\\t{\\n\\t\\ttemp_col--;\\n\\n        if(temp_col < 0)\\n        break;\\n\\n\\t\\tif((temp_row!=row or temp_col!=col) and (mat[temp_row][temp_col]==\\'g\\' or mat[temp_row][temp_col]==\\'w\\'))\\n\\t\\tbreak;\\n\\n        mat[temp_row][temp_col] = \\'*\\';\\n\\t}\\n\\t\\n\\t//checking right\\n\\ttemp_row = row;\\n\\ttemp_col = col;\\n\\twhile(temp_col < mat[0].size())\\n\\t{\\n\\t\\ttemp_col++;\\n\\t\\t\\n        if(temp_col >= mat[0].size())\\n        break;\\n\\n\\t\\tif((temp_row!=row or temp_col!=col) and (mat[temp_row][temp_col]==\\'g\\' or mat[temp_row][temp_col]==\\'w\\'))\\n\\t\\tbreak;\\n\\n        mat[temp_row][temp_col] = \\'*\\';\\n\\t}\\n\\t\\n\\tmat[row][col] = \\'g\\';\\n}\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\nvector<vector<char>>mat;\\nint count;\\nint countUnguarded(int m, int n, vector<vector<int>>& guards, vector<vector<int>>& walls)    \\n{\\n\\tcount=0;\\n    mat.resize(m,vector<char>(n,\\' \\'));\\n\\tfor(int i=0;i<guards.size();i++)\\n\\t{\\n\\t    int r = guards[i][0];\\n\\t    int c = guards[i][1];\\n\\t    mat[r][c] = \\'g\\';\\n    }\\n\\tfor(int i=0;i<walls.size();i++)\\n\\t{\\n\\t    int r = walls[i][0];\\n\\t    int c = walls[i][1];\\n\\t    mat[r][c] = \\'w\\';\\n    }       \\n\\t//if some empty cell is being guarded by some other guard it would mark it as \\'*\"   \\n    for(int i=0;i<mat.size();i++)\\n    {\\n    \\tfor(int j=0;j<mat[i].size();j++)\\n    \\t{\\n    \\t\\tif(mat[i][j]==\\' \\' or  mat[i][j]==\\'*\\' or mat[i][j]==\\'w\\')\\n    \\t\\t{\\n    \\t\\t\\tcontinue;\\n\\t\\t\\t}\\n\\t\\t\\telse if(mat[i][j] == \\'g\\')\\n\\t\\t\\t{\\n\\t\\t\\t    fun(i,j);\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\tfor(int i=0;i<mat.size();i++)\\n\\t{\\n\\t\\tfor(int j=0;j<mat[i].size();j++)\\n\\t\\t{\\n\\t\\t\\tif(mat[i][j] == \\' \\')\\n\\t\\t\\t{\\n\\t\\t\\t\\tcount++;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\treturn count;\\n}\\nvoid fun(int row,int col)\\n{\\n\\tint temp_row;\\n\\tint temp_col;\\n\\t\\n\\t//checking up\\n\\ttemp_row = row;\\n\\ttemp_col = col;\\n\\n\\twhile(temp_row >= 0)\\n\\t{\\n        temp_row--;\\n         \\n        if(temp_row < 0)\\n        break;\\n\\n        if((temp_row!=row or temp_col!=col) and (mat[temp_row][temp_col]==\\'g\\' or mat[temp_row][temp_col]==\\'w\\'))\\n\\t\\tbreak;\\n\\n\\t\\tmat[temp_row][temp_col] = \\'*\\';\\n\\t}\\n\\t\\n\\t//checking down\\n\\ttemp_row = row;\\n\\ttemp_col = col;\\n\\twhile(temp_row < mat.size())\\n\\t{\\n        temp_row++;\\n\\t\\t\\n        if(temp_row >= mat.size())\\n        break;\\n\\n\\t\\tif((temp_row!=row or temp_col!=col) and (mat[temp_row][temp_col]==\\'g\\' or mat[temp_row][temp_col]==\\'w\\'))\\n\\t\\tbreak;\\n\\n        mat[temp_row][temp_col] = \\'*\\';\\n\\t}\\n\\t\\n\\t//checking left\\n\\ttemp_row = row;\\n\\ttemp_col = col;\\n\\twhile(temp_col>=0)\\n\\t{\\n\\t\\ttemp_col--;\\n\\n        if(temp_col < 0)\\n        break;\\n\\n\\t\\tif((temp_row!=row or temp_col!=col) and (mat[temp_row][temp_col]==\\'g\\' or mat[temp_row][temp_col]==\\'w\\'))\\n\\t\\tbreak;\\n\\n        mat[temp_row][temp_col] = \\'*\\';\\n\\t}\\n\\t\\n\\t//checking right\\n\\ttemp_row = row;\\n\\ttemp_col = col;\\n\\twhile(temp_col < mat[0].size())\\n\\t{\\n\\t\\ttemp_col++;\\n\\t\\t\\n        if(temp_col >= mat[0].size())\\n        break;\\n\\n\\t\\tif((temp_row!=row or temp_col!=col) and (mat[temp_row][temp_col]==\\'g\\' or mat[temp_row][temp_col]==\\'w\\'))\\n\\t\\tbreak;\\n\\n        mat[temp_row][temp_col] = \\'*\\';\\n\\t}\\n\\t\\n\\tmat[row][col] = \\'g\\';\\n}\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2757738,
                "title": "c-solution-using-random-shuffle",
                "content": "```\\nclass Solution {\\n public:\\n  int countUnguarded(int m, int n, vector<vector<int>>& guards,\\n                     vector<vector<int>>& walls) {\\n    vector<vector<int>> g(m, vector<int>(n));\\n    for (auto& v : walls) g[v[0]][v[1]] = 1;\\n    auto rng = std::default_random_engine{};\\n    shuffle(guards.begin(), guards.end(), rng);\\n    for (auto& v : guards) {\\n      int x = v[0], y = v[1];\\n      g[x][y] = 2;\\n      static int d[] = {-1, 0, 1, 0, -1};\\n      for (int k = 0; k < 4; k++) {\\n        int dx = d[k], dy = d[k + 1];\\n        for (int s = 1;; s++) {\\n          int nx = x + s * dx, ny = y + s * dy;\\n          if (0 <= nx && nx < m && 0 <= ny && ny < n) {\\n            if (g[nx][ny] == 1 || g[nx][ny] == 2) break;\\n            g[nx][ny] = 3;\\n          } else\\n            break;\\n        }\\n      }\\n    }\\n\\n    int res = 0;\\n    for (int i = 0; i < m; i++)\\n      for (int j = 0; j < n; j++)\\n        if (!g[i][j]) res++;\\n    return res;\\n  }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n public:\\n  int countUnguarded(int m, int n, vector<vector<int>>& guards,\\n                     vector<vector<int>>& walls) {\\n    vector<vector<int>> g(m, vector<int>(n));\\n    for (auto& v : walls) g[v[0]][v[1]] = 1;\\n    auto rng = std::default_random_engine{};\\n    shuffle(guards.begin(), guards.end(), rng);\\n    for (auto& v : guards) {\\n      int x = v[0], y = v[1];\\n      g[x][y] = 2;\\n      static int d[] = {-1, 0, 1, 0, -1};\\n      for (int k = 0; k < 4; k++) {\\n        int dx = d[k], dy = d[k + 1];\\n        for (int s = 1;; s++) {\\n          int nx = x + s * dx, ny = y + s * dy;\\n          if (0 <= nx && nx < m && 0 <= ny && ny < n) {\\n            if (g[nx][ny] == 1 || g[nx][ny] == 2) break;\\n            g[nx][ny] = 3;\\n          } else\\n            break;\\n        }\\n      }\\n    }\\n\\n    int res = 0;\\n    for (int i = 0; i < m; i++)\\n      for (int j = 0; j < n; j++)\\n        if (!g[i][j]) res++;\\n    return res;\\n  }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2757724,
                "title": "golang-bitmasking",
                "content": "```go\\nfunc countUnguarded(m int, n int, guards [][]int, walls [][]int) int {\\n  mat := make([][]int, m)\\n  for i := 0; i < m; i++ {\\n    mat[i] = make([]int, n)\\n  }\\n  var occupied int\\n  for _, wall := range walls {\\n    mat[wall[0]][wall[1]] = -1\\n    occupied++\\n  }\\n  // We mark the matrix with bitmasking of whether horizontal or vertical\\n  // coverage present at a specific cell.\\n  // 01 - horizontal\\n  // 10 - vertical\\n  // 11 - both horizontal and vertical\\n  // 00 - no coverage\\n  directions := [4][2]int{{0, 1}, {1, 0}, {0, -1}, {-1, 0}}\\n  markers := [4]int{1, 2, 1, 2}\\n  for _, guard := range guards {\\n    mat[guard[0]][guard[1]] = 3 // Coverage at both horizontal and vertical\\n    occupied++\\n  }\\n  // Now let\\'s mark all the positions that each guard can watch\\n  for _, guard := range guards {\\n    for idx, dir := range directions {\\n      x, y := guard[0] + dir[0], guard[1] + dir[1]\\n      for x >= 0 && x < m && y >= 0 && y < n && mat[x][y] != -1 && mat[x][y] & markers[idx] == 0 {\\n        if mat[x][y] == 0 {\\n          occupied++\\n        }\\n        mat[x][y] = mat[x][y] | markers[idx]\\n        x, y = x + dir[0], y + dir[1]\\n      }\\n    }\\n  }\\n  return m*n - occupied\\n}\\n```",
                "solutionTags": [
                    "Go",
                    "Bitmask"
                ],
                "code": "```go\\nfunc countUnguarded(m int, n int, guards [][]int, walls [][]int) int {\\n  mat := make([][]int, m)\\n  for i := 0; i < m; i++ {\\n    mat[i] = make([]int, n)\\n  }\\n  var occupied int\\n  for _, wall := range walls {\\n    mat[wall[0]][wall[1]] = -1\\n    occupied++\\n  }\\n  // We mark the matrix with bitmasking of whether horizontal or vertical\\n  // coverage present at a specific cell.\\n  // 01 - horizontal\\n  // 10 - vertical\\n  // 11 - both horizontal and vertical\\n  // 00 - no coverage\\n  directions := [4][2]int{{0, 1}, {1, 0}, {0, -1}, {-1, 0}}\\n  markers := [4]int{1, 2, 1, 2}\\n  for _, guard := range guards {\\n    mat[guard[0]][guard[1]] = 3 // Coverage at both horizontal and vertical\\n    occupied++\\n  }\\n  // Now let\\'s mark all the positions that each guard can watch\\n  for _, guard := range guards {\\n    for idx, dir := range directions {\\n      x, y := guard[0] + dir[0], guard[1] + dir[1]\\n      for x >= 0 && x < m && y >= 0 && y < n && mat[x][y] != -1 && mat[x][y] & markers[idx] == 0 {\\n        if mat[x][y] == 0 {\\n          occupied++\\n        }\\n        mat[x][y] = mat[x][y] | markers[idx]\\n        x, y = x + dir[0], y + dir[1]\\n      }\\n    }\\n  }\\n  return m*n - occupied\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2719870,
                "title": "find-free-cells-by-subtracting-occupied-cells-by-guards-java-solution",
                "content": "```\\nclass Solution {\\n    public int countUnguarded(int m, int n, int[][] guards, int[][] walls) {\\n       char[][] grid = new char[m][n];\\n        for (int[] g : guards)\\n            grid[g[0]][g[1]] = \\'G\\';\\n        for (int[] w : walls)\\n            grid[w[0]][w[1]] = \\'W\\';\\n\\n        int[] count = new int[1];\\n        for (int i = 0; i < m; i++) {\\n            for (int j = 0; j < n; j++) {\\n                if (grid[i][j] == \\'G\\')\\n                    simulate(grid, i, j, count);\\n            }\\n        }\\n        return (m * n) - (guards.length + walls.length + count[0]);\\n    }\\n    \\n   public void simulate(char[][] grid, int row, int col, int[] count) {\\n        // UP check\\n        for (int i = row - 1; i >= 0; i--) {\\n            if (grid[i][col] == \\'G\\' || grid[i][col] == \\'W\\') {\\n                break;\\n            } else if (grid[i][col] != \\'C\\') {\\n                grid[i][col] = \\'C\\';\\n                count[0]++;\\n            }\\n        }\\n        // Down check\\n        for (int i = row + 1; i < grid.length; i++) {\\n            if (grid[i][col] == \\'G\\' || grid[i][col] == \\'W\\') {\\n                break;\\n            } else if (grid[i][col] != \\'C\\') {\\n                grid[i][col] = \\'C\\';\\n                count[0]++;\\n            }\\n        }\\n\\n        // Left check\\n        for (int i = col - 1; i >= 0; i--) {\\n            if (grid[row][i] == \\'G\\' || grid[row][i] == \\'W\\') {\\n                break;\\n            } else if (grid[row][i] != \\'C\\') {\\n                grid[row][i] = \\'C\\';\\n                count[0]++;\\n            }\\n        }\\n\\n        // Right check\\n        for (int i = col + 1; i < grid[0].length; i++) {\\n            if (grid[row][i] == \\'G\\' || grid[row][i] == \\'W\\') {\\n                break;\\n            } else if (grid[row][i] != \\'C\\') {\\n                grid[row][i] = \\'C\\';\\n                count[0]++;\\n            }\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Matrix",
                    "Simulation"
                ],
                "code": "```\\nclass Solution {\\n    public int countUnguarded(int m, int n, int[][] guards, int[][] walls) {\\n       char[][] grid = new char[m][n];\\n        for (int[] g : guards)\\n            grid[g[0]][g[1]] = \\'G\\';\\n        for (int[] w : walls)\\n            grid[w[0]][w[1]] = \\'W\\';\\n\\n        int[] count = new int[1];\\n        for (int i = 0; i < m; i++) {\\n            for (int j = 0; j < n; j++) {\\n                if (grid[i][j] == \\'G\\')\\n                    simulate(grid, i, j, count);\\n            }\\n        }\\n        return (m * n) - (guards.length + walls.length + count[0]);\\n    }\\n    \\n   public void simulate(char[][] grid, int row, int col, int[] count) {\\n        // UP check\\n        for (int i = row - 1; i >= 0; i--) {\\n            if (grid[i][col] == \\'G\\' || grid[i][col] == \\'W\\') {\\n                break;\\n            } else if (grid[i][col] != \\'C\\') {\\n                grid[i][col] = \\'C\\';\\n                count[0]++;\\n            }\\n        }\\n        // Down check\\n        for (int i = row + 1; i < grid.length; i++) {\\n            if (grid[i][col] == \\'G\\' || grid[i][col] == \\'W\\') {\\n                break;\\n            } else if (grid[i][col] != \\'C\\') {\\n                grid[i][col] = \\'C\\';\\n                count[0]++;\\n            }\\n        }\\n\\n        // Left check\\n        for (int i = col - 1; i >= 0; i--) {\\n            if (grid[row][i] == \\'G\\' || grid[row][i] == \\'W\\') {\\n                break;\\n            } else if (grid[row][i] != \\'C\\') {\\n                grid[row][i] = \\'C\\';\\n                count[0]++;\\n            }\\n        }\\n\\n        // Right check\\n        for (int i = col + 1; i < grid[0].length; i++) {\\n            if (grid[row][i] == \\'G\\' || grid[row][i] == \\'W\\') {\\n                break;\\n            } else if (grid[row][i] != \\'C\\') {\\n                grid[row][i] = \\'C\\';\\n                count[0]++;\\n            }\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2718108,
                "title": "different-approach-o-n-2-just-visit-the-matrix-twice",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\ngoing from left to right, if there is wall on right side of guard then elements after that are not guarded\\n\\ngoing from  right to left , if there is wall on left side of guard then elements after that are not guarded\\n\\ngoing from  top to down , if there is wall on down side of guard then elements down to that are not guarded\\n\\ngoing from  down to top , if there is wall on top side of guard then elements top to that are not guarded\\n\\n\\n# Code\\n```\\nclass Solution {\\n    public int countUnguarded(int m, int n, int[][] guards, int[][] walls) {\\n        int[][] mat = new int[m][n];\\n        for(int i=0;i<m;i++)\\n            Arrays.fill(mat[i],1);\\n        //-1 walls ,-5-> guard,0 -> guarded,1->unguarded\\n        for(int[] i: walls) mat[i[0]][i[1]] = -1;\\n        for(int[] i: guards) mat[i[0]][i[1]] = -5;\\n        for(int i=0;i<m;i++){\\n            int left = 0,right = n-1;\\n            int lug = 1,rug = 1;\\n            for(;left<n;left++,right--){\\n                if(mat[i][left]==-5)lug=0;\\n                else if(mat[i][left]==-1) lug=1;\\n                else mat[i][left]&=lug;\\n                \\n                if(mat[i][right]==-5)rug=0;\\n                else if(mat[i][right]==-1) rug=1;\\n                else mat[i][right]&=rug;\\n            }\\n        }\\n        for(int i=0;i<n;i++){\\n            int left = 0,right = m-1;\\n            int lug = 1,rug = 1;\\n            for(;left<m;left++,right--){\\n                if(mat[left][i]==-5)lug=0;\\n                else if(mat[left][i]==-1) lug=1;\\n                else mat[left][i]&=lug;\\n                \\n                if(mat[right][i]==-5)rug=0;\\n                else if(mat[right][i]==-1) rug=1;\\n                else mat[right][i]&=rug;\\n            }\\n        }\\n        int res =0 ;\\n        for(int[] m1: mat){\\n            for(int m11: m1) res+=(m11==1?1:0);\\n        }\\n       // print(mat);\\n        return res;\\n    }\\n    static void print(int[][] mat){\\n        System.out.println(Arrays.deepToString(mat));\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int countUnguarded(int m, int n, int[][] guards, int[][] walls) {\\n        int[][] mat = new int[m][n];\\n        for(int i=0;i<m;i++)\\n            Arrays.fill(mat[i],1);\\n        //-1 walls ,-5-> guard,0 -> guarded,1->unguarded\\n        for(int[] i: walls) mat[i[0]][i[1]] = -1;\\n        for(int[] i: guards) mat[i[0]][i[1]] = -5;\\n        for(int i=0;i<m;i++){\\n            int left = 0,right = n-1;\\n            int lug = 1,rug = 1;\\n            for(;left<n;left++,right--){\\n                if(mat[i][left]==-5)lug=0;\\n                else if(mat[i][left]==-1) lug=1;\\n                else mat[i][left]&=lug;\\n                \\n                if(mat[i][right]==-5)rug=0;\\n                else if(mat[i][right]==-1) rug=1;\\n                else mat[i][right]&=rug;\\n            }\\n        }\\n        for(int i=0;i<n;i++){\\n            int left = 0,right = m-1;\\n            int lug = 1,rug = 1;\\n            for(;left<m;left++,right--){\\n                if(mat[left][i]==-5)lug=0;\\n                else if(mat[left][i]==-1) lug=1;\\n                else mat[left][i]&=lug;\\n                \\n                if(mat[right][i]==-5)rug=0;\\n                else if(mat[right][i]==-1) rug=1;\\n                else mat[right][i]&=rug;\\n            }\\n        }\\n        int res =0 ;\\n        for(int[] m1: mat){\\n            for(int m11: m1) res+=(m11==1?1:0);\\n        }\\n       // print(mat);\\n        return res;\\n    }\\n    static void print(int[][] mat){\\n        System.out.println(Arrays.deepToString(mat));\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2713446,
                "title": "python3-count-as-you-go-commented-and-easy-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nAs most of the other approaches we need some kind of array to keep track which cells are seen/occupied.\\n\\nAs we want to diffferentiate between occupied by wall/guard or already seen, we need to use ints.\\n\\nThis solution differs a little bit from the others as we are creating our result as we gou and mark our cells. Therefore we do not need to go over our array again to compute the result by summing cells.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nAt first we intialize the array and the number of unseen cells, which are m*n.\\n\\nAfter that we place all the walls and guards. For each occupied cell our result gets automatically decreased by one.\\n\\nThen we iterate over all guards and for each guard we go in every direction and mark the cells as seen. We decrease the result only if the cell was previously unseed.\\n\\nNOTE: Placing the guards already before this loop (in the first loop), saves a lot of time as we can immediately break once we hit a guard or a wall.\\n\\nPlacing the guards in this Loop results in TLE for some test cases.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(len(guards)*(m+n)) as we go through each column and row for each guard in the worst case.\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(m*n)\\n# Code\\n```\\nclass Solution:\\n    def countUnguarded(self, m: int, n: int, guards: List[List[int]], walls: List[List[int]]) -> int:\\n\\n        # make the grid which cells are guarded\\n        unseen = [[1]*n for _ in range(m)]\\n\\n        # initialize a the number of unseen cells\\n        result = m*n\\n\\n        # set all the walls and guards\\n        for rx, cx in walls + guards:\\n\\n            # place the wall\\n            unseen[rx][cx] = 0\\n\\n            # subtract from result\\n            result -= 1\\n        \\n        # now go over all the guards and update result\\n        # grx is guard row index\\n        # gcx is guard column index\\n        # brx is \"blick\" row index (blick is german for view)\\n        # bcx is \"blick\" column index\\n        for grx, gcx in guards:\\n\\n            # go from this position till the left end or until we hit a wall\\n            for bcx in range(gcx-1, -1, -1):\\n\\n                # check whether we change an unseen box\\n                if unseen[grx][bcx] == 1:\\n                    unseen[grx][bcx] = -1\\n                    result -= 1\\n                \\n                # check whether we hit a wall or other guard\\n                elif unseen[grx][bcx] == 0:\\n                    break\\n            \\n            # go from this position to the right end or wall\\n            for bcx in range(gcx+1, n):\\n                \\n                # check whether we change an unseen box\\n                if unseen[grx][bcx] == 1:\\n                    unseen[grx][bcx] = -1\\n                    result -= 1\\n                \\n                # check whether we hit a wall or other guard\\n                elif unseen[grx][bcx] == 0:\\n                    break\\n            \\n            # go from this position up and check for end or walls\\n            for brx in range(grx-1, -1, -1):\\n                \\n                # check whether we change an unseen box\\n                if unseen[brx][gcx] == 1:\\n                    unseen[brx][gcx] = -1\\n                    result -= 1\\n                \\n                # check whether we hit a wall or other guard\\n                elif unseen[brx][gcx] == 0:\\n                    break\\n                \\n            # go from this position down and check for end or walls\\n            for brx in range(grx+1, m):\\n                \\n                # check whether we change an unseen box\\n                if unseen[brx][gcx] == 1:\\n                    unseen[brx][gcx] = -1\\n                    result -= 1\\n                \\n                # check whether we hit a wall or other guard\\n                elif unseen[brx][gcx] == 0:\\n                    break\\n        return result\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def countUnguarded(self, m: int, n: int, guards: List[List[int]], walls: List[List[int]]) -> int:\\n\\n        # make the grid which cells are guarded\\n        unseen = [[1]*n for _ in range(m)]\\n\\n        # initialize a the number of unseen cells\\n        result = m*n\\n\\n        # set all the walls and guards\\n        for rx, cx in walls + guards:\\n\\n            # place the wall\\n            unseen[rx][cx] = 0\\n\\n            # subtract from result\\n            result -= 1\\n        \\n        # now go over all the guards and update result\\n        # grx is guard row index\\n        # gcx is guard column index\\n        # brx is \"blick\" row index (blick is german for view)\\n        # bcx is \"blick\" column index\\n        for grx, gcx in guards:\\n\\n            # go from this position till the left end or until we hit a wall\\n            for bcx in range(gcx-1, -1, -1):\\n\\n                # check whether we change an unseen box\\n                if unseen[grx][bcx] == 1:\\n                    unseen[grx][bcx] = -1\\n                    result -= 1\\n                \\n                # check whether we hit a wall or other guard\\n                elif unseen[grx][bcx] == 0:\\n                    break\\n            \\n            # go from this position to the right end or wall\\n            for bcx in range(gcx+1, n):\\n                \\n                # check whether we change an unseen box\\n                if unseen[grx][bcx] == 1:\\n                    unseen[grx][bcx] = -1\\n                    result -= 1\\n                \\n                # check whether we hit a wall or other guard\\n                elif unseen[grx][bcx] == 0:\\n                    break\\n            \\n            # go from this position up and check for end or walls\\n            for brx in range(grx-1, -1, -1):\\n                \\n                # check whether we change an unseen box\\n                if unseen[brx][gcx] == 1:\\n                    unseen[brx][gcx] = -1\\n                    result -= 1\\n                \\n                # check whether we hit a wall or other guard\\n                elif unseen[brx][gcx] == 0:\\n                    break\\n                \\n            # go from this position down and check for end or walls\\n            for brx in range(grx+1, m):\\n                \\n                # check whether we change an unseen box\\n                if unseen[brx][gcx] == 1:\\n                    unseen[brx][gcx] = -1\\n                    result -= 1\\n                \\n                # check whether we hit a wall or other guard\\n                elif unseen[brx][gcx] == 0:\\n                    break\\n        return result\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2702687,
                "title": "no-tle-bfs-how-to-eliminate-tle-c-explained",
                "content": "The problem is a simple **DFS** problem where you traverse in a all **4-directions** without any **turn** and mark all the cells as **visible** in the process.\\nAfter marking all the cell visible you need to traverse the matrix and find count of all **hidden** cells.\\n\\n# **Why does TLE happens?**\\n\\n **TLE** occurs because you are processing for some of the **cells** which are already marked as **visible**. This ***extra work*** can be eleminiated if you reach a already marked **visible** cell and you check if the **direction** in which this cell was marked is the **same** **direction** your current **DFS** call is moving in, if **yes** then **no** need to mark further as the cells ahead are already marked with some previous **DFS** call which marked the current cell\\n \\n *Note the overlaps of colors in bottom right right matrix state:*\\n\\n![image](https://assets.leetcode.com/users/images/4b00679b-4c3e-4e1b-8f45-f735d8119cad_1665672976.6947653.png)\\n\\n\\n\\n\\n```\\ntypedef pair<int,int> pr;\\nclass Solution {\\npublic:\\n    int n,m;\\n    int dx[4]={-1,1,0,0};\\n    int dy[4]={0,0,-1,1};\\n    \\n    int countUnguarded(int sz1, int sz2, vector<vector<int>>& g, vector<vector<int>>& w) {\\n        \\n        n=sz1;m=sz2;\\n        vector<vector<pr>> a(n,vector<pr>(m,{1,-1}));\\n        \\n        for(auto i:w) a[i[0]][i[1]].first=0;\\n        queue<pair<pr,int> > q;\\n        \\n        // 2->Guard , 1->Empty , 0->Wall 3->Visible\\n        \\n        for(auto i:g) a[i[0]][i[1]].first=2,q.push({{i[0],i[1]},4});\\n        \\n        while(!q.empty()){\\n            \\n            auto curr=q.front().first;\\n            int dir=q.front().second;\\n            q.pop();\\n            \\n            int x=curr.first,y=curr.second;\\n            \\n            a[x][y].first=3;a[x][y].second=dir;\\n            \\n            for(int i=0;i<4;i++){\\n                int x1=x+dx[i],y1=y+dy[i];\\n                \\n                if(x1<0 || y1<0 || x1>n-1 || y1>m-1) continue;\\n                \\n                if(a[x1][y1].first==2 || a[x1][y1].first==0) continue;\\n                \\n                if(a[x1][y1].first==3 && a[x1][y1].second==dir) continue;\\n                \\n                if(dir==i || dir==4) q.push({ {x1,y1} ,i });\\n                \\n            }\\n            \\n        }\\n              \\n        int ans=0;for(auto i:a) for(auto j:i) if(j.first==1) ans++;return ans;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Depth-First Search",
                    "Breadth-First Search"
                ],
                "code": "```\\ntypedef pair<int,int> pr;\\nclass Solution {\\npublic:\\n    int n,m;\\n    int dx[4]={-1,1,0,0};\\n    int dy[4]={0,0,-1,1};\\n    \\n    int countUnguarded(int sz1, int sz2, vector<vector<int>>& g, vector<vector<int>>& w) {\\n        \\n        n=sz1;m=sz2;\\n        vector<vector<pr>> a(n,vector<pr>(m,{1,-1}));\\n        \\n        for(auto i:w) a[i[0]][i[1]].first=0;\\n        queue<pair<pr,int> > q;\\n        \\n        // 2->Guard , 1->Empty , 0->Wall 3->Visible\\n        \\n        for(auto i:g) a[i[0]][i[1]].first=2,q.push({{i[0],i[1]},4});\\n        \\n        while(!q.empty()){\\n            \\n            auto curr=q.front().first;\\n            int dir=q.front().second;\\n            q.pop();\\n            \\n            int x=curr.first,y=curr.second;\\n            \\n            a[x][y].first=3;a[x][y].second=dir;\\n            \\n            for(int i=0;i<4;i++){\\n                int x1=x+dx[i],y1=y+dy[i];\\n                \\n                if(x1<0 || y1<0 || x1>n-1 || y1>m-1) continue;\\n                \\n                if(a[x1][y1].first==2 || a[x1][y1].first==0) continue;\\n                \\n                if(a[x1][y1].first==3 && a[x1][y1].second==dir) continue;\\n                \\n                if(dir==i || dir==4) q.push({ {x1,y1} ,i });\\n                \\n            }\\n            \\n        }\\n              \\n        int ans=0;for(auto i:a) for(auto j:i) if(j.first==1) ans++;return ans;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2694671,
                "title": "count-unguarded-cells-simple-no-dfs-direct-by-loops-comments",
                "content": "\\'\\'\\'\\nclass Solution:\\n    def countUnguarded(self, m: int, n: int, guards: List[List[int]], walls: List[List[int]]) -> int:\\n        l=[[0 for x in range(n)]for y in range(m)]\\n        for i in walls:\\n            x=i[0]\\n            y=i[1]\\n            l[x][y]=1\\n        for i in guards:\\n            x=i[0]\\n            y=i[1]\\n            l[x][y]=2\\n        \\n        \\n        \\n        \\n        for i in guards:\\n            x=i[0]\\n            y=i[1]\\n            #up\\n            for up in range(x-1,-1,-1):\\n                if l[up][y]==1 or l[up][y]==2:\\n                    break\\n                else:\\n                    l[up][y]=3\\n            #down\\n            for down in range(x+1,m):\\n                if l[down][y]==1 or l[down][y]==2:\\n                    break\\n                else:\\n                    l[down][y]=3\\n            #left\\n            for left in range(y-1,-1,-1):\\n                if l[x][left]==1 or l[x][left]==2:\\n                    break\\n                else:\\n                    l[x][left]=3\\n            #right\\n            for right in range(y+1,n):\\n                if l[x][right]==1 or l[x][right]==2:\\n                    break\\n                else:\\n                    l[x][right]=3\\n        c=0\\n        for i in range(m):\\n            for j in range(n):\\n                if l[i][j]==0:\\n                    c+=1\\n        return c\\n\\t\\t\\'\\'\\'",
                "solutionTags": [
                    "Python"
                ],
                "code": "\\'\\'\\'\\nclass Solution:\\n    def countUnguarded(self, m: int, n: int, guards: List[List[int]], walls: List[List[int]]) -> int:\\n        l=[[0 for x in range(n)]for y in range(m)]\\n        for i in walls:\\n            x=i[0]\\n            y=i[1]\\n            l[x][y]=1\\n        for i in guards:\\n            x=i[0]\\n            y=i[1]\\n            l[x][y]=2\\n        \\n        \\n        \\n        \\n        for i in guards:\\n            x=i[0]\\n            y=i[1]\\n            #up\\n            for up in range(x-1,-1,-1):\\n                if l[up][y]==1 or l[up][y]==2:\\n                    break\\n                else:\\n                    l[up][y]=3\\n            #down\\n            for down in range(x+1,m):\\n                if l[down][y]==1 or l[down][y]==2:\\n                    break\\n                else:\\n                    l[down][y]=3\\n            #left\\n            for left in range(y-1,-1,-1):\\n                if l[x][left]==1 or l[x][left]==2:\\n                    break\\n                else:\\n                    l[x][left]=3\\n            #right\\n            for right in range(y+1,n):\\n                if l[x][right]==1 or l[x][right]==2:\\n                    break\\n                else:\\n                    l[x][right]=3\\n        c=0\\n        for i in range(m):\\n            for j in range(n):\\n                if l[i][j]==0:\\n                    c+=1\\n        return c\\n\\t\\t\\'\\'\\'",
                "codeTag": "Java"
            },
            {
                "id": 2678234,
                "title": "c-check-4-directions",
                "content": "```\\n    enum State{\\n        NO,\\n        YES,\\n        GUARD,\\n        WALL\\n    };\\n        \\n    int countUnguarded(int m, int n, vector<vector<int>>& guards, vector<vector<int>>& walls) {\\n        auto mat = vector(m, vector(n, State::NO));\\n        for(auto& v:guards) mat[v[0]][v[1]] = GUARD;\\n        for(auto& v:walls) mat[v[0]][v[1]] = WALL;\\n        \\n        auto op = [&](int i, int j, State& pre) mutable {\\n            auto& x = mat[i][j];\\n            if (x == NO){\\n                if (pre == GUARD) {\\n                    x = YES;\\n                }\\n            }\\n            else if (x == GUARD || x == WALL) pre = x;\\n        };\\n        \\n        for(int j=0;j<n;j++){\\n            State pre = WALL;\\n            for(int i=0; i<m; i++) op(i, j, pre);\\n            pre = WALL;\\n            for(int i=m-1; i>=0; i--) op(i, j, pre);\\n        }\\n        \\n        for(int i=0;i<m;i++){\\n            State pre = WALL;\\n            for(int j=0; j<n; j++)  op(i, j, pre);\\n            pre = WALL;\\n            for(int j=n-1; j>=0; j--) op(i, j, pre);\\n        }        \\n        \\n        int res = 0;\\n        for(auto& v:mat) res += count(v.begin(), v.end(), State::NO);        \\n        return res;\\n    }",
                "solutionTags": [],
                "code": "```\\n    enum State{\\n        NO,\\n        YES,\\n        GUARD,\\n        WALL\\n    };\\n        \\n    int countUnguarded(int m, int n, vector<vector<int>>& guards, vector<vector<int>>& walls) {\\n        auto mat = vector(m, vector(n, State::NO));\\n        for(auto& v:guards) mat[v[0]][v[1]] = GUARD;\\n        for(auto& v:walls) mat[v[0]][v[1]] = WALL;\\n        \\n        auto op = [&](int i, int j, State& pre) mutable {\\n            auto& x = mat[i][j];\\n            if (x == NO){\\n                if (pre == GUARD) {\\n                    x = YES;\\n                }\\n            }\\n            else if (x == GUARD || x == WALL) pre = x;\\n        };\\n        \\n        for(int j=0;j<n;j++){\\n            State pre = WALL;\\n            for(int i=0; i<m; i++) op(i, j, pre);\\n            pre = WALL;\\n            for(int i=m-1; i>=0; i--) op(i, j, pre);\\n        }\\n        \\n        for(int i=0;i<m;i++){\\n            State pre = WALL;\\n            for(int j=0; j<n; j++)  op(i, j, pre);\\n            pre = WALL;\\n            for(int j=n-1; j>=0; j--) op(i, j, pre);\\n        }        \\n        \\n        int res = 0;\\n        for(auto& v:mat) res += count(v.begin(), v.end(), State::NO);        \\n        return res;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 2651735,
                "title": "c-easy-short-answer",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int countUnguarded(int m, int n, vector<vector<int>>& g, vector<vector<int>>& w) {\\n        vector<vector<int>> v(m, vector<int> (n,0));\\n        int k = w.size();\\n        for(int i=0;i<k;i++){\\n            int x = w[i][0], y = w[i][1];\\n            v[x][y] = -2;\\n        }\\n        k = g.size();\\n        for(int i=0;i<k;i++){\\n            int x = g[i][0], y = g[i][1];\\n            v[x][y] = 2;\\n        }\\n        for(int j=0;j<k;j++){\\n            int x = g[j][0], y = g[j][1];\\n            for(int i=x-1;i>=0;i--){ \\n                if(v[i][y]==-2 || v[i][y]==2) break;\\n                v[i][y] = 1;\\n            }\\n            for(int i=x+1;i<m;i++){\\n                if(v[i][y]==-2 || v[i][y]==2) break;\\n                v[i][y] = 1;\\n            }\\n            for(int i=y-1;i>=0;i--){ \\n                if(v[x][i]==-2 || v[x][i]==2) break;\\n                v[x][i] = 1;\\n            }\\n            for(int i=y+1;i<n;i++){ \\n                if(v[x][i]==-2 || v[x][i]==2) break;\\n                v[x][i] = 1;\\n            }\\n        }\\n        int ans = 0;\\n        for(int i=0;i<m;i++){\\n            for(int j=0;j<n;j++){\\n                if(!v[i][j]) ans++;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int countUnguarded(int m, int n, vector<vector<int>>& g, vector<vector<int>>& w) {\\n        vector<vector<int>> v(m, vector<int> (n,0));\\n        int k = w.size();\\n        for(int i=0;i<k;i++){\\n            int x = w[i][0], y = w[i][1];\\n            v[x][y] = -2;\\n        }\\n        k = g.size();\\n        for(int i=0;i<k;i++){\\n            int x = g[i][0], y = g[i][1];\\n            v[x][y] = 2;\\n        }\\n        for(int j=0;j<k;j++){\\n            int x = g[j][0], y = g[j][1];\\n            for(int i=x-1;i>=0;i--){ \\n                if(v[i][y]==-2 || v[i][y]==2) break;\\n                v[i][y] = 1;\\n            }\\n            for(int i=x+1;i<m;i++){\\n                if(v[i][y]==-2 || v[i][y]==2) break;\\n                v[i][y] = 1;\\n            }\\n            for(int i=y-1;i>=0;i--){ \\n                if(v[x][i]==-2 || v[x][i]==2) break;\\n                v[x][i] = 1;\\n            }\\n            for(int i=y+1;i<n;i++){ \\n                if(v[x][i]==-2 || v[x][i]==2) break;\\n                v[x][i] = 1;\\n            }\\n        }\\n        int ans = 0;\\n        for(int i=0;i<m;i++){\\n            for(int j=0;j<n;j++){\\n                if(!v[i][j]) ans++;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2603369,
                "title": "c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    \\n    int countUnguarded(int m, int n, vector<vector<int>>& guards, vector<vector<int>>& walls) \\n    {\\n        vector<vector<int>> v(m,vector<int> (n,0));\\n        for(auto &a : walls)\\n        {\\n            v[a[0]][a[1]]=-1;\\n        }\\n        for(auto &a : guards)\\n        {\\n            v[a[0]][a[1]]=1;\\n        }\\n        for(auto &a : guards)\\n        {\\n            int x = a[0];\\n            int y = a[1];\\n            for(int i=x-1; i>=0; i--)\\n            {\\n                if(v[i][y]==-1 || v[i][y]==1)\\n                    break;\\n                else\\n                    v[i][y]=2;\\n            }\\n            for(int i=x+1; i<m; i++)\\n            {\\n                if(v[i][y]==-1 || v[i][y]==1)\\n                    break;\\n                else\\n                    v[i][y]=2;\\n            }\\n            for(int i=y-1; i>=0; i--)\\n            {\\n                if(v[x][i]==1 || v[x][i]==-1)\\n                    break;\\n                else\\n                    v[x][i]=2;\\n            }\\n            for(int i=y+1; i<n; i++)\\n            {\\n                if(v[x][i]==1 || v[x][i]==-1)\\n                    break;\\n                else\\n                    v[x][i]=2;\\n            }\\n        }\\n        int ans=0;\\n        for(int i=0; i<m; i++)\\n            for(int j=0; j<n; j++)\\n                if(!v[i][j])\\n                    ans++;\\n        return ans;\\n    }\\n};",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n    \\n    int countUnguarded(int m, int n, vector<vector<int>>& guards, vector<vector<int>>& walls) \\n    {\\n        vector<vector<int>> v(m,vector<int> (n,0));\\n        for(auto &a : walls)\\n        {\\n            v[a[0]][a[1]]=-1;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2578482,
                "title": "c-simple",
                "content": "```\\nclass Solution {\\npublic:\\n    int countUnguarded(int m, int n, vector<vector<int>>& guards, vector<vector<int>>& walls) {\\n        vector<vector<char>> field(m, vector<char>(n, \\'e\\'));\\n        for(const auto &g : guards) {\\n            field[g[0]][g[1]] = \\'g\\';\\n        }\\n        for(const auto &w : walls) {\\n            field[w[0]][w[1]] = \\'w\\';\\n        }\\n        for(const auto &g : guards) {\\n            const int r = g[0];\\n            const int c = g[1];\\n            // move up until we reach a guard, a wall or a border\\n            for(int i = r - 1; i >= 0; --i) {\\n                if(field[i][c] == \\'e\\' || field[i][c] == \\'p\\') {\\n                    field[i][c] = \\'p\\';\\n                } else\\n                    break;\\n            }\\n            // move down until we reach a guard, a wall or a border\\n            for(int i = r + 1; i < m; ++i) {\\n                if(field[i][c] == \\'e\\' || field[i][c] == \\'p\\') {\\n                    field[i][c] = \\'p\\';\\n                } else\\n                    break;\\n            }\\n            // move left until we reach a guard, a wall or a border\\n            for(int i = c - 1; i >= 0; --i) {\\n                if(field[r][i] == \\'e\\' || field[r][i] == \\'p\\') {\\n                    field[r][i] = \\'p\\';\\n                } else\\n                    break;\\n            }\\n            // move right until we reach a guard, a wall or a border\\n            for(int i = c + 1; i < n; ++i) {\\n                if(field[r][i] == \\'e\\' || field[r][i] == \\'p\\') {\\n                    field[r][i] = \\'p\\';\\n                } else\\n                    break;\\n            }\\n        }\\n        \\n        int ans = 0;\\n        // count a number of non-protected cells (\\'e\\' -> empty)\\n        for(const auto &r : field) {\\n            ans += count(r.cbegin(), r.cend(), \\'e\\');\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int countUnguarded(int m, int n, vector<vector<int>>& guards, vector<vector<int>>& walls) {\\n        vector<vector<char>> field(m, vector<char>(n, \\'e\\'));\\n        for(const auto &g : guards) {\\n            field[g[0]][g[1]] = \\'g\\';\\n        }\\n        for(const auto &w : walls) {\\n            field[w[0]][w[1]] = \\'w\\';\\n        }\\n        for(const auto &g : guards) {\\n            const int r = g[0];\\n            const int c = g[1];\\n            // move up until we reach a guard, a wall or a border\\n            for(int i = r - 1; i >= 0; --i) {\\n                if(field[i][c] == \\'e\\' || field[i][c] == \\'p\\') {\\n                    field[i][c] = \\'p\\';\\n                } else\\n                    break;\\n            }\\n            // move down until we reach a guard, a wall or a border\\n            for(int i = r + 1; i < m; ++i) {\\n                if(field[i][c] == \\'e\\' || field[i][c] == \\'p\\') {\\n                    field[i][c] = \\'p\\';\\n                } else\\n                    break;\\n            }\\n            // move left until we reach a guard, a wall or a border\\n            for(int i = c - 1; i >= 0; --i) {\\n                if(field[r][i] == \\'e\\' || field[r][i] == \\'p\\') {\\n                    field[r][i] = \\'p\\';\\n                } else\\n                    break;\\n            }\\n            // move right until we reach a guard, a wall or a border\\n            for(int i = c + 1; i < n; ++i) {\\n                if(field[r][i] == \\'e\\' || field[r][i] == \\'p\\') {\\n                    field[r][i] = \\'p\\';\\n                } else\\n                    break;\\n            }\\n        }\\n        \\n        int ans = 0;\\n        // count a number of non-protected cells (\\'e\\' -> empty)\\n        for(const auto &r : field) {\\n            ans += count(r.cbegin(), r.cend(), \\'e\\');\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2569406,
                "title": "c-iterative-dfs",
                "content": "### C++ Solution:\\n```\\nclass Solution {\\n    int countGuarded(int m, int n, vector<vector<int>>& guards, set<pair<int,int>>& obstacles)\\n    {\\n        set<pair<int,int>> guardedCells;\\n        \\n        for (const auto& guard : guards)\\n        {\\n            int x = guard[0], y = guard[1];\\n            \\n            // top\\n            x--;\\n            while (x >= 0)\\n            {\\n                if (obstacles.find({x,y}) == obstacles.end())\\n                    guardedCells.insert({x,y});\\n                else\\n                    break;\\n                x--;\\n            }\\n            \\n            x = guard[0];\\n            \\n            // bottom\\n            x++;\\n            while (x < m)\\n            {\\n                if (obstacles.find({x,y}) == obstacles.end())\\n                    guardedCells.insert({x,y});\\n                else\\n                    break;\\n                x++;\\n            }\\n            \\n            x = guard[0];\\n            \\n            // left\\n            y--;\\n            while (y >= 0)\\n            {\\n                if (obstacles.find({x,y}) == obstacles.end())\\n                    guardedCells.insert({x,y});\\n                else\\n                    break;\\n                y--;\\n            }\\n            \\n            y = guard[1];\\n            \\n            // right\\n            y++;\\n            while (y < n)\\n            {\\n                if (obstacles.find({x,y}) == obstacles.end())\\n                    guardedCells.insert({x,y});\\n                else\\n                    break;\\n                y++;\\n            }\\n            \\n            y = guard[1];\\n        }\\n        \\n        // for (auto k : guardedCells)\\n        //     cout << k.first << \" \" << k.second << endl;\\n        \\n        return guardedCells.size();\\n    }\\npublic:\\n    int countUnguarded(int m, int n, vector<vector<int>>& guards, vector<vector<int>>& walls) {\\n        int totalCells = m * n;\\n        \\n        set<pair<int,int>> obstacles;\\n        \\n        for (const auto& guard : guards)\\n            obstacles.insert({guard[0],guard[1]});\\n        for (const auto& wall : walls)\\n            obstacles.insert({wall[0],wall[1]});\\n        \\n        return totalCells - countGuarded(m,n,guards,obstacles) - obstacles.size();\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\n    int countGuarded(int m, int n, vector<vector<int>>& guards, set<pair<int,int>>& obstacles)\\n    {\\n        set<pair<int,int>> guardedCells;\\n        \\n        for (const auto& guard : guards)\\n        {\\n            int x = guard[0], y = guard[1];\\n            \\n            // top\\n            x--;\\n            while (x >= 0)\\n            {\\n                if (obstacles.find({x,y}) == obstacles.end())\\n                    guardedCells.insert({x,y});\\n                else\\n                    break;\\n                x--;\\n            }\\n            \\n            x = guard[0];\\n            \\n            // bottom\\n            x++;\\n            while (x < m)\\n            {\\n                if (obstacles.find({x,y}) == obstacles.end())\\n                    guardedCells.insert({x,y});\\n                else\\n                    break;\\n                x++;\\n            }\\n            \\n            x = guard[0];\\n            \\n            // left\\n            y--;\\n            while (y >= 0)\\n            {\\n                if (obstacles.find({x,y}) == obstacles.end())\\n                    guardedCells.insert({x,y});\\n                else\\n                    break;\\n                y--;\\n            }\\n            \\n            y = guard[1];\\n            \\n            // right\\n            y++;\\n            while (y < n)\\n            {\\n                if (obstacles.find({x,y}) == obstacles.end())\\n                    guardedCells.insert({x,y});\\n                else\\n                    break;\\n                y++;\\n            }\\n            \\n            y = guard[1];\\n        }\\n        \\n        // for (auto k : guardedCells)\\n        //     cout << k.first << \" \" << k.second << endl;\\n        \\n        return guardedCells.size();\\n    }\\npublic:\\n    int countUnguarded(int m, int n, vector<vector<int>>& guards, vector<vector<int>>& walls) {\\n        int totalCells = m * n;\\n        \\n        set<pair<int,int>> obstacles;\\n        \\n        for (const auto& guard : guards)\\n            obstacles.insert({guard[0],guard[1]});\\n        for (const auto& wall : walls)\\n            obstacles.insert({wall[0],wall[1]});\\n        \\n        return totalCells - countGuarded(m,n,guards,obstacles) - obstacles.size();\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2563716,
                "title": "c-dfs",
                "content": "the idea is like others.\\n* we need to fill in 4 directions(`up`, `down`, `left`, `right`) while there is a guard(`2`)\\n* stop fill when there is wall (`3`)/guard(`2`) or invalid position\\n\\n```\\nclass Solution {\\npublic:\\n    int countUnguarded(int m, int n, vector<vector<int>>& guards, vector<vector<int>>& walls) {\\n        vector<vector<int>> graphs(m, vector<int>(n));\\n\\t\\t\\n\\t\\t// four directions\\n        vector<pair<int, int>> directions {\\n            {1, 0}, {0, 1}, {-1, 0}, {0, -1}\\n        };\\n\\t\\t\\n        for (auto& guard: guards)\\n            graphs[guard[0]][guard[1]] = 2;\\n        for (auto& wall: walls)\\n            graphs[wall[0]][wall[1]] = 3;\\n        \\n        function<void(int, int, pair<int,int>)> dfs = [&](int i, int j, pair<int, int> direction){\\n            if (i < 0 || j < 0 || i >= m || j >= n || graphs[i][j] == 3 || graphs[i][j] == 2)\\n                return;\\n            graphs[i][j] = 1;\\n            dfs(i + direction.first, j + direction.second, direction);\\n        };\\n        \\n        for (int i = 0; i < m; i++)\\n            for (int j = 0; j < n; j++) {\\n                if (graphs[i][j] != 2) continue;\\n\\n                for (auto& direct: directions)\\n                    dfs(i + direct.first, j + direct.second, direct);\\n            }\\n        \\n        int ans = 0;\\n        for (int i = 0; i < m; i++)\\n            for (int j = 0; j < n; j++)\\n                if (graphs[i][j] == 0)\\n                    ans++;\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int countUnguarded(int m, int n, vector<vector<int>>& guards, vector<vector<int>>& walls) {\\n        vector<vector<int>> graphs(m, vector<int>(n));\\n\\t\\t\\n\\t\\t// four directions\\n        vector<pair<int, int>> directions {\\n            {1, 0}, {0, 1}, {-1, 0}, {0, -1}\\n        };\\n\\t\\t\\n        for (auto& guard: guards)\\n            graphs[guard[0]][guard[1]] = 2;\\n        for (auto& wall: walls)\\n            graphs[wall[0]][wall[1]] = 3;\\n        \\n        function<void(int, int, pair<int,int>)> dfs = [&](int i, int j, pair<int, int> direction){\\n            if (i < 0 || j < 0 || i >= m || j >= n || graphs[i][j] == 3 || graphs[i][j] == 2)\\n                return;\\n            graphs[i][j] = 1;\\n            dfs(i + direction.first, j + direction.second, direction);\\n        };\\n        \\n        for (int i = 0; i < m; i++)\\n            for (int j = 0; j < n; j++) {\\n                if (graphs[i][j] != 2) continue;\\n\\n                for (auto& direct: directions)\\n                    dfs(i + direct.first, j + direct.second, direct);\\n            }\\n        \\n        int ans = 0;\\n        for (int i = 0; i < m; i++)\\n            for (int j = 0; j < n; j++)\\n                if (graphs[i][j] == 0)\\n                    ans++;\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2555591,
                "title": "java-simple-dfs-solution-easy-to-understand",
                "content": "\\tclass Solution {\\n\\t\\tint[] dRow = new int[]{-1, 0, 1, 0};\\n\\t\\tint[] dCol = new int[]{0, 1, 0, -1};\\n\\n\\t\\tpublic int countUnguarded(int m, int n, int[][] guards, int[][] walls) {        \\n\\t\\t\\tint[][] grid = new int[m][n];\\n\\n\\t\\t\\tfor(int[] loc : guards) {\\n\\t\\t\\t\\tgrid[loc[0]][loc[1]] = 1;\\n\\t\\t\\t}\\n\\n\\t\\t\\tfor(int[] loc : walls) {\\n\\t\\t\\t\\tgrid[loc[0]][loc[1]] = 2;\\n\\t\\t\\t}\\n\\n\\t\\t\\tboolean[][][] isVisited = new boolean[m][n][4];\\n\\n\\t\\t\\tfor(int i=0; i<m; i++) {\\n\\t\\t\\t\\tfor(int j=0; j<n; j++) {\\n\\t\\t\\t\\t\\tif(grid[i][j] == 1) {\\n\\t\\t\\t\\t\\t\\tfor(int k=0; k<4; k++) {\\n\\t\\t\\t\\t\\t\\t\\tif(!isVisited[i][j][k]) {\\n\\t\\t\\t\\t\\t\\t\\t\\tisVisited[i][j][k] = true;\\n\\t\\t\\t\\t\\t\\t\\t\\thelper(i, j, k, grid, isVisited);\\n\\t\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\n\\t\\t\\tint ans = 0;\\n\\t\\t\\tfor(int i=0; i<m; i++) {\\n\\t\\t\\t\\tfor(int j=0; j<n; j++) {\\n\\t\\t\\t\\t\\tif(grid[i][j] == 0) ans++;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn ans;\\n\\n\\t\\t}\\n\\n\\t\\tpublic void helper(int row, int col, int dir, int[][] grid, boolean[][][] isVisited) {\\n\\t\\t\\tint nRow = row + dRow[dir];\\n\\t\\t\\tint nCol = col + dCol[dir];\\n\\n\\t\\t\\tif(nRow < 0 || nRow >= grid.length || nCol < 0 || nCol >= grid[0].length || isVisited[nRow][nCol][dir] || grid[nRow][nCol] == 2 || grid[nRow][nCol] == 1) return;\\n\\n\\t\\t\\tgrid[nRow][nCol] = 3;\\n\\t\\t\\tisVisited[nRow][nCol][dir] = true;\\n\\t\\t\\thelper(nRow, nCol, dir, grid, isVisited);\\n\\t\\t}\\n\\t}",
                "solutionTags": [],
                "code": "class Solution {\\n\\t\\tint[] dRow = new int[]{-1, 0, 1, 0}",
                "codeTag": "Java"
            },
            {
                "id": 2555474,
                "title": "c-guard-path-solution-with-explanation-sep-9th-2022-100-speed-rank",
                "content": "The below is based on @votrubac solution [here](https://leetcode.com/problems/count-unguarded-cells-in-the-grid/discuss/2001912/Bitmask-Tracing-vs.-Binary-Search), though instead of doing a bitmask we opt for a simpler scheme just count if we are about to walk through a path already traveled by another guard.\\n \\n This does a few nice things for speed and clarity relative to the original post, though could probably be improved\\n \\n1. Removes iterating over the guards original position each time in the innermost loop\\n2. Instead of using a bit mask the program checks if another guard has already traveled down that particular path or if we hit a wall\\n3. Moves the iterating of i and j out of the loop body and into the loop decleration \\n4. Uses a constexpr array for the directions\\n5. Adds a matrix class for the grid\\n\\nI couldn\\'t think of a counter example that makes the below wrong but would be very happy if someone could fine one!\\n\\nJust to clarify on the value 2 in the below. Imagine we have a guard coming from the top and the right whose paths intersect. Once we put a value of 2 at where their paths intersect, if a guard comes from the right or bottom then once they see 2 other guards have already gone down that path they know there is no need to travel any further. Similarly walls have a value of 2 since we want the guard to stop at that point.\\n\\n```cpp\\n// So that our grid is one \\n// big chunk of memory instead of a vector of vectors\\nstruct Matrix {\\n  int* arr;\\n  int rows;\\n  int cols;\\n  Matrix(const int n, const int m) noexcept\\n      : rows(n), cols(m), arr(static_cast<int*>(calloc(n * m, sizeof(int)))) {}\\n  inline int& operator()(int i, int j) noexcept { return arr[i * cols + j]; }\\n};\\n\\nclass Solution {\\n public:\\n  using array_2i = std::array<int, 2>;\\n  // up, right, down, left\\n  static constexpr std::array<array_2i, 4> directions{array_2i{0, 1}, \\n                                                      array_2i{1, 0},\\n                                                      array_2i{0, -1},\\n                                                      array_2i{-1, 0}};\\n  int countUnguarded(int m, int n, vector<vector<int>>& guards,\\n                     vector<vector<int>>& walls) {\\n    int not_guarded = m * n - walls.size() - guards.size();\\n    Matrix grid(m, n);\\n    /*\\n     * These get set to 2 just to indicate we\\'ve traveled through them\\n     * at least once. At that point we intersect with another \\n     *  guard so no need to keep going.\\n     * NOTE: That\\'s my intuition on the above, I think it is correct?\\n     */  \\n    for (auto&& wall : walls) {\\n      grid(wall[0], wall[1]) = 2;\\n    }\\n    for (auto&& guard : guards) {\\n      grid(guard[0], guard[1]) = 2;\\n    }\\n    for (auto&& guard : guards) {\\n      for (auto&& path_direction : directions) {\\n        /**\\n         * For each guard and direction, travel until we hit:\\n         * 1. An edge (either negative values or positive oob)\\n         * 2. We come across another guards path\\n         */\\n        for (int i = guard[0] + path_direction[0],\\n                 j = guard[1] + path_direction[1];\\n              min(i, j) >= 0 && i < m && j < n && grid(i, j) < 2;\\n              i += path_direction[0],\\n              j += path_direction[1]) {\\n          if (grid(i, j) == 0) {\\n            --not_guarded;\\n            grid(i, j) += 1;\\n          }\\n        }\\n      }\\n    }\\n    return not_guarded;\\n  }\\n};\\n```\\n\\nThanks for reading! Please like this post if you use the code and feel free to comment with any improvements or questions! One thing I didn\\'t try but could be faster it to forgo using a grid and instead have an unordered map with a cheap hash function to keep track of where the guards have traveled.",
                "solutionTags": [],
                "code": "```cpp\\n// So that our grid is one \\n// big chunk of memory instead of a vector of vectors\\nstruct Matrix {\\n  int* arr;\\n  int rows;\\n  int cols;\\n  Matrix(const int n, const int m) noexcept\\n      : rows(n), cols(m), arr(static_cast<int*>(calloc(n * m, sizeof(int)))) {}\\n  inline int& operator()(int i, int j) noexcept { return arr[i * cols + j]; }\\n};\\n\\nclass Solution {\\n public:\\n  using array_2i = std::array<int, 2>;\\n  // up, right, down, left\\n  static constexpr std::array<array_2i, 4> directions{array_2i{0, 1}, \\n                                                      array_2i{1, 0},\\n                                                      array_2i{0, -1},\\n                                                      array_2i{-1, 0}};\\n  int countUnguarded(int m, int n, vector<vector<int>>& guards,\\n                     vector<vector<int>>& walls) {\\n    int not_guarded = m * n - walls.size() - guards.size();\\n    Matrix grid(m, n);\\n    /*\\n     * These get set to 2 just to indicate we\\'ve traveled through them\\n     * at least once. At that point we intersect with another \\n     *  guard so no need to keep going.\\n     * NOTE: That\\'s my intuition on the above, I think it is correct?\\n     */  \\n    for (auto&& wall : walls) {\\n      grid(wall[0], wall[1]) = 2;\\n    }\\n    for (auto&& guard : guards) {\\n      grid(guard[0], guard[1]) = 2;\\n    }\\n    for (auto&& guard : guards) {\\n      for (auto&& path_direction : directions) {\\n        /**\\n         * For each guard and direction, travel until we hit:\\n         * 1. An edge (either negative values or positive oob)\\n         * 2. We come across another guards path\\n         */\\n        for (int i = guard[0] + path_direction[0],\\n                 j = guard[1] + path_direction[1];\\n              min(i, j) >= 0 && i < m && j < n && grid(i, j) < 2;\\n              i += path_direction[0],\\n              j += path_direction[1]) {\\n          if (grid(i, j) == 0) {\\n            --not_guarded;\\n            grid(i, j) += 1;\\n          }\\n        }\\n      }\\n    }\\n    return not_guarded;\\n  }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2550196,
                "title": "c-dfs",
                "content": "```\\nclass Solution {\\npublic:\\n       int s=0;\\n        \\n  void is(int m,int n,int i,int j,vector<vector<char>>& g,int r,int c)\\n    {\\n      j++;\\n      while(j<n && ((g[r][j]==\\'0\\')||(g[r][j]==\\'p\\')))\\n      {\\n       if(g[r][j]==\\'w\\')\\n        break;\\n          g[r][j]=\\'p\\';\\n          j++;\\n      }\\n  \\n      i++;\\n      while(i<m && ((g[i][c]==\\'0\\')||(g[i][c]==\\'p\\')))\\n          {\\n       if(g[i][c]==\\'w\\')\\n        break;\\n          g[i][c]=\\'p\\';\\n          i++;\\n          }\\n      \\n   \\n      j=c;\\n      i=r;\\n      j--;\\n      while(j>=0 &&  ((g[r][j]==\\'0\\')||(g[r][j]==\\'p\\')))\\n           {\\n       if(g[r][j]==\\'w\\')\\n        break;\\n          g[r][j]=\\'p\\';\\n          j--;\\n          }\\n      \\n      i--;\\n      while(i>=0 &&  ((g[i][c]==\\'0\\')||(g[i][c]==\\'p\\')))\\n           {\\n       if(g[i][c]==\\'w\\')\\n        break;\\n          g[i][c]=\\'p\\';\\n          i--;\\n          }\\n      \\n        \\n    }\\n    \\n    \\n    int countUnguarded(int m, int n, vector<vector<int>>& guards, vector<vector<int>>& walls) {\\n               \\n        vector<char> a(n,\\'0\\');\\n         \\n        vector<vector<char>> grid(m,a);\\n       \\n\\n            for(int i=0;i<guards.size();i++)\\n            {\\n                grid[guards[i][0]][guards[i][1]]=\\'g\\';\\n            }\\n        \\n        for(int i=0;i<walls.size();i++)\\n            {\\n                grid[walls[i][0]][walls[i][1]]=\\'w\\';\\n            }\\n        \\n        \\n        \\n        for(int i=0;i<m;i++)\\n        {\\n            for(int j=0;j<n;j++)\\n            {\\n                if(grid[i][j]==\\'g\\')\\n                    is(m,n,i,j,grid,i,j);\\n            }\\n            \\n        }\\n        \\n    for(int i=0;i<m;i++)\\n        {\\n            for(int j=0;j<n;j++)\\n            {\\n               if(grid[i][j]==\\'0\\')\\n                   s++;\\n            }\\n           \\n        }\\n        \\n        \\n        return s;\\n        \\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n       int s=0;\\n        \\n  void is(int m,int n,int i,int j,vector<vector<char>>& g,int r,int c)\\n    {\\n      j++;\\n      while(j<n && ((g[r][j]==\\'0\\')||(g[r][j]==\\'p\\')))\\n      {\\n       if(g[r][j]==\\'w\\')\\n        break;\\n          g[r][j]=\\'p\\';\\n          j++;\\n      }",
                "codeTag": "Java"
            },
            {
                "id": 2510379,
                "title": "python-simple-for-loops",
                "content": "```\\n def countUnguarded(self, m: int, n: int, guards: List[List[int]], walls: List[List[int]]) -> int:\\n        \\n        ggg = guards.copy()\\n        guards = set([tuple(x) for x in guards])\\n        walls = set([tuple(x) for x in walls])\\n        guardedCells = set()\\n        for gg in range(len(guards)): \\n            g = ggg[gg]\\n            for i in range(g[0]+1, m):\\n                if (i,g[1]) not in walls and (i,g[1]) not in guards :                    \\n                    guardedCells.add((i,g[1]))\\n                else:\\n                    break\\n            \\n            for i in range(g[0]-1, -1, -1):\\n                if (i, g[1]) not in walls and (i,g[1]) not in guards :                    \\n                    guardedCells.add((i,g[1]))\\n                else:\\n                    break\\n                    \\n            for j in range(g[1]+1, n):\\n                if (g[0],j) not in walls and (g[0],j) not in guards :                    \\n                    guardedCells.add((g[0],j))\\n                else:\\n                    break\\n                    \\n            for j in range(g[1]-1, -1, -1):\\n                if (g[0], j) not in walls and (g[0],j) not in guards :                    \\n                    guardedCells.add((g[0],j))\\n                else:\\n                    break\\n\\n        return m*n - len(guards) - len(walls) - len(guardedCells)\\n                        \\n                    \\n",
                "solutionTags": [],
                "code": "```\\n def countUnguarded(self, m: int, n: int, guards: List[List[int]], walls: List[List[int]]) -> int:\\n        \\n        ggg = guards.copy()\\n        guards = set([tuple(x) for x in guards])\\n        walls = set([tuple(x) for x in walls])\\n        guardedCells = set()\\n        for gg in range(len(guards)): \\n            g = ggg[gg]\\n            for i in range(g[0]+1, m):\\n                if (i,g[1]) not in walls and (i,g[1]) not in guards :                    \\n                    guardedCells.add((i,g[1]))\\n                else:\\n                    break\\n            \\n            for i in range(g[0]-1, -1, -1):\\n                if (i, g[1]) not in walls and (i,g[1]) not in guards :                    \\n                    guardedCells.add((i,g[1]))\\n                else:\\n                    break\\n                    \\n            for j in range(g[1]+1, n):\\n                if (g[0],j) not in walls and (g[0],j) not in guards :                    \\n                    guardedCells.add((g[0],j))\\n                else:\\n                    break\\n                    \\n            for j in range(g[1]-1, -1, -1):\\n                if (g[0], j) not in walls and (g[0],j) not in guards :                    \\n                    guardedCells.add((g[0],j))\\n                else:\\n                    break\\n\\n        return m*n - len(guards) - len(walls) - len(guardedCells)\\n                        \\n                    \\n",
                "codeTag": "Python3"
            },
            {
                "id": 2505149,
                "title": "python-solution-using-dfs-faster-than-80",
                "content": "```\\nclass Solution:\\n    def countUnguarded(self, m: int, n: int, guards: List[List[int]], walls: List[List[int]]) -> int:\\n        directions = [[1, 0], [-1, 0], [0, 1], [0, -1]]\\n        grid, ans = [[\\'\\' for I in range(n)] for _ in range(m)], 0\\n        for guard in guards:\\n            grid[guard[0]][guard[1]] = \\'G\\'\\n        for wall in walls:\\n            grid[wall[0]][wall[1]] = \\'W\\'\\n            \\n        def dfs(m: int, n: int, x: int, y: int, grid: List[List[int]], idx: int) -> None:\\n            if x >= m or y >= n or x < 0 or y < 0 or grid[x][y] == \\'G\\' or grid[x][y] == \\'W\\':\\n                return\\n            \\n            grid[x][y] = \\'V\\'\\n            dfs(m, n, x + directions[idx][0], y + directions[idx][1], grid, idx)\\n            \\n        for guard in guards:\\n            grid[guard[0]][guard[1]] = \\'V\\'\\n            for idx in range(4):\\n                dfs(m, n, guard[0], guard[1], grid, idx)\\n            grid[guard[0]][guard[1]] = \\'G\\'\\n        for row in grid:\\n            ans += row.count(\\'\\')\\n        return ans\\n```",
                "solutionTags": [
                    "Python",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```\\nclass Solution:\\n    def countUnguarded(self, m: int, n: int, guards: List[List[int]], walls: List[List[int]]) -> int:\\n        directions = [[1, 0], [-1, 0], [0, 1], [0, -1]]\\n        grid, ans = [[\\'\\' for I in range(n)] for _ in range(m)], 0\\n        for guard in guards:\\n            grid[guard[0]][guard[1]] = \\'G\\'\\n        for wall in walls:\\n            grid[wall[0]][wall[1]] = \\'W\\'\\n            \\n        def dfs(m: int, n: int, x: int, y: int, grid: List[List[int]], idx: int) -> None:\\n            if x >= m or y >= n or x < 0 or y < 0 or grid[x][y] == \\'G\\' or grid[x][y] == \\'W\\':\\n                return\\n            \\n            grid[x][y] = \\'V\\'\\n            dfs(m, n, x + directions[idx][0], y + directions[idx][1], grid, idx)\\n            \\n        for guard in guards:\\n            grid[guard[0]][guard[1]] = \\'V\\'\\n            for idx in range(4):\\n                dfs(m, n, guard[0], guard[1], grid, idx)\\n            grid[guard[0]][guard[1]] = \\'G\\'\\n        for row in grid:\\n            ans += row.count(\\'\\')\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2490195,
                "title": "one-direction-dfs-with-quick-termination",
                "content": "Can cut off some portion of work if you stop unidirectional DFS search when you reach another guard. (they\\'ll take care of the rest themselves). \\n\\n```\\nclass Solution {\\npublic:\\n    vector<pair<int,int>> dirs = {{-1,0}, {1, 0}, {0,-1}, {0, 1}};\\n    \\n    int countUnguarded(int m, int n, vector<vector<int>>& guards, vector<vector<int>>& walls) {\\n        vector<vector<char>> map (m, vector<char>(n, \\' \\'));\\n        for(auto& v: guards) map[v[0]][v[1]] = \\'G\\';\\n        for(auto& v: walls) map[v[0]][v[1]] = \\'W\\';\\n        for(auto& v: guards){\\n            map[v[0]][v[1]] = \\'X\\';\\n            for(int i = 0; i < 4; i++) dfs(m, n, v[0], v[1], map, i);\\n            map[v[0]][v[1]] = \\'G\\';\\n        }\\n        int cnt = 0;\\n        for(auto& v: map) cnt += count( v.begin(), v.end(), \\' \\');\\n        return cnt;\\n    }\\n    \\n    void dfs(int m, int n, int x, int y, vector<vector<char>>& map, int ind){\\n        if(x >= m || y >=n || x < 0 || y < 0 || map[x][y] == \\'G\\' || map[x][y] == \\'W\\') return;\\n        map[x][y] = \\'X\\';\\n        dfs(m, n, x + dirs[ind].first, y +  dirs[ind].second, map, ind);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<pair<int,int>> dirs = {{-1,0}, {1, 0}, {0,-1}, {0, 1}};\\n    \\n    int countUnguarded(int m, int n, vector<vector<int>>& guards, vector<vector<int>>& walls) {\\n        vector<vector<char>> map (m, vector<char>(n, \\' \\'));\\n        for(auto& v: guards) map[v[0]][v[1]] = \\'G\\';\\n        for(auto& v: walls) map[v[0]][v[1]] = \\'W\\';\\n        for(auto& v: guards){\\n            map[v[0]][v[1]] = \\'X\\';\\n            for(int i = 0; i < 4; i++) dfs(m, n, v[0], v[1], map, i);\\n            map[v[0]][v[1]] = \\'G\\';\\n        }\\n        int cnt = 0;\\n        for(auto& v: map) cnt += count( v.begin(), v.end(), \\' \\');\\n        return cnt;\\n    }\\n    \\n    void dfs(int m, int n, int x, int y, vector<vector<char>>& map, int ind){\\n        if(x >= m || y >=n || x < 0 || y < 0 || map[x][y] == \\'G\\' || map[x][y] == \\'W\\') return;\\n        map[x][y] = \\'X\\';\\n        dfs(m, n, x + dirs[ind].first, y +  dirs[ind].second, map, ind);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2455357,
                "title": "c-fast-and-straight-forward-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int countUnguarded(int m, int n, vector<vector<int>>& guards, vector<vector<int>>& walls) {\\n        vector<vector<int>> mp(m, vector<int>(n));   //Create a array of m*n with defau;t zero value..\\n        for(int i=0;i<guards.size();i++)\\n            mp[guards[i][0]][guards[i][1]]=1;\\n        for(int i=0;i<walls.size();i++)\\n            mp[walls[i][0]][walls[i][1]]=2;\\n        //For each guard in all four direction move until we reach end or end upseeing a wall updating them as no go field(-1).\\n         for(auto x: guards)\\n         {\\n             bool l=true,r=true,d=true,u=true;\\n            for(int i=1;i<max(m,n) && (l || u || d || r);i++)  // checking of all bool value is important as it reduces the visits by a huge number\\n            {\\n                if(l && x[0]-i>=0 && mp[x[0]-i][x[1]]!=2 && mp[x[0]-i][x[1]]!=1)\\n                    mp[x[0]-i][x[1]]=-1;\\n                else\\n                    l=false;             \\n                if(r && x[0]+i<m && mp[x[0]+i][x[1]]!=2 && mp[x[0]+i][x[1]]!=1)\\n                    mp[x[0]+i][x[1]]=-1;\\n                else\\n                    r=false;                \\n                if(u && x[1]-i>=0 && mp[x[0]][x[1]-i]!=2  && mp[x[0]][x[1]-i]!=1)\\n                    mp[x[0]][x[1]-i]=-1;\\n                else\\n                    u=false;\\n                if(d && x[1]+i<n && mp[x[0]][x[1]+i]!=2 && mp[x[0]][x[1]+i]!=1)\\n                    mp[x[0]][x[1]+i]=-1;\\n                else\\n                    d=false;\\n            }\\n         }        \\n        int ans=0;   // Once we mark all the guarded places we can now see how many unguarded positions are there.. \\n\\t\\t//conversly in above loop we can count the guarded and add them with number of  walls and guards and subract with m*N to get answers\\n        for(int i=0;i<m;i++)\\n            for(int j=0;j<n;j++)\\n                if(mp[i][j]==0)\\n                    ans++;\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int countUnguarded(int m, int n, vector<vector<int>>& guards, vector<vector<int>>& walls) {\\n        vector<vector<int>> mp(m, vector<int>(n));   //Create a array of m*n with defau;t zero value..\\n        for(int i=0;i<guards.size();i++)\\n            mp[guards[i][0]][guards[i][1]]=1;\\n        for(int i=0;i<walls.size();i++)\\n            mp[walls[i][0]][walls[i][1]]=2;\\n        //For each guard in all four direction move until we reach end or end upseeing a wall updating them as no go field(-1).\\n         for(auto x: guards)\\n         {\\n             bool l=true,r=true,d=true,u=true;\\n            for(int i=1;i<max(m,n) && (l || u || d || r);i++)  // checking of all bool value is important as it reduces the visits by a huge number\\n            {\\n                if(l && x[0]-i>=0 && mp[x[0]-i][x[1]]!=2 && mp[x[0]-i][x[1]]!=1)\\n                    mp[x[0]-i][x[1]]=-1;\\n                else\\n                    l=false;             \\n                if(r && x[0]+i<m && mp[x[0]+i][x[1]]!=2 && mp[x[0]+i][x[1]]!=1)\\n                    mp[x[0]+i][x[1]]=-1;\\n                else\\n                    r=false;                \\n                if(u && x[1]-i>=0 && mp[x[0]][x[1]-i]!=2  && mp[x[0]][x[1]-i]!=1)\\n                    mp[x[0]][x[1]-i]=-1;\\n                else\\n                    u=false;\\n                if(d && x[1]+i<n && mp[x[0]][x[1]+i]!=2 && mp[x[0]][x[1]+i]!=1)\\n                    mp[x[0]][x[1]+i]=-1;\\n                else\\n                    d=false;\\n            }\\n         }        \\n        int ans=0;   // Once we mark all the guarded places we can now see how many unguarded positions are there.. \\n\\t\\t//conversly in above loop we can count the guarded and add them with number of  walls and guards and subract with m*N to get answers\\n        for(int i=0;i<m;i++)\\n            for(int j=0;j<n;j++)\\n                if(mp[i][j]==0)\\n                    ans++;\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2445142,
                "title": "c-easy-tracing-in-4-directions-and-taking-the-bitwise-and-of-all-commented",
                "content": "#define ll long long\\nclass Solution {\\npublic:\\n    int countUnguarded(int m, int n, vector<vector<int>>& guards, vector<vector<int>>& walls) {\\n        ll count=0;\\n        vector<vector<int>>grid(m,vector<int>(n,0));\\n        //guard=>-2\\n        //wall=>2\\n        //greens=>1\\n        //reds=>0\\n        for(auto v:guards)\\n        {\\n            grid[v[0]][v[1]]=-2;\\n        }\\n        for(auto v:walls)\\n        {\\n            grid[v[0]][v[1]]=2;\\n        }\\n        //traversing row wise\\n        for(int i=0;i<m;i++)\\n        {\\n            //traversing as the guard looks only to his right\\n            bool lastIsWall=true;\\n            for(int j=0;j<n;j++)\\n            {\\n                if(grid[i][j]==-2)\\n                {\\n                    lastIsWall=false;\\n                }\\n                else if(grid[i][j]==2)\\n                {\\n                    lastIsWall=true;\\n                }\\n                else if(lastIsWall)\\n                    grid[i][j]=1;\\n                else\\n                    grid[i][j]=0;\\n            }\\n            \\n            //traversing as the guard is looking towards his left and we do (left & right)\\n            //green and red ==>red\\n            //(only) green and green==>green \\n            \\n            lastIsWall=true;\\n            for(int j=n-1;j>=0;j--)\\n            {\\n                if(grid[i][j]==-2)\\n                {\\n                    lastIsWall=false;\\n                }\\n                else if(grid[i][j]==2)\\n                {\\n                    lastIsWall=true;\\n                }\\n                else if(lastIsWall)\\n                    grid[i][j]=grid[i][j] & 1;\\n                else\\n                    grid[i][j]=0;\\n            }           \\n            \\n        }\\n        //traversing column wise\\n        for(int j=0;j<n;j++)\\n        {\\n            //traversing as if the guard can only see up and taking the and\\n            bool lastIsWall=true;\\n            for(int i=0;i<m;i++)\\n            {\\n                if(grid[i][j]==-2)\\n                {\\n                    lastIsWall=false;\\n                }\\n                else if(grid[i][j]==2)\\n                {\\n                    lastIsWall=true;\\n                }\\n                else if(lastIsWall)\\n                    grid[i][j]=grid[i][j] & 1;\\n                else\\n                    grid[i][j]=0;\\n            }\\n            \\n            //traversing as if the guard is looking down and keeping the answer as and of all\\n            lastIsWall=true;\\n            for(int i=m-1;i>=0;i--)\\n            {\\n                if(grid[i][j]==-2)\\n                {\\n                    lastIsWall=false;\\n                }\\n                else if(grid[i][j]==2)\\n                {\\n                    lastIsWall=true;\\n                }\\n                else if(lastIsWall)\\n                    grid[i][j]=grid[i][j] & 1;\\n                else\\n                    grid[i][j]=0;\\n            }           \\n            \\n        }\\n        //now we count the greens i.e. 1\\'s\\n        for(int i=0;i<m;i++)\\n        {\\n            for(int j=0;j<n;j++)\\n            {\\n                // cout<<grid[i][j]<<\" \";\\n                if(grid[i][j]==1)\\n                    count++;\\n            }\\n            // cout<<endl;\\n        }\\n        return count;\\n        \\n    }\\n};",
                "solutionTags": [
                    "Bit Manipulation"
                ],
                "code": "class Solution {\\npublic:\\n    int countUnguarded(int m, int n, vector<vector<int>>& guards, vector<vector<int>>& walls) {\\n        ll count=0;\\n        vector<vector<int>>grid(m,vector<int>(n,0));\\n        //guard=>-2\\n        //wall=>2\\n        //greens=>1\\n        //reds=>0\\n        for(auto v:guards)\\n        {\\n            grid[v[0]][v[1]]=-2;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2429833,
                "title": "faster-than-87",
                "content": "```\\nclass Solution:\\n    def countUnguarded(self, m: int, n: int, guards: List[List[int]], walls: List[List[int]]) -> int:\\n        self.grid = [[0]*n for item in range(m)]\\n        for item in guards:\\n            self.grid[item[0]][item[1]]=\\'G\\'\\n        for item in walls:\\n            self.grid[item[0]][item[1]]=\\'W\\'\\n        for item in guards:\\n            i, j = item\\n            # print(\\'Called from this\\',i,j)\\n            self.down_break(i+1,j)\\n            self.up_break(i-1,j)\\n            self.left_break(i,j-1)\\n            self.right_break(i,j+1)\\n                    # print(self.grid)\\n        count=0\\n        for i in range(m):\\n            for j in range(n):\\n                if self.grid[i][j]==0:\\n                    count+=1\\n        return count\\n                    \\n                 \\n    def up_break(self,r,k):\\n        if r<0 or r>=len(self.grid) or k>=len(self.grid[0]) or k<0 or self.grid[r][k] in [\\'G\\', \\'W\\']:\\n            return\\n        # print(\\'Called up\\', r,k)\\n        self.grid[r][k]=\\'X\\'\\n        self.up_break(r-1,k)\\n    \\n    \\n    def down_break(self,r,k):\\n        if r<0 or r>=len(self.grid) or k>=len(self.grid[0]) or k<0 or self.grid[r][k] in [\\'G\\', \\'W\\']:\\n            return\\n        # print(\\'Called, down\\', r,k)\\n        self.grid[r][k]= \\'X\\'\\n        self.down_break(r+1, k)\\n        \\n    \\n    def left_break(self,r,k):\\n        if r<0 or r>=len(self.grid) or k>=len(self.grid[0]) or k<0 or self.grid[r][k] in [\\'G\\', \\'W\\']:\\n            return\\n        # print(\\'Called left\\', r, k)\\n        self.grid[r][k]= \\'X\\'\\n        self.left_break(r, k-1)\\n        \\n        \\n    def right_break(self,r,k):\\n        if r<0 or r>=len(self.grid) or k>=len(self.grid[0]) or k<0 or self.grid[r][k] in [\\'G\\', \\'W\\']:\\n            return\\n        # print(\\'Called right\\', r,k)\\n        self.grid[r][k]= \\'X\\'\\n        self.right_break(r, k+1)\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def countUnguarded(self, m: int, n: int, guards: List[List[int]], walls: List[List[int]]) -> int:\\n        self.grid = [[0]*n for item in range(m)]\\n        for item in guards:\\n            self.grid[item[0]][item[1]]=\\'G\\'\\n        for item in walls:\\n            self.grid[item[0]][item[1]]=\\'W\\'\\n        for item in guards:\\n            i, j = item\\n            # print(\\'Called from this\\',i,j)\\n            self.down_break(i+1,j)\\n            self.up_break(i-1,j)\\n            self.left_break(i,j-1)\\n            self.right_break(i,j+1)\\n                    # print(self.grid)\\n        count=0\\n        for i in range(m):\\n            for j in range(n):\\n                if self.grid[i][j]==0:\\n                    count+=1\\n        return count\\n                    \\n                 \\n    def up_break(self,r,k):\\n        if r<0 or r>=len(self.grid) or k>=len(self.grid[0]) or k<0 or self.grid[r][k] in [\\'G\\', \\'W\\']:\\n            return\\n        # print(\\'Called up\\', r,k)\\n        self.grid[r][k]=\\'X\\'\\n        self.up_break(r-1,k)\\n    \\n    \\n    def down_break(self,r,k):\\n        if r<0 or r>=len(self.grid) or k>=len(self.grid[0]) or k<0 or self.grid[r][k] in [\\'G\\', \\'W\\']:\\n            return\\n        # print(\\'Called, down\\', r,k)\\n        self.grid[r][k]= \\'X\\'\\n        self.down_break(r+1, k)\\n        \\n    \\n    def left_break(self,r,k):\\n        if r<0 or r>=len(self.grid) or k>=len(self.grid[0]) or k<0 or self.grid[r][k] in [\\'G\\', \\'W\\']:\\n            return\\n        # print(\\'Called left\\', r, k)\\n        self.grid[r][k]= \\'X\\'\\n        self.left_break(r, k-1)\\n        \\n        \\n    def right_break(self,r,k):\\n        if r<0 or r>=len(self.grid) or k>=len(self.grid[0]) or k<0 or self.grid[r][k] in [\\'G\\', \\'W\\']:\\n            return\\n        # print(\\'Called right\\', r,k)\\n        self.grid[r][k]= \\'X\\'\\n        self.right_break(r, k+1)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2429808,
                "title": "time-limit-exceeded",
                "content": "```class Solution:\\n    def countUnguarded(self, m: int, n: int, guards: List[List[int]], walls: List[List[int]]) -> int:\\n        grid = [[1 for _ in range(n)] for _ in range(m)]\\n\\n        for i,j in walls:\\n            grid[i][j] = -1 #walls no passable\\n            \\n        directions = [(0, 1), (1, 0), (-1, 0), (0, -1)]\\n        \\n        def guardingCells(r,c):\\n            #left\\n            grid[r][c] = 0\\n            for dx, dy in directions:\\n                curr_x = r\\n                curr_y = c\\n                \\n                while 0 <= curr_x+dx < m and 0 <= curr_y+dy < n and grid[curr_x+dx][curr_y+dy] != -1:\\n                    curr_x += dx\\n                    curr_y += dy\\n                    grid[curr_x][curr_y] = 0\\n\\n        for i,j in guards:\\n            guardingCells(i,j)\\n\\n        return sum(1 for i in range(m) for j in range(n) if grid[i][j] == 1)\\n\\t\\t```\\n\\t\\t\\n\\t\\tNot sure why this is TLE",
                "solutionTags": [
                    "Python"
                ],
                "code": "```class Solution:\\n    def countUnguarded(self, m: int, n: int, guards: List[List[int]], walls: List[List[int]]) -> int:\\n        grid = [[1 for _ in range(n)] for _ in range(m)]\\n\\n        for i,j in walls:\\n            grid[i][j] = -1 #walls no passable\\n            \\n        directions = [(0, 1), (1, 0), (-1, 0), (0, -1)]\\n        \\n        def guardingCells(r,c):\\n            #left\\n            grid[r][c] = 0\\n            for dx, dy in directions:\\n                curr_x = r\\n                curr_y = c\\n                \\n                while 0 <= curr_x+dx < m and 0 <= curr_y+dy < n and grid[curr_x+dx][curr_y+dy] != -1:\\n                    curr_x += dx\\n                    curr_y += dy\\n                    grid[curr_x][curr_y] = 0\\n\\n        for i,j in guards:\\n            guardingCells(i,j)\\n\\n        return sum(1 for i in range(m) for j in range(n) if grid[i][j] == 1)\\n\\t\\t```",
                "codeTag": "Java"
            },
            {
                "id": 2397430,
                "title": "rust-solution",
                "content": "This grid size is enough small to use brute force.\\n```\\nfn helper(memo: &mut Vec<Vec<i32>>, flag: &mut bool, r:usize, c:usize) {\\n    match memo[r][c] {\\n        1 => {\\n            if *flag {\\n                memo[r][c] = 0;\\n            }\\n        },\\n        10 => {\\n            *flag = true;\\n        },\\n        20 => {\\n            *flag = false;\\n        }\\n        _ => {}\\n    }\\n} \\n\\nimpl Solution {\\n    pub fn count_unguarded(m: i32, n: i32, guards: Vec<Vec<i32>>, walls: Vec<Vec<i32>>) -> i32 {\\n        let m = m as usize;\\n        let n = n as usize;\\n        let mut memo = vec![vec![1;n];m];\\n\\n        for arr in guards {\\n            memo[arr[0] as usize][arr[1] as usize] = 10;\\n        }\\n        for arr in walls {\\n            memo[arr[0] as usize][arr[1] as usize] = 20;\\n        }\\n\\n        for i in 0..m {\\n            let mut flag = false;\\n            for j in 0..n {\\n                helper(&mut memo, &mut flag, i, j);\\n            } \\n            let mut flag = false;\\n            for j in (0..n).rev() {\\n                helper(&mut memo, &mut flag, i, j);\\n            }\\n        }\\n\\n        for i in 0..n {\\n            let mut flag = false;\\n            for j in 0..m {\\n                helper(&mut memo, &mut flag, j, i);\\n            } \\n            let mut flag = false;\\n            for j in (0..m).rev() {\\n                helper(&mut memo, &mut flag, j, i);\\n            }\\n        }\\n\\n        let mut result = 0;\\n        for i in 0..m {\\n            for j in 0..n {\\n                if memo[i][j] == 1 {\\n                    result += 1;\\n                }\\n            }\\n        }\\n\\n        result\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nfn helper(memo: &mut Vec<Vec<i32>>, flag: &mut bool, r:usize, c:usize) {\\n    match memo[r][c] {\\n        1 => {\\n            if *flag {\\n                memo[r][c] = 0;\\n            }\\n        },\\n        10 => {\\n            *flag = true;\\n        },\\n        20 => {\\n            *flag = false;\\n        }\\n        _ => {}\\n    }\\n} \\n\\nimpl Solution {\\n    pub fn count_unguarded(m: i32, n: i32, guards: Vec<Vec<i32>>, walls: Vec<Vec<i32>>) -> i32 {\\n        let m = m as usize;\\n        let n = n as usize;\\n        let mut memo = vec![vec![1;n];m];\\n\\n        for arr in guards {\\n            memo[arr[0] as usize][arr[1] as usize] = 10;\\n        }\\n        for arr in walls {\\n            memo[arr[0] as usize][arr[1] as usize] = 20;\\n        }\\n\\n        for i in 0..m {\\n            let mut flag = false;\\n            for j in 0..n {\\n                helper(&mut memo, &mut flag, i, j);\\n            } \\n            let mut flag = false;\\n            for j in (0..n).rev() {\\n                helper(&mut memo, &mut flag, i, j);\\n            }\\n        }\\n\\n        for i in 0..n {\\n            let mut flag = false;\\n            for j in 0..m {\\n                helper(&mut memo, &mut flag, j, i);\\n            } \\n            let mut flag = false;\\n            for j in (0..m).rev() {\\n                helper(&mut memo, &mut flag, j, i);\\n            }\\n        }\\n\\n        let mut result = 0;\\n        for i in 0..m {\\n            for j in 0..n {\\n                if memo[i][j] == 1 {\\n                    result += 1;\\n                }\\n            }\\n        }\\n\\n        result\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2372238,
                "title": "c-simple-c-code-o-n-m-82-time",
                "content": "# **If you like the implementation then Please help me by increasing my reputation. By clicking the up arrow on the left of my image.**\\n```\\nclass Solution {\\npublic:\\n    int countUnguarded(int m, int n, vector<vector<int>>& guards, vector<vector<int>>& walls) {\\n        vector<vector<int>> visited(m+1, vector<int> (n+1, 0));\\n        int ans = 0;\\n        for(vector<int> &vec : walls){\\n            visited[vec[0]][vec[1]] = -1;\\n            ans++;\\n        }\\n        int dirx[4] = {-1,1,0,0};\\n        int diry[4] = {0,0,1,-1};\\n        queue<pair<pair<int, int>, int>> q;\\n        for(vector<int> &vec : guards)\\n        {\\n            visited[vec[0]][vec[1]] = 2;\\n            q.push({{vec[0], vec[1]},4});\\n        }\\n        while(!q.empty())\\n        {\\n            pair<pair<int, int>, int> tp = q.front();\\n            q.pop();\\n            int x = tp.first.first;\\n            int y = tp.first.second;\\n            int dir = tp.second;\\n            if(visited[x][y] != -2)\\n                ans++;\\n            if(dir == 4)\\n            {\\n                for(int i = 0; i < 4; i++)\\n                {\\n                    int nxtx = x + dirx[i];\\n                    int nxty = y + diry[i];\\n                    if(nxtx >= m || nxtx < 0 || nxty >= n || nxty < 0) continue;\\n                    if(visited[nxtx][nxty] == -1 || visited[nxtx][nxty] == 2) continue;\\n                    q.push({{nxtx, nxty}, i});\\n                }\\n            }\\n            else\\n            {\\n                visited[x][y] = -2;\\n                int nxtx = x + dirx[dir];\\n                int nxty = y + diry[dir];\\n                if(nxtx >= m || nxtx < 0 || nxty >= n || nxty < 0) continue;\\n                if(visited[nxtx][nxty] == -1 || visited[nxtx][nxty] == 2) continue;\\n                q.push({{nxtx, nxty}, dir});\\n            }\\n        }\\n        return (long long)(m*n) - ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int countUnguarded(int m, int n, vector<vector<int>>& guards, vector<vector<int>>& walls) {\\n        vector<vector<int>> visited(m+1, vector<int> (n+1, 0));\\n        int ans = 0;\\n        for(vector<int> &vec : walls){\\n            visited[vec[0]][vec[1]] = -1;\\n            ans++;\\n        }\\n        int dirx[4] = {-1,1,0,0};\\n        int diry[4] = {0,0,1,-1};\\n        queue<pair<pair<int, int>, int>> q;\\n        for(vector<int> &vec : guards)\\n        {\\n            visited[vec[0]][vec[1]] = 2;\\n            q.push({{vec[0], vec[1]},4});\\n        }\\n        while(!q.empty())\\n        {\\n            pair<pair<int, int>, int> tp = q.front();\\n            q.pop();\\n            int x = tp.first.first;\\n            int y = tp.first.second;\\n            int dir = tp.second;\\n            if(visited[x][y] != -2)\\n                ans++;\\n            if(dir == 4)\\n            {\\n                for(int i = 0; i < 4; i++)\\n                {\\n                    int nxtx = x + dirx[i];\\n                    int nxty = y + diry[i];\\n                    if(nxtx >= m || nxtx < 0 || nxty >= n || nxty < 0) continue;\\n                    if(visited[nxtx][nxty] == -1 || visited[nxtx][nxty] == 2) continue;\\n                    q.push({{nxtx, nxty}, i});\\n                }\\n            }\\n            else\\n            {\\n                visited[x][y] = -2;\\n                int nxtx = x + dirx[dir];\\n                int nxty = y + diry[dir];\\n                if(nxtx >= m || nxtx < 0 || nxty >= n || nxty < 0) continue;\\n                if(visited[nxtx][nxty] == -1 || visited[nxtx][nxty] == 2) continue;\\n                q.push({{nxtx, nxty}, dir});\\n            }\\n        }\\n        return (long long)(m*n) - ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2356533,
                "title": "java-easy-count-differently",
                "content": "```\\nclass Solution {\\n    private final char GUARD = \\'G\\';\\n    private final char RANGE = \\'R\\';\\n    private final char WALL = \\'W\\';\\n    private final int[][] dirs = {{0, 1}, {1, 0}, {-1, 0}, {0, -1}};\\n    \\n    public int countUnguarded(int m, int n, int[][] guards, int[][] walls) {\\n        final char[][] mat = new char[m][n];\\n        for (final int[] wall : walls) {\\n            mat[wall[0]][wall[1]] = WALL;\\n        }\\n        \\n        for (final int[] guard : guards) {\\n            mat[guard[0]][guard[1]] = GUARD;\\n        }\\n        \\n        int count = (m*n) - guards.length - walls.length;\\n        \\n        for (final int[] guard : guards) {\\n            for (final int[] dir : dirs) {\\n                int x = dir[0] + guard[0], y = dir[1] + guard[1];\\n                while (isValid(mat, x, y)) {\\n                    if (mat[x][y] == 0) count--;\\n                    mat[x][y] = RANGE;\\n                    x += dir[0];\\n                    y += dir[1]; \\n                }\\n            }\\n        }\\n        \\n        return count;\\n    }\\n    \\n    private boolean isValid(final char[][] mat, final int i, final int j) {\\n        return i >=0 && j >=0 && i < mat.length && j < mat[0].length && (mat[i][j] == 0 || mat[i][j] == RANGE);\\n    }\\n}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    private final char GUARD = \\'G\\';\\n    private final char RANGE = \\'R\\';\\n    private final char WALL = \\'W\\';\\n    private final int[][] dirs = {{0, 1}",
                "codeTag": "Java"
            },
            {
                "id": 2338442,
                "title": "tle-why",
                "content": "class Solution(object):\\n    def countUnguarded(self, m, n, guards, walls):\\n        \"\"\"\\n        :type m: int\\n        :type n: int\\n        :type guards: List[List[int]]\\n        :type walls: List[List[int]]\\n        :rtype: int\\n        \"\"\"\\n         #nseen  = [ [ 1  for j in range(n)] for i in range(m)]\\n        \\n        grid = [ [ 0  for j in range(n)] for i in range(m)]\\n        \\n        for x in guards :\\n            \\n            grid[x[0]][x[1]] = 1\\n            \\n        for x in walls :\\n            \\n            grid[x[0]][x[1]] = -1\\n            \\n            \\n            \\n        for i , j in guards :\\n                    \\n                    \\n                    \\n                    for k in range( j , n) :\\n                        if grid[i][k] == -1 or (grid[i][k] == 1 and [i, k]!=[i, j])  :\\n                            break\\n                       \\n                        grid[i][k] = 2                           \\n                            \\n                            \\n                    for k in range(j,-1, -1) :\\n                        if grid[i][k] == -1 or (grid[i][k] == 1 and [i, k]!=[i, j] ):\\n                            break\\n                        \\n                        grid[i][k] = 2\\n                            \\n                        \\n                    for k in range( i, m ):\\n                        \\n                        if grid[k][j] == -1  or (grid[k][j] == 1 and [k, j] != [i,j]):\\n                            break\\n                 \\n                        grid[k][j] = 2\\n          \\n                        \\n                    for k in range( i, -1 ,-1) :\\n                        if grid[k][j] == -1 or (grid[k][j] == 1 and [k, j] != [i,j]):\\n                            break\\n                        \\n                            \\n                        grid[k][j] = 2\\n                            \\n            \\n                    \\n                \\n                \\n        count = 0\\n        for i in range(m) :\\n            for j in range(n) :\\n                if grid[i][j] == 0 :\\n                    count += 1\\n            \\n            \\n            \\n                  \\n      \\n        return( count)",
                "solutionTags": [],
                "code": "class Solution(object):\\n    def countUnguarded(self, m, n, guards, walls):\\n        \"\"\"\\n        :type m: int\\n        :type n: int\\n        :type guards: List[List[int]]\\n        :type walls: List[List[int]]\\n        :rtype: int\\n        \"\"\"\\n         #nseen  = [ [ 1  for j in range(n)] for i in range(m)]\\n        \\n        grid = [ [ 0  for j in range(n)] for i in range(m)]\\n        \\n        for x in guards :\\n            \\n            grid[x[0]][x[1]] = 1\\n            \\n        for x in walls :\\n            \\n            grid[x[0]][x[1]] = -1\\n            \\n            \\n            \\n        for i , j in guards :\\n                    \\n                    \\n                    \\n                    for k in range( j , n) :\\n                        if grid[i][k] == -1 or (grid[i][k] == 1 and [i, k]!=[i, j])  :\\n                            break\\n                       \\n                        grid[i][k] = 2                           \\n                            \\n                            \\n                    for k in range(j,-1, -1) :\\n                        if grid[i][k] == -1 or (grid[i][k] == 1 and [i, k]!=[i, j] ):\\n                            break\\n                        \\n                        grid[i][k] = 2\\n                            \\n                        \\n                    for k in range( i, m ):\\n                        \\n                        if grid[k][j] == -1  or (grid[k][j] == 1 and [k, j] != [i,j]):\\n                            break\\n                 \\n                        grid[k][j] = 2\\n          \\n                        \\n                    for k in range( i, -1 ,-1) :\\n                        if grid[k][j] == -1 or (grid[k][j] == 1 and [k, j] != [i,j]):\\n                            break\\n                        \\n                            \\n                        grid[k][j] = 2\\n                            \\n            \\n                    \\n                \\n                \\n        count = 0\\n        for i in range(m) :\\n            for j in range(n) :\\n                if grid[i][j] == 0 :\\n                    count += 1\\n            \\n            \\n            \\n                  \\n      \\n        return( count)",
                "codeTag": "Java"
            },
            {
                "id": 2336625,
                "title": "c-easy-solution",
                "content": "pls  upvote  if  it\\'s helpful \\n```\\n int countUnguarded(int m, int n, vector<vector<int>>& g, vector<vector<int>>& w)\\n    {\\n       vector<vector<int>>vi(m,vector<int>(n,0))  ;\\n        for(int i=0;i<g.size();i++)\\n        {\\n            int x=g[i][0] ;\\n            int y=g[i][1] ;\\n            vi[x][y]=1 ;\\n        }\\n        for(int i=0;i<w.size();i++)\\n        {\\n            int x=w[i][0] ;\\n            int y=w[i][1] ;\\n            vi[x][y]=-1 ;\\n        }\\n        for(int i=0;i<m;i++)\\n            for(int j=0;j<n;j++)\\n                if(vi[i][j]==1)\\n                {  \\n                    check(vi,i,j);\\n                    vi[i][j]=-1 ;\\n                }\\n            \\n        \\n        int res=0 ;\\n        for(int i=0;i<m;i++)\\n            for(int j=0;j<n;j++)\\n                if(vi[i][j]==0)\\n                res++ ;\\n            \\n        \\n        return res ;\\n    }\\n    void check(vector<vector<int>>&vi,int i,int j)\\n    {\\n        for(int p=i-1;p>=0;p--)\\n        {\\n            if(vi[p][j]==1 || vi[p][j]==-1)\\n            break ;\\n            \\n             vi[p][j]=10 ;\\n        }\\n        \\n        for(int p=j+1;p<vi[0].size();p++)\\n        {\\n            if(vi[i][p]==1 || vi[i][p]==-1)\\n                break ;\\n            vi[i][p]=10 ;\\n        }\\n        \\n        for(int p=i+1;p<vi.size();p++)\\n        {\\n            if(vi[p][j]==1 || vi[p][j]==-1)\\n                break ;\\n            \\n           vi[p][j]=10 ;\\n        }\\n       \\n        for(int p=j-1 ;p>=0;p--)\\n        {\\n            if(vi[i][p]==1 || vi[i][p]==-1)\\n                break ;\\n            vi[i][p]=10 ;\\n        }\\n        \\n    }\\n```",
                "solutionTags": [
                    "C",
                    "Matrix"
                ],
                "code": "```\\n int countUnguarded(int m, int n, vector<vector<int>>& g, vector<vector<int>>& w)\\n    {\\n       vector<vector<int>>vi(m,vector<int>(n,0))  ;\\n        for(int i=0;i<g.size();i++)\\n        {\\n            int x=g[i][0] ;\\n            int y=g[i][1] ;\\n            vi[x][y]=1 ;\\n        }\\n        for(int i=0;i<w.size();i++)\\n        {\\n            int x=w[i][0] ;\\n            int y=w[i][1] ;\\n            vi[x][y]=-1 ;\\n        }\\n        for(int i=0;i<m;i++)\\n            for(int j=0;j<n;j++)\\n                if(vi[i][j]==1)\\n                {  \\n                    check(vi,i,j);\\n                    vi[i][j]=-1 ;\\n                }\\n            \\n        \\n        int res=0 ;\\n        for(int i=0;i<m;i++)\\n            for(int j=0;j<n;j++)\\n                if(vi[i][j]==0)\\n                res++ ;\\n            \\n        \\n        return res ;\\n    }\\n    void check(vector<vector<int>>&vi,int i,int j)\\n    {\\n        for(int p=i-1;p>=0;p--)\\n        {\\n            if(vi[p][j]==1 || vi[p][j]==-1)\\n            break ;\\n            \\n             vi[p][j]=10 ;\\n        }\\n        \\n        for(int p=j+1;p<vi[0].size();p++)\\n        {\\n            if(vi[i][p]==1 || vi[i][p]==-1)\\n                break ;\\n            vi[i][p]=10 ;\\n        }\\n        \\n        for(int p=i+1;p<vi.size();p++)\\n        {\\n            if(vi[p][j]==1 || vi[p][j]==-1)\\n                break ;\\n            \\n           vi[p][j]=10 ;\\n        }\\n       \\n        for(int p=j-1 ;p>=0;p--)\\n        {\\n            if(vi[i][p]==1 || vi[i][p]==-1)\\n                break ;\\n            vi[i][p]=10 ;\\n        }\\n        \\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2307488,
                "title": "faster-easy-to-understand-c-code",
                "content": "* ***Brute Force***\\n\\n* ***Time Complexity :- O(N * M * N)***\\n\\n* ***Space Complexity :- O(N * M)***\\n\\n```\\nclass Solution {\\npublic:\\n    \\n    int countUnguarded(int n, int m, vector<vector<int>>& guards, vector<vector<int>>& walls) {\\n        \\n        // initialize all the cells unvisited with \\'u\\'\\n        \\n        vector<vector<char>> grid(n, vector<char> (m, \\'u\\'));\\n        \\n        // mark the cell which contain wall with \\'w\\'\\n        \\n        for(int i = 0; i < walls.size(); i++)\\n        {\\n            grid[walls[i][0]][walls[i][1]] = \\'w\\';\\n        }\\n        \\n        // mark the cell which contain guard with \\'g\\'\\n        \\n        for(auto v : guards)\\n        {\\n            grid[v[0]][v[1]] = \\'g\\';\\n        }\\n        \\n        // iterate over guards matrix and mark the possible cell visited with \\'v\\'\\n        \\n        for(auto v : guards)\\n        {\\n            // row no. of guard cell\\n            \\n            int row = v[0];\\n            \\n            // col no. of guard cell\\n            \\n            int col = v[1];\\n            \\n            // mark visited in up side \\n            \\n            int i = row - 1;\\n            \\n            int j = col;\\n           \\n            while(i >= 0 && grid[i][j] != \\'w\\' && grid[i][j] != \\'g\\')\\n            {\\n                grid[i][j] = \\'v\\';\\n                \\n                i--;\\n            }\\n            \\n            // mark visited in bottom side\\n            \\n            i = row + 1;\\n            \\n            j = col;\\n            \\n            while(i < n && grid[i][j] != \\'w\\' && grid[i][j] != \\'g\\')\\n            {\\n                grid[i][j] = \\'v\\';\\n                \\n                i++;\\n            }\\n            \\n            // mark visited in left side\\n            \\n            i = row;\\n            \\n            j = col - 1;\\n            \\n            while(j >= 0 && grid[i][j] != \\'w\\' && grid[i][j] != \\'g\\')\\n            {\\n                grid[i][j] = \\'v\\';\\n                \\n                j--;\\n            }\\n            \\n            // mark visited in right side\\n            \\n            i = row;\\n            \\n            j = col + 1;\\n            \\n            while(j < m && grid[i][j] != \\'w\\' && grid[i][j] != \\'g\\')\\n            {\\n                grid[i][j] = \\'v\\';\\n                \\n                j++;\\n            }\\n        }\\n        \\n        // count all the unvisited cell\\n        \\n        int count = 0;\\n        \\n        for(int i = 0; i < n; i++)\\n        {\\n            for(int j = 0; j < m; j++)\\n            {\\n                if(grid[i][j] == \\'u\\')\\n                    count++;\\n            }\\n        }\\n        \\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    int countUnguarded(int n, int m, vector<vector<int>>& guards, vector<vector<int>>& walls) {\\n        \\n        // initialize all the cells unvisited with \\'u\\'\\n        \\n        vector<vector<char>> grid(n, vector<char> (m, \\'u\\'));\\n        \\n        // mark the cell which contain wall with \\'w\\'\\n        \\n        for(int i = 0; i < walls.size(); i++)\\n        {\\n            grid[walls[i][0]][walls[i][1]] = \\'w\\';\\n        }\\n        \\n        // mark the cell which contain guard with \\'g\\'\\n        \\n        for(auto v : guards)\\n        {\\n            grid[v[0]][v[1]] = \\'g\\';\\n        }\\n        \\n        // iterate over guards matrix and mark the possible cell visited with \\'v\\'\\n        \\n        for(auto v : guards)\\n        {\\n            // row no. of guard cell\\n            \\n            int row = v[0];\\n            \\n            // col no. of guard cell\\n            \\n            int col = v[1];\\n            \\n            // mark visited in up side \\n            \\n            int i = row - 1;\\n            \\n            int j = col;\\n           \\n            while(i >= 0 && grid[i][j] != \\'w\\' && grid[i][j] != \\'g\\')\\n            {\\n                grid[i][j] = \\'v\\';\\n                \\n                i--;\\n            }\\n            \\n            // mark visited in bottom side\\n            \\n            i = row + 1;\\n            \\n            j = col;\\n            \\n            while(i < n && grid[i][j] != \\'w\\' && grid[i][j] != \\'g\\')\\n            {\\n                grid[i][j] = \\'v\\';\\n                \\n                i++;\\n            }\\n            \\n            // mark visited in left side\\n            \\n            i = row;\\n            \\n            j = col - 1;\\n            \\n            while(j >= 0 && grid[i][j] != \\'w\\' && grid[i][j] != \\'g\\')\\n            {\\n                grid[i][j] = \\'v\\';\\n                \\n                j--;\\n            }\\n            \\n            // mark visited in right side\\n            \\n            i = row;\\n            \\n            j = col + 1;\\n            \\n            while(j < m && grid[i][j] != \\'w\\' && grid[i][j] != \\'g\\')\\n            {\\n                grid[i][j] = \\'v\\';\\n                \\n                j++;\\n            }\\n        }\\n        \\n        // count all the unvisited cell\\n        \\n        int count = 0;\\n        \\n        for(int i = 0; i < n; i++)\\n        {\\n            for(int j = 0; j < m; j++)\\n            {\\n                if(grid[i][j] == \\'u\\')\\n                    count++;\\n            }\\n        }\\n        \\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2298098,
                "title": "best-and-easy-way-to-do-this",
                "content": "\\tclass Solution:\\n    def countUnguarded(self, m: int, n: int, guards: List[List[int]], walls: List[List[int]]) -> int:\\n        dp=[[-1 for x in range(n)] for y in range(m)] \\n        print(dp)\\n        for x,y in guards:\\n            print(x,y)\\n            dp[x][y]=1\\n        for x,y in walls:\\n            dp[x][y]=2\\n\\n        for i in range(m):\\n            for j in range(n):\\n                if dp[i][j]==1:\\n                    print(i,j)\\n                    r=j+1\\n                    while r<n and dp[i][r]!=2 and dp[i][r]!=1:\\n                        dp[i][r]=0\\n                        r+=1\\n                    l=j-1\\n                    while dp[i][l]!=2 and l>=0 and dp[i][l]!=1:\\n                        dp[i][l]=0\\n                        l-=1\\n                    up=i-1\\n                    while up>=0 and dp[up][j]!=2 and dp[up][j]!=1:\\n                        dp[up][j]=0\\n                        up-=1\\n                    dw=i+1\\n                    while dw<m and dp[dw][j]!=2 and dp[dw][j]!=1:\\n                        dp[dw][j]=0\\n                        dw+=1\\n        ans=0\\n        for i in range(len(dp)):\\n            ans+=dp[i].count(-1)\\n        \\n        return ans\\n",
                "solutionTags": [],
                "code": "\\tclass Solution:\\n    def countUnguarded(self, m: int, n: int, guards: List[List[int]], walls: List[List[int]]) -> int:\\n        dp=[[-1 for x in range(n)] for y in range(m)] \\n        print(dp)\\n        for x,y in guards:\\n            print(x,y)\\n            dp[x][y]=1\\n        for x,y in walls:\\n            dp[x][y]=2\\n\\n        for i in range(m):\\n            for j in range(n):\\n                if dp[i][j]==1:\\n                    print(i,j)\\n                    r=j+1\\n                    while r<n and dp[i][r]!=2 and dp[i][r]!=1:\\n                        dp[i][r]=0\\n                        r+=1\\n                    l=j-1\\n                    while dp[i][l]!=2 and l>=0 and dp[i][l]!=1:\\n                        dp[i][l]=0\\n                        l-=1\\n                    up=i-1\\n                    while up>=0 and dp[up][j]!=2 and dp[up][j]!=1:\\n                        dp[up][j]=0\\n                        up-=1\\n                    dw=i+1\\n                    while dw<m and dp[dw][j]!=2 and dp[dw][j]!=1:\\n                        dp[dw][j]=0\\n                        dw+=1\\n        ans=0\\n        for i in range(len(dp)):\\n            ans+=dp[i].count(-1)\\n        \\n        return ans\\n",
                "codeTag": "Java"
            },
            {
                "id": 2274016,
                "title": "python-straight-forawrd-dfs",
                "content": "```\\nclass Solution:\\n    def countUnguarded(self, m: int, n: int, guards: List[List[int]], walls: List[List[int]]) -> int:\\n        grid = [ [0]*n for _ in range(m) ]\\n        \\n        for w_i, w_j in walls:\\n            grid[w_i][w_j] = 1\\n        \\n        for g_i, g_j in guards:\\n            grid[g_i][g_j] = 1\\n\\n        directions = [0, 1, 0, -1, 0]\\n        for g_i, g_j in guards:\\n            self.dfs(g_i, g_j, m, n, grid, directions)\\n            \\n        safe_count = 0\\n        for i in range(m):\\n            for j in range(n):\\n                if grid[i][j] == 0:\\n                    safe_count += 1\\n                    \\n        return safe_count\\n    \\n    def dfs(self, g_i, g_j, m, n, grid, directions):\\n        for dir_index in range(1, 5):\\n            direction = (directions[dir_index], directions[dir_index - 1])\\n            self.goToGivenDirection(g_i, g_j, m, n, direction, grid)\\n        \\n    def goToGivenDirection(self, cur_i, cur_j, m, n, direction, grid):\\n        cur_i += direction[0]\\n        cur_j += direction[1]\\n        while self.inside(cur_i, cur_j, m, n) and (grid[cur_i][cur_j] != 1):\\n            grid[cur_i][cur_j] = -1\\n            cur_i += direction[0]\\n            cur_j += direction[1]\\n        \\n    def inside(self, i, j, m, n):\\n        if i < 0 or i >= m or j < 0 or j >= n:\\n            return False\\n        return True\\n```",
                "solutionTags": [
                    "Python",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution:\\n    def countUnguarded(self, m: int, n: int, guards: List[List[int]], walls: List[List[int]]) -> int:\\n        grid = [ [0]*n for _ in range(m) ]\\n        \\n        for w_i, w_j in walls:\\n            grid[w_i][w_j] = 1\\n        \\n        for g_i, g_j in guards:\\n            grid[g_i][g_j] = 1\\n\\n        directions = [0, 1, 0, -1, 0]\\n        for g_i, g_j in guards:\\n            self.dfs(g_i, g_j, m, n, grid, directions)\\n            \\n        safe_count = 0\\n        for i in range(m):\\n            for j in range(n):\\n                if grid[i][j] == 0:\\n                    safe_count += 1\\n                    \\n        return safe_count\\n    \\n    def dfs(self, g_i, g_j, m, n, grid, directions):\\n        for dir_index in range(1, 5):\\n            direction = (directions[dir_index], directions[dir_index - 1])\\n            self.goToGivenDirection(g_i, g_j, m, n, direction, grid)\\n        \\n    def goToGivenDirection(self, cur_i, cur_j, m, n, direction, grid):\\n        cur_i += direction[0]\\n        cur_j += direction[1]\\n        while self.inside(cur_i, cur_j, m, n) and (grid[cur_i][cur_j] != 1):\\n            grid[cur_i][cur_j] = -1\\n            cur_i += direction[0]\\n            cur_j += direction[1]\\n        \\n    def inside(self, i, j, m, n):\\n        if i < 0 or i >= m or j < 0 or j >= n:\\n            return False\\n        return True\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2272978,
                "title": "no-idea-why-this-is-tle",
                "content": "```\\nclass Solution {\\n    \\n    enum state {\\n        GUARDED,\\n        WALL,\\n        NONE\\n    };\\n    \\n    vector<vector<state>> grid_;\\n    int rows_;\\n    int cols_;\\n    \\n    void guard(int x, int y) {\\n        int cur_x = x;\\n        // grid_[x][y] = GUARDED;\\n        while (cur_x >= 0) {\\n            if (grid_[cur_x][y] == WALL)\\n                break;\\n            \\n            grid_[cur_x][y] = GUARDED;\\n            --cur_x;\\n        }\\n        \\n        cur_x = x;\\n        while (cur_x < rows_) {\\n            if (grid_[cur_x][y] == WALL)\\n                break;\\n            \\n            grid_[cur_x][y] = GUARDED;\\n            ++cur_x;\\n        }\\n        \\n        int cur_y = y;\\n        while (cur_y >= 0) {\\n            if (grid_[x][cur_y] == WALL)\\n                break;\\n            grid_[x][cur_y] = GUARDED;\\n            --cur_y;\\n        }\\n        \\n        cur_y = y;\\n        while (cur_y < cols_) {\\n            if (grid_[x][cur_y] == WALL)\\n                break;\\n            grid_[x][cur_y] = GUARDED;\\n            ++cur_y;\\n        }\\n    }\\n    \\npublic:\\n    int countUnguarded(int m, int n, vector<vector<int>>& guards, vector<vector<int>>& walls) {\\n        grid_.assign(m, vector<state>(n, NONE));\\n        rows_ = m;\\n        cols_ = n;\\n        \\n        for (auto& w : walls) {\\n            auto x = w[0];\\n            auto y = w[1];\\n            grid_[x][y] = WALL;\\n        }\\n        \\n        for (auto& g : guards) {\\n            guard(g[0], g[1]);\\n        }\\n        \\n        int res = 0;\\n        for (int i = 0; i < m; ++i) {\\n            for (int j = 0; j < n; ++j) {\\n                if (grid_[i][j] == NONE)\\n                    ++res;\\n            }\\n        }\\n        \\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\n    \\n    enum state {\\n        GUARDED,\\n        WALL,\\n        NONE\\n    };\\n    \\n    vector<vector<state>> grid_;\\n    int rows_;\\n    int cols_;\\n    \\n    void guard(int x, int y) {\\n        int cur_x = x;\\n        // grid_[x][y] = GUARDED;\\n        while (cur_x >= 0) {\\n            if (grid_[cur_x][y] == WALL)\\n                break;\\n            \\n            grid_[cur_x][y] = GUARDED;\\n            --cur_x;\\n        }\\n        \\n        cur_x = x;\\n        while (cur_x < rows_) {\\n            if (grid_[cur_x][y] == WALL)\\n                break;\\n            \\n            grid_[cur_x][y] = GUARDED;\\n            ++cur_x;\\n        }\\n        \\n        int cur_y = y;\\n        while (cur_y >= 0) {\\n            if (grid_[x][cur_y] == WALL)\\n                break;\\n            grid_[x][cur_y] = GUARDED;\\n            --cur_y;\\n        }\\n        \\n        cur_y = y;\\n        while (cur_y < cols_) {\\n            if (grid_[x][cur_y] == WALL)\\n                break;\\n            grid_[x][cur_y] = GUARDED;\\n            ++cur_y;\\n        }\\n    }\\n    \\npublic:\\n    int countUnguarded(int m, int n, vector<vector<int>>& guards, vector<vector<int>>& walls) {\\n        grid_.assign(m, vector<state>(n, NONE));\\n        rows_ = m;\\n        cols_ = n;\\n        \\n        for (auto& w : walls) {\\n            auto x = w[0];\\n            auto y = w[1];\\n            grid_[x][y] = WALL;\\n        }\\n        \\n        for (auto& g : guards) {\\n            guard(g[0], g[1]);\\n        }\\n        \\n        int res = 0;\\n        for (int i = 0; i < m; ++i) {\\n            for (int j = 0; j < n; ++j) {\\n                if (grid_[i][j] == NONE)\\n                    ++res;\\n            }\\n        }\\n        \\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2246001,
                "title": "python-simple-solution-o-m-n",
                "content": "```python\\ndef countUnguarded(self, m: int, n: int, guards: List[List[int]], walls: List[List[int]]) -> int:\\n        grid = [[\" \"] * n for _ in range(m)]\\n        for x,y in guards:\\n            grid[x][y] = \\'g\\'\\n        for x,y in walls:\\n            grid[x][y]= \\'w\\'\\n        a = [0] * n\\n        b = [0] * n \\n        res = 0 \\n        for i in range(m):\\n            l = r = 0\\n            for j in range(n):\\n                while r < n-1 and (r < j or grid[i][r] == \" \"):\\n                    r += 1\\n                while (b[j] < i or grid[b[j]][j] == \" \") and b[j] < m-1:\\n                    b[j] += 1\\n                if grid[i][j] != \" \":\\n                    l, a[j] = j, i\\n                else:\\n                    res += \\'g\\' not in grid[i][l] + grid[i][r] + grid[a[j]][j] + grid[b[j]][j]\\n        return res \\n                       \\n\\t```",
                "solutionTags": [],
                "code": "```python\\ndef countUnguarded(self, m: int, n: int, guards: List[List[int]], walls: List[List[int]]) -> int:\\n        grid = [[\" \"] * n for _ in range(m)]\\n        for x,y in guards:\\n            grid[x][y] = \\'g\\'\\n        for x,y in walls:\\n            grid[x][y]= \\'w\\'\\n        a = [0] * n\\n        b = [0] * n \\n        res = 0 \\n        for i in range(m):\\n            l = r = 0\\n            for j in range(n):\\n                while r < n-1 and (r < j or grid[i][r] == \" \"):\\n                    r += 1\\n                while (b[j] < i or grid[b[j]][j] == \" \") and b[j] < m-1:\\n                    b[j] += 1\\n                if grid[i][j] != \" \":\\n                    l, a[j] = j, i\\n                else:\\n                    res += \\'g\\' not in grid[i][l] + grid[i][r] + grid[a[j]][j] + grid[b[j]][j]\\n        return res \\n                       \\n\\t```",
                "codeTag": "Python3"
            },
            {
                "id": 2237919,
                "title": "python-simple-solution",
                "content": "```python\\n# Each number in the grid will represent an object from \\n# the problem statement\\n# \\n# 0  -> Unguarded Cells\\n# 1  -> Guarded Cells\\n# 2  -> Guards\\n# 3 -> Walls\\n\\n(UNGUARDED, GUARDED, GUARD, WALL) = (0, 1, 2, 3)\\n\\nclass Solution:\\n    def countUnguarded(self, m: int, n: int, guards: List[List[int]], walls: List[List[int]]) -> int:\\n        grid = [[0 for _ in range(0, n)] for _ in range(0, m)]\\n        \\n        cnt = ( m * n) - len(walls) - len(guards)\\n        \\n        for (row, col) in walls:\\n            grid[row][col] = WALL\\n            \\n        for (row, col) in guards:\\n            grid[row][col] = GUARD\\n        \\n        dirs = [(1, 0), (-1, 0), (0, 1), (0, -1)]\\n        \\n        for (row, col) in guards:\\n            \\n            for dx, dy in dirs:\\n                x = row + dx\\n                y = col + dy\\n                \\n                while ( \\n                    x>=0 and \\n                    x <m and \\n                    y >= 0 and \\n                    y< n and \\n                    grid[x][y] != WALL and \\n                    grid[x][y] != GUARD\\n                ):\\n                    if grid[x][y] == UNGUARDED:\\n                        cnt-=1\\n                    grid[x][y] = GUARDED\\n                    x = x + dx\\n                    y = y + dy\\n\\n        return cnt  \\n            \\n        \\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```python\\n# Each number in the grid will represent an object from \\n# the problem statement\\n# \\n# 0  -> Unguarded Cells\\n# 1  -> Guarded Cells\\n# 2  -> Guards\\n# 3 -> Walls\\n\\n(UNGUARDED, GUARDED, GUARD, WALL) = (0, 1, 2, 3)\\n\\nclass Solution:\\n    def countUnguarded(self, m: int, n: int, guards: List[List[int]], walls: List[List[int]]) -> int:\\n        grid = [[0 for _ in range(0, n)] for _ in range(0, m)]\\n        \\n        cnt = ( m * n) - len(walls) - len(guards)\\n        \\n        for (row, col) in walls:\\n            grid[row][col] = WALL\\n            \\n        for (row, col) in guards:\\n            grid[row][col] = GUARD\\n        \\n        dirs = [(1, 0), (-1, 0), (0, 1), (0, -1)]\\n        \\n        for (row, col) in guards:\\n            \\n            for dx, dy in dirs:\\n                x = row + dx\\n                y = col + dy\\n                \\n                while ( \\n                    x>=0 and \\n                    x <m and \\n                    y >= 0 and \\n                    y< n and \\n                    grid[x][y] != WALL and \\n                    grid[x][y] != GUARD\\n                ):\\n                    if grid[x][y] == UNGUARDED:\\n                        cnt-=1\\n                    grid[x][y] = GUARDED\\n                    x = x + dx\\n                    y = y + dy\\n\\n        return cnt  \\n            \\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2214812,
                "title": "java-simple-dfs",
                "content": "```\\nclass Solution \\n{\\n    //0----->unvisited  //1---->visited  //2----->guard  //3----->wall\\n    int d[][]={{-1,0},{1,0},{0,1},{0,-1}};\\n    \\n    public int countUnguarded(int m, int n, int[][] g, int[][] w) \\n    {\\n        int ans=0; int visited[][]=new int[m][n];\\n        \\n        for(int i=0;i<w.length;i++)\\n        {\\n            int x=w[i][0];  int y=w[i][1]; visited[x][y]=3;\\n        }\\n        \\n        for(int i=0;i<g.length;i++)\\n        {\\n            int x=g[i][0];  int y=g[i][1];  visited[x][y]=2;\\n        }\\n        \\n        for(int i=0;i<g.length;i++)\\n        {\\n            int x=g[i][0];  int y=g[i][1];\\n            \\n            for(int j=0;j<4;j++)\\n            dfs(visited,x+d[j][0],y+d[j][1],d[j][0],d[j][1]);\\n        }\\n        \\n        for(int i=0;i<m;i++)\\n        {\\n            for(int j=0;j<n;j++)\\n            {\\n                if(visited[i][j]==0)\\n                ans++;\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n    \\n    public void dfs(int visited[][],int i,int j,int x,int y)\\n    {\\n        if(i<0 || j<0 || i>=visited.length || j>=visited[0].length)\\n        return;\\n        \\n        if(visited[i][j]==3 || visited[i][j]==2)\\n        return;\\n        \\n        visited[i][j]=1;\\n        dfs(visited,i+x,j+y,x,y);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```\\nclass Solution \\n{\\n    //0----->unvisited  //1---->visited  //2----->guard  //3----->wall\\n    int d[][]={{-1,0},{1,0},{0,1},{0,-1}};\\n    \\n    public int countUnguarded(int m, int n, int[][] g, int[][] w) \\n    {\\n        int ans=0; int visited[][]=new int[m][n];\\n        \\n        for(int i=0;i<w.length;i++)\\n        {\\n            int x=w[i][0];  int y=w[i][1]; visited[x][y]=3;\\n        }\\n        \\n        for(int i=0;i<g.length;i++)\\n        {\\n            int x=g[i][0];  int y=g[i][1];  visited[x][y]=2;\\n        }\\n        \\n        for(int i=0;i<g.length;i++)\\n        {\\n            int x=g[i][0];  int y=g[i][1];\\n            \\n            for(int j=0;j<4;j++)\\n            dfs(visited,x+d[j][0],y+d[j][1],d[j][0],d[j][1]);\\n        }\\n        \\n        for(int i=0;i<m;i++)\\n        {\\n            for(int j=0;j<n;j++)\\n            {\\n                if(visited[i][j]==0)\\n                ans++;\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n    \\n    public void dfs(int visited[][],int i,int j,int x,int y)\\n    {\\n        if(i<0 || j<0 || i>=visited.length || j>=visited[0].length)\\n        return;\\n        \\n        if(visited[i][j]==3 || visited[i][j]==2)\\n        return;\\n        \\n        visited[i][j]=1;\\n        dfs(visited,i+x,j+y,x,y);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2181744,
                "title": "javascript-state-transition",
                "content": "```\\n/**\\n * @param {number} m\\n * @param {number} n\\n * @param {number[][]} guards\\n * @param {number[][]} walls\\n * @return {number}\\n */\\nvar countUnguarded = function(m, n, guards, walls) {\\n    const table = new Array(m)\\n    for (const i of table.keys())\\n        table[i] = new Array(n).fill(0)\\n    \\n    for (const [i, j] of guards.values()) {\\n        table[i][j] = 1\\n    }\\n    \\n    for (const [i, j] of walls.values()) {\\n        table[i][j] = 2\\n    }\\n    \\n    \\n    for (let i = 0; i < m; i++) {\\n        let isGuarding = false\\n        for (let j = 0; j < n; j++) {\\n            const val = table[i][j]\\n            if (val === 0) {\\n                if (isGuarding) {\\n                    table[i][j] = 3\\n                }\\n            } else if (val === 1) {\\n                isGuarding = true\\n            } else if (val === 2) {\\n                isGuarding = false\\n            }\\n        }\\n    }\\n    \\n    for (let i = 0; i < m; i++) {\\n        let isGuarding = false\\n        for (let j = n - 1; j >= 0; j--) {\\n            const val = table[i][j]\\n            if (val === 0) {\\n                if (isGuarding) {\\n                    table[i][j] = 3\\n                }\\n            } else if (val === 1) {\\n                isGuarding = true\\n            } else if (val === 2) {\\n                isGuarding = false\\n            }\\n        }\\n    }\\n    \\n    for (let j = 0; j < n; j++) {\\n        let isGuarding = false\\n        for (let i = 0; i < m; i++) {\\n            const val = table[i][j]\\n            if (val === 0) {\\n                if (isGuarding) {\\n                    table[i][j] = 3\\n                }\\n            } else if (val === 1) {\\n                isGuarding = true\\n            } else if (val === 2) {\\n                isGuarding = false\\n            }\\n        }\\n    }\\n    \\n    for (let j = 0; j < n; j++) {\\n        let isGuarding = false\\n        for (let i = m - 1; i >= 0; i--) {\\n            const val = table[i][j]\\n            if (val === 0) {\\n                if (isGuarding) {\\n                    table[i][j] = 3\\n                }\\n            } else if (val === 1) {\\n                isGuarding = true\\n            } else if (val === 2) {\\n                isGuarding = false\\n            }\\n        }\\n    }\\n    \\n    \\n    let result = 0\\n    for (const row of table.values())\\n        for (const val of row.values())\\n            if (val === 0)  result++\\n    \\n    \\n    return result\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n/**\\n * @param {number} m\\n * @param {number} n\\n * @param {number[][]} guards\\n * @param {number[][]} walls\\n * @return {number}\\n */\\nvar countUnguarded = function(m, n, guards, walls) {\\n    const table = new Array(m)\\n    for (const i of table.keys())\\n        table[i] = new Array(n).fill(0)\\n    \\n    for (const [i, j] of guards.values()) {\\n        table[i][j] = 1\\n    }\\n    \\n    for (const [i, j] of walls.values()) {\\n        table[i][j] = 2\\n    }\\n    \\n    \\n    for (let i = 0; i < m; i++) {\\n        let isGuarding = false\\n        for (let j = 0; j < n; j++) {\\n            const val = table[i][j]\\n            if (val === 0) {\\n                if (isGuarding) {\\n                    table[i][j] = 3\\n                }\\n            } else if (val === 1) {\\n                isGuarding = true\\n            } else if (val === 2) {\\n                isGuarding = false\\n            }\\n        }\\n    }\\n    \\n    for (let i = 0; i < m; i++) {\\n        let isGuarding = false\\n        for (let j = n - 1; j >= 0; j--) {\\n            const val = table[i][j]\\n            if (val === 0) {\\n                if (isGuarding) {\\n                    table[i][j] = 3\\n                }\\n            } else if (val === 1) {\\n                isGuarding = true\\n            } else if (val === 2) {\\n                isGuarding = false\\n            }\\n        }\\n    }\\n    \\n    for (let j = 0; j < n; j++) {\\n        let isGuarding = false\\n        for (let i = 0; i < m; i++) {\\n            const val = table[i][j]\\n            if (val === 0) {\\n                if (isGuarding) {\\n                    table[i][j] = 3\\n                }\\n            } else if (val === 1) {\\n                isGuarding = true\\n            } else if (val === 2) {\\n                isGuarding = false\\n            }\\n        }\\n    }\\n    \\n    for (let j = 0; j < n; j++) {\\n        let isGuarding = false\\n        for (let i = m - 1; i >= 0; i--) {\\n            const val = table[i][j]\\n            if (val === 0) {\\n                if (isGuarding) {\\n                    table[i][j] = 3\\n                }\\n            } else if (val === 1) {\\n                isGuarding = true\\n            } else if (val === 2) {\\n                isGuarding = false\\n            }\\n        }\\n    }\\n    \\n    \\n    let result = 0\\n    for (const row of table.values())\\n        for (const val of row.values())\\n            if (val === 0)  result++\\n    \\n    \\n    return result\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2177296,
                "title": "c-simulation",
                "content": "```\\nclass Solution {\\npublic:\\n    int countUnguarded(int m, int n, vector<vector<int>>& guards, vector<vector<int>>& walls) \\n    {\\n        vector<vector<int>>matrix(m, vector<int>(n));        \\n        for (auto guard: guards)\\n            matrix[guard[0]][guard[1]] = 2;\\n        for (auto wall: walls)\\n            matrix[wall[0]][wall[1]] = 2;\\n        \\n        vector<pair<int,int>>dir({{1,0},{-1,0},{0,1},{0,-1}});\\n        for (auto guard: guards)                   \\n            for (auto [dx, dy]: dir)\\n            {                \\n                int i = guard[0], j = guard[1];\\n                while (1)\\n                {\\n                    i+=dx;\\n                    j+=dy;\\n                    if (i<0||i>=m || j<0||j>=n) break;\\n                    if (matrix[i][j]==2) break;\\n                    matrix[i][j] = 1;\\n                }\\n            }\\n        \\n        int ret = 0;\\n        for (int i=0; i<m; i++)\\n            for (int j=0; j<n; j++)\\n                if (matrix[i][j]==0)\\n                    ret++;\\n        \\n        return ret;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int countUnguarded(int m, int n, vector<vector<int>>& guards, vector<vector<int>>& walls) \\n    {\\n        vector<vector<int>>matrix(m, vector<int>(n));        \\n        for (auto guard: guards)\\n            matrix[guard[0]][guard[1]] = 2;\\n        for (auto wall: walls)\\n            matrix[wall[0]][wall[1]] = 2;\\n        \\n        vector<pair<int,int>>dir({{1,0},{-1,0},{0,1},{0,-1}});\\n        for (auto guard: guards)                   \\n            for (auto [dx, dy]: dir)\\n            {                \\n                int i = guard[0], j = guard[1];\\n                while (1)\\n                {\\n                    i+=dx;\\n                    j+=dy;\\n                    if (i<0||i>=m || j<0||j>=n) break;\\n                    if (matrix[i][j]==2) break;\\n                    matrix[i][j] = 1;\\n                }\\n            }\\n        \\n        int ret = 0;\\n        for (int i=0; i<m; i++)\\n            for (int j=0; j<n; j++)\\n                if (matrix[i][j]==0)\\n                    ret++;\\n        \\n        return ret;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2158940,
                "title": "c-matrix-brute-force",
                "content": "```\\nclass Solution {\\npublic:\\n    //1->no guard\\n    //0->guard can protect\\n    //3->intial guard\\n    //4->intial wall\\n    int countUnguarded(int m, int n, vector<vector<int>>& g, vector<vector<int>>& w) {\\n       vector<vector<int>>a(m,vector<int>(n,-1)) ;\\n        for(int i=0;i<g.size();i++)\\n            a[g[i][0]][g[i][1]]=3;\\n        for(int i=0;i<w.size();i++)\\n            a[w[i][0]][w[i][1]]=4;\\n        for(int i=0;i<m;i++)\\n        {   int pr=4;\\n            for(int j=0;j<n;j++)\\n            {\\n                if(a[i][j]==-1&&pr==4)\\n                {\\n                    a[i][j]=1;\\n                }\\n                else if(a[i][j]==-1&&pr==3)\\n                {\\n                    a[i][j]=0;\\n                }\\n                else\\n                    pr=a[i][j];\\n            }\\n        }\\n         for(int i=0;i<m;i++)\\n        {   int pr=4;\\n            for(int j=n-1;j>=0;j--)\\n            {\\n                if(a[i][j]==1&&pr==3)\\n                {\\n                    a[i][j]=0;\\n                }\\n                else if(a[i][j]==3||a[i][j]==4)\\n                    pr=a[i][j];\\n            }\\n        }\\n          for(int i=0;i<n;i++)\\n        {   int pr=4;\\n            for(int j=0;j<m;j++)\\n            {\\n                if(a[j][i]==1&&pr==3)\\n                {\\n                    a[j][i]=0;\\n                }\\n                else if(a[j][i]==3||a[j][i]==4)\\n                    pr=a[j][i];\\n            }\\n        }\\n          for(int i=0;i<n;i++)\\n        {   int pr=4;\\n            for(int j=m-1;j>=0;j--)\\n            {\\n                if(a[j][i]==1&&pr==3)\\n                {\\n                    a[j][i]=0;\\n                }\\n                else if(a[j][i]==3||a[j][i]==4)\\n                    pr=a[j][i];\\n            }\\n        }\\n        int ans=0;\\n        for(int i=0;i<m;i++)\\n        {\\n            for(int j=0;j<n;j++)\\n            {\\n                if(a[i][j]==1)\\n                    ans++;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Matrix"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    //1->no guard\\n    //0->guard can protect\\n    //3->intial guard\\n    //4->intial wall\\n    int countUnguarded(int m, int n, vector<vector<int>>& g, vector<vector<int>>& w) {\\n       vector<vector<int>>a(m,vector<int>(n,-1)) ;\\n        for(int i=0;i<g.size();i++)\\n            a[g[i][0]][g[i][1]]=3;\\n        for(int i=0;i<w.size();i++)\\n            a[w[i][0]][w[i][1]]=4;\\n        for(int i=0;i<m;i++)\\n        {   int pr=4;\\n            for(int j=0;j<n;j++)\\n            {\\n                if(a[i][j]==-1&&pr==4)\\n                {\\n                    a[i][j]=1;\\n                }\\n                else if(a[i][j]==-1&&pr==3)\\n                {\\n                    a[i][j]=0;\\n                }\\n                else\\n                    pr=a[i][j];\\n            }\\n        }\\n         for(int i=0;i<m;i++)\\n        {   int pr=4;\\n            for(int j=n-1;j>=0;j--)\\n            {\\n                if(a[i][j]==1&&pr==3)\\n                {\\n                    a[i][j]=0;\\n                }\\n                else if(a[i][j]==3||a[i][j]==4)\\n                    pr=a[i][j];\\n            }\\n        }\\n          for(int i=0;i<n;i++)\\n        {   int pr=4;\\n            for(int j=0;j<m;j++)\\n            {\\n                if(a[j][i]==1&&pr==3)\\n                {\\n                    a[j][i]=0;\\n                }\\n                else if(a[j][i]==3||a[j][i]==4)\\n                    pr=a[j][i];\\n            }\\n        }\\n          for(int i=0;i<n;i++)\\n        {   int pr=4;\\n            for(int j=m-1;j>=0;j--)\\n            {\\n                if(a[j][i]==1&&pr==3)\\n                {\\n                    a[j][i]=0;\\n                }\\n                else if(a[j][i]==3||a[j][i]==4)\\n                    pr=a[j][i];\\n            }\\n        }\\n        int ans=0;\\n        for(int i=0;i<m;i++)\\n        {\\n            for(int j=0;j<n;j++)\\n            {\\n                if(a[i][j]==1)\\n                    ans++;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2152858,
                "title": "simple-clear-java-simulation-solution",
                "content": "```\\nclass Solution {\\n    public int countUnguarded(int m, int n, int[][] guards, int[][] walls) {\\n        int[][] map = new int[m][n];\\n        for (int[] g: guards) {\\n            map[g[0]][g[1]] = 2; // means guard\\n        }\\n        \\n        for (int[] w: walls) {\\n            map[w[0]][w[1]] = 3; // means wall\\n        }      \\n        \\n        for (int i = 0; i < m; i++) {\\n            for (int j = 0; j < n; j++) {\\n                if (map[i][j] == 2) { // search guard\\n                    dfs(map, i, j, m, n);\\n                }\\n            }\\n        }        \\n        \\n        int cnt = 0;\\n        for (int i = 0; i < m; i++) {\\n            for (int j = 0; j < n; j++) {\\n                if (map[i][j] == 0) // count unprotected\\n                    cnt++;\\n            }\\n        }\\n        return cnt;\\n    }\\n    \\n    void dfs(int[][] map, int x, int y, int m, int n) {\\n        for (int i = x-1; i >= 0; i--) {  // search up\\n            if (map[i][y] == 2 || map[i][y] == 3) {\\n                break;\\n            }\\n            map[i][y] = 1; // change to protected\\n        }\\n        for (int i = x+1; i < m; i++) { // search down\\n            if (map[i][y] == 2 || map[i][y] == 3) {\\n                break;\\n            }\\n            map[i][y] = 1; // change to protected\\n        }\\n        for (int j = y-1; j >= 0; j--) { // search left\\n            if (map[x][j] == 2 || map[x][j] == 3) {\\n                break;\\n            }\\n            map[x][j] = 1; // change to protected\\n        }\\n        for (int j = y+1; j < n; j++) { // search right\\n            if (map[x][j] == 2 || map[x][j] == 3) {\\n                break;\\n            }\\n            map[x][j] = 1; // change to protected\\n        }       \\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Depth-First Search",
                    "Simulation"
                ],
                "code": "```\\nclass Solution {\\n    public int countUnguarded(int m, int n, int[][] guards, int[][] walls) {\\n        int[][] map = new int[m][n];\\n        for (int[] g: guards) {\\n            map[g[0]][g[1]] = 2; // means guard\\n        }\\n        \\n        for (int[] w: walls) {\\n            map[w[0]][w[1]] = 3; // means wall\\n        }      \\n        \\n        for (int i = 0; i < m; i++) {\\n            for (int j = 0; j < n; j++) {\\n                if (map[i][j] == 2) { // search guard\\n                    dfs(map, i, j, m, n);\\n                }\\n            }\\n        }        \\n        \\n        int cnt = 0;\\n        for (int i = 0; i < m; i++) {\\n            for (int j = 0; j < n; j++) {\\n                if (map[i][j] == 0) // count unprotected\\n                    cnt++;\\n            }\\n        }\\n        return cnt;\\n    }\\n    \\n    void dfs(int[][] map, int x, int y, int m, int n) {\\n        for (int i = x-1; i >= 0; i--) {  // search up\\n            if (map[i][y] == 2 || map[i][y] == 3) {\\n                break;\\n            }\\n            map[i][y] = 1; // change to protected\\n        }\\n        for (int i = x+1; i < m; i++) { // search down\\n            if (map[i][y] == 2 || map[i][y] == 3) {\\n                break;\\n            }\\n            map[i][y] = 1; // change to protected\\n        }\\n        for (int j = y-1; j >= 0; j--) { // search left\\n            if (map[x][j] == 2 || map[x][j] == 3) {\\n                break;\\n            }\\n            map[x][j] = 1; // change to protected\\n        }\\n        for (int j = y+1; j < n; j++) { // search right\\n            if (map[x][j] == 2 || map[x][j] == 3) {\\n                break;\\n            }\\n            map[x][j] = 1; // change to protected\\n        }       \\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1684099,
                "content": [
                    {
                        "username": "PhilipSmith",
                        "content": "This question should probably be marked medium."
                    },
                    {
                        "username": "jaiyadav",
                        "content": "[@kushalnagwanshicloud](/kushalnagwanshicloud) lol"
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "They marked it Medium !!"
                    }
                ]
            }
        ]
    },
    {
        "title": "Percentage of Letter in String",
        "question_content": "<p>Given a string <code>s</code> and a character <code>letter</code>, return<em> the <strong>percentage</strong> of characters in </em><code>s</code><em> that equal </em><code>letter</code><em> <strong>rounded down</strong> to the nearest whole percent.</em></p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> s = &quot;foobar&quot;, letter = &quot;o&quot;\n<strong>Output:</strong> 33\n<strong>Explanation:</strong>\nThe percentage of characters in s that equal the letter &#39;o&#39; is 2 / 6 * 100% = 33% when rounded down, so we return 33.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> s = &quot;jjjj&quot;, letter = &quot;k&quot;\n<strong>Output:</strong> 0\n<strong>Explanation:</strong>\nThe percentage of characters in s that equal the letter &#39;k&#39; is 0%, so we return 0.</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= s.length &lt;= 100</code></li>\n\t<li><code>s</code> consists of lowercase English letters.</li>\n\t<li><code>letter</code> is a lowercase English letter.</li>\n</ul>\n",
        "solutions": [
            {
                "id": 2061845,
                "title": "1-liner",
                "content": "**C++**\\n```cpp\\nint percentageLetter(string s, char letter) {\\n    return 100 * count(begin(s), end(s), letter) / s.size();\\n}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```cpp\\nint percentageLetter(string s, char letter) {\\n    return 100 * count(begin(s), end(s), letter) / s.size();\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2061912,
                "title": "straightforward",
                "content": "```\\nclass Solution {\\npublic:\\n    int percentageLetter(string s, char letter) {\\n        int count=0;\\n        for(int i=0;i<s.length();i++)\\n        {  if(s[i]==letter)\\n            {\\n                count++;\\n            }\\n        }\\n        return (count*100)/s.length();\\n        \\n    }\\n};\\n```\\n**Like it ? Please Upvote ;-)**",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int percentageLetter(string s, char letter) {\\n        int count=0;\\n        for(int i=0;i<s.length();i++)\\n        {  if(s[i]==letter)\\n            {\\n                count++;\\n            }\\n        }\\n        return (count*100)/s.length();\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2061802,
                "title": "c-easy-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int percentageLetter(string s, char letter) {\\n        int n=s.length();\\n        int count=0;\\n        for(char x: s){\\n            if(x==letter){\\n                count++;\\n            }\\n        }\\n        return count*100/n;\\n    }\\n};\\n```\\n**Don\\'t forget to upvote this post if it has helped you!!!**",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int percentageLetter(string s, char letter) {\\n        int n=s.length();\\n        int count=0;\\n        for(char x: s){\\n            if(x==letter){\\n                count++;\\n            }\\n        }\\n        return count*100/n;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2066611,
                "title": "java-clean-well-commented-explanation",
                "content": "**Approach:**\\n1. Traverse the given String \"s\", and increment the count each time the character is equal to the given \"letter\".\\n2. Find the percentage using standard percentage formula : (given*100)/total.\\n\\n***Kindly upvote if I was able to help you, this motivates me to do more for the community.***\\n\\n***Kindly look for the comments in the code below for explanation.***\\n**Time Complexity:** O(N)\\n**Space Complexity:** O(1)\\n```\\nclass Solution {\\n    public int percentageLetter(String s, char letter) {\\n        int count=0; //count acts as a counter variabe to count the give character \"letter\" in the string \\n        \\n        //Traverse the string s and each time the character int the string is equal to \"letter\"\\n        //increment the count variable by 1.\\n        for(char ch:s.toCharArray())\\n        {\\n            if(ch==letter)\\n                count++;\\n        }\\n        \\n    //If the count is zero, then the percentage is also zero\\n        if(count==0) \\n            return 0;\\n        \\n        \\n     // to find the total characters in the strings or we can say to find the length of the string   \\n        int total=s.length(); \\n    \\n    // Calculate the total percentage using the standard percentage formula i.e (given*100)/total\\n        int per=(count*100)/total;\\n        return per;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int percentageLetter(String s, char letter) {\\n        int count=0; //count acts as a counter variabe to count the give character \"letter\" in the string \\n        \\n        //Traverse the string s and each time the character int the string is equal to \"letter\"\\n        //increment the count variable by 1.\\n        for(char ch:s.toCharArray())\\n        {\\n            if(ch==letter)\\n                count++;\\n        }\\n        \\n    //If the count is zero, then the percentage is also zero\\n        if(count==0) \\n            return 0;\\n        \\n        \\n     // to find the total characters in the strings or we can say to find the length of the string   \\n        int total=s.length(); \\n    \\n    // Calculate the total percentage using the standard percentage formula i.e (given*100)/total\\n        int per=(count*100)/total;\\n        return per;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2061931,
                "title": "python-one-line-solution-simple-counting",
                "content": "```\\nclass Solution:\\n    def percentageLetter(self, s: str, letter: str) -> int:\\n        return (s.count(letter)*100)//len(s)\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def percentageLetter(self, s: str, letter: str) -> int:\\n        return (s.count(letter)*100)//len(s)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2065067,
                "title": "js-solution-fast-simple-understandable",
                "content": "**Runtime: 67 ms, faster than 85.98% of JavaScript online submissions for Percentage of Letter in String.\\nMemory Usage: 42.2 MB, less than 40.15% of JavaScript online submissions for Percentage of Letter in String.**\\n\\n```\\nvar percentageLetter = function(s, letter) {\\n    let count = 0;\\n    for (let i of s) { // count how many letters are in s\\n        if (i == letter) count++;\\n    }\\n    return (Math.floor((count*1.0) / (s.length*1.0) * 100)) // get percentage\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar percentageLetter = function(s, letter) {\\n    let count = 0;\\n    for (let i of s) { // count how many letters are in s\\n        if (i == letter) count++;\\n    }\\n    return (Math.floor((count*1.0) / (s.length*1.0) * 100)) // get percentage\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2063318,
                "title": "3-solutions-intuitive-recursive-1-liner-easy-to-understand-c",
                "content": "**Solution 1: Intuitive approach (Count variable by checking character in the string)**\\n```\\n    int percentageLetter(string s, char letter) {\\n        int count = 0;\\n        for(char ch : s)\\n            if(ch == letter)\\n                 count++;\\n        return count * 100 / s.size();\\n    }\\n```\\n\\n\\n**Solution 2: 1 liner (Using `count()` Function in C++)**\\n```\\n\\tint percentageLetter(string s, char letter) {\\n\\t\\treturn 100 * count(begin(s), end(s), letter) / s.size();\\n\\t}\\n```\\n\\n\\n**Solution 3: Using recursion to count character**\\n    \\n```\\n\\tint countinString(string s, char ch){\\n\\t\\tif (s.length() == 0)\\n\\t\\t      return 0;\\n\\t\\tint count = 0;\\n\\t\\tif (s[0] == ch)\\n\\t\\t\\t  count++;\\n\\t\\tcount += countinString(s.substr(1), ch);\\n\\t\\treturn count;\\n\\t}\\n\\n\\tint percentageLetter(string s, char letter) {\\n\\t\\treturn countinString(s, letter)*100/s.size();\\n\\t}\\n```\\n\\n**If you like it, Please Upvote!!!**",
                "solutionTags": [
                    "C",
                    "String",
                    "Recursion"
                ],
                "code": "```\\n    int percentageLetter(string s, char letter) {\\n        int count = 0;\\n        for(char ch : s)\\n            if(ch == letter)\\n                 count++;\\n        return count * 100 / s.size();\\n    }\\n```\n```\\n\\tint percentageLetter(string s, char letter) {\\n\\t\\treturn 100 * count(begin(s), end(s), letter) / s.size();\\n\\t}\\n```\n```\\n\\tint countinString(string s, char ch){\\n\\t\\tif (s.length() == 0)\\n\\t\\t      return 0;\\n\\t\\tint count = 0;\\n\\t\\tif (s[0] == ch)\\n\\t\\t\\t  count++;\\n\\t\\tcount += countinString(s.substr(1), ch);\\n\\t\\treturn count;\\n\\t}\\n\\n\\tint percentageLetter(string s, char letter) {\\n\\t\\treturn countinString(s, letter)*100/s.size();\\n\\t}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3003664,
                "title": "python-simple-one-liner-solution",
                "content": "# Code\\n```\\nclass Solution:\\n    def percentageLetter(self, s: str, letter: str) -> int:\\n        return int((s.count(letter) / len(s)) * 100)\\n```\\n\\nLike it ? Please upvote !",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def percentageLetter(self, s: str, letter: str) -> int:\\n        return int((s.count(letter) / len(s)) * 100)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3001148,
                "title": "java-0ms-100-faster-3-line-code",
                "content": "![percentage.PNG](https://assets.leetcode.com/users/images/642d90c2-bbbe-4cd6-a4f9-ceca41154d01_1672895995.7502918.png)\\n\\n# Code\\n```\\n**please upvote it , if you like it.**  \\n\\nclass Solution {\\n    public int percentageLetter(String s, char letter) {\\n        double count = 0;\\n        for (char i : s.toCharArray()) {\\n            if (i == letter) count++;\\n            else continue;\\n        }\\n        double result = (count / s.length()) * 100;\\n        return (int) result;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n**please upvote it , if you like it.**  \\n\\nclass Solution {\\n    public int percentageLetter(String s, char letter) {\\n        double count = 0;\\n        for (char i : s.toCharArray()) {\\n            if (i == letter) count++;\\n            else continue;\\n        }\\n        double result = (count / s.length()) * 100;\\n        return (int) result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2779886,
                "title": "percentage-of-letter-in-string-easy-solve",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nint percentageLetter(char *s, char letter){\\n    int x=strlen(s);\\n    int k=0;\\n    for(int i=0;i<x;i++)\\n     {\\n        if(s[i]==letter)\\n        {\\n            k++;\\n        }\\n       \\n      \\n    }\\n     return (100*k)/x;\\n    \\n}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nint percentageLetter(char *s, char letter){\\n    int x=strlen(s);\\n    int k=0;\\n    for(int i=0;i<x;i++)\\n     {\\n        if(s[i]==letter)\\n        {\\n            k++;\\n        }\\n       \\n      \\n    }\\n     return (100*k)/x;\\n    \\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2061847,
                "title": "c-cakewalk-brute-force-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int percentageLetter(string s, char letter) {\\n        int n = s.size();\\n        int cnt = 0;\\n        for(int i=0; i<n; i++) {\\n            if(s[i] == letter) cnt++;\\n        }\\n        int ans = cnt * 100 / n;\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Math",
                    "String"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int percentageLetter(string s, char letter) {\\n        int n = s.size();\\n        int cnt = 0;\\n        for(int i=0; i<n; i++) {\\n            if(s[i] == letter) cnt++;\\n        }\\n        int ans = cnt * 100 / n;\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2061796,
                "title": "1-liner-solution-java",
                "content": "method - 1\\n\\n```\\nreturn (int)(s.chars().filter(ch -> ch == letter).count()*100 / s.length());\\n```\\nMethod - 2\\n```\\nreturn (int)Arrays.stream(s.split(\"\")).filter(ch -> letter==ch.charAt(0)).count()*100 / s.length();\\n```\\nMethod - 3\\n\\n```\\npublic int percentageLetter(String s, char letter) {\\n     double a = 0;\\n     for(int i=0;i<s.length();i++){\\n         if(s.charAt(i)==letter) a++;\\n     }\\n     return (int)(100*a / s.length());\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nreturn (int)(s.chars().filter(ch -> ch == letter).count()*100 / s.length());\\n```\n```\\nreturn (int)Arrays.stream(s.split(\"\")).filter(ch -> letter==ch.charAt(0)).count()*100 / s.length();\\n```\n```\\npublic int percentageLetter(String s, char letter) {\\n     double a = 0;\\n     for(int i=0;i<s.length();i++){\\n         if(s.charAt(i)==letter) a++;\\n     }\\n     return (int)(100*a / s.length());\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2613114,
                "title": "single-line-code-c-easy",
                "content": "```\\nclass Solution {\\npublic:\\n    int percentageLetter(string s, char letter) {\\n        return count(s.begin(),s.end(),letter)*100/s.length();\\n    }\\n};\\n```\\n**Please upvote if it helps**",
                "solutionTags": [
                    "C",
                    "String"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int percentageLetter(string s, char letter) {\\n        return count(s.begin(),s.end(),letter)*100/s.length();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2100099,
                "title": "easy-python-solution",
                "content": "```\\ndef percentageLetter(self, s: str, letter: str) -> int:\\n        return (\"%d\" %(s.count(letter)/len(s)*100))\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\ndef percentageLetter(self, s: str, letter: str) -> int:\\n        return (\"%d\" %(s.count(letter)/len(s)*100))\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2066856,
                "title": "javascript-1-liner",
                "content": "```\\n/**\\n * @param {string} s\\n * @param {character} letter\\n * @return {number}\\n */\\nconst percentageLetter = (s, letter) => Math.floor((s.length - s.replaceAll(letter, \\'\\').length) * 100 / s.length);\\n```\\n\\n<br />\\n\\n\\u2139\\uFE0F [My javascript solution collection](https://github.com/toantd90/leetcode-js-solutions)\\n\\n<br />",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {string} s\\n * @param {character} letter\\n * @return {number}\\n */\\nconst percentageLetter = (s, letter) => Math.floor((s.length - s.replaceAll(letter, \\'\\').length) * 100 / s.length);\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3720564,
                "title": "beats-beginner-friendly-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int percentageLetter(String s, char letter) {\\n        int count = 0;\\n        for(char c : s.toCharArray()) {\\n            if(c == letter){ \\n                count++;\\n            }\\n        }\\n        return (100 * count) / s.length();\\n        // if you like it, please upvote it.\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int percentageLetter(String s, char letter) {\\n        int count = 0;\\n        for(char c : s.toCharArray()) {\\n            if(c == letter){ \\n                count++;\\n            }\\n        }\\n        return (100 * count) / s.length();\\n        // if you like it, please upvote it.\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3228343,
                "title": "6-line-100-faster-c-code",
                "content": "```\\nint percentageLetter(string s, char c) {\\n        vector<int> v(26,0);\\n        for(auto &i: s){\\n            v[i-\\'a\\']++;\\n        }\\n        return (v[c-\\'a\\']*1.0/s.length())*100;\\n    }\\n\\t```",
                "solutionTags": [
                    "C++",
                    "C",
                    "String"
                ],
                "code": "```\\nint percentageLetter(string s, char c) {\\n        vector<int> v(26,0);\\n        for(auto &i: s){\\n            v[i-\\'a\\']++;\\n        }\\n        return (v[c-\\'a\\']*1.0/s.length())*100;\\n    }\\n\\t```",
                "codeTag": "Unknown"
            },
            {
                "id": 2739747,
                "title": "java-easiest-solution-possible",
                "content": "\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int percentageLetter(String s, char letter) {\\n     int count = 0;\\n     for(char c : s.toCharArray()) {\\n         if(c == letter)\\n         count ++;\\n     } \\n     return (count * 100) / s.length();  \\n    }\\n}\\n```\\n# PLEASE UPVOTE IF IT WAS HELPFULL",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int percentageLetter(String s, char letter) {\\n     int count = 0;\\n     for(char c : s.toCharArray()) {\\n         if(c == letter)\\n         count ++;\\n     } \\n     return (count * 100) / s.length();  \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2384120,
                "title": "0ms-java-solution-faster-than-100",
                "content": "**Runtime: 0 ms, faster than 100.00% of Java online submissions for Percentage of Letter in String.\\nMemory Usage: 41.6 MB, less than 72.89% of Java online submissions for Percentage of Letter in String.**\\n\\nJava code:\\n```\\n    public int percentageLetter(String s, char letter) {\\n        var count = 0;\\n        for (int i = 0; i < s.length(); i++) {\\n            if (s.charAt(i) == letter) {\\n                count++;\\n            }\\n        }\\n        return (int) (((double) count / (double) s.length()) * 100);\\n    }\\n```",
                "solutionTags": [
                    "Java",
                    "String"
                ],
                "code": "```\\n    public int percentageLetter(String s, char letter) {\\n        var count = 0;\\n        for (int i = 0; i < s.length(); i++) {\\n            if (s.charAt(i) == letter) {\\n                count++;\\n            }\\n        }\\n        return (int) (((double) count / (double) s.length()) * 100);\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2067164,
                "title": "java-short-0ms-solution-faster-than-100",
                "content": "```\\npublic int percentageLetter(String s, char letter) {\\n    double count = 0.0;\\n\\n    for (int i = 0; i < s.length(); i++) {\\n        if (s.charAt(i) == letter) count++;\\n    }\\n\\n    double percentage = count / s.length();\\n    return (int) (percentage * 100);\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\npublic int percentageLetter(String s, char letter) {\\n    double count = 0.0;\\n\\n    for (int i = 0; i < s.length(); i++) {\\n        if (s.charAt(i) == letter) count++;\\n    }\\n\\n    double percentage = count / s.length();\\n    return (int) (percentage * 100);\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2061926,
                "title": "easy-math-solution-c-o-n",
                "content": "```\\nclass Solution {\\npublic:\\n    int percentageLetter(string s, char letter) {\\n        long n = s.length();\\n        long cnt = 0;\\n        for(int i=0;i<n;i++){\\n            if(s[i] == letter)\\n                cnt++;\\n        }\\n        \\n        long x = cnt* 100 / n;\\n        \\n        return (int)x;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int percentageLetter(string s, char letter) {\\n        long n = s.length();\\n        long cnt = 0;\\n        for(int i=0;i<n;i++){\\n            if(s[i] == letter)\\n                cnt++;\\n        }\\n        \\n        long x = cnt* 100 / n;\\n        \\n        return (int)x;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4012504,
                "title": "simple-and-easy-code-using-java",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int percentageLetter(String str, char letter) {\\n        int count=0;\\n        int n=str.length();\\n        for(int i=0;i<n;i++){\\n            if(str.charAt(i)==letter){\\n\\n                count ++;\\n            }\\n        }\\n                 int per= (100*count)/n;\\n         return per;   \\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int percentageLetter(String str, char letter) {\\n        int count=0;\\n        int n=str.length();\\n        for(int i=0;i<n;i++){\\n            if(str.charAt(i)==letter){\\n\\n                count ++;\\n            }\\n        }\\n                 int per= (100*count)/n;\\n         return per;   \\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3779033,
                "title": "one-line-solution-swift",
                "content": "\\n# Code\\n```\\nclass Solution {\\n    func percentageLetter(_ s: String, _ letter: Character) -> Int {\\n        s.filter { $0 == letter }.count * 100 / s.count\\n    }\\n}\\n```",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nclass Solution {\\n    func percentageLetter(_ s: String, _ letter: Character) -> Int {\\n        s.filter { $0 == letter }.count * 100 / s.count\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3105886,
                "title": "3-lines-code-0ms-runtime-beats-100",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int percentageLetter(string s, char letter) {\\n        int cnt=0;\\n        for(int i=0;i<s.length();i++){\\n            if(s[i]==letter)cnt++;\\n        }\\n        return (cnt*100)/s.length();\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int percentageLetter(string s, char letter) {\\n        int cnt=0;\\n        for(int i=0;i<s.length();i++){\\n            if(s[i]==letter)cnt++;\\n        }\\n        return (cnt*100)/s.length();\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3081906,
                "title": "beats-100-code-in-java",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\n    public int percentageLetter(String s, char letter) {\\n        int n = s.length();\\n        int count = 0;\\n        for(int i=0;i<n;i++){\\n            if(s.charAt(i)== letter){\\n                count++;\\n            }\\n        }\\n        return (count *100)/n;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int percentageLetter(String s, char letter) {\\n        int n = s.length();\\n        int count = 0;\\n        for(int i=0;i<n;i++){\\n            if(s.charAt(i)== letter){\\n                count++;\\n            }\\n        }\\n        return (count *100)/n;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2735156,
                "title": "c-easy-short",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int percentageLetter(string s, char ch) \\n    {\\n        double count=0;\\n        double length = s.length();\\n        \\n        for(int i=0;i<s.length();i++)\\n        {\\n            if(s[i] == ch)\\n            {\\n                count++;\\n            }\\n        }\\n        double x =(count / length);\\n        return x*100;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int percentageLetter(string s, char ch) \\n    {\\n        double count=0;\\n        double length = s.length();\\n        \\n        for(int i=0;i<s.length();i++)\\n        {\\n            if(s[i] == ch)\\n            {\\n                count++;\\n            }\\n        }\\n        double x =(count / length);\\n        return x*100;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2211680,
                "title": "go-simple-one-pass-easy-to-understand",
                "content": "```\\nfunc percentageLetter(s string, letter byte) int {\\n    count := 0\\n    \\n    for i := 0; i < len(s); i++ {\\n        if s[i] == letter {\\n            count++\\n        }\\n    }\\n    \\n    return int(float64(count)/float64(len(s)) * 100)\\n}\\n```",
                "solutionTags": [
                    "C",
                    "Go"
                ],
                "code": "```\\nfunc percentageLetter(s string, letter byte) int {\\n    count := 0\\n    \\n    for i := 0; i < len(s); i++ {\\n        if s[i] == letter {\\n            count++\\n        }\\n    }\\n    \\n    return int(float64(count)/float64(len(s)) * 100)\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2081824,
                "title": "simple-python-solution",
                "content": "```\\nimport math\\nclass Solution:\\n    def percentageLetter(self, s: str, letter: str) -> int:\\n        cnt=s.count(letter)\\n        size=len(s)        \\n        ans=math.floor(cnt/size*100)\\n        return ans\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nimport math\\nclass Solution:\\n    def percentageLetter(self, s: str, letter: str) -> int:\\n        cnt=s.count(letter)\\n        size=len(s)        \\n        ans=math.floor(cnt/size*100)\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2074076,
                "title": "simple-fast-java-solution-faster-than-100",
                "content": "```\\npublic int percentageLetter(String s, char letter) {\\n    var count = 0;\\n    for (int i = 0; i < s.length(); i++) { // count the occurences of letter in s\\n        if (s.charAt(i)==letter) {\\n            count++;\\n        }\\n    }\\n    return (int) (((double) count/(double) s.length())*100); // return the percentage\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\npublic int percentageLetter(String s, char letter) {\\n    var count = 0;\\n    for (int i = 0; i < s.length(); i++) { // count the occurences of letter in s\\n        if (s.charAt(i)==letter) {\\n            count++;\\n        }\\n    }\\n    return (int) (((double) count/(double) s.length())*100); // return the percentage\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2065753,
                "title": "python-easy-solution-simple-fast",
                "content": "class Solution:\\n    def percentageLetter(self, s: str, letter: str) -> int:\\n        return (s.count(letter)*100//len(s))",
                "solutionTags": [
                    "Python"
                ],
                "code": "class Solution:\\n    def percentageLetter(self, s: str, letter: str) -> int:\\n        return (s.count(letter)*100//len(s))",
                "codeTag": "Java"
            },
            {
                "id": 2064857,
                "title": "easy-solution-c-0ms-runtime",
                "content": "```\\nclass Solution {\\npublic:\\n    int percentageLetter(string s, char letter) {\\n\\t//count the occurance of letter in string s.\\n        int val=count(s.begin(),s.end(),letter);\\n\\t//return percentage\\t\\n        return int(val*100/s.length());\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int percentageLetter(string s, char letter) {\\n\\t//count the occurance of letter in string s.\\n        int val=count(s.begin(),s.end(),letter);\\n\\t//return percentage\\t\\n        return int(val*100/s.length());\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2062432,
                "title": "simple-rust-one-line",
                "content": "```rust\\nimpl Solution {\\n    pub fn percentage_letter(s: String, letter: char) -> i32 {\\n        (s.chars().filter(|c| *c == letter).count() * 100 / s.len()) as i32\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```rust\\nimpl Solution {\\n    pub fn percentage_letter(s: String, letter: char) -> i32 {\\n        (s.chars().filter(|c| *c == letter).count() * 100 / s.len()) as i32\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2062414,
                "title": "two-liner-javascript-solution",
                "content": "Found this solution helpful? Consider showing support by upvoting this post.\\nHave a question? Kindly leave a comment below.\\nThank you and happy hacking!\\n```\\nvar percentageLetter = function (s, letter) {\\n    let letterFilter = s.split(\\'\\').filter(char => char == letter)\\n\\t\\n    return Math.trunc((letterFilter.length/ s.length) * 100)\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar percentageLetter = function (s, letter) {\\n    let letterFilter = s.split(\\'\\').filter(char => char == letter)\\n\\t\\n    return Math.trunc((letterFilter.length/ s.length) * 100)\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2062287,
                "title": "c-simple-approach-using-map-approach",
                "content": "**Time Complexity :** O(n)\\n**Space Complexity :** O(1)\\n\\n**Simple Approach** -->\\n```\\nclass Solution {\\npublic:\\n    int percentageLetter(string s, char letter) {\\n        int n = s.size(); // length of string\\n        int cnt=0; // count of letter\\n        for(int i=0;i<n;i++){ // loop through string\\n            if(s[i]==letter) cnt++; // if letter found, increment count\\n        }\\n        return float(cnt*100/(float)n); // return percentage\\n    }\\n};\\n```\\n\\n**Map Approach** --> \\n```\\nint percentageLetter(string s, char letter) {\\n        map<char,int> mp; // map to store the count of each letter\\n        for(auto x : s) mp[x]++; // increment the count of each letter\\n        int cnt=0; // count of the letter\\n        if(mp.find(letter)!=mp.end()){  // if the letter is present in the string\\n            cnt=mp[letter]; // store the count of the letter\\n        }\\n        return (cnt*100/s.size()); // return the percentage of the letter\\n    }\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int percentageLetter(string s, char letter) {\\n        int n = s.size(); // length of string\\n        int cnt=0; // count of letter\\n        for(int i=0;i<n;i++){ // loop through string\\n            if(s[i]==letter) cnt++; // if letter found, increment count\\n        }\\n        return float(cnt*100/(float)n); // return percentage\\n    }\\n};\\n```\n```\\nint percentageLetter(string s, char letter) {\\n        map<char,int> mp; // map to store the count of each letter\\n        for(auto x : s) mp[x]++; // increment the count of each letter\\n        int cnt=0; // count of the letter\\n        if(mp.find(letter)!=mp.end()){  // if the letter is present in the string\\n            cnt=mp[letter]; // store the count of the letter\\n        }\\n        return (cnt*100/s.size()); // return the percentage of the letter\\n    }\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2061960,
                "title": "percentage-of-letter-in-string-java-solution",
                "content": "```\\nclass Solution {\\n    public int percentageLetter(String s, char letter) {\\n        double count=0,tot=0;\\n       for(int i=0;i<s.length();i++)\\n       {\\n           if(s.charAt(i)==letter)\\n               count++;\\n           tot++;\\n        }\\n        return (int)((count/tot)*100);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int percentageLetter(String s, char letter) {\\n        double count=0,tot=0;\\n       for(int i=0;i<s.length();i++)\\n       {\\n           if(s.charAt(i)==letter)\\n               count++;\\n           tot++;\\n        }\\n        return (int)((count/tot)*100);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2061945,
                "title": "simple-java-solution",
                "content": "```\\nclass Solution {\\n    public int percentageLetter(String s, char l) {\\n        int k=0;\\n        for(char c:s.toCharArray())\\n        {\\n            if(l==c)\\n                k++;\\n        }\\n        k=Math.round((k*100)/s.length());\\n        return k;\\n    }\\n}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    public int percentageLetter(String s, char l) {\\n        int k=0;\\n        for(char c:s.toCharArray())\\n        {\\n            if(l==c)\\n                k++;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2061930,
                "title": "simple-python-solution-easy-to-understand-two-liner-solution-o-n-solution",
                "content": "```\\nclass Solution:\\n    def percentageLetter(self, s: str, letter: str) -> int:\\n        a = s.count(letter)\\n        return (a*100)//len(s)\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def percentageLetter(self, s: str, letter: str) -> int:\\n        a = s.count(letter)\\n        return (a*100)//len(s)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2061921,
                "title": "easy-cpp-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int percentageLetter(string s, char letter) {\\n        int a[26]={0},n=s.size();\\n        for(int i=0;i<n;i++)\\n            a[s[i]-\\'a\\']++;\\n        int x=a[letter-\\'a\\'];\\n        x*=100;\\n        x/=n;\\n        return x;\\n    }\\n};",
                "solutionTags": [
                    "C++"
                ],
                "code": "class Solution {\\npublic:\\n    int percentageLetter(string s, char letter) {\\n        int a[26]={0}",
                "codeTag": "Java"
            },
            {
                "id": 2061877,
                "title": "easy-cpp-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int percentageLetter(string s, char letter) {\\n        map<char,double> mp ; \\n        for(int i = 0 ; i < s.size(); i ++) {\\n             mp[s[i]] ++ ; \\n        }\\n        double l = s.size(); \\n        if(mp[letter] == 0 ) {\\n            return 0 ; \\n        }\\n        cout << mp[letter] << endl ; \\n         \\n        double p = (mp[letter]/l)*100;\\n        cout << p << endl ;\\n        return int(p) ; \\n     }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int percentageLetter(string s, char letter) {\\n        map<char,double> mp ; \\n        for(int i = 0 ; i < s.size(); i ++) {\\n             mp[s[i]] ++ ; \\n        }\\n        double l = s.size(); \\n        if(mp[letter] == 0 ) {\\n            return 0 ; \\n        }\\n        cout << mp[letter] << endl ; \\n         \\n        double p = (mp[letter]/l)*100;\\n        cout << p << endl ;\\n        return int(p) ; \\n     }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2061800,
                "title": "c-easy-to-understand",
                "content": "```\\nclass Solution {\\nprivate:\\n    int percent(int number, int total){\\n        int x = (number*100)/total;\\n        return x;\\n    }\\npublic:\\n    int percentageLetter(string s, char letter) {\\n        int count = 0;\\n        for(auto itr: s){\\n            if(itr==letter){ count++; }\\n        }\\n        return percent(count, s.size());\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\nprivate:\\n    int percent(int number, int total){\\n        int x = (number*100)/total;\\n        return x;\\n    }\\npublic:\\n    int percentageLetter(string s, char letter) {\\n        int count = 0;\\n        for(auto itr: s){\\n            if(itr==letter){ count++; }\\n        }\\n        return percent(count, s.size());\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3903351,
                "title": "easy-python-3-solution-beats-85",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def percentageLetter(self, s: str, letter: str) -> int:\\n        count=0\\n        start_index=0\\n        l=len(s)\\n        for i in range(l):\\n            j = s.find(letter,start_index)\\n            if(j!=-1):\\n                start_index = j+1\\n                count+=1\\n        per = math.floor((count/l)*100)\\n        return per\\n\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def percentageLetter(self, s: str, letter: str) -> int:\\n        count=0\\n        start_index=0\\n        l=len(s)\\n        for i in range(l):\\n            j = s.find(letter,start_index)\\n            if(j!=-1):\\n                start_index = j+1\\n                count+=1\\n        per = math.floor((count/l)*100)\\n        return per\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3723779,
                "title": "0ms-runtime-java-python-c",
                "content": "# Code\\n```Java []\\nclass Solution {\\n    public int percentageLetter(String s, char letter) {\\n          int n=s.length();\\n          int count=0;\\n          for(int i=0;i<n;i++)\\n          {\\n              if(s.charAt(i)==letter)\\n              \\n                  count++;\\n              \\n          }\\n          return (100*count)/n;\\n    }\\n}\\n```\\n```Python []\\nclass Solution(object):\\n    def percentageLetter(self, s, letter):\\n        count=0\\n        for i in range(0,len(s)):\\n            if (s[i]==letter): count+=1\\n        return int((100*count)/len(s))\\n```\\n```C++ []\\nclass Solution {\\npublic:\\n    int percentageLetter(string s, char letter) {\\n        int count=0;\\n        for (int i=0; i<s.size(); i++)\\n        {\\n            if (s[i]==letter) count++;\\n        }\\n        return (100*count)/s.size();\\n    }\\n};\\n```\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "String"
                ],
                "code": "```Java []\\nclass Solution {\\n    public int percentageLetter(String s, char letter) {\\n          int n=s.length();\\n          int count=0;\\n          for(int i=0;i<n;i++)\\n          {\\n              if(s.charAt(i)==letter)\\n              \\n                  count++;\\n              \\n          }\\n          return (100*count)/n;\\n    }\\n}\\n```\n```Python []\\nclass Solution(object):\\n    def percentageLetter(self, s, letter):\\n        count=0\\n        for i in range(0,len(s)):\\n            if (s[i]==letter): count+=1\\n        return int((100*count)/len(s))\\n```\n```C++ []\\nclass Solution {\\npublic:\\n    int percentageLetter(string s, char letter) {\\n        int count=0;\\n        for (int i=0; i<s.size(); i++)\\n        {\\n            if (s[i]==letter) count++;\\n        }\\n        return (100*count)/s.size();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3723751,
                "title": "easy-0-ms-solution-in-java-c-and-python",
                "content": "```java []\\nclass Solution {\\n    public int percentageLetter(String s, char letter) {\\n          int n=s.length();\\n          int count=0;\\n          for(int i=0;i<n;i++)\\n          {\\n              if(s.charAt(i)==letter)\\n              \\n                  count++;\\n              \\n          }\\n          return (100*count)/n;\\n    }\\n}\\n```\\n```python []\\nclass Solution(object):\\n    def percentageLetter(self, s, letter):\\n        count=0\\n        for i in range(0,len(s)):\\n            if (s[i]==letter): count+=1\\n        return int((100*count)/len(s))\\n```\\n```C++ []\\nclass Solution {\\npublic:\\n    int percentageLetter(string s, char letter) {\\n        int count=0;\\n        for (int i=0; i<s.size(); i++)\\n        {\\n            if (s[i]==letter) count++;\\n        }\\n        return (100*count)/s.size();\\n    }\\n};\\n```\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "String"
                ],
                "code": "```java []\\nclass Solution {\\n    public int percentageLetter(String s, char letter) {\\n          int n=s.length();\\n          int count=0;\\n          for(int i=0;i<n;i++)\\n          {\\n              if(s.charAt(i)==letter)\\n              \\n                  count++;\\n              \\n          }\\n          return (100*count)/n;\\n    }\\n}\\n```\n```python []\\nclass Solution(object):\\n    def percentageLetter(self, s, letter):\\n        count=0\\n        for i in range(0,len(s)):\\n            if (s[i]==letter): count+=1\\n        return int((100*count)/len(s))\\n```\n```C++ []\\nclass Solution {\\npublic:\\n    int percentageLetter(string s, char letter) {\\n        int count=0;\\n        for (int i=0; i<s.size(); i++)\\n        {\\n            if (s[i]==letter) count++;\\n        }\\n        return (100*count)/s.size();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3704737,
                "title": "percentage-of-letter-in-string-java-solution-code",
                "content": "# Code\\n```\\nclass Solution {\\n    public int percentageLetter(String s, char letter) {\\n        double count = 0;\\n        for(int i=0; i<s.length(); i++){\\n            if(s.charAt(i) == letter){\\n                count++;\\n            }\\n        }\\n        return (int)(count * 100) / s.length();\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int percentageLetter(String s, char letter) {\\n        double count = 0;\\n        for(int i=0; i<s.length(); i++){\\n            if(s.charAt(i) == letter){\\n                count++;\\n            }\\n        }\\n        return (int)(count * 100) / s.length();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3566667,
                "title": "percentage-of-letter-in-string-solution-in-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1)\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int percentageLetter(string s, char letter) {\\n        int c = count(s.begin(), s.end(), letter);\\n        return c*100/s.length();\\n    }\\n};\\n```\\n![upvote new.jpg](https://assets.leetcode.com/users/images/4c281000-7517-4dc6-a994-2a93c65e65e1_1685162324.053199.jpeg)\\n",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int percentageLetter(string s, char letter) {\\n        int c = count(s.begin(), s.end(), letter);\\n        return c*100/s.length();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3493888,
                "title": "easy-solution",
                "content": "\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n        add it to the frequency map\\n\\n# Complexity\\n- Time complexity: O(s.length())\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(s.length())\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int percentageLetter(String s, char letter) {\\n        HashMap<Character, Integer> map= new HashMap<>();\\n        for(int i=0;i<s.length();i++){\\n            char c= s.charAt(i);\\n            if(map.containsKey(c)) map.put(c, map.get(c)+1);\\n                else map.put(c,1);\\n        }\\n\\n        int percentage= (map.getOrDefault(letter,0)*100/ s.length());\\n\\n        return  percentage;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int percentageLetter(String s, char letter) {\\n        HashMap<Character, Integer> map= new HashMap<>();\\n        for(int i=0;i<s.length();i++){\\n            char c= s.charAt(i);\\n            if(map.containsKey(c)) map.put(c, map.get(c)+1);\\n                else map.put(c,1);\\n        }\\n\\n        int percentage= (map.getOrDefault(letter,0)*100/ s.length());\\n\\n        return  percentage;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3444622,
                "title": "most-difficult-ans-to-most-difficult-question",
                "content": "- # Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int percentageLetter(String s, char letter) {\\n        int count=0;\\n        for(int i=0;i<s.length();i++){\\n            if(s.charAt(i) == letter) {\\n            \\tcount++;\\n            }\\n        }  \\n        return (count*100)/s.length();\\n    }\\n}\\n`****Kindly upvote if you like the ans****``",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    public int percentageLetter(String s, char letter) {\\n        int count=0;\\n        for(int i=0;i<s.length();i++){\\n            if(s.charAt(i) == letter) {\\n            \\tcount++;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 3350166,
                "title": "simple-java-code",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int percentageLetter(String s, char letter) {\\n        int a = s.length();\\n        int count =0;\\n        for(int i =0; i<a; i++){\\n            if(s.charAt(i) == letter) count++;\\n        }\\n        //System.out.println(count);\\n        int b = (count*100)/a;\\n        return b;\\n\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int percentageLetter(String s, char letter) {\\n        int a = s.length();\\n        int count =0;\\n        for(int i =0; i<a; i++){\\n            if(s.charAt(i) == letter) count++;\\n        }\\n        //System.out.println(count);\\n        int b = (count*100)/a;\\n        return b;\\n\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3241054,
                "title": "c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int percentageLetter(string s, char letter) {\\n        \\n    int count = 0;\\n    for (int i = 0; i < s.size(); i++)\\n        if (s[i] == letter)\\n            count++;\\n    return ((count * 100) / s.size()); \\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int percentageLetter(string s, char letter) {\\n        \\n    int count = 0;\\n    for (int i = 0; i < s.size(); i++)\\n        if (s[i] == letter)\\n            count++;\\n    return ((count * 100) / s.size()); \\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3218465,
                "title": "percentage-of-letter-in-string",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n![percentageofstring.PNG](https://assets.leetcode.com/users/images/4fe252f9-a351-40a7-b646-bee2ce2d3469_1677075653.892181.png)\\n\\n# Code\\n```\\n\\nclass Solution:\\n    def percentageLetter(self, s: str, letter: str) -> int:\\n        if letter not in s:\\n            return 0\\n        return round(math.floor((s.count(letter)/len(s))*100))     \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\n\\nclass Solution:\\n    def percentageLetter(self, s: str, letter: str) -> int:\\n        if letter not in s:\\n            return 0\\n        return round(math.floor((s.count(letter)/len(s))*100))     \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3201712,
                "title": "python-soln",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def percentageLetter(self, s: str, letter: str) -> int:\\n        l=len(s)\\n        count=0\\n        for i in s:\\n            if i==letter:\\n                count+=1\\n            else:\\n                pass\\n        return int((count/l)*100)        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def percentageLetter(self, s: str, letter: str) -> int:\\n        l=len(s)\\n        count=0\\n        for i in s:\\n            if i==letter:\\n                count+=1\\n            else:\\n                pass\\n        return int((count/l)*100)        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3181416,
                "title": "simple-easy-c-code-beats-100-in-runtime",
                "content": "Runtime : Beats 100% \\u270C\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int percentageLetter(string s, char letter) {\\n        float c=0;\\n        float a=s.size();\\n        for(int i=0;i<a;i++){\\n            if(s[i]==letter){\\n                c++;\\n            }\\n        }\\n            float x=(c*100)/a;\\n            return x;\\n    }\\n};\\n```\\n\\nHope you liked the implementation of the code, if you like it feel free to upvote \\uD83D\\uDC4D",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int percentageLetter(string s, char letter) {\\n        float c=0;\\n        float a=s.size();\\n        for(int i=0;i<a;i++){\\n            if(s[i]==letter){\\n                c++;\\n            }\\n        }\\n            float x=(c*100)/a;\\n            return x;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3140654,
                "title": "java-solution-beats-100-simple-and-easy-solution",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\n    public int percentageLetter(String s, char letter) {\\n        int x = 0;\\n        for(int i = 0 ; i < s.length() ; i++){\\n            if(s.charAt(i)==letter)x++;\\n        }\\n        \\n        return x*100/s.length();\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "String"
                ],
                "code": "```\\nclass Solution {\\n    public int percentageLetter(String s, char letter) {\\n        int x = 0;\\n        for(int i = 0 ; i < s.length() ; i++){\\n            if(s.charAt(i)==letter)x++;\\n        }\\n        \\n        return x*100/s.length();\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3054106,
                "title": "java-0-ms-beats-100-percent-easy-undersatnding-strings",
                "content": "# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n    O(n)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n    O(1);\\n# Code\\n```\\nclass Solution {\\n    public int percentageLetter(String s, char letter) {\\n        int cnt=0;\\n        for(int i=0;i<s.length();i++){\\n            if(s.charAt(i)==letter) cnt++;\\n        }\\n        return Math.round((cnt*100)/s.length());\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "String"
                ],
                "code": "```\\nclass Solution {\\n    public int percentageLetter(String s, char letter) {\\n        int cnt=0;\\n        for(int i=0;i<s.length();i++){\\n            if(s.charAt(i)==letter) cnt++;\\n        }\\n        return Math.round((cnt*100)/s.length());\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3053529,
                "title": "easy-c-solution-100-faster",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int percentageLetter(string s, char letter) {\\n        int c=0;\\n        int l=s.size();\\n        for(int i=0;i<s.size();i++){\\n            if(s[i]==letter)\\n            c++;\\n        }\\n        int ans = (c *100)/l;\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int percentageLetter(string s, char letter) {\\n        int c=0;\\n        int l=s.size();\\n        for(int i=0;i<s.size();i++){\\n            if(s[i]==letter)\\n            c++;\\n        }\\n        int ans = (c *100)/l;\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3045807,
                "title": "3-lines-approach-please-upvote-if-you-like-the-solution",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    int percentageLetter(string s, char letter) {\\n        int c=0;\\n        for(int i=0;i<s.size();i++)\\n            if(s[i]==letter) c++;\\n        return (c*100)/s.size();\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int percentageLetter(string s, char letter) {\\n        int c=0;\\n        for(int i=0;i<s.size();i++)\\n            if(s[i]==letter) c++;\\n        return (c*100)/s.size();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3043666,
                "title": "percentage-of-letter-in-string-easy-java-solution",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\n- convert string in array and put all element of string s in array ch.\\n- use for loop and check every elemt of array ch that it is matching with letter or not. If it match with letter then count will be increased by 1. \\n\\n        if(chr[i] == letter){\\n            count++;\\n\\n\\n# Code\\n```\\nclass Solution {\\n    public int percentageLetter(String s, char letter) {\\n        int ans;\\n        int count = 0;\\n        int numOfString = s.length();\\n        char[] chr = new char[numOfString];\\n        for(int i=0; i<chr.length; i++){\\n            chr[i] = s.charAt(i);\\n        }\\n        for(int i=0; i<chr.length; i++){\\n            if(chr[i] == letter){\\n                count++;\\n            }\\n        }\\n        ans = (count*100)/numOfString;\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int percentageLetter(String s, char letter) {\\n        int ans;\\n        int count = 0;\\n        int numOfString = s.length();\\n        char[] chr = new char[numOfString];\\n        for(int i=0; i<chr.length; i++){\\n            chr[i] = s.charAt(i);\\n        }\\n        for(int i=0; i<chr.length; i++){\\n            if(chr[i] == letter){\\n                count++;\\n            }\\n        }\\n        ans = (count*100)/numOfString;\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2997896,
                "title": "simple-approach-by-using-percentage",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int percentageLetter(string s, char letter) {\\n        int count = 0;\\n        for(int i=0; i<s.length(); i++){\\n            if(s[i] == letter){\\n                count++;\\n            }\\n        }\\n        int ans = ((count*100)/s.length()); \\n        return ans;\\n    }\\n}; \\n```",
                "solutionTags": [
                    "C++",
                    "Math"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int percentageLetter(string s, char letter) {\\n        int count = 0;\\n        for(int i=0; i<s.length(); i++){\\n            if(s[i] == letter){\\n                count++;\\n            }\\n        }\\n        int ans = ((count*100)/s.length()); \\n        return ans;\\n    }\\n}; \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2950436,
                "title": "easiest-solution-c-easy-to-understand",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int percentageLetter(string s, char letter) {\\n        map<char,int> mp;\\n        for(auto &i:s) mp[i]++;\\n        int ans = 0;\\n        for(auto i:mp) if(i.first==letter) ans=((double)i.second/(double)s.length())*100;\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int percentageLetter(string s, char letter) {\\n        map<char,int> mp;\\n        for(auto &i:s) mp[i]++;\\n        int ans = 0;\\n        for(auto i:mp) if(i.first==letter) ans=((double)i.second/(double)s.length())*100;\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2792400,
                "title": "only-4-5-lines-of-code-and-gives-0-ms-time-complexity",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nfirst count how many times letter is present in s string then simply find persentage\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nsimply searching then find persentage\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n41.8 MB\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n0 MS\\n\\n# Code\\n```\\nclass Solution {\\n    public int percentageLetter(String s, char letter) {\\n        // for find count\\n        int count = 0;\\n            for(int j=0; j<s.length(); j++){\\n                if(s.charAt(j) == letter){\\n                    count++;\\n                }\\n            }\\n        // print persentage\\n        return (count * 100) / s.length();\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int percentageLetter(String s, char letter) {\\n        // for find count\\n        int count = 0;\\n            for(int j=0; j<s.length(); j++){\\n                if(s.charAt(j) == letter){\\n                    count++;\\n                }\\n            }\\n        // print persentage\\n        return (count * 100) / s.length();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2760945,
                "title": "percentage-of-letter-in-string",
                "content": "```\\nclass Solution {\\n    public int percentageLetter(String s, char letter) {\\n        int count = 0;\\n        for(int i=0;i<s.length();i++){\\n            if(s.charAt(i)== letter){\\n                count++;\\n            }\\n        }\\n        return (count*100)/s.length();\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "String"
                ],
                "code": "```\\nclass Solution {\\n    public int percentageLetter(String s, char letter) {\\n        int count = 0;\\n        for(int i=0;i<s.length();i++){\\n            if(s.charAt(i)== letter){\\n                count++;\\n            }\\n        }\\n        return (count*100)/s.length();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2710506,
                "title": "python-o-n-runtime-50-ms-beats-56-36-memory-13-9-mb-beats-10-66",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n- O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n- O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def percentageLetter(self, s: str, letter: str) -> int:\\n        c=0\\n        for i in s:\\n            if i==letter:\\n                c+=1\\n        n=len(s)\\n        return int(c/n*100)\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def percentageLetter(self, s: str, letter: str) -> int:\\n        c=0\\n        for i in s:\\n            if i==letter:\\n                c+=1\\n        n=len(s)\\n        return int(c/n*100)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2699469,
                "title": "100-faster-c-solution",
                "content": "```\\nclass Solution {\\n   public:\\n    int percentageLetter(string s, char letter) {\\n        int len = s.length();\\n        float count = 0;\\n        for (int i = 0; i < len; i++)\\n            if (s[i] == letter) count++;\\n        return (double(count) / len ) * 100;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\n   public:\\n    int percentageLetter(string s, char letter) {\\n        int len = s.length();\\n        float count = 0;\\n        for (int i = 0; i < len; i++)\\n            if (s[i] == letter) count++;\\n        return (double(count) / len ) * 100;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2647725,
                "title": "100-better-solution-c",
                "content": "```\\nclass Solution {\\npublic:\\n    int percentageLetter(string s, char ch) \\n    {\\n        double count=0;\\n        double length = s.length();\\n        \\n        for(int i=0;i<s.length();i++)\\n        {\\n            if(s[i] == ch)\\n            {\\n                count++;\\n            }\\n        }\\n        double x =(count / length);\\n        return x*100;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int percentageLetter(string s, char ch) \\n    {\\n        double count=0;\\n        double length = s.length();\\n        \\n        for(int i=0;i<s.length();i++)\\n        {\\n            if(s[i] == ch)\\n            {\\n                count++;\\n            }\\n        }\\n        double x =(count / length);\\n        return x*100;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2619988,
                "title": "c-easy-solution-0ms-faster-than-100",
                "content": "**Please upvote if this helps :)**\\n\\nclass Solution {\\npublic:\\n\\n    int percentageLetter(string s, char letter) {\\n        double count=0;\\n        float n=s.size();\\n        sort(s.begin(),s.end());\\n        int i=0;\\n        while(i<n){\\n            if(s[i]==letter){\\n                count++;  \\n            }\\n            i++;\\n        } \\n        return count/n*100;     \\n    }\\n};",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n\\n    int percentageLetter(string s, char letter) {\\n        double count=0;\\n        float n=s.size();\\n        sort(s.begin(),s.end());\\n        int i=0;\\n        while(i<n){\\n            if(s[i]==letter){\\n                count++;  \\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2489349,
                "title": "java-solution-0ms-ru-time-100-faster-easy-to-understa-d",
                "content": "```\\nclass Solution {\\n    public int percentageLetter(String word, char tar) {\\n        int c = 0;\\n        for (char i : word.toCharArray()) {\\n            if (i == tar) c++;\\n        }\\n        return (int)(c * 100.0) / word.length();\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int percentageLetter(String word, char tar) {\\n        int c = 0;\\n        for (char i : word.toCharArray()) {\\n            if (i == tar) c++;\\n        }\\n        return (int)(c * 100.0) / word.length();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2439354,
                "title": "c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int percentageLetter(string s, char letter) {\\n        int c=0;\\n        for(int i=0;i<s.length();i++)\\n        {\\n            if(s[i]==letter)\\n            {\\n                c++;\\n            }\\n        }\\n        c = ((c*100)/s.length());\\n        return c;\\n        \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int percentageLetter(string s, char letter) {\\n        int c=0;\\n        for(int i=0;i<s.length();i++)\\n        {\\n            if(s[i]==letter)\\n            {\\n                c++;\\n            }\\n        }\\n        c = ((c*100)/s.length());\\n        return c;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2428414,
                "title": "c-easy-understandable-small-solution-0ms-100",
                "content": "```\\nint percentageLetter(string s, char letter) {\\n        int count = 0;\\n        for(auto i : s) if(i == letter) count++;\\n        double c = ((count * 0.1)/(s.size() * 0.1)) * 100;\\n        return int(c);\\n\\t\\t}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nint percentageLetter(string s, char letter) {\\n        int count = 0;\\n        for(auto i : s) if(i == letter) count++;\\n        double c = ((count * 0.1)/(s.size() * 0.1)) * 100;\\n        return int(c);\\n\\t\\t}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2426928,
                "title": "easy-cpp-soln",
                "content": "class Solution {\\npublic:\\n    int percentageLetter(string s, char letter) {\\n        int count=0;\\n        int n=s.size();\\n        for(int i=0; i<n; i++){\\n            if(s[i]==letter){\\n                count++;\\n            }\\n        }\\n        int ans=(count*100)/n;\\n        return ans;\\n    }\\n};",
                "solutionTags": [
                    "C",
                    "String"
                ],
                "code": "class Solution {\\npublic:\\n    int percentageLetter(string s, char letter) {\\n        int count=0;\\n        int n=s.size();\\n        for(int i=0; i<n; i++){\\n            if(s[i]==letter){\\n                count++;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2332965,
                "title": "python3-o-n-o-n-runtime-45ms-55-96-memory-13-9mb-10-12",
                "content": "```\\nfrom collections import Counter as c\\n# O(n) || O(n)\\n# Runtime: 45ms 55.96% || Memory: 13.9mb 10.12%\\nclass Solution:\\n    def percentageLetter(self, string: str, letter: str) -> int:\\n        stringFreq = c(string)\\n        if not letter in stringFreq: return 0\\n        letterFreq = stringFreq[letter]\\n        stringSize = len(string)\\n        \\n        return letterFreq * 100 // stringSize\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nfrom collections import Counter as c\\n# O(n) || O(n)\\n# Runtime: 45ms 55.96% || Memory: 13.9mb 10.12%\\nclass Solution:\\n    def percentageLetter(self, string: str, letter: str) -> int:\\n        stringFreq = c(string)\\n        if not letter in stringFreq: return 0\\n        letterFreq = stringFreq[letter]\\n        stringSize = len(string)\\n        \\n        return letterFreq * 100 // stringSize\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2308655,
                "title": "simple-2-line-solution-in-cpp-please-upvote",
                "content": "```\\nclass Solution {\\npublic:\\n    int percentageLetter(string s, char letter) {\\n        double c = count(s.begin() , s.end() , letter);\\n        return c/s.size()*100;\\n    }\\n};\\n```\\nPlease upvote \\nhttps://github.com/Reehan9/Leetcode-Solutions",
                "solutionTags": [
                    "String"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int percentageLetter(string s, char letter) {\\n        double c = count(s.begin() , s.end() , letter);\\n        return c/s.size()*100;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2287025,
                "title": "javascript-solution-easy-to-understand",
                "content": "```\\n\\nvar percentageLetter = function(s, letter) {\\n    let count=0;\\n    \\n    if(!s.includes(letter))  return 0;\\n    \\n    for(let l of s){\\n        if(l==letter)   count +=1;\\n    }\\n    \\n    let percent=eval(count / s.length)*100;\\n    let result = Math.floor(percent);\\n    return result;\\n};\\n\\n```",
                "solutionTags": [],
                "code": "```\\n\\nvar percentageLetter = function(s, letter) {\\n    let count=0;\\n    \\n    if(!s.includes(letter))  return 0;\\n    \\n    for(let l of s){\\n        if(l==letter)   count +=1;\\n    }\\n    \\n    let percent=eval(count / s.length)*100;\\n    let result = Math.floor(percent);\\n    return result;\\n};\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2195486,
                "title": "javascript-solution-with-indexof",
                "content": "```\\nvar percentageLetter = function(s, letter) {\\n    \\n    let pos = s.indexOf(letter);\\n    let count = 0;\\n    \\n    while(pos != -1) {\\n        count++;\\n        pos = s.indexOf(letter, pos+1);\\n    }\\n    \\n    if(count != 0) {\\n        return Math.floor((count/s.length)*100);\\n    } \\n\\t\\n    return 0;    \\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar percentageLetter = function(s, letter) {\\n    \\n    let pos = s.indexOf(letter);\\n    let count = 0;\\n    \\n    while(pos != -1) {\\n        count++;\\n        pos = s.indexOf(letter, pos+1);\\n    }\\n    \\n    if(count != 0) {\\n        return Math.floor((count/s.length)*100);\\n    } \\n\\t\\n    return 0;    \\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2175333,
                "title": "simple-javascript-solution-using-for-loop",
                "content": "\\n```\\nvar percentageLetter = function(s, letter) {\\n    let count = 0;\\n    for(let i=0; i<s.length; i++){\\n        if(s.charAt(i) === letter) count++;\\n    }\\n    \\n    return Math.floor((count*100)/ s.length);\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar percentageLetter = function(s, letter) {\\n    let count = 0;\\n    for(let i=0; i<s.length; i++){\\n        if(s.charAt(i) === letter) count++;\\n    }\\n    \\n    return Math.floor((count*100)/ s.length);\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2171522,
                "title": "java-very-easy-solution",
                "content": "```\\nclass Solution {\\n    public int percentageLetter(String s, char letter) {\\n        int n=s.length();\\n        int count=0;\\n        for(int i=0;i<s.length();i++)\\n        {\\n            if(s.charAt(i)==letter)\\n            {\\n                count++;\\n            }\\n        }\\n        int ans=(count*100)/n;\\n        return ans;\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "String"
                ],
                "code": "```\\nclass Solution {\\n    public int percentageLetter(String s, char letter) {\\n        int n=s.length();\\n        int count=0;\\n        for(int i=0;i<s.length();i++)\\n        {\\n            if(s.charAt(i)==letter)\\n            {\\n                count++;\\n            }\\n        }\\n        int ans=(count*100)/n;\\n        return ans;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2094816,
                "title": "simple-python-solution",
                "content": "```python\\nclass Solution:\\n    def percentageLetter(self, s: str, letter: str) -> int:\\n        if letter not in s:\\n            return 0\\n        counter = collections.Counter(s)\\n        return 100 * counter.get(letter, 0) // counter.total()\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```python\\nclass Solution:\\n    def percentageLetter(self, s: str, letter: str) -> int:\\n        if letter not in s:\\n            return 0\\n        counter = collections.Counter(s)\\n        return 100 * counter.get(letter, 0) // counter.total()\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2082890,
                "title": "simple-and-faster-c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int percentageLetter(string s, char letter) {\\n       int count=0;\\n       for(auto i=0;i<s.size();++i){\\n           if(s[i]==letter){\\n               count++;\\n           }\\n       }\\n        return (count*100)/s.size();\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int percentageLetter(string s, char letter) {\\n       int count=0;\\n       for(auto i=0;i<s.size();++i){\\n           if(s[i]==letter){\\n               count++;\\n           }\\n       }\\n        return (count*100)/s.size();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2077360,
                "title": "one-liner",
                "content": "```\\nclass Solution {\\n    public int percentageLetter(String s, char letter) {\\n         return (int) s.chars().filter(ch -> ch == letter).count() * 100 / s.length();\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int percentageLetter(String s, char letter) {\\n         return (int) s.chars().filter(ch -> ch == letter).count() * 100 / s.length();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2076805,
                "title": "one-liner-solution-in-python",
                "content": "```\\nimport math\\nclass Solution:\\n    def percentageLetter(self, s: str, letter: str) -> int:\\n        return math.floor(s.count(letter)/len(s)*100)\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nimport math\\nclass Solution:\\n    def percentageLetter(self, s: str, letter: str) -> int:\\n        return math.floor(s.count(letter)/len(s)*100)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2076107,
                "title": "faster-than-100-c-submission-solution-easy-to-understand",
                "content": "```\\nclass Solution {\\npublic:\\n    int percentageLetter(string s, char letter) {\\n        map<char,int> map;\\n        for (auto x:s){\\n            map[x]++;\\n        }\\n        return (map[letter]*100/s.size());\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int percentageLetter(string s, char letter) {\\n        map<char,int> map;\\n        for (auto x:s){\\n            map[x]++;\\n        }\\n        return (map[letter]*100/s.size());\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2074565,
                "title": "c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int percentageLetter(string s, char l) {\\n        \\n        int n=s.size();\\n        int c=0;\\n        for(int i=0;i<n;i++){\\n            if(s[i]==l)\\n                c++;\\n        }\\n        return c*100/n;\\n    }\\n};\\n```",
                "solutionTags": [
                    "String"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int percentageLetter(string s, char l) {\\n        \\n        int n=s.size();\\n        int c=0;\\n        for(int i=0;i<n;i++){\\n            if(s[i]==l)\\n                c++;\\n        }\\n        return c*100/n;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2074082,
                "title": "javascript-faster-than-96-06-with-comments",
                "content": "```\\nvar percentageLetter = function(s, letter) {\\n    let includedCount = 0;\\n    if (!letter.includes(s)) return 0; // check if letter does not include s at all\\n    for (let l of s) {\\n        if (l == letter) includedCount+=1; // check if \\'l\\' is the same as letter if so, add 1 to \\'includedCount\\'\\n    }\\n    let result = eval(includedCount / s.length * 100).toString() // evaluate an equation and stringify the result\\n    if (result.includes(\".\")) result = parseInt(result.split(\".\")[0]) // remove the decimal\\n    return result;\\n};\\n```\\n![image](https://assets.leetcode.com/users/images/2a1a8d35-3675-42f7-9853-610ae04d3315_1653521913.7664704.png)\\n",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar percentageLetter = function(s, letter) {\\n    let includedCount = 0;\\n    if (!letter.includes(s)) return 0; // check if letter does not include s at all\\n    for (let l of s) {\\n        if (l == letter) includedCount+=1; // check if \\'l\\' is the same as letter if so, add 1 to \\'includedCount\\'\\n    }\\n    let result = eval(includedCount / s.length * 100).toString() // evaluate an equation and stringify the result\\n    if (result.includes(\".\")) result = parseInt(result.split(\".\")[0]) // remove the decimal\\n    return result;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2071427,
                "title": "0-ms-100-faster-c-very-easy",
                "content": "\\tclass Solution {\\n\\tpublic:\\n\\t\\tint percentageLetter(string s, char letter) {\\n\\t\\t\\tint n = s.size();\\n\\t\\t\\tint c=0;\\n\\t\\t\\tfor(auto i:s){\\n\\t\\t\\t\\tif(i==letter)\\n\\t\\t\\t\\t\\tc++;\\n\\t\\t\\t}\\n\\t\\t\\treturn c*100/n;   \\n\\t\\t}\\n\\t};\\n\\n\\tfeel free to ask your doubts :)\\n\\tand pls upvote if it was helpful :)",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution {\\n\\tpublic:\\n\\t\\tint percentageLetter(string s, char letter) {\\n\\t\\t\\tint n = s.size();\\n\\t\\t\\tint c=0;\\n\\t\\t\\tfor(auto i:s){\\n\\t\\t\\t\\tif(i==letter)\\n\\t\\t\\t\\t\\tc++;\\n\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 2065181,
                "title": "go-golang-solution",
                "content": "```go\\nfunc percentageLetter(s string, letter byte) int {\\n    n, c := len(s), 0\\n    for i := 0; i < n; i++ { if s[i] == letter { c++ } }\\n    ans := float64(c) / float64(n)\\n    return int(ans * 100)\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```go\\nfunc percentageLetter(s string, letter byte) int {\\n    n, c := len(s), 0\\n    for i := 0; i < n; i++ { if s[i] == letter { c++ } }\\n    ans := float64(c) / float64(n)\\n    return int(ans * 100)\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2065089,
                "title": "javascript-easy-solution-simple-fast",
                "content": "1. **get the count of how many times letter is included in s**\\n1. **evaluate a formula using the function, \\'eval()\\'**\\n1. **check if result is an decimal, if so, get the whole number**\\n```\\nvar percentageLetter = function(s, letter) {\\n    let includedCount = 0;\\n    if (!letter.includes(s)) return 0;\\n    for (let l of s) {\\n        if (l == letter) includedCount+=1;\\n    }\\n    let result = eval(includedCount / s.length * 100).toString()\\n    if (result.includes(\".\")) result = parseInt(result.split(\".\")[0])\\n    return result;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar percentageLetter = function(s, letter) {\\n    let includedCount = 0;\\n    if (!letter.includes(s)) return 0;\\n    for (let l of s) {\\n        if (l == letter) includedCount+=1;\\n    }\\n    let result = eval(includedCount / s.length * 100).toString()\\n    if (result.includes(\".\")) result = parseInt(result.split(\".\")[0])\\n    return result;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2064166,
                "title": "easy-math-solution-in-python",
                "content": "...\\n\\nclass Solution:\\n    def percentageLetter(self, s: str, letter: str) -> int:\\n        c=0\\n        y=len(s)\\n        for i in s:\\n            if i==letter:\\n                c+=1       \\n        return int((c/y)*100)\\n\\t\\t\\n\\t\\t...",
                "solutionTags": [
                    "Python"
                ],
                "code": "...\\n\\nclass Solution:\\n    def percentageLetter(self, s: str, letter: str) -> int:\\n        c=0\\n        y=len(s)\\n        for i in s:\\n            if i==letter:\\n                c+=1       \\n        return int((c/y)*100)\\n\\t\\t\\n\\t\\t...",
                "codeTag": "Java"
            },
            {
                "id": 2063877,
                "title": "java-easy-solution-o-n",
                "content": "**1)** *First count the frequency of letter in string*\\n**2)** *Then calculate percentage*\\n**Time:** O(n)\\n**Space:** O(1)\\n```\\npublic int percentageLetter(String s, char letter) {\\n        int ans = 0;\\n        int count = 0;\\n        for(int i = 0; i < s.length(); i++){\\n            if(s.charAt(i) == letter){\\n                count += 1;\\n            }\\n        }\\n        ans = (count * 100)/ s.length();\\n        return  ans;\\n    }\\n```\\n",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\npublic int percentageLetter(String s, char letter) {\\n        int ans = 0;\\n        int count = 0;\\n        for(int i = 0; i < s.length(); i++){\\n            if(s.charAt(i) == letter){\\n                count += 1;\\n            }\\n        }\\n        ans = (count * 100)/ s.length();\\n        return  ans;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2063504,
                "title": "are-you-serious-is-this-a-problem",
                "content": "```\\nclass Solution {\\npublic:\\n    int percentageLetter(string s, char letter) {\\n        int l = s.length(), c=0;\\n        for(auto& i : s){\\n            if(i==letter) c++;\\n        }\\n        return 100*c/l;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int percentageLetter(string s, char letter) {\\n        int l = s.length(), c=0;\\n        for(auto& i : s){\\n            if(i==letter) c++;\\n        }\\n        return 100*c/l;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2063138,
                "title": "c-beginner-friendly-faster-than-100",
                "content": "please upvote if you like it\\n```\\nclass Solution {\\npublic:\\n    int percentageLetter(string s, char letter) {\\n       int count=0;\\n       for(int i=0;i<s.length();i++){\\n          if(s[i]==letter){\\n              count++;\\n          }\\n       }\\n        return (count*100)/s.length();\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    int percentageLetter(string s, char letter) {\\n       int count=0;\\n       for(int i=0;i<s.length();i++){\\n          if(s[i]==letter){\\n              count++;\\n          }",
                "codeTag": "Java"
            },
            {
                "id": 2063117,
                "title": "c-0ms-runtime-beats-100",
                "content": "```\\nclass Solution {\\npublic:\\n    int percentageLetter(string s, char letter) {\\n       int count=0;\\n        for(auto x:s){\\n            if (x==letter) count++;\\n        }\\n         int res=((count*100)/s.length());\\n        return res;\\n    }\\n};\\n```\\npls upvote if u like\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int percentageLetter(string s, char letter) {\\n       int count=0;\\n        for(auto x:s){\\n            if (x==letter) count++;\\n        }\\n         int res=((count*100)/s.length());\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2062998,
                "title": "easy-c-solution",
                "content": "\\n    int percentageLetter(string s, char letter) {\\n        int count = 0;\\n        for(auto x:s){\\n            if(x == letter)count++;\\n        }\\n        return (100*count)/s.length();\\n    }",
                "solutionTags": [
                    "C"
                ],
                "code": "\\n    int percentageLetter(string s, char letter) {\\n        int count = 0;\\n        for(auto x:s){\\n            if(x == letter)count++;\\n        }\\n        return (100*count)/s.length();\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 2062950,
                "title": "c-linq-one-line",
                "content": "```\\npublic int PercentageLetter(string s, char letter) \\n\\t=> s.Count(c => c == letter) * 100 / s.Length;\\n```",
                "solutionTags": [],
                "code": "```\\npublic int PercentageLetter(string s, char letter) \\n\\t=> s.Count(c => c == letter) * 100 / s.Length;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2062939,
                "title": "python3-three-solutions",
                "content": "```\\nclass Solution:\\n    def percentageLetter(self, s: str, letter: str) -> int:\\n        return math.floor((s.count(letter)/len(s)*100))\\n```\\n\\n```\\nclass Solution:\\n    def percentageLetter(self, s: str, letter: str) -> int:\\n        c=0\\n        for i in range(len(s)):\\n            if letter== s[i]:\\n                c+=1\\n        return math.floor(c/len(s)*100)\\n```\\n```\\nclass Solution:\\n    def percentageLetter(self, s: str, letter: str) -> int:\\n\\t\\treturn ((s.count(letter)*100)//len(s))\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def percentageLetter(self, s: str, letter: str) -> int:\\n        return math.floor((s.count(letter)/len(s)*100))\\n```\n```\\nclass Solution:\\n    def percentageLetter(self, s: str, letter: str) -> int:\\n        c=0\\n        for i in range(len(s)):\\n            if letter== s[i]:\\n                c+=1\\n        return math.floor(c/len(s)*100)\\n```\n```\\nclass Solution:\\n    def percentageLetter(self, s: str, letter: str) -> int:\\n\\t\\treturn ((s.count(letter)*100)//len(s))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2062821,
                "title": "c-easy-solution",
                "content": "\\n\\n    class Solution {\\n    public:\\n    int percentageLetter(string s, char letter) {\\n        int d=0;\\n        int n=s.length();\\n        for(int i=0;i<n;i++){\\n            if(s[i]==letter){\\n                d++;\\n            }\\n        }\\n        float l=(d*100)/n;\\n        //cout<<l<<endl;\\n        return l;\\n       }\\n    };",
                "solutionTags": [
                    "C",
                    "String"
                ],
                "code": "class Solution {\\n    public:\\n    int percentageLetter(string s, char letter) {\\n        int d=0;\\n        int n=s.length();\\n        for(int i=0;i<n;i++){\\n            if(s[i]==letter){\\n                d++;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2062678,
                "title": "faster-easy-to-understand-c-code",
                "content": "* ***Time Complexity : O(N)***\\n\\n* ***Space Complexity : O(1)***\\n\\n```\\nclass Solution {\\npublic:\\n    int percentageLetter(string str, char letter) {\\n        \\n        int n = str.size();\\n        \\n        int count = 0;\\n        \\n        for(int i = 0; i < n; i++)\\n        {\\n            if(str[i] == letter)\\n            {\\n                count++;\\n            }\\n        }\\n        \\n        return (count * 100) / n; \\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Math"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int percentageLetter(string str, char letter) {\\n        \\n        int n = str.size();\\n        \\n        int count = 0;\\n        \\n        for(int i = 0; i < n; i++)\\n        {\\n            if(str[i] == letter)\\n            {\\n                count++;\\n            }\\n        }\\n        \\n        return (count * 100) / n; \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2062495,
                "title": "100-faster-o-n-simple-formula-based",
                "content": "### Simple Percentage Calculator:\\n\\nI multiplied the count with 100 in advance because otherwise when we do count / length of string it gives an answer in 0.x which gets converted to 0.\\n\\n```\\nclass Solution {\\n    public int percentageLetter(String s, char letter) {\\n        int c = 0;\\n        int n = s.length();\\n        for (int i=0; i<n; i++){\\n            if (s.charAt(i) == letter)\\n                c++;\\n        }\\n        int ans = 100 * c / n;\\n        return n;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int percentageLetter(String s, char letter) {\\n        int c = 0;\\n        int n = s.length();\\n        for (int i=0; i<n; i++){\\n            if (s.charAt(i) == letter)\\n                c++;\\n        }\\n        int ans = 100 * c / n;\\n        return n;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2062338,
                "title": "simple-approach",
                "content": "```\\nint percentageLetter(string s, char letter) {\\n        int n=s.size(),c=0;\\n    for(int i=0;i<n;i++)\\n    {\\n        if(s[i]==letter) c++;\\n    }\\n        return (100*c)/n;\\n    }\\n```",
                "solutionTags": [
                    "C",
                    "String"
                ],
                "code": "```\\nint percentageLetter(string s, char letter) {\\n        int n=s.size(),c=0;\\n    for(int i=0;i<n;i++)\\n    {\\n        if(s[i]==letter) c++;\\n    }\\n        return (100*c)/n;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2062280,
                "title": "ruby-one-line-solution",
                "content": "```\\n# @param {String} s\\n# @param {Character} letter\\n# @return {Integer}\\ndef percentage_letter(s, letter)\\n    s.count(letter) * 100 / s.length\\nend\\n",
                "solutionTags": [],
                "code": "```\\n# @param {String} s\\n# @param {Character} letter\\n# @return {Integer}\\ndef percentage_letter(s, letter)\\n    s.count(letter) * 100 / s.length\\nend\\n",
                "codeTag": "Python3"
            },
            {
                "id": 2062094,
                "title": "cpp-easy-o-n",
                "content": "```\\nclass Solution {\\npublic:\\n    int percentageLetter(string s, char letter) {\\n        int cnt=0,n=s.length();\\n        for( char c:s)cnt+=c==letter;\\n        return cnt*100/(n*1.0);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int percentageLetter(string s, char letter) {\\n        int cnt=0,n=s.length();\\n        for( char c:s)cnt+=c==letter;\\n        return cnt*100/(n*1.0);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2061989,
                "title": "simple-o-n-solution",
                "content": "\\'\\'\\'\\nclass Solution {\\npublic:\\n    int percentageLetter(string s, char l) \\n    {\\n        int n=s.size();\\n        unordered_map<char,int>m;\\n        for(int i=0;i<n;i++)\\n        {\\n         m[s[i]]++;//counting the frequency\\n        }\\n        double p=((1.0*m[l])/n);//frequency/total number of characters\\n        int t=p*1ll*100;\\n        return t;\\n    }\\n};\\n\\'\\'\\'\\nTime Complexity->O(N)\\nSpace Complexity->O(N)",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    int percentageLetter(string s, char l) \\n    {\\n        int n=s.size();\\n        unordered_map<char,int>m;\\n        for(int i=0;i<n;i++)\\n        {\\n         m[s[i]]++;//counting the frequency\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2061984,
                "title": "c-easy-3-line-code",
                "content": "```\\nclass Solution {\\npublic:\\n    int percentageLetter(string s, char letter) {\\n        int count=0;\\n        for(auto ch:s) if(ch==letter) count++;\\n        return (count*100)/s.size();\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "String"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int percentageLetter(string s, char letter) {\\n        int count=0;\\n        for(auto ch:s) if(ch==letter) count++;\\n        return (count*100)/s.size();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2061954,
                "title": "python-easy-to-understand-solution",
                "content": "```\\nclass Solution:\\n    def percentageLetter(self, s: str, letter: str) -> int:\\n        if letter not in s:\\n            return 0\\n        \\n        leng = len(s)\\n        ctr = 0\\n        for char in s:\\n            if char == letter:\\n                ctr += 1\\n                \\n        return math.floor((ctr / leng) * 100)\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def percentageLetter(self, s: str, letter: str) -> int:\\n        if letter not in s:\\n            return 0\\n        \\n        leng = len(s)\\n        ctr = 0\\n        for char in s:\\n            if char == letter:\\n                ctr += 1\\n                \\n        return math.floor((ctr / leng) * 100)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2061915,
                "title": "java-ac-solution",
                "content": "```\\nclass Solution {\\n    public int percentageLetter(String s, char letter) {\\n        int len = s.length();\\n        int freq = 0;\\n        for(int i = 0;i<len;i++){\\n            char a = s.charAt(i);\\n            if(a == letter)\\n                freq++;\\n        }\\n        int ans = (freq * 100)/len;\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int percentageLetter(String s, char letter) {\\n        int len = s.length();\\n        int freq = 0;\\n        for(int i = 0;i<len;i++){\\n            char a = s.charAt(i);\\n            if(a == letter)\\n                freq++;\\n        }\\n        int ans = (freq * 100)/len;\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2061914,
                "title": "python-easy-solution",
                "content": "```\\nclass Solution:\\n    def percentageLetter(self, s: str, letter: str) -> int:\\n        cnt = 0\\n        for char in s:\\n            if char == letter:\\n                cnt += 1\\n        res = math.floor((cnt / len(s)) * 100)\\n        return res\\n```\\n\\t\\t\\n**Time Complexity:** O(n)\\n**Space Complexity:** O(1)",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def percentageLetter(self, s: str, letter: str) -> int:\\n        cnt = 0\\n        for char in s:\\n            if char == letter:\\n                cnt += 1\\n        res = math.floor((cnt / len(s)) * 100)\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2061879,
                "title": "o-n",
                "content": "class Solution {\\npublic:\\n    int percentageLetter(string s, char letter) {\\n        map<char,int>m;\\n        int n=s.size(),c;\\n        for(int i=0;i<n;++i){\\n            m[s[i]]++;\\n        }\\n        \\n        for(auto i:m){\\n            if(i.first==letter){\\n                c=i.second;\\n                break;\\n            }else{\\n                c=0;\\n            }\\n        }\\n      \\n        \\n        cout<<c<<\" \"<<n<<endl;\\n        \\n        return (c*100)/n;\\n    }\\n};",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n    int percentageLetter(string s, char letter) {\\n        map<char,int>m;\\n        int n=s.size(),c;\\n        for(int i=0;i<n;++i){\\n            m[s[i]]++;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2061858,
                "title": "c-easy-solution-floor",
                "content": "```\\nclass Solution {\\npublic:\\n    int percentageLetter(string s, char letter) {\\n        int n = s.length();\\n        map<char,int>m;\\n        for(auto x : s)\\n        {\\n            m[x]++;\\n        }\\n        int percentage;\\n        int count = 0;\\n        if(m.find(letter)!=m.end())\\n            count = m[letter];\\n        percentage = floor(((count*1.0)/n)*100);\\n        return percentage;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int percentageLetter(string s, char letter) {\\n        int n = s.length();\\n        map<char,int>m;\\n        for(auto x : s)\\n        {\\n            m[x]++;\\n        }\\n        int percentage;\\n        int count = 0;\\n        if(m.find(letter)!=m.end())\\n            count = m[letter];\\n        percentage = floor(((count*1.0)/n)*100);\\n        return percentage;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2061848,
                "title": "most-easy-approach-simple-maths",
                "content": "```\\nclass Solution {\\npublic:\\n    int percentageLetter(string s, char letter) {\\n        unordered_map<char,int>mpp;\\n        int per=0;\\n           \\n        for(int i=0;i<s.size();i++)\\n        {\\n           mpp[s[i]]++;\\n        }\\n        for(auto it:mpp)\\n        {\\n             int count=0;\\n            if(letter==it.first)\\n            {\\n                count=it.second;\\n                  per=floor(((count*1.0)/s.size())*100);\\n            }\\n            \\n           \\n        }\\n       return per;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int percentageLetter(string s, char letter) {\\n        unordered_map<char,int>mpp;\\n        int per=0;\\n           \\n        for(int i=0;i<s.size();i++)\\n        {\\n           mpp[s[i]]++;\\n        }\\n        for(auto it:mpp)\\n        {\\n             int count=0;\\n            if(letter==it.first)\\n            {\\n                count=it.second;\\n                  per=floor(((count*1.0)/s.size())*100);\\n            }\\n            \\n           \\n        }\\n       return per;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2061825,
                "title": "java-easy-solution-o-n-approach",
                "content": "```\\nclass Solution {\\n    public int percentageLetter(String s, char letter) {\\n        int len=s.length();\\n        int cnt=0;\\n        for(int i=0;i<len;i++){\\n            if(s.charAt(i)==letter) cnt++;\\n        }\\n        \\n        int per=(cnt*100/len);\\n        return per;\\n    }\\n}\\n```\\n",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int percentageLetter(String s, char letter) {\\n        int len=s.length();\\n        int cnt=0;\\n        for(int i=0;i<len;i++){\\n            if(s.charAt(i)==letter) cnt++;\\n        }\\n        \\n        int per=(cnt*100/len);\\n        return per;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4095373,
                "title": "make-java-easy-and-simple-0ms-beats-97-18",
                "content": "\\n\\n# Complexity\\n- Time complexity: O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int percentageLetter(String s, char letter) {\\n        int count = 0;\\n        for(int i = 0; i < s.length(); i++){\\n            if(s.charAt(i) == letter)\\n                count++;\\n        }\\n        return (count)*100/s.length();\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int percentageLetter(String s, char letter) {\\n        int count = 0;\\n        for(int i = 0; i < s.length(); i++){\\n            if(s.charAt(i) == letter)\\n                count++;\\n        }\\n        return (count)*100/s.length();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4084196,
                "title": "percentage-of-letter-in-string",
                "content": "# Approach\\nI made this wayyyy more complicated than it needed to be. \\n\\nFind the number of times the letter occurs in the string by splitting the string into an array and then filtering the array for the letter. \\n\\nReturn this value as a percentage by dividing it by string length * 100. \\n\\n/**\\n * @param {string} s\\n * @param {character} letter\\n * @return {number}\\n */\\n\\nvar percentageLetter = function(s, letter) {\\n    const value = s.split(\\'\\').filter((x) => x === letter).length;\\n    return Math.floor((value / s.length) * 100)\\n};\\n\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "# Approach\\nI made this wayyyy more complicated than it needed to be. \\n\\nFind the number of times the letter occurs in the string by splitting the string into an array and then filtering the array for the letter. \\n\\nReturn this value as a percentage by dividing it by string length * 100. \\n\\n/**\\n * @param {string} s\\n * @param {character} letter\\n * @return {number}\\n */\\n\\nvar percentageLetter = function(s, letter) {\\n    const value = s.split(\\'\\').filter((x) => x === letter).length;\\n    return Math.floor((value / s.length) * 100)\\n};\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4079432,
                "title": "discuss",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n$$O(n)$$\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n$$O(1)$$\\n\\n# Code\\n```\\nclass Solution {\\n    public int percentageLetter(String s, char letter) {\\n        return 100 * (int) s.chars().filter(c -> c == letter).count() / s.length();\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int percentageLetter(String s, char letter) {\\n        return 100 * (int) s.chars().filter(c -> c == letter).count() / s.length();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4079151,
                "title": "direct-approach-using-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\npublic class Solution {\\n    public int PercentageLetter(string s, char letter) {\\n        int count = 0;\\n        for(int i =0;i<s.Length;i++){\\n            if(s[i]==letter){\\n                count++;\\n            }\\n        }\\n        Console.WriteLine(count);\\n        int ans = (count*100/s.Length);\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#",
                    "String"
                ],
                "code": "```\\npublic class Solution {\\n    public int PercentageLetter(string s, char letter) {\\n        int count = 0;\\n        for(int i =0;i<s.Length;i++){\\n            if(s[i]==letter){\\n                count++;\\n            }\\n        }\\n        Console.WriteLine(count);\\n        int ans = (count*100/s.Length);\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4078505,
                "title": "one-line-solution",
                "content": "```\\nclass Solution:\\n    def percentageLetter(self, s: str, letter: str) -> int:\\n        return s.count(letter)*100//len(s)\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def percentageLetter(self, s: str, letter: str) -> int:\\n        return s.count(letter)*100//len(s)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4077641,
                "title": "beats-100-in-run-time-and-95-in-space-complexity",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int percentageLetter(String s, char letter) {\\n        char [] array = s.toCharArray();\\n        double frequency=0;\\n        for(int i=0;i<array.length;i++){\\n            if(array[i]==letter){\\n                frequency++;\\n            }\\n        }\\n        return (int)((frequency/(double)array.length)*100);\\n    }\\n}\\n```\\n\\n![Screenshot 2023-09-22 at 7.24.53\\u202FPM.png](https://assets.leetcode.com/users/images/9aa7b34c-fd10-4fe9-8eea-125309d60980_1695403773.6144347.png)\\n",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int percentageLetter(String s, char letter) {\\n        char [] array = s.toCharArray();\\n        double frequency=0;\\n        for(int i=0;i<array.length;i++){\\n            if(array[i]==letter){\\n                frequency++;\\n            }\\n        }\\n        return (int)((frequency/(double)array.length)*100);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4077064,
                "title": "you-know-how-to-solve-this-problem",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int percentageLetter(String s, char letter) {\\n        int c=0;\\n        for(int i=0; i<s.length(); i++){\\n            if(s.charAt(i)==letter){\\n                c++;\\n            }\\n        }\\n        return (100*c)/s.length();\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int percentageLetter(String s, char letter) {\\n        int c=0;\\n        for(int i=0; i<s.length(); i++){\\n            if(s.charAt(i)==letter){\\n                c++;\\n            }\\n        }\\n        return (100*c)/s.length();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4076168,
                "title": "simple-java-solution-100-beats-line-by-line-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int percentageLetter(String s, char letter) {\\n        // variable to count number of \\'letter\\' in the string.\\n        int count =0;\\n        // Itearate through the string.\\n        for(char c: s.toCharArray()){\\n            // if character match with the \\'letter\\' then increse the count.\\n            if(c == letter) count++;\\n        }\\n        // return the result multiply 100 with count then devide by the length of the string.\\n        return (count*100/s.length());\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "String"
                ],
                "code": "```\\nclass Solution {\\n    public int percentageLetter(String s, char letter) {\\n        // variable to count number of \\'letter\\' in the string.\\n        int count =0;\\n        // Itearate through the string.\\n        for(char c: s.toCharArray()){\\n            // if character match with the \\'letter\\' then increse the count.\\n            if(c == letter) count++;\\n        }\\n        // return the result multiply 100 with count then devide by the length of the string.\\n        return (count*100/s.length());\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4072357,
                "title": "very-easy-question",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {string} s\\n * @param {character} letter\\n * @return {number}\\n */\\nvar percentageLetter = function(s, letter) {\\n    \\n    let count = 0;\\n    let n = s.length;\\n\\n    for(let i of s){\\n        if(letter === i){\\n            count++\\n        }\\n    }\\n\\n   let percentage = Math.floor((count / n ) * 100);\\n\\n   return percentage\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "String"
                ],
                "code": "```\\n/**\\n * @param {string} s\\n * @param {character} letter\\n * @return {number}\\n */\\nvar percentageLetter = function(s, letter) {\\n    \\n    let count = 0;\\n    let n = s.length;\\n\\n    for(let i of s){\\n        if(letter === i){\\n            count++\\n        }\\n    }\\n\\n   let percentage = Math.floor((count / n ) * 100);\\n\\n   return percentage\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4071001,
                "title": "1-line-c-solution",
                "content": "# Complexity\\n- Time complexity: $$O(n)$$\\n- Space complexity: $$O(1)$$\\n\\n# Code\\n```\\npublic class Solution\\n{\\n    public int PercentageLetter(string s, char letter)\\n    {\\n        return s.Count(c => c == letter) * 100 / s.Length;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution\\n{\\n    public int PercentageLetter(string s, char letter)\\n    {\\n        return s.Count(c => c == letter) * 100 / s.Length;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4069713,
                "title": "beats-100-of-solutions-beginner-friendly-using-hashmaps",
                "content": "\\n# Complexity\\n- Time complexity: 0(n)\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int percentageLetter(string s, char letter) {\\n\\n        int n=s.size();\\n        int target= letter;\\n        int perc;\\n        \\n        int H[26]={0};\\n\\n        for(int i=0; i<n ; i++){\\n\\n            H[s[i]-97]+=1;\\n        }\\n\\n        perc=(H[target-97]*100)/n;\\n\\n        return perc;\\n\\n\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int percentageLetter(string s, char letter) {\\n\\n        int n=s.size();\\n        int target= letter;\\n        int perc;\\n        \\n        int H[26]={0};\\n\\n        for(int i=0; i<n ; i++){\\n\\n            H[s[i]-97]+=1;\\n        }\\n\\n        perc=(H[target-97]*100)/n;\\n\\n        return perc;\\n\\n\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4068583,
                "title": "beats-100-very-easy-java-salution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int percentageLetter(String s, char letter) {\\n        int n = s.length();\\n        int count = 0;\\n        for(int i = 0; i < n; i++){\\n            char ch = s.charAt(i);\\n            if(ch == letter)\\n            count++;\\n        }\\n        return 100*count/n;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int percentageLetter(String s, char letter) {\\n        int n = s.length();\\n        int count = 0;\\n        for(int i = 0; i < n; i++){\\n            char ch = s.charAt(i);\\n            if(ch == letter)\\n            count++;\\n        }\\n        return 100*count/n;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4049145,
                "title": "one-line-easy-js-solution",
                "content": "# Code\\n```\\n/**\\n * @param {string} s\\n * @param {character} letter\\n * @return {number}\\n */\\nvar percentageLetter = function(s, letter) {\\n    return Math.floor(s.split(\\'\\').reduce((acc, v) => acc += v == letter ? 1 : 0, 0) * 100 / s.length)\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {string} s\\n * @param {character} letter\\n * @return {number}\\n */\\nvar percentageLetter = function(s, letter) {\\n    return Math.floor(s.split(\\'\\').reduce((acc, v) => acc += v == letter ? 1 : 0, 0) * 100 / s.length)\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4048001,
                "title": "fast-java-solution-runtime-beginners-friendly",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\n    public int percentageLetter(String s, char letter) {\\n        int count = 0;\\n        for (int i = 0; i < s.length(); i++) {\\n            if (s.charAt(i) == letter){\\n                count++;\\n            }\\n        }\\n        double n = (double) count / s.length();\\n        return (int) (n * 100);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int percentageLetter(String s, char letter) {\\n        int count = 0;\\n        for (int i = 0; i < s.length(); i++) {\\n            if (s.charAt(i) == letter){\\n                count++;\\n            }\\n        }\\n        double n = (double) count / s.length();\\n        return (int) (n * 100);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4039087,
                "title": "c-easy-worst-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int percentageLetter(string s, char letter) {\\n        int count=0;\\n        for(int i=0;i<s.size();i++)\\n        {\\n          if(s[i]==letter)\\n          {\\n            count++;\\n          }\\n        }\\n        return (count*100)/s.size();\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "String"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int percentageLetter(string s, char letter) {\\n        int count=0;\\n        for(int i=0;i<s.size();i++)\\n        {\\n          if(s[i]==letter)\\n          {\\n            count++;\\n          }\\n        }\\n        return (count*100)/s.size();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4038599,
                "title": "2278-percentage-of-letter-in-string",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int percentageLetter(String s, char letter) {\\n        int c = 0;\\n        int n = s.length(); \\n        for (int i = 0; i < n; i++) {\\n            char ch = s.charAt(i); \\n            if (ch == letter) {\\n                c++;\\n            }\\n        }\\n\\n        if (c == 0) {\\n            return 0;\\n        } else {\\n            return (c * 100) / n;\\n        } \\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int percentageLetter(String s, char letter) {\\n        int c = 0;\\n        int n = s.length(); \\n        for (int i = 0; i < n; i++) {\\n            char ch = s.charAt(i); \\n            if (ch == letter) {\\n                c++;\\n            }\\n        }\\n\\n        if (c == 0) {\\n            return 0;\\n        } else {\\n            return (c * 100) / n;\\n        } \\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4033643,
                "title": "python-1-line-solution",
                "content": "# Code\\n```\\nclass Solution:\\n    def percentageLetter(self, s: str, letter: str) -> int:\\n        return int(s.count(letter)/len(s)*100)\\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def percentageLetter(self, s: str, letter: str) -> int:\\n        return int(s.count(letter)/len(s)*100)\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 4027498,
                "title": "best-sollution-in-java",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int percentageLetter(String s, char letter) {\\n        int x = 0;\\n        for(int i=0;i<s.length();i++){\\n            if(s.charAt(i)==letter){\\n                x++; \\n                \\n            }\\n        }\\n        x = x*100;\\n        int n = s.length();\\n        int y = x/n;\\n        return y;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int percentageLetter(String s, char letter) {\\n        int x = 0;\\n        for(int i=0;i<s.length();i++){\\n            if(s.charAt(i)==letter){\\n                x++; \\n                \\n            }\\n        }\\n        x = x*100;\\n        int n = s.length();\\n        int y = x/n;\\n        return y;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4022348,
                "title": "easy-to-understand-python3-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def percentageLetter(self, s: str, letter: str) -> int:\\n        s= list(s)\\n        return math.floor((s.count(letter)/len(s)) * 100)\\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def percentageLetter(self, s: str, letter: str) -> int:\\n        s= list(s)\\n        return math.floor((s.count(letter)/len(s)) * 100)\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 4021773,
                "title": "easiest-in-java",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int percentageLetter(String s, char letter) {int a=0;int per=0;\\n        for(int i=0;i<s.length();i++){\\n            if(s.charAt(i)==letter)a++;\\n           int b=s.length();\\n            per=(a*100)/b;\\n\\n        }\\n       // return(a/b)*100;\\n       return per;\\n        \\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int percentageLetter(String s, char letter) {int a=0;int per=0;\\n        for(int i=0;i<s.length();i++){\\n            if(s.charAt(i)==letter)a++;\\n           int b=s.length();\\n            per=(a*100)/b;\\n\\n        }\\n       // return(a/b)*100;\\n       return per;\\n        \\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4018958,
                "title": "hashmap-java-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int percentageLetter(String s, char l) {\\n        Map<Character,Integer>fmap=new HashMap<>();\\n        for(int i=0;i<s.length();i++){\\n                char a=s.charAt(i);\\n                if(fmap.containsKey(a)){\\n                    int f=fmap.get(a);\\n                    fmap.put(a,f+1);\\n                }\\n                else{\\n                    fmap.put(a,1);\\n                }\\n        }\\n        int v=0;\\n        \\n        if(fmap.containsKey(l)){\\n            v=fmap.get(l);\\n        }\\n        \\n        int ans=v*100/s.length();\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int percentageLetter(String s, char l) {\\n        Map<Character,Integer>fmap=new HashMap<>();\\n        for(int i=0;i<s.length();i++){\\n                char a=s.charAt(i);\\n                if(fmap.containsKey(a)){\\n                    int f=fmap.get(a);\\n                    fmap.put(a,f+1);\\n                }\\n                else{\\n                    fmap.put(a,1);\\n                }\\n        }\\n        int v=0;\\n        \\n        if(fmap.containsKey(l)){\\n            v=fmap.get(l);\\n        }\\n        \\n        int ans=v*100/s.length();\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4013820,
                "title": "best-100-in-time-0ms-beats-98-70-in-space",
                "content": "# Approach The formula is given in the description proceed step by step\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int percentageLetter(String s, char letter) {\\n        double count = 0;\\n        int len = s.length();\\n        for(char ch:s.toCharArray()){\\n            if(ch == letter) count++;\\n        }\\n        double output = count/len*100;\\n        return (int)output;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int percentageLetter(String s, char letter) {\\n        double count = 0;\\n        int len = s.length();\\n        for(char ch:s.toCharArray()){\\n            if(ch == letter) count++;\\n        }\\n        double output = count/len*100;\\n        return (int)output;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4012547,
                "title": "simple-java-program",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int percentageLetter(String str, char letter) {\\n        Scanner scan=new Scanner(System.in);\\n        //String str=scan.next();\\n        int n=str.length();\\n        int count=0;\\n        for(int i=0;i<n;i++ ){\\n            if(str.charAt(i)==letter)\\n            count ++;\\n        }\\n        int per=(count*100)/n;\\n        \\n        return per;\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int percentageLetter(String str, char letter) {\\n        Scanner scan=new Scanner(System.in);\\n        //String str=scan.next();\\n        int n=str.length();\\n        int count=0;\\n        for(int i=0;i<n;i++ ){\\n            if(str.charAt(i)==letter)\\n            count ++;\\n        }\\n        int per=(count*100)/n;\\n        \\n        return per;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4010136,
                "title": "easy-code-string-java",
                "content": "# Code\\n```\\nclass Solution {\\n    public int percentageLetter(String s, char letter) {\\n        int count = 0;\\n        int total = s.length();\\n        \\n        for (int i = 0; i < s.length(); i++) {\\n            char ch = s.charAt(i);\\n            if (ch == letter) {\\n                count++;\\n            }\\n        }\\n        \\n        // Calculate the percentage and round it down to the nearest whole percent\\n        int percentage = (count * 100) / total;\\n        \\n        return percentage;\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int percentageLetter(String s, char letter) {\\n        int count = 0;\\n        int total = s.length();\\n        \\n        for (int i = 0; i < s.length(); i++) {\\n            char ch = s.charAt(i);\\n            if (ch == letter) {\\n                count++;\\n            }\\n        }\\n        \\n        // Calculate the percentage and round it down to the nearest whole percent\\n        int percentage = (count * 100) / total;\\n        \\n        return percentage;\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4010129,
                "title": "1ms-easy-code-string",
                "content": "# Code\\n```\\nclass Solution {\\n    public int percentageLetter(String s, char letter) {\\n        int count = 0;\\n        int total = s.length();\\n        \\n        for (int i = 0; i < s.length(); i++) {\\n            char ch = s.charAt(i);\\n            if (ch == letter) {\\n                count++;\\n            }\\n        }\\n        \\n        // Calculate the percentage and round it down to the nearest whole percent\\n        int percentage = (count * 100) / total;\\n        \\n        return percentage;\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int percentageLetter(String s, char letter) {\\n        int count = 0;\\n        int total = s.length();\\n        \\n        for (int i = 0; i < s.length(); i++) {\\n            char ch = s.charAt(i);\\n            if (ch == letter) {\\n                count++;\\n            }\\n        }\\n        \\n        // Calculate the percentage and round it down to the nearest whole percent\\n        int percentage = (count * 100) / total;\\n        \\n        return percentage;\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4001187,
                "title": "beats-100",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int percentageLetter(string s, char letter) {\\n        int count=0;\\n        for (int i=0; i<s.size(); i++){\\n            if (s[i]==letter){\\n                count++;\\n            }\\n        }\\n        int n= double(count*100/s.size());\\n        return n;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int percentageLetter(string s, char letter) {\\n        int count=0;\\n        for (int i=0; i<s.size(); i++){\\n            if (s[i]==letter){\\n                count++;\\n            }\\n        }\\n        int n= double(count*100/s.size());\\n        return n;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4001018,
                "title": "easy-cpp-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int percentageLetter(string s, char letter) {\\n        int n = s.length();\\n        int count = 0;\\n        for(int i = 0; i < n; i++){\\n            if(s[i] == letter) count++;\\n        }\\n        double res = floor(((count * 100.0) / n)); // Convert count to a double\\n\\n        return static_cast<int>(res);\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int percentageLetter(string s, char letter) {\\n        int n = s.length();\\n        int count = 0;\\n        for(int i = 0; i < n; i++){\\n            if(s[i] == letter) count++;\\n        }\\n        double res = floor(((count * 100.0) / n)); // Convert count to a double\\n\\n        return static_cast<int>(res);\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3998064,
                "title": "using-javascript-beats-91-of-the-people-shortest-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {string} s\\n * @param {character} letter\\n * @return {number}\\n */\\nvar percentageLetter = function(s, letter) {\\n     let count = 0;\\n  let strLen = s.length;\\n  for (let i = 0; i < strLen; i++) {\\n    if (s[i] === letter) {\\n      count += 1;\\n    }\\n  }\\n  let percentage = Math.floor((count / strLen) * 100);\\n  return percentage;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {string} s\\n * @param {character} letter\\n * @return {number}\\n */\\nvar percentageLetter = function(s, letter) {\\n     let count = 0;\\n  let strLen = s.length;\\n  for (let i = 0; i < strLen; i++) {\\n    if (s[i] === letter) {\\n      count += 1;\\n    }\\n  }\\n  let percentage = Math.floor((count / strLen) * 100);\\n  return percentage;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3994272,
                "title": "c-sharp",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\npublic class Solution {\\n    public int PercentageLetter(string s, char letter) {\\n        int letterCount = 0;\\n        foreach (char c in s) {\\n            if (c == letter) {\\n                letterCount++;\\n            }\\n        }\\n        int percentage = (letterCount * 100) / s.Length;\\n        return percentage;\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution {\\n    public int PercentageLetter(string s, char letter) {\\n        int letterCount = 0;\\n        foreach (char c in s) {\\n            if (c == letter) {\\n                letterCount++;\\n            }\\n        }\\n        int percentage = (letterCount * 100) / s.Length;\\n        return percentage;\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3994192,
                "title": "easy-java-solution-beats-100-users",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int percentageLetter(String s, char letter) {\\n        int c=0;\\n        for(int i=0;i<s.length();i++){\\n            if(s.charAt(i)==letter)\\n                c++;\\n        }\\n        if(c>0)\\n            return c*100/s.length();\\n        return 0;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int percentageLetter(String s, char letter) {\\n        int c=0;\\n        for(int i=0;i<s.length();i++){\\n            if(s.charAt(i)==letter)\\n                c++;\\n        }\\n        if(c>0)\\n            return c*100/s.length();\\n        return 0;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3992744,
                "title": "easy-solution-in-java",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int percentageLetter(String s, char letter) {\\n        ArrayList<Character> arr=new ArrayList<Character>();\\n        for(int i=0;i<s.length();i++){\\n            if(s.charAt(i)==letter){\\n            arr.add(s.charAt(i));\\n            }\\n        }\\n\\n            int res=(arr.size()*100)/s.length();\\n            return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int percentageLetter(String s, char letter) {\\n        ArrayList<Character> arr=new ArrayList<Character>();\\n        for(int i=0;i<s.length();i++){\\n            if(s.charAt(i)==letter){\\n            arr.add(s.charAt(i));\\n            }\\n        }\\n\\n            int res=(arr.size()*100)/s.length();\\n            return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3974465,
                "title": "easy-cpp-solution-beats-100-in-runtime-naive-approach",
                "content": "![image.png](https://assets.leetcode.com/users/images/74448e58-f0dc-4e51-9a6a-08702222e981_1693284530.2475433.png)\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int percentageLetter(string s, char letter) {\\n        double cnt = 0;\\n\\n        for(auto i : s)\\n            if(i == letter) cnt++;\\n\\n        return int((cnt/double(s.length())) * 100);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int percentageLetter(string s, char letter) {\\n        double cnt = 0;\\n\\n        for(auto i : s)\\n            if(i == letter) cnt++;\\n\\n        return int((cnt/double(s.length())) * 100);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3973430,
                "title": "using-hashmap",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\n    public int percentageLetter(String s, char letter) {\\n       int n=s.length();\\n       char arr[]=s.toCharArray();\\n       HashMap<Character,Integer> map=new HashMap<>();\\n       for(char x:arr){\\n           map.put(x,map.getOrDefault(x,0)+1);\\n       } \\n       int per=0;\\n       char ch=letter;\\n       for(char x:arr){\\n           if(map.containsKey(ch)){\\n               int t=map.get(ch);\\n               per=(t*100)/n;\\n           }\\n       }\\n       return per;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int percentageLetter(String s, char letter) {\\n       int n=s.length();\\n       char arr[]=s.toCharArray();\\n       HashMap<Character,Integer> map=new HashMap<>();\\n       for(char x:arr){\\n           map.put(x,map.getOrDefault(x,0)+1);\\n       } \\n       int per=0;\\n       char ch=letter;\\n       for(char x:arr){\\n           if(map.containsKey(ch)){\\n               int t=map.get(ch);\\n               per=(t*100)/n;\\n           }\\n       }\\n       return per;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3965994,
                "title": "beats-easy-beginner-friendly-solution-simple-and-easy-java-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int percentageLetter(String s, char l) {\\n        int c=0;\\n        int n=s.length();\\n        for(int i=0;i<n;i++)\\n        {\\n            if(s.charAt(i)==l){\\n                c++;\\n            }\\n        }\\n        return (c*100/n);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int percentageLetter(String s, char l) {\\n        int c=0;\\n        int n=s.length();\\n        for(int i=0;i<n;i++)\\n        {\\n            if(s.charAt(i)==l){\\n                c++;\\n            }\\n        }\\n        return (c*100/n);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3944482,
                "title": "best-code-in-java",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int percentageLetter(String s, char letter) {\\n        int count=0;\\n        for(int i=0;i<s.length();i++) if(s.charAt(i) == letter) count++;\\n        return (count*100/s.length());\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int percentageLetter(String s, char letter) {\\n        int count=0;\\n        for(int i=0;i<s.length();i++) if(s.charAt(i) == letter) count++;\\n        return (count*100/s.length());\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3941765,
                "title": "easiest-python-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution(object):\\n    def percentageLetter(self, s, letter):\\n        \"\"\"\\n        :type s: str\\n        :type letter: str\\n        :rtype: int\\n        \"\"\"\\n        count = 0\\n        for i in range(len(s)):\\n            if s[i] == letter:\\n                count += 1\\n        return int((float(count)/float(len(s))) * 100)\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution(object):\\n    def percentageLetter(self, s, letter):\\n        \"\"\"\\n        :type s: str\\n        :type letter: str\\n        :rtype: int\\n        \"\"\"\\n        count = 0\\n        for i in range(len(s)):\\n            if s[i] == letter:\\n                count += 1\\n        return int((float(count)/float(len(s))) * 100)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3924042,
                "title": "percentage-of-a-letter-in-string-simple-easy-and-iterative-approach",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nFirstly Take a count variable cnt initilize with zero\\ntake one loop apply on question string that is \"S\" in these case\\nand check each character with second string if it found than increse the count value by 1\\nthe multiply the count with 100 and divide by total length of string \"S\"\\nand return the percentage\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\ntime compelexity is O(n)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\n    public int percentageLetter(String s, char letter) {\\n        int cnt =0;\\n        for(int i =0;i<s.length();i++)\\n        {\\n            if(letter==s.charAt(i))\\n            {\\n                cnt++;\\n            }\\n        }\\n        int per = (cnt*100)/s.length();\\n        return per;\\n\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int percentageLetter(String s, char letter) {\\n        int cnt =0;\\n        for(int i =0;i<s.length();i++)\\n        {\\n            if(letter==s.charAt(i))\\n            {\\n                cnt++;\\n            }\\n        }\\n        int per = (cnt*100)/s.length();\\n        return per;\\n\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3916800,
                "title": "100-in-one-liner",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(1)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1)\\n\\n# Code\\n```\\n#include<bits/stdc++.h>\\nclass Solution {\\npublic:\\n    int percentageLetter(string s, char letter) {\\n        return (count(begin(s),end(s),letter)*100)/s.size();\\n         \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n#include<bits/stdc++.h>\\nclass Solution {\\npublic:\\n    int percentageLetter(string s, char letter) {\\n        return (count(begin(s),end(s),letter)*100)/s.size();\\n         \\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3916505,
                "title": "c-100-counting",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n\\tint percentageLetter(string s, char letter) {\\n\\n\\t\\tint count = 0;\\n\\n\\t\\tint inputSize = s.size();\\n\\n\\t\\tfor (int i = 0; i < inputSize; ++i)\\n\\t\\t{\\n\\t\\t\\tif(s[i] == letter){\\n\\t\\t\\t\\tcount++;\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\treturn (count * 100) / inputSize;\\n\\n\\t}\\n};\\n\\n```",
                "solutionTags": [
                    "C++",
                    "String"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\tint percentageLetter(string s, char letter) {\\n\\n\\t\\tint count = 0;\\n\\n\\t\\tint inputSize = s.size();\\n\\n\\t\\tfor (int i = 0; i < inputSize; ++i)\\n\\t\\t{\\n\\t\\t\\tif(s[i] == letter){\\n\\t\\t\\t\\tcount++;\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\treturn (count * 100) / inputSize;\\n\\n\\t}\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3914762,
                "title": "easy-solution-using-java",
                "content": "\\n# Complexity\\n- Time complexity:O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int percentageLetter(String s, char letter) {\\n        int count = 0;\\n        for(int i = 0; i < s.length(); i++){\\n            if(s.charAt(i) == letter){\\n                count++;\\n            }\\n        }\\n        return (int)((double)count / s.length() * 100);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int percentageLetter(String s, char letter) {\\n        int count = 0;\\n        for(int i = 0; i < s.length(); i++){\\n            if(s.charAt(i) == letter){\\n                count++;\\n            }\\n        }\\n        return (int)((double)count / s.length() * 100);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3913301,
                "title": "the-best-in-dart",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n- Space complexity:\\nO(1)\\n# Code\\n```\\nclass Solution {\\n  int percentageLetter(String s, String letter) {\\n   int count = 0;\\n  for (int i = 0; i < s.length; i++) {\\n    if (s[i] == letter) {\\n      count++;\\n    }\\n  }\\n   return ((count/s.length)*100).floor();\\n  }\\n}\\n```",
                "solutionTags": [
                    "Dart"
                ],
                "code": "```\\nclass Solution {\\n  int percentageLetter(String s, String letter) {\\n   int count = 0;\\n  for (int i = 0; i < s.length; i++) {\\n    if (s[i] == letter) {\\n      count++;\\n    }\\n  }\\n   return ((count/s.length)*100).floor();\\n  }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3909510,
                "title": "easy-solution-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int percentageLetter(string s, char letter) {\\n       int L=s.length();\\n       int p=0 ;\\n       for (char c : s){\\n           if (c==letter) \\n                p++;\\n       } \\n        \\n         return (static_cast<double> (p) / L ) * 100;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int percentageLetter(string s, char letter) {\\n       int L=s.length();\\n       int p=0 ;\\n       for (char c : s){\\n           if (c==letter) \\n                p++;\\n       } \\n        \\n         return (static_cast<double> (p) / L ) * 100;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1776020,
                "content": [
                    {
                        "username": "cjatherton19",
                        "content": "i wish every interview questions was like this "
                    },
                    {
                        "username": "Saad03",
                        "content": "When I run my code in jupyter notebook, I get correct ans whereas here I get error..can anyone tell me what the problem is?\\nclass Solution(object):\\n    def percentageLetter(self, s, letter):\\n        sLen=len(s)\\n        nLetter=s.count(letter)\\n        ans=(nLetter/sLen)*100\\n        return int(ans)\\n\\nwhen s=\"foobar\" and letter=\"o\"....I\\'m getting 0 insted of 33"
                    },
                    {
                        "username": "viking09_",
                        "content": "Use float for calculation and after convert the answer back to int and then return the answer"
                    },
                    {
                        "username": "Saad03",
                        "content": "[@papitochi](/papitochi) yeah its workin now.. I wonder why it didn\\'t work with the above code....anyways thanks :)\\n"
                    },
                    {
                        "username": "papitochi",
                        "content": "figured it out, try nletter*100/sLen"
                    },
                    {
                        "username": "papitochi",
                        "content": "same\\n"
                    },
                    {
                        "username": "fool_100",
                        "content": "return the percentage of characters in s that equal letter **rounded down to the nearest whole percent**\\nI was using round() but it simply wants us to return previous integer !! \\nDescription is not correct !!!!!! "
                    },
                    {
                        "username": "nikhil-niks",
                        "content": "When I run the below code in Leetcode I am getting output as 0 whereas when I run this on my local I am getting output 33.Can someone help me where is the issue ?\\n\\nclass Solution(object):\\n    def percentageLetter(self, s, letter):\\n        totalLen = len(s)\\n        wordCount = 0\\n        for i in s:\\n            if i == letter:\\n                wordCount += 1\\n        return (int(wordCount)/int(totalLen))*100"
                    },
                    {
                        "username": "pranav_kumar_16",
                        "content": "(wordCount/totalLen) will give you 0  , so 0 * 100 results in 0. Instead use  (wordCount*100)/totalLen ."
                    },
                    {
                        "username": "bhuppidhamii",
                        "content": "`double ans = (static_cast<double>(count) / N) * 100;`\n `return static_cast<int>(ans);`\nEXPLAIN???"
                    },
                    {
                        "username": "PrashDev001",
                        "content": "1 Line Java\\n((double) s.chars().filter(c -> c == letter).count()/s.length())*100"
                    },
                    {
                        "username": "VamsidharReddyy",
                        "content": "c++:\\n\\nclass Solution {\\npublic:\\n    int percentageLetter(string s, char letter) {\\n        int count=0;\\n        int n=s.size();\\n        for(int i=0;i<s.size();i++){\\n            if(s[i]==letter) count++;\\n        }\\n        count*=100;\\n        \\n        return count/n;\\n    }\\n};"
                    },
                    {
                        "username": "anshumaan_1024",
                        "content": "\"cccaaa\" is not a valid value of type character\\nwhat does this mean ?"
                    },
                    {
                        "username": "Kartik_Bhasin",
                        "content": "wrong test case"
                    },
                    {
                        "username": "Nitish-Devarshi",
                        "content": "class Solution {\\npublic:\\n    int percentageLetter(string s, char l) {\\n        int count=0;\\n        int z=s.size();\\n        for(int i=0;i<z;i++){\\n            if(s[i]==l){\\n                count++;\\n            }\\n        }\\n        count=count*100;\\n        return count/z;\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1741882,
                "content": [
                    {
                        "username": "cjatherton19",
                        "content": "i wish every interview questions was like this "
                    },
                    {
                        "username": "Saad03",
                        "content": "When I run my code in jupyter notebook, I get correct ans whereas here I get error..can anyone tell me what the problem is?\\nclass Solution(object):\\n    def percentageLetter(self, s, letter):\\n        sLen=len(s)\\n        nLetter=s.count(letter)\\n        ans=(nLetter/sLen)*100\\n        return int(ans)\\n\\nwhen s=\"foobar\" and letter=\"o\"....I\\'m getting 0 insted of 33"
                    },
                    {
                        "username": "viking09_",
                        "content": "Use float for calculation and after convert the answer back to int and then return the answer"
                    },
                    {
                        "username": "Saad03",
                        "content": "[@papitochi](/papitochi) yeah its workin now.. I wonder why it didn\\'t work with the above code....anyways thanks :)\\n"
                    },
                    {
                        "username": "papitochi",
                        "content": "figured it out, try nletter*100/sLen"
                    },
                    {
                        "username": "papitochi",
                        "content": "same\\n"
                    },
                    {
                        "username": "fool_100",
                        "content": "return the percentage of characters in s that equal letter **rounded down to the nearest whole percent**\\nI was using round() but it simply wants us to return previous integer !! \\nDescription is not correct !!!!!! "
                    },
                    {
                        "username": "nikhil-niks",
                        "content": "When I run the below code in Leetcode I am getting output as 0 whereas when I run this on my local I am getting output 33.Can someone help me where is the issue ?\\n\\nclass Solution(object):\\n    def percentageLetter(self, s, letter):\\n        totalLen = len(s)\\n        wordCount = 0\\n        for i in s:\\n            if i == letter:\\n                wordCount += 1\\n        return (int(wordCount)/int(totalLen))*100"
                    },
                    {
                        "username": "pranav_kumar_16",
                        "content": "(wordCount/totalLen) will give you 0  , so 0 * 100 results in 0. Instead use  (wordCount*100)/totalLen ."
                    },
                    {
                        "username": "bhuppidhamii",
                        "content": "`double ans = (static_cast<double>(count) / N) * 100;`\n `return static_cast<int>(ans);`\nEXPLAIN???"
                    },
                    {
                        "username": "PrashDev001",
                        "content": "1 Line Java\\n((double) s.chars().filter(c -> c == letter).count()/s.length())*100"
                    },
                    {
                        "username": "VamsidharReddyy",
                        "content": "c++:\\n\\nclass Solution {\\npublic:\\n    int percentageLetter(string s, char letter) {\\n        int count=0;\\n        int n=s.size();\\n        for(int i=0;i<s.size();i++){\\n            if(s[i]==letter) count++;\\n        }\\n        count*=100;\\n        \\n        return count/n;\\n    }\\n};"
                    },
                    {
                        "username": "anshumaan_1024",
                        "content": "\"cccaaa\" is not a valid value of type character\\nwhat does this mean ?"
                    },
                    {
                        "username": "Kartik_Bhasin",
                        "content": "wrong test case"
                    },
                    {
                        "username": "Nitish-Devarshi",
                        "content": "class Solution {\\npublic:\\n    int percentageLetter(string s, char l) {\\n        int count=0;\\n        int z=s.size();\\n        for(int i=0;i<z;i++){\\n            if(s[i]==l){\\n                count++;\\n            }\\n        }\\n        count=count*100;\\n        return count/z;\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1738078,
                "content": [
                    {
                        "username": "cjatherton19",
                        "content": "i wish every interview questions was like this "
                    },
                    {
                        "username": "Saad03",
                        "content": "When I run my code in jupyter notebook, I get correct ans whereas here I get error..can anyone tell me what the problem is?\\nclass Solution(object):\\n    def percentageLetter(self, s, letter):\\n        sLen=len(s)\\n        nLetter=s.count(letter)\\n        ans=(nLetter/sLen)*100\\n        return int(ans)\\n\\nwhen s=\"foobar\" and letter=\"o\"....I\\'m getting 0 insted of 33"
                    },
                    {
                        "username": "viking09_",
                        "content": "Use float for calculation and after convert the answer back to int and then return the answer"
                    },
                    {
                        "username": "Saad03",
                        "content": "[@papitochi](/papitochi) yeah its workin now.. I wonder why it didn\\'t work with the above code....anyways thanks :)\\n"
                    },
                    {
                        "username": "papitochi",
                        "content": "figured it out, try nletter*100/sLen"
                    },
                    {
                        "username": "papitochi",
                        "content": "same\\n"
                    },
                    {
                        "username": "fool_100",
                        "content": "return the percentage of characters in s that equal letter **rounded down to the nearest whole percent**\\nI was using round() but it simply wants us to return previous integer !! \\nDescription is not correct !!!!!! "
                    },
                    {
                        "username": "nikhil-niks",
                        "content": "When I run the below code in Leetcode I am getting output as 0 whereas when I run this on my local I am getting output 33.Can someone help me where is the issue ?\\n\\nclass Solution(object):\\n    def percentageLetter(self, s, letter):\\n        totalLen = len(s)\\n        wordCount = 0\\n        for i in s:\\n            if i == letter:\\n                wordCount += 1\\n        return (int(wordCount)/int(totalLen))*100"
                    },
                    {
                        "username": "pranav_kumar_16",
                        "content": "(wordCount/totalLen) will give you 0  , so 0 * 100 results in 0. Instead use  (wordCount*100)/totalLen ."
                    },
                    {
                        "username": "bhuppidhamii",
                        "content": "`double ans = (static_cast<double>(count) / N) * 100;`\n `return static_cast<int>(ans);`\nEXPLAIN???"
                    },
                    {
                        "username": "PrashDev001",
                        "content": "1 Line Java\\n((double) s.chars().filter(c -> c == letter).count()/s.length())*100"
                    },
                    {
                        "username": "VamsidharReddyy",
                        "content": "c++:\\n\\nclass Solution {\\npublic:\\n    int percentageLetter(string s, char letter) {\\n        int count=0;\\n        int n=s.size();\\n        for(int i=0;i<s.size();i++){\\n            if(s[i]==letter) count++;\\n        }\\n        count*=100;\\n        \\n        return count/n;\\n    }\\n};"
                    },
                    {
                        "username": "anshumaan_1024",
                        "content": "\"cccaaa\" is not a valid value of type character\\nwhat does this mean ?"
                    },
                    {
                        "username": "Kartik_Bhasin",
                        "content": "wrong test case"
                    },
                    {
                        "username": "Nitish-Devarshi",
                        "content": "class Solution {\\npublic:\\n    int percentageLetter(string s, char l) {\\n        int count=0;\\n        int z=s.size();\\n        for(int i=0;i<z;i++){\\n            if(s[i]==l){\\n                count++;\\n            }\\n        }\\n        count=count*100;\\n        return count/z;\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 2014941,
                "content": [
                    {
                        "username": "cjatherton19",
                        "content": "i wish every interview questions was like this "
                    },
                    {
                        "username": "Saad03",
                        "content": "When I run my code in jupyter notebook, I get correct ans whereas here I get error..can anyone tell me what the problem is?\\nclass Solution(object):\\n    def percentageLetter(self, s, letter):\\n        sLen=len(s)\\n        nLetter=s.count(letter)\\n        ans=(nLetter/sLen)*100\\n        return int(ans)\\n\\nwhen s=\"foobar\" and letter=\"o\"....I\\'m getting 0 insted of 33"
                    },
                    {
                        "username": "viking09_",
                        "content": "Use float for calculation and after convert the answer back to int and then return the answer"
                    },
                    {
                        "username": "Saad03",
                        "content": "[@papitochi](/papitochi) yeah its workin now.. I wonder why it didn\\'t work with the above code....anyways thanks :)\\n"
                    },
                    {
                        "username": "papitochi",
                        "content": "figured it out, try nletter*100/sLen"
                    },
                    {
                        "username": "papitochi",
                        "content": "same\\n"
                    },
                    {
                        "username": "fool_100",
                        "content": "return the percentage of characters in s that equal letter **rounded down to the nearest whole percent**\\nI was using round() but it simply wants us to return previous integer !! \\nDescription is not correct !!!!!! "
                    },
                    {
                        "username": "nikhil-niks",
                        "content": "When I run the below code in Leetcode I am getting output as 0 whereas when I run this on my local I am getting output 33.Can someone help me where is the issue ?\\n\\nclass Solution(object):\\n    def percentageLetter(self, s, letter):\\n        totalLen = len(s)\\n        wordCount = 0\\n        for i in s:\\n            if i == letter:\\n                wordCount += 1\\n        return (int(wordCount)/int(totalLen))*100"
                    },
                    {
                        "username": "pranav_kumar_16",
                        "content": "(wordCount/totalLen) will give you 0  , so 0 * 100 results in 0. Instead use  (wordCount*100)/totalLen ."
                    },
                    {
                        "username": "bhuppidhamii",
                        "content": "`double ans = (static_cast<double>(count) / N) * 100;`\n `return static_cast<int>(ans);`\nEXPLAIN???"
                    },
                    {
                        "username": "PrashDev001",
                        "content": "1 Line Java\\n((double) s.chars().filter(c -> c == letter).count()/s.length())*100"
                    },
                    {
                        "username": "VamsidharReddyy",
                        "content": "c++:\\n\\nclass Solution {\\npublic:\\n    int percentageLetter(string s, char letter) {\\n        int count=0;\\n        int n=s.size();\\n        for(int i=0;i<s.size();i++){\\n            if(s[i]==letter) count++;\\n        }\\n        count*=100;\\n        \\n        return count/n;\\n    }\\n};"
                    },
                    {
                        "username": "anshumaan_1024",
                        "content": "\"cccaaa\" is not a valid value of type character\\nwhat does this mean ?"
                    },
                    {
                        "username": "Kartik_Bhasin",
                        "content": "wrong test case"
                    },
                    {
                        "username": "Nitish-Devarshi",
                        "content": "class Solution {\\npublic:\\n    int percentageLetter(string s, char l) {\\n        int count=0;\\n        int z=s.size();\\n        for(int i=0;i<z;i++){\\n            if(s[i]==l){\\n                count++;\\n            }\\n        }\\n        count=count*100;\\n        return count/z;\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1968474,
                "content": [
                    {
                        "username": "cjatherton19",
                        "content": "i wish every interview questions was like this "
                    },
                    {
                        "username": "Saad03",
                        "content": "When I run my code in jupyter notebook, I get correct ans whereas here I get error..can anyone tell me what the problem is?\\nclass Solution(object):\\n    def percentageLetter(self, s, letter):\\n        sLen=len(s)\\n        nLetter=s.count(letter)\\n        ans=(nLetter/sLen)*100\\n        return int(ans)\\n\\nwhen s=\"foobar\" and letter=\"o\"....I\\'m getting 0 insted of 33"
                    },
                    {
                        "username": "viking09_",
                        "content": "Use float for calculation and after convert the answer back to int and then return the answer"
                    },
                    {
                        "username": "Saad03",
                        "content": "[@papitochi](/papitochi) yeah its workin now.. I wonder why it didn\\'t work with the above code....anyways thanks :)\\n"
                    },
                    {
                        "username": "papitochi",
                        "content": "figured it out, try nletter*100/sLen"
                    },
                    {
                        "username": "papitochi",
                        "content": "same\\n"
                    },
                    {
                        "username": "fool_100",
                        "content": "return the percentage of characters in s that equal letter **rounded down to the nearest whole percent**\\nI was using round() but it simply wants us to return previous integer !! \\nDescription is not correct !!!!!! "
                    },
                    {
                        "username": "nikhil-niks",
                        "content": "When I run the below code in Leetcode I am getting output as 0 whereas when I run this on my local I am getting output 33.Can someone help me where is the issue ?\\n\\nclass Solution(object):\\n    def percentageLetter(self, s, letter):\\n        totalLen = len(s)\\n        wordCount = 0\\n        for i in s:\\n            if i == letter:\\n                wordCount += 1\\n        return (int(wordCount)/int(totalLen))*100"
                    },
                    {
                        "username": "pranav_kumar_16",
                        "content": "(wordCount/totalLen) will give you 0  , so 0 * 100 results in 0. Instead use  (wordCount*100)/totalLen ."
                    },
                    {
                        "username": "bhuppidhamii",
                        "content": "`double ans = (static_cast<double>(count) / N) * 100;`\n `return static_cast<int>(ans);`\nEXPLAIN???"
                    },
                    {
                        "username": "PrashDev001",
                        "content": "1 Line Java\\n((double) s.chars().filter(c -> c == letter).count()/s.length())*100"
                    },
                    {
                        "username": "VamsidharReddyy",
                        "content": "c++:\\n\\nclass Solution {\\npublic:\\n    int percentageLetter(string s, char letter) {\\n        int count=0;\\n        int n=s.size();\\n        for(int i=0;i<s.size();i++){\\n            if(s[i]==letter) count++;\\n        }\\n        count*=100;\\n        \\n        return count/n;\\n    }\\n};"
                    },
                    {
                        "username": "anshumaan_1024",
                        "content": "\"cccaaa\" is not a valid value of type character\\nwhat does this mean ?"
                    },
                    {
                        "username": "Kartik_Bhasin",
                        "content": "wrong test case"
                    },
                    {
                        "username": "Nitish-Devarshi",
                        "content": "class Solution {\\npublic:\\n    int percentageLetter(string s, char l) {\\n        int count=0;\\n        int z=s.size();\\n        for(int i=0;i<z;i++){\\n            if(s[i]==l){\\n                count++;\\n            }\\n        }\\n        count=count*100;\\n        return count/z;\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1849560,
                "content": [
                    {
                        "username": "cjatherton19",
                        "content": "i wish every interview questions was like this "
                    },
                    {
                        "username": "Saad03",
                        "content": "When I run my code in jupyter notebook, I get correct ans whereas here I get error..can anyone tell me what the problem is?\\nclass Solution(object):\\n    def percentageLetter(self, s, letter):\\n        sLen=len(s)\\n        nLetter=s.count(letter)\\n        ans=(nLetter/sLen)*100\\n        return int(ans)\\n\\nwhen s=\"foobar\" and letter=\"o\"....I\\'m getting 0 insted of 33"
                    },
                    {
                        "username": "viking09_",
                        "content": "Use float for calculation and after convert the answer back to int and then return the answer"
                    },
                    {
                        "username": "Saad03",
                        "content": "[@papitochi](/papitochi) yeah its workin now.. I wonder why it didn\\'t work with the above code....anyways thanks :)\\n"
                    },
                    {
                        "username": "papitochi",
                        "content": "figured it out, try nletter*100/sLen"
                    },
                    {
                        "username": "papitochi",
                        "content": "same\\n"
                    },
                    {
                        "username": "fool_100",
                        "content": "return the percentage of characters in s that equal letter **rounded down to the nearest whole percent**\\nI was using round() but it simply wants us to return previous integer !! \\nDescription is not correct !!!!!! "
                    },
                    {
                        "username": "nikhil-niks",
                        "content": "When I run the below code in Leetcode I am getting output as 0 whereas when I run this on my local I am getting output 33.Can someone help me where is the issue ?\\n\\nclass Solution(object):\\n    def percentageLetter(self, s, letter):\\n        totalLen = len(s)\\n        wordCount = 0\\n        for i in s:\\n            if i == letter:\\n                wordCount += 1\\n        return (int(wordCount)/int(totalLen))*100"
                    },
                    {
                        "username": "pranav_kumar_16",
                        "content": "(wordCount/totalLen) will give you 0  , so 0 * 100 results in 0. Instead use  (wordCount*100)/totalLen ."
                    },
                    {
                        "username": "bhuppidhamii",
                        "content": "`double ans = (static_cast<double>(count) / N) * 100;`\n `return static_cast<int>(ans);`\nEXPLAIN???"
                    },
                    {
                        "username": "PrashDev001",
                        "content": "1 Line Java\\n((double) s.chars().filter(c -> c == letter).count()/s.length())*100"
                    },
                    {
                        "username": "VamsidharReddyy",
                        "content": "c++:\\n\\nclass Solution {\\npublic:\\n    int percentageLetter(string s, char letter) {\\n        int count=0;\\n        int n=s.size();\\n        for(int i=0;i<s.size();i++){\\n            if(s[i]==letter) count++;\\n        }\\n        count*=100;\\n        \\n        return count/n;\\n    }\\n};"
                    },
                    {
                        "username": "anshumaan_1024",
                        "content": "\"cccaaa\" is not a valid value of type character\\nwhat does this mean ?"
                    },
                    {
                        "username": "Kartik_Bhasin",
                        "content": "wrong test case"
                    },
                    {
                        "username": "Nitish-Devarshi",
                        "content": "class Solution {\\npublic:\\n    int percentageLetter(string s, char l) {\\n        int count=0;\\n        int z=s.size();\\n        for(int i=0;i<z;i++){\\n            if(s[i]==l){\\n                count++;\\n            }\\n        }\\n        count=count*100;\\n        return count/z;\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1841024,
                "content": [
                    {
                        "username": "cjatherton19",
                        "content": "i wish every interview questions was like this "
                    },
                    {
                        "username": "Saad03",
                        "content": "When I run my code in jupyter notebook, I get correct ans whereas here I get error..can anyone tell me what the problem is?\\nclass Solution(object):\\n    def percentageLetter(self, s, letter):\\n        sLen=len(s)\\n        nLetter=s.count(letter)\\n        ans=(nLetter/sLen)*100\\n        return int(ans)\\n\\nwhen s=\"foobar\" and letter=\"o\"....I\\'m getting 0 insted of 33"
                    },
                    {
                        "username": "viking09_",
                        "content": "Use float for calculation and after convert the answer back to int and then return the answer"
                    },
                    {
                        "username": "Saad03",
                        "content": "[@papitochi](/papitochi) yeah its workin now.. I wonder why it didn\\'t work with the above code....anyways thanks :)\\n"
                    },
                    {
                        "username": "papitochi",
                        "content": "figured it out, try nletter*100/sLen"
                    },
                    {
                        "username": "papitochi",
                        "content": "same\\n"
                    },
                    {
                        "username": "fool_100",
                        "content": "return the percentage of characters in s that equal letter **rounded down to the nearest whole percent**\\nI was using round() but it simply wants us to return previous integer !! \\nDescription is not correct !!!!!! "
                    },
                    {
                        "username": "nikhil-niks",
                        "content": "When I run the below code in Leetcode I am getting output as 0 whereas when I run this on my local I am getting output 33.Can someone help me where is the issue ?\\n\\nclass Solution(object):\\n    def percentageLetter(self, s, letter):\\n        totalLen = len(s)\\n        wordCount = 0\\n        for i in s:\\n            if i == letter:\\n                wordCount += 1\\n        return (int(wordCount)/int(totalLen))*100"
                    },
                    {
                        "username": "pranav_kumar_16",
                        "content": "(wordCount/totalLen) will give you 0  , so 0 * 100 results in 0. Instead use  (wordCount*100)/totalLen ."
                    },
                    {
                        "username": "bhuppidhamii",
                        "content": "`double ans = (static_cast<double>(count) / N) * 100;`\n `return static_cast<int>(ans);`\nEXPLAIN???"
                    },
                    {
                        "username": "PrashDev001",
                        "content": "1 Line Java\\n((double) s.chars().filter(c -> c == letter).count()/s.length())*100"
                    },
                    {
                        "username": "VamsidharReddyy",
                        "content": "c++:\\n\\nclass Solution {\\npublic:\\n    int percentageLetter(string s, char letter) {\\n        int count=0;\\n        int n=s.size();\\n        for(int i=0;i<s.size();i++){\\n            if(s[i]==letter) count++;\\n        }\\n        count*=100;\\n        \\n        return count/n;\\n    }\\n};"
                    },
                    {
                        "username": "anshumaan_1024",
                        "content": "\"cccaaa\" is not a valid value of type character\\nwhat does this mean ?"
                    },
                    {
                        "username": "Kartik_Bhasin",
                        "content": "wrong test case"
                    },
                    {
                        "username": "Nitish-Devarshi",
                        "content": "class Solution {\\npublic:\\n    int percentageLetter(string s, char l) {\\n        int count=0;\\n        int z=s.size();\\n        for(int i=0;i<z;i++){\\n            if(s[i]==l){\\n                count++;\\n            }\\n        }\\n        count=count*100;\\n        return count/z;\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1799266,
                "content": [
                    {
                        "username": "cjatherton19",
                        "content": "i wish every interview questions was like this "
                    },
                    {
                        "username": "Saad03",
                        "content": "When I run my code in jupyter notebook, I get correct ans whereas here I get error..can anyone tell me what the problem is?\\nclass Solution(object):\\n    def percentageLetter(self, s, letter):\\n        sLen=len(s)\\n        nLetter=s.count(letter)\\n        ans=(nLetter/sLen)*100\\n        return int(ans)\\n\\nwhen s=\"foobar\" and letter=\"o\"....I\\'m getting 0 insted of 33"
                    },
                    {
                        "username": "viking09_",
                        "content": "Use float for calculation and after convert the answer back to int and then return the answer"
                    },
                    {
                        "username": "Saad03",
                        "content": "[@papitochi](/papitochi) yeah its workin now.. I wonder why it didn\\'t work with the above code....anyways thanks :)\\n"
                    },
                    {
                        "username": "papitochi",
                        "content": "figured it out, try nletter*100/sLen"
                    },
                    {
                        "username": "papitochi",
                        "content": "same\\n"
                    },
                    {
                        "username": "fool_100",
                        "content": "return the percentage of characters in s that equal letter **rounded down to the nearest whole percent**\\nI was using round() but it simply wants us to return previous integer !! \\nDescription is not correct !!!!!! "
                    },
                    {
                        "username": "nikhil-niks",
                        "content": "When I run the below code in Leetcode I am getting output as 0 whereas when I run this on my local I am getting output 33.Can someone help me where is the issue ?\\n\\nclass Solution(object):\\n    def percentageLetter(self, s, letter):\\n        totalLen = len(s)\\n        wordCount = 0\\n        for i in s:\\n            if i == letter:\\n                wordCount += 1\\n        return (int(wordCount)/int(totalLen))*100"
                    },
                    {
                        "username": "pranav_kumar_16",
                        "content": "(wordCount/totalLen) will give you 0  , so 0 * 100 results in 0. Instead use  (wordCount*100)/totalLen ."
                    },
                    {
                        "username": "bhuppidhamii",
                        "content": "`double ans = (static_cast<double>(count) / N) * 100;`\n `return static_cast<int>(ans);`\nEXPLAIN???"
                    },
                    {
                        "username": "PrashDev001",
                        "content": "1 Line Java\\n((double) s.chars().filter(c -> c == letter).count()/s.length())*100"
                    },
                    {
                        "username": "VamsidharReddyy",
                        "content": "c++:\\n\\nclass Solution {\\npublic:\\n    int percentageLetter(string s, char letter) {\\n        int count=0;\\n        int n=s.size();\\n        for(int i=0;i<s.size();i++){\\n            if(s[i]==letter) count++;\\n        }\\n        count*=100;\\n        \\n        return count/n;\\n    }\\n};"
                    },
                    {
                        "username": "anshumaan_1024",
                        "content": "\"cccaaa\" is not a valid value of type character\\nwhat does this mean ?"
                    },
                    {
                        "username": "Kartik_Bhasin",
                        "content": "wrong test case"
                    },
                    {
                        "username": "Nitish-Devarshi",
                        "content": "class Solution {\\npublic:\\n    int percentageLetter(string s, char l) {\\n        int count=0;\\n        int z=s.size();\\n        for(int i=0;i<z;i++){\\n            if(s[i]==l){\\n                count++;\\n            }\\n        }\\n        count=count*100;\\n        return count/z;\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1756245,
                "content": [
                    {
                        "username": "cjatherton19",
                        "content": "i wish every interview questions was like this "
                    },
                    {
                        "username": "Saad03",
                        "content": "When I run my code in jupyter notebook, I get correct ans whereas here I get error..can anyone tell me what the problem is?\\nclass Solution(object):\\n    def percentageLetter(self, s, letter):\\n        sLen=len(s)\\n        nLetter=s.count(letter)\\n        ans=(nLetter/sLen)*100\\n        return int(ans)\\n\\nwhen s=\"foobar\" and letter=\"o\"....I\\'m getting 0 insted of 33"
                    },
                    {
                        "username": "viking09_",
                        "content": "Use float for calculation and after convert the answer back to int and then return the answer"
                    },
                    {
                        "username": "Saad03",
                        "content": "[@papitochi](/papitochi) yeah its workin now.. I wonder why it didn\\'t work with the above code....anyways thanks :)\\n"
                    },
                    {
                        "username": "papitochi",
                        "content": "figured it out, try nletter*100/sLen"
                    },
                    {
                        "username": "papitochi",
                        "content": "same\\n"
                    },
                    {
                        "username": "fool_100",
                        "content": "return the percentage of characters in s that equal letter **rounded down to the nearest whole percent**\\nI was using round() but it simply wants us to return previous integer !! \\nDescription is not correct !!!!!! "
                    },
                    {
                        "username": "nikhil-niks",
                        "content": "When I run the below code in Leetcode I am getting output as 0 whereas when I run this on my local I am getting output 33.Can someone help me where is the issue ?\\n\\nclass Solution(object):\\n    def percentageLetter(self, s, letter):\\n        totalLen = len(s)\\n        wordCount = 0\\n        for i in s:\\n            if i == letter:\\n                wordCount += 1\\n        return (int(wordCount)/int(totalLen))*100"
                    },
                    {
                        "username": "pranav_kumar_16",
                        "content": "(wordCount/totalLen) will give you 0  , so 0 * 100 results in 0. Instead use  (wordCount*100)/totalLen ."
                    },
                    {
                        "username": "bhuppidhamii",
                        "content": "`double ans = (static_cast<double>(count) / N) * 100;`\n `return static_cast<int>(ans);`\nEXPLAIN???"
                    },
                    {
                        "username": "PrashDev001",
                        "content": "1 Line Java\\n((double) s.chars().filter(c -> c == letter).count()/s.length())*100"
                    },
                    {
                        "username": "VamsidharReddyy",
                        "content": "c++:\\n\\nclass Solution {\\npublic:\\n    int percentageLetter(string s, char letter) {\\n        int count=0;\\n        int n=s.size();\\n        for(int i=0;i<s.size();i++){\\n            if(s[i]==letter) count++;\\n        }\\n        count*=100;\\n        \\n        return count/n;\\n    }\\n};"
                    },
                    {
                        "username": "anshumaan_1024",
                        "content": "\"cccaaa\" is not a valid value of type character\\nwhat does this mean ?"
                    },
                    {
                        "username": "Kartik_Bhasin",
                        "content": "wrong test case"
                    },
                    {
                        "username": "Nitish-Devarshi",
                        "content": "class Solution {\\npublic:\\n    int percentageLetter(string s, char l) {\\n        int count=0;\\n        int z=s.size();\\n        for(int i=0;i<z;i++){\\n            if(s[i]==l){\\n                count++;\\n            }\\n        }\\n        count=count*100;\\n        return count/z;\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1732835,
                "content": [
                    {
                        "username": "cjatherton19",
                        "content": "i wish every interview questions was like this "
                    },
                    {
                        "username": "Saad03",
                        "content": "When I run my code in jupyter notebook, I get correct ans whereas here I get error..can anyone tell me what the problem is?\\nclass Solution(object):\\n    def percentageLetter(self, s, letter):\\n        sLen=len(s)\\n        nLetter=s.count(letter)\\n        ans=(nLetter/sLen)*100\\n        return int(ans)\\n\\nwhen s=\"foobar\" and letter=\"o\"....I\\'m getting 0 insted of 33"
                    },
                    {
                        "username": "viking09_",
                        "content": "Use float for calculation and after convert the answer back to int and then return the answer"
                    },
                    {
                        "username": "Saad03",
                        "content": "[@papitochi](/papitochi) yeah its workin now.. I wonder why it didn\\'t work with the above code....anyways thanks :)\\n"
                    },
                    {
                        "username": "papitochi",
                        "content": "figured it out, try nletter*100/sLen"
                    },
                    {
                        "username": "papitochi",
                        "content": "same\\n"
                    },
                    {
                        "username": "fool_100",
                        "content": "return the percentage of characters in s that equal letter **rounded down to the nearest whole percent**\\nI was using round() but it simply wants us to return previous integer !! \\nDescription is not correct !!!!!! "
                    },
                    {
                        "username": "nikhil-niks",
                        "content": "When I run the below code in Leetcode I am getting output as 0 whereas when I run this on my local I am getting output 33.Can someone help me where is the issue ?\\n\\nclass Solution(object):\\n    def percentageLetter(self, s, letter):\\n        totalLen = len(s)\\n        wordCount = 0\\n        for i in s:\\n            if i == letter:\\n                wordCount += 1\\n        return (int(wordCount)/int(totalLen))*100"
                    },
                    {
                        "username": "pranav_kumar_16",
                        "content": "(wordCount/totalLen) will give you 0  , so 0 * 100 results in 0. Instead use  (wordCount*100)/totalLen ."
                    },
                    {
                        "username": "bhuppidhamii",
                        "content": "`double ans = (static_cast<double>(count) / N) * 100;`\n `return static_cast<int>(ans);`\nEXPLAIN???"
                    },
                    {
                        "username": "PrashDev001",
                        "content": "1 Line Java\\n((double) s.chars().filter(c -> c == letter).count()/s.length())*100"
                    },
                    {
                        "username": "VamsidharReddyy",
                        "content": "c++:\\n\\nclass Solution {\\npublic:\\n    int percentageLetter(string s, char letter) {\\n        int count=0;\\n        int n=s.size();\\n        for(int i=0;i<s.size();i++){\\n            if(s[i]==letter) count++;\\n        }\\n        count*=100;\\n        \\n        return count/n;\\n    }\\n};"
                    },
                    {
                        "username": "anshumaan_1024",
                        "content": "\"cccaaa\" is not a valid value of type character\\nwhat does this mean ?"
                    },
                    {
                        "username": "Kartik_Bhasin",
                        "content": "wrong test case"
                    },
                    {
                        "username": "Nitish-Devarshi",
                        "content": "class Solution {\\npublic:\\n    int percentageLetter(string s, char l) {\\n        int count=0;\\n        int z=s.size();\\n        for(int i=0;i<z;i++){\\n            if(s[i]==l){\\n                count++;\\n            }\\n        }\\n        count=count*100;\\n        return count/z;\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1776020,
                "content": [
                    {
                        "username": "cjatherton19",
                        "content": "i wish every interview questions was like this "
                    },
                    {
                        "username": "Saad03",
                        "content": "When I run my code in jupyter notebook, I get correct ans whereas here I get error..can anyone tell me what the problem is?\\nclass Solution(object):\\n    def percentageLetter(self, s, letter):\\n        sLen=len(s)\\n        nLetter=s.count(letter)\\n        ans=(nLetter/sLen)*100\\n        return int(ans)\\n\\nwhen s=\"foobar\" and letter=\"o\"....I\\'m getting 0 insted of 33"
                    },
                    {
                        "username": "viking09_",
                        "content": "Use float for calculation and after convert the answer back to int and then return the answer"
                    },
                    {
                        "username": "Saad03",
                        "content": "[@papitochi](/papitochi) yeah its workin now.. I wonder why it didn\\'t work with the above code....anyways thanks :)\\n"
                    },
                    {
                        "username": "papitochi",
                        "content": "figured it out, try nletter*100/sLen"
                    },
                    {
                        "username": "papitochi",
                        "content": "same\\n"
                    },
                    {
                        "username": "fool_100",
                        "content": "return the percentage of characters in s that equal letter **rounded down to the nearest whole percent**\\nI was using round() but it simply wants us to return previous integer !! \\nDescription is not correct !!!!!! "
                    },
                    {
                        "username": "nikhil-niks",
                        "content": "When I run the below code in Leetcode I am getting output as 0 whereas when I run this on my local I am getting output 33.Can someone help me where is the issue ?\\n\\nclass Solution(object):\\n    def percentageLetter(self, s, letter):\\n        totalLen = len(s)\\n        wordCount = 0\\n        for i in s:\\n            if i == letter:\\n                wordCount += 1\\n        return (int(wordCount)/int(totalLen))*100"
                    },
                    {
                        "username": "pranav_kumar_16",
                        "content": "(wordCount/totalLen) will give you 0  , so 0 * 100 results in 0. Instead use  (wordCount*100)/totalLen ."
                    },
                    {
                        "username": "bhuppidhamii",
                        "content": "`double ans = (static_cast<double>(count) / N) * 100;`\n `return static_cast<int>(ans);`\nEXPLAIN???"
                    },
                    {
                        "username": "PrashDev001",
                        "content": "1 Line Java\\n((double) s.chars().filter(c -> c == letter).count()/s.length())*100"
                    },
                    {
                        "username": "VamsidharReddyy",
                        "content": "c++:\\n\\nclass Solution {\\npublic:\\n    int percentageLetter(string s, char letter) {\\n        int count=0;\\n        int n=s.size();\\n        for(int i=0;i<s.size();i++){\\n            if(s[i]==letter) count++;\\n        }\\n        count*=100;\\n        \\n        return count/n;\\n    }\\n};"
                    },
                    {
                        "username": "anshumaan_1024",
                        "content": "\"cccaaa\" is not a valid value of type character\\nwhat does this mean ?"
                    },
                    {
                        "username": "Kartik_Bhasin",
                        "content": "wrong test case"
                    },
                    {
                        "username": "Nitish-Devarshi",
                        "content": "class Solution {\\npublic:\\n    int percentageLetter(string s, char l) {\\n        int count=0;\\n        int z=s.size();\\n        for(int i=0;i<z;i++){\\n            if(s[i]==l){\\n                count++;\\n            }\\n        }\\n        count=count*100;\\n        return count/z;\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1741882,
                "content": [
                    {
                        "username": "cjatherton19",
                        "content": "i wish every interview questions was like this "
                    },
                    {
                        "username": "Saad03",
                        "content": "When I run my code in jupyter notebook, I get correct ans whereas here I get error..can anyone tell me what the problem is?\\nclass Solution(object):\\n    def percentageLetter(self, s, letter):\\n        sLen=len(s)\\n        nLetter=s.count(letter)\\n        ans=(nLetter/sLen)*100\\n        return int(ans)\\n\\nwhen s=\"foobar\" and letter=\"o\"....I\\'m getting 0 insted of 33"
                    },
                    {
                        "username": "viking09_",
                        "content": "Use float for calculation and after convert the answer back to int and then return the answer"
                    },
                    {
                        "username": "Saad03",
                        "content": "[@papitochi](/papitochi) yeah its workin now.. I wonder why it didn\\'t work with the above code....anyways thanks :)\\n"
                    },
                    {
                        "username": "papitochi",
                        "content": "figured it out, try nletter*100/sLen"
                    },
                    {
                        "username": "papitochi",
                        "content": "same\\n"
                    },
                    {
                        "username": "fool_100",
                        "content": "return the percentage of characters in s that equal letter **rounded down to the nearest whole percent**\\nI was using round() but it simply wants us to return previous integer !! \\nDescription is not correct !!!!!! "
                    },
                    {
                        "username": "nikhil-niks",
                        "content": "When I run the below code in Leetcode I am getting output as 0 whereas when I run this on my local I am getting output 33.Can someone help me where is the issue ?\\n\\nclass Solution(object):\\n    def percentageLetter(self, s, letter):\\n        totalLen = len(s)\\n        wordCount = 0\\n        for i in s:\\n            if i == letter:\\n                wordCount += 1\\n        return (int(wordCount)/int(totalLen))*100"
                    },
                    {
                        "username": "pranav_kumar_16",
                        "content": "(wordCount/totalLen) will give you 0  , so 0 * 100 results in 0. Instead use  (wordCount*100)/totalLen ."
                    },
                    {
                        "username": "bhuppidhamii",
                        "content": "`double ans = (static_cast<double>(count) / N) * 100;`\n `return static_cast<int>(ans);`\nEXPLAIN???"
                    },
                    {
                        "username": "PrashDev001",
                        "content": "1 Line Java\\n((double) s.chars().filter(c -> c == letter).count()/s.length())*100"
                    },
                    {
                        "username": "VamsidharReddyy",
                        "content": "c++:\\n\\nclass Solution {\\npublic:\\n    int percentageLetter(string s, char letter) {\\n        int count=0;\\n        int n=s.size();\\n        for(int i=0;i<s.size();i++){\\n            if(s[i]==letter) count++;\\n        }\\n        count*=100;\\n        \\n        return count/n;\\n    }\\n};"
                    },
                    {
                        "username": "anshumaan_1024",
                        "content": "\"cccaaa\" is not a valid value of type character\\nwhat does this mean ?"
                    },
                    {
                        "username": "Kartik_Bhasin",
                        "content": "wrong test case"
                    },
                    {
                        "username": "Nitish-Devarshi",
                        "content": "class Solution {\\npublic:\\n    int percentageLetter(string s, char l) {\\n        int count=0;\\n        int z=s.size();\\n        for(int i=0;i<z;i++){\\n            if(s[i]==l){\\n                count++;\\n            }\\n        }\\n        count=count*100;\\n        return count/z;\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1738078,
                "content": [
                    {
                        "username": "cjatherton19",
                        "content": "i wish every interview questions was like this "
                    },
                    {
                        "username": "Saad03",
                        "content": "When I run my code in jupyter notebook, I get correct ans whereas here I get error..can anyone tell me what the problem is?\\nclass Solution(object):\\n    def percentageLetter(self, s, letter):\\n        sLen=len(s)\\n        nLetter=s.count(letter)\\n        ans=(nLetter/sLen)*100\\n        return int(ans)\\n\\nwhen s=\"foobar\" and letter=\"o\"....I\\'m getting 0 insted of 33"
                    },
                    {
                        "username": "viking09_",
                        "content": "Use float for calculation and after convert the answer back to int and then return the answer"
                    },
                    {
                        "username": "Saad03",
                        "content": "[@papitochi](/papitochi) yeah its workin now.. I wonder why it didn\\'t work with the above code....anyways thanks :)\\n"
                    },
                    {
                        "username": "papitochi",
                        "content": "figured it out, try nletter*100/sLen"
                    },
                    {
                        "username": "papitochi",
                        "content": "same\\n"
                    },
                    {
                        "username": "fool_100",
                        "content": "return the percentage of characters in s that equal letter **rounded down to the nearest whole percent**\\nI was using round() but it simply wants us to return previous integer !! \\nDescription is not correct !!!!!! "
                    },
                    {
                        "username": "nikhil-niks",
                        "content": "When I run the below code in Leetcode I am getting output as 0 whereas when I run this on my local I am getting output 33.Can someone help me where is the issue ?\\n\\nclass Solution(object):\\n    def percentageLetter(self, s, letter):\\n        totalLen = len(s)\\n        wordCount = 0\\n        for i in s:\\n            if i == letter:\\n                wordCount += 1\\n        return (int(wordCount)/int(totalLen))*100"
                    },
                    {
                        "username": "pranav_kumar_16",
                        "content": "(wordCount/totalLen) will give you 0  , so 0 * 100 results in 0. Instead use  (wordCount*100)/totalLen ."
                    },
                    {
                        "username": "bhuppidhamii",
                        "content": "`double ans = (static_cast<double>(count) / N) * 100;`\n `return static_cast<int>(ans);`\nEXPLAIN???"
                    },
                    {
                        "username": "PrashDev001",
                        "content": "1 Line Java\\n((double) s.chars().filter(c -> c == letter).count()/s.length())*100"
                    },
                    {
                        "username": "VamsidharReddyy",
                        "content": "c++:\\n\\nclass Solution {\\npublic:\\n    int percentageLetter(string s, char letter) {\\n        int count=0;\\n        int n=s.size();\\n        for(int i=0;i<s.size();i++){\\n            if(s[i]==letter) count++;\\n        }\\n        count*=100;\\n        \\n        return count/n;\\n    }\\n};"
                    },
                    {
                        "username": "anshumaan_1024",
                        "content": "\"cccaaa\" is not a valid value of type character\\nwhat does this mean ?"
                    },
                    {
                        "username": "Kartik_Bhasin",
                        "content": "wrong test case"
                    },
                    {
                        "username": "Nitish-Devarshi",
                        "content": "class Solution {\\npublic:\\n    int percentageLetter(string s, char l) {\\n        int count=0;\\n        int z=s.size();\\n        for(int i=0;i<z;i++){\\n            if(s[i]==l){\\n                count++;\\n            }\\n        }\\n        count=count*100;\\n        return count/z;\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 2014941,
                "content": [
                    {
                        "username": "cjatherton19",
                        "content": "i wish every interview questions was like this "
                    },
                    {
                        "username": "Saad03",
                        "content": "When I run my code in jupyter notebook, I get correct ans whereas here I get error..can anyone tell me what the problem is?\\nclass Solution(object):\\n    def percentageLetter(self, s, letter):\\n        sLen=len(s)\\n        nLetter=s.count(letter)\\n        ans=(nLetter/sLen)*100\\n        return int(ans)\\n\\nwhen s=\"foobar\" and letter=\"o\"....I\\'m getting 0 insted of 33"
                    },
                    {
                        "username": "viking09_",
                        "content": "Use float for calculation and after convert the answer back to int and then return the answer"
                    },
                    {
                        "username": "Saad03",
                        "content": "[@papitochi](/papitochi) yeah its workin now.. I wonder why it didn\\'t work with the above code....anyways thanks :)\\n"
                    },
                    {
                        "username": "papitochi",
                        "content": "figured it out, try nletter*100/sLen"
                    },
                    {
                        "username": "papitochi",
                        "content": "same\\n"
                    },
                    {
                        "username": "fool_100",
                        "content": "return the percentage of characters in s that equal letter **rounded down to the nearest whole percent**\\nI was using round() but it simply wants us to return previous integer !! \\nDescription is not correct !!!!!! "
                    },
                    {
                        "username": "nikhil-niks",
                        "content": "When I run the below code in Leetcode I am getting output as 0 whereas when I run this on my local I am getting output 33.Can someone help me where is the issue ?\\n\\nclass Solution(object):\\n    def percentageLetter(self, s, letter):\\n        totalLen = len(s)\\n        wordCount = 0\\n        for i in s:\\n            if i == letter:\\n                wordCount += 1\\n        return (int(wordCount)/int(totalLen))*100"
                    },
                    {
                        "username": "pranav_kumar_16",
                        "content": "(wordCount/totalLen) will give you 0  , so 0 * 100 results in 0. Instead use  (wordCount*100)/totalLen ."
                    },
                    {
                        "username": "bhuppidhamii",
                        "content": "`double ans = (static_cast<double>(count) / N) * 100;`\n `return static_cast<int>(ans);`\nEXPLAIN???"
                    },
                    {
                        "username": "PrashDev001",
                        "content": "1 Line Java\\n((double) s.chars().filter(c -> c == letter).count()/s.length())*100"
                    },
                    {
                        "username": "VamsidharReddyy",
                        "content": "c++:\\n\\nclass Solution {\\npublic:\\n    int percentageLetter(string s, char letter) {\\n        int count=0;\\n        int n=s.size();\\n        for(int i=0;i<s.size();i++){\\n            if(s[i]==letter) count++;\\n        }\\n        count*=100;\\n        \\n        return count/n;\\n    }\\n};"
                    },
                    {
                        "username": "anshumaan_1024",
                        "content": "\"cccaaa\" is not a valid value of type character\\nwhat does this mean ?"
                    },
                    {
                        "username": "Kartik_Bhasin",
                        "content": "wrong test case"
                    },
                    {
                        "username": "Nitish-Devarshi",
                        "content": "class Solution {\\npublic:\\n    int percentageLetter(string s, char l) {\\n        int count=0;\\n        int z=s.size();\\n        for(int i=0;i<z;i++){\\n            if(s[i]==l){\\n                count++;\\n            }\\n        }\\n        count=count*100;\\n        return count/z;\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1968474,
                "content": [
                    {
                        "username": "cjatherton19",
                        "content": "i wish every interview questions was like this "
                    },
                    {
                        "username": "Saad03",
                        "content": "When I run my code in jupyter notebook, I get correct ans whereas here I get error..can anyone tell me what the problem is?\\nclass Solution(object):\\n    def percentageLetter(self, s, letter):\\n        sLen=len(s)\\n        nLetter=s.count(letter)\\n        ans=(nLetter/sLen)*100\\n        return int(ans)\\n\\nwhen s=\"foobar\" and letter=\"o\"....I\\'m getting 0 insted of 33"
                    },
                    {
                        "username": "viking09_",
                        "content": "Use float for calculation and after convert the answer back to int and then return the answer"
                    },
                    {
                        "username": "Saad03",
                        "content": "[@papitochi](/papitochi) yeah its workin now.. I wonder why it didn\\'t work with the above code....anyways thanks :)\\n"
                    },
                    {
                        "username": "papitochi",
                        "content": "figured it out, try nletter*100/sLen"
                    },
                    {
                        "username": "papitochi",
                        "content": "same\\n"
                    },
                    {
                        "username": "fool_100",
                        "content": "return the percentage of characters in s that equal letter **rounded down to the nearest whole percent**\\nI was using round() but it simply wants us to return previous integer !! \\nDescription is not correct !!!!!! "
                    },
                    {
                        "username": "nikhil-niks",
                        "content": "When I run the below code in Leetcode I am getting output as 0 whereas when I run this on my local I am getting output 33.Can someone help me where is the issue ?\\n\\nclass Solution(object):\\n    def percentageLetter(self, s, letter):\\n        totalLen = len(s)\\n        wordCount = 0\\n        for i in s:\\n            if i == letter:\\n                wordCount += 1\\n        return (int(wordCount)/int(totalLen))*100"
                    },
                    {
                        "username": "pranav_kumar_16",
                        "content": "(wordCount/totalLen) will give you 0  , so 0 * 100 results in 0. Instead use  (wordCount*100)/totalLen ."
                    },
                    {
                        "username": "bhuppidhamii",
                        "content": "`double ans = (static_cast<double>(count) / N) * 100;`\n `return static_cast<int>(ans);`\nEXPLAIN???"
                    },
                    {
                        "username": "PrashDev001",
                        "content": "1 Line Java\\n((double) s.chars().filter(c -> c == letter).count()/s.length())*100"
                    },
                    {
                        "username": "VamsidharReddyy",
                        "content": "c++:\\n\\nclass Solution {\\npublic:\\n    int percentageLetter(string s, char letter) {\\n        int count=0;\\n        int n=s.size();\\n        for(int i=0;i<s.size();i++){\\n            if(s[i]==letter) count++;\\n        }\\n        count*=100;\\n        \\n        return count/n;\\n    }\\n};"
                    },
                    {
                        "username": "anshumaan_1024",
                        "content": "\"cccaaa\" is not a valid value of type character\\nwhat does this mean ?"
                    },
                    {
                        "username": "Kartik_Bhasin",
                        "content": "wrong test case"
                    },
                    {
                        "username": "Nitish-Devarshi",
                        "content": "class Solution {\\npublic:\\n    int percentageLetter(string s, char l) {\\n        int count=0;\\n        int z=s.size();\\n        for(int i=0;i<z;i++){\\n            if(s[i]==l){\\n                count++;\\n            }\\n        }\\n        count=count*100;\\n        return count/z;\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1849560,
                "content": [
                    {
                        "username": "cjatherton19",
                        "content": "i wish every interview questions was like this "
                    },
                    {
                        "username": "Saad03",
                        "content": "When I run my code in jupyter notebook, I get correct ans whereas here I get error..can anyone tell me what the problem is?\\nclass Solution(object):\\n    def percentageLetter(self, s, letter):\\n        sLen=len(s)\\n        nLetter=s.count(letter)\\n        ans=(nLetter/sLen)*100\\n        return int(ans)\\n\\nwhen s=\"foobar\" and letter=\"o\"....I\\'m getting 0 insted of 33"
                    },
                    {
                        "username": "viking09_",
                        "content": "Use float for calculation and after convert the answer back to int and then return the answer"
                    },
                    {
                        "username": "Saad03",
                        "content": "[@papitochi](/papitochi) yeah its workin now.. I wonder why it didn\\'t work with the above code....anyways thanks :)\\n"
                    },
                    {
                        "username": "papitochi",
                        "content": "figured it out, try nletter*100/sLen"
                    },
                    {
                        "username": "papitochi",
                        "content": "same\\n"
                    },
                    {
                        "username": "fool_100",
                        "content": "return the percentage of characters in s that equal letter **rounded down to the nearest whole percent**\\nI was using round() but it simply wants us to return previous integer !! \\nDescription is not correct !!!!!! "
                    },
                    {
                        "username": "nikhil-niks",
                        "content": "When I run the below code in Leetcode I am getting output as 0 whereas when I run this on my local I am getting output 33.Can someone help me where is the issue ?\\n\\nclass Solution(object):\\n    def percentageLetter(self, s, letter):\\n        totalLen = len(s)\\n        wordCount = 0\\n        for i in s:\\n            if i == letter:\\n                wordCount += 1\\n        return (int(wordCount)/int(totalLen))*100"
                    },
                    {
                        "username": "pranav_kumar_16",
                        "content": "(wordCount/totalLen) will give you 0  , so 0 * 100 results in 0. Instead use  (wordCount*100)/totalLen ."
                    },
                    {
                        "username": "bhuppidhamii",
                        "content": "`double ans = (static_cast<double>(count) / N) * 100;`\n `return static_cast<int>(ans);`\nEXPLAIN???"
                    },
                    {
                        "username": "PrashDev001",
                        "content": "1 Line Java\\n((double) s.chars().filter(c -> c == letter).count()/s.length())*100"
                    },
                    {
                        "username": "VamsidharReddyy",
                        "content": "c++:\\n\\nclass Solution {\\npublic:\\n    int percentageLetter(string s, char letter) {\\n        int count=0;\\n        int n=s.size();\\n        for(int i=0;i<s.size();i++){\\n            if(s[i]==letter) count++;\\n        }\\n        count*=100;\\n        \\n        return count/n;\\n    }\\n};"
                    },
                    {
                        "username": "anshumaan_1024",
                        "content": "\"cccaaa\" is not a valid value of type character\\nwhat does this mean ?"
                    },
                    {
                        "username": "Kartik_Bhasin",
                        "content": "wrong test case"
                    },
                    {
                        "username": "Nitish-Devarshi",
                        "content": "class Solution {\\npublic:\\n    int percentageLetter(string s, char l) {\\n        int count=0;\\n        int z=s.size();\\n        for(int i=0;i<z;i++){\\n            if(s[i]==l){\\n                count++;\\n            }\\n        }\\n        count=count*100;\\n        return count/z;\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1841024,
                "content": [
                    {
                        "username": "cjatherton19",
                        "content": "i wish every interview questions was like this "
                    },
                    {
                        "username": "Saad03",
                        "content": "When I run my code in jupyter notebook, I get correct ans whereas here I get error..can anyone tell me what the problem is?\\nclass Solution(object):\\n    def percentageLetter(self, s, letter):\\n        sLen=len(s)\\n        nLetter=s.count(letter)\\n        ans=(nLetter/sLen)*100\\n        return int(ans)\\n\\nwhen s=\"foobar\" and letter=\"o\"....I\\'m getting 0 insted of 33"
                    },
                    {
                        "username": "viking09_",
                        "content": "Use float for calculation and after convert the answer back to int and then return the answer"
                    },
                    {
                        "username": "Saad03",
                        "content": "[@papitochi](/papitochi) yeah its workin now.. I wonder why it didn\\'t work with the above code....anyways thanks :)\\n"
                    },
                    {
                        "username": "papitochi",
                        "content": "figured it out, try nletter*100/sLen"
                    },
                    {
                        "username": "papitochi",
                        "content": "same\\n"
                    },
                    {
                        "username": "fool_100",
                        "content": "return the percentage of characters in s that equal letter **rounded down to the nearest whole percent**\\nI was using round() but it simply wants us to return previous integer !! \\nDescription is not correct !!!!!! "
                    },
                    {
                        "username": "nikhil-niks",
                        "content": "When I run the below code in Leetcode I am getting output as 0 whereas when I run this on my local I am getting output 33.Can someone help me where is the issue ?\\n\\nclass Solution(object):\\n    def percentageLetter(self, s, letter):\\n        totalLen = len(s)\\n        wordCount = 0\\n        for i in s:\\n            if i == letter:\\n                wordCount += 1\\n        return (int(wordCount)/int(totalLen))*100"
                    },
                    {
                        "username": "pranav_kumar_16",
                        "content": "(wordCount/totalLen) will give you 0  , so 0 * 100 results in 0. Instead use  (wordCount*100)/totalLen ."
                    },
                    {
                        "username": "bhuppidhamii",
                        "content": "`double ans = (static_cast<double>(count) / N) * 100;`\n `return static_cast<int>(ans);`\nEXPLAIN???"
                    },
                    {
                        "username": "PrashDev001",
                        "content": "1 Line Java\\n((double) s.chars().filter(c -> c == letter).count()/s.length())*100"
                    },
                    {
                        "username": "VamsidharReddyy",
                        "content": "c++:\\n\\nclass Solution {\\npublic:\\n    int percentageLetter(string s, char letter) {\\n        int count=0;\\n        int n=s.size();\\n        for(int i=0;i<s.size();i++){\\n            if(s[i]==letter) count++;\\n        }\\n        count*=100;\\n        \\n        return count/n;\\n    }\\n};"
                    },
                    {
                        "username": "anshumaan_1024",
                        "content": "\"cccaaa\" is not a valid value of type character\\nwhat does this mean ?"
                    },
                    {
                        "username": "Kartik_Bhasin",
                        "content": "wrong test case"
                    },
                    {
                        "username": "Nitish-Devarshi",
                        "content": "class Solution {\\npublic:\\n    int percentageLetter(string s, char l) {\\n        int count=0;\\n        int z=s.size();\\n        for(int i=0;i<z;i++){\\n            if(s[i]==l){\\n                count++;\\n            }\\n        }\\n        count=count*100;\\n        return count/z;\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1799266,
                "content": [
                    {
                        "username": "cjatherton19",
                        "content": "i wish every interview questions was like this "
                    },
                    {
                        "username": "Saad03",
                        "content": "When I run my code in jupyter notebook, I get correct ans whereas here I get error..can anyone tell me what the problem is?\\nclass Solution(object):\\n    def percentageLetter(self, s, letter):\\n        sLen=len(s)\\n        nLetter=s.count(letter)\\n        ans=(nLetter/sLen)*100\\n        return int(ans)\\n\\nwhen s=\"foobar\" and letter=\"o\"....I\\'m getting 0 insted of 33"
                    },
                    {
                        "username": "viking09_",
                        "content": "Use float for calculation and after convert the answer back to int and then return the answer"
                    },
                    {
                        "username": "Saad03",
                        "content": "[@papitochi](/papitochi) yeah its workin now.. I wonder why it didn\\'t work with the above code....anyways thanks :)\\n"
                    },
                    {
                        "username": "papitochi",
                        "content": "figured it out, try nletter*100/sLen"
                    },
                    {
                        "username": "papitochi",
                        "content": "same\\n"
                    },
                    {
                        "username": "fool_100",
                        "content": "return the percentage of characters in s that equal letter **rounded down to the nearest whole percent**\\nI was using round() but it simply wants us to return previous integer !! \\nDescription is not correct !!!!!! "
                    },
                    {
                        "username": "nikhil-niks",
                        "content": "When I run the below code in Leetcode I am getting output as 0 whereas when I run this on my local I am getting output 33.Can someone help me where is the issue ?\\n\\nclass Solution(object):\\n    def percentageLetter(self, s, letter):\\n        totalLen = len(s)\\n        wordCount = 0\\n        for i in s:\\n            if i == letter:\\n                wordCount += 1\\n        return (int(wordCount)/int(totalLen))*100"
                    },
                    {
                        "username": "pranav_kumar_16",
                        "content": "(wordCount/totalLen) will give you 0  , so 0 * 100 results in 0. Instead use  (wordCount*100)/totalLen ."
                    },
                    {
                        "username": "bhuppidhamii",
                        "content": "`double ans = (static_cast<double>(count) / N) * 100;`\n `return static_cast<int>(ans);`\nEXPLAIN???"
                    },
                    {
                        "username": "PrashDev001",
                        "content": "1 Line Java\\n((double) s.chars().filter(c -> c == letter).count()/s.length())*100"
                    },
                    {
                        "username": "VamsidharReddyy",
                        "content": "c++:\\n\\nclass Solution {\\npublic:\\n    int percentageLetter(string s, char letter) {\\n        int count=0;\\n        int n=s.size();\\n        for(int i=0;i<s.size();i++){\\n            if(s[i]==letter) count++;\\n        }\\n        count*=100;\\n        \\n        return count/n;\\n    }\\n};"
                    },
                    {
                        "username": "anshumaan_1024",
                        "content": "\"cccaaa\" is not a valid value of type character\\nwhat does this mean ?"
                    },
                    {
                        "username": "Kartik_Bhasin",
                        "content": "wrong test case"
                    },
                    {
                        "username": "Nitish-Devarshi",
                        "content": "class Solution {\\npublic:\\n    int percentageLetter(string s, char l) {\\n        int count=0;\\n        int z=s.size();\\n        for(int i=0;i<z;i++){\\n            if(s[i]==l){\\n                count++;\\n            }\\n        }\\n        count=count*100;\\n        return count/z;\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1756245,
                "content": [
                    {
                        "username": "cjatherton19",
                        "content": "i wish every interview questions was like this "
                    },
                    {
                        "username": "Saad03",
                        "content": "When I run my code in jupyter notebook, I get correct ans whereas here I get error..can anyone tell me what the problem is?\\nclass Solution(object):\\n    def percentageLetter(self, s, letter):\\n        sLen=len(s)\\n        nLetter=s.count(letter)\\n        ans=(nLetter/sLen)*100\\n        return int(ans)\\n\\nwhen s=\"foobar\" and letter=\"o\"....I\\'m getting 0 insted of 33"
                    },
                    {
                        "username": "viking09_",
                        "content": "Use float for calculation and after convert the answer back to int and then return the answer"
                    },
                    {
                        "username": "Saad03",
                        "content": "[@papitochi](/papitochi) yeah its workin now.. I wonder why it didn\\'t work with the above code....anyways thanks :)\\n"
                    },
                    {
                        "username": "papitochi",
                        "content": "figured it out, try nletter*100/sLen"
                    },
                    {
                        "username": "papitochi",
                        "content": "same\\n"
                    },
                    {
                        "username": "fool_100",
                        "content": "return the percentage of characters in s that equal letter **rounded down to the nearest whole percent**\\nI was using round() but it simply wants us to return previous integer !! \\nDescription is not correct !!!!!! "
                    },
                    {
                        "username": "nikhil-niks",
                        "content": "When I run the below code in Leetcode I am getting output as 0 whereas when I run this on my local I am getting output 33.Can someone help me where is the issue ?\\n\\nclass Solution(object):\\n    def percentageLetter(self, s, letter):\\n        totalLen = len(s)\\n        wordCount = 0\\n        for i in s:\\n            if i == letter:\\n                wordCount += 1\\n        return (int(wordCount)/int(totalLen))*100"
                    },
                    {
                        "username": "pranav_kumar_16",
                        "content": "(wordCount/totalLen) will give you 0  , so 0 * 100 results in 0. Instead use  (wordCount*100)/totalLen ."
                    },
                    {
                        "username": "bhuppidhamii",
                        "content": "`double ans = (static_cast<double>(count) / N) * 100;`\n `return static_cast<int>(ans);`\nEXPLAIN???"
                    },
                    {
                        "username": "PrashDev001",
                        "content": "1 Line Java\\n((double) s.chars().filter(c -> c == letter).count()/s.length())*100"
                    },
                    {
                        "username": "VamsidharReddyy",
                        "content": "c++:\\n\\nclass Solution {\\npublic:\\n    int percentageLetter(string s, char letter) {\\n        int count=0;\\n        int n=s.size();\\n        for(int i=0;i<s.size();i++){\\n            if(s[i]==letter) count++;\\n        }\\n        count*=100;\\n        \\n        return count/n;\\n    }\\n};"
                    },
                    {
                        "username": "anshumaan_1024",
                        "content": "\"cccaaa\" is not a valid value of type character\\nwhat does this mean ?"
                    },
                    {
                        "username": "Kartik_Bhasin",
                        "content": "wrong test case"
                    },
                    {
                        "username": "Nitish-Devarshi",
                        "content": "class Solution {\\npublic:\\n    int percentageLetter(string s, char l) {\\n        int count=0;\\n        int z=s.size();\\n        for(int i=0;i<z;i++){\\n            if(s[i]==l){\\n                count++;\\n            }\\n        }\\n        count=count*100;\\n        return count/z;\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1732835,
                "content": [
                    {
                        "username": "cjatherton19",
                        "content": "i wish every interview questions was like this "
                    },
                    {
                        "username": "Saad03",
                        "content": "When I run my code in jupyter notebook, I get correct ans whereas here I get error..can anyone tell me what the problem is?\\nclass Solution(object):\\n    def percentageLetter(self, s, letter):\\n        sLen=len(s)\\n        nLetter=s.count(letter)\\n        ans=(nLetter/sLen)*100\\n        return int(ans)\\n\\nwhen s=\"foobar\" and letter=\"o\"....I\\'m getting 0 insted of 33"
                    },
                    {
                        "username": "viking09_",
                        "content": "Use float for calculation and after convert the answer back to int and then return the answer"
                    },
                    {
                        "username": "Saad03",
                        "content": "[@papitochi](/papitochi) yeah its workin now.. I wonder why it didn\\'t work with the above code....anyways thanks :)\\n"
                    },
                    {
                        "username": "papitochi",
                        "content": "figured it out, try nletter*100/sLen"
                    },
                    {
                        "username": "papitochi",
                        "content": "same\\n"
                    },
                    {
                        "username": "fool_100",
                        "content": "return the percentage of characters in s that equal letter **rounded down to the nearest whole percent**\\nI was using round() but it simply wants us to return previous integer !! \\nDescription is not correct !!!!!! "
                    },
                    {
                        "username": "nikhil-niks",
                        "content": "When I run the below code in Leetcode I am getting output as 0 whereas when I run this on my local I am getting output 33.Can someone help me where is the issue ?\\n\\nclass Solution(object):\\n    def percentageLetter(self, s, letter):\\n        totalLen = len(s)\\n        wordCount = 0\\n        for i in s:\\n            if i == letter:\\n                wordCount += 1\\n        return (int(wordCount)/int(totalLen))*100"
                    },
                    {
                        "username": "pranav_kumar_16",
                        "content": "(wordCount/totalLen) will give you 0  , so 0 * 100 results in 0. Instead use  (wordCount*100)/totalLen ."
                    },
                    {
                        "username": "bhuppidhamii",
                        "content": "`double ans = (static_cast<double>(count) / N) * 100;`\n `return static_cast<int>(ans);`\nEXPLAIN???"
                    },
                    {
                        "username": "PrashDev001",
                        "content": "1 Line Java\\n((double) s.chars().filter(c -> c == letter).count()/s.length())*100"
                    },
                    {
                        "username": "VamsidharReddyy",
                        "content": "c++:\\n\\nclass Solution {\\npublic:\\n    int percentageLetter(string s, char letter) {\\n        int count=0;\\n        int n=s.size();\\n        for(int i=0;i<s.size();i++){\\n            if(s[i]==letter) count++;\\n        }\\n        count*=100;\\n        \\n        return count/n;\\n    }\\n};"
                    },
                    {
                        "username": "anshumaan_1024",
                        "content": "\"cccaaa\" is not a valid value of type character\\nwhat does this mean ?"
                    },
                    {
                        "username": "Kartik_Bhasin",
                        "content": "wrong test case"
                    },
                    {
                        "username": "Nitish-Devarshi",
                        "content": "class Solution {\\npublic:\\n    int percentageLetter(string s, char l) {\\n        int count=0;\\n        int z=s.size();\\n        for(int i=0;i<z;i++){\\n            if(s[i]==l){\\n                count++;\\n            }\\n        }\\n        count=count*100;\\n        return count/z;\\n    }\\n};"
                    }
                ]
            }
        ]
    }
]