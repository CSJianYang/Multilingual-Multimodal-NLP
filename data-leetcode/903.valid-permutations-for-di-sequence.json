[
    {
        "title": "Valid Permutations for DI Sequence",
        "question_content": "You are given a string s of length n where s[i] is either:\n\n\t'D' means decreasing, or\n\t'I' means increasing.\n\nA permutation perm of n + 1 integers of all the integers in the range [0, n] is called a valid permutation if for all valid i:\n\n\tIf s[i] == 'D', then perm[i] > perm[i + 1], and\n\tIf s[i] == 'I', then perm[i] < perm[i + 1].\n\nReturn the number of valid permutations perm. Since the answer may be large, return it modulo 109 + 7.\n&nbsp;\nExample 1:\n\nInput: s = \"DID\"\nOutput: 5\nExplanation: The 5 valid permutations of (0, 1, 2, 3) are:\n(1, 0, 3, 2)\n(2, 0, 3, 1)\n(2, 1, 3, 0)\n(3, 0, 2, 1)\n(3, 1, 2, 0)\n\nExample 2:\n\nInput: s = \"D\"\nOutput: 1\n\n&nbsp;\nConstraints:\n\n\tn == s.length\n\t1 <= n <= 200\n\ts[i] is either 'I' or 'D'.",
        "solutions": [
            {
                "id": 168278,
                "title": "c-java-python-dp-solution-o-n-2",
                "content": "# Intuition\\n`dp[i][j]` means the number of possible permutations of first `i + 1` digits,\\nwhere the `i + 1`th digit is `j + 1`th smallest in the rest of unused digits.\\n\\n\\nOk, may not make sense ... Let\\'s see the following diagram.\\n![image](https://s3-lc-upload.s3.amazonaws.com/users/lee215/image_1536486527.png)\\n\\nI take the example of `S = \"DID\"`.\\nIn the parenthesis, I list all possible permutations.\\n\\nThe permutation can start from `1, 2, 3, 4`.\\nSo `dp[0][0] = dp[0][1] = dp[0][2] = dp[0][3] = 1`.\\n\\nWe decrese from the first digit to the second,\\nthe down arrow show the all possibile decresing pathes.\\n\\nThe same, because we increase from the second digit to the third,\\nthe up arrow show the all possibile increasing pathes.\\n\\n`dp[2][1] = 5`, mean the number of permutations\\nwhere the third digitis the second smallest of the rest.\\nWe have 413,314,214,423,324.\\nFow example 413, where 2,3 are left and 3 the second smallest of them.\\n<br>\\n\\n# Explanation\\nAs shown in the diagram,\\nfor \"I\", we calculate prefix sum of the array,\\nfor \"D\", we calculate sufixsum of the array.\\n<br>\\n\\n# Complexity\\nTime `O(N^2)`\\nSpace `O(N^2)`\\n<br>\\n\\n**C++:**\\n```cpp\\n    int numPermsDISequence(string S) {\\n        int n = S.length(), mod = 1e9 + 7;\\n        vector<vector<int>> dp(n + 1, vector<int>(n + 1));\\n        for (int j = 0; j <= n; j++) dp[0][j] = 1;\\n        for (int i = 0; i < n; i++)\\n            if (S[i] == \\'I\\')\\n                for (int j = 0, cur = 0; j < n - i; j++)\\n                    dp[i + 1][j] = cur = (cur + dp[i][j]) % mod;\\n            else\\n                for (int j = n - i - 1, cur = 0; j >= 0; j--)\\n                    dp[i + 1][j] = cur = (cur + dp[i][j + 1]) % mod;\\n        return dp[n][0];\\n    }\\n```\\n\\n**Java:**\\n```java\\n    public int numPermsDISequence(String S) {\\n        int n = S.length(), mod = (int)1e9 + 7;\\n        int[][] dp = new int[n + 1][n + 1];\\n        for (int j = 0; j <= n; j++) dp[0][j] = 1;\\n        for (int i = 0; i < n; i++)\\n            if (S.charAt(i) == \\'I\\')\\n                for (int j = 0, cur = 0; j < n - i; j++)\\n                    dp[i + 1][j] = cur = (cur + dp[i][j]) % mod;\\n            else\\n                for (int j = n - i - 1, cur = 0; j >= 0; j--)\\n                    dp[i + 1][j] = cur = (cur + dp[i][j + 1]) % mod;\\n        return dp[n][0];\\n    }\\n```\\n\\n# Solution 2:\\nNow as we did for every DP, make it 1D dp.\\nTime `O(N^2)`\\nSpace `O(N)`\\n\\n**C++:**\\n```cpp\\n    int numPermsDISequence(string S) {\\n        int n = S.length(), mod = 1e9 + 7;\\n        vector<int> dp(n + 1, 1), dp2(n);\\n        for (int i = 0; i < n; dp = dp2, i++) {\\n            if (S[i] == \\'I\\')\\n                for (int j = 0, cur = 0; j < n - i; j++)\\n                    dp2[j] = cur = (cur + dp[j]) % mod;\\n            else\\n                for (int j = n - i - 1, cur = 0; j >= 0; j--)\\n                    dp2[j] = cur = (cur + dp[j + 1]) % mod;\\n        }\\n        return dp[0];\\n    }\\n```\\n\\n**Java:**\\n```java\\n    public int numPermsDISequence(String S) {\\n        int n = S.length(), mod = (int)1e9 + 7;\\n        int[] dp = new int[n + 1], dp2 = new int[n];;\\n        for (int j = 0; j <= n; j++) dp[j] = 1;\\n        for (int i = 0; i < n; i++) {\\n            if (S.charAt(i) == \\'I\\')\\n                for (int j = 0, cur = 0; j < n - i; j++)\\n                    dp2[j] = cur = (cur + dp[j]) % mod;\\n            else\\n                for (int j = n - i - 1, cur = 0; j >= 0; j--)\\n                    dp2[j] = cur = (cur + dp[j + 1]) % mod;\\n            dp = Arrays.copyOf(dp2, n);\\n        }\\n        return dp[0];\\n    }\\n```\\n\\n**Python2**\\n```py\\n    def numPermsDISequence(self, S):\\n        dp = [1] * (len(S) + 1)\\n        for c in S:\\n            if c == \"I\":\\n                dp = dp[:-1]\\n                for i in range(1, len(dp)):\\n                    dp[i] += dp[i - 1]\\n            else:\\n                dp = dp[1:]\\n                for i in range(len(dp) - 1)[::-1]:\\n                    dp[i] += dp[i + 1]\\n        return dp[0] % (10**9 + 7)\\n```\\n**Python3**\\n```py\\n    def numPermsDISequence(self, S):\\n        dp = [1] * (len(S) + 1)\\n        for a, b in zip(\\'I\\' + S, S):\\n            dp = list(itertools.accumulate(dp[:-1] if a == b else dp[-1:0:-1]))\\n        return dp[0] % (10**9 + 7)\\n```",
                "solutionTags": [],
                "code": "```cpp\\n    int numPermsDISequence(string S) {\\n        int n = S.length(), mod = 1e9 + 7;\\n        vector<vector<int>> dp(n + 1, vector<int>(n + 1));\\n        for (int j = 0; j <= n; j++) dp[0][j] = 1;\\n        for (int i = 0; i < n; i++)\\n            if (S[i] == \\'I\\')\\n                for (int j = 0, cur = 0; j < n - i; j++)\\n                    dp[i + 1][j] = cur = (cur + dp[i][j]) % mod;\\n            else\\n                for (int j = n - i - 1, cur = 0; j >= 0; j--)\\n                    dp[i + 1][j] = cur = (cur + dp[i][j + 1]) % mod;\\n        return dp[n][0];\\n    }\\n```\n```java\\n    public int numPermsDISequence(String S) {\\n        int n = S.length(), mod = (int)1e9 + 7;\\n        int[][] dp = new int[n + 1][n + 1];\\n        for (int j = 0; j <= n; j++) dp[0][j] = 1;\\n        for (int i = 0; i < n; i++)\\n            if (S.charAt(i) == \\'I\\')\\n                for (int j = 0, cur = 0; j < n - i; j++)\\n                    dp[i + 1][j] = cur = (cur + dp[i][j]) % mod;\\n            else\\n                for (int j = n - i - 1, cur = 0; j >= 0; j--)\\n                    dp[i + 1][j] = cur = (cur + dp[i][j + 1]) % mod;\\n        return dp[n][0];\\n    }\\n```\n```cpp\\n    int numPermsDISequence(string S) {\\n        int n = S.length(), mod = 1e9 + 7;\\n        vector<int> dp(n + 1, 1), dp2(n);\\n        for (int i = 0; i < n; dp = dp2, i++) {\\n            if (S[i] == \\'I\\')\\n                for (int j = 0, cur = 0; j < n - i; j++)\\n                    dp2[j] = cur = (cur + dp[j]) % mod;\\n            else\\n                for (int j = n - i - 1, cur = 0; j >= 0; j--)\\n                    dp2[j] = cur = (cur + dp[j + 1]) % mod;\\n        }\\n        return dp[0];\\n    }\\n```\n```java\\n    public int numPermsDISequence(String S) {\\n        int n = S.length(), mod = (int)1e9 + 7;\\n        int[] dp = new int[n + 1], dp2 = new int[n];;\\n        for (int j = 0; j <= n; j++) dp[j] = 1;\\n        for (int i = 0; i < n; i++) {\\n            if (S.charAt(i) == \\'I\\')\\n                for (int j = 0, cur = 0; j < n - i; j++)\\n                    dp2[j] = cur = (cur + dp[j]) % mod;\\n            else\\n                for (int j = n - i - 1, cur = 0; j >= 0; j--)\\n                    dp2[j] = cur = (cur + dp[j + 1]) % mod;\\n            dp = Arrays.copyOf(dp2, n);\\n        }\\n        return dp[0];\\n    }\\n```\n```py\\n    def numPermsDISequence(self, S):\\n        dp = [1] * (len(S) + 1)\\n        for c in S:\\n            if c == \"I\":\\n                dp = dp[:-1]\\n                for i in range(1, len(dp)):\\n                    dp[i] += dp[i - 1]\\n            else:\\n                dp = dp[1:]\\n                for i in range(len(dp) - 1)[::-1]:\\n                    dp[i] += dp[i + 1]\\n        return dp[0] % (10**9 + 7)\\n```\n```py\\n    def numPermsDISequence(self, S):\\n        dp = [1] * (len(S) + 1)\\n        for a, b in zip(\\'I\\' + S, S):\\n            dp = list(itertools.accumulate(dp[:-1] if a == b else dp[-1:0:-1]))\\n        return dp[0] % (10**9 + 7)\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 196939,
                "title": "easy-to-understand-solution-with-detailed-explanation",
                "content": "\\nBefore diving into the state transition function, let us first start with a simple example.\\n\\n### 1. a simple example\\n\\nIn the following discussion, for simplification, I will use both notation DI-seq and DI-rule instead of DI sequence.\\n\\nConsider a permutation 1032, which is based on a DI-seq \"DID\", how to use it to construct a new instance ending at **2** and based on DI-seq \"DID**D**\"?\\n\\n**Method**:\\nstep 1.\\nfor the original permutation `1032`, we add 1 to the digits *that are larger than or equal to* **2**.\\n```C++\\n1032->1043\\n  ^^\\n```\\n\\nstep 2.\\nthen directly append **2**  to `1043`,  i.e., 1043 -> 1043**2**\\n\\n**Remark on step 1**:\\n(1) By performing add operation, 2 in the original permutation now becomes 3, and thus there is no duplicate element for the new arrival **2**.\\n(2) More importantly, such operation on the digits **will not break the original DI-rule**. e.g., 1043 still keeps its old DI-rule, i.e., \"DID\". The proof is straight-forward,  you can validate yourself.\\n\\nNow a new permutation with DI-rule \"DID**D**\" and ending at **2** has been constructed from 1032, namely 1043**2**.\\n\\n\\nWith the same spirit, using 1032(\"DID\"), we can construct instances with DI-rule \"DID**D**\": 2043**1**(ending with **1**), 2143**0**(ending with **0**).\\n(Note that the instance(based on \"DID**D**\") which ends with 3 can not be constructed.)\\n\\n\\n\\nSimilarly, from 1032(\"DID\"), we can construct instances with DI-rule \"DID**I**\": 10423(ending with **3**), 10324(ending with **4**).\\n(Note that the instance(based on \"DID**I**\") which ends with 1 or 2 can not be constructed.)\\n\\n\\n\\n### 2. state transition function\\n\\nWith the example above in mind, the transition function seems to be clear.\\n\\nGiven a string DI-seq S, let `dp[i][j]` represents the number of permutation of number `0, 1, ... , i`, satisfying DI-rule S.substr(0, i), and ending with digit `j`.\\n\\n\\n```C++\\nif(S[i-1] == \\'D\\')\\n   dp[i][j] = dp[i-1][j] + dp[i-1][j+1] + ... + dp[i-1][i-1]\\n\\nif(S[i-1] == \\'I\\') \\n   dp[i][j] = dp[i-1][0] + dp[i-1][1] + ... + dp[i-1][j-1]\\n```\\n\\n\\n\\n\\n### 3.  Solution\\n\\n```C++\\nlass Solution {\\npublic:\\n    int numPermsDISequence(string S) {\\n        int n = S.size(), m = 1e9 + 7;\\n        vector<vector<int>> dp(n+1, vector<int>(n+1, 0));\\n        dp[0][0] = 1;\\n        for(int i = 1; i <= n; i++)\\n            for(int j = 0; j <= i; j++)\\n                if(S[i-1] == \\'D\\')\\n                    for(int k = j; k <= i-1; k++)\\n                        dp[i][j] = dp[i][j]%m + dp[i-1][k]%m;\\n                else\\n                    for(int k = 0; k <= j-1; k++)\\n                        dp[i][j] = dp[i][j]%m + dp[i-1][k]%m;\\n        int res = 0;\\n        for(int i = 0; i <= n; i++)\\n            res = res%m + dp[n][i]%m;\\n        return res%m;\\n    }\\n};\\n```\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n",
                "solutionTags": [],
                "code": "```C++\\n1032->1043\\n  ^^\\n```\n```C++\\nif(S[i-1] == \\'D\\')\\n   dp[i][j] = dp[i-1][j] + dp[i-1][j+1] + ... + dp[i-1][i-1]\\n\\nif(S[i-1] == \\'I\\') \\n   dp[i][j] = dp[i-1][0] + dp[i-1][1] + ... + dp[i-1][j-1]\\n```\n```C++\\nlass Solution {\\npublic:\\n    int numPermsDISequence(string S) {\\n        int n = S.size(), m = 1e9 + 7;\\n        vector<vector<int>> dp(n+1, vector<int>(n+1, 0));\\n        dp[0][0] = 1;\\n        for(int i = 1; i <= n; i++)\\n            for(int j = 0; j <= i; j++)\\n                if(S[i-1] == \\'D\\')\\n                    for(int k = j; k <= i-1; k++)\\n                        dp[i][j] = dp[i][j]%m + dp[i-1][k]%m;\\n                else\\n                    for(int k = 0; k <= j-1; k++)\\n                        dp[i][j] = dp[i][j]%m + dp[i-1][k]%m;\\n        int res = 0;\\n        for(int i = 0; i <= n; i++)\\n            res = res%m + dp[n][i]%m;\\n        return res%m;\\n    }\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 168612,
                "title": "top-down-with-memo-bottom-up-dp-n-3-dp-n-2-dp-o-n-space",
                "content": "**Top-down with Memo:**\\n\\nDefinition: `helper(String s, Map<String, Long> map)`: Answer to `s`.\\n\\nIntuition: Insert the largest number into appropriate postion.\\n\\neg. `s=\\'IIDD\\'`, we can only insert `4` between `I` and `D`. We break the remained numbers `0, 1, 2, 3` into two groups both with the size of 2. We have `C(4, 2)` possible combinations. Then `helper(\"IIDD\") = helper(\"I\") * helper(\"D\") * C(4, 2)`.\\n\\nTricky: How to calculate `C(n, k) % M`? I referred a method using *Pascal Triangle* from [here](https://www.geeksforgeeks.org/compute-ncr-p-set-1-introduction-and-dynamic-programming-solution/). (This part makes this method ugly and lengthy, anybody has better approaches?)\\n\\nTime complexity: `O(n^4)` in my implementation, however could improve to `O(n^3)`.\\n\\nCode:\\n\\n```\\nclass Solution {\\n    private int M = (int)1e9 + 7;\\n    private int[][] nCkMemo;\\n    public int numPermsDISequence(String S) {\\n        int n = S.length();\\n        nCkMemo = new int[n + 1][n + 1];\\n        return (int)helper(S, new HashMap<>());\\n    }\\n    private long helper(String s, Map<String, Long> map) {\\n        if (s.equals(\"\")) {\\n            return 1;\\n        }\\n        if (map.containsKey(s)) {\\n            return map.get(s);\\n        }\\n        long result = 0;\\n        int n = s.length();\\n        if (s.charAt(0) == \\'D\\') {\\n            result += helper(s.substring(1), map);\\n            result %= M;\\n        }\\n        if (s.charAt(n - 1) == \\'I\\') {\\n            result += helper(s.substring(0, n - 1), map);\\n            result %= M;\\n        }\\n        for (int i = 1; i < n; i++) {\\n            if (s.charAt(i - 1) == \\'I\\' && s.charAt(i) == \\'D\\') {\\n                long left = helper(s.substring(0, i - 1), map);\\n                long right = helper(s.substring(i + 1), map);\\n                result += (((left * right) % M) * nCk(n, i)) % M;\\n                result %= M;\\n            }\\n        }\\n        map.put(s, result);\\n        return result;\\n    }\\n    private int nCk(int n, int k) {\\n        if (k == 0 || k == n) {\\n            return 1;\\n        }\\n        if (nCkMemo[n][k] == 0) {\\n            nCkMemo[n][k] = (nCk(n - 1, k) + nCk(n - 1, k - 1)) % M;\\n        }\\n        return nCkMemo[n][k];\\n    }\\n}\\n```\\n\\n**Bottom-up DP:**\\n\\nSame idea with the Top-down. `dp[i][j]` represent the answer of `s.substring(i, j)`. Just a Bottom-up implementation:\\n\\nTime complexity: `O(n^3)`\\n\\n```\\nclass Solution {\\n    private int M = (int)1e9 + 7;\\n    public int numPermsDISequence(String S) {\\n        int n = S.length();\\n        long[][] dp = new long[n + 1][n + 1];\\n        int[][] nCkMemo = new int[n + 1][n + 1];\\n        for (int i = 0; i <= n; i++) {\\n            dp[i][i] = 1;\\n        }\\n        for (int len = 1; len <= n; len++) {\\n            for (int i = 0; i <= n - len; i++) {\\n                int j = i + len;\\n                if (S.charAt(i) == \\'D\\') {\\n                    dp[i][j] += dp[i + 1][j];\\n                    dp[i][j] %= M;\\n                }\\n                for (int k = i + 1; k < j; k++) {\\n                    if (S.charAt(k - 1) == \\'I\\' && S.charAt(k) == \\'D\\') {\\n                        dp[i][j] += (((dp[i][k - 1] * dp[k + 1][j]) % M) * nCk(len, k - i, nCkMemo)) % M;\\n                        dp[i][j] %= M;\\n                    }\\n                }\\n                if (S.charAt(j - 1) == \\'I\\') {\\n                    dp[i][j] += dp[i][j - 1];\\n                    dp[i][j] %= M;\\n                }\\n            }\\n        }\\n        return (int)dp[0][n];\\n    }\\n    private int nCk(int n, int k, int[][] nCkMemo) {\\n        if (k == 0 || k == n) {\\n            return 1;\\n        }\\n        if (nCkMemo[n][k] == 0) {\\n            nCkMemo[n][k] = (nCk(n - 1, k, nCkMemo) + nCk(n - 1, k - 1, nCkMemo)) % M;\\n        }\\n        return nCkMemo[n][k];\\n    }\\n}\\n```\\n\\n**N^3 DP:**\\n\\nLet\\'s change the definition of `dp` matrix to make the calculation simple: let\\'s say `dp[i][j]` represents the number of permutation of number `0, 1, ... , i` which ends with `j`. Also, it represents the answer of  `s.substring(0, i)` which ends with `j`.\\nWe will have two conditions: \\n\\n1. `s.charAt(i - 1) == \\'I\\'`: In this case, `dp[i][j] = sum(dp[i - 1][0], dp[i - 1][1], ... , dp[i - 1][j - 1])`.\\n2. `s.charAt(i - 1) == \\'D\\'`: In this case, `dp[i][j] = sum(dp[i - 1][j], dp[i - 1][j + 1], ... , dp[i - 1][i - 1])`.\\n\\nImagine each time when appending the `j` to the previous permutations, you have to **add 1 to each number in the previous permutation which is greater than or equals to `j`**. In this way, we keep the orders and counts of previous permutations and cumulate.\\n\\neg. We already have permutation `(1, 0, 3, 2)`. We are trying to append `2`. Now the `(1, 0, 3, 2)` changes to `(1, 0, 4, 3)` then appended with a `2`. We have `(1, 0, 4, 3, 2)`. Although the values change but the order and count don\\'t change.\\n\\nTime complexity: `O(n^3)`\\n\\nCode:\\n\\n```\\nclass Solution {\\n    public int numPermsDISequence(String S) {\\n        int n = S.length(), M = (int)1e9 + 7;\\n        int[][] dp = new int[n + 1][n + 1];\\n        dp[0][0] = 1;\\n        for (int i = 1; i <= n; i++) {\\n            for (int j = 0; j <= i; j++) {\\n                if (S.charAt(i - 1) == \\'D\\') {\\n                    for (int k = j; k < i; k++) {\\n                        dp[i][j] += dp[i - 1][k];\\n                        dp[i][j] %= M;\\n                    }\\n                } else {\\n                    for (int k = 0; k < j; k++) {\\n                        dp[i][j] += dp[i - 1][k];\\n                        dp[i][j] %= M;\\n                    }\\n                }\\n            }\\n        }\\n        int result = 0;\\n        for (int j = 0; j <= n; j++) {\\n            result += dp[n][j];\\n            result %= M;\\n        }\\n        return result;\\n    }\\n}\\n```\\n\\n **N^2 DP:**\\n \\n Notice that in the previous method, we are actually calculate the **prefix sum** and **suffix sum**  in the two conditions:\\n \\n1. `s.charAt(i - 1) == \\'I\\'`: In this case, `dp[i][j] = sum[i - 1][j - 1]`.\\n2. `s.charAt(i - 1) == \\'D\\'`: In this case, `dp[i][j] = sum[i - 1][i - 1] - sum[i - 1][j - 1]`.\\n\\nWe can define `dp[i][j]` as `sum(dp[i][0], dp[i][1], ... dp[i][j])` which is `sum[i][j]`.\\n\\nTime complexity: `O(n^2)`\\n\\nCode:\\n\\n```\\nclass Solution {\\n    public int numPermsDISequence(String S) {\\n        int n = S.length(), M = (int)1e9 + 7;\\n        int[][] dp = new int[n + 1][n + 1];\\n        Arrays.fill(dp[0], 1);\\n        for (int i = 1; i <= n; i++) {\\n            for (int j = 0; j <= i; j++) {\\n                dp[i][j] = j == 0 ? 0 : dp[i][j - 1];\\n                if (S.charAt(i - 1) == \\'D\\') {\\n                    dp[i][j] += (dp[i - 1][i - 1] - (j == 0 ? 0 : dp[i - 1][j - 1])) % M;\\n                    if (dp[i][j] < 0) {\\n                        dp[i][j] += M;\\n                    }\\n                } else {\\n                    dp[i][j] += j == 0 ? 0 : dp[i - 1][j - 1];\\n                }\\n                dp[i][j] %= M;\\n            }\\n        }\\n        return dp[n][n];\\n    }\\n}\\n```\\n\\n**O(N) space:**\\n\\nPrevious solution could be optimized to `O(n)` space.\\n\\nTime complexity: `O(n^2)`. Space complexity: `O(n)`.\\n\\n```\\nclass Solution {\\n    public int numPermsDISequence(String S) {\\n        int n = S.length(), M = (int)1e9 + 7;\\n        int[] dp = new int[n + 1];\\n        Arrays.fill(dp, 1);\\n        for (int i = 1; i <= n; i++) {\\n            int[] temp = new int[n + 1];\\n            for (int j = 0; j <= i; j++) {\\n                temp[j] = j == 0 ? 0 : temp[j - 1];\\n                if (S.charAt(i - 1) == \\'D\\') {\\n                    temp[j] += (dp[i - 1] - (j == 0 ? 0 : dp[j - 1])) % M;\\n                    if (temp[j] < 0) {\\n                        temp[j] += M;\\n                    }\\n                } else {\\n                    temp[j] += j == 0 ? 0 : dp[j - 1];\\n                }\\n                temp[j] %= M;\\n            }\\n            dp = temp;\\n        }\\n        return dp[n];\\n    }\\n}\\n```\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    private int M = (int)1e9 + 7;\\n    private int[][] nCkMemo;\\n    public int numPermsDISequence(String S) {\\n        int n = S.length();\\n        nCkMemo = new int[n + 1][n + 1];\\n        return (int)helper(S, new HashMap<>());\\n    }\\n    private long helper(String s, Map<String, Long> map) {\\n        if (s.equals(\"\")) {\\n            return 1;\\n        }\\n        if (map.containsKey(s)) {\\n            return map.get(s);\\n        }\\n        long result = 0;\\n        int n = s.length();\\n        if (s.charAt(0) == \\'D\\') {\\n            result += helper(s.substring(1), map);\\n            result %= M;\\n        }\\n        if (s.charAt(n - 1) == \\'I\\') {\\n            result += helper(s.substring(0, n - 1), map);\\n            result %= M;\\n        }\\n        for (int i = 1; i < n; i++) {\\n            if (s.charAt(i - 1) == \\'I\\' && s.charAt(i) == \\'D\\') {\\n                long left = helper(s.substring(0, i - 1), map);\\n                long right = helper(s.substring(i + 1), map);\\n                result += (((left * right) % M) * nCk(n, i)) % M;\\n                result %= M;\\n            }\\n        }\\n        map.put(s, result);\\n        return result;\\n    }\\n    private int nCk(int n, int k) {\\n        if (k == 0 || k == n) {\\n            return 1;\\n        }\\n        if (nCkMemo[n][k] == 0) {\\n            nCkMemo[n][k] = (nCk(n - 1, k) + nCk(n - 1, k - 1)) % M;\\n        }\\n        return nCkMemo[n][k];\\n    }\\n}\\n```\n```\\nclass Solution {\\n    private int M = (int)1e9 + 7;\\n    public int numPermsDISequence(String S) {\\n        int n = S.length();\\n        long[][] dp = new long[n + 1][n + 1];\\n        int[][] nCkMemo = new int[n + 1][n + 1];\\n        for (int i = 0; i <= n; i++) {\\n            dp[i][i] = 1;\\n        }\\n        for (int len = 1; len <= n; len++) {\\n            for (int i = 0; i <= n - len; i++) {\\n                int j = i + len;\\n                if (S.charAt(i) == \\'D\\') {\\n                    dp[i][j] += dp[i + 1][j];\\n                    dp[i][j] %= M;\\n                }\\n                for (int k = i + 1; k < j; k++) {\\n                    if (S.charAt(k - 1) == \\'I\\' && S.charAt(k) == \\'D\\') {\\n                        dp[i][j] += (((dp[i][k - 1] * dp[k + 1][j]) % M) * nCk(len, k - i, nCkMemo)) % M;\\n                        dp[i][j] %= M;\\n                    }\\n                }\\n                if (S.charAt(j - 1) == \\'I\\') {\\n                    dp[i][j] += dp[i][j - 1];\\n                    dp[i][j] %= M;\\n                }\\n            }\\n        }\\n        return (int)dp[0][n];\\n    }\\n    private int nCk(int n, int k, int[][] nCkMemo) {\\n        if (k == 0 || k == n) {\\n            return 1;\\n        }\\n        if (nCkMemo[n][k] == 0) {\\n            nCkMemo[n][k] = (nCk(n - 1, k, nCkMemo) + nCk(n - 1, k - 1, nCkMemo)) % M;\\n        }\\n        return nCkMemo[n][k];\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public int numPermsDISequence(String S) {\\n        int n = S.length(), M = (int)1e9 + 7;\\n        int[][] dp = new int[n + 1][n + 1];\\n        dp[0][0] = 1;\\n        for (int i = 1; i <= n; i++) {\\n            for (int j = 0; j <= i; j++) {\\n                if (S.charAt(i - 1) == \\'D\\') {\\n                    for (int k = j; k < i; k++) {\\n                        dp[i][j] += dp[i - 1][k];\\n                        dp[i][j] %= M;\\n                    }\\n                } else {\\n                    for (int k = 0; k < j; k++) {\\n                        dp[i][j] += dp[i - 1][k];\\n                        dp[i][j] %= M;\\n                    }\\n                }\\n            }\\n        }\\n        int result = 0;\\n        for (int j = 0; j <= n; j++) {\\n            result += dp[n][j];\\n            result %= M;\\n        }\\n        return result;\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public int numPermsDISequence(String S) {\\n        int n = S.length(), M = (int)1e9 + 7;\\n        int[][] dp = new int[n + 1][n + 1];\\n        Arrays.fill(dp[0], 1);\\n        for (int i = 1; i <= n; i++) {\\n            for (int j = 0; j <= i; j++) {\\n                dp[i][j] = j == 0 ? 0 : dp[i][j - 1];\\n                if (S.charAt(i - 1) == \\'D\\') {\\n                    dp[i][j] += (dp[i - 1][i - 1] - (j == 0 ? 0 : dp[i - 1][j - 1])) % M;\\n                    if (dp[i][j] < 0) {\\n                        dp[i][j] += M;\\n                    }\\n                } else {\\n                    dp[i][j] += j == 0 ? 0 : dp[i - 1][j - 1];\\n                }\\n                dp[i][j] %= M;\\n            }\\n        }\\n        return dp[n][n];\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public int numPermsDISequence(String S) {\\n        int n = S.length(), M = (int)1e9 + 7;\\n        int[] dp = new int[n + 1];\\n        Arrays.fill(dp, 1);\\n        for (int i = 1; i <= n; i++) {\\n            int[] temp = new int[n + 1];\\n            for (int j = 0; j <= i; j++) {\\n                temp[j] = j == 0 ? 0 : temp[j - 1];\\n                if (S.charAt(i - 1) == \\'D\\') {\\n                    temp[j] += (dp[i - 1] - (j == 0 ? 0 : dp[j - 1])) % M;\\n                    if (temp[j] < 0) {\\n                        temp[j] += M;\\n                    }\\n                } else {\\n                    temp[j] += j == 0 ? 0 : dp[j - 1];\\n                }\\n                temp[j] %= M;\\n            }\\n            dp = temp;\\n        }\\n        return dp[n];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 168289,
                "title": "share-my-o-n-3-o-n-2-c-dp-solution-including-the-thoughts-of-improvement",
                "content": "Came up with the original idea during contest, so might not be the best. But it works.\\n```c++\\nclass Solution {\\npublic:\\n    int numPermsDISequence(string S) {\\n        int N = S.length() + 1;\\n        int MOD = 1e9 + 7;\\n        // dp[i][j] number of permutation whose length is i and end with j\\n        int dp[202][202] = {};\\n        dp[1][1] = 1;\\n        for (int i = 2; i <= N; ++i) {\\n            // length is i\\n            for (int j = 1; j <= i; ++j) {\\n                // end with j\\n                if (S[i - 2] == \\'D\\') {\\n                    // decrease to j\\n                    // add all string with length i - 1 and last digit is greater than or equal to j\\n                    for (int k = j; k <= i; ++k) {\\n                        dp[i][j] = (dp[i][j] + dp[i-1][k]) % MOD;\\n                    }\\n                } else {\\n                    // increase to j\\n                    // add all string with length i - 1 and last digit is smaller than j\\n                    for (int k = 1; k < j; ++k) {\\n                        dp[i][j] = (dp[i][j] + dp[i-1][k]) % MOD;\\n                    }\\n                }\\n            }\\n        }\\n        int ans = 0;\\n        for (int i = 1; i <= N; ++i) ans = (ans + dp[N][i]) % MOD;\\n        return ans;\\n    }\\n};\\n```\\n\\n**UPDATE 9/9/2018**:\\nThanks to `@chosun1`, I used prefix sum to save the result which reduce the complexity to O(N ^ 2). There is no need to keep a separate 2d array for prefix sum, just change the definition of dp array is fine. Here is the updated code, it is even shorter.\\n\\n`dp[i][j]` means number of permutation whose length is `i` and end with **at most** `j`.\\n\\nLet\\'s say the current position of DI sequence is `\\'D\\'`, \\nSo, `dp[i][j] = dp[i][j-1] + X`, where `X` is number of permutations whose length is `i` and end exactly with `j`. We can calculate it by adding number of permutations whose length is `i-1` and end with `{j, j+1, ..., i-1}`, because they will satisfy the condition of \"decreasing to j\". (*Wait! Wait! Why start with j not j + 1?, see the bolded explaination below.*)\\nAccording to the definition of dp array, we can get `X = dp[i-1][i-1] - dp[i-1][j-1]`.\\n\\nIf the DI sequence is `\\'I\\'`, it\\'s similiar.\\n\\n**So, why start with j, not j + 1, since the sequence is decreasing to j?**\\n`Thought Experiment`: In the sequence with length of `i-1`, the largest number in this sequence should be `i-1`. However, when we are dealing with length `i` and end with `j`, the previous sequence has already another `j` and we should also add `i` to the sequence. What we can do is, **add one to all those numbers greater than or equal to j**. This operation will make the largest number to be `i` without breaking the sequence property, also, it will free the `j` so that we can use it at the end of the sequence. By this thought experiment, we can easily get the result of `X`. For example, if the sequence is `{3,4,1,2,5}` and we want to expand it to be of length 6 and end with 3. We first make it to be `{3->4,4->5,1,2,5->6}`, and then, add 3 to the end of the sequence.\\n\\n```c++\\nclass Solution {\\npublic:\\n    int numPermsDISequence(string S) {\\n        int N = S.length() + 1;\\n        int MOD = 1e9 + 7;\\n        // dp[i][j] means number of permutation whose length is i and end with at most j.\\n        int dp[202][202] = {};\\n        dp[1][1] = 1;\\n        for (int i = 2; i <= N; ++i) {\\n            // length is i\\n            for (int j = 1; j <= i; ++j) {\\n                // end with j\\n                if (S[i - 2] == \\'D\\') {\\n                    // decrease to j\\n                    dp[i][j] = (dp[i][j-1] + (dp[i-1][i-1] - dp[i-1][j-1]) % MOD) % MOD;\\n                } else {\\n                    // increase to j\\n                    dp[i][j] = (dp[i][j-1] + (dp[i-1][j-1] - dp[i-1][0]) % MOD) % MOD;\\n                }\\n            }\\n        }\\n        return (dp[N][N] + MOD) % MOD;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```c++\\nclass Solution {\\npublic:\\n    int numPermsDISequence(string S) {\\n        int N = S.length() + 1;\\n        int MOD = 1e9 + 7;\\n        // dp[i][j] number of permutation whose length is i and end with j\\n        int dp[202][202] = {};\\n        dp[1][1] = 1;\\n        for (int i = 2; i <= N; ++i) {\\n            // length is i\\n            for (int j = 1; j <= i; ++j) {\\n                // end with j\\n                if (S[i - 2] == \\'D\\') {\\n                    // decrease to j\\n                    // add all string with length i - 1 and last digit is greater than or equal to j\\n                    for (int k = j; k <= i; ++k) {\\n                        dp[i][j] = (dp[i][j] + dp[i-1][k]) % MOD;\\n                    }\\n                } else {\\n                    // increase to j\\n                    // add all string with length i - 1 and last digit is smaller than j\\n                    for (int k = 1; k < j; ++k) {\\n                        dp[i][j] = (dp[i][j] + dp[i-1][k]) % MOD;\\n                    }\\n                }\\n            }\\n        }\\n        int ans = 0;\\n        for (int i = 1; i <= N; ++i) ans = (ans + dp[N][i]) % MOD;\\n        return ans;\\n    }\\n};\\n```\n```c++\\nclass Solution {\\npublic:\\n    int numPermsDISequence(string S) {\\n        int N = S.length() + 1;\\n        int MOD = 1e9 + 7;\\n        // dp[i][j] means number of permutation whose length is i and end with at most j.\\n        int dp[202][202] = {};\\n        dp[1][1] = 1;\\n        for (int i = 2; i <= N; ++i) {\\n            // length is i\\n            for (int j = 1; j <= i; ++j) {\\n                // end with j\\n                if (S[i - 2] == \\'D\\') {\\n                    // decrease to j\\n                    dp[i][j] = (dp[i][j-1] + (dp[i-1][i-1] - dp[i-1][j-1]) % MOD) % MOD;\\n                } else {\\n                    // increase to j\\n                    dp[i][j] = (dp[i][j-1] + (dp[i-1][j-1] - dp[i-1][0]) % MOD) % MOD;\\n                }\\n            }\\n        }\\n        return (dp[N][N] + MOD) % MOD;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 715588,
                "title": "how-to-define-the-dp-states-with-clear-picture-explanation",
                "content": "When I tried to understand lee215\\'s [solution](https://leetcode.com/problems/valid-permutations-for-di-sequence/discuss/168278/C++JavaPython-DP-Solution-O(N2)), I got stuck. Then I redescribe this process to better understand the whole process. Credits go to lee215.  \\nThe intuition is: given a string s, results of the number of permutations for the following strings are the same.\\n```\\n0,1,2\\n1,2,3\\n1,2,4\\n```\\n\\nBased on this observation, we can use the index of the sorted unused digits to aggregate the results.\\nI am going to improve the illustration and also state definition.\\nDefine the state of DP[i][j] as:\\n- i is the digit index.\\n- j is the **index** of current digit from sorted(current digit + remaining digits).\\n\\nThe reason we define j in this way is:\\nAll the following will have the same results based on the same string S.\\n```\\n0, 1,2\\n1,2,3\\n1,2,4\\n```\\nWe can use index to have an unified representation.\\n```\\n0, 1, 2   ->   0, 1,  2\\n1, 2, 3   ->   0, 1,  2\\n1, 2, 4   ->   0, 1,  2\\n```\\nAfter figuring out this, the transitions can be shown as below:![image](https://assets.leetcode.com/users/images/d146760c-7121-409f-be5d-a7d406029ae0_1623956092.467306.png)\\n\\n\\nMore detail can be found [Here.](https://medium.com/@jim.morris.shen/hard-dp-77774c6a4695?source=friends_link&sk=d901fef6067a08fdbb184acfdeb8cf5e)\\n\\nAfter figuring out the state transitions, then the code is pretty simple.\\nif \"D\": postfix sum\\nif \\'I\\': prefix sum\\n```\\n/*\\njimmy shen\\nTime complexity: O(n^2)\\nSpace complexity: O(n)\\n*/\\n\\nint MOD = 1e9+7;\\nclass Solution {\\npublic:\\n    int numPermsDISequence(string S) {\\n        int N = S.size();\\n        vector<int> dp(N+1, 1);\\n        for (int i=1;i<N+1;++i){\\n            int M = (N+1)-i;\\n            vector<int> new_dp(M, 0);\\n            if (S[i-1]==\\'D\\'){\\n                //postfix sum\\n                for (int j=dp.size()-2;j>=0;--j){\\n                    dp[j] += dp[j+1]; \\n                    if (dp[j]>=MOD)dp[j] %= MOD;\\n                }\\n                for (int j=0;j<M;++j){\\n                    new_dp[j] = dp[j+1];\\n                }\\n            }\\n            else{\\n                //prefix sum\\n                for (int j=1;j<dp.size();++j){\\n                    dp[j] += dp[j-1]; \\n                    if (dp[j]>=MOD)dp[j] %= MOD;\\n                }\\n                for (int j=0;j<M;++j){\\n                    new_dp[j] = dp[j];\\n                }\\n            }\\n            dp = new_dp;\\n        }\\n        int ret = 0;\\n        for (int i=0;i<dp.size();++i){\\n            ret+=dp[i];\\n            if (ret>=MOD)ret %= MOD;}\\n        return ret;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n0,1,2\\n1,2,3\\n1,2,4\\n```\n```\\n0, 1,2\\n1,2,3\\n1,2,4\\n```\n```\\n0, 1, 2   ->   0, 1,  2\\n1, 2, 3   ->   0, 1,  2\\n1, 2, 4   ->   0, 1,  2\\n```\n```\\n/*\\njimmy shen\\nTime complexity: O(n^2)\\nSpace complexity: O(n)\\n*/\\n\\nint MOD = 1e9+7;\\nclass Solution {\\npublic:\\n    int numPermsDISequence(string S) {\\n        int N = S.size();\\n        vector<int> dp(N+1, 1);\\n        for (int i=1;i<N+1;++i){\\n            int M = (N+1)-i;\\n            vector<int> new_dp(M, 0);\\n            if (S[i-1]==\\'D\\'){\\n                //postfix sum\\n                for (int j=dp.size()-2;j>=0;--j){\\n                    dp[j] += dp[j+1]; \\n                    if (dp[j]>=MOD)dp[j] %= MOD;\\n                }\\n                for (int j=0;j<M;++j){\\n                    new_dp[j] = dp[j+1];\\n                }\\n            }\\n            else{\\n                //prefix sum\\n                for (int j=1;j<dp.size();++j){\\n                    dp[j] += dp[j-1]; \\n                    if (dp[j]>=MOD)dp[j] %= MOD;\\n                }\\n                for (int j=0;j<M;++j){\\n                    new_dp[j] = dp[j];\\n                }\\n            }\\n            dp = new_dp;\\n        }\\n        int ret = 0;\\n        for (int i=0;i<dp.size();++i){\\n            ret+=dp[i];\\n            if (ret>=MOD)ret %= MOD;}\\n        return ret;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 707459,
                "title": "python-dp-approach-some-explanation",
                "content": "Most of us here are preparing for programming Interviews and those interviews have a threshold of about 45 minutes, and you have to come-up with an approach, write code, and explain. If you spend some time on the discuss section, you will realize there are some awesome solutions, which take you more than an interview-time to understand, let alone to come-up and code it. You may probably not hit the cool greedy solution, or the most optimized DP within time (though with time you will improve) but you should first practice to be able to solve the problem **within time**.\\nIt is often helpful to keep a timer of 45 minutes to solve these problems, even if you are not able to solve it you will get enough understanding to explain your approaches and why those won\\'t work out? Then move to discuss sections and try to understand a solution in 10-20 minutes. If you are able to understand in this time, you can code in the remaining time.\\n\\nSo, the following is what I came up within ~45 minutes:\\nThis problem clearly speaks for a Dynamic Programmic approach. \\nYou can imagine a state graph, \\n* last state can have any values between [0, n]\\n* if the last step was \\'D\\', the previous state can have only a higher value than what at the last state. Similarly, a lower value if step was \\'I\\'.\\n* and the combination should be unique.\\n\\nThe third point, required some book-keeping of what numbers have appeared already. And I started out with a solution to keep the mask (as a tuple) (which as you may already know, won\\'t work). After much brainstorming, I realized that it is not required to keep the details of which numbers (specifically) have appeared. It would just suffice to keep the details of the number of numbers haven\\'t appeared and how many of them are lower (or higher) than the last number.\\n\\n```python\\nclass Solution:\\n    def numPermsDISequence(self, S: str) -> int:\\n        N = len(S)\\n        MOD = 10**9 + 7\\n        \\n        @lru_cache(None)\\n        def dp(i, less, more):\\n            res = 0\\n            if(i < 0): return 1\\n            if(less + more == 0): return 0\\n            if(S[i] == \\'I\\'):\\n                for k in range(less):\\n                    res = (res + dp(i-1, k, less - k -1 + more)) % MOD\\n            elif(S[i] == \\'D\\'):\\n                for k in range(more):\\n                    res = (res + dp(i-1, less + k, more - k - 1)) % MOD\\n            return res\\n        \\n        return sum(dp(N-1, k, N-k) for k in range(N+1)) % MOD\\n```",
                "solutionTags": [],
                "code": "```python\\nclass Solution:\\n    def numPermsDISequence(self, S: str) -> int:\\n        N = len(S)\\n        MOD = 10**9 + 7\\n        \\n        @lru_cache(None)\\n        def dp(i, less, more):\\n            res = 0\\n            if(i < 0): return 1\\n            if(less + more == 0): return 0\\n            if(S[i] == \\'I\\'):\\n                for k in range(less):\\n                    res = (res + dp(i-1, k, less - k -1 + more)) % MOD\\n            elif(S[i] == \\'D\\'):\\n                for k in range(more):\\n                    res = (res + dp(i-1, less + k, more - k - 1)) % MOD\\n            return res\\n        \\n        return sum(dp(N-1, k, N-k) for k in range(N+1)) % MOD\\n```",
                "codeTag": "Java"
            },
            {
                "id": 186571,
                "title": "python-o-n-3-o-n-2-time-o-n-space-dp-solution-with-clear-explanation-no-relative-rank-stuff",
                "content": "Since I didn\\'t understand the relative rank stuff, I found this problem to be quite confusing until I saw this thread:\\nhttps://leetcode.com/problems/valid-permutations-for-di-sequence/discuss/169126/Visualization-Key-to-the-DP-solution:-imagine-cutting-a-piece-of-paper-and-separating-the-halves\\n\\n**Property: If we increment elements that are greater than or equal to a certain value the D or I property will not be broken, as this only makes \"larger\" elements even larger.**\\n\\nFrom this point, it is easier to see where the dynamic programming essence comes in. Basically the number of solutions with length i depends on, and can be derived from, the number of solutions with length i-1, as follows:\\n\\n    We increment all elements that are greater than or equal to 0, and see if we can append 0 to the end of the sequence.\\n    We increment all elements that are greater than or equal to 1, and see if we can append 1 to the end of the sequence.\\n    ...\\n    We increment all elements that are greater than or equal to i, and see if we can append i to the end of the sequence.\\n\\n**Therefore, we only care about the last number of each existing valid permutation.**\\n\\nFor each j in the range (0, i), we want to find the number of valid permutations of len i ending in j. \\n* When placing j following a decreasing instruction \\'D\\', we want the last number in the existing permutation to have a higher value. \\n* When placing j following an increasing instruction \\'I\\', we want the last number in the existing permutation to have a lower value. \\n\\nWe use two DP arrays of len(S)+1, dp and dp2. We swap dp and dp2 at the end of each step.\\n\\n**D:** 10\\nThe only valid permutation for \\'D\\' is 10.\\n* solutions ending with 0: 1\\n* solutions ending with 1: 0\\n\\n**DI:** 102, 201\\nWe want the last number in each existing permutation to have a lower value than j.\\n* \\\\# solutions ending with 0: 0\\nWe cannot add a 0 to any existing valid permutation, since the only valid permutation for \\'D\\' is 10.\\n* \\\\# solutions ending with 1: dp2[1] = dp[0], which is 1\\nWe have 1 solution ending with a 0 we can add a 0 to, since we want the last number in the permutation to have a lower value.\\n* \\\\# solutions ending with 2: dp2[2] = dp[0] + dp[1], which is 1\\nWe have 1 solution ending with a 0 we can add a 2 to, since we want the last number in the permutation to have a lower value.\\n\\n**DID:** 5 permutations\\nWe want the last number in each existing permutation to have a higher value than j. \\n* \\\\# of solutions ending with 0: dp[0] + dp[1] + dp[2] = 2\\nWe increment all elements in 102, 201 that are >= 0 to get 213 and 312, which we can add a 0 to.\\n* \\\\# solutions ending with 1: dp[1] + dp[2] = 2\\nWe increment all elements in 102, 201 that are >= 1 to get 203 and 302, which we can add a 1 to.\\n* \\\\# solutions ending with 2: dp[2] = 1\\nSimilarly, the permutation 102 becomes 103, which we can add a 2 to.\\n* \\\\# solutions ending with 3: 0\\n\\n**DIDI:** 16 permutations\\nFrom this point onward, only the number of permutations is listed for the sake of brevity.\\n\\nsolutions ending with 0: 0\\nsolutions ending with 1: 2 (dp[0])\\nsolutions ending with 2: 4 (dp[0] + dp[1])\\nsolutions ending with 3: 5 (dp[0] + dp[1] + dp[2])\\nsolutions ending with 4: 5 (dp[0] + dp[1] + dp[2] + dp[3])\\n\\nNow let\\'s see the two different outcomes for adding an I or D to that sequence:\\n\\n**DIDID:** 61 permutations\\nsolutions ending with 0: 16 (dp[0] + dp[1] + dp[2] + dp[3] + dp[4])\\nsolutions ending with 1: 16 (dp[1] + dp[2] + dp[3] + dp[4])\\nsolutions ending with 2: 14 (dp[2] + dp[3] + dp[4])\\nsolutions ending with 3: 10 (dp[3] + dp[4])\\nsolutions ending with 4: 5 (dp[4])\\nsolutions ending with 5: 0\\n\\n**DIDII:** 35 permutations\\nsolutions ending with 0: 0 \\nsolutions ending with 1: 0 (dp[0])\\nsolutions ending with 2: 2 (dp[0] + dp[1])\\nsolutions ending with 3: 6 (dp[0] + dp[1] + dp[2])\\nsolutions ending with 4: 11 (dp[0] + dp[1] + dp[2] + dp[3])\\nsolutions ending with 5: 16 (dp[0] + dp[1] + dp[2] + dp[3] + dp[4])\\n\\nYou might be able to notice a pattern here:\\nWhen placing j following a decreasing instruction \\'D\\', then dp2[j] = sum of dp[j] to dp[i-1]\\nWhen placing j following an increasing instruction \\'I\\', then dp2[j] = sum of dp[0] to dp[j-1]\\n\\nTherefore:\\n\\n```\\nclass Solution(object):\\n    def numPermsDISequence(self, S):\\n        \"\"\"\\n        :type S: str\\n        :rtype: int\\n        \"\"\"\\n        dp = [1 for c in range(len(S)+1)]\\n        dp2 = [0 for c in range(len(S)+1)]\\n        \\n        for i in range(1, len(S) + 1):\\n            if S[i-1] == \\'D\\':\\n                for j in range(i+1):\\n                    dp2[j] = sum(dp[j:i])\\n            else:\\n                for j in range(i+1):\\n                    dp2[j] = sum(dp[:j])\\n            dp, dp2 = dp2, dp\\n            \\n        return sum(dp) % 1000000007\\n```\\n\\t\\t\\n\\t\\t\\nThis solution is O(n^3)\\nInstead of having to use sum() each inner loop, you can calculate prefix/suffix sums in order to bring the runtime down to O(n^2)",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def numPermsDISequence(self, S):\\n        \"\"\"\\n        :type S: str\\n        :rtype: int\\n        \"\"\"\\n        dp = [1 for c in range(len(S)+1)]\\n        dp2 = [0 for c in range(len(S)+1)]\\n        \\n        for i in range(1, len(S) + 1):\\n            if S[i-1] == \\'D\\':\\n                for j in range(i+1):\\n                    dp2[j] = sum(dp[j:i])\\n            else:\\n                for j in range(i+1):\\n                    dp2[j] = sum(dp[:j])\\n            dp, dp2 = dp2, dp\\n            \\n        return sum(dp) % 1000000007\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2246618,
                "title": "why-backtracking-memoization-is-working",
                "content": "To all Coders of the Leetcode Community this post needs to be addressed \\nwhy this solution is working ??\\n```\\nclass Solution {\\npublic:\\n    \\n    int mod = 1e9 + 7;\\n    \\n    int n;\\n    \\n    vector<int> vis;\\n    \\n    int dp[202][202];\\n    \\n    long long func(int i,int j,string &s){\\n        if(i == n) return 1;\\n        if(dp[i][j] != -1) return dp[i][j];\\n        long long ans=0;\\n        if(s[i] == \\'D\\'){\\n            \\n            for(int k=j-1;k>=0;k--){\\n                if(vis[k] == false){\\n                    vis[k] = true;\\n                    long long tmp = func(i+1,k,s);\\n                    ans += tmp;\\n                    ans%=mod;\\n                    vis[k] = false;\\n                }\\n            }\\n        }else{\\n            for(int k=j+1;k<=n;k++){\\n                if(vis[k] == false){\\n                    vis[k] = true;\\n                    long long tmp = func(i+1,k,s);\\n                    ans += tmp;\\n                    ans%=mod;\\n                    vis[k] = false;\\n                }\\n            }\\n        }\\n        \\n        return dp[i][j] = ans;\\n        \\n    }\\n    \\n    int numPermsDISequence(string s) {\\n        \\n        n = s.size();\\n        memset(dp,-1,sizeof(dp));\\n        \\n        vis = vector<int> (n+1,false);\\n        \\n        long long ans = 0;\\n        for(int i=0;i<=n;i++){\\n            vis[i] = true;\\n            long long tmp = func(0,i,s);\\n            ans += tmp;\\n            ans%=mod;\\n            vis[i] = false;\\n        }\\n        \\n        return ans;\\n        \\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    \\n    int mod = 1e9 + 7;\\n    \\n    int n;\\n    \\n    vector<int> vis;\\n    \\n    int dp[202][202];\\n    \\n    long long func(int i,int j,string &s){\\n        if(i == n) return 1;\\n        if(dp[i][j] != -1) return dp[i][j];\\n        long long ans=0;\\n        if(s[i] == \\'D\\'){\\n            \\n            for(int k=j-1;k>=0;k--){\\n                if(vis[k] == false){\\n                    vis[k] = true;\\n                    long long tmp = func(i+1,k,s);\\n                    ans += tmp;\\n                    ans%=mod;\\n                    vis[k] = false;\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 1285921,
                "title": "c-memoization-backtracking-easy",
                "content": "```\\nclass Solution {\\npublic:\\n    int vis[201];\\n    long long int dp[202][202];\\n    int mod=1000000007;\\n    int util(string &s,int index,int prev){\\n        if(index==s.size()) return 1;\\n        \\n        if(dp[index][prev]!=-1) return dp[index][prev];\\n        \\n        long long int cnt=0;\\n        if(s[index]==\\'D\\'){\\n           for(int i=0;i<prev;i++){\\n               if(vis[i]==0){\\n                    vis[i]=1;\\n                    cnt+=(util(s,index+1,i))%mod;\\n                     vis[i]=0;\\n               }\\n           } \\n        }\\n        else{\\n            for(int i=prev+1;i<=s.size();i++){\\n                if(vis[i]==0){\\n                    vis[i]=1;\\n                    cnt+=(util(s,index+1,i))%mod;\\n                    vis[i]=0;\\n                }\\n            }\\n        }\\n        return dp[index][prev]=cnt%mod;\\n    }\\n    int numPermsDISequence(string s) {\\n        long long int cnt=0;\\n         memset(vis,0,sizeof(vis));\\n        memset(dp,-1,sizeof(dp));\\n        for(int i=0;i<=s.size();i++){\\n            vis[i]=1;\\n            cnt+=(util(s,0,i))%mod;\\n            vis[i]=0;\\n        }\\n        return cnt%mod;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Backtracking",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int vis[201];\\n    long long int dp[202][202];\\n    int mod=1000000007;\\n    int util(string &s,int index,int prev){\\n        if(index==s.size()) return 1;\\n        \\n        if(dp[index][prev]!=-1) return dp[index][prev];\\n        \\n        long long int cnt=0;\\n        if(s[index]==\\'D\\'){\\n           for(int i=0;i<prev;i++){\\n               if(vis[i]==0){\\n                    vis[i]=1;\\n                    cnt+=(util(s,index+1,i))%mod;\\n                     vis[i]=0;\\n               }\\n           } \\n        }\\n        else{\\n            for(int i=prev+1;i<=s.size();i++){\\n                if(vis[i]==0){\\n                    vis[i]=1;\\n                    cnt+=(util(s,index+1,i))%mod;\\n                    vis[i]=0;\\n                }\\n            }\\n        }\\n        return dp[index][prev]=cnt%mod;\\n    }\\n    int numPermsDISequence(string s) {\\n        long long int cnt=0;\\n         memset(vis,0,sizeof(vis));\\n        memset(dp,-1,sizeof(dp));\\n        for(int i=0;i<=s.size();i++){\\n            vis[i]=1;\\n            cnt+=(util(s,0,i))%mod;\\n            vis[i]=0;\\n        }\\n        return cnt%mod;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1251715,
                "title": "c-soln-backtracking-dp",
                "content": "```\\n#define mod 1000000007;\\nclass Solution {\\npublic:\\n    vector<int> vis;\\n    int dp[201][202];\\n    int sol(string &s, int ind, int prev){\\n        if(ind==s.length()+1){return 1;}\\n        if(dp[ind][prev+1]!=-1)return dp[ind][prev+1];\\n        long ans=0;\\n        for(int i=0;i<=s.length();i++){\\n            if(vis[i]!=0)continue;\\n            if(prev!=-1){\\n                if(s[ind-1]==\\'D\\'){\\n                    if(i>prev)break;\\n                    vis[i]=1;\\n                    ans+=sol(s,ind+1,i);\\n                    vis[i]=0;\\n                }\\n                else{\\n                    if(i<prev)continue;\\n                    vis[i]=1;\\n                    ans+=sol(s, ind+1,i);\\n                    vis[i]=0;\\n                }\\n            }\\n            else {\\n                vis[i]=1;\\n                ans+=sol(s, ind+1, i);\\n                vis[i]=0;\\n            }\\n            \\n        }\\n        return dp[ind][prev+1]=ans%mod;\\n    }\\n    int numPermsDISequence(string s) {\\n        memset(dp,-1,sizeof dp);\\n        vis.resize(s.length()+1,0);\\n        return sol(s,0,-1);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Backtracking"
                ],
                "code": "```\\n#define mod 1000000007;\\nclass Solution {\\npublic:\\n    vector<int> vis;\\n    int dp[201][202];\\n    int sol(string &s, int ind, int prev){\\n        if(ind==s.length()+1){return 1;}\\n        if(dp[ind][prev+1]!=-1)return dp[ind][prev+1];\\n        long ans=0;\\n        for(int i=0;i<=s.length();i++){\\n            if(vis[i]!=0)continue;\\n            if(prev!=-1){\\n                if(s[ind-1]==\\'D\\'){\\n                    if(i>prev)break;\\n                    vis[i]=1;\\n                    ans+=sol(s,ind+1,i);\\n                    vis[i]=0;\\n                }\\n                else{\\n                    if(i<prev)continue;\\n                    vis[i]=1;\\n                    ans+=sol(s, ind+1,i);\\n                    vis[i]=0;\\n                }\\n            }\\n            else {\\n                vis[i]=1;\\n                ans+=sol(s, ind+1, i);\\n                vis[i]=0;\\n            }\\n            \\n        }\\n        return dp[ind][prev+1]=ans%mod;\\n    }\\n    int numPermsDISequence(string s) {\\n        memset(dp,-1,sizeof dp);\\n        vis.resize(s.length()+1,0);\\n        return sol(s,0,-1);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 877923,
                "title": "dp-o-n-2-space-o-n-with-intuitive-walkthrough-about-how-to-derive-it",
                "content": "Knowing that we only have to figure out how many permutaitons there are, I stopped thinking about index orders, and instead thought about paths.\\n\\nConceptually, with D alone there\\'s only one path.\\n\\n```\\n *   \\n  \\\\\\n   * (ending)\\n ```\\n \\n If we do DI, then the up path can end either between the existing two nodes, or at the top:\\n\\n```\\n0:      * (ending)\\n1: *   /\\n    \\\\ /\\n2:   *\\n\\n0: *\\n1:  \\\\   *(ending)\\n     \\\\ /\\n2:    *\\n```\\n\\nThe way I began to represent this is the number of paths that END at a given index.\\nD: [0, 1]\\nDI: [1, 1, 0]\\n\\nNow, for DID, we should think about continuing the path that ends at index 0 and 1. Since it will have to go down from there, we\\'ll add an index and consider the number of places the current paths can go. When there are more than just 1 paths ending at an index, we\\'ll need to preserve the increasing possibilities, so I\\'m using variables instead of 1 to show how it should work.\\n\\n```\\n0: x |\\n1: y |\\n2: z |\\n3:   |  (add an index)\\n\\n// add x to all of the indices below it.\\n// add y to all of the indices below it.\\n// etc. for each index i from 1..n\\n// x = 1, y = 1, z = 0\\n0: x |\\n1: y | x\\n2: z | x y\\n3:   | x y z\\n\\n0: 1 |     -> 0\\n1: 1 | 1   -> 1\\n2: 0 | 1 1 -> 2\\n3:   | 1 1 -> 2\\n```\\n\\nSo DID = [0, 1, 2, 2] (The sum of these = 5)\\n\\nNow lets take it one step further for each direction to watch how it evolves:\\n\\n```\\nDIDD:\\n0: 0 |       -> 0\\n1: 1 |       -> 0\\n2: 2 | 1     -> 1\\n3: 2 | 1 2   -> 3\\n4:   | 1 2 2 -> 5\\n\\nDIDI:\\n0: 0 | 2 2 1 | 5\\n1: 1 | 2 2 1 | 5\\n2: 2 | 2 2   | 4\\n3: 2 | 2     | 2\\n4: 0 |       | 0\\n```\\n\\nFor increasing the end paths, we have to first imagine shifting all of the indices up (down visually in my ascii art) by one and inserting a new index at 0 => [0 0 1 2 2]. Then accumulating each index to the indices before it. However, we don\\'t actually have shift all the data, we can just modify where we read the array from. That\\'s why it\\'s depicted above as adding the number of ending paths to all of the rows ABOVE OR EQUAL to that index.\\n\\nNow, at this point, we can look for patterns.\\nOne thing I spotted was this:\\n```\\n0: 0 | 2 2 1 | 5\\n1: 1 | 2 2 1 | 5\\n2: 2 | 2 2   | 4\\n3: 2 | 2     | 2\\n4: 0 |       | 0\\n-------------------\\n       2*4 +\\n\\t     2*3 +\\n\\t\\t   1*2 +\\n\\t\\t     0*1\\n```\\nWhich, does give us the answer, but alas isn\\'t that useful for determining the next incremental step.\\nSo instead looking at each row rather than each column, we can see that \"2 2 1\" from the previous array is present, at index 0 and 1.\\nAnd it\\'s essentially a running sum from back to front.\\n\\nSo now we can translate that into an algorithm to compute each index:\\nSo, for the case of \"I\":\\n\\nassuming we index into the string with k, S[k] == \"I\":\\nn = k+1\\n\\n\\t// sum from n-1 to 0\\n\\t// writing from n-1 to 0\\n\\tdp[n] = 0;\\n\\tfor (int i = n-1; i >= 0; i--) {\\n\\t\\tdp[i] = (dp[i+1] + dp[i]) % m;\\n\\t}\\n\\nNow lets look at D again:\\n\\n    DIDD:\\n\\t0: 0 |       -> 0\\n\\t1: 1 |       -> 0\\n\\t2: 2 | 1     -> 1\\n\\t3: 2 | 2 1   -> 3\\n\\t4:   | 2 2 1 -> 5\\n\\nIndex 4 shows [2 2 1], and index 3 shows [2 1], so spotting the pattern, just like in the increasing case, we can accumulate the values from the previous step and store them, but this time we need to iterate through the array in the forwards direction when accumulating.\\n                \\n\\t// sum from 0 to n-1\\n\\t// writing from 1 to n\\n\\t//sum = dp[0];\\n\\tint saved  = dp[0];\\n\\tdp[0] = 0;\\n\\tfor (int i = 1; i <= n; i++) {\\n\\t\\tint t = dp[i];\\n\\t\\tdp[i] = (dp[i-1] + saved) % m;\\n\\t\\tsaved = t;\\n\\t}\\n\\nI\\'m having to use some temporary values so I can modify the same array, since we need to iterate through it forward and shift it at the same time.\\n\\nHere\\'s the full solution:\\n\\n    int numPermsDISequence(string s) {\\n        int m = 1000000007;\\n        // make the buffer:\\n        int dp[s.size()+1];\\n        dp[0] = 1;\\n        \\n        int sum = 0;\\n        for (int k = 0; k < s.size(); k++) {\\n            int n = k+1;\\n            if (s[k] == \\'D\\') {\\n                // sum from 0 to n-1\\n                // writing to 1 to n\\n                //sum = dp[0];\\n                int saved  = dp[0];\\n                dp[0] = 0;\\n                for (int i = 1; i <= n; i++) {\\n                    int t = dp[i];\\n                    dp[i] = (dp[i-1] + saved) % m;\\n                    saved = t;\\n                }\\n            } else {\\n                // sum from n-1 to 0\\n                // writing from n-1 to 0\\n                dp[n] = 0;\\n                for (int i = n-1; i >= 0; i--) {\\n                    dp[i] = (dp[i+1] + dp[i]) % m;\\n                }\\n            }\\n        }\\n        sum = 0;\\n        for (int i = 0; i <= s.size(); i++) {\\n            sum = (sum + dp[i]) % m;\\n        }\\n        return sum;\\n    }",
                "solutionTags": [],
                "code": "```\\n *   \\n  \\\\\\n   * (ending)\\n ```\n```\\n0:      * (ending)\\n1: *   /\\n    \\\\ /\\n2:   *\\n\\n0: *\\n1:  \\\\   *(ending)\\n     \\\\ /\\n2:    *\\n```\n```\\n0: x |\\n1: y |\\n2: z |\\n3:   |  (add an index)\\n\\n// add x to all of the indices below it.\\n// add y to all of the indices below it.\\n// etc. for each index i from 1..n\\n// x = 1, y = 1, z = 0\\n0: x |\\n1: y | x\\n2: z | x y\\n3:   | x y z\\n\\n0: 1 |     -> 0\\n1: 1 | 1   -> 1\\n2: 0 | 1 1 -> 2\\n3:   | 1 1 -> 2\\n```\n```\\nDIDD:\\n0: 0 |       -> 0\\n1: 1 |       -> 0\\n2: 2 | 1     -> 1\\n3: 2 | 1 2   -> 3\\n4:   | 1 2 2 -> 5\\n\\nDIDI:\\n0: 0 | 2 2 1 | 5\\n1: 1 | 2 2 1 | 5\\n2: 2 | 2 2   | 4\\n3: 2 | 2     | 2\\n4: 0 |       | 0\\n```\n```\\n0: 0 | 2 2 1 | 5\\n1: 1 | 2 2 1 | 5\\n2: 2 | 2 2   | 4\\n3: 2 | 2     | 2\\n4: 0 |       | 0\\n-------------------\\n       2*4 +\\n\\t     2*3 +\\n\\t\\t   1*2 +\\n\\t\\t     0*1\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 652054,
                "title": "java-dfs-with-memo",
                "content": "\\n```\\nclass Solution {\\n    private static int MOD = 1000000007;\\n    public int numPermsDISequence(String S) {\\n        int res = 0;\\n        Integer[][] dp = new Integer[S.length() + 1][S.length() + 1];\\n        \\n        for (int i = 0; i <= S.length(); i++) {\\n            res += dfs(i, S.length() - i, dp, S, 0);\\n            res = res % MOD;\\n        }\\n        return res;\\n    }\\n    \\n    private int dfs(int higher, int lower, Integer[][] dp, String S, int index) {\\n        if (index == S.length()) {\\n            return 1;\\n        }\\n        int d = S.charAt(index) == \\'D\\' ? 1 : 0;\\n        if (dp[higher][lower] != null) {\\n            return dp[higher][lower];\\n        }\\n        int count = 0;\\n        if (d == 1) {\\n            if (lower > 0) {\\n                for (int i = 0; i < lower; i++) {\\n                    count += dfs(higher + i, lower - (i + 1), dp, S, index + 1);\\n                    count = count % MOD;\\n                }\\n            }\\n        } else {\\n            if (higher > 0) {\\n                for (int i = 0; i < higher; i++) {\\n                    count += dfs(higher - (i + 1), lower + i, dp, S, index + 1);\\n                    count = count % MOD;\\n                }\\n            }\\n        }\\n        dp[higher][lower] = count;\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    private static int MOD = 1000000007;\\n    public int numPermsDISequence(String S) {\\n        int res = 0;\\n        Integer[][] dp = new Integer[S.length() + 1][S.length() + 1];\\n        \\n        for (int i = 0; i <= S.length(); i++) {\\n            res += dfs(i, S.length() - i, dp, S, 0);\\n            res = res % MOD;\\n        }\\n        return res;\\n    }\\n    \\n    private int dfs(int higher, int lower, Integer[][] dp, String S, int index) {\\n        if (index == S.length()) {\\n            return 1;\\n        }\\n        int d = S.charAt(index) == \\'D\\' ? 1 : 0;\\n        if (dp[higher][lower] != null) {\\n            return dp[higher][lower];\\n        }\\n        int count = 0;\\n        if (d == 1) {\\n            if (lower > 0) {\\n                for (int i = 0; i < lower; i++) {\\n                    count += dfs(higher + i, lower - (i + 1), dp, S, index + 1);\\n                    count = count % MOD;\\n                }\\n            }\\n        } else {\\n            if (higher > 0) {\\n                for (int i = 0; i < higher; i++) {\\n                    count += dfs(higher - (i + 1), lower + i, dp, S, index + 1);\\n                    count = count % MOD;\\n                }\\n            }\\n        }\\n        dp[higher][lower] = count;\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 606518,
                "title": "java-sol",
                "content": "```\\nclass Solution {\\n    int mod=1000000007;\\n    long dp[][];\\n    public int numPermsDISequence(String s) {//i: string index   end: end with number end\\n        int len=s.length();\\n        long res=0;\\n        dp=new long[len+1][len+1];\\n        dp[0][0]=1;\\n        for(int i=1;i<=s.length();i++){\\n            char c=s.charAt(i-1);\\n            for(int end=0;end<=i;end++){\\n                long val=0;\\n                if(c==\\'D\\'){\\n                    for(int j=end;j<=i-1;j++){\\n                        val+=dp[i-1][j];\\n                        val%=mod;\\n                    }\\n                }else{\\n                    for(int j=0;j<end;j++){\\n                        val+=dp[i-1][j];\\n                        val%=mod;\\n                    }\\n                }\\n                dp[i][end]=val;\\n            }\\n        }\\n        for(int i=0;i<dp[0].length;i++){\\n            res+=dp[len][i];\\n            res%=mod;\\n        }\\n        return (int)(res%mod);\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    int mod=1000000007;\\n    long dp[][];\\n    public int numPermsDISequence(String s) {//i: string index   end: end with number end\\n        int len=s.length();\\n        long res=0;\\n        dp=new long[len+1][len+1];\\n        dp[0][0]=1;\\n        for(int i=1;i<=s.length();i++){\\n            char c=s.charAt(i-1);\\n            for(int end=0;end<=i;end++){\\n                long val=0;\\n                if(c==\\'D\\'){\\n                    for(int j=end;j<=i-1;j++){\\n                        val+=dp[i-1][j];\\n                        val%=mod;\\n                    }\\n                }else{\\n                    for(int j=0;j<end;j++){\\n                        val+=dp[i-1][j];\\n                        val%=mod;\\n                    }\\n                }\\n                dp[i][end]=val;\\n            }\\n        }\\n        for(int i=0;i<dp[0].length;i++){\\n            res+=dp[len][i];\\n            res%=mod;\\n        }\\n        return (int)(res%mod);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 289703,
                "title": "backtracking-to-dp-java-solution",
                "content": "**Idea**\\nWe will try all possibilities for all positions and backtracking when we can\\'t go further. `seen` maintains the visited numbers in per recursion tree branch.\\n\\n**Solution1** **TLE**\\n```\\nclass Solution {\\n    int[] seen = null;\\n    public int numPermsDISequence(String s) {\\n        seen = new int[s.length()+1];\\n        int count = 0;\\n        for(int i=0; i <= s.length(); i++) {\\n            seen[i] = 1;\\n        \\tcount += numPerms(s, 0, i);\\n            seen[i] = 0;\\n        }\\n        return count;\\n    }\\n    private int numPerms(String s, int j, int p){\\n        if(j == s.length())\\n            return 1;\\n        char ch = s.charAt(j);\\n        int count = 0;\\n        if(ch == \\'D\\'){\\n            for(int i=p-1; i >= 0; i--){\\n                if(seen[i] == 1)\\n                    continue;\\n                seen[i] = 1;\\n                count += numPerms(s, j+1, i);\\n                seen[i] = 0;\\n            }\\n        }else{\\n            for(int i=p+1; i <= s.length(); i++){\\n                if(seen[i] == 1)\\n                    continue;\\n                seen[i] = 1;\\n                count += numPerms(s, j+1, i);\\n                seen[i] = 0;\\n            }\\n        }\\n        return count;\\n    }\\n}\\n```\\n**Solution2** DP Memo for overlapping subproblems. `dp[j][p]` indicates number of permutations till `j`th char in `s` and for permutations ending with number `p` (`p` stands for parent in my recursion, since we are exploring the subtree rooted at `p` in the recursion call).\\n```\\nclass Solution {\\n    private static final int DIV = 1000000007;\\n    int[] seen = null;\\n    Integer[][] dp = null;\\n    public int numPermsDISequence(String s) {\\n        dp = new Integer[s.length()][s.length()+1];\\n        seen = new int[s.length()+1];\\n        int count = 0;\\n        for(int i=0; i <= s.length(); i++) {\\n            seen[i] = 1;\\n        \\tcount = count % DIV + numPerms(s, 0, i) % DIV;\\n            seen[i] = 0;\\n        }\\n        return count % DIV;\\n    }\\n    private int numPerms(String s, int j, int p){\\n        if(j == s.length())\\n            return 1;\\n        if(dp[j][p] != null) return dp[j][p];\\n        char ch = s.charAt(j);\\n        int count = 0;\\n        if(ch == \\'D\\'){\\n            for(int i=p-1; i >= 0; i--){\\n                if(seen[i] == 1)\\n                    continue;\\n                seen[i] = 1;\\n                count = count % DIV + numPerms(s, j+1, i)  % DIV;\\n                seen[i] = 0;\\n            }\\n        }else{\\n            for(int i=p+1; i <= s.length(); i++){\\n                if(seen[i] == 1)\\n                    continue;\\n                seen[i] = 1;\\n                count = count % DIV + numPerms(s, j+1, i) % DIV;\\n                seen[i] = 0;\\n            }\\n        }\\n        dp[j][p] = count % DIV;\\n        return dp[j][p];\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    int[] seen = null;\\n    public int numPermsDISequence(String s) {\\n        seen = new int[s.length()+1];\\n        int count = 0;\\n        for(int i=0; i <= s.length(); i++) {\\n            seen[i] = 1;\\n        \\tcount += numPerms(s, 0, i);\\n            seen[i] = 0;\\n        }\\n        return count;\\n    }\\n    private int numPerms(String s, int j, int p){\\n        if(j == s.length())\\n            return 1;\\n        char ch = s.charAt(j);\\n        int count = 0;\\n        if(ch == \\'D\\'){\\n            for(int i=p-1; i >= 0; i--){\\n                if(seen[i] == 1)\\n                    continue;\\n                seen[i] = 1;\\n                count += numPerms(s, j+1, i);\\n                seen[i] = 0;\\n            }\\n        }else{\\n            for(int i=p+1; i <= s.length(); i++){\\n                if(seen[i] == 1)\\n                    continue;\\n                seen[i] = 1;\\n                count += numPerms(s, j+1, i);\\n                seen[i] = 0;\\n            }\\n        }\\n        return count;\\n    }\\n}\\n```\n```\\nclass Solution {\\n    private static final int DIV = 1000000007;\\n    int[] seen = null;\\n    Integer[][] dp = null;\\n    public int numPermsDISequence(String s) {\\n        dp = new Integer[s.length()][s.length()+1];\\n        seen = new int[s.length()+1];\\n        int count = 0;\\n        for(int i=0; i <= s.length(); i++) {\\n            seen[i] = 1;\\n        \\tcount = count % DIV + numPerms(s, 0, i) % DIV;\\n            seen[i] = 0;\\n        }\\n        return count % DIV;\\n    }\\n    private int numPerms(String s, int j, int p){\\n        if(j == s.length())\\n            return 1;\\n        if(dp[j][p] != null) return dp[j][p];\\n        char ch = s.charAt(j);\\n        int count = 0;\\n        if(ch == \\'D\\'){\\n            for(int i=p-1; i >= 0; i--){\\n                if(seen[i] == 1)\\n                    continue;\\n                seen[i] = 1;\\n                count = count % DIV + numPerms(s, j+1, i)  % DIV;\\n                seen[i] = 0;\\n            }\\n        }else{\\n            for(int i=p+1; i <= s.length(); i++){\\n                if(seen[i] == 1)\\n                    continue;\\n                seen[i] = 1;\\n                count = count % DIV + numPerms(s, j+1, i) % DIV;\\n                seen[i] = 0;\\n            }\\n        }\\n        dp[j][p] = count % DIV;\\n        return dp[j][p];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2154540,
                "title": "memo-c",
                "content": "\\tclass Solution {\\n\\tpublic:\\n    int dp[201][201];\\n    int mod=1e9+7;\\n    int util(string &s,vector<int>&visited,int curr,int index,int n){\\n        if(index==s.length())\\n            return 1;\\n        if(dp[curr][index]!=-1)\\n            return dp[curr][index];\\n        int res=0;\\n        visited[curr]=true;\\n        if(s[index]==\\'I\\'){\\n            for(int i=curr+1;i<=n;i++)\\n                if(!visited[i])\\n                res=(res+util(s,visited,i,index+1,n))%mod;\\n            \\n        }else{\\n            for(int i=curr-1;i>=0;i--)\\n                if(!visited[i])\\n                res=(res+util(s,visited,i,index+1,n))%mod;\\n            \\n        }\\n        visited[curr]=false;\\n        return dp[curr][index]=res;\\n    }\\n    int numPermsDISequence(string s) {\\n        memset(dp,-1,sizeof(dp));\\n        int n=s.length();\\n        vector<int>visited(n+1,false);\\n        int res=0;\\n        for(int i=0;i<=n;i++)\\n         res=(res+util(s,visited,i,0,n))%mod;\\n        return res;\\n        \\n    }\\n\\t};",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "class Solution {\\n\\tpublic:\\n    int dp[201][201];\\n    int mod=1e9+7;\\n    int util(string &s,vector<int>&visited,int curr,int index,int n){\\n        if(index==s.length())\\n            return 1;\\n        if(dp[curr][index]!=-1)\\n            return dp[curr][index];\\n        int res=0;\\n        visited[curr]=true;\\n        if(s[index]==\\'I\\'){\\n            for(int i=curr+1;i<=n;i++)\\n                if(!visited[i])\\n                res=(res+util(s,visited,i,index+1,n))%mod;\\n            \\n        }",
                "codeTag": "Java"
            },
            {
                "id": 3392399,
                "title": "backtracking-memoization-is-working-why",
                "content": "# Doubt\\n   Since to decide a unique state , we need:\\n\\n            1.index at which we are currently in string s\\n            2.previous element chosen\\n            3.set of numbers that are used or left.Here vis vector.\\n\\n   But i have done memoization over first two, but the soln is working.Can\\'t understand why??\\n# Code\\n```\\n#define ll long long\\nclass Solution {\\npublic:\\n    ll dp[202][202];\\n    ll mod=1e9+7;\\nint fun(int ind,int prev,int n,string&s, vector<bool>&vis)\\n{\\n    if(ind==s.size())\\n    {\\n        return 1;\\n    }\\n\\n     if(dp[ind][prev]!=-1) return dp[ind][prev];\\n    int ans=0;\\n    if(s[ind]==\\'D\\')\\n    {\\n       for(int i=prev-1;i>=0;i--)\\n       {\\n         if(vis[i]==0)\\n         {\\n            vis[i]=1;\\n            ans+=fun(ind+1,i,n,s,vis);\\n            ans%=mod;\\n            vis[i]=0;\\n         }\\n       }\\n    }\\n    else if(s[ind]==\\'I\\')\\n    {\\n        for(int i=prev+1;i<=n;i++)\\n       {\\n         if(vis[i]==0)\\n         {\\n            vis[i]=1;\\n            ans+=fun(ind+1,i,n,s,vis);\\n            ans%=mod;\\n            vis[i]=0;\\n         }\\n       }\\n    }\\n   return dp[ind][prev]=ans;\\n}\\n\\nint numPermsDISequence(string s) \\n{\\n    memset(dp,-1,sizeof(dp));\\n    ll n=s.size();\\n    vector<bool>vis(n+1,0);\\n    int ans=0;\\n    for(int i=0;i<=n;i++)\\n    {\\n        vis[i]=1;\\n        ans+=fun(0,i,n,s,vis);\\n        ans%=mod;\\n        vis[i]=0;\\n    }\\n    //cout<<\"ans=\"<<ans<<endl;\\n    return ans;\\n}\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Backtracking",
                    "Memoization"
                ],
                "code": "```\\n#define ll long long\\nclass Solution {\\npublic:\\n    ll dp[202][202];\\n    ll mod=1e9+7;\\nint fun(int ind,int prev,int n,string&s, vector<bool>&vis)\\n{\\n    if(ind==s.size())\\n    {\\n        return 1;\\n    }\\n\\n     if(dp[ind][prev]!=-1) return dp[ind][prev];\\n    int ans=0;\\n    if(s[ind]==\\'D\\')\\n    {\\n       for(int i=prev-1;i>=0;i--)\\n       {\\n         if(vis[i]==0)\\n         {\\n            vis[i]=1;\\n            ans+=fun(ind+1,i,n,s,vis);\\n            ans%=mod;\\n            vis[i]=0;\\n         }\\n       }\\n    }\\n    else if(s[ind]==\\'I\\')\\n    {\\n        for(int i=prev+1;i<=n;i++)\\n       {\\n         if(vis[i]==0)\\n         {\\n            vis[i]=1;\\n            ans+=fun(ind+1,i,n,s,vis);\\n            ans%=mod;\\n            vis[i]=0;\\n         }\\n       }\\n    }\\n   return dp[ind][prev]=ans;\\n}\\n\\nint numPermsDISequence(string s) \\n{\\n    memset(dp,-1,sizeof(dp));\\n    ll n=s.size();\\n    vector<bool>vis(n+1,0);\\n    int ans=0;\\n    for(int i=0;i<=n;i++)\\n    {\\n        vis[i]=1;\\n        ans+=fun(0,i,n,s,vis);\\n        ans%=mod;\\n        vis[i]=0;\\n    }\\n    //cout<<\"ans=\"<<ans<<endl;\\n    return ans;\\n}\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2781519,
                "title": "detailed-explanation-and-intuition",
                "content": "# Intuition\\n\\nThe possible lengths of `s`, and the fact that there\\'s a modulo involved, hints that were dealing with some sort of recursive function.\\n\\nIndeed, we have a very large number of alternatives for each step. For a 200 character string, there are 200 valid first choices to explore (some of which may later turn out to be invalid). Then, there\\'s potentially 199 choices, and so on, yielding $\\\\textrm{O}(n!)$.\\n\\nThis tells us that we need to memoize each step somehow. For memoization to work, we must describe the state in such a way that the state space isn\\'t too large.\\n\\nA naive first attempt at a state would be to store:\\n\\n1. $\\\\textrm{O}(n)$ - previously picked index\\n2. $\\\\textrm{O}(n)$ - remaining string length\\n3. $\\\\textrm{O}(n!)$ - set of remaining numbers\\n\\nClearly, (3) won\\'t work.\\n\\nAt this point when you\\'re stuck, it\\'s good to write down some different examples and look for clues. Try moving from a massive `n` to the next step, like `n = 100` to `n = 99`. Try to move from `n = 1` to `n = 0`. Try the other direction, i.e. to introduce a new number to the set.\\n\\nFor me, the breakthrough was when I imagined the last step of a long series of changes that started with `n = 100`. What possible numbers could be left in the set?\\n\\n$$\\n\\\\{ (0, 1), (0, 2), ..., (0, n) \\\\}\\\\\\\\\\n\\\\{ (1, 0), (1, 2), ..., (1, n) \\\\}\\\\\\\\\\n... \\\\\\\\\\n\\\\{ (n, 0), (n, 1), ..., (n, n-1) \\\\}\\\\\\\\\\n$$\\n\\nTo evaluate `\\'D\\'` or `\\'I\\'` with these pairs, it only mattered whether the pair was increasing or decreasing. In other words, we could reduce all these pairs to $(0, 1)$ or $(1, 0)$ and it would make no difference to the result.\\n\\nThis told me that the set could always contain the same numbers, i.e. from `0..n`. It was only the relative position of numbers that mattered.\\n\\n# Approach\\n\\nDue to the reasoning above, the set of possible choices is dependent only on the length of / position in `s` and the previously picked value `x`. This gives us a state space of $\\\\textrm{O}(n^2)$.\\n\\nOnce a valid current number is found, we pick it and continue evaluation. Since the set of numbers is reduced each turn, we must deduct 1 from number `y` when is larger than `x` (x is removed from the set).\\n\\nNote: it is trivial to change top-down to bottom-up, almost always at the expense of legibility. So I\\'ll stick with top-down here.\\n\\n# Complexity\\n\\n- Time complexity: $\\\\textrm{O}(n^2)$\\n- Space complexity: $\\\\textrm{O}(n^2)$\\n\\n# Code\\n\\n```go\\nconst mod = 1e9 + 7\\n\\nfunc numPermsDISequence(s string) int {\\n\\tvar res int\\n\\tn := len(s)\\n\\tmem := make([][]int, n+1)\\n\\tfor i := range mem {\\n\\t\\tmem[i] = make([]int, n+1)\\n\\t\\tfor j := range mem[i] {\\n\\t\\t\\tmem[i][j] = -1\\n\\t\\t}\\n\\t}\\n\\tfor i := 0; i <= n; i++ {\\n\\t\\tres = (res + numPerms(mem, s, i)) % mod\\n\\t}\\n\\treturn res\\n}\\n\\nfunc numPerms(mem [][]int, s string, x int) int {\\n\\tn := len(s)\\n\\tif mem[n][x] != -1 {\\n\\t\\treturn mem[n][x]\\n\\t}\\n\\tif len(s) == 0 {\\n\\t\\treturn 1\\n\\t}\\n\\tvar res int\\n\\tif s[0] == \\'I\\' {\\n\\t\\tfor y := x + 1; y <= n; y++ {\\n\\t\\t\\tres = (res + numPerms(mem, s[1:], y-1)) % mod\\n\\t\\t}\\n\\t} else {\\n\\t\\tfor y := x - 1; y >= 0; y-- {\\n\\t\\t\\tres = (res + numPerms(mem, s[1:], y)) % mod\\n\\t\\t}\\n\\t}\\n\\tmem[n][x] = res\\n\\treturn res\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```go\\nconst mod = 1e9 + 7\\n\\nfunc numPermsDISequence(s string) int {\\n\\tvar res int\\n\\tn := len(s)\\n\\tmem := make([][]int, n+1)\\n\\tfor i := range mem {\\n\\t\\tmem[i] = make([]int, n+1)\\n\\t\\tfor j := range mem[i] {\\n\\t\\t\\tmem[i][j] = -1\\n\\t\\t}\\n\\t}\\n\\tfor i := 0; i <= n; i++ {\\n\\t\\tres = (res + numPerms(mem, s, i)) % mod\\n\\t}\\n\\treturn res\\n}\\n\\nfunc numPerms(mem [][]int, s string, x int) int {\\n\\tn := len(s)\\n\\tif mem[n][x] != -1 {\\n\\t\\treturn mem[n][x]\\n\\t}\\n\\tif len(s) == 0 {\\n\\t\\treturn 1\\n\\t}\\n\\tvar res int\\n\\tif s[0] == \\'I\\' {\\n\\t\\tfor y := x + 1; y <= n; y++ {\\n\\t\\t\\tres = (res + numPerms(mem, s[1:], y-1)) % mod\\n\\t\\t}\\n\\t} else {\\n\\t\\tfor y := x - 1; y >= 0; y-- {\\n\\t\\t\\tres = (res + numPerms(mem, s[1:], y)) % mod\\n\\t\\t}\\n\\t}\\n\\tmem[n][x] = res\\n\\treturn res\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2030781,
                "title": "python-dp-10-lines-of-code-detailed-comments",
                "content": "```\\ndef numPermsDISequence(self, s: str) -> int:\\n        n = len(s)\\n        \\n        # len(dp) is the length of remaining unused set as remain_set\\n        # dp[i] means the last digit of any permutation formed by used set is remain_set[i]\\n        # so, initially, remain_set = [0, 1, ..,n]\\n        # dp[i] = 1\\n        # so, the remain_set for dp[i] is [0, 1,..,i-1, i+1..n]\\n        # Two edge cases:\\n        # remain_set for dp[0] becomes [1, 2,..,n]\\n        # remain_set for dp[n] becomes [0, 1, 2,..,n-1]\\n        # for the new remain_set, dp\\'s lenght becomes the length of new remain_set\\n        # let\\'s create a new dp1 which depends on s[0]\\n        # if s[0] is \\'I\\',\\n        # dp1[0] = dp[0] + dp[1]\\n        # dp1[i] = dp[0] + dp[1] + ..+ dp[i]\\n        # if s[0] is \\'D\\',\\n        # dp1[len(remain_set)-1 # n-1] = dp[n]\\n        # dp1[i] = dp[i+1] + dp[i+2] + ..+ dp[n]\\n        dp = [1] * (n+1)\\n        for c in s:\\n            dp1 = [0]*(len(dp)-1)\\n            if c == \"I\":\\n                for i in range(len(dp1)):\\n                    dp1[i] = sum(dp[:i+1])\\n            else:\\n                for i in range(len(dp1)-1, -1, -1):\\n                    dp1[i] = sum(dp[i+1:])\\n            dp = dp1\\n        return dp[0] % (10**9 + 7)",
                "solutionTags": [],
                "code": "```\\ndef numPermsDISequence(self, s: str) -> int:\\n        n = len(s)\\n        \\n        # len(dp) is the length of remaining unused set as remain_set\\n        # dp[i] means the last digit of any permutation formed by used set is remain_set[i]\\n        # so, initially, remain_set = [0, 1, ..,n]\\n        # dp[i] = 1\\n        # so, the remain_set for dp[i] is [0, 1,..,i-1, i+1..n]\\n        # Two edge cases:\\n        # remain_set for dp[0] becomes [1, 2,..,n]\\n        # remain_set for dp[n] becomes [0, 1, 2,..,n-1]\\n        # for the new remain_set, dp\\'s lenght becomes the length of new remain_set\\n        # let\\'s create a new dp1 which depends on s[0]\\n        # if s[0] is \\'I\\',\\n        # dp1[0] = dp[0] + dp[1]\\n        # dp1[i] = dp[0] + dp[1] + ..+ dp[i]\\n        # if s[0] is \\'D\\',\\n        # dp1[len(remain_set)-1 # n-1] = dp[n]\\n        # dp1[i] = dp[i+1] + dp[i+2] + ..+ dp[n]\\n        dp = [1] * (n+1)\\n        for c in s:\\n            dp1 = [0]*(len(dp)-1)\\n            if c == \"I\":\\n                for i in range(len(dp1)):\\n                    dp1[i] = sum(dp[:i+1])\\n            else:\\n                for i in range(len(dp1)-1, -1, -1):\\n                    dp1[i] = sum(dp[i+1:])\\n            dp = dp1\\n        return dp[0] % (10**9 + 7)",
                "codeTag": "Python3"
            },
            {
                "id": 4049287,
                "title": "explained-why-backtrack-memorization-working",
                "content": "why it works without explicitly saving the state of the visited array?\\n\\n\\nWhen we backtrack and return from a recursive call, we reset ```_ visited[curr] to false _``` which means that the state of visited is restored to what it was before the recursive call.\\n\\nThe memoization table dp is used to store and retrieve previously computed results for specific combinations of curr and index. This allows the algorithm to avoid redundant calculations and significantly improves its efficiency.\\n\\nIn summary, while the visited array is modified during the recursion, it is effectively reset to its original state when backtracking,``` _ thanks to the visited[curr] = false statement _ ``` \\nThe state of visited is managed correctly within the recursive calls, and the memoization table dp ensures that previously computed results are reused to avoid unnecessary computations. This is why the algorithm works correctly without explicitly saving the state of the visited array.\\n\\n```\\nclass Solution {\\npublic:\\n    string s=\"\";\\n    int n;\\n    int dp[203][203];\\n    int m=1e9+7;\\n    int solve(int idx,int prev, vector<int>&vis)\\n    {\\n        if(idx==n) return 1;        \\n        if(dp[idx+1][prev+1]!=-1) return dp[idx+1][prev+1];\\n        long long ans=0;\\n        if(idx==-1)\\n        {\\n            for(int i=0; i<=n; i++) \\n            {\\n                vis[i]=1;\\n                ans+=solve(0,i,vis)%m;\\n                ans%=m;\\n                vis[i]=0;\\n            }\\n        }else\\n        {\\n            for(int i=0; i<=n; i++)\\n            {\\n                if(vis[i]==0 )\\n                {\\n                    if(s[idx]==\\'D\\' &&i<prev)\\n                    {\\n                        vis[i]=1;\\n                        ans+=solve(idx+1,i, vis)%m;\\n                        ans%=m;\\n                        vis[i]=0;\\n                    }else if(s[idx]==\\'I\\' && i>prev)\\n                    {\\n                        vis[i]=1;\\n                        ans+=solve(idx+1,i, vis)%m;\\n                        ans%=m;\\n                        vis[i]=0;\\n                    }\\n                }\\n            }\\n        }\\n        return dp[idx+1][prev+1]=(int)ans;\\n    }\\n    \\n    int numPermsDISequence(string s1) \\n    {\\n        s=s1;\\n        n=s.size();\\n        vector<int> vis(n+1,0);\\n        memset(dp,-1,sizeof(dp));\\n        return solve(-1,-1,vis);\\n    }\\n};\\n\\n\\n```",
                "solutionTags": [
                    "C",
                    "Backtracking",
                    "Memoization"
                ],
                "code": "```_ visited[curr] to false _```\n``` _ thanks to the visited[curr] = false statement _ ```\n```\\nclass Solution {\\npublic:\\n    string s=\"\";\\n    int n;\\n    int dp[203][203];\\n    int m=1e9+7;\\n    int solve(int idx,int prev, vector<int>&vis)\\n    {\\n        if(idx==n) return 1;        \\n        if(dp[idx+1][prev+1]!=-1) return dp[idx+1][prev+1];\\n        long long ans=0;\\n        if(idx==-1)\\n        {\\n            for(int i=0; i<=n; i++) \\n            {\\n                vis[i]=1;\\n                ans+=solve(0,i,vis)%m;\\n                ans%=m;\\n                vis[i]=0;\\n            }\\n        }else\\n        {\\n            for(int i=0; i<=n; i++)\\n            {\\n                if(vis[i]==0 )\\n                {\\n                    if(s[idx]==\\'D\\' &&i<prev)\\n                    {\\n                        vis[i]=1;\\n                        ans+=solve(idx+1,i, vis)%m;\\n                        ans%=m;\\n                        vis[i]=0;\\n                    }else if(s[idx]==\\'I\\' && i>prev)\\n                    {\\n                        vis[i]=1;\\n                        ans+=solve(idx+1,i, vis)%m;\\n                        ans%=m;\\n                        vis[i]=0;\\n                    }\\n                }\\n            }\\n        }\\n        return dp[idx+1][prev+1]=(int)ans;\\n    }\\n    \\n    int numPermsDISequence(string s1) \\n    {\\n        s=s1;\\n        n=s.size();\\n        vector<int> vis(n+1,0);\\n        memset(dp,-1,sizeof(dp));\\n        return solve(-1,-1,vis);\\n    }\\n};\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2649709,
                "title": "dp-solution",
                "content": "To add a new character to a sequence we only have to consider the last element-\\n\\nLets say currently DID sequence is 1032- this can form\\n\\nDIDI - in cases where we end with 3,4\\nDIDD - in cases where we end with 0,1,2\\n\\nSo just use the last element value to create a new sequence.\\n\\n```\\nclass Solution:\\n    def numPermsDISequence(self, s: str) -> int:\\n        mem=defaultdict(int)\\n        def dfs(i,val=0):\\n            if i==len(s):\\n                return 1\\n            if (i,val) in mem:\\n                return mem[i,val]\\n            p=0\\n            if s[i]==\"D\":\\n                for ind in range(0,val+1):\\n                    p+=dfs(i+1,ind)%(10**9+7)\\n            else:\\n                for ind in range(val+1,i+2):\\n                    p+=dfs(i+1,ind)%(10**9+7)\\n            mem[i,val]=p\\n            return p\\n        return dfs(0)\\n ```\\n\\t\\t\\t\\t",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def numPermsDISequence(self, s: str) -> int:\\n        mem=defaultdict(int)\\n        def dfs(i,val=0):\\n            if i==len(s):\\n                return 1\\n            if (i,val) in mem:\\n                return mem[i,val]\\n            p=0\\n            if s[i]==\"D\":\\n                for ind in range(0,val+1):\\n                    p+=dfs(i+1,ind)%(10**9+7)\\n            else:\\n                for ind in range(val+1,i+2):\\n                    p+=dfs(i+1,ind)%(10**9+7)\\n            mem[i,val]=p\\n            return p\\n        return dfs(0)\\n ```",
                "codeTag": "Java"
            },
            {
                "id": 2333944,
                "title": "python-solution-tricky-question",
                "content": "```\\nclass Solution:\\n    # an implicit DP problem\\n    # For simplicity, let\\'s consider the sequence \"D\"\\n    # So we have the sequences [0,1] to permute\\n    # The valid permutation is [1,0]\\n    # Now let\\'s go to \"DI\", we add the number 2\\n    # and let\\'s separate the cases in which the sequence ends with different numbers\\n    # We see that 0 cannot be the end, because it cannot account for the I\\n    # We see that it can end with 1, by increasing every number larger than 1 by 1: [2, 0, 1]\\n    # We see the same applies for ending with 2: [1, 0, 2]\\n    # Now we consider the alternative \"DD\"\\n    # We see that we can get 0 to be the end by increasing all numbers larger or equal to 0 by 1: [2,1,0]\\n    # We cannot satisfy this for 1 and 2\\n    # Therefore, to solve the problem, we need to build the sequences from left to right\\n    # dp[i][j] = number of sequences that uses integers from [0,i] and ends with j\\n    # dp[0][0] = 1\\n    # If s = \"D\": dp[1][0] = dp[0][0] = 1; dp[1][1] = 0\\n    # If s = \"I\": dp[1][0] = 0; dp[1][1] = dp[0][0] = 1\\n    # If s = \"DI\": dp[2][0] = 0; dp[2][1] = dp[1][0] = 1; dp[2][2] = dp[1][0] + dp[1][1] = 1\\n    # If s = \"DD\": dp[2][0] = dp[1][0] + dp[1][1] = 1; dp[2][1] = dp[1][0] = 0; dp[2][2] = 0\\n    # If s = \"DID\": dp[3][0] = dp[2][0] + dp[2][1] + dp[2][2] = 0 + 1 + 1 = 2; dp[3][1] = dp[2][1] + dp[2][2] = 1 + 1 = 2; dp[3][2] =  dp[2][2] = 1; dp[3][3] = 0\\n    # As we see we should calculate prefix sum or suffix sums according to whether the current character is \"D\" or \"L\" respectively to facilitate calculations\\n    def numPermsDISequence(self, s: str) -> int:\\n        prev, MOD = [1], pow(10,9) + 7\\n        for i, c in enumerate(s):\\n            if c == \"D\":\\n                prefix = [0]*(i+2)\\n                for j in range(1,i+2,1):\\n                    prefix[j] = prefix[j-1] + prev[j-1]\\n                    prefix[j] %= MOD\\n                #print(\"prefix = \", prefix)\\n                nxt = [0]*(i+2)\\n                for j in range(i+1):\\n                    nxt[j] = prefix[i+1] - prefix[j]\\n            else:\\n                suffix = [0]*(i+2)\\n                for j in range(i,-1,-1):\\n                    suffix[j] = suffix[j+1] + prev[j]\\n                    suffix[j] %= MOD\\n                #print(\"suffix = \", suffix)\\n                nxt = [0]*(i+2)\\n                for j in range(1,i+2):\\n                    nxt[j] = suffix[0] - suffix[j]\\n            prev = nxt[:]\\n        return sum(prev) % MOD\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    # an implicit DP problem\\n    # For simplicity, let\\'s consider the sequence \"D\"\\n    # So we have the sequences [0,1] to permute\\n    # The valid permutation is [1,0]\\n    # Now let\\'s go to \"DI\", we add the number 2\\n    # and let\\'s separate the cases in which the sequence ends with different numbers\\n    # We see that 0 cannot be the end, because it cannot account for the I\\n    # We see that it can end with 1, by increasing every number larger than 1 by 1: [2, 0, 1]\\n    # We see the same applies for ending with 2: [1, 0, 2]\\n    # Now we consider the alternative \"DD\"\\n    # We see that we can get 0 to be the end by increasing all numbers larger or equal to 0 by 1: [2,1,0]\\n    # We cannot satisfy this for 1 and 2\\n    # Therefore, to solve the problem, we need to build the sequences from left to right\\n    # dp[i][j] = number of sequences that uses integers from [0,i] and ends with j\\n    # dp[0][0] = 1\\n    # If s = \"D\": dp[1][0] = dp[0][0] = 1; dp[1][1] = 0\\n    # If s = \"I\": dp[1][0] = 0; dp[1][1] = dp[0][0] = 1\\n    # If s = \"DI\": dp[2][0] = 0; dp[2][1] = dp[1][0] = 1; dp[2][2] = dp[1][0] + dp[1][1] = 1\\n    # If s = \"DD\": dp[2][0] = dp[1][0] + dp[1][1] = 1; dp[2][1] = dp[1][0] = 0; dp[2][2] = 0\\n    # If s = \"DID\": dp[3][0] = dp[2][0] + dp[2][1] + dp[2][2] = 0 + 1 + 1 = 2; dp[3][1] = dp[2][1] + dp[2][2] = 1 + 1 = 2; dp[3][2] =  dp[2][2] = 1; dp[3][3] = 0\\n    # As we see we should calculate prefix sum or suffix sums according to whether the current character is \"D\" or \"L\" respectively to facilitate calculations\\n    def numPermsDISequence(self, s: str) -> int:\\n        prev, MOD = [1], pow(10,9) + 7\\n        for i, c in enumerate(s):\\n            if c == \"D\":\\n                prefix = [0]*(i+2)\\n                for j in range(1,i+2,1):\\n                    prefix[j] = prefix[j-1] + prev[j-1]\\n                    prefix[j] %= MOD\\n                #print(\"prefix = \", prefix)\\n                nxt = [0]*(i+2)\\n                for j in range(i+1):\\n                    nxt[j] = prefix[i+1] - prefix[j]\\n            else:\\n                suffix = [0]*(i+2)\\n                for j in range(i,-1,-1):\\n                    suffix[j] = suffix[j+1] + prev[j]\\n                    suffix[j] %= MOD\\n                #print(\"suffix = \", suffix)\\n                nxt = [0]*(i+2)\\n                for j in range(1,i+2):\\n                    nxt[j] = suffix[0] - suffix[j]\\n            prev = nxt[:]\\n        return sum(prev) % MOD\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2293851,
                "title": "beats-100-other-s-solutions",
                "content": "```\\nclass Solution:\\n    def numPermsDISequence(self, S: str) -> int:\\n        dp = [1] * (len(S) + 1)\\n        for a, b in zip(\\'I\\' + S, S):\\n            dp = list(itertools.accumulate(dp[:-1] if a == b else dp[-1:0:-1]))\\n        return dp[0] % (10**9 + 7)\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def numPermsDISequence(self, S: str) -> int:\\n        dp = [1] * (len(S) + 1)\\n        for a, b in zip(\\'I\\' + S, S):\\n            dp = list(itertools.accumulate(dp[:-1] if a == b else dp[-1:0:-1]))\\n        return dp[0] % (10**9 + 7)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1880241,
                "title": "c-dfs-memo",
                "content": "```\\nclass Solution {\\npublic:\\n    int mod = 1e9+7;\\n    int dfs(vector<vector<int>> &dp,vector<bool> &vis,string &s,int in,int n,int last){\\n        if(in>=s.size()) return 1;\\n        if(dp[in][last]!=-1) return dp[in][last];\\n        if(s[in]==\\'D\\'){  \\n            long re = 0;\\n            for(int i = 0; i<last; ++i){\\n                if(vis[i]==1) continue;\\n                vis[i] = 1;\\n                int k = dfs(dp,vis,s,in+1,n,i);\\n                vis[i]=0;\\n                re = (re + k)%mod;\\n            }\\n            return dp[in][last] = (int)re;\\n        }\\n        else{\\n            long re = 0;\\n            for(int i = last+1; i<=s.size(); ++i){\\n                if(vis[i]==1) continue;\\n                vis[i] = 1;\\n                int k = dfs(dp,vis,s,in+1,n,i);\\n                vis[i]=0;\\n                re = (re + k)%mod;\\n            }\\n            return dp[in][last] = (int)re;\\n        }\\n    }\\n    int numPermsDISequence(string s) {\\n        int n = s.size(), i = 0; \\n        long re = 0;\\n        vector<vector<int>> dp(n+2,vector<int>(n+2,-1));\\n        vector<bool> vis(n+1,0);\\n        \\n        if(s[0]==\\'D\\') i++; \\n        for(;i<=n;i++){\\n            vis[i] = 1;\\n            re = (re + dfs(dp,vis,s,0,n,i))%mod;\\n            vis[i] = 0;\\n        }\\n        return (int)re;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int mod = 1e9+7;\\n    int dfs(vector<vector<int>> &dp,vector<bool> &vis,string &s,int in,int n,int last){\\n        if(in>=s.size()) return 1;\\n        if(dp[in][last]!=-1) return dp[in][last];\\n        if(s[in]==\\'D\\'){  \\n            long re = 0;\\n            for(int i = 0; i<last; ++i){\\n                if(vis[i]==1) continue;\\n                vis[i] = 1;\\n                int k = dfs(dp,vis,s,in+1,n,i);\\n                vis[i]=0;\\n                re = (re + k)%mod;\\n            }\\n            return dp[in][last] = (int)re;\\n        }\\n        else{\\n            long re = 0;\\n            for(int i = last+1; i<=s.size(); ++i){\\n                if(vis[i]==1) continue;\\n                vis[i] = 1;\\n                int k = dfs(dp,vis,s,in+1,n,i);\\n                vis[i]=0;\\n                re = (re + k)%mod;\\n            }\\n            return dp[in][last] = (int)re;\\n        }\\n    }\\n    int numPermsDISequence(string s) {\\n        int n = s.size(), i = 0; \\n        long re = 0;\\n        vector<vector<int>> dp(n+2,vector<int>(n+2,-1));\\n        vector<bool> vis(n+1,0);\\n        \\n        if(s[0]==\\'D\\') i++; \\n        for(;i<=n;i++){\\n            vis[i] = 1;\\n            re = (re + dfs(dp,vis,s,0,n,i))%mod;\\n            vis[i] = 0;\\n        }\\n        return (int)re;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1261833,
                "title": "python3-top-down-dp",
                "content": "\\n```\\nclass Solution:\\n    def numPermsDISequence(self, s: str) -> int:\\n        \\n        @cache \\n        def fn(i, x): \\n            \"\"\"Return number of valid permutation given x numbers smaller than previous one.\"\"\"\\n            if i == len(s): return 1 \\n            if s[i] == \"D\": \\n                if x == 0: return 0 # cannot decrease\\n                return fn(i, x-1) + fn(i+1, x-1)\\n            else: \\n                if x == len(s)-i: return 0 # cannot increase \\n                return fn(i, x+1) + fn(i+1, x)\\n        \\n        return sum(fn(0, x) for x in range(len(s)+1)) % 1_000_000_007\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def numPermsDISequence(self, s: str) -> int:\\n        \\n        @cache \\n        def fn(i, x): \\n            \"\"\"Return number of valid permutation given x numbers smaller than previous one.\"\"\"\\n            if i == len(s): return 1 \\n            if s[i] == \"D\": \\n                if x == 0: return 0 # cannot decrease\\n                return fn(i, x-1) + fn(i+1, x-1)\\n            else: \\n                if x == len(s)-i: return 0 # cannot increase \\n                return fn(i, x+1) + fn(i+1, x)\\n        \\n        return sum(fn(0, x) for x in range(len(s)+1)) % 1_000_000_007\\n```",
                "codeTag": "Java"
            },
            {
                "id": 645163,
                "title": "simple-c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int numPermsDISequence(string S) {\\n        int n = S.length(), mod = 1e9 + 7;\\n        vector<vector<int>> dp(n + 1, vector<int>(n + 1));\\n        for (int j = 0; j <= n; j++){\\n            dp[0][j] = 1;\\n        } \\n        for (int i = 0; i < n; i++){\\n            if (S[i] == \\'I\\'){\\n                for (int j = 0, cur = 0; j < n - i; j++)\\n                    dp[i + 1][j] = cur = (cur + dp[i][j]) % mod;\\n            } else {\\n                for (int j = n - i - 1, cur = 0; j >= 0; j--)\\n                    dp[i + 1][j] = cur = (cur + dp[i][j + 1]) % mod;   \\n            }\\n        }  \\n        return dp[n][0];\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int numPermsDISequence(string S) {\\n        int n = S.length(), mod = 1e9 + 7;\\n        vector<vector<int>> dp(n + 1, vector<int>(n + 1));\\n        for (int j = 0; j <= n; j++){\\n            dp[0][j] = 1;\\n        } \\n        for (int i = 0; i < n; i++){\\n            if (S[i] == \\'I\\'){\\n                for (int j = 0, cur = 0; j < n - i; j++)\\n                    dp[i + 1][j] = cur = (cur + dp[i][j]) % mod;\\n            } else {\\n                for (int j = n - i - 1, cur = 0; j >= 0; j--)\\n                    dp[i + 1][j] = cur = (cur + dp[i][j + 1]) % mod;   \\n            }\\n        }  \\n        return dp[n][0];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 490123,
                "title": "c-dp-100-100",
                "content": "I highly doubt if this is a real interview question or merely from contest, which adopts ideas/techniques in some fields. \\n \\nThe main challege to apply DP is the state space is too large, if remembering which numbers have been assigned. This challenge can be overcomed by using ranking. For people with background in discrete and combinatorics math, the idea is rather common. \\n\\nAlso, this problem requires some modeling technique commonly seen in optimal control/operations research. Dynamic programming models typically requires defining state and actions associated with the state. One can solve a DP model as a sequence of action choosing problems for each state. Another way is to regard state and action pair as a whole, and solve the DP by searching for the next state-and-actoin. As for which approach to take, it depends on specific problems. For this question, the latter one is more straightforward. \\n\\nTherefore, it is not a fair problem and should not be used in real interview. \\n\\n```\\n    int numPermsDISequence(string S) {\\n        const int M = 1e9 + 7, n = S.length(); \\n        vector<int> curr(n + 1, 1), next(n + 1, 0);\\n        for (int t = 0; t < n; ++t) {\\n            char c = S[t]; \\n            int sum = 0; \\n            if (c == \\'D\\') {\\n                for (int i = n - t - 1; i >=0; --i) {\\n                    sum = (curr[i + 1]%M + sum%M)%M;\\n                    next[i] = sum; \\n                }\\n            } else {\\n                for (int i = 0; i < n - t; ++i) {\\n                    sum = (curr[i]%M + sum%M)%M; \\n                    next[i] = sum;  \\n                }\\n            }\\n            swap(curr, next); \\n        } \\n        return curr.front(); \\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    int numPermsDISequence(string S) {\\n        const int M = 1e9 + 7, n = S.length(); \\n        vector<int> curr(n + 1, 1), next(n + 1, 0);\\n        for (int t = 0; t < n; ++t) {\\n            char c = S[t]; \\n            int sum = 0; \\n            if (c == \\'D\\') {\\n                for (int i = n - t - 1; i >=0; --i) {\\n                    sum = (curr[i + 1]%M + sum%M)%M;\\n                    next[i] = sum; \\n                }\\n            } else {\\n                for (int i = 0; i < n - t; ++i) {\\n                    sum = (curr[i]%M + sum%M)%M; \\n                    next[i] = sum;  \\n                }\\n            }\\n            swap(curr, next); \\n        } \\n        return curr.front(); \\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 482430,
                "title": "java-dfs-with-memo",
                "content": "\\'\\'\\'\\n\\n\\tclass Solution {\\n\\t\\tint MOD = (int)1e9 + 7;\\n\\t\\tpublic int numPermsDISequence(String s) {\\n\\t\\t\\tif (s == null || s.length() == 0) {\\n\\t\\t\\t\\treturn 0;\\n\\t\\t\\t}\\n\\t\\t\\tSet<Integer> hashSet = new HashSet<>();\\n\\t\\t\\tfor (int i = 0; i <= s.length(); i++) {\\n\\t\\t\\t\\thashSet.add(i);\\n\\t\\t\\t}\\n\\n\\t\\t\\tlong result = helper(s, 0, hashSet, null, null, new boolean[s.length() + 1][s.length() + 1], new long[s.length() + 1][s.length() + 1]);\\n\\t\\t\\tSystem.out.println(result);\\n\\t\\t\\treturn (int)(result % MOD);\\n\\t\\t}\\n\\n\\t\\tpublic long helper(String s, int startIndex, Set<Integer> hashSet, Integer lastNumber, Integer relativeIndex, boolean[][] visited, long[][] dp) {\\n\\t\\t\\tif (startIndex == s.length() + 1) {\\n\\t\\t\\t\\treturn 1;\\n\\t\\t\\t}\\n\\t\\t\\tif (relativeIndex != null && visited[startIndex][relativeIndex]) {\\n\\t\\t\\t\\treturn dp[startIndex][relativeIndex];\\n\\t\\t\\t}\\n\\n\\t\\t\\tlong result = 0;\\n\\t\\t\\tint index = -1;\\n\\t\\t\\tPriorityQueue<Integer> pQueue = new PriorityQueue<Integer>(hashSet); \\n\\t\\t\\tfor (int i : pQueue) {\\n\\t\\t\\t\\tindex++;\\n\\t\\t\\t\\tif (startIndex != 0 && ((s.charAt(startIndex - 1) == \\'D\\' && i > lastNumber) || \\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t(s.charAt(startIndex - 1) == \\'I\\' && i < lastNumber))) {\\n\\t\\t\\t\\t\\tcontinue;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\thashSet.remove(i);\\n\\t\\t\\t\\tresult += helper(s, startIndex + 1, hashSet, i, index, visited, dp);\\n\\t\\t\\t\\tresult %= MOD;\\n\\t\\t\\t\\thashSet.add(i);\\n\\t\\t\\t}\\n\\n\\t\\t\\tif (relativeIndex != null) {\\n\\t\\t\\t\\tvisited[startIndex][relativeIndex] = true;\\n\\t\\t\\t\\tdp[startIndex][relativeIndex] = result;\\n\\t\\t\\t}\\n\\t\\t\\treturn result;\\n\\t\\t}\\n\\t}\\n\\'\\'\\'\\n\\n",
                "solutionTags": [],
                "code": "class Solution {\\n\\t\\tint MOD = (int)1e9 + 7;\\n\\t\\tpublic int numPermsDISequence(String s) {\\n\\t\\t\\tif (s == null || s.length() == 0) {\\n\\t\\t\\t\\treturn 0;\\n\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 257525,
                "title": "java-solution",
                "content": "```\\n    public int numPermsDISequence(String S) {\\n        int len = S.length(), N = len + 1, mod = 1000000007;\\n        int[][] dp = new int[N+1][N];\\n        \\n        for(int i = 0; i < N; i++) dp[1][i] = 1;\\n        \\n        for(int i = 1; i <= len; i++) {\\n            if(S.charAt(i-1) == \\'D\\') for(int j = N - i -1; j >= 0; j--) dp[i+1][j] = (dp[i+1][j+1] + dp[i][j+1])%mod;\\n            else  for(int j = 0; j <= N - i-1; j++) dp[i+1][j] = ((j > 0 ? dp[i+1][j-1] : 0) + dp[i][j])%mod;\\n        }\\n        \\n        return dp[N][0];\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    public int numPermsDISequence(String S) {\\n        int len = S.length(), N = len + 1, mod = 1000000007;\\n        int[][] dp = new int[N+1][N];\\n        \\n        for(int i = 0; i < N; i++) dp[1][i] = 1;\\n        \\n        for(int i = 1; i <= len; i++) {\\n            if(S.charAt(i-1) == \\'D\\') for(int j = N - i -1; j >= 0; j--) dp[i+1][j] = (dp[i+1][j+1] + dp[i][j+1])%mod;\\n            else  for(int j = 0; j <= N - i-1; j++) dp[i+1][j] = ((j > 0 ? dp[i+1][j-1] : 0) + dp[i][j])%mod;\\n        }\\n        \\n        return dp[N][0];\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4085333,
                "title": "easiest-solution",
                "content": "\\n\\n# Code\\n```java []\\nclass Solution {\\n    public int numPermsDISequence(String s) {\\n\\tint n = s.length();\\n\\tint[][] dp = new int [n+2][2];\\n\\tint mod = 1000000007;\\n\\tdp[1][0] = 1;\\n\\tfor(int i = 1; i<=n; i++){\\n\\t\\tif(s.charAt(i-1)==\\'I\\') {\\n\\t\\t\\tfor(int j = 0; j<=i; j++) dp[j+1][i&1]=(dp[j][(i+1)&1] + dp[j][i&1])%mod;  \\n\\t\\t} else {\\n\\t\\t\\tfor(int j = 0; j<=i; j++) dp[j+1][i&1]=((dp[i][(i+1)&1] + mod - dp[j][(i+1)&1])%mod + dp[j][i&1])%mod;\\n\\t\\t} \\n\\t}\\n\\treturn dp[n+1][n&1];\\n}\\n}\\n```\\n```c++ []\\nclass Solution {\\npublic:\\n    int visited[201];\\n    int mod = 1e9+7;\\n    map<pair<int,int>,int>mp;\\n    int solve(int idx , int last,string &s){\\n        //base case\\n        if(idx<0)return 1;\\n        \\n        if(mp.count({idx,last}))\\n            return mp[{idx,last}];\\n        int ans = 0 ;\\n        \\n        //hash means any number can be insertd at last position\\n        if(s[idx]==\\'#\\'){\\n            for(int i=0;i<s.size();i++){\\n                if(!visited[i]){\\n                    visited[i]=1;\\n                    ans = (ans + solve(idx-1,i,s))%mod;\\n                    visited[i]=0;\\n                }\\n            }\\n        }\\n        \\n        if(s[idx]==\\'D\\'){\\n            for(int i=last+1;i<s.size();i++){\\n                if(!visited[i]){\\n                    visited[i]=1;\\n                    ans = (ans + solve(idx-1,i,s))%mod;\\n                    visited[i]=0;\\n                }\\n            }            \\n        }\\n        \\n        if(s[idx]==\\'I\\'){\\n            for(int i=0;i<last;i++){\\n                if(!visited[i]){\\n                    visited[i]=1;\\n                    ans = (ans + solve(idx-1,i,s))%mod;\\n                    visited[i]=0;\\n                }\\n            }             \\n        }\\n        \\n        return mp[{idx,last}] = ans;\\n        \\n    }\\n    int numPermsDISequence(string s) {\\n        s.push_back(\\'#\\');\\n        int n=s.size();\\n        return solve(n-1,0,s);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Java"
                ],
                "code": "```java []\\nclass Solution {\\n    public int numPermsDISequence(String s) {\\n\\tint n = s.length();\\n\\tint[][] dp = new int [n+2][2];\\n\\tint mod = 1000000007;\\n\\tdp[1][0] = 1;\\n\\tfor(int i = 1; i<=n; i++){\\n\\t\\tif(s.charAt(i-1)==\\'I\\') {\\n\\t\\t\\tfor(int j = 0; j<=i; j++) dp[j+1][i&1]=(dp[j][(i+1)&1] + dp[j][i&1])%mod;  \\n\\t\\t} else {\\n\\t\\t\\tfor(int j = 0; j<=i; j++) dp[j+1][i&1]=((dp[i][(i+1)&1] + mod - dp[j][(i+1)&1])%mod + dp[j][i&1])%mod;\\n\\t\\t} \\n\\t}\\n\\treturn dp[n+1][n&1];\\n}\\n}\\n```\n```c++ []\\nclass Solution {\\npublic:\\n    int visited[201];\\n    int mod = 1e9+7;\\n    map<pair<int,int>,int>mp;\\n    int solve(int idx , int last,string &s){\\n        //base case\\n        if(idx<0)return 1;\\n        \\n        if(mp.count({idx,last}))\\n            return mp[{idx,last}];\\n        int ans = 0 ;\\n        \\n        //hash means any number can be insertd at last position\\n        if(s[idx]==\\'#\\'){\\n            for(int i=0;i<s.size();i++){\\n                if(!visited[i]){\\n                    visited[i]=1;\\n                    ans = (ans + solve(idx-1,i,s))%mod;\\n                    visited[i]=0;\\n                }\\n            }\\n        }\\n        \\n        if(s[idx]==\\'D\\'){\\n            for(int i=last+1;i<s.size();i++){\\n                if(!visited[i]){\\n                    visited[i]=1;\\n                    ans = (ans + solve(idx-1,i,s))%mod;\\n                    visited[i]=0;\\n                }\\n            }            \\n        }\\n        \\n        if(s[idx]==\\'I\\'){\\n            for(int i=0;i<last;i++){\\n                if(!visited[i]){\\n                    visited[i]=1;\\n                    ans = (ans + solve(idx-1,i,s))%mod;\\n                    visited[i]=0;\\n                }\\n            }             \\n        }\\n        \\n        return mp[{idx,last}] = ans;\\n        \\n    }\\n    int numPermsDISequence(string s) {\\n        s.push_back(\\'#\\');\\n        int n=s.size();\\n        return solve(n-1,0,s);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3852423,
                "title": "editorial-like-solution-simple-to-understand-with-multiple-approaches-from-brute-force-to-optimal",
                "content": "The problem asks what is the number of valid permutations that follow a string of `\"DI\"` instructions, if a number `i` is used in a podition with `\\'D\\'` the next number must be in the range `0 <= j < i`, likewise if it\\'s in an `\\'I\\'` position the next number must be `i < j <= n` where `n` is the length if the string provided, the hard part comes in that we cannot repeat the same number, so it seems (but turns out not to be the case) that we need to remember all the previous numbers to solve the problem, let\\'s see how we might develop a solution.\\n\\n\\n# Approach #1: Brute-Force\\n\\n# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe first thing that is recommended to be done in a complex problem like this one is to generate all possible solutions and discard the invalid ones, that can be done via backtracking, we define a helper function `backTrack` that keeps track of where in the string we are and what was the previous number used, and define a set `state` that contains all numbers previously used; at a given index position `i` we check for all numbers bigger/smaller than the previous number, if we can insert it into the permutation we add it to the stack, we we are done generating all it\\'s sub-solutions we remove it from the set, (this can also be done with a stack, which may be faster).\\nIf we reach `i == n` we finished generating a permutation and add `1` to our count (which I named `ans`).\\n\\n# Algorithm\\n<!-- Describe your approach to solving the problem. -->\\n1. Define a set/stack and a counter\\n2. Define the `backTrack` function:\\n2.1 If we reached the end, increase the counter\\n2.2 If not, go through all numbers lower/higher than the previous number and check if they can be added, if yes then add the number tot the set, call `backTrack` with `i+1` and this added number, when the function returns, remove the number from the set\\n3. Call `backTrack` for all possible starting number `0` to `n`\\n\\n# Complexity\\n- Time complexity: $$O(n!)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nAt any index `i` we have `i` options to choose from in worst-case, since `n` can go up to `200` this will result in a TLE.\\n\\n- Space complexity: $$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nWe use a set/stack that will contain at most `n` numbers when a permutation is complete\\n\\n# Implementation (only python, sorry)\\n```\\nclass Solution:\\n    def numPermsDISequence(self, s: str) -> int:\\n        n = len(s)\\n        ans = [0]\\n        state = set()\\n        def backTrack(i, p):\\n            if i == n:\\n                ans[0] += 1\\n                return\\n            if s[i] == \"I\":\\n                for j in range(p+1, n+1):\\n                    if j not in state:\\n                        state.add(j)\\n                        backTrack(i+1, j)\\n                        state.remove(j)\\n            else:\\n                for j in range(0, p):\\n                    if j not in state:\\n                        state.add(j)\\n                        backTrack(i+1, j)\\n                        state.remove(j)\\n            return  \\n        for i in range(n+1):\\n            state.add(i)\\n            backTrack(0, i)\\n            state.remove(i)\\n        return ans[0]%(10**9+7)\\n```\\n\\n# Approach #2: Dynamic programming\\n\\n# Intuition\\nThe previous solution was too slow to be accepted, we need to find a faster way to calculate the answer. We first note that we got asked the number of valid permutations, so maybe (for this problem to be possible, we definitely) we don\\'t need to generate all possible permutations to know how many there are, usually we can break down a problem into sub-problems to generate an answer faster from solving sub-problems\\nAt first it may look like this is impossible to do here, since at each index the number we choose will affect all the possible choices in the future, but remembering we only need to know the quantity we may wonder if maybe the quantities are not dependent directly on the number you choose to place, let\\'s do a thought experiment, imagine instead of using the numbers `(1,2,3,4, ...)` to generate our permutatons we use `(1,1,1,1, ...)` only a bunch of ones, and when we use a number like `3` the whole thing turns into `(1,1,0,1, ...)` so we have a certain concept of \"order\" so that the problem is the same, now think about using `1` or `2` or `3`, in a given index `i` we would get accordingly `(0,1,1,1), (1,0,1,1), (1,1,0,1)` which are different, but look very similar! Why they all look so similar? because they all have the same idea of **relative ordering**, `1` is still smaller than `3` and `4` even when 2 is out of the equation and likewise for all the others, so if we only focus on the relative ordering of the numbers essentially all of the three sub-problems above are **identical**, so we can just represent them all as `(1,1,1)`.\\nThis is still not the complete picture, we know that the `\"ID\"` will limit our choice of next number, so returning to the last example, if the digit is `\\'I\\'`, then in the case of choosing `1` we would have `(0,1,1,1)` and the next number could be any of the following ones, but if we chose `2` the the sub-problem is `(1,0,1,1)` and we can only choose as the next number the ones to the right of the new zero, likewise if it were a `\\'D\\'` it would be the ones to the left of the zero, with that in mind we can now define our dynamic programming sub-problem.\\n\\n`\\ndp[i][j] = Solution to sub-problem s[i:n], if we can choose only ones bounded to the j\\'th one\\n`\\n\\nBy bounded I mean that if `s[i]` is `\\'I\\'` we can choose the ones from the `j` one to the right-end and if it is a `\\'D\\'` we can choose the ones from `j` one to the left-end.\\nFor example `dp[2][3]` for the tuple `(1,1,1,1,1,1,1)` is the solution to the sub-string `s[2:n]` using at position `2` any one that is from the inclusive left/right (depending on `s[2]`) of the highlighted one in `(1,1,_1_,1,1)`, notice that the size of the tuple is smaller by 2 than the original because we zero\\'ed two other ones in the original tuple, in general, if the original tuple is of size `n`, at index `i` the tuple will have size `n-i`.\\n\\nNow that we have a table, let\\'s see how we can generate answers from sub-problems. The base case is very simple, `s[n-1]` is either `\\'I\\'` or `\\'D\\'` and the tuple is simply `(1,1)`, we can define the base cases as follows:\\n```\\nif s[n-1] == \\'I\\':\\n    #If we choose 1, then it is impossible to increase\\n    dp[n-1][0] = 1\\n    dp[n-1][1] = 0\\nelif s[n-1] == \\'D:\\n    #If we choose 0, then it is impossible to decrease\\n    dp[n-1][0] = 0\\n    dp[n-1][1] = 1\\n```\\nThis idea of choosing the highest number or the lowest, makes it impossible to continue will keep re-occurring in later cases too.\\nFor an index `i < n-1` we know that if `s[i] == \\'I\\'` then the last number will have an answer of zero, if `s[i] == \\'D\\'` then the first number will have an answer of zero, in general `dp[i][j]\\n` will have all the answers that were pre-calculated in that row `i` (from the definition of the dp) and will also contain all the possible answers of the sub-problem at the `i+1` using only one to the left/right of it, which in our table happens that answer turns out to be stored in `dp[i+1][j]` (you can convince yourself of that by imagining how removing a one from a tuple changes the absolute postion of each remaining one), so our final update step looks like this.\\n\\n```\\nif s[n-1] == \\'I\\':\\n    if i == n-1:\\n        #If we choose 1, then it is impossible to increase\\n        dp[n-1][0] = 1\\n        dp[n-1][1] = 0\\n    else:\\n        if j == n-i:\\n            dp[i][j] = 0\\n        else:\\n            dp[i][j] = dp[i][j+1] + dp[i+1][j]\\nelif s[n-1] == \\'D:\\n    if i == n-1:\\n        #If we choose 0, then it is impossible to decrease\\n        dp[n-1][0] = 0\\n        dp[n-1][1] = 1\\n    else:\\n        if j == 0:\\n            dp[i][j] = 0\\n        else:\\n            dp[i][j] = dp[i][j-1] + dp[i+1][j]\\n```\\nPhew! That\\'s a pretty complicated update step, make sure you understand it, before writing it down because later on it will get worse! Now at last all that\\'s left to do is to write down the solution\\n\\n# Algorithm\\n1. Define our table `dp`\\n2. Go from the base case to the original case\\n3. Update the table according to the update step\\n4. return the `sum` of all possible start choices\\n\\n# Implementation (only python, sorry)\\n```\\nclass Solution:\\n    def numPermsDISequence(self, s: str) -> int:\\n        n = len(s)\\n        dp = [[None for j in range(n-i+1)] for i in range(n)]\\n        for j in range(n-1, 0-1, -1):\\n            if s[j] == \"I\":\\n                if j == n-1:\\n                    dp[j][0] = 1\\n                    dp[j][1] = 0\\n                else:\\n                    dp[j][n-j] = 0\\n                    for i in range((n-j)-1, 0-1, -1):\\n                        dp[j][i] = dp[j+1][i]+dp[j][i+1]\\n            else:\\n                if j == n-1:\\n                    dp[j][0] = 0\\n                    dp[j][1] = 1\\n                else:\\n                    dp[j][0] = 0\\n                    for i in range(1, n-j+1):\\n                        dp[j][i] = dp[j+1][i-1]+dp[j][i-1]\\n        return sum([dp[0][i] for i in range(n+1)])%(10**9+7)\\n```\\n# Complexity\\n- Time complexity: $$O(n^2)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nIt only takes $O(1)$ to calculate the update step, we have `n + n-1 + n-2 + ... ` entries in the table, so $n^2$ time to compute every entry.\\n\\n- Space complexity: $$O(n^2)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nThe table has size $n^2$\\n\\n# Approach 3 DP + Double buffer\\n\\nWe notice that the update step only makes use of the last computed row and the current row being computed, so we can use two arrays and to calculate the whole ordeal, the space complexity will then be $O(n)$\\n```\\nclass Solution:\\n    def numPermsDISequence(self, s: str) -> int:\\n        n = len(s)\\n        dp = None\\n        for j in range(n-1, 0-1, -1):\\n            ndp = [None for i in range(n-j+1)]\\n            if s[j] == \"I\":\\n                if j == n-1:\\n                    ndp[0] = 1\\n                    ndp[1] = 0\\n                else:\\n                    ndp[n-j] = 0\\n                    for i in range((n-j)-1, 0-1, -1):\\n                        ndp[i] = dp[i]+ndp[i+1]\\n            else:\\n                if j == n-1:\\n                    ndp[0] = 0\\n                    ndp[1] = 1\\n                else:\\n                    ndp[0] = 0\\n                    for i in range(1, n-j+1):\\n                        ndp[i] = dp[i-1]+ndp[i-1]\\n            dp = ndp\\n        return sum(dp)%(10**9+7)\\n```\\n\\n# Approach 4 Optimized memory\\n\\nWe can make a solution with only one array, first notice that the update step of `\\'I\\'` is fairly easy to adapt to one array since the base case is in a completely new index, but in the `\\'D` case we need to update `i=0` so we set a variable `last` to remember the last value removed, but we need the last variable to update the next entry so we define an `nlast` to remember the variable that is about to be updated so that we can then update last with the  value that was before the update, whew... (see the code, it\\'s easier to understand)\\n\\n```\\nclass Solution:\\n    def numPermsDISequence(self, s: str) -> int:\\n        n = len(s)\\n        dp = [0 for _ in range(n+1)]\\n        for j in range(n-1, 0-1, -1):\\n            if s[j] == \"I\":\\n                if j == n-1:\\n                    dp[0] = 1\\n                    dp[1] = 0\\n                else:\\n                    dp[n-j] = 0\\n                    for i in range((n-j)-1, 0-1, -1):\\n                        dp[i] = dp[i]+dp[i+1]\\n            else:\\n                if j == n-1:\\n                    dp[0] = 0\\n                    dp[1] = 1\\n                else:\\n                    last = dp[0]\\n                    dp[0] = 0\\n                    for i in range(1, n-j+1):\\n                        nlast = dp[i]\\n                        dp[i] = last+dp[i-1]\\n                        last = nlast\\n        return sum(dp)%(10**9+7)\\n```\\n\\nAny comments or improvements are appreciated, thank you for reading!",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def numPermsDISequence(self, s: str) -> int:\\n        n = len(s)\\n        ans = [0]\\n        state = set()\\n        def backTrack(i, p):\\n            if i == n:\\n                ans[0] += 1\\n                return\\n            if s[i] == \"I\":\\n                for j in range(p+1, n+1):\\n                    if j not in state:\\n                        state.add(j)\\n                        backTrack(i+1, j)\\n                        state.remove(j)\\n            else:\\n                for j in range(0, p):\\n                    if j not in state:\\n                        state.add(j)\\n                        backTrack(i+1, j)\\n                        state.remove(j)\\n            return  \\n        for i in range(n+1):\\n            state.add(i)\\n            backTrack(0, i)\\n            state.remove(i)\\n        return ans[0]%(10**9+7)\\n```\n```\\nif s[n-1] == \\'I\\':\\n    #If we choose 1, then it is impossible to increase\\n    dp[n-1][0] = 1\\n    dp[n-1][1] = 0\\nelif s[n-1] == \\'D:\\n    #If we choose 0, then it is impossible to decrease\\n    dp[n-1][0] = 0\\n    dp[n-1][1] = 1\\n```\n```\\nif s[n-1] == \\'I\\':\\n    if i == n-1:\\n        #If we choose 1, then it is impossible to increase\\n        dp[n-1][0] = 1\\n        dp[n-1][1] = 0\\n    else:\\n        if j == n-i:\\n            dp[i][j] = 0\\n        else:\\n            dp[i][j] = dp[i][j+1] + dp[i+1][j]\\nelif s[n-1] == \\'D:\\n    if i == n-1:\\n        #If we choose 0, then it is impossible to decrease\\n        dp[n-1][0] = 0\\n        dp[n-1][1] = 1\\n    else:\\n        if j == 0:\\n            dp[i][j] = 0\\n        else:\\n            dp[i][j] = dp[i][j-1] + dp[i+1][j]\\n```\n```\\nclass Solution:\\n    def numPermsDISequence(self, s: str) -> int:\\n        n = len(s)\\n        dp = [[None for j in range(n-i+1)] for i in range(n)]\\n        for j in range(n-1, 0-1, -1):\\n            if s[j] == \"I\":\\n                if j == n-1:\\n                    dp[j][0] = 1\\n                    dp[j][1] = 0\\n                else:\\n                    dp[j][n-j] = 0\\n                    for i in range((n-j)-1, 0-1, -1):\\n                        dp[j][i] = dp[j+1][i]+dp[j][i+1]\\n            else:\\n                if j == n-1:\\n                    dp[j][0] = 0\\n                    dp[j][1] = 1\\n                else:\\n                    dp[j][0] = 0\\n                    for i in range(1, n-j+1):\\n                        dp[j][i] = dp[j+1][i-1]+dp[j][i-1]\\n        return sum([dp[0][i] for i in range(n+1)])%(10**9+7)\\n```\n```\\nclass Solution:\\n    def numPermsDISequence(self, s: str) -> int:\\n        n = len(s)\\n        dp = None\\n        for j in range(n-1, 0-1, -1):\\n            ndp = [None for i in range(n-j+1)]\\n            if s[j] == \"I\":\\n                if j == n-1:\\n                    ndp[0] = 1\\n                    ndp[1] = 0\\n                else:\\n                    ndp[n-j] = 0\\n                    for i in range((n-j)-1, 0-1, -1):\\n                        ndp[i] = dp[i]+ndp[i+1]\\n            else:\\n                if j == n-1:\\n                    ndp[0] = 0\\n                    ndp[1] = 1\\n                else:\\n                    ndp[0] = 0\\n                    for i in range(1, n-j+1):\\n                        ndp[i] = dp[i-1]+ndp[i-1]\\n            dp = ndp\\n        return sum(dp)%(10**9+7)\\n```\n```\\nclass Solution:\\n    def numPermsDISequence(self, s: str) -> int:\\n        n = len(s)\\n        dp = [0 for _ in range(n+1)]\\n        for j in range(n-1, 0-1, -1):\\n            if s[j] == \"I\":\\n                if j == n-1:\\n                    dp[0] = 1\\n                    dp[1] = 0\\n                else:\\n                    dp[n-j] = 0\\n                    for i in range((n-j)-1, 0-1, -1):\\n                        dp[i] = dp[i]+dp[i+1]\\n            else:\\n                if j == n-1:\\n                    dp[0] = 0\\n                    dp[1] = 1\\n                else:\\n                    last = dp[0]\\n                    dp[0] = 0\\n                    for i in range(1, n-j+1):\\n                        nlast = dp[i]\\n                        dp[i] = last+dp[i-1]\\n                        last = nlast\\n        return sum(dp)%(10**9+7)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3731618,
                "title": "simple-c-solution-dynamic-programming-recursion-memoization",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\nint mod=1e9+7;\\nlong long hope(int index,int prev,vector<int>&curr,vector<int>&visited,string &s,int &n,vector<vector<long long>>&dp){\\n    if(index>=s.length() && curr.size()==n+1)return 1;\\n    if(dp[index+1][prev+1]!=-1)return dp[index+1][prev+1];\\n    long long ans=0;\\n    if(index==-1){\\n        for(int i=0;i<=n;i++){\\n            curr.push_back(i);\\n            visited[i]=-1;\\n            ans=(ans%mod+hope(index+1,i,curr,visited,s,n,dp)%mod)%mod;\\n            curr.pop_back();\\n            visited[i]=0;\\n        }\\n    }\\n    else if(index!=-1){\\n        if(s[index]==\\'I\\'){\\n            int previous=prev;\\n            for(int i=previous+1;i<=n;i++){\\n                if(visited[i]!=-1){\\n                    curr.push_back(i);\\n            visited[i]=-1;\\n            ans=(ans%mod+hope(index+1,i,curr,visited,s,n,dp)%mod)%mod;\\n            curr.pop_back();\\n            visited[i]=0;\\n                }\\n            }\\n        }\\n        else if(s[index]==\\'D\\'){\\n            int previous=prev;\\n            for(int i=0;i<previous;i++){\\n                if(visited[i]!=-1){\\n                    curr.push_back(i);\\n            visited[i]=-1;\\n            ans=(ans%mod+hope(index+1,i,curr,visited,s,n,dp)%mod)%mod;\\n            curr.pop_back();\\n            visited[i]=0;\\n                }\\n            }\\n        }\\n    }\\n    return dp[index+1][prev+1]=ans%mod;\\n}\\n    int numPermsDISequence(string s) {\\n        int n=s.length();\\n  vector<int>visited(s.length()+1,0);\\n  vector<int>curr;\\n  vector<vector<long long>>dp(202,vector<long long>(202,-1));\\n  long long fa=hope(-1,-1,curr,visited,s,n,dp)%mod;\\n  int answer=fa;\\n  return answer;      \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\nint mod=1e9+7;\\nlong long hope(int index,int prev,vector<int>&curr,vector<int>&visited,string &s,int &n,vector<vector<long long>>&dp){\\n    if(index>=s.length() && curr.size()==n+1)return 1;\\n    if(dp[index+1][prev+1]!=-1)return dp[index+1][prev+1];\\n    long long ans=0;\\n    if(index==-1){\\n        for(int i=0;i<=n;i++){\\n            curr.push_back(i);\\n            visited[i]=-1;\\n            ans=(ans%mod+hope(index+1,i,curr,visited,s,n,dp)%mod)%mod;\\n            curr.pop_back();\\n            visited[i]=0;\\n        }\\n    }\\n    else if(index!=-1){\\n        if(s[index]==\\'I\\'){\\n            int previous=prev;\\n            for(int i=previous+1;i<=n;i++){\\n                if(visited[i]!=-1){\\n                    curr.push_back(i);\\n            visited[i]=-1;\\n            ans=(ans%mod+hope(index+1,i,curr,visited,s,n,dp)%mod)%mod;\\n            curr.pop_back();\\n            visited[i]=0;\\n                }\\n            }\\n        }\\n        else if(s[index]==\\'D\\'){\\n            int previous=prev;\\n            for(int i=0;i<previous;i++){\\n                if(visited[i]!=-1){\\n                    curr.push_back(i);\\n            visited[i]=-1;\\n            ans=(ans%mod+hope(index+1,i,curr,visited,s,n,dp)%mod)%mod;\\n            curr.pop_back();\\n            visited[i]=0;\\n                }\\n            }\\n        }\\n    }\\n    return dp[index+1][prev+1]=ans%mod;\\n}\\n    int numPermsDISequence(string s) {\\n        int n=s.length();\\n  vector<int>visited(s.length()+1,0);\\n  vector<int>curr;\\n  vector<vector<long long>>dp(202,vector<long long>(202,-1));\\n  long long fa=hope(-1,-1,curr,visited,s,n,dp)%mod;\\n  int answer=fa;\\n  return answer;      \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3633737,
                "title": "scala-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(n^2)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n^2)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nobject Solution {\\n    def numPermsDISequence(s: String): Int = {\\n      val n = s.length\\n      val dp = Array.ofDim[Int](n+2, 2)\\n      val mod = 1000000007\\n      dp(1)(0) = 1\\n      for (i <- 1 to n) \\n        if (s(i-1) == \\'I\\') for (j <- 0 to i) dp(j+1)(i%2) = (dp(j)((i+1)%2) + dp(j)(i%2)) % mod\\n        else for (j <- 0 to i) dp(j+1)(i%2) = ((dp(i)((i+1)%2) + mod - dp(j)((i+1)%2)) % mod + dp(j)(i%2)) % mod\\n      dp(n+1)(n%2)\\n    }\\n}\\n```",
                "solutionTags": [
                    "Scala"
                ],
                "code": "```\\nobject Solution {\\n    def numPermsDISequence(s: String): Int = {\\n      val n = s.length\\n      val dp = Array.ofDim[Int](n+2, 2)\\n      val mod = 1000000007\\n      dp(1)(0) = 1\\n      for (i <- 1 to n) \\n        if (s(i-1) == \\'I\\') for (j <- 0 to i) dp(j+1)(i%2) = (dp(j)((i+1)%2) + dp(j)(i%2)) % mod\\n        else for (j <- 0 to i) dp(j+1)(i%2) = ((dp(i)((i+1)%2) + mod - dp(j)((i+1)%2)) % mod + dp(j)(i%2)) % mod\\n      dp(n+1)(n%2)\\n    }\\n}\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3513915,
                "title": "solution",
                "content": "```C++ []\\nclass Solution {\\npublic:\\n        int numPermsDISequence(string S) {\\n        int n = S.length(), mod = 1e9 + 7;\\n        vector<vector<int>> dp(n + 1, vector<int>(n + 1));\\n        for (int j = 0; j <= n; j++) dp[0][j] = 1;\\n        for (int i = 0; i < n; i++)\\n            if (S[i] == \\'I\\')\\n                for (int j = 0, cur = 0; j < n - i; j++)\\n                    dp[i + 1][j] = cur = (cur + dp[i][j]) % mod;\\n            else\\n                for (int j = n - i - 1, cur = 0; j >= 0; j--)\\n                    dp[i + 1][j] = cur = (cur + dp[i][j + 1]) % mod;\\n        return dp[n][0];\\n    }\\n};\\n```\\n\\n```Python3 []\\nfrom itertools import accumulate\\n\\nclass Solution:\\n    def numPermsDISequence(self, S):\\n        dp = [1] * (len(S) + 1)\\n        for a, b in zip(\"I\" + S, S):\\n            dp = list(accumulate(dp[:-1] if a == b else dp[-1:0:-1]))\\n        return dp[0] % (10**9 + 7)\\n```\\n\\n```Java []\\nclass Solution {\\n\\tpublic int numPermsDISequence(String s) {\\n\\t\\tint length = s.length();\\n\\t\\tint mod = 1000000007;\\n\\t\\tint[] dp1 = new int[length + 1];\\n\\t\\tint[] dp2 = new int[length];\\n\\t\\tfor (int j = 0; j <= length; j++) {\\n\\t\\t\\tdp1[j] = 1;\\n\\t\\t}\\n\\t\\tfor (int i = 0; i < length; i++) {\\n\\t\\t\\tif (s.charAt(i) == \\'I\\') {\\n\\t\\t\\t\\tfor (int j = 0, curr = 0; j < length - i; j++) {\\n\\t\\t\\t\\t\\tdp2[j] = curr = (curr + dp1[j]) % mod;\\n\\t\\t\\t\\t}\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tfor (int j = length - i - 1, curr = 0; j >= 0; j--) {\\n\\t\\t\\t\\t\\tdp2[j] = curr = (curr + dp1[j + 1]) % mod;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\tdp1 = Arrays.copyOf(dp2, length);\\n\\t\\t}\\n\\t\\treturn dp1[0];\\n\\t}\\n}\\n```\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3"
                ],
                "code": "```C++ []\\nclass Solution {\\npublic:\\n        int numPermsDISequence(string S) {\\n        int n = S.length(), mod = 1e9 + 7;\\n        vector<vector<int>> dp(n + 1, vector<int>(n + 1));\\n        for (int j = 0; j <= n; j++) dp[0][j] = 1;\\n        for (int i = 0; i < n; i++)\\n            if (S[i] == \\'I\\')\\n                for (int j = 0, cur = 0; j < n - i; j++)\\n                    dp[i + 1][j] = cur = (cur + dp[i][j]) % mod;\\n            else\\n                for (int j = n - i - 1, cur = 0; j >= 0; j--)\\n                    dp[i + 1][j] = cur = (cur + dp[i][j + 1]) % mod;\\n        return dp[n][0];\\n    }\\n};\\n```\n```Python3 []\\nfrom itertools import accumulate\\n\\nclass Solution:\\n    def numPermsDISequence(self, S):\\n        dp = [1] * (len(S) + 1)\\n        for a, b in zip(\"I\" + S, S):\\n            dp = list(accumulate(dp[:-1] if a == b else dp[-1:0:-1]))\\n        return dp[0] % (10**9 + 7)\\n```\n```Java []\\nclass Solution {\\n\\tpublic int numPermsDISequence(String s) {\\n\\t\\tint length = s.length();\\n\\t\\tint mod = 1000000007;\\n\\t\\tint[] dp1 = new int[length + 1];\\n\\t\\tint[] dp2 = new int[length];\\n\\t\\tfor (int j = 0; j <= length; j++) {\\n\\t\\t\\tdp1[j] = 1;\\n\\t\\t}\\n\\t\\tfor (int i = 0; i < length; i++) {\\n\\t\\t\\tif (s.charAt(i) == \\'I\\') {\\n\\t\\t\\t\\tfor (int j = 0, curr = 0; j < length - i; j++) {\\n\\t\\t\\t\\t\\tdp2[j] = curr = (curr + dp1[j]) % mod;\\n\\t\\t\\t\\t}\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tfor (int j = length - i - 1, curr = 0; j >= 0; j--) {\\n\\t\\t\\t\\t\\tdp2[j] = curr = (curr + dp1[j + 1]) % mod;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\tdp1 = Arrays.copyOf(dp2, length);\\n\\t\\t}\\n\\t\\treturn dp1[0];\\n\\t}\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3466073,
                "title": "c-3ms-dp-top-down-prefix-sum",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\nint mod=1e9+7;\\n    int numPermsDISequence(string s) {\\n        int n=s.size();\\n        vector<vector<int>> dp(n+1,vector<int>(n+1));\\n        for(int i=0;i<=n;i++){\\n            dp[0][i]=1+i;\\n        }\\n        for(int i=1;i<=n;i++){\\n            for(int j=0;j<=n-i;j++){\\n                long long ans=0;\\n                if(s[i-1]==\\'I\\'){\\n                    ans=dp[i-1][n+1-i]-dp[i-1][j];\\n                    ans=(ans+mod)%mod;\\n                }\\n                else{\\n                    ans+=1LL*dp[i-1][j];\\n                    ans=(ans+mod)%mod;\\n                }\\n                if(j>0) ans+=dp[i][j-1];\\n                ans%=mod;\\n                dp[i][j]=ans;\\n            }\\n        }\\n        return dp[n][0];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\nint mod=1e9+7;\\n    int numPermsDISequence(string s) {\\n        int n=s.size();\\n        vector<vector<int>> dp(n+1,vector<int>(n+1));\\n        for(int i=0;i<=n;i++){\\n            dp[0][i]=1+i;\\n        }\\n        for(int i=1;i<=n;i++){\\n            for(int j=0;j<=n-i;j++){\\n                long long ans=0;\\n                if(s[i-1]==\\'I\\'){\\n                    ans=dp[i-1][n+1-i]-dp[i-1][j];\\n                    ans=(ans+mod)%mod;\\n                }\\n                else{\\n                    ans+=1LL*dp[i-1][j];\\n                    ans=(ans+mod)%mod;\\n                }\\n                if(j>0) ans+=dp[i][j-1];\\n                ans%=mod;\\n                dp[i][j]=ans;\\n            }\\n        }\\n        return dp[n][0];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3455905,
                "title": "o-n-2-dp-with-o-n-space",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n- dp[j] in the i-th round memorizes the number of permutations ends with j for s[0:i].\\n\\n- When s[i] is \\'D\\', update the ndp[j] with sum(dp[j:i]), which increases each element larger than j by one in the prefix.\\n- When s[i] is \\'I\\', update ndp[j] with sum(dp[0:j-1]) while keeping the prefix.\\n- Make use of the sum of prefix to get any sum(dp[j:i]) in $$O(1)$$\\n\\n\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: $$O(n^2)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: \\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n  int numPermsDISequence(string s) {\\n      int n=s.size(),mod=1e9+7;\\n      vector<int> dp{1};\\n      for(int i=0;i<n;i++){\\n          vector<int> pre{0}; //pre[i]=sum(dp[0:i-1])\\n          int tmp=0;\\n          for(auto j:dp) pre.emplace_back((j+pre.back())%mod);\\n          vector<int> ndp;\\n          if(s[i]==\\'D\\') for(int j=0;j<=i+1;j++) ndp.emplace_back(pre.back()>pre[j]?pre.back()-pre[j]:pre.back()-(pre[j]-mod)); //sum(dp[j,i])\\n          else for(int j=0;j<=i+1;j++) ndp.emplace_back(pre[j]); //sum(dp[0],...,dp[j-1])\\n          dp=ndp;\\n      }\\n      int result=0;\\n      for(auto i:dp)  result=(result+i)%mod;\\n      return result;\\n  }\\n};\\n\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n  int numPermsDISequence(string s) {\\n      int n=s.size(),mod=1e9+7;\\n      vector<int> dp{1};\\n      for(int i=0;i<n;i++){\\n          vector<int> pre{0}; //pre[i]=sum(dp[0:i-1])\\n          int tmp=0;\\n          for(auto j:dp) pre.emplace_back((j+pre.back())%mod);\\n          vector<int> ndp;\\n          if(s[i]==\\'D\\') for(int j=0;j<=i+1;j++) ndp.emplace_back(pre.back()>pre[j]?pre.back()-pre[j]:pre.back()-(pre[j]-mod)); //sum(dp[j,i])\\n          else for(int j=0;j<=i+1;j++) ndp.emplace_back(pre[j]); //sum(dp[0],...,dp[j-1])\\n          dp=ndp;\\n      }\\n      int result=0;\\n      for(auto i:dp)  result=(result+i)%mod;\\n      return result;\\n  }\\n};\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3228861,
                "title": "python-simple-dp",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def numPermsDISequence(self, s):\\n        n, mod = len(s), 10**9+7\\n\\n        @lru_cache(None)\\n        def dfs(i,val):\\n            if i == n:\\n                return 1\\n\\n            if s[i] == \"D\":\\n                if val == 0: return 0\\n                return dfs(i,val-1) + dfs(i+1,val-1)\\n\\n            if s[i] == \"I\":\\n                if val == n-i: return 0\\n                return dfs(i,val+1) + dfs(i+1,val)\\n\\n        return sum([dfs(0,j) for j in range(n+1)])%mod\\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def numPermsDISequence(self, s):\\n        n, mod = len(s), 10**9+7\\n\\n        @lru_cache(None)\\n        def dfs(i,val):\\n            if i == n:\\n                return 1\\n\\n            if s[i] == \"D\":\\n                if val == 0: return 0\\n                return dfs(i,val-1) + dfs(i+1,val-1)\\n\\n            if s[i] == \"I\":\\n                if val == n-i: return 0\\n                return dfs(i,val+1) + dfs(i+1,val)\\n\\n        return sum([dfs(0,j) for j in range(n+1)])%mod\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3200100,
                "title": "c-easy-solution-using-dp-backtraking-optimal-solution",
                "content": "\\n\\n# Complexity\\n- Time complexity:O($$N*N*N$$)\\n\\n- Space complexity:O($$N*N$$)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int mod=1e9+7;\\n    //TC=O(N*N*N)\\n    //SC=O(N*N)\\n    int find(int ind,int pre,string& s,int n,vector<bool>& vis,vector<vector<int>>& dp){\\n        if(ind==n){\\n            return 1;\\n        }\\n        if(dp[ind][pre+1]!=-1){\\n            return dp[ind][pre+1];\\n        }\\n        int way1=0,way2=0;\\n        if(pre==-1){\\n            for(int i=0;i<=n;i++){\\n                if(!vis[i]){\\n                    vis[i]=true;\\n                    way1=(way1+find(ind,i,s,n,vis,dp))%mod;\\n                    vis[i]=false;\\n                }\\n            }\\n            return way1%mod;\\n        }\\n        else{\\n            if(s[ind]==\\'D\\'){\\n                for(int i=0;i<=n;i++){\\n                    if(i<pre){\\n                        if(!vis[i]){\\n                            vis[i]=true;\\n                            way1=(way1+find(ind+1,i,s,n,vis,dp))%mod;\\n                            vis[i]=false;\\n                        }\\n                    }\\n                }\\n            }else{\\n                for(int i=0;i<=n;i++){\\n                    if(i>pre){\\n                        if(!vis[i]){\\n                            vis[i]=true;\\n                           \\n                            way2=(way2+find(ind+1,i,s,n,vis,dp))%mod;\\n                            vis[i]=false;\\n                        }\\n                    }\\n\\n                }\\n            }\\n        }\\n        return dp[ind][pre+1]=(way1+way2)%mod;\\n    }\\n    int numPermsDISequence(string s) {\\n        int n=s.size();\\n        vector<vector<int>> dp(n+1,vector<int>(n+2,-1));\\n        vector<bool> vis(n+1,false);\\n        return find(0,-1,s,n,vis,dp);\\n    }\\n};\\n```\\n# AUTHOR:JAYESH BADGUJAR\\n\\n",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Backtracking",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int mod=1e9+7;\\n    //TC=O(N*N*N)\\n    //SC=O(N*N)\\n    int find(int ind,int pre,string& s,int n,vector<bool>& vis,vector<vector<int>>& dp){\\n        if(ind==n){\\n            return 1;\\n        }\\n        if(dp[ind][pre+1]!=-1){\\n            return dp[ind][pre+1];\\n        }\\n        int way1=0,way2=0;\\n        if(pre==-1){\\n            for(int i=0;i<=n;i++){\\n                if(!vis[i]){\\n                    vis[i]=true;\\n                    way1=(way1+find(ind,i,s,n,vis,dp))%mod;\\n                    vis[i]=false;\\n                }\\n            }\\n            return way1%mod;\\n        }\\n        else{\\n            if(s[ind]==\\'D\\'){\\n                for(int i=0;i<=n;i++){\\n                    if(i<pre){\\n                        if(!vis[i]){\\n                            vis[i]=true;\\n                            way1=(way1+find(ind+1,i,s,n,vis,dp))%mod;\\n                            vis[i]=false;\\n                        }\\n                    }\\n                }\\n            }else{\\n                for(int i=0;i<=n;i++){\\n                    if(i>pre){\\n                        if(!vis[i]){\\n                            vis[i]=true;\\n                           \\n                            way2=(way2+find(ind+1,i,s,n,vis,dp))%mod;\\n                            vis[i]=false;\\n                        }\\n                    }\\n\\n                }\\n            }\\n        }\\n        return dp[ind][pre+1]=(way1+way2)%mod;\\n    }\\n    int numPermsDISequence(string s) {\\n        int n=s.size();\\n        vector<vector<int>> dp(n+1,vector<int>(n+2,-1));\\n        vector<bool> vis(n+1,false);\\n        return find(0,-1,s,n,vis,dp);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3177930,
                "title": "scala-clean-functional-dp",
                "content": "Let `dp[i][j]` be the number of permutations that `s[i:]` could form with the first number be the `j`th smallest candidate number.\\n\\nThen if `s[i] == \\'D\\'`, because for `dp[i][j]` we already choose the `j`th smallest possible value, we can only choose the candidate numbers before `j` for the `i+1`th position. So `dp[i][j] = dp[i + 1][0] + dp[i + 1][1] + ... + dp[i + 1][j - 1]`.\\n\\nThe same logic applies to the case when `s[i] == \\'I`. We can choose the `j + 1`th, `j + 2`th... candidate value for position `i + 1`.  Note that because `j`th value is taken, the `j + 1`th value in `i`\\'s candidate numbers will be the `j`th value in `i+1`\\'s candidate numbers. So `dp[i][j] = dp[i + 1][j] + dp[i + 1][j + 1] + ...`.\\n\\nBecause `dp[i][]` only depends on `dp[i + 1][]`, we can eliminate the first dimension of dp states to save some memory.\\n```Scala\\nobject Solution {\\n  def numPermsDISequence(s: String): Int = {\\n    val mod = (1e9 + 7).toInt\\n    def add(x: Int, y: Int) = ((x + y) % mod + mod) % mod\\n\\n    s.reverse.foldLeft(Vector(1)) {\\n      case (dp, \\'D\\') => Vector.tabulate(dp.size + 1)(j => (0 until j).map(dp).fold(0)(add))\\n      case (dp, \\'I\\') => Vector.tabulate(dp.size + 1)(j => (j until dp.size).map(dp).fold(0)(add))\\n      case _ => null\\n    }.reduce(add)\\n  }\\n}\\n```",
                "solutionTags": [],
                "code": "```Scala\\nobject Solution {\\n  def numPermsDISequence(s: String): Int = {\\n    val mod = (1e9 + 7).toInt\\n    def add(x: Int, y: Int) = ((x + y) % mod + mod) % mod\\n\\n    s.reverse.foldLeft(Vector(1)) {\\n      case (dp, \\'D\\') => Vector.tabulate(dp.size + 1)(j => (0 until j).map(dp).fold(0)(add))\\n      case (dp, \\'I\\') => Vector.tabulate(dp.size + 1)(j => (j until dp.size).map(dp).fold(0)(add))\\n      case _ => null\\n    }.reduce(add)\\n  }\\n}\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3094901,
                "title": "easy-c-beginner-friendly-dp-backtracking-solution",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> vis;\\n    int dp[202][202];\\n    int mod = 1000000007;\\n    int recur(string &s, int i, int n,int idx){\\n        if(idx==n-1){\\n            return 1;\\n        }\\n        if(dp[idx][i]!=-1)\\n            return dp[idx][i];\\n        \\n        int res = 0;\\n        if(s[idx]==\\'D\\'){\\n            for(int j=i-1;j>=0;j--){\\n                if(vis[j])  continue;\\n                vis[j] = 1;\\n                res = (res + (recur(s,j,n,idx+1))%mod)%mod;\\n                vis[j] = 0; \\n            }\\n        }\\n        else{\\n            for(int j=i+1;j<n;j++){\\n                if(vis[j])  continue;\\n                vis[j] = 1;\\n                res = (res + (recur(s,j,n,idx+1))%mod)%mod;\\n                vis[j] = 0;\\n            }\\n        }\\n        return dp[idx][i] = res;\\n    }\\n\\n    int numPermsDISequence(string s) {\\n        int n = s.size()+1;\\n        vis.resize(n,0);\\n        for(int i=0;i<202;i++){\\n            for(int j=0;j<202;j++){\\n                dp[i][j] = -1;\\n            }\\n        }\\n        int ans = 0;\\n        for(int i=0;i<n;i++){\\n            vis[i] = 1;\\n            ans = (ans + (recur(s,i,n,0))%mod)%mod;\\n            vis[i] = 0;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Backtracking"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> vis;\\n    int dp[202][202];\\n    int mod = 1000000007;\\n    int recur(string &s, int i, int n,int idx){\\n        if(idx==n-1){\\n            return 1;\\n        }\\n        if(dp[idx][i]!=-1)\\n            return dp[idx][i];\\n        \\n        int res = 0;\\n        if(s[idx]==\\'D\\'){\\n            for(int j=i-1;j>=0;j--){\\n                if(vis[j])  continue;\\n                vis[j] = 1;\\n                res = (res + (recur(s,j,n,idx+1))%mod)%mod;\\n                vis[j] = 0; \\n            }\\n        }\\n        else{\\n            for(int j=i+1;j<n;j++){\\n                if(vis[j])  continue;\\n                vis[j] = 1;\\n                res = (res + (recur(s,j,n,idx+1))%mod)%mod;\\n                vis[j] = 0;\\n            }\\n        }\\n        return dp[idx][i] = res;\\n    }\\n\\n    int numPermsDISequence(string s) {\\n        int n = s.size()+1;\\n        vis.resize(n,0);\\n        for(int i=0;i<202;i++){\\n            for(int j=0;j<202;j++){\\n                dp[i][j] = -1;\\n            }\\n        }\\n        int ans = 0;\\n        for(int i=0;i<n;i++){\\n            vis[i] = 1;\\n            ans = (ans + (recur(s,i,n,0))%mod)%mod;\\n            vis[i] = 0;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3066316,
                "title": "c-solution-beats-100",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe problem is asking us to find the number of permutations of a string of length n that satisfy the condition that the string only contains \\'I\\' and \\'D\\' and where \\'I\\' represents increasing and \\'D\\' represents decreasing.\\n\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nWe can use Dynamic Programming to solve this problem. We create a 2D array dp[n+1][n+1] where dp[i][j] represent the number of permutations of the first i characters that end with j \\'I\\'s.\\n\\nWe iterate through the string one character at a time, and for each character, we check if it is an \\'I\\' or a \\'D\\'. If it is an \\'I\\', we update dp[i][j] using dp[i-1][k] where k is from j to i-1. If it is a \\'D\\', we update dp[i][j] using dp[i-1][k] where k is from 0 to j-1.\\n\\n\\n# Complexity\\n- Time complexity: O(n^2)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n^2)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nint numPermsDISequence(char * s){\\n    int n = strlen(s), mod = 1e9 + 7;\\n    int dp[n + 1][n + 1];\\n    memset(dp, 0, sizeof(dp));\\n    dp[0][0] = 1;\\n    for (int i = 1; i <= n; i++)\\n    {\\n        for (int j = 0; j <= i; j++)\\n        {\\n            if (s[i - 1] == \\'D\\')\\n                for (int k = j; k < i; k++)\\n                    dp[i][j] = (dp[i][j] + dp[i - 1][k]) % mod;\\n            else\\n                for (int k = 0; k < j; k++)\\n                    dp[i][j] = (dp[i][j] + dp[i - 1][k]) % mod;\\n        }\\n    }\\n    int ans = 0;\\n    for (int i = 0; i <= n; i++)\\n        ans = (ans + dp[n][i]) % mod;\\n    return ans;\\n}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nint numPermsDISequence(char * s){\\n    int n = strlen(s), mod = 1e9 + 7;\\n    int dp[n + 1][n + 1];\\n    memset(dp, 0, sizeof(dp));\\n    dp[0][0] = 1;\\n    for (int i = 1; i <= n; i++)\\n    {\\n        for (int j = 0; j <= i; j++)\\n        {\\n            if (s[i - 1] == \\'D\\')\\n                for (int k = j; k < i; k++)\\n                    dp[i][j] = (dp[i][j] + dp[i - 1][k]) % mod;\\n            else\\n                for (int k = 0; k < j; k++)\\n                    dp[i][j] = (dp[i][j] + dp[i - 1][k]) % mod;\\n        }\\n    }\\n    int ans = 0;\\n    for (int i = 0; i <= n; i++)\\n        ans = (ans + dp[n][i]) % mod;\\n    return ans;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3007576,
                "title": "detailed-comments-for-an-o-n-2-solution",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n\\n    int numPermsDISequence(string s) {\\n        int N = s.size() + 1;\\n        vector<vector<int>> dp(N, vector<int>(N));\\n        const int mod = 1e9 + 7;\\n\\n        // dp[i][j] : answers for length=i+1 (using number [0,1,..,i]) that ends with j (j <= i)\\n        for (int j = 0; j < N; j++) {\\n            dp[0][j] = 1;\\n        }\\n\\n        for (int i = 1; i < N; i++) {\\n            for (int j = 0; j <= i; j++) {\\n                // when we append j to the array, in order to avoid duplicate, by default, all the elements >= j in the previous array will automatically increment by one\\n                // e.g. [2, 1, 0] + [1] => [3, 2, 0, 1]\\n\\n                if (s[i-1] == \\'I\\') {\\n                    // dp[i][j] = dp[i-1][0] + dp[i-1][1] + .. dp[i-1][j-1]\\n                    dp[i][j] = j ? dp[i-1][j-1] : 0;\\n                } else {\\n                    // dp[i][j] = dp[i-1][j] + dp[i-1][j+1] + .. dp[i-1][i-1]\\n                    dp[i][j] = dp[i-1][i-1] - (j ? dp[i-1][j-1] : 0);\\n                }\\n            }\\n\\n            // change dp[i][j] to prefix sum so that we can have O(N^2) overall complexity instead of O(N^3)\\n            for (int j = 1; j <= i; j++) {\\n                dp[i][j] += dp[i][j-1];\\n                dp[i][j] %= mod;\\n                if (dp[i][j] < 0) {\\n                    dp[i][j] += mod;\\n                }\\n            }\\n        }\\n\\n        return dp[N-1][N-1];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\n    int numPermsDISequence(string s) {\\n        int N = s.size() + 1;\\n        vector<vector<int>> dp(N, vector<int>(N));\\n        const int mod = 1e9 + 7;\\n\\n        // dp[i][j] : answers for length=i+1 (using number [0,1,..,i]) that ends with j (j <= i)\\n        for (int j = 0; j < N; j++) {\\n            dp[0][j] = 1;\\n        }\\n\\n        for (int i = 1; i < N; i++) {\\n            for (int j = 0; j <= i; j++) {\\n                // when we append j to the array, in order to avoid duplicate, by default, all the elements >= j in the previous array will automatically increment by one\\n                // e.g. [2, 1, 0] + [1] => [3, 2, 0, 1]\\n\\n                if (s[i-1] == \\'I\\') {\\n                    // dp[i][j] = dp[i-1][0] + dp[i-1][1] + .. dp[i-1][j-1]\\n                    dp[i][j] = j ? dp[i-1][j-1] : 0;\\n                } else {\\n                    // dp[i][j] = dp[i-1][j] + dp[i-1][j+1] + .. dp[i-1][i-1]\\n                    dp[i][j] = dp[i-1][i-1] - (j ? dp[i-1][j-1] : 0);\\n                }\\n            }\\n\\n            // change dp[i][j] to prefix sum so that we can have O(N^2) overall complexity instead of O(N^3)\\n            for (int j = 1; j <= i; j++) {\\n                dp[i][j] += dp[i][j-1];\\n                dp[i][j] %= mod;\\n                if (dp[i][j] < 0) {\\n                    dp[i][j] += mod;\\n                }\\n            }\\n        }\\n\\n        return dp[N-1][N-1];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2990982,
                "title": "just-a-runnable-solution",
                "content": "# Code\\n```\\nimpl Solution {\\n    pub fn num_perms_di_sequence(s: String) -> i32 {\\n        let n = s.len();\\n        let m = 1_000_000_007;\\n        let mut dp = vec![vec![0; n + 1]; n + 1];\\n        dp[0][0] = 1;\\n        for i in 1..=n {\\n            for j in 0..=i {\\n                if s.chars().nth(i - 1).unwrap() == \\'D\\' {\\n                    for k in j..=i - 1 {\\n                        dp[i][j] = dp[i][j] % m + dp[i - 1][k] % m;\\n                    }\\n                } else if j > 0 {\\n                    for k in 0..=j - 1 {\\n                        dp[i][j] = dp[i][j] % m + dp[i - 1][k] % m;\\n                    }\\n                }\\n            }\\n        }\\n        let mut res = 0;\\n        for i in 0..=n {\\n            res = res % m + dp[n][i] % m;\\n        }\\n        (res % m) as _\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nimpl Solution {\\n    pub fn num_perms_di_sequence(s: String) -> i32 {\\n        let n = s.len();\\n        let m = 1_000_000_007;\\n        let mut dp = vec![vec![0; n + 1]; n + 1];\\n        dp[0][0] = 1;\\n        for i in 1..=n {\\n            for j in 0..=i {\\n                if s.chars().nth(i - 1).unwrap() == \\'D\\' {\\n                    for k in j..=i - 1 {\\n                        dp[i][j] = dp[i][j] % m + dp[i - 1][k] % m;\\n                    }\\n                } else if j > 0 {\\n                    for k in 0..=j - 1 {\\n                        dp[i][j] = dp[i][j] % m + dp[i - 1][k] % m;\\n                    }\\n                }\\n            }\\n        }\\n        let mut res = 0;\\n        for i in 0..=n {\\n            res = res % m + dp[n][i] % m;\\n        }\\n        (res % m) as _\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2918004,
                "title": "python3-top-down-dp-o-n-2",
                "content": "```\\nclass Solution:\\n    def numPermsDISequence(self, s: str) -> int:\\n        n,ans = len(s),0\\n        mod = 1_00_00_00_000 + 7\\n        memo = [[-1] * 201 for i in range(201)]\\n        def dp(ind,prevNum):\\n            if ind < 0:\\n                return 1\\n            if memo[ind][prevNum] != -1:\\n                return memo[ind][prevNum]\\n            val = 0\\n            if s[ind] == \\'D\\':\\n                for more in range(prevNum+1,n+1):\\n                    if more not in vis:\\n                        vis.add(more)\\n                        val += dp(ind-1,more)\\n                        vis.remove(more)\\n            else:\\n                for less in range(prevNum):\\n                    if less not in vis:\\n                        vis.add(less)\\n                        val += dp(ind-1,less)\\n                        vis.remove(less)\\n            memo[ind][prevNum] = val\\n            return memo[ind][prevNum]\\n        for i in range(n+1):\\n            vis = set([i])\\n            ans += dp(n-1,i)\\n        return ans % mod\\n            \\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution:\\n    def numPermsDISequence(self, s: str) -> int:\\n        n,ans = len(s),0\\n        mod = 1_00_00_00_000 + 7\\n        memo = [[-1] * 201 for i in range(201)]\\n        def dp(ind,prevNum):\\n            if ind < 0:\\n                return 1\\n            if memo[ind][prevNum] != -1:\\n                return memo[ind][prevNum]\\n            val = 0\\n            if s[ind] == \\'D\\':\\n                for more in range(prevNum+1,n+1):\\n                    if more not in vis:\\n                        vis.add(more)\\n                        val += dp(ind-1,more)\\n                        vis.remove(more)\\n            else:\\n                for less in range(prevNum):\\n                    if less not in vis:\\n                        vis.add(less)\\n                        val += dp(ind-1,less)\\n                        vis.remove(less)\\n            memo[ind][prevNum] = val\\n            return memo[ind][prevNum]\\n        for i in range(n+1):\\n            vis = set([i])\\n            ans += dp(n-1,i)\\n        return ans % mod\\n            \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2862039,
                "title": "python-backtracking-works-and-easy-to-understand",
                "content": "```python\\nfrom functools import lru_cache\\nclass Solution:\\n    def numPermsDISequence(self, s):\\n        return self.backtrack(s) % (10**9 + 7)\\n\\n    def backtrack(self, s):  # with pruning and memo\\n        L = len(s)\\n        nums = set(range(-1, L + 1))  # dummy -1 as \\'pre\\', only happens when idx == 0 (in which case we don\\'t need var \\'pre\\')\\n\\n        @lru_cache(None)\\n        def backtrack(idx, pre):  # current index\\n            nums.remove(pre)\\n\\n            cnt = 0\\n            if not nums:            cnt = 1  # empty, it\\'s a valid permutation\\n            elif idx == 0:          cnt = sum(backtrack(idx + 1, num) for num in range(L + 1))\\n            elif s[idx - 1] == \\'D\\': cnt = sum(backtrack(idx + 1, num) for num in range(pre) if num in nums)\\n            elif s[idx - 1] == \\'I\\': cnt = sum(backtrack(idx + 1, num) for num in range(pre + 1, L + 1) if num in nums)\\n\\n            nums.add(pre)  # recover\\n            return cnt\\n\\n        return backtrack(0, -1)\\n```",
                "solutionTags": [
                    "Python",
                    "Backtracking",
                    "Memoization"
                ],
                "code": "```python\\nfrom functools import lru_cache\\nclass Solution:\\n    def numPermsDISequence(self, s):\\n        return self.backtrack(s) % (10**9 + 7)\\n\\n    def backtrack(self, s):  # with pruning and memo\\n        L = len(s)\\n        nums = set(range(-1, L + 1))  # dummy -1 as \\'pre\\', only happens when idx == 0 (in which case we don\\'t need var \\'pre\\')\\n\\n        @lru_cache(None)\\n        def backtrack(idx, pre):  # current index\\n            nums.remove(pre)\\n\\n            cnt = 0\\n            if not nums:            cnt = 1  # empty, it\\'s a valid permutation\\n            elif idx == 0:          cnt = sum(backtrack(idx + 1, num) for num in range(L + 1))\\n            elif s[idx - 1] == \\'D\\': cnt = sum(backtrack(idx + 1, num) for num in range(pre) if num in nums)\\n            elif s[idx - 1] == \\'I\\': cnt = sum(backtrack(idx + 1, num) for num in range(pre + 1, L + 1) if num in nums)\\n\\n            nums.add(pre)  # recover\\n            return cnt\\n\\n        return backtrack(0, -1)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2789671,
                "title": "c-backtracking-memoization",
                "content": "```\\nclass Solution {\\npublic:\\n    int visited[201];\\n    int mod = 1e9+7;\\n    map<pair<int,int>,int>mp;\\n    int solve(int idx , int last,string &s){\\n        //base case\\n        if(idx<0)return 1;\\n        \\n        if(mp.count({idx,last}))\\n            return mp[{idx,last}];\\n        int ans = 0 ;\\n        \\n        //hash means any number can be insertd at last position\\n        if(s[idx]==\\'#\\'){\\n            for(int i=0;i<s.size();i++){\\n                if(!visited[i]){\\n                    visited[i]=1;\\n                    ans = (ans + solve(idx-1,i,s))%mod;\\n                    visited[i]=0;\\n                }\\n            }\\n        }\\n        \\n        if(s[idx]==\\'D\\'){\\n            for(int i=last+1;i<s.size();i++){\\n                if(!visited[i]){\\n                    visited[i]=1;\\n                    ans = (ans + solve(idx-1,i,s))%mod;\\n                    visited[i]=0;\\n                }\\n            }            \\n        }\\n        \\n        if(s[idx]==\\'I\\'){\\n            for(int i=0;i<last;i++){\\n                if(!visited[i]){\\n                    visited[i]=1;\\n                    ans = (ans + solve(idx-1,i,s))%mod;\\n                    visited[i]=0;\\n                }\\n            }             \\n        }\\n        \\n        return mp[{idx,last}] = ans;\\n        \\n    }\\n    int numPermsDISequence(string s) {\\n        s.push_back(\\'#\\');\\n        int n=s.size();\\n        return solve(n-1,0,s);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Backtracking",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int visited[201];\\n    int mod = 1e9+7;\\n    map<pair<int,int>,int>mp;\\n    int solve(int idx , int last,string &s){\\n        //base case\\n        if(idx<0)return 1;\\n        \\n        if(mp.count({idx,last}))\\n            return mp[{idx,last}];\\n        int ans = 0 ;\\n        \\n        //hash means any number can be insertd at last position\\n        if(s[idx]==\\'#\\'){\\n            for(int i=0;i<s.size();i++){\\n                if(!visited[i]){\\n                    visited[i]=1;\\n                    ans = (ans + solve(idx-1,i,s))%mod;\\n                    visited[i]=0;\\n                }\\n            }\\n        }\\n        \\n        if(s[idx]==\\'D\\'){\\n            for(int i=last+1;i<s.size();i++){\\n                if(!visited[i]){\\n                    visited[i]=1;\\n                    ans = (ans + solve(idx-1,i,s))%mod;\\n                    visited[i]=0;\\n                }\\n            }            \\n        }\\n        \\n        if(s[idx]==\\'I\\'){\\n            for(int i=0;i<last;i++){\\n                if(!visited[i]){\\n                    visited[i]=1;\\n                    ans = (ans + solve(idx-1,i,s))%mod;\\n                    visited[i]=0;\\n                }\\n            }             \\n        }\\n        \\n        return mp[{idx,last}] = ans;\\n        \\n    }\\n    int numPermsDISequence(string s) {\\n        s.push_back(\\'#\\');\\n        int n=s.size();\\n        return solve(n-1,0,s);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2788203,
                "title": "js-solution-dp",
                "content": "```\\nvar numPermsDISequence = function(s) {\\n    let mod = 10**9+7,res = 0\\n    const dp = new Array(s.length+1).fill().map(()=>new Array)\\n    dp[0][0]=1\\n    for(i=1;i<s.length+1;i++) {\\n        if(s[i-1]===\\'D\\') {\\n            dp[i][i]=0\\n            for(j=i-1;j>=0;j--) {\\n                dp[i][j]=(dp[i][j+1]+dp[i-1][j])%mod\\n            }\\n        } else {\\n            dp[i][0]=0\\n            for(j=1;j<=i;j++) {\\n                dp[i][j]=(dp[i][j-1]+dp[i-1][j-1])%mod\\n            }\\n        }\\n    }\\n    dp[s.length].map((e)=>{res+=e%mod})\\n    return res%mod\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar numPermsDISequence = function(s) {\\n    let mod = 10**9+7,res = 0\\n    const dp = new Array(s.length+1).fill().map(()=>new Array)\\n    dp[0][0]=1\\n    for(i=1;i<s.length+1;i++) {\\n        if(s[i-1]===\\'D\\') {\\n            dp[i][i]=0\\n            for(j=i-1;j>=0;j--) {\\n                dp[i][j]=(dp[i][j+1]+dp[i-1][j])%mod\\n            }\\n        } else {\\n            dp[i][0]=0\\n            for(j=1;j<=i;j++) {\\n                dp[i][j]=(dp[i][j-1]+dp[i-1][j-1])%mod\\n            }\\n        }\\n    }\\n    dp[s.length].map((e)=>{res+=e%mod})\\n    return res%mod\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2465388,
                "title": "c-beginner-friendly-dp-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int mod=1000000007;\\n    int solve(string &s, int index, vector<bool> &vis, int last, vector<vector<int> > &dp){\\n        //if we reach the last index, there will be single element left we can do this in one way.\\n        if(index == s.size()){\\n            return 1;\\n        }\\n        \\n        if(dp[index][last] != -1) return dp[index][last];\\n        \\n        //when we need less than last one\\n        long long cnt = 0;\\n        if(s[index] == \\'D\\'){\\n            for(int i=0; i<last; i++){\\n                if(vis[i]) continue;\\n                vis[i] = true;\\n                cnt+=(solve(s, index+1, vis, i, dp))%mod;\\n                vis[i] = false;\\n            }\\n        }\\n        \\n        //when we need greater than last one\\n        else{\\n            for(int i=last+1; i<=s.size(); i++){\\n                if(vis[i]) continue;\\n                vis[i] = true;\\n                cnt+=(solve(s, index+1, vis, i, dp))%mod;\\n                vis[i] = false;\\n            }\\n        }\\n        \\n        return dp[index][last] = cnt%mod;\\n    }\\n    int numPermsDISequence(string s) {\\n        vector<bool> vis(s.size()+1, false);\\n        vector<vector<int> > dp(s.size()+2, vector<int>(s.size()+2, -1));\\n        \\n        //start with any number at first position, then apply conditions in function\\n        long long cnt = 0;\\n        for(int i=0; i<=s.size(); i++){\\n            vis[i] = true;\\n            cnt+=(solve(s, 0, vis, i, dp))%mod;\\n            vis[i] = false;\\n        }\\n        \\n        return cnt%mod;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int mod=1000000007;\\n    int solve(string &s, int index, vector<bool> &vis, int last, vector<vector<int> > &dp){\\n        //if we reach the last index, there will be single element left we can do this in one way.\\n        if(index == s.size()){\\n            return 1;\\n        }\\n        \\n        if(dp[index][last] != -1) return dp[index][last];\\n        \\n        //when we need less than last one\\n        long long cnt = 0;\\n        if(s[index] == \\'D\\'){\\n            for(int i=0; i<last; i++){\\n                if(vis[i]) continue;\\n                vis[i] = true;\\n                cnt+=(solve(s, index+1, vis, i, dp))%mod;\\n                vis[i] = false;\\n            }\\n        }\\n        \\n        //when we need greater than last one\\n        else{\\n            for(int i=last+1; i<=s.size(); i++){\\n                if(vis[i]) continue;\\n                vis[i] = true;\\n                cnt+=(solve(s, index+1, vis, i, dp))%mod;\\n                vis[i] = false;\\n            }\\n        }\\n        \\n        return dp[index][last] = cnt%mod;\\n    }\\n    int numPermsDISequence(string s) {\\n        vector<bool> vis(s.size()+1, false);\\n        vector<vector<int> > dp(s.size()+2, vector<int>(s.size()+2, -1));\\n        \\n        //start with any number at first position, then apply conditions in function\\n        long long cnt = 0;\\n        for(int i=0; i<=s.size(); i++){\\n            vis[i] = true;\\n            cnt+=(solve(s, 0, vis, i, dp))%mod;\\n            vis[i] = false;\\n        }\\n        \\n        return cnt%mod;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2450477,
                "title": "java-time-o-n-2-space-o-n-3ms-2ms-dp-n-1",
                "content": "```\\npublic int numPermsDISequence(String s) {\\n\\tint n = s.length();\\n\\tint[][] dp = new int [n+2][2];\\n\\tint mod = 1000000007;\\n\\tdp[1][0] = 1;\\n\\tfor(int i = 1; i<=n; i++){\\n\\t\\tif(s.charAt(i-1)==\\'I\\') {\\n\\t\\t\\tfor(int j = 0; j<=i; j++) dp[j+1][i&1]=(dp[j][(i+1)&1] + dp[j][i&1])%mod;  \\n\\t\\t} else {\\n\\t\\t\\tfor(int j = 0; j<=i; j++) dp[j+1][i&1]=((dp[i][(i+1)&1] + mod - dp[j][(i+1)&1])%mod + dp[j][i&1])%mod;\\n\\t\\t} \\n\\t}\\n\\treturn dp[n+1][n&1];\\n}\\n```\\nfrom dp[][] to dp[]\\n```\\npublic int numPermsDISequence(String s) {\\n\\tint n = s.length();\\n\\tint mod = 1000000007;\\n\\tint[] dp = new int[n+1];\\n\\tdp[0] = 1;\\n\\tint c, sum,prev;\\n\\tfor(int i = 1; i<=n; i++){\\n\\t\\tif(s.charAt(i-1)==\\'I\\') {\\n\\t\\t\\tsum = 0;\\n\\t\\t\\tfor(int j = 0; j<=i; j++){\\n\\t\\t\\t\\tprev = sum;\\n\\t\\t\\t\\tsum = (sum+dp[j])%mod;\\n\\t\\t\\t\\tdp[j] = prev;    \\n\\t\\t\\t} \\n\\t\\t} else {\\n\\t\\t\\tc = dp[i-1]+mod;\\n\\t\\t\\tsum = c%mod;\\n\\t\\t\\tfor(int j = 0; j<=i; j++) {\\n\\t\\t\\t\\tprev = sum;\\n\\t\\t\\t\\tsum = (sum+(c-dp[j])%mod)%mod;\\n\\t\\t\\t\\tdp[j] = prev;    \\n\\t\\t\\t }\\n\\t\\t} \\n\\t}\\n\\treturn dp[n]%mod;\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "```\\npublic int numPermsDISequence(String s) {\\n\\tint n = s.length();\\n\\tint[][] dp = new int [n+2][2];\\n\\tint mod = 1000000007;\\n\\tdp[1][0] = 1;\\n\\tfor(int i = 1; i<=n; i++){\\n\\t\\tif(s.charAt(i-1)==\\'I\\') {\\n\\t\\t\\tfor(int j = 0; j<=i; j++) dp[j+1][i&1]=(dp[j][(i+1)&1] + dp[j][i&1])%mod;  \\n\\t\\t} else {\\n\\t\\t\\tfor(int j = 0; j<=i; j++) dp[j+1][i&1]=((dp[i][(i+1)&1] + mod - dp[j][(i+1)&1])%mod + dp[j][i&1])%mod;\\n\\t\\t} \\n\\t}\\n\\treturn dp[n+1][n&1];\\n}\\n```\n```\\npublic int numPermsDISequence(String s) {\\n\\tint n = s.length();\\n\\tint mod = 1000000007;\\n\\tint[] dp = new int[n+1];\\n\\tdp[0] = 1;\\n\\tint c, sum,prev;\\n\\tfor(int i = 1; i<=n; i++){\\n\\t\\tif(s.charAt(i-1)==\\'I\\') {\\n\\t\\t\\tsum = 0;\\n\\t\\t\\tfor(int j = 0; j<=i; j++){\\n\\t\\t\\t\\tprev = sum;\\n\\t\\t\\t\\tsum = (sum+dp[j])%mod;\\n\\t\\t\\t\\tdp[j] = prev;    \\n\\t\\t\\t} \\n\\t\\t} else {\\n\\t\\t\\tc = dp[i-1]+mod;\\n\\t\\t\\tsum = c%mod;\\n\\t\\t\\tfor(int j = 0; j<=i; j++) {\\n\\t\\t\\t\\tprev = sum;\\n\\t\\t\\t\\tsum = (sum+(c-dp[j])%mod)%mod;\\n\\t\\t\\t\\tdp[j] = prev;    \\n\\t\\t\\t }\\n\\t\\t} \\n\\t}\\n\\treturn dp[n]%mod;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2352796,
                "title": "python3-solution",
                "content": "Solution, requires a bit of observation\\n\\n```\\nclass Solution:\\n    def numPermsDISequence(self, s: str) -> int:\\n        myStore = [1]\\n        \\n        for index, val in enumerate(s):\\n            if val == 0:\\n                continue\\n            temp = []\\n            for i in range(index + 2):\\n                if val == \"I\":\\n                    curr = sum(myStore[i:])\\n                else:\\n                    curr = sum(myStore[:i])\\n                temp.append(curr)\\n            myStore = temp\\n        return sum(myStore) % (10**9+7)\\n```\\n",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def numPermsDISequence(self, s: str) -> int:\\n        myStore = [1]\\n        \\n        for index, val in enumerate(s):\\n            if val == 0:\\n                continue\\n            temp = []\\n            for i in range(index + 2):\\n                if val == \"I\":\\n                    curr = sum(myStore[i:])\\n                else:\\n                    curr = sum(myStore[:i])\\n                temp.append(curr)\\n            myStore = temp\\n        return sum(myStore) % (10**9+7)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2349395,
                "title": "java-solution",
                "content": "class Solution {\\n    private static final int mod = 1000000007;\\n    int[] seen = null;\\n    Integer[][] dp = null;\\n    public int numPermsDISequence(String s) {\\n        dp = new Integer[s.length()][s.length()+1];\\n        seen = new int[s.length()+1];\\n        int count = 0;\\n        for(int i=0; i <= s.length(); i++) {\\n            seen[i] = 1;\\n        \\tcount = count % mod + numPerms(s, 0, i) % mod;\\n            seen[i] = 0;\\n        }\\n        return count % mod;\\n    }\\n    private int numPerms(String s, int j, int p){\\n        if(j == s.length())\\n            return 1;\\n        if(dp[j][p] != null) return dp[j][p];\\n        char ch = s.charAt(j);\\n        int count = 0;\\n        if(ch == \\'D\\'){\\n            for(int i=p-1; i >= 0; i--){\\n                if(seen[i] == 1)\\n                    continue;\\n                seen[i] = 1;\\n                count = count % mod + numPerms(s, j+1, i)  % mod;\\n                seen[i] = 0;\\n            }\\n        }else{\\n            for(int i=p+1; i <= s.length(); i++){\\n                if(seen[i] == 1)\\n                    continue;\\n                seen[i] = 1;\\n                count = count % mod + numPerms(s, j+1, i) % mod;\\n                seen[i] = 0;\\n            }\\n        }\\n        dp[j][p] = count % mod;\\n        return dp[j][p];\\n    }\\n}",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "class Solution {\\n    private static final int mod = 1000000007;\\n    int[] seen = null;\\n    Integer[][] dp = null;\\n    public int numPermsDISequence(String s) {\\n        dp = new Integer[s.length()][s.length()+1];\\n        seen = new int[s.length()+1];\\n        int count = 0;\\n        for(int i=0; i <= s.length(); i++) {\\n            seen[i] = 1;\\n        \\tcount = count % mod + numPerms(s, 0, i) % mod;\\n            seen[i] = 0;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2246352,
                "title": "anyone-can-modify-this-bfs-approach-with-tle",
                "content": "```\\nclass Solution {\\npublic:\\n    int numPermsDISequence(string s) {\\n        int n=s.length();\\n        queue<pair<string,unordered_set<int>>> q;\\n        unordered_set<int> v;\\n        string str=\"\";\\n        for(int i=0;i<=n;++i)\\n        {\\n            str=\"\";\\n            v.clear();\\n            str+=(i+\\'0\\');\\n            v.insert(i);\\n            q.push({str,v});\\n        }\\n        int i=0;\\n        unordered_set<string> visall;\\n        while(!q.empty())\\n        {\\n            int sz=q.size();\\n            if(i==n)\\n            {\\n                return q.size();\\n            }\\n            while(sz--)\\n            {\\n                auto temp=q.front();\\n                q.pop();\\n                if(visall.find(temp.first)!=visall.end())\\n                {\\n                    continue;\\n                }\\n                if(s[i]==\\'D\\')\\n                {\\n                    for(int j=temp.first.back()-\\'0\\'-1;j>=0;--j)\\n                    {\\n                        if(temp.second.find(j)==temp.second.end())\\n                        {\\n                            temp.first+=(j+\\'0\\');\\n                            temp.second.insert(j);\\n                            if(visall.find(temp.first)==visall.end())\\n                            {\\n                                q.push({temp.first,temp.second});\\n                            }\\n                            temp.second.erase(j);\\n                            temp.first.pop_back();\\n                        }\\n                    }\\n            }\\n                else\\n                {\\n                    for(int j=temp.first.back()-\\'0\\'+1;j<=n;++j)\\n                    {\\n                        if(temp.second.find(j)==temp.second.end())\\n                        {\\n                            temp.first+=(j+\\'0\\');\\n                            temp.second.insert(j);\\n                            if(visall.find(temp.first)==visall.end())\\n                            {\\n                                q.push({temp.first,temp.second});\\n                            }\\n                            temp.second.erase(j);\\n                            temp.first.pop_back();\\n                        }\\n                    }\\n                }\\n            }\\n            i++;\\n        }\\n        return 0;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int numPermsDISequence(string s) {\\n        int n=s.length();\\n        queue<pair<string,unordered_set<int>>> q;\\n        unordered_set<int> v;\\n        string str=\"\";\\n        for(int i=0;i<=n;++i)\\n        {\\n            str=\"\";\\n            v.clear();\\n            str+=(i+\\'0\\');\\n            v.insert(i);\\n            q.push({str,v});\\n        }\\n        int i=0;\\n        unordered_set<string> visall;\\n        while(!q.empty())\\n        {\\n            int sz=q.size();\\n            if(i==n)\\n            {\\n                return q.size();\\n            }\\n            while(sz--)\\n            {\\n                auto temp=q.front();\\n                q.pop();\\n                if(visall.find(temp.first)!=visall.end())\\n                {\\n                    continue;\\n                }\\n                if(s[i]==\\'D\\')\\n                {\\n                    for(int j=temp.first.back()-\\'0\\'-1;j>=0;--j)\\n                    {\\n                        if(temp.second.find(j)==temp.second.end())\\n                        {\\n                            temp.first+=(j+\\'0\\');\\n                            temp.second.insert(j);\\n                            if(visall.find(temp.first)==visall.end())\\n                            {\\n                                q.push({temp.first,temp.second});\\n                            }\\n                            temp.second.erase(j);\\n                            temp.first.pop_back();\\n                        }\\n                    }\\n            }\\n                else\\n                {\\n                    for(int j=temp.first.back()-\\'0\\'+1;j<=n;++j)\\n                    {\\n                        if(temp.second.find(j)==temp.second.end())\\n                        {\\n                            temp.first+=(j+\\'0\\');\\n                            temp.second.insert(j);\\n                            if(visall.find(temp.first)==visall.end())\\n                            {\\n                                q.push({temp.first,temp.second});\\n                            }\\n                            temp.second.erase(j);\\n                            temp.first.pop_back();\\n                        }\\n                    }\\n                }\\n            }\\n            i++;\\n        }\\n        return 0;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2246128,
                "title": "c-easy",
                "content": "class Solution {\\npublic:\\n    int mod = 1e9 + 7;\\n    // unordered_set<int>st;\\n    int perm(int i, int prev, int n, string &s, vector<vector<int>>&dp, vector<bool>&vis)\\n    {\\n        //cout<<\"HERE\"<<i<<\"\\\\n\";\\n        if(i<0)\\n        {\\n            return 1;\\n        }\\n        if(dp[i][prev] != -1)\\n        {\\n            return dp[i][prev];\\n        }\\n        \\n        int ways = 0;\\n        \\n        if(i == n)\\n        {\\n            for(int j=0; j<=n;j++)\\n            {\\n                int x = j;\\n                vis[x] = true;\\n                //cout<<x<<\"\\\\n\";\\n                ways = (ways + perm(i-1, x, n, s, dp, vis))%mod;\\n                //cout<<ways<<\" \"<<x<<\"\\\\n\";\\n                vis[x] = false;\\n            }\\n        }\\n        else\\n        {\\n            if(s[i] == \\'D\\')\\n            {\\n                for(int j=0; j<=n; j++)\\n                {\\n                    if(vis[j] == true) continue;\\n                    int x = j;\\n                    if(prev < x)\\n                    {\\n                        vis[x] = true;\\n                        ways = (ways + perm(i-1, x,n, s, dp, vis))%mod;\\n                        vis[x] = false;\\n                    }\\n                    \\n                }\\n            }\\n            else\\n            {\\n                for(int j=0; j<=n; j++)\\n                {\\n                    if(vis[j] == true) continue;\\n                    int x = j;\\n                    if(prev > x)\\n                    {\\n                        vis[x] = true;\\n                        ways = (ways + perm(i-1, x,n, s, dp, vis))%mod;\\n                        vis[x] = false;\\n                    }\\n                }\\n            }\\n        }\\n        return dp[i][prev] = ways;\\n    }\\n    \\n    \\n    int numPermsDISequence(string s) {\\n        vector<bool>vis(s.size()+10, -1);\\n        for(int i=0; i<= s.size();i++)\\n        {\\n            vis[i] = false;\\n            //cout<<i<<\"\\\\n\";\\n        }\\n        vector<vector<int>>dp(s.size()+10, vector<int>(s.size()+10, -1));\\n        return perm(s.size(), s.size()+5, s.size(), s, dp, vis);\\n        return 0;\\n    }\\n};",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "class Solution {\\npublic:\\n    int mod = 1e9 + 7;\\n    // unordered_set<int>st;\\n    int perm(int i, int prev, int n, string &s, vector<vector<int>>&dp, vector<bool>&vis)\\n    {\\n        //cout<<\"HERE\"<<i<<\"\\\\n\";\\n        if(i<0)\\n        {\\n            return 1;\\n        }",
                "codeTag": "C++"
            },
            {
                "id": 2245996,
                "title": "easy-c-solution-dp-recursion-memoization",
                "content": "```\\nclass Solution {\\npublic:\\n    \\n    int dp[201][201];\\n    int m = 1e9+7;\\n    int helper(string &s, int i, vector<bool> &visit, int start){\\n        if(i==s.length()){\\n            return 1;\\n        }\\n        \\n        if(dp[i][start]!=-1){\\n            return dp[i][start];\\n        }\\n        if(s[i]==\\'D\\'){\\n            int ans = 0;\\n            for(int j = 0;j < start;j++){\\n            \\n                if(visit[j]==false){\\n                    visit[j]=true;\\n                    ans = (ans%m + helper(s,i+1,visit,j)%m)%m;\\n                    visit[j]=false;\\n                }\\n            }\\n            return dp[i][start] = ans;\\n        }\\n        else{\\n            int ans = 0;\\n            for(int j = start+1;j <= s.length();j++){\\n            \\n                if(visit[j]==false){\\n                    visit[j]=true;\\n                    ans = (ans%m + helper(s,i+1,visit,j)%m)%m;\\n                    visit[j]=false;\\n                }\\n            }\\n            return dp[i][start] = ans;\\n        }\\n    }\\n    \\n    \\n    int numPermsDISequence(string s) {\\n        vector<bool> visit(s.length()+1,false);\\n        int ans = 0;\\n             memset(dp,-1,sizeof(dp));\\n        for(int i = 0; i <= s.length();i++){\\n            visit[i]=true;\\n       \\n            ans = (ans%m + helper(s,0,visit,i)%m)%m;\\n            visit[i]=false;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    int dp[201][201];\\n    int m = 1e9+7;\\n    int helper(string &s, int i, vector<bool> &visit, int start){\\n        if(i==s.length()){\\n            return 1;\\n        }\\n        \\n        if(dp[i][start]!=-1){\\n            return dp[i][start];\\n        }\\n        if(s[i]==\\'D\\'){\\n            int ans = 0;\\n            for(int j = 0;j < start;j++){\\n            \\n                if(visit[j]==false){\\n                    visit[j]=true;\\n                    ans = (ans%m + helper(s,i+1,visit,j)%m)%m;\\n                    visit[j]=false;\\n                }\\n            }\\n            return dp[i][start] = ans;\\n        }\\n        else{\\n            int ans = 0;\\n            for(int j = start+1;j <= s.length();j++){\\n            \\n                if(visit[j]==false){\\n                    visit[j]=true;\\n                    ans = (ans%m + helper(s,i+1,visit,j)%m)%m;\\n                    visit[j]=false;\\n                }\\n            }\\n            return dp[i][start] = ans;\\n        }\\n    }\\n    \\n    \\n    int numPermsDISequence(string s) {\\n        vector<bool> visit(s.length()+1,false);\\n        int ans = 0;\\n             memset(dp,-1,sizeof(dp));\\n        for(int i = 0; i <= s.length();i++){\\n            visit[i]=true;\\n       \\n            ans = (ans%m + helper(s,0,visit,i)%m)%m;\\n            visit[i]=false;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2245756,
                "title": "easy-c-solution",
                "content": "```\\nusing ll = long long;\\n\\nll dp[205][205];\\nconst ll mod = 1e9 + 7;\\nint n;\\n\\nll solve(int index, string &s, vector<int> &v, int piche)\\n{\\n    if (index >= s.size())\\n        return 1;\\n\\n    if (dp[index][piche] != -1)\\n        return dp[index][piche];\\n\\n    dp[index][piche] = 0;\\n\\n    if (s[index] == \\'D\\')\\n    {\\n        for (int i = 0; i < piche; ++i)\\n        {\\n            if (v[i] == 0)\\n            {\\n                v[i] = 1;\\n                dp[index][piche] += solve(index + 1, s, v, i);\\n                dp[index][piche] %= mod;\\n                v[i] = 0;\\n            }\\n        }\\n    }\\n    else\\n    {\\n        for (int i = piche + 1; i < n + 1; ++i)\\n        {\\n            if (v[i] == 0)\\n            {\\n                v[i] = 1;\\n                dp[index][piche] += solve(index + 1, s, v, i);\\n                dp[index][piche] %= mod;\\n                v[i] = 0;\\n            }\\n        }\\n    }\\n\\n    return dp[index][piche] %= mod;\\n\\n}\\n\\nclass Solution\\n{\\n    public:\\n        int numPermsDISequence(string s)\\n        {\\n            memset(dp, -1, sizeof(dp));\\n            n=s.size();\\n            \\n            if(n==1)\\n                return 1;\\n            \\n            vector<int>v(n+1,0);\\n            \\n            ll ans=0;\\n            \\n            for(int i=0;i<=n;++i)\\n            {\\n                v[i]=1;\\n                ans+=solve(0,s,v,i);\\n                ans%=mod;\\n                v[i]=0;\\n            }\\n            return ans;\\n            \\n        }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\nusing ll = long long;\\n\\nll dp[205][205];\\nconst ll mod = 1e9 + 7;\\nint n;\\n\\nll solve(int index, string &s, vector<int> &v, int piche)\\n{\\n    if (index >= s.size())\\n        return 1;\\n\\n    if (dp[index][piche] != -1)\\n        return dp[index][piche];\\n\\n    dp[index][piche] = 0;\\n\\n    if (s[index] == \\'D\\')\\n    {\\n        for (int i = 0; i < piche; ++i)\\n        {\\n            if (v[i] == 0)\\n            {\\n                v[i] = 1;\\n                dp[index][piche] += solve(index + 1, s, v, i);\\n                dp[index][piche] %= mod;\\n                v[i] = 0;\\n            }\\n        }\\n    }\\n    else\\n    {\\n        for (int i = piche + 1; i < n + 1; ++i)\\n        {\\n            if (v[i] == 0)\\n            {\\n                v[i] = 1;\\n                dp[index][piche] += solve(index + 1, s, v, i);\\n                dp[index][piche] %= mod;\\n                v[i] = 0;\\n            }\\n        }\\n    }\\n\\n    return dp[index][piche] %= mod;\\n\\n}\\n\\nclass Solution\\n{\\n    public:\\n        int numPermsDISequence(string s)\\n        {\\n            memset(dp, -1, sizeof(dp));\\n            n=s.size();\\n            \\n            if(n==1)\\n                return 1;\\n            \\n            vector<int>v(n+1,0);\\n            \\n            ll ans=0;\\n            \\n            for(int i=0;i<=n;++i)\\n            {\\n                v[i]=1;\\n                ans+=solve(0,s,v,i);\\n                ans%=mod;\\n                v[i]=0;\\n            }\\n            return ans;\\n            \\n        }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2172627,
                "title": "c-solution",
                "content": "```\\n//This is based on a couple others..\\n//I take no credit other than the obvious refactoring.\\n//I deliberately chose the one that seemed easier to understand, not the fastest.\\n\\npublic class Solution \\n{\\n    //Number of Permutations Table - Using long to avoid a lot of mod operations.\\n    long [,] np;\\n    int MOD;\\n    \\n    public void GetNumPermutationsEndingIn(int len, int end, int endStart, int endStop)\\n    {\\n        for(int k = endStart; k <= endStop; k++)\\n        {\\n            np[len,end] += np[len-1,k];\\n        }\\n        //This is just trying to keep the value from overflowing..\\n        if (np[len,end] > 0xFFFFFFFFFFFF)\\n        {\\n            np[len,end] = np[len,end]%this.MOD;\\n        }\\n    }\\n    \\n    public int NumPermsDISequence(string S) {\\n        int n = S.Length;\\n        this.MOD = 1000000000 + 7;\\n        this.np = new long[n+1,n+1];\\n        this.np[0,0] = 1;\\n        for(int len = 1; len <= n; len++)\\n        {\\n            for(int end = 0; end <= len; end++)\\n            {\\n                if(S[len-1] == \\'D\\')\\n                {\\n                    //Here the transformation is to decrease.  This means the previous MUST be bigger than this one.\\n                    //The starting point is apparently end not end-1 here to also include the number of permutations frm the previous as a starting point. \\n                    //The next np[len,end] is np[len-1,end] + np[len-1,end+1]... + np[len-1,len-1]\\n                    GetNumPermutationsEndingIn(len,end,  end/*prev end start*/, len-1/*prev end stop*/);\\n                }\\n                else\\n                {\\n                    //The next np[len,end] is np[len-1,0] + np[len-1,1]... + np[len-1,end-1]\\n                    GetNumPermutationsEndingIn(len,end,  0/*prev end start*/  , end-1/*prev end stop*/);\\n                }\\n            }\\n        }\\n        \\n        //To get the complete the complete set a simple sum is required.\\n        long res = 0;\\n        for(int i = 0; i <= n; i++)\\n        {\\n            res += np[n,i];\\n        }\\n        return (int)(res%MOD);\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\n//This is based on a couple others..\\n//I take no credit other than the obvious refactoring.\\n//I deliberately chose the one that seemed easier to understand, not the fastest.\\n\\npublic class Solution \\n{\\n    //Number of Permutations Table - Using long to avoid a lot of mod operations.\\n    long [,] np;\\n    int MOD;\\n    \\n    public void GetNumPermutationsEndingIn(int len, int end, int endStart, int endStop)\\n    {\\n        for(int k = endStart; k <= endStop; k++)\\n        {\\n            np[len,end] += np[len-1,k];\\n        }\\n        //This is just trying to keep the value from overflowing..\\n        if (np[len,end] > 0xFFFFFFFFFFFF)\\n        {\\n            np[len,end] = np[len,end]%this.MOD;\\n        }\\n    }\\n    \\n    public int NumPermsDISequence(string S) {\\n        int n = S.Length;\\n        this.MOD = 1000000000 + 7;\\n        this.np = new long[n+1,n+1];\\n        this.np[0,0] = 1;\\n        for(int len = 1; len <= n; len++)\\n        {\\n            for(int end = 0; end <= len; end++)\\n            {\\n                if(S[len-1] == \\'D\\')\\n                {\\n                    //Here the transformation is to decrease.  This means the previous MUST be bigger than this one.\\n                    //The starting point is apparently end not end-1 here to also include the number of permutations frm the previous as a starting point. \\n                    //The next np[len,end] is np[len-1,end] + np[len-1,end+1]... + np[len-1,len-1]\\n                    GetNumPermutationsEndingIn(len,end,  end/*prev end start*/, len-1/*prev end stop*/);\\n                }\\n                else\\n                {\\n                    //The next np[len,end] is np[len-1,0] + np[len-1,1]... + np[len-1,end-1]\\n                    GetNumPermutationsEndingIn(len,end,  0/*prev end start*/  , end-1/*prev end stop*/);\\n                }\\n            }\\n        }\\n        \\n        //To get the complete the complete set a simple sum is required.\\n        long res = 0;\\n        for(int i = 0; i <= n; i++)\\n        {\\n            res += np[n,i];\\n        }\\n        return (int)(res%MOD);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2053711,
                "title": "first-javascript-solution",
                "content": "```\\nfunction numPermsDISequence(s) {\\n    let mod = 1e9 + 7, dp = [[1], []], res = 0\\n\\n    for (let i = 1; i <= S.length; i++) {\\n        for (let j = 0; j <= i; j++) {\\n            let l = 0,  r = j\\n            if (s.charAt(i-1) === \\'D\\') {\\n                l = j, r = i\\n            }\\n            dp[1][j] = 0\\n            for (let k = l; k < r; k++) {\\n                dp[1][j] += dp[0][k]\\n                dp[1][j] %= mod\\n            }\\n        }\\n        [dp[0], dp[1]] = [dp[1], dp[0]]\\n    }\\n\\n    for (let cnt of dp.shift()) {\\n        res += cnt\\n        res %= mod\\n    }\\n    return res\\n}\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nfunction numPermsDISequence(s) {\\n    let mod = 1e9 + 7, dp = [[1], []], res = 0\\n\\n    for (let i = 1; i <= S.length; i++) {\\n        for (let j = 0; j <= i; j++) {\\n            let l = 0,  r = j\\n            if (s.charAt(i-1) === \\'D\\') {\\n                l = j, r = i\\n            }\\n            dp[1][j] = 0\\n            for (let k = l; k < r; k++) {\\n                dp[1][j] += dp[0][k]\\n                dp[1][j] %= mod\\n            }\\n        }\\n        [dp[0], dp[1]] = [dp[1], dp[0]]\\n    }\\n\\n    for (let cnt of dp.shift()) {\\n        res += cnt\\n        res %= mod\\n    }\\n    return res\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2053260,
                "title": "c-memoization-solution",
                "content": "```\\nclass Solution {\\nprivate:\\n    int n,mod=1000000000+7;\\n    vector<vector<int>>mem;\\n    int solve(string &s,int index,int prev,vector<bool>&seen){\\n        if(index==n){\\n            return 1;\\n        } else if(mem[index][prev]!=-1){\\n            return mem[index][prev];\\n        } else {\\n            int ans=0;\\n            if(s[index]==\\'D\\'){\\n                for(int i=0;i<prev;i++){\\n                    if(!seen[i]){\\n                        seen[i]=true;\\n                        ans=(ans%mod+solve(s,index+1,i,seen)%mod)%mod;\\n                        seen[i]=false;\\n                    }\\n                }\\n            } else {\\n                for(int i=prev+1;i<=n;i++){\\n                    if(!seen[i]){\\n                        seen[i]=true;\\n                        ans=(ans%mod+solve(s,index+1,i,seen)%mod)%mod;\\n                        seen[i]=false;\\n                    }\\n                }\\n            }\\n            return mem[index][prev]=ans;\\n        }\\n    }\\npublic:\\n    int numPermsDISequence(string &s) {\\n        n=s.size();\\n        int ans=0;\\n        mem=vector<vector<int>>(n+1,vector<int>(n+1,-1));\\n        vector<bool>seen(n+1,false);\\n        for(int i=0;i<=n;i++){\\n            seen[i]=true;\\n            ans=(ans%mod+solve(s,0,i,seen)%mod)%mod;\\n            seen[i]=false;\\n        }\\n        return ans;\\n    }\\n};",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "class Solution {\\nprivate:\\n    int n,mod=1000000000+7;\\n    vector<vector<int>>mem;\\n    int solve(string &s,int index,int prev,vector<bool>&seen){\\n        if(index==n){\\n            return 1;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1854816,
                "title": "python-solution-easy-explained-dp-well-writtten-code",
                "content": "Try putting Value at the position keeping in mind that the current value should be increasing or decreasing \\nTo check this check s[pos - 1] \\nNow since we cannot repeat any digit we should use a dictionary to keep in check what value we used so far .\\n\\nOnce you find the no. of answer having index  = i and last item = x , put it on dp\\n\\n\\n\\n\\n\\n```\\nclass Solution:\\n    def recursion(self,idx,s,prev,limit,val,used):\\n        if idx == limit + 1:\\n            return 1\\n        if (idx,prev) in self.dp:return self.dp[(idx,prev)]\\n        start = 0 if s[idx-1] == \\'D\\' else prev + 1\\n        end = prev -1 if s[idx-1] == \\'D\\' else limit\\n        ans = 0\\n        for i in range(start,end+1):\\n            if i in used and used[i]==True:continue\\n            used[i] = True\\n            ans+=self.recursion(idx+1,s,i,limit,val+str(i),used)\\n            used[i] = False\\n        self.dp[(idx,prev)]=ans\\n        return ans\\n    def numPermsDISequence(self, s: str) -> int:\\n        limit = len(s)\\n        ans = 0\\n        self.dp = {}\\n        for i in range(limit+1):\\n            ans+= self.recursion(1,s,i,limit,str(i),{i:True})\\n        return ans%1000000007\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution:\\n    def recursion(self,idx,s,prev,limit,val,used):\\n        if idx == limit + 1:\\n            return 1\\n        if (idx,prev) in self.dp:return self.dp[(idx,prev)]\\n        start = 0 if s[idx-1] == \\'D\\' else prev + 1\\n        end = prev -1 if s[idx-1] == \\'D\\' else limit\\n        ans = 0\\n        for i in range(start,end+1):\\n            if i in used and used[i]==True:continue\\n            used[i] = True\\n            ans+=self.recursion(idx+1,s,i,limit,val+str(i),used)\\n            used[i] = False\\n        self.dp[(idx,prev)]=ans\\n        return ans\\n    def numPermsDISequence(self, s: str) -> int:\\n        limit = len(s)\\n        ans = 0\\n        self.dp = {}\\n        for i in range(limit+1):\\n            ans+= self.recursion(1,s,i,limit,str(i),{i:True})\\n        return ans%1000000007\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1851457,
                "title": "memoization-dp",
                "content": "```\\nclass Solution {\\npublic:\\n    int dp[203][203];\\n    int mod=1e9+7;\\n    int solve(int index , string& s, vector<int> & visited , int prev){\\n        if(index==s.size()) return 1;\\n        if(dp[index][prev]!=-1) return dp[index][prev];\\n        int n=s.size();\\n        long long temp=0;\\n        if(s[index]==\\'D\\'){\\n            //0 to prev-1\\n            for(int i=0;i<=prev-1;i++){\\n                if(visited[i]==0){\\n                    visited[i]=1;\\n                    temp=(temp%mod+(long long)solve(index+1,s,visited,i)%mod)%mod;\\n\\n                    visited[i]=0;\\n                }\\n            }\\n        }else {\\n            //prev+1 to n\\n            for(int i=prev+1;i<=n;i++){\\n                if(visited[i]==0){\\n                    visited[i]=1;\\n                    temp=(temp%mod+(long long)solve(index+1,s,visited,i)%mod)%mod;\\n                    visited[i]=0;\\n                }\\n            }\\n        }\\n        return dp[index][prev]=temp;\\n    }\\n    int numPermsDISequence(string s) {\\n        memset(dp,-1,sizeof dp);\\n        int n=s.size();\\n        vector<int> visited(n+1,0);\\n        int count=0;\\n        for(int i=0;i<=n;i++){\\n            visited[i]=1;\\n            count= (count%mod+(long long)solve(0,s,visited,i)%mod)%mod;\\n            visited[i]=0;\\n        }\\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int dp[203][203];\\n    int mod=1e9+7;\\n    int solve(int index , string& s, vector<int> & visited , int prev){\\n        if(index==s.size()) return 1;\\n        if(dp[index][prev]!=-1) return dp[index][prev];\\n        int n=s.size();\\n        long long temp=0;\\n        if(s[index]==\\'D\\'){\\n            //0 to prev-1\\n            for(int i=0;i<=prev-1;i++){\\n                if(visited[i]==0){\\n                    visited[i]=1;\\n                    temp=(temp%mod+(long long)solve(index+1,s,visited,i)%mod)%mod;\\n\\n                    visited[i]=0;\\n                }\\n            }\\n        }else {\\n            //prev+1 to n\\n            for(int i=prev+1;i<=n;i++){\\n                if(visited[i]==0){\\n                    visited[i]=1;\\n                    temp=(temp%mod+(long long)solve(index+1,s,visited,i)%mod)%mod;\\n                    visited[i]=0;\\n                }\\n            }\\n        }\\n        return dp[index][prev]=temp;\\n    }\\n    int numPermsDISequence(string s) {\\n        memset(dp,-1,sizeof dp);\\n        int n=s.size();\\n        vector<int> visited(n+1,0);\\n        int count=0;\\n        for(int i=0;i<=n;i++){\\n            visited[i]=1;\\n            count= (count%mod+(long long)solve(0,s,visited,i)%mod)%mod;\\n            visited[i]=0;\\n        }\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1307997,
                "title": "compiling-both-o-n-2-approaches",
                "content": "The first approach is based on [this](https://leetcode.com/problems/valid-permutations-for-di-sequence/discuss/168278/C%2B%2BJavaPython-DP-Solution-O(N2)) post by lee215.\\n\\nIn both the cases we are avoiding looping through the values already looped through by the previous element by just using the previous values to make it O(n^2) instead of O(n^3).\\n```\\n// Runtime: 4ms\\nvoid firstApproach(string& s, int n, vvi&dp) {\\n        for (int i =0;i<=n;i++) dp[0][i] = 1;\\n        for (int i = 1;i<=n;i++) {\\n            if (s[i-1] == \\'I\\') {\\n                dp[i][0] = dp[i-1][0];\\n                for (int j=1;j<=n-i;j++) {\\n                    dp[i][j] = (dp[i][j-1] + dp[i-1][j])%mod; // summing dp[i-1][0..j]\\n                }\\n            } else {\\n                dp[i][n-i] = dp[i-1][n-i+1];\\n                for (int j=n-i-1;j>=0;j--) {\\n                    dp[i][j] = (dp[i][j+1] + dp[i-1][j+1])%mod; // summing dp[i-1][j+1...n-i+1]\\n                }\\n            }\\n        }\\n    }\\n```\\n\\n\\nThe second approach is based on the intuitions by wxd_sjtu [here](https://leetcode.com/problems/valid-permutations-for-di-sequence/discuss/196939/Easy-to-understand-solution-with-detailed-explanation), another great explanation by ariawynn [here](https://leetcode.com/problems/valid-permutations-for-di-sequence/discuss/186571/Python-O(N3)O(N2)-time-O(N)-space-DP-solution-with-clear-explanation-(no-%22relative-rank%22-stuff)).\\nA great visualisation for this approach is also provided by quadpixels [here](https://leetcode.com/problems/valid-permutations-for-di-sequence/discuss/169126/Visualization-Key-to-the-DP-solution:-imagine-cutting-a-piece-of-paper-and-separating-the-halves)\\n\\n```\\n// Runtime: 4ms\\nvoid secondApproach(string& s, int n, vvi&dp) {\\n       for (int i=0;i<=n;i++) dp[0][i] = 1;\\n       for (int i = 1;i<=n;i++) {\\n           if (s[i-1] == \\'I\\') {\\n              dp[i][1] = dp[i-1][0];\\n               for (int j = 2;j<=i;j++) {\\n                   dp[i][j] = (dp[i][j-1] + dp[i-1][j-1])%mod; // summing dp[i-1][0...j-1]\\n               } \\n           } else {\\n               dp[i][i-1] = dp[i-1][i-1];\\n               for (int j = i-2;j>=0;j--) {\\n                   dp[i][j] = (dp[i][j+1] + dp[i-1][j])%mod; // summing dp[i-1][j...i-1]\\n               }\\n           }\\n       }\\n   }\\n```\\n\\nBoilerplate:\\n```\\ntypedef vector<int> vi;\\ntypedef vector<vi> vvi;\\nint mod = 1e9+7;\\nint numPermsDISequence(string& s) {\\n\\tint n = s.size();\\n\\tvvi dp = vvi(n+1, vi(n+1,0));\\n\\tfirstApproach(s, n, dp);\\n\\t//secondApproach(s, n, dp);\\n\\tint ans =0;\\n\\tfor (int i: dp[n]) ans = (ans + i)%mod;\\n\\treturn ans;\\n}\\n```\\n\\nJust a compilation, kudos to the original posters.\\n",
                "solutionTags": [],
                "code": "```\\n// Runtime: 4ms\\nvoid firstApproach(string& s, int n, vvi&dp) {\\n        for (int i =0;i<=n;i++) dp[0][i] = 1;\\n        for (int i = 1;i<=n;i++) {\\n            if (s[i-1] == \\'I\\') {\\n                dp[i][0] = dp[i-1][0];\\n                for (int j=1;j<=n-i;j++) {\\n                    dp[i][j] = (dp[i][j-1] + dp[i-1][j])%mod; // summing dp[i-1][0..j]\\n                }\\n            } else {\\n                dp[i][n-i] = dp[i-1][n-i+1];\\n                for (int j=n-i-1;j>=0;j--) {\\n                    dp[i][j] = (dp[i][j+1] + dp[i-1][j+1])%mod; // summing dp[i-1][j+1...n-i+1]\\n                }\\n            }\\n        }\\n    }\\n```\n```\\n// Runtime: 4ms\\nvoid secondApproach(string& s, int n, vvi&dp) {\\n       for (int i=0;i<=n;i++) dp[0][i] = 1;\\n       for (int i = 1;i<=n;i++) {\\n           if (s[i-1] == \\'I\\') {\\n              dp[i][1] = dp[i-1][0];\\n               for (int j = 2;j<=i;j++) {\\n                   dp[i][j] = (dp[i][j-1] + dp[i-1][j-1])%mod; // summing dp[i-1][0...j-1]\\n               } \\n           } else {\\n               dp[i][i-1] = dp[i-1][i-1];\\n               for (int j = i-2;j>=0;j--) {\\n                   dp[i][j] = (dp[i][j+1] + dp[i-1][j])%mod; // summing dp[i-1][j...i-1]\\n               }\\n           }\\n       }\\n   }\\n```\n```\\ntypedef vector<int> vi;\\ntypedef vector<vi> vvi;\\nint mod = 1e9+7;\\nint numPermsDISequence(string& s) {\\n\\tint n = s.size();\\n\\tvvi dp = vvi(n+1, vi(n+1,0));\\n\\tfirstApproach(s, n, dp);\\n\\t//secondApproach(s, n, dp);\\n\\tint ans =0;\\n\\tfor (int i: dp[n]) ans = (ans + i)%mod;\\n\\treturn ans;\\n}\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1239404,
                "title": "c-easy",
                "content": "```c++\\nclass Solution {\\npublic:\\n    int n;\\n    string s;\\n    int mod = 1e9 + 7;\\n    map<pair<int,int>,int>dp;\\n    int countways(int id,int prev,vector<bool>&taken){\\n\\n        if(id==n+1){\\n            return 1;\\n        }\\n        if(dp.find({id,prev})!=dp.end()) return dp[{id,prev}];\\n        int ans = 0;\\n        if(s[id-1]==\\'D\\'){\\n            for(int i = 0;i<=prev;i++){\\n                if(taken[i]==true) continue;\\n                taken[i] = true;\\n                ans+=countways(id+1,i,taken)%mod;\\n                ans%=mod;\\n                taken[i] = false;\\n            }\\n        }\\n        else{\\n            for(int i = prev+1;i<=n;i++){\\n                if(taken[i]==true) continue;\\n                taken[i] = true;\\n                ans+=countways(id+1,i,taken)%mod;\\n                ans%=mod;\\n                taken[i] = false;\\n            }\\n        }\\n        return dp[{id,prev}] = ans%mod;\\n    }\\n    int numPermsDISequence(string _s) {\\n        s = _s;\\n        n = s.size();\\n        vector<bool>taken(n+1,false);\\n        int ans = 0;\\n        for(int i = 0;i<=n;i++){\\n            taken[i] = true;\\n            ans+=countways(1,i,taken)%mod;\\n            ans%=mod;\\n            taken[i] = false;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```c++\\nclass Solution {\\npublic:\\n    int n;\\n    string s;\\n    int mod = 1e9 + 7;\\n    map<pair<int,int>,int>dp;\\n    int countways(int id,int prev,vector<bool>&taken){\\n\\n        if(id==n+1){\\n            return 1;\\n        }\\n        if(dp.find({id,prev})!=dp.end()) return dp[{id,prev}];\\n        int ans = 0;\\n        if(s[id-1]==\\'D\\'){\\n            for(int i = 0;i<=prev;i++){\\n                if(taken[i]==true) continue;\\n                taken[i] = true;\\n                ans+=countways(id+1,i,taken)%mod;\\n                ans%=mod;\\n                taken[i] = false;\\n            }\\n        }\\n        else{\\n            for(int i = prev+1;i<=n;i++){\\n                if(taken[i]==true) continue;\\n                taken[i] = true;\\n                ans+=countways(id+1,i,taken)%mod;\\n                ans%=mod;\\n                taken[i] = false;\\n            }\\n        }\\n        return dp[{id,prev}] = ans%mod;\\n    }\\n    int numPermsDISequence(string _s) {\\n        s = _s;\\n        n = s.size();\\n        vector<bool>taken(n+1,false);\\n        int ans = 0;\\n        for(int i = 0;i<=n;i++){\\n            taken[i] = true;\\n            ans+=countways(1,i,taken)%mod;\\n            ans%=mod;\\n            taken[i] = false;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1210448,
                "title": "java-dp-o-n-3",
                "content": "```\\nclass Solution {\\n    int MOD = 1000000007;\\n    Map<Integer, Integer> cache;\\n    public int numPermsDISequence(String s) {\\n        cache = new HashMap<>();\\n        return dpRec(s, 0, 0, s.length(), new boolean[s.length()+1]);\\n    }\\n    private int dpRec(String s, int i, int x, int y, boolean[] vis) {\\n        if(i == s.length()){\\n            int j;\\n            for(j = x; j <= y; j++) if(vis[j] == false) break;\\n            return (j <= y) ? 1 : 0;\\n        } \\n        int key = i*40000 + x*200 + y;\\n        if(cache.containsKey(key)) return cache.get(key);\\n        int count = 0;\\n        for(int j = x; j <= y; j++) {\\n            if(vis[j] == false) {\\n                vis[j] = true;\\n                count += (s.charAt(i) == \\'D\\') ? dpRec(s, i+1, 0, j-1, vis) : dpRec(s, i+1, j+1, s.length(), vis);\\n                count = count%MOD;\\n                vis[j] = false;\\n            }\\n        }\\n        cache.put(key, count);\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    int MOD = 1000000007;\\n    Map<Integer, Integer> cache;\\n    public int numPermsDISequence(String s) {\\n        cache = new HashMap<>();\\n        return dpRec(s, 0, 0, s.length(), new boolean[s.length()+1]);\\n    }\\n    private int dpRec(String s, int i, int x, int y, boolean[] vis) {\\n        if(i == s.length()){\\n            int j;\\n            for(j = x; j <= y; j++) if(vis[j] == false) break;\\n            return (j <= y) ? 1 : 0;\\n        } \\n        int key = i*40000 + x*200 + y;\\n        if(cache.containsKey(key)) return cache.get(key);\\n        int count = 0;\\n        for(int j = x; j <= y; j++) {\\n            if(vis[j] == false) {\\n                vis[j] = true;\\n                count += (s.charAt(i) == \\'D\\') ? dpRec(s, i+1, 0, j-1, vis) : dpRec(s, i+1, j+1, s.length(), vis);\\n                count = count%MOD;\\n                vis[j] = false;\\n            }\\n        }\\n        cache.put(key, count);\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1181145,
                "title": "java-bottom-up-solution-dp",
                "content": "Let\\'s define our dp first:\\ndp[i][j]=permutations with lenght i with last digit j. The trick is that when you are iterating from i=1 to i=n, you select different j from 0 to i. Then, for each one of those j, you need to sum the relevant DPs. If S.charAt(i-1)=\\'I\\', then the prev digit should have been less than the current. So, we use the left half (0,j-1). If it is \\'D\\', then the prev digit should have been greater than the current one. So, we use (j,i-1). At the end, we sum up the last row dp[n][...] which means all the permuations with length n ending in different digits. Since the result might be big, be careful of the required mods.\\n```\\n   public int numPermsDISequence(String S) {\\n        int mod = 1_000_000_007;\\n        int n = S.length();\\n        long[][] dp = new long[n + 1][n + 1];\\n        dp[0][0] = 1;\\n        for (int i = 1; i <= n; i++) { // We start from 1 to\\n            char c = S.charAt(i - 1);\\n            for (int j = 0; j <= i; j++) { // curr: dp[i][...] prev dp[i-1][...]\\n                long sum = 0;\\n                if (c == \\'I\\') { // Increasing- the prev digit was less than the current->use prev(0,j-1)\\n                    for (int k = 0; k <= j - 1; k++) sum = (sum + dp[i - 1][k]) % mod;\\n                } else { // c==\\'D\\'- Decreasing- the prev digit was greater than the current->use prev(j,i-1)\\n                    for (int k = j; k <= i - 1; k++) sum = (sum + dp[i - 1][k]) % mod;\\n                }\\n                dp[i][j] = sum;\\n            }\\n        }\\n        Long res = 0L; // Sum the last row- dp[n][...]\\n        for (int i = 0; i <= n; i++) res = (res + dp[n][i]) % mod;\\n        res = res % mod;\\n        return res.intValue();\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n   public int numPermsDISequence(String S) {\\n        int mod = 1_000_000_007;\\n        int n = S.length();\\n        long[][] dp = new long[n + 1][n + 1];\\n        dp[0][0] = 1;\\n        for (int i = 1; i <= n; i++) { // We start from 1 to\\n            char c = S.charAt(i - 1);\\n            for (int j = 0; j <= i; j++) { // curr: dp[i][...] prev dp[i-1][...]\\n                long sum = 0;\\n                if (c == \\'I\\') { // Increasing- the prev digit was less than the current->use prev(0,j-1)\\n                    for (int k = 0; k <= j - 1; k++) sum = (sum + dp[i - 1][k]) % mod;\\n                } else { // c==\\'D\\'- Decreasing- the prev digit was greater than the current->use prev(j,i-1)\\n                    for (int k = j; k <= i - 1; k++) sum = (sum + dp[i - 1][k]) % mod;\\n                }\\n                dp[i][j] = sum;\\n            }\\n        }\\n        Long res = 0L; // Sum the last row- dp[n][...]\\n        for (int i = 0; i <= n; i++) res = (res + dp[n][i]) % mod;\\n        res = res % mod;\\n        return res.intValue();\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1119442,
                "title": "python3-top-down-dp",
                "content": "```\\nfrom functools import lru_cache\\nclass Solution:\\n    def numPermsDISequence(self, S: str) -> int:\\n        n = len(S) + 1\\n        @lru_cache(maxsize = 40000)\\n        def dfs(lastPos, pos):\\n            total = 0\\n            if pos == 0:\\n                for i in range(n):\\n                    total += dfs(i, pos + 1)\\n                return total%1000000007\\n            letter = S[pos - 1]\\n            if pos == len(S):\\n                if letter == \\'I\\':\\n                    return 1 - lastPos\\n                else:\\n                    return lastPos\\n            else:\\n                if letter == \\'I\\':\\n                    for i in range(lastPos, n-pos):\\n                        total += dfs(i, pos + 1)\\n                else:\\n                    for i in range(lastPos):\\n                        total += dfs(i, pos + 1)\\n                        \\n                return total%1000000007\\n            \\n        return dfs(0,0)%1000000007\\n```",
                "solutionTags": [],
                "code": "```\\nfrom functools import lru_cache\\nclass Solution:\\n    def numPermsDISequence(self, S: str) -> int:\\n        n = len(S) + 1\\n        @lru_cache(maxsize = 40000)\\n        def dfs(lastPos, pos):\\n            total = 0\\n            if pos == 0:\\n                for i in range(n):\\n                    total += dfs(i, pos + 1)\\n                return total%1000000007\\n            letter = S[pos - 1]\\n            if pos == len(S):\\n                if letter == \\'I\\':\\n                    return 1 - lastPos\\n                else:\\n                    return lastPos\\n            else:\\n                if letter == \\'I\\':\\n                    for i in range(lastPos, n-pos):\\n                        total += dfs(i, pos + 1)\\n                else:\\n                    for i in range(lastPos):\\n                        total += dfs(i, pos + 1)\\n                        \\n                return total%1000000007\\n            \\n        return dfs(0,0)%1000000007\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1115156,
                "title": "java",
                "content": "```\\npublic int numPermsDISequence(String S) {\\n        int n = S.length(), mod = (int)1e9 + 7;\\n        int[][] dp = new int[n + 1][n + 1];\\n        for (int j = 0; j <= n; j++) dp[0][j] = 1;\\n        for (int i = 0; i < n; i++)\\n            if (S.charAt(i) == \\'I\\')\\n                for (int j = 0, cur = 0; j < n - i; j++)\\n                    dp[i + 1][j] = cur = (cur + dp[i][j]) % mod;\\n            else\\n                for (int j = n - i - 1, cur = 0; j >= 0; j--)\\n                    dp[i + 1][j] = cur = (cur + dp[i][j + 1]) % mod;\\n        return dp[n][0];\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\npublic int numPermsDISequence(String S) {\\n        int n = S.length(), mod = (int)1e9 + 7;\\n        int[][] dp = new int[n + 1][n + 1];\\n        for (int j = 0; j <= n; j++) dp[0][j] = 1;\\n        for (int i = 0; i < n; i++)\\n            if (S.charAt(i) == \\'I\\')\\n                for (int j = 0, cur = 0; j < n - i; j++)\\n                    dp[i + 1][j] = cur = (cur + dp[i][j]) % mod;\\n            else\\n                for (int j = n - i - 1, cur = 0; j >= 0; j--)\\n                    dp[i + 1][j] = cur = (cur + dp[i][j + 1]) % mod;\\n        return dp[n][0];\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 976437,
                "title": "c-dp-o-n-3",
                "content": "```\\n///v2[i][j] stores value of i!/((i-j)!*j!) \\n///v1[i][j] stores permutations for DI seq from j to j+i-1 \\n#define ll long long\\nclass Solution {\\npublic:\\n    ll p = 1e9+7;\\n    int numPermsDISequence(string s){\\n        ll n = s.size();\\n        vector < vector < ll > > v1( n+1 , vector<ll> ( n+1 , 1 ) );\\n        vector < vector < ll > > v2 = v1;\\n        for( int i = 1 ; i <= n ; i++) { \\n            for( int j = 0 ; j <= i ; j++) {\\n                if( j==0 || j==i ) v2[i][j] = 1 ;\\n                else v2[i][j] = ( v2[i-1][j-1] + v2[i-1][j] ) % p;\\n            }\\n        }\\n        for(ll i = 2 ; i <= n ; i++) {\\n            for(ll j = 0 ; j+i-1 < n ; j++) {\\n                v1[i][j] = 0 ;\\n                for(ll k = j ;k < i + j -1 ; k++) {\\n                    if( s[k] == \\'I\\' && s[k+1] == \\'D\\' ) {\\n                        v1[i][j] = ( v1[i][j] + ( ( v2[i][k+1-j] * v1[k-j][j] ) %p ) * v1[i+j-k-2][k+2] ) % p;\\n                    }\\n                }\\n                if( s[j] == \\'D\\' ) v1[i][j] = ( v1[i][j] + v1[i-1][j+1] ) %p;\\n                if( s[i+j-1] == \\'I\\' ) v1[i][j] = ( v1[i][j] + v1[i-1][j] ) %p;\\n            }\\n        }\\n        return v1[n][0];\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    ll p = 1e9+7;\\n    int numPermsDISequence(string s){\\n        ll n = s.size();\\n        vector < vector < ll > > v1( n+1 , vector<ll> ( n+1 , 1 ) );\\n        vector < vector < ll > > v2 = v1;\\n        for( int i = 1 ; i <= n ; i++) { \\n            for( int j = 0 ; j <= i ; j++) {\\n                if( j==0 || j==i ) v2[i][j] = 1 ;\\n                else v2[i][j] = ( v2[i-1][j-1] + v2[i-1][j] ) % p;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 901920,
                "title": "cpp14-dp-solution",
                "content": "```\\n\\nconst int mod = 1e9+7;\\n\\nclass Solution {\\npublic:\\n    int numPermsDISequence(string S) {\\n        int dp[205][205];\\n        memset(dp , 0 ,sizeof dp) ;\\n        int n = S.length();\\n        for(int j = 1 ; j <= n + 1  ; ++j) dp[1][j] = 1;\\n\\n        for(int i = 2 ; i <= n + 1  ; ++i){\\n           // cout << \" i is \" << i << endl ; \\n            if(S[i - 2] == \\'D\\'){\\n                /// p[i] > p[i+1]\\n                int sum = 0;\\n                for(int j = n - i + 2 ; j >= 1 ; --j){\\n                    sum = sum + dp[i-1][j+1];\\n                    sum = sum % mod ;\\n                    dp[i][j] = sum ;\\n                }\\n            }\\n            else if(S[i-2] == \\'I\\'){\\n                /// p[i] < p[i+1]\\n                int sum = 0;\\n                for(int j = 1 ; j <= n - i + 2 ; ++j){\\n                    sum = sum + dp[i-1][j];\\n                    sum = sum % mod ;\\n                    dp[i][j] = sum ;\\n                }\\n            }\\n    \\n        }\\n        return dp[n+1][1] ;\\n    }\\n};\\n\\n```",
                "solutionTags": [],
                "code": "```\\n\\nconst int mod = 1e9+7;\\n\\nclass Solution {\\npublic:\\n    int numPermsDISequence(string S) {\\n        int dp[205][205];\\n        memset(dp , 0 ,sizeof dp) ;\\n        int n = S.length();\\n        for(int j = 1 ; j <= n + 1  ; ++j) dp[1][j] = 1;\\n\\n        for(int i = 2 ; i <= n + 1  ; ++i){\\n           // cout << \" i is \" << i << endl ; \\n            if(S[i - 2] == \\'D\\'){\\n                /// p[i] > p[i+1]\\n                int sum = 0;\\n                for(int j = n - i + 2 ; j >= 1 ; --j){\\n                    sum = sum + dp[i-1][j+1];\\n                    sum = sum % mod ;\\n                    dp[i][j] = sum ;\\n                }\\n            }\\n            else if(S[i-2] == \\'I\\'){\\n                /// p[i] < p[i+1]\\n                int sum = 0;\\n                for(int j = 1 ; j <= n - i + 2 ; ++j){\\n                    sum = sum + dp[i-1][j];\\n                    sum = sum % mod ;\\n                    dp[i][j] = sum ;\\n                }\\n            }\\n    \\n        }\\n        return dp[n+1][1] ;\\n    }\\n};\\n\\n```",
                "codeTag": "C++"
            },
            {
                "id": 898513,
                "title": "java-dp-solution-time-compexity-o-n2-space-complexity-o-n",
                "content": "```\\nclass Solution {\\n    public int numPermsDISequence(String S) {\\n        int MOD = 1000000007;\\n        int N = S.length();\\n        int [] dp = new int [N+1];\\n        dp[0] =1;\\n        int sum = 0;\\n        for(int i =1;i<=N;i++){\\n            char ch = S.charAt(i-1);\\n            int [] dp2 = new int[N+1];\\n            if(ch == \\'I\\'){\\n                for(int j = 1;j<=i;j++)\\n                    dp2[j] = (dp2[j-1]+dp[j-1])%MOD;\\n            }\\n            else{\\n                 for(int j = i-1;j>=0;j--)\\n                    dp2[j] = (dp2[j+1]+dp[j])%MOD;\\n            }\\n            dp = dp2;\\n        }\\n        int ans = 0;\\n        for(int num : dp)\\n            ans = (ans+num)%MOD;\\n        return ans;\\n    }\\n}\\n\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int numPermsDISequence(String S) {\\n        int MOD = 1000000007;\\n        int N = S.length();\\n        int [] dp = new int [N+1];\\n        dp[0] =1;\\n        int sum = 0;\\n        for(int i =1;i<=N;i++){\\n            char ch = S.charAt(i-1);\\n            int [] dp2 = new int[N+1];\\n            if(ch == \\'I\\'){\\n                for(int j = 1;j<=i;j++)\\n                    dp2[j] = (dp2[j-1]+dp[j-1])%MOD;\\n            }\\n            else{\\n                 for(int j = i-1;j>=0;j--)\\n                    dp2[j] = (dp2[j+1]+dp[j])%MOD;\\n            }\\n            dp = dp2;\\n        }\\n        int ans = 0;\\n        for(int num : dp)\\n            ans = (ans+num)%MOD;\\n        return ans;\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 876768,
                "title": "python-dp-o-n-2",
                "content": "```\\nclass Solution:\\n    def numPermsDISequence(self, S: str) -> int:\\n        M = 10**9 + 7\\n        C = [1] + [0 for _ in range(len(S))]\\n        for n, id in enumerate(list(S), start=2):\\n            if id == \\'I\\':\\n                C = [sum(C[j - 1] for j in range(1, k)) % M for\\n                     k in range(1, n + 1)]\\n            elif id == \\'D\\':\\n                C = [sum(C[j - 1] for j in range(k, n)) % M for\\n                     k in range(1, n + 1)]\\n        return sum(C) % M\\n```\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def numPermsDISequence(self, S: str) -> int:\\n        M = 10**9 + 7\\n        C = [1] + [0 for _ in range(len(S))]\\n        for n, id in enumerate(list(S), start=2):\\n            if id == \\'I\\':\\n                C = [sum(C[j - 1] for j in range(1, k)) % M for\\n                     k in range(1, n + 1)]\\n            elif id == \\'D\\':\\n                C = [sum(C[j - 1] for j in range(k, n)) % M for\\n                     k in range(1, n + 1)]\\n        return sum(C) % M\\n```",
                "codeTag": "Java"
            },
            {
                "id": 866925,
                "title": "js-solution",
                "content": "```js\\n/**\\n * @param {string} S\\n * @return {number}\\n */\\nexport default (S) => {\\n  let dp = [];\\n  const len = S.length;\\n  const mod = Math.pow(10, 9) + 7;\\n  // S=DID\\n  // len = 4,\\u6240\\u4EE5\\u8FD9\\u91CC\\u67090\\uFF0C1\\uFF0C2\\uFF0C3\\u56DB\\u4E2A\\u6570\\u5B57\\u9700\\u8981\\u653E\\u7F6E\\uFF0C\\n  // dp[i][j] \\u8868\\u793Ai\\u4E2A\\u6570\\u5B57\\u653E\\u7F6E\\u5B8C\\u6BD5\\uFF0C\\u5728\\u5269\\u4E0B\\u7684\\u6570\\u5B57\\u91CC\\u8FB9\\u9009\\u62E9\\u7B2Cj\\u4F4D\\u7684\\u4E2A\\u6570\\n  // \\u6BD4\\u5982d[3][0] \\u8868\\u793A\\u57280\\uFF0C1\\uFF0C2\\uFF0C3\\u4E2D\\u5DF2\\u7ECF\\u9009\\u62E9\\u4E86\\u4E09\\u4E2A\\u6570\\u5B57\\uFF0C\\u6309\\u7167DID\\u7684\\u8981\\u6C42\\u5DF2\\u7ECF\\u653E\\u7F6E\\u5B8C\\u6BD5\\u4E86\\uFF0C\\u7136\\u540E\\u5728\\u5269\\u4E0B\\u7684\\u6570\\u5B57\\u91CC\\u8FB9\\u9009\\u62E9\\u4F4D\\u7F6E\\u4E3A0\\u7684\\u6570\\u5B57\\n  for (let i = 0; i <= len; i++) {\\n    dp[i] = [];\\n  }\\n  // \\u56E0\\u4E3A\\u67090\\uFF0C1\\uFF0C2\\uFF0C3 \\u56DB\\u4E2A\\u6570\\u5B57\\n  // dp[0][0] = 1, [0]\\n  // dp[0][1] = 1, [1]\\n  // dp[0][2] = 1, [2]\\n  // dp[0][3] = 1, [3]\\n  for (let i = 0; i <= len; i++) {\\n    dp[0][i] = 1;\\n  }\\n  // \\u8BA1\\u7B97dp[len][0]\\n  for (let i = 0; i < len; i++) {\\n    if (S.charAt(i) == \"I\") {\\n      // \\u56E0\\u4E3A\\u5DF2\\u7ECF\\u6709i\\u4E2A\\u6570\\u5B57\\u5DF2\\u7ECF\\u88AB\\u653E\\u7F6E\\u597D\\u4E86\\n      // \\u6BD4\\u5982\\u5F53i=0\\u7684\\u65F6\\u5019\\uFF0C\\u4E00\\u5171\\u9700\\u8981\\u653E0\\uFF0C1\\uFF0C2\\uFF0C3\\uFF0Ci=0\\uFF0C\\u5C31\\u662F\\u5DF2\\u7ECF0\\u7684\\u4F4D\\u7F6E\\u4E0A\\u5DF2\\u7ECF\\u653E\\u7F6E\\u4E86\\u4E00\\u4E2A\\u4E86\\uFF0C\\n      // \\u4E5F\\u5C31\\u662F\\u8BF4\\u8FD8\\u6709\\u4E09\\u4E2A\\u6570\\u5B57\\u9700\\u8981\\u653E\\u7F6E\\uFF0C\\u4E5F\\u5C31\\u662Flen-i\\n      for (let j = 0, cur = 0; j < len - i; j++) {\\n        // \\u53D6\\u6A21\\n        cur = cur + dp[i][j];\\n        if (cur > mod) {\\n          cur = cur % mod;\\n        }\\n        dp[i + 1][j] = cur;\\n      }\\n    } else {\\n      // \\u5F53S.charAt(i) == \"D\"\\u7684\\u65F6\\u5019\\uFF0C\\u4E5F\\u5C31\\u662F\\u9700\\u8981\\u964D\\u5E8F\\uFF0C\\n      // \\u6BD4\\u5982\\u67090\\uFF0C 1\\uFF0C2\\uFF0C3\\uFF0C \\u5982\\u679C\\u9700\\u8981\\u653E\\u7F6Edp[1][2],\\u5219\\u53EA\\u6709\\u4E00\\u79CD\\u53EF\\u80FD\\uFF0C\\u90A3\\u5C31\\u662F\\u7B49\\u4E8Edp[0][3],\\n      // \\u4E0D\\u7136\\u5982\\u679C\\u653E\\u7F6E\\u4E86dp[1][2]\\u7684\\u65F6\\u5019\\uFF0C\\u57282\\u7684\\u4F4D\\u7F6E\\u653E\\u7F6E\\u7684\\u5143\\u7D20\\u80AF\\u5B9A\\u6BD4\\u524D\\u9762\\u7684\\u5927\\uFF0C\\u4E5F\\u5C31\\u662F\\u4E0D\\u7B26\\u5408S.charAt(i) == \"D\"\\n      for (let j = len - i - 1, cur = 0; j >= 0; j--) {\\n        cur = cur + dp[i][j + 1];\\n        if (cur > mod) {\\n          cur = cur % mod;\\n        }\\n        dp[i + 1][j] = cur;\\n      }\\n    }\\n  }\\n  return dp[len][0];\\n};\\n\\n \\n\\n```",
                "solutionTags": [],
                "code": "```js\\n/**\\n * @param {string} S\\n * @return {number}\\n */\\nexport default (S) => {\\n  let dp = [];\\n  const len = S.length;\\n  const mod = Math.pow(10, 9) + 7;\\n  // S=DID\\n  // len = 4,\\u6240\\u4EE5\\u8FD9\\u91CC\\u67090\\uFF0C1\\uFF0C2\\uFF0C3\\u56DB\\u4E2A\\u6570\\u5B57\\u9700\\u8981\\u653E\\u7F6E\\uFF0C\\n  // dp[i][j] \\u8868\\u793Ai\\u4E2A\\u6570\\u5B57\\u653E\\u7F6E\\u5B8C\\u6BD5\\uFF0C\\u5728\\u5269\\u4E0B\\u7684\\u6570\\u5B57\\u91CC\\u8FB9\\u9009\\u62E9\\u7B2Cj\\u4F4D\\u7684\\u4E2A\\u6570\\n  // \\u6BD4\\u5982d[3][0] \\u8868\\u793A\\u57280\\uFF0C1\\uFF0C2\\uFF0C3\\u4E2D\\u5DF2\\u7ECF\\u9009\\u62E9\\u4E86\\u4E09\\u4E2A\\u6570\\u5B57\\uFF0C\\u6309\\u7167DID\\u7684\\u8981\\u6C42\\u5DF2\\u7ECF\\u653E\\u7F6E\\u5B8C\\u6BD5\\u4E86\\uFF0C\\u7136\\u540E\\u5728\\u5269\\u4E0B\\u7684\\u6570\\u5B57\\u91CC\\u8FB9\\u9009\\u62E9\\u4F4D\\u7F6E\\u4E3A0\\u7684\\u6570\\u5B57\\n  for (let i = 0; i <= len; i++) {\\n    dp[i] = [];\\n  }\\n  // \\u56E0\\u4E3A\\u67090\\uFF0C1\\uFF0C2\\uFF0C3 \\u56DB\\u4E2A\\u6570\\u5B57\\n  // dp[0][0] = 1, [0]\\n  // dp[0][1] = 1, [1]\\n  // dp[0][2] = 1, [2]\\n  // dp[0][3] = 1, [3]\\n  for (let i = 0; i <= len; i++) {\\n    dp[0][i] = 1;\\n  }\\n  // \\u8BA1\\u7B97dp[len][0]\\n  for (let i = 0; i < len; i++) {\\n    if (S.charAt(i) == \"I\") {\\n      // \\u56E0\\u4E3A\\u5DF2\\u7ECF\\u6709i\\u4E2A\\u6570\\u5B57\\u5DF2\\u7ECF\\u88AB\\u653E\\u7F6E\\u597D\\u4E86\\n      // \\u6BD4\\u5982\\u5F53i=0\\u7684\\u65F6\\u5019\\uFF0C\\u4E00\\u5171\\u9700\\u8981\\u653E0\\uFF0C1\\uFF0C2\\uFF0C3\\uFF0Ci=0\\uFF0C\\u5C31\\u662F\\u5DF2\\u7ECF0\\u7684\\u4F4D\\u7F6E\\u4E0A\\u5DF2\\u7ECF\\u653E\\u7F6E\\u4E86\\u4E00\\u4E2A\\u4E86\\uFF0C\\n      // \\u4E5F\\u5C31\\u662F\\u8BF4\\u8FD8\\u6709\\u4E09\\u4E2A\\u6570\\u5B57\\u9700\\u8981\\u653E\\u7F6E\\uFF0C\\u4E5F\\u5C31\\u662Flen-i\\n      for (let j = 0, cur = 0; j < len - i; j++) {\\n        // \\u53D6\\u6A21\\n        cur = cur + dp[i][j];\\n        if (cur > mod) {\\n          cur = cur % mod;\\n        }\\n        dp[i + 1][j] = cur;\\n      }\\n    } else {\\n      // \\u5F53S.charAt(i) == \"D\"\\u7684\\u65F6\\u5019\\uFF0C\\u4E5F\\u5C31\\u662F\\u9700\\u8981\\u964D\\u5E8F\\uFF0C\\n      // \\u6BD4\\u5982\\u67090\\uFF0C 1\\uFF0C2\\uFF0C3\\uFF0C \\u5982\\u679C\\u9700\\u8981\\u653E\\u7F6Edp[1][2],\\u5219\\u53EA\\u6709\\u4E00\\u79CD\\u53EF\\u80FD\\uFF0C\\u90A3\\u5C31\\u662F\\u7B49\\u4E8Edp[0][3],\\n      // \\u4E0D\\u7136\\u5982\\u679C\\u653E\\u7F6E\\u4E86dp[1][2]\\u7684\\u65F6\\u5019\\uFF0C\\u57282\\u7684\\u4F4D\\u7F6E\\u653E\\u7F6E\\u7684\\u5143\\u7D20\\u80AF\\u5B9A\\u6BD4\\u524D\\u9762\\u7684\\u5927\\uFF0C\\u4E5F\\u5C31\\u662F\\u4E0D\\u7B26\\u5408S.charAt(i) == \"D\"\\n      for (let j = len - i - 1, cur = 0; j >= 0; j--) {\\n        cur = cur + dp[i][j + 1];\\n        if (cur > mod) {\\n          cur = cur % mod;\\n        }\\n        dp[i + 1][j] = cur;\\n      }\\n    }\\n  }\\n  return dp[len][0];\\n};\\n\\n \\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 564801,
                "title": "c-dp",
                "content": "```\\nclass Solution {\\npublic:\\n    #define mod 1000000007\\n    long long giveres(int pos,int len,int choto, vector<vector<long long>>&dp,string &s){\\n        if(pos==len)\\n            return 1ll;\\n        long long &ret = dp[pos][choto];\\n        if(ret!=-1)\\n            return ret;\\n        ret = 0;\\n        if(s[pos-1]==\\'D\\'){\\n            for(int i = 1;i<=choto;i++){\\n                ret += giveres(pos+1,len,i-1,dp,s);\\n                if(ret>=mod)\\n                    ret%=-mod;\\n            }\\n        }\\n        else {\\n            for(int i = 1;i<=len-pos-choto;i++){\\n                ret += giveres(pos+1,len,i-1+choto,dp,s);\\n                if(ret>=mod)\\n                    ret %= mod;\\n            }\\n        }\\n        return ret;\\n    }\\n    \\n    int numPermsDISequence(string S) {\\n        int len = S.size();\\n        vector<vector<long long>>dp(len+5,vector<long long>(len+5,-1));\\n        long long ans = 0;\\n        for(int i = 1;i<=len+1;i++){\\n            ans += giveres(1,len+1,i-1,dp,S);\\n            if(ans >= mod)\\n                ans %= mod;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    #define mod 1000000007\\n    long long giveres(int pos,int len,int choto, vector<vector<long long>>&dp,string &s){\\n        if(pos==len)\\n            return 1ll;\\n        long long &ret = dp[pos][choto];\\n        if(ret!=-1)\\n            return ret;\\n        ret = 0;\\n        if(s[pos-1]==\\'D\\'){\\n            for(int i = 1;i<=choto;i++){\\n                ret += giveres(pos+1,len,i-1,dp,s);\\n                if(ret>=mod)\\n                    ret%=-mod;\\n            }\\n        }\\n        else {\\n            for(int i = 1;i<=len-pos-choto;i++){\\n                ret += giveres(pos+1,len,i-1+choto,dp,s);\\n                if(ret>=mod)\\n                    ret %= mod;\\n            }\\n        }\\n        return ret;\\n    }\\n    \\n    int numPermsDISequence(string S) {\\n        int len = S.size();\\n        vector<vector<long long>>dp(len+5,vector<long long>(len+5,-1));\\n        long long ans = 0;\\n        for(int i = 1;i<=len+1;i++){\\n            ans += giveres(1,len+1,i-1,dp,S);\\n            if(ans >= mod)\\n                ans %= mod;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 494725,
                "title": "rust-0ms-2-1mb-100",
                "content": "```rust\\n// translated from https://leetcode.com/problems/valid-permutations-for-di-sequence/discuss/168278/C%2B%2BJavaPython-DP-Solution-O(N2)\\npub fn num_perms_di_sequence(s: String) -> i32 {\\n    const MOD: i32 = 1_000_000_007;\\n    let n = s.len();\\n    let mut dp = vec![1; n + 1];\\n    let mut dp2 = vec![0; n];\\n//    println!(\"{:?}\", dp);\\n    for i in 0..n {\\n        if s[i..].chars().next().unwrap() == \\'I\\' {\\n            let mut cur = 0;\\n            for j in 0..n - i\\n            {\\n                cur = (cur + dp[j]) % MOD;\\n                dp2[j] = cur;\\n            }\\n        } else {\\n            let mut cur = 0;\\n            for j in (0..n - i).rev() {\\n                cur = (cur + dp[j + 1]) % MOD;\\n                dp2[j] = cur;\\n            }\\n        }\\n        dp[..n].copy_from_slice(&dp2[..n]);\\n//        println!(\"{:?}\", dp);\\n    }\\n    dp[0]\\n}\\n\\n```",
                "solutionTags": [],
                "code": "```rust\\n// translated from https://leetcode.com/problems/valid-permutations-for-di-sequence/discuss/168278/C%2B%2BJavaPython-DP-Solution-O(N2)\\npub fn num_perms_di_sequence(s: String) -> i32 {\\n    const MOD: i32 = 1_000_000_007;\\n    let n = s.len();\\n    let mut dp = vec![1; n + 1];\\n    let mut dp2 = vec![0; n];\\n//    println!(\"{:?}\", dp);\\n    for i in 0..n {\\n        if s[i..].chars().next().unwrap() == \\'I\\' {\\n            let mut cur = 0;\\n            for j in 0..n - i\\n            {\\n                cur = (cur + dp[j]) % MOD;\\n                dp2[j] = cur;\\n            }\\n        } else {\\n            let mut cur = 0;\\n            for j in (0..n - i).rev() {\\n                cur = (cur + dp[j + 1]) % MOD;\\n                dp2[j] = cur;\\n            }\\n        }\\n        dp[..n].copy_from_slice(&dp2[..n]);\\n//        println!(\"{:?}\", dp);\\n    }\\n    dp[0]\\n}\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 443745,
                "title": "python3-divide-and-conquer-solution-slightly-quicker-than-official-divide-and-conquer-solution",
                "content": "```\\nfrom functools import lru_cache\\n\\n\\nclass Solution:\\n    def __init__(self):\\n        self.mod = 10 ** 9 + 7\\n\\n    @lru_cache(maxsize=None)\\n    def nCk(self, n, k):\\n        if k == 1: return n\\n        if k == 0 or n == k: return 1\\n        return self.nCk(n - 1, k - 1) + self.nCk(n - 1, k)\\n\\n    @lru_cache(maxsize=None)\\n    def numPermsDISequence(self, s: str) -> int:\\n        if len(s) <= 1: return 1\\n        n = len(s) + 1\\n        ans = 0\\n\\t\\t#Insert max number in every \\'DI\\' part, left and right part are choosed from left numbers\\n        for i in range(n - 1):\\n            if s[i:i + 2] == \\'ID\\': ans += self.nCk(n - 1, i + 1) * self.numPermsDISequence(s[:i]) * self.numPermsDISequence(s[i + 2:])\\n\\t\\t#Insert max number at start position if s[0] == \\'D\\'\\n        if s[0] == \\'D\\': ans += self.numPermsDISequence(s[1: n - 1])\\n\\t\\t#Same insert max number at end\\n        if s[n - 2] == \\'I\\': ans += self.numPermsDISequence(s[: n - 2])\\n        return ans % self.mod\\n```",
                "solutionTags": [
                    "Python3",
                    "Divide and Conquer"
                ],
                "code": "```\\nfrom functools import lru_cache\\n\\n\\nclass Solution:\\n    def __init__(self):\\n        self.mod = 10 ** 9 + 7\\n\\n    @lru_cache(maxsize=None)\\n    def nCk(self, n, k):\\n        if k == 1: return n\\n        if k == 0 or n == k: return 1\\n        return self.nCk(n - 1, k - 1) + self.nCk(n - 1, k)\\n\\n    @lru_cache(maxsize=None)\\n    def numPermsDISequence(self, s: str) -> int:\\n        if len(s) <= 1: return 1\\n        n = len(s) + 1\\n        ans = 0\\n\\t\\t#Insert max number in every \\'DI\\' part, left and right part are choosed from left numbers\\n        for i in range(n - 1):\\n            if s[i:i + 2] == \\'ID\\': ans += self.nCk(n - 1, i + 1) * self.numPermsDISequence(s[:i]) * self.numPermsDISequence(s[i + 2:])\\n\\t\\t#Insert max number at start position if s[0] == \\'D\\'\\n        if s[0] == \\'D\\': ans += self.numPermsDISequence(s[1: n - 1])\\n\\t\\t#Same insert max number at end\\n        if s[n - 2] == \\'I\\': ans += self.numPermsDISequence(s[: n - 2])\\n        return ans % self.mod\\n```",
                "codeTag": "Java"
            },
            {
                "id": 436007,
                "title": "python-dp",
                "content": "dp  \\n**Subproblem definition**:  dp[n][j] = number of permutations or [0,1,2,3,4,5,..., n-2, n-1] that end with j \\n**How many subproblems** O(n^2)\\n**Recurrence** \\n1. dp[n][j] = sigma dp[n-1][b] for all a < j if the last evolution is an increase\\n2. dp[n][j] = sigma dp[n-1][a] for all j <=b < n - 1  if the last evolution is an increase\\n\\n\\n**Time per subproblem** O(n)\\n**Final Answer** sigma dp[n][j] for j in [0,1,2,3,..., n-2,n-1]\\n\\n\\n\\n\\n\\n\\n\\n```\\nMOD  = 10 ** 9 + 7\\nclass Solution(object):\\n    def numPermsDISequence(self, S):\\n        mem, nn = {}, len(S) + 1\\n        res = 0\\n        for n in range(1, nn + 1):\\n            for j in range(n):\\n                r = self.f(n, j, S, mem)\\n                if n == nn:\\n                    res += r\\n                    res %= MOD\\n        return res\\n    \\n    \\n    def f(self, n, j, s, mem):\\n        # if n == 0 : return 0\\n        if n == 1:  return 1 if j == 0 else 0\\n        if (n,j) not in mem:\\n            mem[(n,j)] = sum([self.f(n - 1, a, s, mem) for a in range(j,n - 1)] or [0]) % MOD if s[n - 2] == \\'D\\' else sum([self.f(n - 1, b, s, mem) for b in range(j)] or [0]) % MOD\\n        return mem[(n,j)] \\n```",
                "solutionTags": [],
                "code": "```\\nMOD  = 10 ** 9 + 7\\nclass Solution(object):\\n    def numPermsDISequence(self, S):\\n        mem, nn = {}, len(S) + 1\\n        res = 0\\n        for n in range(1, nn + 1):\\n            for j in range(n):\\n                r = self.f(n, j, S, mem)\\n                if n == nn:\\n                    res += r\\n                    res %= MOD\\n        return res\\n    \\n    \\n    def f(self, n, j, s, mem):\\n        # if n == 0 : return 0\\n        if n == 1:  return 1 if j == 0 else 0\\n        if (n,j) not in mem:\\n            mem[(n,j)] = sum([self.f(n - 1, a, s, mem) for a in range(j,n - 1)] or [0]) % MOD if s[n - 2] == \\'D\\' else sum([self.f(n - 1, b, s, mem) for b in range(j)] or [0]) % MOD\\n        return mem[(n,j)] \\n```",
                "codeTag": "Java"
            },
            {
                "id": 404899,
                "title": "i-have-a-question",
                "content": "these solutions seem like that they don\\'t consider the repetition pattern like that:\\nwhen input is: DID\\nwe all know that (3, 0, 2, 1) is valid\\nhowever, just use the dp way, dp[m][n] = sum(dp[m - 1][j < n when input[pos] == \\'D\\']) or \\ndp[m][n] = sum(dp[m - 1][j > n when input[pos] == \\'I\\'] can\\'t guarantee the pattern (3, 0, 3, 1)happen\\ncause the result can be larger than we expect!!\\n",
                "solutionTags": [],
                "code": "these solutions seem like that they don\\'t consider the repetition pattern like that:\\nwhen input is: DID\\nwe all know that (3, 0, 2, 1) is valid\\nhowever, just use the dp way, dp[m][n] = sum(dp[m - 1][j < n when input[pos] == \\'D\\']) or \\ndp[m][n] = sum(dp[m - 1][j > n when input[pos] == \\'I\\'] can\\'t guarantee the pattern (3, 0, 3, 1)happen\\ncause the result can be larger than we expect!!\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 356234,
                "title": "python-simple-intuitive-solution",
                "content": "```\\nclass Solution(object):\\n    def numPermsDISequence(self, s):\\n        \"\"\"\\n        :type S: str\\n        :rtype: int\\n        \"\"\"\\n        n = len(s) + 1\\n        dp = [[0 for _ in xrange(n)] for _ in xrange(n)]\\n        dp[0][0] = 1\\n        for i in xrange(1,n):\\n            for j in xrange(i + 1):\\n                if s[i - 1] == \\'D\\':\\n                    for k in xrange(j,i):\\n                        dp[i][j] += dp[i - 1][k]\\n                elif s[i - 1] == \\'I\\':\\n                    for k in xrange(j):\\n                        dp[i][j] += dp[i - 1][k]\\n        return sum(dp[-1]) % (10 ** 9 + 7)\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def numPermsDISequence(self, s):\\n        \"\"\"\\n        :type S: str\\n        :rtype: int\\n        \"\"\"\\n        n = len(s) + 1\\n        dp = [[0 for _ in xrange(n)] for _ in xrange(n)]\\n        dp[0][0] = 1\\n        for i in xrange(1,n):\\n            for j in xrange(i + 1):\\n                if s[i - 1] == \\'D\\':\\n                    for k in xrange(j,i):\\n                        dp[i][j] += dp[i - 1][k]\\n                elif s[i - 1] == \\'I\\':\\n                    for k in xrange(j):\\n                        dp[i][j] += dp[i - 1][k]\\n        return sum(dp[-1]) % (10 ** 9 + 7)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 343312,
                "title": "share-my-python3-solutions-with-o-n-3-and-o-n-2",
                "content": "(1)O(n^3):\\n\\n```\\nclass Solution:\\n    def numPermsDISequence(self, S: str) -> int:\\n        if not S:\\n            return 0\\n\\n        mod = 1000000007\\n        n = len(S)\\n        dp = []\\n        for i in range(n+1):\\n            dp.append([0] * (n+1))\\n        if S[0] == \\'D\\':\\n            dp[1][0] = 1\\n        elif S[0] == \\'I\\':\\n            dp[1][1] = 1\\n\\n        for i in range(1, n+1):\\n            for j in range(i+1):\\n                if S[i-1] == \\'D\\':\\n                    for k in range(j, i):\\n                        dp[i][j] += dp[i-1][k]\\n                        dp[i][j] %= mod\\n                elif S[i-1] == \\'I\\':\\n                    for k in range(0, j):\\n                        dp[i][j] += dp[i-1][k]\\n                        dp[i][j] %= mod\\n\\n        ret = 0\\n        for k in range(n+1):\\n            ret += dp[n][k]\\n            ret %= mod\\n\\n        return ret\\n```\\n\\n(2) O(n^2): using prefix sum to optimize\\n\\n```\\nclass Solution:\\n    def numPermsDISequence(self, S: str) -> int:\\n        if not S:\\n            return 0\\n\\n        mod = 1000000007\\n        n = len(S)\\n        dp = []\\n        for i in range(n+1):\\n            dp.append([0] * (n+1))\\n        dp[0][0] = 1\\n\\n        for i in range(1, n+1):\\n            for j in range(i+1):\\n                if S[i-1] == \\'D\\':\\n                    if j != 0:\\n                        dp[i][j] = (dp[i-1][i-1] - dp[i-1][j-1] + dp[i][j-1]) % mod\\n                    else:\\n                        dp[i][j] = dp[i-1][i-1]\\n                elif S[i-1] == \\'I\\':\\n                    if j != 0:\\n                        dp[i][j] = (dp[i-1][j-1] + dp[i][j-1]) % mod\\n        \\n        return dp[n][n]\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def numPermsDISequence(self, S: str) -> int:\\n        if not S:\\n            return 0\\n\\n        mod = 1000000007\\n        n = len(S)\\n        dp = []\\n        for i in range(n+1):\\n            dp.append([0] * (n+1))\\n        if S[0] == \\'D\\':\\n            dp[1][0] = 1\\n        elif S[0] == \\'I\\':\\n            dp[1][1] = 1\\n\\n        for i in range(1, n+1):\\n            for j in range(i+1):\\n                if S[i-1] == \\'D\\':\\n                    for k in range(j, i):\\n                        dp[i][j] += dp[i-1][k]\\n                        dp[i][j] %= mod\\n                elif S[i-1] == \\'I\\':\\n                    for k in range(0, j):\\n                        dp[i][j] += dp[i-1][k]\\n                        dp[i][j] %= mod\\n\\n        ret = 0\\n        for k in range(n+1):\\n            ret += dp[n][k]\\n            ret %= mod\\n\\n        return ret\\n```\n```\\nclass Solution:\\n    def numPermsDISequence(self, S: str) -> int:\\n        if not S:\\n            return 0\\n\\n        mod = 1000000007\\n        n = len(S)\\n        dp = []\\n        for i in range(n+1):\\n            dp.append([0] * (n+1))\\n        dp[0][0] = 1\\n\\n        for i in range(1, n+1):\\n            for j in range(i+1):\\n                if S[i-1] == \\'D\\':\\n                    if j != 0:\\n                        dp[i][j] = (dp[i-1][i-1] - dp[i-1][j-1] + dp[i][j-1]) % mod\\n                    else:\\n                        dp[i][j] = dp[i-1][i-1]\\n                elif S[i-1] == \\'I\\':\\n                    if j != 0:\\n                        dp[i][j] = (dp[i-1][j-1] + dp[i][j-1]) % mod\\n        \\n        return dp[n][n]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 317865,
                "title": "golang-dp-solution-o-n-2",
                "content": "I believe that everyone knows the following formula when **S[i-1] is \"D\"**,\\n```\\ndp[i][j] = dp[i-1][j] + dp[i-1][j+1] + dp[i-1][j+2] + ... + dp[i-1][i-1]\\n```\\nSo,\\n```\\ndp[i][j-1] = dp[i-1][j-1] + dp[i-1][j] + dp[i-1][j+1] + dp[i-1][j+2] + ... + dp[i-1][i-1]\\n```\\n\\nAccordingly,\\n```\\ndp[i][j] = dp[i][j-1] - dp[i-1][j-1]\\n```\\nPlease note that dp[i][j-1] could be less than dp[i-1][j-1], because each intermediate result is modulo 1000000007, so we need to change the above formula a little bit as below for safety,\\n```\\ndp[i][j] = dp[i][j-1] + MOD - dp[i-1][j-1]\\n```\\n\\nSimilarly, we can easily get the following formula when S[i-1] is \"I\",\\n```\\ndp[i][j] = dp[i][j-1] + dp[i-1][j-1]\\n```\\n\\nSo the final solution is as below,\\n\\n```\\nfunc numPermsDISequence(S string) int {\\n    MOD := 1000000007\\n    N := len(S)\\n    dp := make([][]int, N+1)\\n    for i:=0; i<=N; i++ {\\n        dp[i] = make([]int, N+1)\\n    }\\n    \\n    for i:=0; i<=N; i++{\\n        dp[0][i] = 1\\n    }\\n    \\n    for i:=1; i<=N; i++ {\\n        for j:=0; j<=i; j++ {\\n            if S[i-1] == \\'D\\' {\\n                if j == 0 {\\n                    for k:=j; k<i; k++ {\\n                        dp[i][j] += dp[i-1][k]\\n                        dp[i][j] %= MOD\\n                    }\\n                } else {\\n                    if dp[i][j-1] < dp[i-1][j-1] {\\n                        dp[i][j] = dp[i][j-1] + MOD - dp[i-1][j-1]\\n                    } else {\\n                        dp[i][j] = dp[i][j-1] - dp[i-1][j-1]\\n                    }\\n                    dp[i][j] %= MOD \\n                }\\n            } else {\\n                if j > 0 {\\n                    dp[i][j] = dp[i][j-1] + dp[i-1][j-1]\\n                    dp[i][j] %= MOD\\n                }\\n            }\\n        }\\n    }\\n    \\n    ret := 0\\n    for i:=0; i<=N; i++ {\\n        ret += dp[N][i]\\n        ret %= MOD\\n    }\\n    \\n    return ret\\n}\\n\\n```",
                "solutionTags": [],
                "code": "```\\ndp[i][j] = dp[i-1][j] + dp[i-1][j+1] + dp[i-1][j+2] + ... + dp[i-1][i-1]\\n```\n```\\ndp[i][j-1] = dp[i-1][j-1] + dp[i-1][j] + dp[i-1][j+1] + dp[i-1][j+2] + ... + dp[i-1][i-1]\\n```\n```\\ndp[i][j] = dp[i][j-1] - dp[i-1][j-1]\\n```\n```\\ndp[i][j] = dp[i][j-1] + MOD - dp[i-1][j-1]\\n```\n```\\ndp[i][j] = dp[i][j-1] + dp[i-1][j-1]\\n```\n```\\nfunc numPermsDISequence(S string) int {\\n    MOD := 1000000007\\n    N := len(S)\\n    dp := make([][]int, N+1)\\n    for i:=0; i<=N; i++ {\\n        dp[i] = make([]int, N+1)\\n    }\\n    \\n    for i:=0; i<=N; i++{\\n        dp[0][i] = 1\\n    }\\n    \\n    for i:=1; i<=N; i++ {\\n        for j:=0; j<=i; j++ {\\n            if S[i-1] == \\'D\\' {\\n                if j == 0 {\\n                    for k:=j; k<i; k++ {\\n                        dp[i][j] += dp[i-1][k]\\n                        dp[i][j] %= MOD\\n                    }\\n                } else {\\n                    if dp[i][j-1] < dp[i-1][j-1] {\\n                        dp[i][j] = dp[i][j-1] + MOD - dp[i-1][j-1]\\n                    } else {\\n                        dp[i][j] = dp[i][j-1] - dp[i-1][j-1]\\n                    }\\n                    dp[i][j] %= MOD \\n                }\\n            } else {\\n                if j > 0 {\\n                    dp[i][j] = dp[i][j-1] + dp[i-1][j-1]\\n                    dp[i][j] %= MOD\\n                }\\n            }\\n        }\\n    }\\n    \\n    ret := 0\\n    for i:=0; i<=N; i++ {\\n        ret += dp[N][i]\\n        ret %= MOD\\n    }\\n    \\n    return ret\\n}\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 308917,
                "title": "can-any-one-explain-the-proof-to-calculate-the-module-of-combination-in-the-second-solution",
                "content": "Can anyone please explain why we calculate inverse of factorial as pow(f, MOD-2, MOD) ? Thanks a lot.\\n\\n```\\n        facinv = [pow(f, MOD-2, MOD) for f in fac]\\n\\n        def binom(n, k):\\n            return fac[n] * facinv[n-k] % MOD * facinv[k] % MOD\\n```",
                "solutionTags": [],
                "code": "```\\n        facinv = [pow(f, MOD-2, MOD) for f in fac]\\n\\n        def binom(n, k):\\n            return fac[n] * facinv[n-k] % MOD * facinv[k] % MOD\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 298593,
                "title": "c-beats-100-8ms-dp-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int numPermsDISequence(string S) {\\n        \\n\\tint max = S.size();\\n        if(max == 1)\\n            return 1;\\n\\tvector<long long> last(max + 1); // last[i] means when the end is i, the number of available\\n\\tif (S.at(0) == \\'D\\') {\\n\\t\\tlast[0] = 1;  \\n\\t} else {\\n\\t\\tlast[1] = 1;\\n\\t}\\n\\t\\n\\tfor (int i = 1; i < max; i++) { //i+1 means the len of array\\n\\t\\tif (S.at(i) == \\'D\\') {\\n\\t\\t\\tlast[i+1] = 0;\\n\\t\\t\\tfor (int j = i; j >= 0; j--) {\\n\\t\\t\\t\\tlast[j] = (last[j+1] + last[j]) % 1000000007; // last(i, j) = last(i-1, j) + last(i, j+1) ; \\n\\t\\t\\t}\\n\\t\\t} else {\\n\\t\\t\\tlong long temp = last[0];\\n\\t\\t\\tlast[0] = 0;\\n\\t\\t\\tfor (int j = 1; j <= i + 1; j++) {\\n\\t\\t\\t\\tlong long x = last[j];\\n\\t\\t\\t\\tlast[j] = (temp + last[j - 1]) % 1000000007; //last(i, j) = last(i - 1, j - 1) + last(i, j - 1);\\n\\t\\t\\t\\ttemp = x;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\tlong long ans = 0;\\n\\tfor (long long x : last)\\n\\t\\tans += x;\\n\\treturn ans % 1000000007;\\n}\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int numPermsDISequence(string S) {\\n        \\n\\tint max = S.size();\\n        if(max == 1)\\n            return 1;\\n\\tvector<long long> last(max + 1); // last[i] means when the end is i, the number of available\\n\\tif (S.at(0) == \\'D\\') {\\n\\t\\tlast[0] = 1;  \\n\\t} else {\\n\\t\\tlast[1] = 1;\\n\\t}\\n\\t\\n\\tfor (int i = 1; i < max; i++) { //i+1 means the len of array\\n\\t\\tif (S.at(i) == \\'D\\') {\\n\\t\\t\\tlast[i+1] = 0;\\n\\t\\t\\tfor (int j = i; j >= 0; j--) {\\n\\t\\t\\t\\tlast[j] = (last[j+1] + last[j]) % 1000000007; // last(i, j) = last(i-1, j) + last(i, j+1) ; \\n\\t\\t\\t}\\n\\t\\t} else {\\n\\t\\t\\tlong long temp = last[0];\\n\\t\\t\\tlast[0] = 0;\\n\\t\\t\\tfor (int j = 1; j <= i + 1; j++) {\\n\\t\\t\\t\\tlong long x = last[j];\\n\\t\\t\\t\\tlast[j] = (temp + last[j - 1]) % 1000000007; //last(i, j) = last(i - 1, j - 1) + last(i, j - 1);\\n\\t\\t\\t\\ttemp = x;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\tlong long ans = 0;\\n\\tfor (long long x : last)\\n\\t\\tans += x;\\n\\treturn ans % 1000000007;\\n}\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 213523,
                "title": "c-dp-solution-o-n-2",
                "content": "```\\nconst int MOD = 1000000007;\\n\\nclass Solution {\\npublic:\\n    int numPermsDISequence(string S) {\\n        /**\\n            \\u72B6\\u6001\\u5B9A\\u4E49\\uFF1A   \\u8BBE f(i,j) \\u662F\\u5E8F\\u5217<0..i>\\u4EE5 \"\\u7B2Cj\\u5C0F\\u5143\\u7D20\" \\u4E3A\\u5C3E\\u65F6\\u7684\\u6709\\u6548\\u5E8F\\u5217\\u6570, 0<=j<=i\\n            \\u8F6C\\u79FB\\u65B9\\u7A0B\\uFF1A   f(i,j) = sum{ f(i-1,k) }, k < j \\u6216 k > j\\n            \\u8FB9\\u754C\\u6761\\u4EF6\\uFF1A   f(0,0) = 1\\n        **/\\n        int n = S.size();\\n        vector<int> dp(n+1,0), sum(n+1,0), aux(n+1,0);\\n        sum[0] = 1;\\n        for (int i = 1; i <= n; i++) {\\n            aux[0] = dp[0] = S[i-1]==\\'I\\' ? 0 : sum[i-1];\\n            for (int j = 1; j <= i; j++) {\\n                dp[j]  = S[i-1]==\\'I\\' ? sum[j-1] : (sum[i-1]-sum[j-1]+MOD)%MOD; \\n                aux[j] = (aux[j-1] + dp[j]) % MOD;\\n            }\\n            swap(aux, sum);\\n        }\\n        return sum[n];\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nconst int MOD = 1000000007;\\n\\nclass Solution {\\npublic:\\n    int numPermsDISequence(string S) {\\n        /**\\n            \\u72B6\\u6001\\u5B9A\\u4E49\\uFF1A   \\u8BBE f(i,j) \\u662F\\u5E8F\\u5217<0..i>\\u4EE5 \"\\u7B2Cj\\u5C0F\\u5143\\u7D20\" \\u4E3A\\u5C3E\\u65F6\\u7684\\u6709\\u6548\\u5E8F\\u5217\\u6570, 0<=j<=i\\n            \\u8F6C\\u79FB\\u65B9\\u7A0B\\uFF1A   f(i,j) = sum{ f(i-1,k) }, k < j \\u6216 k > j\\n            \\u8FB9\\u754C\\u6761\\u4EF6\\uFF1A   f(0,0) = 1\\n        **/\\n        int n = S.size();\\n        vector<int> dp(n+1,0), sum(n+1,0), aux(n+1,0);\\n        sum[0] = 1;\\n        for (int i = 1; i <= n; i++) {\\n            aux[0] = dp[0] = S[i-1]==\\'I\\' ? 0 : sum[i-1];\\n            for (int j = 1; j <= i; j++) {\\n                dp[j]  = S[i-1]==\\'I\\' ? sum[j-1] : (sum[i-1]-sum[j-1]+MOD)%MOD; \\n                aux[j] = (aux[j-1] + dp[j]) % MOD;\\n            }\\n            swap(aux, sum);\\n        }\\n        return sum[n];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 211592,
                "title": "c-o-n-3",
                "content": "```\\nint numPermsDISequence(string S) {\\n   const long long mod = 1e9 + 7;\\n   vector<long long> pre(S.size() + 1, 1), cur;\\n   for (auto c : S) {\\n      cur = vector<long long>(pre.size() - 1);\\n      for (int j = 0; j < pre.size(); j++) {\\n         for (int k = 0; k < pre.size(); k++) {\\n            if (c == \\'D\\' && k >= j) continue;\\n            if (c == \\'I\\' && k <= j) continue;\\n            auto k1 = k > j ? k - 1 : k;\\n            cur[k1] += pre[j]; cur[k1] %= mod;\\n         }\\n      }\\n      pre = move(cur);\\n   }\\n   return accumulate(pre.begin(), pre.end(), 0ll) % mod;\\n}",
                "solutionTags": [],
                "code": "```\\nint numPermsDISequence(string S) {\\n   const long long mod = 1e9 + 7;\\n   vector<long long> pre(S.size() + 1, 1), cur;\\n   for (auto c : S) {\\n      cur = vector<long long>(pre.size() - 1);\\n      for (int j = 0; j < pre.size(); j++) {\\n         for (int k = 0; k < pre.size(); k++) {\\n            if (c == \\'D\\' && k >= j) continue;\\n            if (c == \\'I\\' && k <= j) continue;\\n            auto k1 = k > j ? k - 1 : k;\\n            cur[k1] += pre[j]; cur[k1] %= mod;\\n         }\\n      }\\n      pre = move(cur);\\n   }\\n   return accumulate(pre.begin(), pre.end(), 0ll) % mod;\\n}",
                "codeTag": "Unknown"
            },
            {
                "id": 209226,
                "title": "python-o-n-2-and-o-n-space-96-63",
                "content": "```\\nclass Solution:\\n    def numPermsDISequence(self, S):\\n        l, r = 0, len(S)+1\\n        dp =  [1] * r\\n        for j in S:\\n            new = [0] * r\\n            if j == \\'D\\':\\n                r -= 1\\n                for u in range(r-1,l-1,-1):\\n                    new[u] = new[u+1] + dp[u+1]\\n            elif j == \\'I\\':\\n                l += 1\\n                for u in range(l,r):\\n                    new[u] = new[u-1] + dp[u-1]\\n            dp = new\\n        return dp[l] % (10 ** 9 + 7)\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def numPermsDISequence(self, S):\\n        l, r = 0, len(S)+1\\n        dp =  [1] * r\\n        for j in S:\\n            new = [0] * r\\n            if j == \\'D\\':\\n                r -= 1\\n                for u in range(r-1,l-1,-1):\\n                    new[u] = new[u+1] + dp[u+1]\\n            elif j == \\'I\\':\\n                l += 1\\n                for u in range(l,r):\\n                    new[u] = new[u-1] + dp[u-1]\\n            dp = new\\n        return dp[l] % (10 ** 9 + 7)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 199444,
                "title": "10-lines-c-time-o-n-2-space-o-n-with-remark",
                "content": "```C++\\n// K(s, x) = nums of perms with tail ranking x\\n// K(s + \\'I\\') = K(s, x) + K(s, x+1) + ... + K(s, s.len)\\n// K(s + \\'D\\') = K(s, 0) + K(s, 1) + ... + K(s, x - 1)\\n\\n// G(s, 0) = 0\\n// G(s, x) = K(s, 0) + K(s, 1) + ... + K(s, x - 1)\\n\\n// K(s + \\'I\\') = K(s, x) + K(s, x+1) + ... + K(s, s.len) = G(s, s.len + 1) - G(s, x)\\n// K(s + \\'D\\') = K(s, 0) + K(s, 1) + ... + K(s, x - 1) = G(s, x)\\n\\n// G(s, x + 1) = G(s, x) + K(s, x)\\n\\n\\nclass Solution {\\npublic:\\n    int numPermsDISequence(string S) {\\n        vector<int64_t> G = {0, 1};\\n        \\n        for (int s_len = 0; s_len < S.size(); ++s_len) {\\n            vector<int64_t> nG = {0};\\n            \\n            for (int x = 0; x <= s_len + 1; ++x) {\\n                int64_t k = S[s_len] == \\'I\\' ? G[s_len + 1] - G[x] : G[x];\\n                nG.push_back((nG.back() + k + 1000000007) % 1000000007);\\n            }\\n            \\n            G.swap(nG);\\n        }\\n        \\n        return G[S.size() + 1];\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```C++\\n// K(s, x) = nums of perms with tail ranking x\\n// K(s + \\'I\\') = K(s, x) + K(s, x+1) + ... + K(s, s.len)\\n// K(s + \\'D\\') = K(s, 0) + K(s, 1) + ... + K(s, x - 1)\\n\\n// G(s, 0) = 0\\n// G(s, x) = K(s, 0) + K(s, 1) + ... + K(s, x - 1)\\n\\n// K(s + \\'I\\') = K(s, x) + K(s, x+1) + ... + K(s, s.len) = G(s, s.len + 1) - G(s, x)\\n// K(s + \\'D\\') = K(s, 0) + K(s, 1) + ... + K(s, x - 1) = G(s, x)\\n\\n// G(s, x + 1) = G(s, x) + K(s, x)\\n\\n\\nclass Solution {\\npublic:\\n    int numPermsDISequence(string S) {\\n        vector<int64_t> G = {0, 1};\\n        \\n        for (int s_len = 0; s_len < S.size(); ++s_len) {\\n            vector<int64_t> nG = {0};\\n            \\n            for (int x = 0; x <= s_len + 1; ++x) {\\n                int64_t k = S[s_len] == \\'I\\' ? G[s_len + 1] - G[x] : G[x];\\n                nG.push_back((nG.back() + k + 1000000007) % 1000000007);\\n            }\\n            \\n            G.swap(nG);\\n        }\\n        \\n        return G[S.size() + 1];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 191960,
                "title": "java-beats-100",
                "content": "```\\nclass Solution {\\n    public int numPermsDISequence(String S) {\\n        if (S == null) {\\n            return 0;\\n        }\\n        int mod = (int) 1e9 + 7;\\n        int n = S.length() + 1;\\n        int[][] memo = new int[n][n];\\n        for (int i = 0; i < n; i++) {\\n            memo[i][0] = 1;\\n        }\\n        int acc = 0;\\n        int up = 0;\\n        int down = S.length();\\n        for (int j = 1; j < n; j++) {\\n            if (S.charAt(j - 1) == \\'I\\') {\\n                up++;\\n                for (int i = up; i <= down; i++) {\\n                    memo[i][j] = (memo[i - 1][j] + memo[i - 1][j - 1]) % mod;\\n                    acc = memo[i][j];\\n                }\\n            } else {\\n                down--;\\n                for (int i = down; i >= up; i--) {\\n                    memo[i][j] = (memo[i + 1][j] + memo[i + 1][j - 1]) % mod;\\n                    acc = memo[i][j];\\n                }\\n            }\\n        }\\n        return acc;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int numPermsDISequence(String S) {\\n        if (S == null) {\\n            return 0;\\n        }\\n        int mod = (int) 1e9 + 7;\\n        int n = S.length() + 1;\\n        int[][] memo = new int[n][n];\\n        for (int i = 0; i < n; i++) {\\n            memo[i][0] = 1;\\n        }\\n        int acc = 0;\\n        int up = 0;\\n        int down = S.length();\\n        for (int j = 1; j < n; j++) {\\n            if (S.charAt(j - 1) == \\'I\\') {\\n                up++;\\n                for (int i = up; i <= down; i++) {\\n                    memo[i][j] = (memo[i - 1][j] + memo[i - 1][j - 1]) % mod;\\n                    acc = memo[i][j];\\n                }\\n            } else {\\n                down--;\\n                for (int i = down; i >= up; i--) {\\n                    memo[i][j] = (memo[i + 1][j] + memo[i + 1][j - 1]) % mod;\\n                    acc = memo[i][j];\\n                }\\n            }\\n        }\\n        return acc;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 168647,
                "title": "c-stl-partial-sum-0ms",
                "content": "    class Solution {\\n    public:\\n        int numPermsDISequence(string S) {\\n            int n = S.size() + 1, d = 0, i = 0;\\n            vector<int> arr(n, 1);\\n            auto func = [](int a, int b) { return (a + b) % 1000000007; };\\n            for (char c : S) {\\n                if (c == \\'D\\') {\\n                    ++d;\\n                    partial_sum(arr.rbegin() + i, arr.rend() - d, arr.rbegin() + i, func);\\n                } else {\\n                    ++i;\\n                    partial_sum(arr.begin() + d, arr.end() - i, arr.begin() + d, func);\\n                }\\n            }\\n            return *(arr.begin() + d);\\n        }\\n    };",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n        int numPermsDISequence(string S) {\\n            int n = S.size() + 1, d = 0, i = 0;\\n            vector<int> arr(n, 1);\\n            auto func = [](int a, int b) { return (a + b) % 1000000007; }",
                "codeTag": "Java"
            },
            {
                "id": 168477,
                "title": "c-dp-solution-o-n-3-can-modify-to-o-n-2-with-some-thinking-process",
                "content": "It\\'s a \\'find a pattern\\' problem, but when you try to generate a dp formular, you first try to find a recursion formular. \\nIt basically uses an idea of mapping, if you use a 0, and you can reuse the result of 01234(for some thing like 4 char S \"DIDI\") as the result of 12345 (for some thing like 4 char S \"DIDI\") as the have same increase decrease pattern. So IDID  can be recusivaly caculated by I + DID.  You just think every possible starting num and find the correct count recusively.\\nThen you probably just want to find a dp pattern, the rule may change on some corner case as if you currently use a num, your next num (serve as a start num for a subproblem) is limited. But they do have a general pattern if you write down a 2d dp. I use a 2D dp and do it backward base on my recusion idea. You can presum or sum in for loop but I just leave it N^3.\\n```\\nint numPermsDISequence(string S) {\\n    \\n    vector<vector<long>> dp(S.size()+1,vector<long>(S.size(),0));\\n    int m = 1000000007;\\n    int n = S.size();\\n    \\n    if (S[n-1] == \\'D\\') {\\n        dp[0][n-1] = 0;\\n        dp[1][n-1] = 1;\\n    } else {\\n        dp[0][n-1] = 1;\\n        dp[1][n-1] = 0;\\n    }\\n    \\n    for (int j = n-2; j >= 0; j--) {\\n        if (S[j] == \\'D\\') {\\n            for (int i = 0; i <= n-j; i++) {\\n                for (int k = 0; k < i; k++) {\\n                    dp[i][j] += dp[k][j+1];\\n                    dp[i][j] %= m;\\n                }\\n            }\\n        } else {\\n            for (int i = 0; i <= n-j ; i++) {\\n                for (int k = i; k < n-j; k++) {\\n                    dp[i][j] += dp[k][j+1];\\n                    dp[i][j] %= m;\\n                }\\n            }\\n        }\\n    }\\n    \\n    long result = 0;\\n    for (int i = 0; i <= n; i++) {\\n        result += dp[i][0];\\n        result %= m;\\n    }\\n    \\n    return result;\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nint numPermsDISequence(string S) {\\n    \\n    vector<vector<long>> dp(S.size()+1,vector<long>(S.size(),0));\\n    int m = 1000000007;\\n    int n = S.size();\\n    \\n    if (S[n-1] == \\'D\\') {\\n        dp[0][n-1] = 0;\\n        dp[1][n-1] = 1;\\n    } else {\\n        dp[0][n-1] = 1;\\n        dp[1][n-1] = 0;\\n    }\\n    \\n    for (int j = n-2; j >= 0; j--) {\\n        if (S[j] == \\'D\\') {\\n            for (int i = 0; i <= n-j; i++) {\\n                for (int k = 0; k < i; k++) {\\n                    dp[i][j] += dp[k][j+1];\\n                    dp[i][j] %= m;\\n                }\\n            }\\n        } else {\\n            for (int i = 0; i <= n-j ; i++) {\\n                for (int k = i; k < n-j; k++) {\\n                    dp[i][j] += dp[k][j+1];\\n                    dp[i][j] %= m;\\n                }\\n            }\\n        }\\n    }\\n    \\n    long result = 0;\\n    for (int i = 0; i <= n; i++) {\\n        result += dp[i][0];\\n        result %= m;\\n    }\\n    \\n    return result;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 168384,
                "title": "c-o-n-2-solution-with-only-one-1d-array-extremely-intuitive-detailed-thought-process",
                "content": "```\\nclass Solution {\\npublic:\\n    int numPermsDISequence(string S) {\\n        int MOD = 1e9 + 7;\\n        deque<int> memo;\\n        memo.push_back(1);\\n        for (int i = 0; i < S.size(); i++) {\\n            if (S[i] == \\'D\\') {\\n                memo.push_back(0);\\n                for (int j = i; j >= 0; j--) {\\n                    memo[j] = (memo[j] + memo[j + 1]) % MOD;\\n                }\\n            } else {\\n                assert(S[i] == \\'I\\');\\n                memo.push_front(0);\\n                for (int j = 1; j <= i + 1; j++) {\\n                    memo[j] = (memo[j] + memo[j - 1]) % MOD;\\n                }\\n            }\\n        }\\n        int sum = 0;\\n        for (int num: memo) {\\n            sum = (sum + num) % MOD;\\n        }\\n        return sum;\\n    }\\n};\\n```\\n\\nHow you derives the algorithm? Details below.\\n\\n# 1. Determine the parameters for DP\\nLet\\'s say you have already computed numPermsDISequence(3), can you compute numPermsDISequence(4)?\\nWe examine a sequence in numPermsDISequence(3), denoted by [ o o o ]. Imagine there are three pointers pointing to each of the token here. So we want to insert an item into the sequence. Let\\'s say S[4] = \"D\", how many ways can we insert the last item?\\nObviously, this depend on where the last pointer is pointing to. Let\\'s use bold token here to denote the item that the last of the  3 pointers points to, and \"I\" to denote how you insert the 4th item.\\n[ **o** o o ] -> [ I  **o** o o ]       1 way\\n[o **o** o ] -> [ I  o **o** o ]  [ o I **o** o ]       2 ways\\nso on so forth.\\nObviously, the number of ways you can insert the 4th token is dependent on where the 3rd pointer points to. So we need another parameter for DP purpose, which is the index of the last element in the array.\\n\\n# 2. Derive recursive formula\\nNow we have to start from scrach by redefining the function with an additional parameter we just described. Let\\'s say we have numPermsDISequence(3, *j*) for *j* in 0~2, which returns the ways of constructing length=3 sequence whose last element is *j*. For simplicity, Let F(*j*)=numPermsDISequence(3, *j*) and F\\'(*j*)=numPermsDISequence(4, *j*). How do we compute F\\'(*j*)? Again, let\\'s assume S[4] = \"D\".\\n\\nF\\'(0) will produces a sequence of [ I o o o ]. In order for that to happen, the bolden o can be any of the tokens after I. So:\\n\\n[ I **o** o o ]  [ I o **o** o ]  [ I o o  **o** ]\\nF\\'(0) = F(0) + F(1) + F(2)\\n\\nSimilarly, F\\'(1) = F(1) + F(2), F\\'(2) = F(2), F(3) = 0. Note that F(3) = 0 because there is no way you can produce [ o o o I ] no matter what.\\nLet n = 4. You have F\\'(j) = sum(F(k)) for k in j~n. To optimize sum computation, we simply compute from F\\'(n) to F\\'(0), because F\\'(k - 1) = sum( j= k-1 to n) = sum( j = k to n ) + F(k - 1) = F\\'(k) + F(k - 1)\\nIf we already have an array that maintains [ F(0), F(1), F(2) ], for the decreasing case, we only need to append a \"0\" to the **end of the array**, and then recompute F(2) ~ F(0) from **right to left**.\\n[ F(0), F(1), F(2), **F\\'(3) = 0** ]\\n[ F(0), F(1), **F\\'(3) + F(2)**, 0 ]\\n[ F(0), **F\\'(2) + F(1)**, F\\'(3) + F(2), 0 ]\\n[ **F\\'(1) + F(0)**, F\\'(2) + F(1), F\\'(3) + F(2), 0 ]\\n\\nWhen S[4] = \"I\". We simply mirror everything. We will push a 0 in the **start of the array** and then update sums from **left to right**.\\n\\nWe need a data structure to insert/remove an item at the beginning/end of array in O(1) time, and random access in O(1) time. Dynamic array will satisfy this requirement, which is deque in c++.\\n\\n# 3. Compute the result\\n\\nAt the end of the algorithm, numPermsDISequence(4) is simply ways of constructing arrays that the last element end in either 0, 1, 2 or 3. So result(4) = F\\'(0) + F\\'(1) + F\\'(2) + F\\'(3). We can use std::accumulate but due to the MOD requirement we have to compute it manually:(",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int numPermsDISequence(string S) {\\n        int MOD = 1e9 + 7;\\n        deque<int> memo;\\n        memo.push_back(1);\\n        for (int i = 0; i < S.size(); i++) {\\n            if (S[i] == \\'D\\') {\\n                memo.push_back(0);\\n                for (int j = i; j >= 0; j--) {\\n                    memo[j] = (memo[j] + memo[j + 1]) % MOD;\\n                }\\n            } else {\\n                assert(S[i] == \\'I\\');\\n                memo.push_front(0);\\n                for (int j = 1; j <= i + 1; j++) {\\n                    memo[j] = (memo[j] + memo[j - 1]) % MOD;\\n                }\\n            }\\n        }\\n        int sum = 0;\\n        for (int num: memo) {\\n            sum = (sum + num) % MOD;\\n        }\\n        return sum;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 168300,
                "title": "dynamic-programming-o-n-3-solution",
                "content": "Use a helper function helper(start, end) to record the intermediate result in range [start... end]\\n```\\npublic class Solution {\\n    private static final int MOD = (int)1e9 + 7;\\n    private long[][] mem, c;\\n    private int n;\\n    public int numPermsDISequence(String S) {\\n        n = S.length();\\n        mem = new long[n + 1][n + 1];\\n        c = new long[n + 1][n + 1];\\n        return (int)helper(S, 0, n);\\n    }\\n\\n    private long helper(String s, int start, int end) {\\n        if (start >= end) return 1;\\n        if (mem[start][end] > 0) return mem[start][end];\\n        long res = 0;\\n        for (int i = start; i <= end; ++i) {\\n            boolean leftLess = (i == start) || s.charAt(i - 1) == \\'I\\';\\n            boolean rightLess = (i == end) || s.charAt(i) == \\'D\\';\\n            if (leftLess && rightLess) {\\n                long leftRes = helper(s, start, i - 1), rightRes = helper(s, i + 1, end);\\n                long prod = (leftRes * rightRes) % MOD;\\n                res += Comb(end - start, i - start) * prod;\\n                res %= MOD;\\n            }\\n        }\\n        return mem[start][end] = res;\\n    }\\n\\n    private long Comb(int n, int k) {\\n        if (k == 0 || n == k) return 1;\\n        if (c[n][k] > 0) return c[n][k];\\n        if (n == k) return 1;\\n        return c[n][k] = (Comb(n - 1, k - 1) + Comb(n - 1, k)) % MOD;\\n    }\\n}\\n\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    private static final int MOD = (int)1e9 + 7;\\n    private long[][] mem, c;\\n    private int n;\\n    public int numPermsDISequence(String S) {\\n        n = S.length();\\n        mem = new long[n + 1][n + 1];\\n        c = new long[n + 1][n + 1];\\n        return (int)helper(S, 0, n);\\n    }\\n\\n    private long helper(String s, int start, int end) {\\n        if (start >= end) return 1;\\n        if (mem[start][end] > 0) return mem[start][end];\\n        long res = 0;\\n        for (int i = start; i <= end; ++i) {\\n            boolean leftLess = (i == start) || s.charAt(i - 1) == \\'I\\';\\n            boolean rightLess = (i == end) || s.charAt(i) == \\'D\\';\\n            if (leftLess && rightLess) {\\n                long leftRes = helper(s, start, i - 1), rightRes = helper(s, i + 1, end);\\n                long prod = (leftRes * rightRes) % MOD;\\n                res += Comb(end - start, i - start) * prod;\\n                res %= MOD;\\n            }\\n        }\\n        return mem[start][end] = res;\\n    }\\n\\n    private long Comb(int n, int k) {\\n        if (k == 0 || n == k) return 1;\\n        if (c[n][k] > 0) return c[n][k];\\n        if (n == k) return 1;\\n        return c[n][k] = (Comb(n - 1, k - 1) + Comb(n - 1, k)) % MOD;\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1035286,
                "title": "p23-5",
                "content": "Puting n-1 and then putting nth\\nLet\\'s change the definition of dp matrix to make the calculation simple: let\\'s say dp[i][j] represents the number of permutation of number 0, 1, ... , i which ends with j. Also, it represents the answer of s.substring(0, i) which ends with j.\\nWe will have two conditions:\\n\\ns.charAt(i - 1) == \\'I\\': In this case, dp[i][j] = sum(dp[i - 1][0], dp[i - 1][1], ... , dp[i - 1][j - 1]).\\ns.charAt(i - 1) == \\'D\\': In this case, dp[i][j] = sum(dp[i - 1][j], dp[i - 1][j + 1], ... , dp[i - 1][i - 1]).\\nImagine each time when appending the j to the previous permutations, you have to add 1 to each number in the previous permutation which is greater than or equals to j. In this way, we keep the orders and counts of previous permutations and cumulate.\\n\\neg. We already have permutation (1, 0, 3, 2). We are trying to append 2. Now the (1, 0, 3, 2) changes to (1, 0, 4, 3) then appended with a 2. We have (1, 0, 4, 3, 2). Although the values change but the order and count don\\'t change.\\nWhy in case of D, <=l is used explanation\\nMethod:\\nstep 1.\\nfor the original permutation 1032, we add 1 to the digits that are larger than or equal to 2.\\n\\n1032->1043\\n  ^^\\nstep 2.\\nthen directly append 2 to 1043, i.e., 1043 -> 10432\\n\\nRemark on step 1:\\n(1) By performing add operation, 2 in the original permutation now becomes 3, and thus there is no duplicate element for the new arrival 2.\\n(2) More importantly, such operation on the digits will not break the original DI-rule. e.g., 1043 still keeps its old DI-rule, i.e., \"DID\". The proof is straight-forward, you can validate yourself.",
                "solutionTags": [],
                "code": "Puting n-1 and then putting nth\\nLet\\'s change the definition of dp matrix to make the calculation simple: let\\'s say dp[i][j] represents the number of permutation of number 0, 1, ... , i which ends with j. Also, it represents the answer of s.substring(0, i) which ends with j.\\nWe will have two conditions:\\n\\ns.charAt(i - 1) == \\'I\\': In this case, dp[i][j] = sum(dp[i - 1][0], dp[i - 1][1], ... , dp[i - 1][j - 1]).\\ns.charAt(i - 1) == \\'D\\': In this case, dp[i][j] = sum(dp[i - 1][j], dp[i - 1][j + 1], ... , dp[i - 1][i - 1]).\\nImagine each time when appending the j to the previous permutations, you have to add 1 to each number in the previous permutation which is greater than or equals to j. In this way, we keep the orders and counts of previous permutations and cumulate.\\n\\neg. We already have permutation (1, 0, 3, 2). We are trying to append 2. Now the (1, 0, 3, 2) changes to (1, 0, 4, 3) then appended with a 2. We have (1, 0, 4, 3, 2). Although the values change but the order and count don\\'t change.\\nWhy in case of D, <=l is used explanation\\nMethod:\\nstep 1.\\nfor the original permutation 1032, we add 1 to the digits that are larger than or equal to 2.\\n\\n1032->1043\\n  ^^\\nstep 2.\\nthen directly append 2 to 1043, i.e., 1043 -> 10432\\n\\nRemark on step 1:\\n(1) By performing add operation, 2 in the original permutation now becomes 3, and thus there is no duplicate element for the new arrival 2.\\n(2) More importantly, such operation on the digits will not break the original DI-rule. e.g., 1043 still keeps its old DI-rule, i.e., \"DID\". The proof is straight-forward, you can validate yourself.",
                "codeTag": "Unknown"
            }
        ],
        "discussions": [
            {
                "id": 1565857,
                "content": [
                    {
                        "username": "quadpixels",
                        "content": "After viewing the topics on this page I came to realize that one nice property of this problem is if we _increment elements that are greater than or equal to a certain value_ the D or I property will not be broken, as this only makes \"larger\" elements even larger.\\n\\nThis can be visualized by imagining cutting a piece of paper with the elements plotted on it, with the X axis being the index in a sequence, and the Y axis being the actual value, and then separate the two parts, as follows:\\n\\n![image](https://s3-lc-upload.s3.amazonaws.com/users/quadpixels/image_1536661881.png)\\n\\nImagine cutting a piece of paper with this plot on it along the blue lines and separate the two parts, and adding a new element to the end ------\\n\\nA _GIF_ version may be seen here: (it seems LeetCode discussion boards do not allow directly posting GIFs) [https://imgur.com/a/y5MreX8](https://imgur.com/a/y5MreX8)\\n\\n\\nFrom this point, it is easier to see where the dynamic programming essence comes in. Basically the number of solutions with length N+1 depends on, and can be derived from, the number of solutions with length N, as follows:\\n* We increment all elements that are greater than or equal to 0, and see if we can append 0 to the end of the sequence.\\n* We increment all elements that are greater than or equal to 1, and see if we can append 1 to the end of the sequence.\\n* ...\\n* We increment all elements that are greater than or equal to N+1, and see if we can append N+1 to the end of the sequence.\\n\\nThus the dynamic programming pattern.\\n(:"
                    },
                    {
                        "username": "orioncyngus",
                        "content": "lee215 had a different definition for dp[i][j], but it would be very unlikely for me to come up with his definition, so instead, I looked at the solutions that I think I could (or be more inclined to) have come up with in: \\n\\n(1) https://leetcode.com/problems/valid-permutations-for-di-sequence/discuss/196939/Easy-to-understand-solution-with-detailed-explanation\\n\\nand\\n\\n(2) https://leetcode.com/problems/valid-permutations-for-di-sequence/discuss/168612/Top-down-with-Memo-greater-Bottom-up-DP-greater-N3-DP-greater-N2-DP-greater-O(N)-space\\n\\n\\nIn both of these links `dp[i][j]` is defined as the number of permutations for `{0,1,..,i}` that ends in `j` that satisfies `s[0:i-1]`.\\n\\nAnd the transition function is:\\nif(s[i - 1] == \"I\") dp[i][j] = sum(dp[i-1][k]) from k = 0...j-1\\nif(s[i - 1] == \"D\") dp[i][j] = sum(dp[i-1][k]) from k = j...i-1\\n\\nI understand the idea of adding ones to all values `>= j` in the permutations for `dp[i-1][k]` and then appending `j`. I understand that this gives us valid permutations for `dp[i][j]` and that all the permutations in `dp[i-1][k]` are disjoint and hence summable. What I don\\'t understand is why this is sufficient? That is, how does this include all possible valid permutations? I have not seen a discussion that demonstrates why this transition function is sufficient. \\n\\nAt first, I thought perhaps the validity follows by induction, but by \"adding ones,\" I don\\'t think the proof can follow by induction, so I\\'m lost as to how to show this transition function is correct. \\n\\n"
                    },
                    {
                        "username": "lcgod",
                        "content": "![image](https://assets.leetcode.com/users/images/714aed02-bdd4-4bc9-8643-05ac27073110_1609729667.0158942.png)\\n"
                    }
                ]
            },
            {
                "id": 1570469,
                "content": [
                    {
                        "username": "quadpixels",
                        "content": "After viewing the topics on this page I came to realize that one nice property of this problem is if we _increment elements that are greater than or equal to a certain value_ the D or I property will not be broken, as this only makes \"larger\" elements even larger.\\n\\nThis can be visualized by imagining cutting a piece of paper with the elements plotted on it, with the X axis being the index in a sequence, and the Y axis being the actual value, and then separate the two parts, as follows:\\n\\n![image](https://s3-lc-upload.s3.amazonaws.com/users/quadpixels/image_1536661881.png)\\n\\nImagine cutting a piece of paper with this plot on it along the blue lines and separate the two parts, and adding a new element to the end ------\\n\\nA _GIF_ version may be seen here: (it seems LeetCode discussion boards do not allow directly posting GIFs) [https://imgur.com/a/y5MreX8](https://imgur.com/a/y5MreX8)\\n\\n\\nFrom this point, it is easier to see where the dynamic programming essence comes in. Basically the number of solutions with length N+1 depends on, and can be derived from, the number of solutions with length N, as follows:\\n* We increment all elements that are greater than or equal to 0, and see if we can append 0 to the end of the sequence.\\n* We increment all elements that are greater than or equal to 1, and see if we can append 1 to the end of the sequence.\\n* ...\\n* We increment all elements that are greater than or equal to N+1, and see if we can append N+1 to the end of the sequence.\\n\\nThus the dynamic programming pattern.\\n(:"
                    },
                    {
                        "username": "orioncyngus",
                        "content": "lee215 had a different definition for dp[i][j], but it would be very unlikely for me to come up with his definition, so instead, I looked at the solutions that I think I could (or be more inclined to) have come up with in: \\n\\n(1) https://leetcode.com/problems/valid-permutations-for-di-sequence/discuss/196939/Easy-to-understand-solution-with-detailed-explanation\\n\\nand\\n\\n(2) https://leetcode.com/problems/valid-permutations-for-di-sequence/discuss/168612/Top-down-with-Memo-greater-Bottom-up-DP-greater-N3-DP-greater-N2-DP-greater-O(N)-space\\n\\n\\nIn both of these links `dp[i][j]` is defined as the number of permutations for `{0,1,..,i}` that ends in `j` that satisfies `s[0:i-1]`.\\n\\nAnd the transition function is:\\nif(s[i - 1] == \"I\") dp[i][j] = sum(dp[i-1][k]) from k = 0...j-1\\nif(s[i - 1] == \"D\") dp[i][j] = sum(dp[i-1][k]) from k = j...i-1\\n\\nI understand the idea of adding ones to all values `>= j` in the permutations for `dp[i-1][k]` and then appending `j`. I understand that this gives us valid permutations for `dp[i][j]` and that all the permutations in `dp[i-1][k]` are disjoint and hence summable. What I don\\'t understand is why this is sufficient? That is, how does this include all possible valid permutations? I have not seen a discussion that demonstrates why this transition function is sufficient. \\n\\nAt first, I thought perhaps the validity follows by induction, but by \"adding ones,\" I don\\'t think the proof can follow by induction, so I\\'m lost as to how to show this transition function is correct. \\n\\n"
                    },
                    {
                        "username": "lcgod",
                        "content": "![image](https://assets.leetcode.com/users/images/714aed02-bdd4-4bc9-8643-05ac27073110_1609729667.0158942.png)\\n"
                    }
                ]
            },
            {
                "id": 1568500,
                "content": [
                    {
                        "username": "quadpixels",
                        "content": "After viewing the topics on this page I came to realize that one nice property of this problem is if we _increment elements that are greater than or equal to a certain value_ the D or I property will not be broken, as this only makes \"larger\" elements even larger.\\n\\nThis can be visualized by imagining cutting a piece of paper with the elements plotted on it, with the X axis being the index in a sequence, and the Y axis being the actual value, and then separate the two parts, as follows:\\n\\n![image](https://s3-lc-upload.s3.amazonaws.com/users/quadpixels/image_1536661881.png)\\n\\nImagine cutting a piece of paper with this plot on it along the blue lines and separate the two parts, and adding a new element to the end ------\\n\\nA _GIF_ version may be seen here: (it seems LeetCode discussion boards do not allow directly posting GIFs) [https://imgur.com/a/y5MreX8](https://imgur.com/a/y5MreX8)\\n\\n\\nFrom this point, it is easier to see where the dynamic programming essence comes in. Basically the number of solutions with length N+1 depends on, and can be derived from, the number of solutions with length N, as follows:\\n* We increment all elements that are greater than or equal to 0, and see if we can append 0 to the end of the sequence.\\n* We increment all elements that are greater than or equal to 1, and see if we can append 1 to the end of the sequence.\\n* ...\\n* We increment all elements that are greater than or equal to N+1, and see if we can append N+1 to the end of the sequence.\\n\\nThus the dynamic programming pattern.\\n(:"
                    },
                    {
                        "username": "orioncyngus",
                        "content": "lee215 had a different definition for dp[i][j], but it would be very unlikely for me to come up with his definition, so instead, I looked at the solutions that I think I could (or be more inclined to) have come up with in: \\n\\n(1) https://leetcode.com/problems/valid-permutations-for-di-sequence/discuss/196939/Easy-to-understand-solution-with-detailed-explanation\\n\\nand\\n\\n(2) https://leetcode.com/problems/valid-permutations-for-di-sequence/discuss/168612/Top-down-with-Memo-greater-Bottom-up-DP-greater-N3-DP-greater-N2-DP-greater-O(N)-space\\n\\n\\nIn both of these links `dp[i][j]` is defined as the number of permutations for `{0,1,..,i}` that ends in `j` that satisfies `s[0:i-1]`.\\n\\nAnd the transition function is:\\nif(s[i - 1] == \"I\") dp[i][j] = sum(dp[i-1][k]) from k = 0...j-1\\nif(s[i - 1] == \"D\") dp[i][j] = sum(dp[i-1][k]) from k = j...i-1\\n\\nI understand the idea of adding ones to all values `>= j` in the permutations for `dp[i-1][k]` and then appending `j`. I understand that this gives us valid permutations for `dp[i][j]` and that all the permutations in `dp[i-1][k]` are disjoint and hence summable. What I don\\'t understand is why this is sufficient? That is, how does this include all possible valid permutations? I have not seen a discussion that demonstrates why this transition function is sufficient. \\n\\nAt first, I thought perhaps the validity follows by induction, but by \"adding ones,\" I don\\'t think the proof can follow by induction, so I\\'m lost as to how to show this transition function is correct. \\n\\n"
                    },
                    {
                        "username": "lcgod",
                        "content": "![image](https://assets.leetcode.com/users/images/714aed02-bdd4-4bc9-8643-05ac27073110_1609729667.0158942.png)\\n"
                    }
                ]
            }
        ]
    }
]