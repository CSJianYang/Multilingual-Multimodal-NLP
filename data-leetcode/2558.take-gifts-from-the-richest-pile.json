[
    {
        "title": "Take Gifts From the Richest Pile",
        "question_content": "You are given an integer array gifts denoting the number of gifts in various piles. Every second, you do the following:\n\n\tChoose the pile with the maximum number of gifts.\n\tIf there is more than one pile with the maximum number of gifts, choose any.\n\tLeave behind the floor of the square root of the number of gifts in the pile. Take the rest of the gifts.\n\nReturn the number of gifts remaining after k seconds.\n&nbsp;\nExample 1:\n\nInput: gifts = [25,64,9,4,100], k = 4\nOutput: 29\nExplanation: \nThe gifts are taken in the following way:\n- In the first second, the last pile is chosen and 10 gifts are left behind.\n- Then the second pile is chosen and 8 gifts are left behind.\n- After that the first pile is chosen and 5 gifts are left behind.\n- Finally, the last pile is chosen again and 3 gifts are left behind.\nThe final remaining gifts are [5,8,9,4,3], so the total number of gifts remaining is 29.\n\nExample 2:\n\nInput: gifts = [1,1,1,1], k = 4\nOutput: 4\nExplanation: \nIn this case, regardless which pile you choose, you have to leave behind 1 gift in each pile. \nThat is, you can't take any pile with you. \nSo, the total gifts remaining are 4.\n\n&nbsp;\nConstraints:\n\n\t1 <= gifts.length <= 103\n\t1 <= gifts[i] <= 109\n\t1 <= k <= 103",
        "solutions": [
            {
                "id": 3143788,
                "title": "java-priority-queue-very-easy-intuitive",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(nlogn)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public long pickGifts(int[] nums, int k) {\\n        int n = nums.length;\\n        PriorityQueue<Integer> pq = new PriorityQueue<>((a,b)->(b-a));    // MAX-HEAP\\n        \\n        for(int i = 0; i<n; i++){\\n            pq.add(nums[i]);\\n        }\\n        \\n        long sum = 0;\\n        while(k-->0){\\n            pq.add((int)Math.sqrt(pq.remove()));\\n        }\\n        \\n        while(pq.size()>0){\\n            sum+=pq.remove();\\n        }\\n\\n        return sum;\\n    }\\n}\\n```\\n\\n\\n![cat upvote.jpeg](https://assets.leetcode.com/users/images/4182f390-5204-4a87-99d5-eebe8baa88fc_1675570141.2059023.jpeg)\\n",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Math",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\n    public long pickGifts(int[] nums, int k) {\\n        int n = nums.length;\\n        PriorityQueue<Integer> pq = new PriorityQueue<>((a,b)->(b-a));    // MAX-HEAP\\n        \\n        for(int i = 0; i<n; i++){\\n            pq.add(nums[i]);\\n        }\\n        \\n        long sum = 0;\\n        while(k-->0){\\n            pq.add((int)Math.sqrt(pq.remove()));\\n        }\\n        \\n        while(pq.size()>0){\\n            sum+=pq.remove();\\n        }\\n\\n        return sum;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3143722,
                "title": "priority-queue-very-simple-easy-to-understand-solution",
                "content": "### Up Vote if you like the solution\\n\\n# Approach\\nPush each element to priority queue and then, k time push the sqrt of each item. pop k times the top.\\nTake sum of remaining elements in the queue.\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long pickGifts(vector<int>& gifts, int k) {\\n        long long ans = 0;\\n        priority_queue<int> pq;\\n        for(auto n: gifts) pq.push(n);\\n        while(k--){ pq.push(sqrt(pq.top())); pq.pop(); }\\n        while(pq.size() > 0){ ans+= pq.top(); pq.pop(); }\\n        return ans;\\n    }\\n};\\n```\\n\\nHere is an article of my recent interview experience at Amazon, you may like : \\nhttps://leetcode.com/discuss/interview-experience/3171859/Journey-to-a-FAANG-Company-Amazon-or-SDE2-(L5)-or-Bangalore-or-Oct-2022-Accepted",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long pickGifts(vector<int>& gifts, int k) {\\n        long long ans = 0;\\n        priority_queue<int> pq;\\n        for(auto n: gifts) pq.push(n);\\n        while(k--){ pq.push(sqrt(pq.top())); pq.pop(); }\\n        while(pq.size() > 0){ ans+= pq.top(); pq.pop(); }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3143755,
                "title": "make-heap",
                "content": "We use array heap functions here for the efficiency. \\n\\nIt also allows us to sum the remaining numbers directly (no need to pop them).\\n\\nTherefore, the time complexity is O(n + k log n).\\n\\nNote that, if `k` is very large, we can exit when the top of the heap becomes `1`.\\n\\n**C++**\\n```cpp\\nlong long pickGifts(vector<int>& g, int k) {\\n    make_heap(begin(g), end(g));\\n    while(k--) {\\n        pop_heap(begin(g), end(g));\\n        g.back() = sqrt(g.back());\\n        push_heap(begin(g), end(g));\\n    }\\n    return accumulate(begin(g), end(g), 0LL);\\n}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```cpp\\nlong long pickGifts(vector<int>& g, int k) {\\n    make_heap(begin(g), end(g));\\n    while(k--) {\\n        pop_heap(begin(g), end(g));\\n        g.back() = sqrt(g.back());\\n        push_heap(begin(g), end(g));\\n    }\\n    return accumulate(begin(g), end(g), 0LL);\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3144075,
                "title": "python3-heap",
                "content": "```\\nclass Solution:\\n    def pickGifts(self, gifts: List[int], k: int) -> int:\\n        nums = [-num for num in gifts]\\n        heapify(nums)\\n        \\n        while k:\\n            tmp = math.isqrt(-heappop(nums))\\n            heappush(nums, -tmp)\\n            k -= 1\\n            \\n        return -sum(nums)\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution:\\n    def pickGifts(self, gifts: List[int], k: int) -> int:\\n        nums = [-num for num in gifts]\\n        heapify(nums)\\n        \\n        while k:\\n            tmp = math.isqrt(-heappop(nums))\\n            heappush(nums, -tmp)\\n            k -= 1\\n            \\n        return -sum(nums)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3149317,
                "title": "python-100-faster-easy-solution",
                "content": "# Code\\u2705\\n```\\nimport math\\nclass Solution:\\n    def pickGifts(self, gifts: List[int], k: int) -> int:\\n        i = 0\\n        while i < k:\\n            gifts = sorted(gifts)\\n            sqrt = math.floor(math.sqrt(gifts[-1]))\\n            gifts[-1] = sqrt\\n            i +=1\\n        return sum(gifts)\\n```\\n![Screen Shot 2023-02-06 at 11.03.32 AM.png](https://assets.leetcode.com/users/images/9b3dc255-4a6b-4a52-bc8d-4a8319b930af_1675661681.3121037.png)\\n",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Math"
                ],
                "code": "```\\nimport math\\nclass Solution:\\n    def pickGifts(self, gifts: List[int], k: int) -> int:\\n        i = 0\\n        while i < k:\\n            gifts = sorted(gifts)\\n            sqrt = math.floor(math.sqrt(gifts[-1]))\\n            gifts[-1] = sqrt\\n            i +=1\\n        return sum(gifts)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3143816,
                "title": "c-priority-queue-easy-to-understand",
                "content": "# Code\\n```\\nclass Solution \\n{\\npublic:\\n    long long pickGifts(vector<int>& gifts, int k) \\n    {\\n        priority_queue<long long> pq;\\n        \\n        for(auto &it:gifts) pq.push(it);\\n        long long sum=0, n;\\n        \\n        while(k--)\\n        {\\n            n = sqrt(pq.top());\\n            pq.pop();\\n            pq.push(n);\\n        }\\n            \\n        while(!pq.empty())\\n        {\\n            sum += pq.top(); pq.pop();\\n        }\\n        return sum;\\n        \\n    }\\n};\\n```\\n\\n# Please upvote if you find this solution helpful",
                "solutionTags": [
                    "C++",
                    "Math",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution \\n{\\npublic:\\n    long long pickGifts(vector<int>& gifts, int k) \\n    {\\n        priority_queue<long long> pq;\\n        \\n        for(auto &it:gifts) pq.push(it);\\n        long long sum=0, n;\\n        \\n        while(k--)\\n        {\\n            n = sqrt(pq.top());\\n            pq.pop();\\n            pq.push(n);\\n        }\\n            \\n        while(!pq.empty())\\n        {\\n            sum += pq.top(); pq.pop();\\n        }\\n        return sum;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3143839,
                "title": "very-easy-beginners-friendly-c-priority-queue",
                "content": "```\\n\\nclass Solution {\\npublic:\\n    #define ll long long \\n    long long pickGifts(vector<int>& gifts, int k) \\n    {\\n        priority_queue<ll > pq;\\n        ll res = 0;\\n        \\n        for(auto it : gifts)\\n        {\\n              pq.push(it);\\n        }\\n         \\n        while(k--)\\n        {\\n           ll val = pq.top();\\n           pq.pop();\\n           \\n           ll temp = sqrt(val);\\n           pq.push(temp);\\n        }\\n        \\n        while(!pq.empty())\\n        {\\n            res += pq.top();\\n            pq.pop();\\n        }\\n        \\n        return res;\\n    }\\n};\\n```\\n\\nIf it helps, then Upvote Please \\uD83D\\uDE0A\\uD83D\\uDE0A",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n\\nclass Solution {\\npublic:\\n    #define ll long long \\n    long long pickGifts(vector<int>& gifts, int k) \\n    {\\n        priority_queue<ll > pq;\\n        ll res = 0;\\n        \\n        for(auto it : gifts)\\n        {\\n              pq.push(it);\\n        }\\n         \\n        while(k--)\\n        {\\n           ll val = pq.top();\\n           pq.pop();\\n           \\n           ll temp = sqrt(val);\\n           pq.push(temp);\\n        }\\n        \\n        while(!pq.empty())\\n        {\\n            res += pq.top();\\n            pq.pop();\\n        }\\n        \\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3143978,
                "title": "c-beginner-friendly-code-clean-easy",
                "content": "![image](https://assets.leetcode.com/users/images/51d8e783-4a2c-4ebc-801a-3ff0d8cd90c2_1675570700.0074947.png)\\n\\n**T->O(logn + n) && S->O(n)**\\n\\n\\tclass Solution {\\n\\tpublic:\\n\\t\\tlong long pickGifts(vector<int>& g, int k) {\\n\\t\\t\\tlong long ans=0;\\n\\t\\t\\tpriority_queue<int>pq;\\n\\n\\t\\t\\tfor(auto i:g) pq.push(i);\\n\\n\\t\\t\\twhile(k-- && !pq.empty()){\\n\\t\\t\\t\\tint t=pq.top();\\n\\t\\t\\t\\tpq.pop();\\n\\t\\t\\t\\tpq.push(floor(sqrt(t)));\\n\\t\\t\\t}\\n\\n\\t\\t\\twhile(!pq.empty()){\\n\\t\\t\\t\\tans+=pq.top();\\n\\t\\t\\t\\tpq.pop();\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn ans;\\n\\t\\t}\\n\\t};",
                "solutionTags": [
                    "C++",
                    "C",
                    "Heap (Priority Queue)"
                ],
                "code": "class Solution {\\n\\tpublic:\\n\\t\\tlong long pickGifts(vector<int>& g, int k) {\\n\\t\\t\\tlong long ans=0;\\n\\t\\t\\tpriority_queue<int>pq;\\n\\n\\t\\t\\tfor(auto i:g) pq.push(i);\\n\\n\\t\\t\\twhile(k-- && !pq.empty()){\\n\\t\\t\\t\\tint t=pq.top();\\n\\t\\t\\t\\tpq.pop();\\n\\t\\t\\t\\tpq.push(floor(sqrt(t)));\\n\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 3143807,
                "title": "easy-java-solution-priorityqueue",
                "content": "\\n# Code\\n```\\nclass Solution {\\n    public long pickGifts(int[] gifts, int k) {\\n        PriorityQueue<Integer> pq=new PriorityQueue<>(Collections.reverseOrder());\\n        for(int i=0;i<gifts.length;i++){\\n            pq.add(gifts[i]);\\n        }\\n         for(int i=0;i<k;i++){\\n            int a=pq.poll();\\n             int sq=(int)Math.sqrt(a);\\n             int res=(int)sq;\\n             pq.add(res);\\n        }\\n        long ans=0;\\n        for(int i=0;i<gifts.length;i++){\\n            ans+=pq.poll();\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Math",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\n    public long pickGifts(int[] gifts, int k) {\\n        PriorityQueue<Integer> pq=new PriorityQueue<>(Collections.reverseOrder());\\n        for(int i=0;i<gifts.length;i++){\\n            pq.add(gifts[i]);\\n        }\\n         for(int i=0;i<k;i++){\\n            int a=pq.poll();\\n             int sq=(int)Math.sqrt(a);\\n             int res=(int)sq;\\n             pq.add(res);\\n        }\\n        long ans=0;\\n        for(int i=0;i<gifts.length;i++){\\n            ans+=pq.poll();\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3143731,
                "title": "c-using-priority-queue",
                "content": "```\\nclass Solution {\\npublic:\\n    long long pickGifts(vector<int>& gifts, int k) \\n    {\\n        priority_queue<int>pq;\\n        for(auto i:gifts)pq.push(i);\\n        \\n        long long ans = 0;\\n        for(int i = 0;i<k;i++)\\n        {\\n            int top = pq.top();\\n            pq.pop();\\n            pq.push(sqrt(top));\\n        }\\n        while(!pq.empty())\\n        {\\n            ans+=pq.top();\\n            pq.pop();\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long pickGifts(vector<int>& gifts, int k) \\n    {\\n        priority_queue<int>pq;\\n        for(auto i:gifts)pq.push(i);\\n        \\n        long long ans = 0;\\n        for(int i = 0;i<k;i++)\\n        {\\n            int top = pq.top();\\n            pq.pop();\\n            pq.push(sqrt(top));\\n        }\\n        while(!pq.empty())\\n        {\\n            ans+=pq.top();\\n            pq.pop();\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3153336,
                "title": "python-3-6-lines-heap-w-example-t-m-32-ms-14-0-mb",
                "content": "\"$$heapq.heappushpop(heap, item)$$:   Push item on the heap, then pop and return the smallest item from the heap. The combined action runs more efficiently than heappush() followed by a separate call to heappop.\" -- [https://docs.python.org/3/library/heapq.html]()\"\\n```\\nclass Solution:\\n    def pickGifts(self, gifts: List[int], k: int) -> int:\\n\\n        heap = []                               # Example: gifts = [25,64,9,4,100] ; k = 4\\n\\n        for g in gifts: heappush(heap,-g)       # heap = [-100,-64,-25, -9,-4]\\n                     \\n                                                #    g    isqrt(g)        heap\\n        g = -heappop(heap)                      #  \\u2013\\u2013\\u2013\\u2013\\u2013  \\u2013\\u2013\\u2013\\u2013\\u2013\\u2013\\u2013\\u2013  \\u2013\\u2013\\u2013\\u2013\\u2013\\u2013\\u2013\\u2013\\u2013\\u2013\\u2013\\u2013\\u2013\\u2013\\u2013\\u2013\\u2013\\n                                                #   100     10      [-64,-25, -9, -4]\\n        for _ in range(k):                      #    64      8      [-25,-10, -9, -4]      \\n            g = -heappushpop(heap, -isqrt(g))   #    10      3      [-10,- 8, -9, -4]\\n                                                #     9             [- 8, -4, -5, -3]\\n        \\n        return g - sum(heap)                    # return 9 - sum(- 8, -4,-5,-3) = 29\\n```\\n[https://leetcode.com/problems/take-gifts-from-the-richest-pile/submissions/892067623/](http://)",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def pickGifts(self, gifts: List[int], k: int) -> int:\\n\\n        heap = []                               # Example: gifts = [25,64,9,4,100] ; k = 4\\n\\n        for g in gifts: heappush(heap,-g)       # heap = [-100,-64,-25, -9,-4]\\n                     \\n                                                #    g    isqrt(g)        heap\\n        g = -heappop(heap)                      #  \\u2013\\u2013\\u2013\\u2013\\u2013  \\u2013\\u2013\\u2013\\u2013\\u2013\\u2013\\u2013\\u2013  \\u2013\\u2013\\u2013\\u2013\\u2013\\u2013\\u2013\\u2013\\u2013\\u2013\\u2013\\u2013\\u2013\\u2013\\u2013\\u2013\\u2013\\n                                                #   100     10      [-64,-25, -9, -4]\\n        for _ in range(k):                      #    64      8      [-25,-10, -9, -4]      \\n            g = -heappushpop(heap, -isqrt(g))   #    10      3      [-10,- 8, -9, -4]\\n                                                #     9             [- 8, -4, -5, -3]\\n        \\n        return g - sum(heap)                    # return 9 - sum(- 8, -4,-5,-3) = 29\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3144218,
                "title": "beats-100-simplest-c-self-understandable-code",
                "content": "\\n\\n# Complexity\\n- Time complexity: O(n^2)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n\\nPLEASE UPVOTE IF YOU LIKE THE SOLUTION\\n\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long pickGifts(vector<int>& gifts, int k) {\\n        while (k > 0 && gifts.size() > 0) {\\n            int max_gift = gifts[0];\\n            int max_gift_index = 0;\\n            for (int i = 1; i < gifts.size(); i++) {\\n                if (gifts[i] > max_gift) {\\n                    max_gift = gifts[i];\\n                    max_gift_index = i;\\n                }\\n            }\\n            gifts[max_gift_index] = floor(sqrt(gifts[max_gift_index]));\\n            k--;\\n        }\\n        long long result = 0;\\n        for (int i = 0; i < gifts.size(); i++) {\\n            result += gifts[i];\\n        }\\n        return result;\\n    }\\n};\\n\\n\\n\\n\\n\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long pickGifts(vector<int>& gifts, int k) {\\n        while (k > 0 && gifts.size() > 0) {\\n            int max_gift = gifts[0];\\n            int max_gift_index = 0;\\n            for (int i = 1; i < gifts.size(); i++) {\\n                if (gifts[i] > max_gift) {\\n                    max_gift = gifts[i];\\n                    max_gift_index = i;\\n                }\\n            }\\n            gifts[max_gift_index] = floor(sqrt(gifts[max_gift_index]));\\n            k--;\\n        }\\n        long long result = 0;\\n        for (int i = 0; i < gifts.size(); i++) {\\n            result += gifts[i];\\n        }\\n        return result;\\n    }\\n};\\n\\n\\n\\n\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3144018,
                "title": "java-easy-one",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public long pickGifts(int[] gifts, int k) {\\n        long res=0;\\n        Arrays.sort(gifts);\\n        // [25,64,9,4,100]  3 5 8 9  \\n        PriorityQueue<Integer> p=new PriorityQueue<>(Collections.reverseOrder());\\n        for(int i:gifts)p.add(i);\\n        while(k!=0){\\n                int v=(int)Math.sqrt(p.poll());\\n                p.add(v);\\n                k--;\\n        }\\n        for(int i:p)res+=i;\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public long pickGifts(int[] gifts, int k) {\\n        long res=0;\\n        Arrays.sort(gifts);\\n        // [25,64,9,4,100]  3 5 8 9  \\n        PriorityQueue<Integer> p=new PriorityQueue<>(Collections.reverseOrder());\\n        for(int i:gifts)p.add(i);\\n        while(k!=0){\\n                int v=(int)Math.sqrt(p.poll());\\n                p.add(v);\\n                k--;\\n        }\\n        for(int i:p)res+=i;\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3143827,
                "title": "cpp-easiest-solution-for-beginner-s-without-queue",
                "content": "```\\nclass Solution {\\npublic:\\n    long long pickGifts(vector<int>& gifts, int k) {\\n        long long sum=0,index=-1;\\n        for(int i=0;i<k;i++){\\n            int maxi=*max_element(gifts.begin(),gifts.end());\\n            for(int j=0;j<gifts.size();j++){\\n                if(maxi==gifts[j]){\\n                    index=j;\\n                    break;\\n                }\\n            }\\n        gifts[index]=floor(sqrt(gifts[index]));          \\n        }\\n        for(auto& it:gifts)sum+=it;\\n        \\n        return sum;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long pickGifts(vector<int>& gifts, int k) {\\n        long long sum=0,index=-1;\\n        for(int i=0;i<k;i++){\\n            int maxi=*max_element(gifts.begin(),gifts.end());\\n            for(int j=0;j<gifts.size();j++){\\n                if(maxi==gifts[j]){\\n                    index=j;\\n                    break;\\n                }\\n            }\\n        gifts[index]=floor(sqrt(gifts[index]));          \\n        }\\n        for(auto& it:gifts)sum+=it;\\n        \\n        return sum;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3143776,
                "title": "short-clean-java",
                "content": "\\n```java []\\nclass Solution {\\n    public long pickGifts(int[] gifts, int k) {\\n        PriorityQueue<Integer> pq = new PriorityQueue<>((a,b)->b-a);\\n        for(int gift: gifts)    pq.add(gift);\\n        while(k-->0)    pq.add((int)Math.floor(Math.sqrt(pq.poll())));\\n        long sum = 0;\\n        while(!pq.isEmpty())    sum += pq.poll();\\n        return sum;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```java []\\nclass Solution {\\n    public long pickGifts(int[] gifts, int k) {\\n        PriorityQueue<Integer> pq = new PriorityQueue<>((a,b)->b-a);\\n        for(int gift: gifts)    pq.add(gift);\\n        while(k-->0)    pq.add((int)Math.floor(Math.sqrt(pq.poll())));\\n        long sum = 0;\\n        while(!pq.isEmpty())    sum += pq.poll();\\n        return sum;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3143714,
                "title": "easy-js-solution",
                "content": "\\n# Code\\n```\\nconst pickGifts = (gifts, k) => {\\n\\n\\n    for(let i = 0; i < k; i++){\\n        gifts.sort((a,b) => a - b)\\n        let newEl = Math.floor(Math.sqrt(gifts.pop()))\\n        gifts.push(newEl)\\n    }\\n    return gifts.reduce((a,b) => a + b)\\n};\\n\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nconst pickGifts = (gifts, k) => {\\n\\n\\n    for(let i = 0; i < k; i++){\\n        gifts.sort((a,b) => a - b)\\n        let newEl = Math.floor(Math.sqrt(gifts.pop()))\\n        gifts.push(newEl)\\n    }\\n    return gifts.reduce((a,b) => a + b)\\n};\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3143700,
                "title": "easy-solution-c-priority-queue",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n //app 1:\\n    \\n    /*idea:\\n    use a pq to always pick the gift with max. val\\n    repeat this step for k times\\n    after picking a gift push in pq it\\'s sq root.\\n    at the end, return sum of remaining gifts. \\n    */\\n    long long pickGifts(vector<int>& gifts, int k) {\\n        long long ans=0;\\n        \\n        priority_queue<long long> pq;\\n        \\n        for(int &x: gifts) pq.push(x);\\n        \\n        while(k--){\\n            long long topp = pq.top();\\n            pq.pop();\\n            \\n            long long y = sqrt(topp);\\n            //cout<<y<<\" \";\\n            pq.push(y);\\n        }\\n        \\n        while(!pq.empty()){\\n            ans += pq.top();\\n            pq.pop();\\n        }\\n        return ans;\\n    }\\n};\\n```\\n# Please Upvote \\u2705\\u2705\\n\\n![Upvote Please.jpeg](https://assets.leetcode.com/users/images/37383587-cc62-4f15-b630-a6271902be7b_1675570180.0010076.jpeg)\\n\\n\\n",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n //app 1:\\n    \\n    /*idea:\\n    use a pq to always pick the gift with max. val\\n    repeat this step for k times\\n    after picking a gift push in pq it\\'s sq root.\\n    at the end, return sum of remaining gifts. \\n    */\\n    long long pickGifts(vector<int>& gifts, int k) {\\n        long long ans=0;\\n        \\n        priority_queue<long long> pq;\\n        \\n        for(int &x: gifts) pq.push(x);\\n        \\n        while(k--){\\n            long long topp = pq.top();\\n            pq.pop();\\n            \\n            long long y = sqrt(topp);\\n            //cout<<y<<\" \";\\n            pq.push(y);\\n        }\\n        \\n        while(!pq.empty()){\\n            ans += pq.top();\\n            pq.pop();\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3526863,
                "title": "c-heap-replace-max-by-sqrt-max",
                "content": "replace max element by sqrt(mx).\\nthan return sum of all remaing elements.\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long pickGifts(vector<int>& gifts, int k) {\\n        priority_queue<int> pq;\\n        for(auto &i: gifts){\\n            pq.push(i);\\n        }\\n        long long int ans = 0;\\n        int x;\\n        while(k--){\\n            x = pq.top();\\n            pq.pop();\\n            pq.push(sqrt(x));\\n        }\\n        while(!pq.empty()){\\n            ans += pq.top();\\n            pq.pop();\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long pickGifts(vector<int>& gifts, int k) {\\n        priority_queue<int> pq;\\n        for(auto &i: gifts){\\n            pq.push(i);\\n        }\\n        long long int ans = 0;\\n        int x;\\n        while(k--){\\n            x = pq.top();\\n            pq.pop();\\n            pq.push(sqrt(x));\\n        }\\n        while(!pq.empty()){\\n            ans += pq.top();\\n            pq.pop();\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3481524,
                "title": "java-easy-to-understand-priority-queue",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public long pickGifts(int[] gifts, int k) {\\n        // Arrays.sort(gifts);\\n        // //long i=0;\\n        // while(k>0){\\n        //     gifts[gifts.length-1]=(int)Math.sqrt(gifts[gifts.length-1]);\\n        //     Arrays.sort(gifts);\\n        //     k--;\\n        // }\\n        // long ans=0;\\n        // for(int i=0;i<gifts.length;i++){\\n        //     ans+=gifts[i];\\n        // }\\n        // return ans;\\n        PriorityQueue<Integer> q=new PriorityQueue<>(Collections.reverseOrder());\\n        for(int x:gifts)\\n            q.add(x);\\n        for(int i=0;i<k;i++){\\n            int cur=q.remove();\\n            q.add((int)Math.sqrt(cur));\\n        }\\n        long ans=0;\\n        while(q.size()>0){\\n            ans+=q.remove();\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\n    public long pickGifts(int[] gifts, int k) {\\n        // Arrays.sort(gifts);\\n        // //long i=0;\\n        // while(k>0){\\n        //     gifts[gifts.length-1]=(int)Math.sqrt(gifts[gifts.length-1]);\\n        //     Arrays.sort(gifts);\\n        //     k--;\\n        // }\\n        // long ans=0;\\n        // for(int i=0;i<gifts.length;i++){\\n        //     ans+=gifts[i];\\n        // }\\n        // return ans;\\n        PriorityQueue<Integer> q=new PriorityQueue<>(Collections.reverseOrder());\\n        for(int x:gifts)\\n            q.add(x);\\n        for(int i=0;i<k;i++){\\n            int cur=q.remove();\\n            q.add((int)Math.sqrt(cur));\\n        }\\n        long ans=0;\\n        while(q.size()>0){\\n            ans+=q.remove();\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3146400,
                "title": "javascript-solution-using-max-priority-queue",
                "content": "# Code\\n```\\n/**\\n * @param {number[]} gifts\\n * @param {number} k\\n * @return {number}\\n */\\nvar pickGifts = function(gifts, k) {\\n    const q = new MaxPriorityQueue();\\n    for (const i of gifts) {\\n        q.enqueue(i);\\n    }\\n    \\n    while (k--) {\\n        const val = q.dequeue().element;\\n        const fsqrt = Math.floor(Math.sqrt(val));\\n        q.enqueue(fsqrt);\\n    }\\n    \\n    let sum = 0;\\n   while (!q.isEmpty()) {\\n       sum += q.dequeue().element;\\n   }\\n    \\n    return sum;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} gifts\\n * @param {number} k\\n * @return {number}\\n */\\nvar pickGifts = function(gifts, k) {\\n    const q = new MaxPriorityQueue();\\n    for (const i of gifts) {\\n        q.enqueue(i);\\n    }\\n    \\n    while (k--) {\\n        const val = q.dequeue().element;\\n        const fsqrt = Math.floor(Math.sqrt(val));\\n        q.enqueue(fsqrt);\\n    }\\n    \\n    let sum = 0;\\n   while (!q.isEmpty()) {\\n       sum += q.dequeue().element;\\n   }\\n    \\n    return sum;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3144971,
                "title": "easy-c-solution-using-sorting-100-faster",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nIntuitive: Just read the question carefully and try to visualise the problem with pen and paper.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nSort every time when evaluating the array and go on accordingly.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(k*nlogn)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long pickGifts(vector<int>& gifts, int k) {\\n        int n=gifts.size();\\n        long long count=0;\\n            while(k>0)\\n            {\\n                sort(gifts.begin(),gifts.end());\\n                gifts[n-1]=floor(sqrt(gifts[n-1]));\\n                k--;\\n            }\\n            for(int i=0;i<n;i++)\\n            {\\n                count=count+gifts[i];\\n            }\\n        return count;       \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long pickGifts(vector<int>& gifts, int k) {\\n        int n=gifts.size();\\n        long long count=0;\\n            while(k>0)\\n            {\\n                sort(gifts.begin(),gifts.end());\\n                gifts[n-1]=floor(sqrt(gifts[n-1]));\\n                k--;\\n            }\\n            for(int i=0;i<n;i++)\\n            {\\n                count=count+gifts[i];\\n            }\\n        return count;       \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3143669,
                "title": "python-simple-python-solution-100-faster",
                "content": "# If You like the Solution, Don\\'t Forget To UpVote Me, Please UpVote! \\uD83D\\uDD3C\\uD83D\\uDE4F\\n# Runtime: 155 ms, faster than 100.00% of Python3 online submissions for Take Gifts From the Richest Pile.\\n# Memory Usage: 14 MB, less than 100.00% of Python3 online submissions for Take Gifts From the Richest Pile.\\n\\n![image](https://assets.leetcode.com/users/images/93eaa340-070c-4ff9-9f0d-7db1055268c8_1675570024.3132586.png)\\n\\n\\n\\tclass Solution:\\n\\t\\tdef pickGifts(self, gifts: List[int], k: int) -> int:\\n\\n\\t\\t\\twhile k > 0:\\n\\n\\t\\t\\t\\tmax_pile = max(gifts)\\n\\t\\t\\t\\tindex = gifts.index(max_pile)\\n\\n\\t\\t\\t\\tgifts[index] = int(math.sqrt(max_pile))\\n\\n\\t\\t\\t\\tk = k - 1\\n\\n\\t\\t\\treturn sum(gifts)\\n\\t\\t\\t\\n# Thank You \\uD83E\\uDD73\\u270C\\uD83D\\uDC4D",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "# If You like the Solution, Don\\'t Forget To UpVote Me, Please UpVote! \\uD83D\\uDD3C\\uD83D\\uDE4F\\n# Runtime: 155 ms, faster than 100.00% of Python3 online submissions for Take Gifts From the Richest Pile.\\n# Memory Usage: 14 MB, less than 100.00% of Python3 online submissions for Take Gifts From the Richest Pile.\\n\\n![image](https://assets.leetcode.com/users/images/93eaa340-070c-4ff9-9f0d-7db1055268c8_1675570024.3132586.png)\\n\\n\\n\\tclass Solution:\\n\\t\\tdef pickGifts(self, gifts: List[int], k: int) -> int:\\n\\n\\t\\t\\twhile k > 0:\\n\\n\\t\\t\\t\\tmax_pile = max(gifts)\\n\\t\\t\\t\\tindex = gifts.index(max_pile)\\n\\n\\t\\t\\t\\tgifts[index] = int(math.sqrt(max_pile))\\n\\n\\t\\t\\t\\tk = k - 1\\n\\n\\t\\t\\treturn sum(gifts)\\n\\t\\t\\t\\n# Thank You \\uD83E\\uDD73\\u270C\\uD83D\\uDC4D",
                "codeTag": "Java"
            },
            {
                "id": 3143648,
                "title": "simple-java-solution",
                "content": "\\n\\n# Complexity\\n- Time complexity: O(n  log n) \\n\\n- Space complexity: O(1) \\n\\n# Code\\n```\\nclass Solution {\\n    public long pickGifts(int[] gifts, int k) {\\n        Arrays.sort(gifts);\\n        for(int i=gifts.length-1,j=1;j<=k;j++)\\n        {\\n            if(gifts[i]==1)\\n            {\\n                break;\\n            }\\n            int p=(int)(Math.sqrt(gifts[i]));\\n            gifts[i]=p;\\n            Arrays.sort(gifts);\\n        }\\n        long s=0;\\n        for(int i:gifts)\\n        {\\n            s+=(long)i;\\n        }\\n        return s;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public long pickGifts(int[] gifts, int k) {\\n        Arrays.sort(gifts);\\n        for(int i=gifts.length-1,j=1;j<=k;j++)\\n        {\\n            if(gifts[i]==1)\\n            {\\n                break;\\n            }\\n            int p=(int)(Math.sqrt(gifts[i]));\\n            gifts[i]=p;\\n            Arrays.sort(gifts);\\n        }\\n        long s=0;\\n        for(int i:gifts)\\n        {\\n            s+=(long)i;\\n        }\\n        return s;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3691304,
                "title": "easy-priority-queue",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long pickGifts(vector<int>& gifts, int k) {\\n        priority_queue<int> pq;\\n        int n = gifts.size();\\n\\n        for(int i = 0; i<n; i++)\\n        {\\n            pq.push(gifts[i]);\\n        }\\n        long long sum = 0;\\n        \\n        for(int j = 0; j<k; j++)\\n        {\\n            int temp = pq.top();\\n            pq.push(sqrt(temp));\\n            pq.pop();\\n        }\\n        while(!pq.empty()){\\n            sum+=pq.top();\\n            pq.pop();\\n        }\\n        return sum;\\n    }  \\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long pickGifts(vector<int>& gifts, int k) {\\n        priority_queue<int> pq;\\n        int n = gifts.size();\\n\\n        for(int i = 0; i<n; i++)\\n        {\\n            pq.push(gifts[i]);\\n        }\\n        long long sum = 0;\\n        \\n        for(int j = 0; j<k; j++)\\n        {\\n            int temp = pq.top();\\n            pq.push(sqrt(temp));\\n            pq.pop();\\n        }\\n        while(!pq.empty()){\\n            sum+=pq.top();\\n            pq.pop();\\n        }\\n        return sum;\\n    }  \\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3637358,
                "title": "easy-implementation-using-max-heap-priority-queue",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long pickGifts(vector<int>& gifts, int k) {\\n        priority_queue<int>pq(gifts.begin(), gifts.end());\\n        while(k--){\\n            int temp = pq.top(); pq.pop();\\n            pq.push(sqrt(temp)); \\n        }\\n        long long sum = 0;\\n        while(!pq.empty()){\\n            sum += pq.top(); pq.pop();\\n        }\\n        return sum;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long pickGifts(vector<int>& gifts, int k) {\\n        priority_queue<int>pq(gifts.begin(), gifts.end());\\n        while(k--){\\n            int temp = pq.top(); pq.pop();\\n            pq.push(sqrt(temp)); \\n        }\\n        long long sum = 0;\\n        while(!pq.empty()){\\n            sum += pq.top(); pq.pop();\\n        }\\n        return sum;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3318154,
                "title": "faster-than-100-java-solution",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\n    public long pickGifts(int[] gifts, int k) {\\n        for(int i=1;i<=k;i++)\\n        {\\n            int max = Integer.MIN_VALUE;\\n            for(int j=0;j<gifts.length;j++)\\n            {\\n                max = Math.max(max,gifts[j]);\\n            }\\n            for(int j=0;j<gifts.length;j++)\\n            {\\n                if(gifts[j]==max)\\n                {\\n                    gifts[j] = (int)(Math.sqrt(max));\\n                    break;\\n                }\\n            }\\n        }\\n        long sum=0;\\n        for(int i=0;i<gifts.length;i++)\\n            sum+=gifts[i];\\n        return sum;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public long pickGifts(int[] gifts, int k) {\\n        for(int i=1;i<=k;i++)\\n        {\\n            int max = Integer.MIN_VALUE;\\n            for(int j=0;j<gifts.length;j++)\\n            {\\n                max = Math.max(max,gifts[j]);\\n            }\\n            for(int j=0;j<gifts.length;j++)\\n            {\\n                if(gifts[j]==max)\\n                {\\n                    gifts[j] = (int)(Math.sqrt(max));\\n                    break;\\n                }\\n            }\\n        }\\n        long sum=0;\\n        for(int i=0;i<gifts.length;i++)\\n            sum+=gifts[i];\\n        return sum;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3303777,
                "title": "easy-java-solution-full-explaination-comments-lbeginner-friendly",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n**Take a Priority Queue which stores data in descending order and put all the data inside that. Then as data is stored in descending order the first data which we will get using poll() function of Priority Queue will be the largest. We take the first value caluclate the data using formula Math.floor(Math.sqrt(gifts[i])) and again put it back into the PriorityQueue and will repeat this step kth time and after kth time we just pop out all the data from Priority Queue and calculate its sum and return it.**\\n\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public long pickGifts(int[] gifts, int k) {\\n        //initialize a Priority Queue which stores data in Descending Order\\n        PriorityQueue<Integer> q = new PriorityQueue<>(Comparator.reverseOrder());\\n        //putting all data into the Priority Queue\\n        for(int i = 0 ; i < gifts.length; i ++){\\n            q.add(gifts[i]);\\n        }\\n        //applying the Formula kth time for largest element in the Priority Queue and adding it back \\n        while(k != 0){\\n            int ele = (int)Math.floor(Math.sqrt(q.poll()));\\n            q.add(ele);\\n            k--;\\n        }\\n        //Poping out all the data from the Priority Queue and calculate its sum \\n        long sum = 0;\\n        while(!q.isEmpty()){\\n            int ele = q.poll();\\n            sum += ele;\\n        }\\n        return sum;\\n    }\\n}\\n```\\n**Please UPVOTE if you like it\\nHappy coding**",
                "solutionTags": [
                    "Java",
                    "Math",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\n    public long pickGifts(int[] gifts, int k) {\\n        //initialize a Priority Queue which stores data in Descending Order\\n        PriorityQueue<Integer> q = new PriorityQueue<>(Comparator.reverseOrder());\\n        //putting all data into the Priority Queue\\n        for(int i = 0 ; i < gifts.length; i ++){\\n            q.add(gifts[i]);\\n        }\\n        //applying the Formula kth time for largest element in the Priority Queue and adding it back \\n        while(k != 0){\\n            int ele = (int)Math.floor(Math.sqrt(q.poll()));\\n            q.add(ele);\\n            k--;\\n        }\\n        //Poping out all the data from the Priority Queue and calculate its sum \\n        long sum = 0;\\n        while(!q.isEmpty()){\\n            int ele = q.poll();\\n            sum += ele;\\n        }\\n        return sum;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3224883,
                "title": "priority-queue-based-c-solution-with-comment-5ms",
                "content": "```\\nclass Solution {\\npublic:\\n    long long pickGifts(vector<int>& gifts, int k) {\\n        priority_queue<int> pq;\\n        for(auto &i: gifts)pq.push(i);\\n        while(k--){\\n            int x = pq.top();pq.pop();//remove max element from array to reduce sum of final array\\n            pq.push(sqrt(x));push sqrt of element in array\\n        }\\n        long long int ans = 0;\\n        while(!pq.empty()){\\n            ans += pq.top();\\n            pq.pop();\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Sorting",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long pickGifts(vector<int>& gifts, int k) {\\n        priority_queue<int> pq;\\n        for(auto &i: gifts)pq.push(i);\\n        while(k--){\\n            int x = pq.top();pq.pop();//remove max element from array to reduce sum of final array\\n            pq.push(sqrt(x));push sqrt of element in array\\n        }\\n        long long int ans = 0;\\n        while(!pq.empty()){\\n            ans += pq.top();\\n            pq.pop();\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3146763,
                "title": "java-priority-queue-9-lines-beats-100",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nUse a Priority Queue to sort all elements of the `gifts` array in descending order. Run a loop for `k` iterations, each time removing the largest element and inserting back the floor of the square root of the same. Finally, sum up all the remaining elements in the queue and return the answer.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: $$O(n*log(n))$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n  public long pickGifts(int[] gifts, int k) {\\n    var queue = new PriorityQueue<Integer>(Collections.reverseOrder());\\n    \\n    for (var gift : gifts)\\n      queue.offer(gift);\\n    \\n    while (k-- > 0)\\n      queue.offer((int) Math.sqrt(queue.poll()));\\n    \\n    long ans = 0;\\n    while (!queue.isEmpty())\\n      ans += queue.poll();\\n    \\n    return ans;\\n  }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\n  public long pickGifts(int[] gifts, int k) {\\n    var queue = new PriorityQueue<Integer>(Collections.reverseOrder());\\n    \\n    for (var gift : gifts)\\n      queue.offer(gift);\\n    \\n    while (k-- > 0)\\n      queue.offer((int) Math.sqrt(queue.poll()));\\n    \\n    long ans = 0;\\n    while (!queue.isEmpty())\\n      ans += queue.poll();\\n    \\n    return ans;\\n  }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3144230,
                "title": "priority-queue-easy-peasy-java",
                "content": "```\\nclass Solution {\\n    public long pickGifts(int[] gifts, int k) {\\n        PriorityQueue<Integer> pq = new PriorityQueue<Integer>(Collections.reverseOrder());\\n        for(int i:gifts)\\n        {\\n            pq.add(i);\\n        }\\n        while(!pq.isEmpty() && k>0)\\n        {\\n            int num = pq.poll();\\n            double cum = Math.sqrt(num);\\n            num = (int)Math.floor(cum);\\n            pq.add(num);\\n            k--;\\n        }\\n        long sum=0;\\n        while(!pq.isEmpty())\\n        {\\n            sum+=pq.poll();\\n        }\\n        return sum;\\n    }\\n}",
                "solutionTags": [
                    "Java",
                    "Math",
                    "Heap (Priority Queue)"
                ],
                "code": "class Solution {\\n    public long pickGifts(int[] gifts, int k) {\\n        PriorityQueue<Integer> pq = new PriorityQueue<Integer>(Collections.reverseOrder());\\n        for(int i:gifts)\\n        {\\n            pq.add(i);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 3144223,
                "title": "beats-100-simplest-c-self-understandable-code",
                "content": "\\n\\n# Complexity\\n- Time complexity: O(n^2)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n- please upvote if you like the solution\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long pickGifts(vector<int>& gifts, int k) {\\n        while (k > 0 && gifts.size() > 0) {\\n            int max_gift = gifts[0];\\n            int max_gift_index = 0;\\n            for (int i = 1; i < gifts.size(); i++) {\\n                if (gifts[i] > max_gift) {\\n                    max_gift = gifts[i];\\n                    max_gift_index = i;\\n                }\\n            }\\n            gifts[max_gift_index] = floor(sqrt(gifts[max_gift_index]));\\n            k--;\\n        }\\n        long long result = 0;\\n        for (int i = 0; i < gifts.size(); i++) {\\n            result += gifts[i];\\n        }\\n        return result;\\n    }\\n};\\n\\n\\n\\n\\n\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long pickGifts(vector<int>& gifts, int k) {\\n        while (k > 0 && gifts.size() > 0) {\\n            int max_gift = gifts[0];\\n            int max_gift_index = 0;\\n            for (int i = 1; i < gifts.size(); i++) {\\n                if (gifts[i] > max_gift) {\\n                    max_gift = gifts[i];\\n                    max_gift_index = i;\\n                }\\n            }\\n            gifts[max_gift_index] = floor(sqrt(gifts[max_gift_index]));\\n            k--;\\n        }\\n        long long result = 0;\\n        for (int i = 0; i < gifts.size(); i++) {\\n            result += gifts[i];\\n        }\\n        return result;\\n    }\\n};\\n\\n\\n\\n\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3144106,
                "title": "2-easy-solutions-explained-step-by-step-100",
                "content": "# Intuition\\n*Two approaches that readily come to mind are:*\\n1. Brute force: `Arrays.sort()` before every operation\\n2. **Priority Queue** (Reverse Order)\\n\\n# Approach 1\\nUsing **Priority Queue**\\n\\n## Code \\n```\\nclass Solution {\\n    public long pickGifts(int[] gifts, int k) {\\n        int l = gifts.length;\\n        PriorityQueue<Integer> pq = new PriorityQueue<Integer>((a, b) -> b - a);\\n        for(int i:gifts)                   // Adding the elements to pq\\n            pq.add(i);\\n        \\n        for(int i=1; i<=k; i++)\\n        {\\n            int temp = pq.poll();         //Fetching the max element\\n            int n = (int)Math.sqrt(temp);\\n            pq.add(n);\\n        }\\n\\n        long sum=0;\\n        for(int i:pq)                     // Iterate over the elements\\n        {                                 // of pq and add to sum\\n            sum+=i;\\n        }\\n        return sum;\\n    }\\n}\\n```\\n>![image.png](https://assets.leetcode.com/users/images/acb47d7d-a61f-4e44-a81a-c2390401a1e5_1675573037.8374379.png)\\n# Approach 2\\n **Brute Force** approach : Using **Sorting**\\n\\n## Code  \\n```\\nclass Solution {\\n    public long pickGifts(int[] gifts, int k) {\\n        int l = gifts.length;\\n        for(int i=1; i<=k; i++)\\n        {\\n            Arrays.sort(gifts);                      // Sort before each operation\\n            gifts[l-1]=(int)Math.sqrt(gifts[l-1]);   //Operation on max element\\n        }\\n        long sum=0;\\n        for(int i:gifts)                  // Iterate over the elements    \\n        {                                 // of pq and add to sum\\n            sum+=i;\\n        }\\n        return sum;\\n    }\\n}\\n```\\n>![image.png](https://assets.leetcode.com/users/images/29bf72e9-e943-405d-ae73-af4bfe886249_1675572967.258324.png)\\n\\n**Hope it helps \\u2764\\uFE0F\\u2764\\uFE0F**\\n*Please do **Upvote** if you find it useful.*\\n*Also if you have any suggestion or query do comment.*\\n***Thank you.***\\n",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Greedy",
                    "Sort",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\n    public long pickGifts(int[] gifts, int k) {\\n        int l = gifts.length;\\n        PriorityQueue<Integer> pq = new PriorityQueue<Integer>((a, b) -> b - a);\\n        for(int i:gifts)                   // Adding the elements to pq\\n            pq.add(i);\\n        \\n        for(int i=1; i<=k; i++)\\n        {\\n            int temp = pq.poll();         //Fetching the max element\\n            int n = (int)Math.sqrt(temp);\\n            pq.add(n);\\n        }\\n\\n        long sum=0;\\n        for(int i:pq)                     // Iterate over the elements\\n        {                                 // of pq and add to sum\\n            sum+=i;\\n        }\\n        return sum;\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public long pickGifts(int[] gifts, int k) {\\n        int l = gifts.length;\\n        for(int i=1; i<=k; i++)\\n        {\\n            Arrays.sort(gifts);                      // Sort before each operation\\n            gifts[l-1]=(int)Math.sqrt(gifts[l-1]);   //Operation on max element\\n        }\\n        long sum=0;\\n        for(int i:gifts)                  // Iterate over the elements    \\n        {                                 // of pq and add to sum\\n            sum+=i;\\n        }\\n        return sum;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3143859,
                "title": "java-solution-with-comments-only-loop-and-sqrt-method-1005-faster",
                "content": "\\n\\n# Code\\n```\\n \\n     class Solution {\\n    public long pickGifts(int[] gifts, int k) {\\n        Arrays.sort(gifts);\\n        int n=gifts.length;\\n        // loop to iterate backwards in gifts array \\n        for(int i=n-1,j=1;j<=k;j++)\\n        {\\n            // checking whether thers\\'s single gift or not if yes we will break the loop \\n            if(gifts[i]==1)\\n            {\\n                break;\\n            }\\n            // typecasting to int to avoid double or any error related to this \\n            int p=(int)(Math.sqrt(gifts[i]));\\n            // stored p in ith index of gifts array \\n            gifts[i]=p;\\n            // again sorted for upcoming loop work \\n            Arrays.sort(gifts);\\n        }\\n        // crating an answer variable s of long to avoid incompatible types \\n        long s=0;\\n        // simple for-each loop \\n        for(int i:gifts)\\n        {\\n            s+=(long)i;\\n        }\\n        return s;\\n    }\\n}\\n\\n\\n// if you find it useful please upvote \\n \\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n \\n     class Solution {\\n    public long pickGifts(int[] gifts, int k) {\\n        Arrays.sort(gifts);\\n        int n=gifts.length;\\n        // loop to iterate backwards in gifts array \\n        for(int i=n-1,j=1;j<=k;j++)\\n        {\\n            // checking whether thers\\'s single gift or not if yes we will break the loop \\n            if(gifts[i]==1)\\n            {\\n                break;\\n            }\\n            // typecasting to int to avoid double or any error related to this \\n            int p=(int)(Math.sqrt(gifts[i]));\\n            // stored p in ith index of gifts array \\n            gifts[i]=p;\\n            // again sorted for upcoming loop work \\n            Arrays.sort(gifts);\\n        }\\n        // crating an answer variable s of long to avoid incompatible types \\n        long s=0;\\n        // simple for-each loop \\n        for(int i:gifts)\\n        {\\n            s+=(long)i;\\n        }\\n        return s;\\n    }\\n}\\n\\n\\n// if you find it useful please upvote \\n \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3143643,
                "title": "c-easy-and-simple-solution-using-max-heap",
                "content": "\\n***Guy\\'s if you find this solution helpful \\uD83D\\uDE0A, PLEASE do UPVOTE. By doing that it motivate\\'s me to create more better post like this \\u270D\\uFE0F***\\n# Complexity\\n- Time complexity:\\nO(NLogN)\\n\\n- Space complexity:\\nO(N)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long pickGifts(vector<int>& gifts, int k) {\\n        priority_queue<int>pq;\\n        for(auto i : gifts){\\n            pq.push(i);\\n        }\\n        \\n        \\n        while(!pq.empty() && k>0){\\n           \\n            int top=pq.top();\\n            \\n            pq.pop();\\n            k--;\\n            pq.push(sqrt(top));\\n        }\\n        long long sum=0;\\n        while(!pq.empty()){\\n            sum+=pq.top();\\n            pq.pop();\\n        }\\n        return sum;\\n    }\\n};\\n```\\n***Guy\\'s if you find this solution helpful \\uD83D\\uDE0A, PLEASE do UPVOTE. By doing that it motivate\\'s me to create more better post like this \\u270D\\uFE0F***",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long pickGifts(vector<int>& gifts, int k) {\\n        priority_queue<int>pq;\\n        for(auto i : gifts){\\n            pq.push(i);\\n        }\\n        \\n        \\n        while(!pq.empty() && k>0){\\n           \\n            int top=pq.top();\\n            \\n            pq.pop();\\n            k--;\\n            pq.push(sqrt(top));\\n        }\\n        long long sum=0;\\n        while(!pq.empty()){\\n            sum+=pq.top();\\n            pq.pop();\\n        }\\n        return sum;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4062410,
                "title": "optimized-solution-using-pq",
                "content": "# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n    O(n log n)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n    O(n)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long pickGifts(vector<int>& gifts, int k) {\\n        int n = gifts.size();\\n\\n        priority_queue<pair<int,int>> maxHeap;\\n\\n        for(int i=0;i<n;i++) {\\n            maxHeap.push({gifts[i],i});\\n        }\\n\\n        for(int i=0;i<k;i++) {\\n            auto it = maxHeap.top();\\n            int currVal = it.first;\\n            int index = it.second;\\n\\n            int newVal = sqrt(currVal);\\n\\n            maxHeap.pop();\\n\\n            gifts[index] = newVal;\\n\\n            maxHeap.push({newVal,index});\\n        }\\n\\n        long long sum = 0;\\n\\n        for(int i=0;i<n;i++) {\\n            sum += gifts[i];\\n        }\\n\\n        return sum;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long pickGifts(vector<int>& gifts, int k) {\\n        int n = gifts.size();\\n\\n        priority_queue<pair<int,int>> maxHeap;\\n\\n        for(int i=0;i<n;i++) {\\n            maxHeap.push({gifts[i],i});\\n        }\\n\\n        for(int i=0;i<k;i++) {\\n            auto it = maxHeap.top();\\n            int currVal = it.first;\\n            int index = it.second;\\n\\n            int newVal = sqrt(currVal);\\n\\n            maxHeap.pop();\\n\\n            gifts[index] = newVal;\\n\\n            maxHeap.push({newVal,index});\\n        }\\n\\n        long long sum = 0;\\n\\n        for(int i=0;i<n;i++) {\\n            sum += gifts[i];\\n        }\\n\\n        return sum;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3691319,
                "title": "priority-queue-easy",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long pickGifts(vector<int>& gifts, int k) {\\n        priority_queue<int> pq;\\n        int n = gifts.size();\\n\\n        for(int i = 0; i<n; i++)\\n        {\\n            pq.push(gifts[i]);\\n        }\\n        long long sum = 0;\\n        \\n        for(int j = 0; j<k; j++)\\n        {\\n            int temp = pq.top();\\n            pq.push(sqrt(temp));\\n            pq.pop();\\n        }\\n        while(!pq.empty()){\\n            sum+=pq.top();\\n            pq.pop();\\n        }\\n        return sum;\\n    }  \\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long pickGifts(vector<int>& gifts, int k) {\\n        priority_queue<int> pq;\\n        int n = gifts.size();\\n\\n        for(int i = 0; i<n; i++)\\n        {\\n            pq.push(gifts[i]);\\n        }\\n        long long sum = 0;\\n        \\n        for(int j = 0; j<k; j++)\\n        {\\n            int temp = pq.top();\\n            pq.push(sqrt(temp));\\n            pq.pop();\\n        }\\n        while(!pq.empty()){\\n            sum+=pq.top();\\n            pq.pop();\\n        }\\n        return sum;\\n    }  \\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3690425,
                "title": "golang-maxheap-fix-100",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\nUsing a heap we always have a sorted array. In this case we always want the max, so we choose h[i] > h[j]. We always take the max, which is the first element, and replace it with the sqrt of itself. Afterwards we fix the heap by calling fix, which is less expensive than a pop followed by a push. We do this k times. Afterwards our array is in the desired state and we can sum all the element in the array to get the desired result. \\n\\n# Code\\n```\\ntype MaxIntHeap []int\\n\\nfunc (h MaxIntHeap) Len() int { return len (h) }\\nfunc (h MaxIntHeap) Less(i, j int) bool { return h[i] > h[j] }\\nfunc (h MaxIntHeap) Swap(i, j int) { h[i], h[j] = h[j], h[i] }\\n\\nfunc (h *MaxIntHeap) Pop() any {\\n    lastIdx := len(*h) - 1\\n    ele := (*h)[lastIdx]\\n    *h = (*h)[:lastIdx]\\n    return ele\\n}\\n\\nfunc (h *MaxIntHeap) Push(x any) {\\n    *h = append(*h, x.(int))\\n}\\n\\nfunc pickGifts(gifts []int, k int) int64 {\\n    giftHeap := MaxIntHeap(gifts)\\n    heap.Init(&giftHeap)\\n    for k > 0 {\\n        giftHeap[0] = int(math.Sqrt(float64(giftHeap[0])))\\n        heap.Fix(&giftHeap, 0)\\n        k--\\n    }\\n\\n    sum := 0\\n    for _, val := range giftHeap {\\n        sum += val\\n    }\\n\\n    return int64(sum)\\n}\\n```",
                "solutionTags": [
                    "Go",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\ntype MaxIntHeap []int\\n\\nfunc (h MaxIntHeap) Len() int { return len (h) }\\nfunc (h MaxIntHeap) Less(i, j int) bool { return h[i] > h[j] }\\nfunc (h MaxIntHeap) Swap(i, j int) { h[i], h[j] = h[j], h[i] }\\n\\nfunc (h *MaxIntHeap) Pop() any {\\n    lastIdx := len(*h) - 1\\n    ele := (*h)[lastIdx]\\n    *h = (*h)[:lastIdx]\\n    return ele\\n}\\n\\nfunc (h *MaxIntHeap) Push(x any) {\\n    *h = append(*h, x.(int))\\n}\\n\\nfunc pickGifts(gifts []int, k int) int64 {\\n    giftHeap := MaxIntHeap(gifts)\\n    heap.Init(&giftHeap)\\n    for k > 0 {\\n        giftHeap[0] = int(math.Sqrt(float64(giftHeap[0])))\\n        heap.Fix(&giftHeap, 0)\\n        k--\\n    }\\n\\n    sum := 0\\n    for _, val := range giftHeap {\\n        sum += val\\n    }\\n\\n    return int64(sum)\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3667932,
                "title": "please-upvote",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long pickGifts(vector<int>& gifts, int k) {\\n        priority_queue<int> a;\\n        for(int i=0;i<gifts.size();i++){\\n            a.push(gifts[i]);\\n        }  \\n        long long ans=0;\\n        while(k--){\\n            int temp = sqrt(a.top());\\n            a.pop();\\n            a.push(temp);\\n        }\\n        while(!a.empty()){\\n            ans+=a.top();\\n            a.pop();\\n        }\\n        return ans;\\n    }\\n    \\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long pickGifts(vector<int>& gifts, int k) {\\n        priority_queue<int> a;\\n        for(int i=0;i<gifts.size();i++){\\n            a.push(gifts[i]);\\n        }  \\n        long long ans=0;\\n        while(k--){\\n            int temp = sqrt(a.top());\\n            a.pop();\\n            a.push(temp);\\n        }\\n        while(!a.empty()){\\n            ans+=a.top();\\n            a.pop();\\n        }\\n        return ans;\\n    }\\n    \\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3577312,
                "title": "easy-approach-sets-c-beats-75-o-n-o-n",
                "content": "# Intuition\\nKeep sorting and keep calculating the square root of bigger element till k iterations\\n\\n# Approach\\nTake a multisets\\nFill sets with the vector values\\nKeep finding the sqrt of the bigger element and replacing it into sets\\nFinaly take a sum after k rounds\\nReturnt he final sum\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(n)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long pickGifts(vector<int>& gifts, int k) {\\n        multiset<int,std::greater<int>> sets;\\n        for(auto var:gifts)            sets.insert(var);\\n        while(k)\\n        {\\n            int temp = sqrt(*sets.begin());\\n            sets.erase(sets.begin());\\n            sets.insert(temp);\\n            k--;\\n        }\\n        long long int res = 0;\\n        for(auto var:sets) res += var;\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long pickGifts(vector<int>& gifts, int k) {\\n        multiset<int,std::greater<int>> sets;\\n        for(auto var:gifts)            sets.insert(var);\\n        while(k)\\n        {\\n            int temp = sqrt(*sets.begin());\\n            sets.erase(sets.begin());\\n            sets.insert(temp);\\n            k--;\\n        }\\n        long long int res = 0;\\n        for(auto var:sets) res += var;\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3422405,
                "title": "easy-cpp-code",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long pickGifts(vector<int>& gifts, int k) {\\n        long long ans=0;\\n        int n=gifts.size()-1;\\n        while(k>0){\\n            sort(gifts.begin(),gifts.end());\\n            gifts[n]=sqrt(gifts[n]);\\n            k--;\\n        }\\n        for(int i=0;i<=n;i++){\\n            ans+=gifts[i];\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long pickGifts(vector<int>& gifts, int k) {\\n        long long ans=0;\\n        int n=gifts.size()-1;\\n        while(k>0){\\n            sort(gifts.begin(),gifts.end());\\n            gifts[n]=sqrt(gifts[n]);\\n            k--;\\n        }\\n        for(int i=0;i<=n;i++){\\n            ans+=gifts[i];\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3418221,
                "title": "java-using-priorityqueue",
                "content": "# Code\\n```\\nclass Solution {\\n    public long pickGifts(int[] gifts, int k) {\\n        PriorityQueue<Integer> pq = new PriorityQueue<>(Comparator.reverseOrder());\\n        for (int n : gifts) pq.offer(n);\\n        int count = 0;\\n        while (count++ < k) pq.offer((int) Math.sqrt(pq.poll()));\\n        long sum = 0;\\n        while (!pq.isEmpty()) sum += pq.poll();\\n        return sum;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public long pickGifts(int[] gifts, int k) {\\n        PriorityQueue<Integer> pq = new PriorityQueue<>(Comparator.reverseOrder());\\n        for (int n : gifts) pq.offer(n);\\n        int count = 0;\\n        while (count++ < k) pq.offer((int) Math.sqrt(pq.poll()));\\n        long sum = 0;\\n        while (!pq.isEmpty()) sum += pq.poll();\\n        return sum;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3386844,
                "title": "easy-c-solution-using-priority-queue",
                "content": "# Intuition\\n sort the priority queue.\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nuse sqrt() to get the root and then return the sum of priority queue.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long pickGifts(vector<int>& gifts, int k) {\\n           priority_queue<int> pq(gifts.begin(),gifts.end());\\n           while(k>0){\\n            int y=pq.top();\\n            pq.pop();\\n            y = sqrt(y);\\n            pq.push(y);\\n            k--;\\n           }\\n            long long  sum=0;\\n            while (!pq.empty()) {\\n        sum = sum + pq.top();\\n        pq.pop();\\n    }\\n            \\n        \\n        return sum;\\n    }\\n    };\\n   \\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long pickGifts(vector<int>& gifts, int k) {\\n           priority_queue<int> pq(gifts.begin(),gifts.end());\\n           while(k>0){\\n            int y=pq.top();\\n            pq.pop();\\n            y = sqrt(y);\\n            pq.push(y);\\n            k--;\\n           }\\n            long long  sum=0;\\n            while (!pq.empty()) {\\n        sum = sum + pq.top();\\n        pq.pop();\\n    }\\n            \\n        \\n        return sum;\\n    }\\n    };\\n   \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3380466,
                "title": "very-easy-c-solution-easily-readable",
                "content": "# Complexity\\n- Time complexity:O(nlogn)\\n\\n\\n- Space complexity: O(N)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long pickGifts(vector<int>& gifts, int k) {\\n        \\n        priority_queue<long long>pq;\\n\\n        for(int i = 0 ; i < gifts.size() ; i++){\\n            pq.push(gifts[i]);\\n        }\\n        long long ans = 0;\\n        while(k--){   \\n            int temp = sqrt(pq.top());\\n            pq.pop();\\n            pq.push(temp);\\n        }\\n        while(!pq.empty()){\\n            ans += pq.top();\\n            pq.pop();\\n        }\\n\\n        return ans;\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long pickGifts(vector<int>& gifts, int k) {\\n        \\n        priority_queue<long long>pq;\\n\\n        for(int i = 0 ; i < gifts.size() ; i++){\\n            pq.push(gifts[i]);\\n        }\\n        long long ans = 0;\\n        while(k--){   \\n            int temp = sqrt(pq.top());\\n            pq.pop();\\n            pq.push(temp);\\n        }\\n        while(!pq.empty()){\\n            ans += pq.top();\\n            pq.pop();\\n        }\\n\\n        return ans;\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3357066,
                "title": "take-gifts-from-the-richest-pile-solution-in-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n^2)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1)\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long pickGifts(vector<int>& gifts, int k) {\\n        int i;\\n        long long int count=0;\\n        while(k--)\\n        {\\n            sort(gifts.begin(), gifts.end());\\n            gifts[gifts.size()-1] = sqrt(gifts[gifts.size()-1]);\\n        }\\n        for(i=0 ; i<gifts.size() ; i++)\\n        {\\n            count += gifts[i];\\n        }\\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long pickGifts(vector<int>& gifts, int k) {\\n        int i;\\n        long long int count=0;\\n        while(k--)\\n        {\\n            sort(gifts.begin(), gifts.end());\\n            gifts[gifts.size()-1] = sqrt(gifts[gifts.size()-1]);\\n        }\\n        for(i=0 ; i<gifts.size() ; i++)\\n        {\\n            count += gifts[i];\\n        }\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3315702,
                "title": "5-lines-simplest-code-you-ever-found-python3",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n#heap approach\\nclass Solution:\\n    def pickGifts(self, gifts: List[int], k: int) -> int:\\n        list1 = [-x for x in gifts]\\n        heapq.heapify(list1)\\n        for i in range(k):\\n            x = -heapq.heappop(list1)\\n            heapq.heappush(list1,-int(math.sqrt(x)))\\n        return abs(sum(list1)\\n```\\n```\\n#normal approach\\nclass Solution:\\n    def pickGifts(self, gifts: List[int], k: int) -> int:\\n        for i in range(k):\\n            x=max(gifts)\\n            gifts.remove(x)\\n            gifts.append(int(sqrt(x)))\\n        return sum(gifts)\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\n#heap approach\\nclass Solution:\\n    def pickGifts(self, gifts: List[int], k: int) -> int:\\n        list1 = [-x for x in gifts]\\n        heapq.heapify(list1)\\n        for i in range(k):\\n            x = -heapq.heappop(list1)\\n            heapq.heappush(list1,-int(math.sqrt(x)))\\n        return abs(sum(list1)\\n```\n```\\n#normal approach\\nclass Solution:\\n    def pickGifts(self, gifts: List[int], k: int) -> int:\\n        for i in range(k):\\n            x=max(gifts)\\n            gifts.remove(x)\\n            gifts.append(int(sqrt(x)))\\n        return sum(gifts)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3263519,
                "title": "java-solution-no-extra-space-o-n",
                "content": "**Bold**# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public long pickGifts(int[] gifts, int k) {\\n        int l=gifts.length-1;\\n        Arrays.sort(gifts);\\n        while(k-->0){\\n          int n=gifts[l];\\n          n=(int)Math.floor(Math.sqrt(n));\\n          gifts[l]=n;\\n          Arrays.sort(gifts);\\n        }\\n        long sum=0;\\n        for(int i=0;i<gifts.length;i++){\\n            sum+=gifts[i];\\n        }\\n        return sum;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public long pickGifts(int[] gifts, int k) {\\n        int l=gifts.length-1;\\n        Arrays.sort(gifts);\\n        while(k-->0){\\n          int n=gifts[l];\\n          n=(int)Math.floor(Math.sqrt(n));\\n          gifts[l]=n;\\n          Arrays.sort(gifts);\\n        }\\n        long sum=0;\\n        for(int i=0;i<gifts.length;i++){\\n            sum+=gifts[i];\\n        }\\n        return sum;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3221040,
                "title": "easy-javascript-solution-short-simple",
                "content": "\\n\\n# Code\\n```\\n/**\\n * @param {number[]} gifts\\n * @param {number} k\\n * @return {number}\\n */\\nvar pickGifts = function(gifts, k) {\\n    while(k-->0){\\n        let max=Math.max(...gifts)\\n        gifts[gifts.lastIndexOf(max)]=Math.floor(Math.sqrt(max))\\n    }\\n    return gifts.reduce((a,b)=>a+b,0)\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} gifts\\n * @param {number} k\\n * @return {number}\\n */\\nvar pickGifts = function(gifts, k) {\\n    while(k-->0){\\n        let max=Math.max(...gifts)\\n        gifts[gifts.lastIndexOf(max)]=Math.floor(Math.sqrt(max))\\n    }\\n    return gifts.reduce((a,b)=>a+b,0)\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3174926,
                "title": "priority-queue-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long pickGifts(vector<int>& gifts, int k) {\\n      long long ans=0;\\n      priority_queue<int> pq;\\n      for(auto i: gifts){\\n          pq.push(i);\\n      }\\n\\n      while(k--&&!pq.empty()){\\n          int t=pq.top();\\n          pq.pop();\\n          pq.push(floor(sqrt(t)));\\n      }\\n      while(!pq.empty()){\\n          int p=pq.top();\\n          ans=ans+p;\\n          pq.pop();\\n      }\\n      return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long pickGifts(vector<int>& gifts, int k) {\\n      long long ans=0;\\n      priority_queue<int> pq;\\n      for(auto i: gifts){\\n          pq.push(i);\\n      }\\n\\n      while(k--&&!pq.empty()){\\n          int t=pq.top();\\n          pq.pop();\\n          pq.push(floor(sqrt(t)));\\n      }\\n      while(!pq.empty()){\\n          int p=pq.top();\\n          ans=ans+p;\\n          pq.pop();\\n      }\\n      return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3163701,
                "title": "solution-with-one-sorting-and-insertion-method-with-description",
                "content": "# Code\\n```\\n/**\\n * @param {number[]} gifts\\n * @param {number} k\\n * @return {number}\\n */\\nvar pickGifts = function(gifts, k) {\\n    // sort array in descending way => [100, 64, 25, 9, 4]\\n    gifts.sort((n1, n2) => n2 - n1);\\n\\n    // loop for k iterations\\n    for (let step = 0; step < k; step++) {\\n        // every time change only 0-index element\\n        gifts[0] = Math.floor(Math.sqrt(gifts[0]));\\n\\n        // then move 0-index element to new position in order to preserve sorted array\\n        // it\\'s better than sorting again (O(N) instead of O(NlogN))\\n        let i = 0;\\n        while (gifts[i] < gifts[i + 1]) {\\n            [gifts[i], gifts[i + 1]] = [gifts[i + 1], gifts[i]];\\n            i++;\\n        }\\n    }\\n\\n    // return the sum of all elements\\n    return gifts.reduce((sum, n) => sum + n, 0);\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} gifts\\n * @param {number} k\\n * @return {number}\\n */\\nvar pickGifts = function(gifts, k) {\\n    // sort array in descending way => [100, 64, 25, 9, 4]\\n    gifts.sort((n1, n2) => n2 - n1);\\n\\n    // loop for k iterations\\n    for (let step = 0; step < k; step++) {\\n        // every time change only 0-index element\\n        gifts[0] = Math.floor(Math.sqrt(gifts[0]));\\n\\n        // then move 0-index element to new position in order to preserve sorted array\\n        // it\\'s better than sorting again (O(N) instead of O(NlogN))\\n        let i = 0;\\n        while (gifts[i] < gifts[i + 1]) {\\n            [gifts[i], gifts[i + 1]] = [gifts[i + 1], gifts[i]];\\n            i++;\\n        }\\n    }\\n\\n    // return the sum of all elements\\n    return gifts.reduce((sum, n) => sum + n, 0);\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3160369,
                "title": "easy-python-max-heap-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:   O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def pickGifts(self, gifts: List[int], k: int) -> int:\\n        heap=[]\\n        for i in range(len(gifts)):\\n            heapq.heappush(heap,-gifts[i])\\n        for i in range(k):\\n            n=-(heapq.heappop(heap))\\n            sq=math.sqrt(n)\\n            heapq.heappush(heap,-int(sq))\\n        c=sum(heap)\\n        return -1*c\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def pickGifts(self, gifts: List[int], k: int) -> int:\\n        heap=[]\\n        for i in range(len(gifts)):\\n            heapq.heappush(heap,-gifts[i])\\n        for i in range(k):\\n            n=-(heapq.heappop(heap))\\n            sq=math.sqrt(n)\\n            heapq.heappush(heap,-int(sq))\\n        c=sum(heap)\\n        return -1*c\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3154144,
                "title": "short-and-clean-beginner-friendly-java-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public long pickGifts(int[] nums, int k) {\\n        for(int i=0; i<k; i++){\\n            int maxIndex=0;\\n            for(int j=1; j<nums.length; j++){\\n                if(nums[j]>nums[maxIndex])\\n                    maxIndex=j;\\n            }\\n            nums[maxIndex]=(int)Math.floor(Math.sqrt(nums[maxIndex]));\\n        }\\n        long sum=0; \\n        for(int i=0; i<nums.length; i++){\\n            sum+=nums[i];\\n        }\\n        return sum;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array"
                ],
                "code": "```\\nclass Solution {\\n    public long pickGifts(int[] nums, int k) {\\n        for(int i=0; i<k; i++){\\n            int maxIndex=0;\\n            for(int j=1; j<nums.length; j++){\\n                if(nums[j]>nums[maxIndex])\\n                    maxIndex=j;\\n            }\\n            nums[maxIndex]=(int)Math.floor(Math.sqrt(nums[maxIndex]));\\n        }\\n        long sum=0; \\n        for(int i=0; i<nums.length; i++){\\n            sum+=nums[i];\\n        }\\n        return sum;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3151144,
                "title": "c-beats-100-priority-queue-simple-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nMaintain priority queue (MAX-HEAP) for gifts.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nIn each operation dequeue top element which will be maximum element then enqueue Floor(SQRT) of this dequeued element. After completing all K operations get sum of all elements in the priority queue. \\n# Complexity\\n- Time complexity: O(Klog(n)); n is no. of gifts\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n); n is no. of gifts\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\npublic class Solution {\\n    public long PickGifts(int[] gifts, int k)\\n    {\\n        long ans = 0;\\n        PriorityQueue<int,int> pq = new PriorityQueue<int,int>(Comparer<int>.Create((x,y)=>y-x));\\n        for(int i=0;i<gifts.Length;i++)\\n            pq.Enqueue(i,gifts[i]);\\n        while(k>0)\\n        {\\n            if(pq.TryDequeue(out int element, out int priority))\\n            {\\n                pq.Enqueue(element,Convert.ToInt32(Math.Floor(Math.Sqrt(priority))));\\n            }\\n            k--;\\n        }\\n        while(pq.Count>0)\\n        {\\n            if(pq.TryDequeue(out int element, out int priority))\\n                ans += priority;\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution {\\n    public long PickGifts(int[] gifts, int k)\\n    {\\n        long ans = 0;\\n        PriorityQueue<int,int> pq = new PriorityQueue<int,int>(Comparer<int>.Create((x,y)=>y-x));\\n        for(int i=0;i<gifts.Length;i++)\\n            pq.Enqueue(i,gifts[i]);\\n        while(k>0)\\n        {\\n            if(pq.TryDequeue(out int element, out int priority))\\n            {\\n                pq.Enqueue(element,Convert.ToInt32(Math.Floor(Math.Sqrt(priority))));\\n            }\\n            k--;\\n        }\\n        while(pq.Count>0)\\n        {\\n            if(pq.TryDequeue(out int element, out int priority))\\n                ans += priority;\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3150173,
                "title": "a-simple-solution-with-stl-functions-c",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long pickGifts(vector<int>& gifts, int k) {\\n        long long sum = 0;\\n        long long temp = 0;\\n        int j = 0;\\n        for(int i=0;i<k;i++){\\n            // Function to find the highest element in the array\\n            temp = *max_element(gifts.begin(),gifts.end());\\n            // The below function is to locate the max element\\n            j = max_element(gifts.begin(),gifts.end()) - gifts.begin();\\n            temp = sqrt(temp);\\n            cout << j << endl;\\n            // Replace the highest gift at its index\\n            gifts[j] = temp;\\n        }\\n\\n        // Add the remaining gifts\\n        for(int i=0;i<gifts.size();i++){\\n            sum += gifts[i];\\n        }   \\n\\n        return sum;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long pickGifts(vector<int>& gifts, int k) {\\n        long long sum = 0;\\n        long long temp = 0;\\n        int j = 0;\\n        for(int i=0;i<k;i++){\\n            // Function to find the highest element in the array\\n            temp = *max_element(gifts.begin(),gifts.end());\\n            // The below function is to locate the max element\\n            j = max_element(gifts.begin(),gifts.end()) - gifts.begin();\\n            temp = sqrt(temp);\\n            cout << j << endl;\\n            // Replace the highest gift at its index\\n            gifts[j] = temp;\\n        }\\n\\n        // Add the remaining gifts\\n        for(int i=0;i<gifts.size();i++){\\n            sum += gifts[i];\\n        }   \\n\\n        return sum;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3148372,
                "title": "easy-js-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {number[]} gifts\\n * @param {number} k\\n * @return {number}\\n */\\nvar pickGifts = function(gifts, k) {\\n    let n = gifts.length;\\n   for(let i=0; i<k; i++){\\n       gifts = gifts.sort((a,b)=>b-a);\\n       gifts[0] =Math.floor(Math.sqrt(gifts[0])) \\n   } \\n   let sum = 0;\\n   for(let x of gifts){\\n       sum+=x;\\n   }\\n   return sum;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} gifts\\n * @param {number} k\\n * @return {number}\\n */\\nvar pickGifts = function(gifts, k) {\\n    let n = gifts.length;\\n   for(let i=0; i<k; i++){\\n       gifts = gifts.sort((a,b)=>b-a);\\n       gifts[0] =Math.floor(Math.sqrt(gifts[0])) \\n   } \\n   let sum = 0;\\n   for(let x of gifts){\\n       sum+=x;\\n   }\\n   return sum;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3148008,
                "title": "priority-queue-just-3-steps",
                "content": "Concept:-\\nevery second we need to take the maximum element(Step-2) and push the floor of the square root of the number therfore priority queue will help us the best . At last return the sum of the elements remaining in the queue after K seconds (Step-3).\\n\\n```\\nclass Solution {\\npublic:\\n    long long pickGifts(vector<int>& gifts, int k) {\\n        //priority queue - max heap\\n        priority_queue<long long>pq;\\n        \\n        //step 1 - push all elements\\n        for(int i=0; i<gifts.size(); i++){\\n            pq.push(gifts[i]);\\n        }\\n        \\n        // step 2\\n        // extract the max pile and push the floor of the square root\\n        while(k !=0){\\n            long long top = pq.top();\\n            pq.pop();\\n            pq.push(floor(sqrt(top)));\\n            k--;\\n        }\\n        // step 3\\n        // add up the remaining elements in the queue\\n        long long ans =0;\\n        while(!pq.empty()){\\n            ans += pq.top();\\n            pq.pop();\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long pickGifts(vector<int>& gifts, int k) {\\n        //priority queue - max heap\\n        priority_queue<long long>pq;\\n        \\n        //step 1 - push all elements\\n        for(int i=0; i<gifts.size(); i++){\\n            pq.push(gifts[i]);\\n        }\\n        \\n        // step 2\\n        // extract the max pile and push the floor of the square root\\n        while(k !=0){\\n            long long top = pq.top();\\n            pq.pop();\\n            pq.push(floor(sqrt(top)));\\n            k--;\\n        }\\n        // step 3\\n        // add up the remaining elements in the queue\\n        long long ans =0;\\n        while(!pq.empty()){\\n            ans += pq.top();\\n            pq.pop();\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3146278,
                "title": "rust-solution-using-priority-queue",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nuse std::collections::BinaryHeap;\\n\\nimpl Solution {\\n    pub fn pick_gifts(gifts: Vec<i32>, k: i32) -> i64 {\\n        let mut k = k;\\n        let mut pq = BinaryHeap::from(gifts);\\n\\n        while let Some(v) = pq.pop() {\\n            let x = f64::sqrt(v as f64 + 0.5) as i32;\\n            pq.push(x);\\n            k -= 1;\\n            if k == 0 { break }\\n        }\\n        \\n        pq.into_iter().map(|a| a as i64).sum::<i64>()\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nuse std::collections::BinaryHeap;\\n\\nimpl Solution {\\n    pub fn pick_gifts(gifts: Vec<i32>, k: i32) -> i64 {\\n        let mut k = k;\\n        let mut pq = BinaryHeap::from(gifts);\\n\\n        while let Some(v) = pq.pop() {\\n            let x = f64::sqrt(v as f64 + 0.5) as i32;\\n            pq.push(x);\\n            k -= 1;\\n            if k == 0 { break }\\n        }\\n        \\n        pq.into_iter().map(|a| a as i64).sum::<i64>()\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3145847,
                "title": "c-priority-queue-100-fast",
                "content": "prio\\n\\n# Approach\\nPriority queue\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long pickGifts(vector<int>& gifts, int k) {\\n        priority_queue<int> temp;\\n        int first=0;\\n        for(auto x:gifts)\\n        {\\n            temp.push(x);\\n        }\\n        while(k--)\\n        {\\n            first=temp.top();\\n            temp.pop();\\n            temp.push(sqrt(first));\\n        }\\n        long long int count=0;\\n        while(!temp.empty())\\n        {\\n            count+=temp.top();\\n            temp.pop();\\n        }\\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long pickGifts(vector<int>& gifts, int k) {\\n        priority_queue<int> temp;\\n        int first=0;\\n        for(auto x:gifts)\\n        {\\n            temp.push(x);\\n        }\\n        while(k--)\\n        {\\n            first=temp.top();\\n            temp.pop();\\n            temp.push(sqrt(first));\\n        }\\n        long long int count=0;\\n        while(!temp.empty())\\n        {\\n            count+=temp.top();\\n            temp.pop();\\n        }\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3145779,
                "title": "easy-to-understand",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\nMaximum element and its index can be found with the help of **max_element()** function provided in STL. If several elements are equivalent to the maximum element, the function return the iterator to the first such element.\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long pickGifts(vector<int>& gifts, int k) {\\n        \\n        for(int i=0 ; i<k ; i++){\\n            int max = *max_element(gifts.begin(), gifts.end());\\n            int max_idx = max_element(gifts.begin(), gifts.end()) - gifts.begin();\\n        \\n            int sqv = sqrt(max);\\n            gifts[max_idx] = sqv;\\n        }\\n        \\n        long long sum = 0;\\n        for(auto &v : gifts){\\n            sum += v;\\n        }\\n        \\n        return sum;\\n    }\\n};\\n```\\nIf you like the solution , do **UPVOTE** .\\n",
                "solutionTags": [
                    "C++",
                    "Math"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long pickGifts(vector<int>& gifts, int k) {\\n        \\n        for(int i=0 ; i<k ; i++){\\n            int max = *max_element(gifts.begin(), gifts.end());\\n            int max_idx = max_element(gifts.begin(), gifts.end()) - gifts.begin();\\n        \\n            int sqv = sqrt(max);\\n            gifts[max_idx] = sqv;\\n        }\\n        \\n        long long sum = 0;\\n        for(auto &v : gifts){\\n            sum += v;\\n        }\\n        \\n        return sum;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3145554,
                "title": "scala-priorityqueue",
                "content": "# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(n)\\n\\n# Code\\n```\\nobject Solution {\\n  def pickGifts(gifts: Array[Int], k: Int): Long = {\\n    val heap = scala.collection.mutable.PriorityQueue.from(gifts)\\n    (1 to k).foreach { _ =>\\n      val gift = heap.dequeue()\\n      heap.addOne(math.sqrt(gift).toInt)\\n    }\\n    heap.foldLeft(0L)(_ + _)\\n  }\\n}\\n```",
                "solutionTags": [
                    "Scala"
                ],
                "code": "```\\nobject Solution {\\n  def pickGifts(gifts: Array[Int], k: Int): Long = {\\n    val heap = scala.collection.mutable.PriorityQueue.from(gifts)\\n    (1 to k).foreach { _ =>\\n      val gift = heap.dequeue()\\n      heap.addOne(math.sqrt(gift).toInt)\\n    }\\n    heap.foldLeft(0L)(_ + _)\\n  }\\n}\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3145399,
                "title": "python-faster-than-100-easy-understanding-clean-concise-code",
                "content": "#\\n![image.png](https://assets.leetcode.com/users/images/c6092bbf-04a6-4188-8562-1250b48c2f65_1675587792.7913907.png)\\n\\n# Approach\\n> **Simple Using Heap \\uD83D\\uDCAB**\\n\\n# Complexity\\n- Time complexity: O(n)\\n- Space complexity: O(n)\\n# Code\\n```\\nclass Solution(object):\\n    def pickGifts(self, gifts, k):\\n        # heapify(heap)\\n        # heapq.heappush(heap,-4)\\n        # heapq.heappush(heap,-8)\\n        # heapq.heappush(heap,-9)\\n        #\\n        # print(-heapq.heappop(heap)) # 9\\n        # print(-heapq.heappop(heap)) # 8\\n        # print(-heapq.heappop(heap)) # 4\\n\\n        heap = []\\n        for gift in gifts:\\n            heapq.heappush(heap,-gift)\\n\\n        for _ in range(k):\\n            curMaxVal = -heapq.heappop(heap)\\n            heapq.heappush(heap,-1*int(math.sqrt(curMaxVal)))\\n\\n        return -sum(heap)\\n```\\n> You Can also Look At My SDE Prep Repo [\\uD83E\\uDDE2 GitHub](https://github.com/Ayon-SSP/The-SDE-Prep) myrepoo",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution(object):\\n    def pickGifts(self, gifts, k):\\n        # heapify(heap)\\n        # heapq.heappush(heap,-4)\\n        # heapq.heappush(heap,-8)\\n        # heapq.heappush(heap,-9)\\n        #\\n        # print(-heapq.heappop(heap)) # 9\\n        # print(-heapq.heappop(heap)) # 8\\n        # print(-heapq.heappop(heap)) # 4\\n\\n        heap = []\\n        for gift in gifts:\\n            heapq.heappush(heap,-gift)\\n\\n        for _ in range(k):\\n            curMaxVal = -heapq.heappop(heap)\\n            heapq.heappush(heap,-1*int(math.sqrt(curMaxVal)))\\n\\n        return -sum(heap)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3145216,
                "title": "c-priority-queue-easy-approach",
                "content": "Here is my c++ code for this problem.\\n\\n# Complexity\\n- Time complexity:$$O(nlogn)$$\\n\\n- Space complexity:$$O(n)$$\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long pickGifts(vector<int>& gifts, int k) {\\n        long long int cnt=0;\\n        priority_queue<int>q;\\n        for(int i=0; i<gifts.size(); i++){\\n            q.push(gifts[i]);\\n        }\\n        while(k--){\\n            int tp=q.top();\\n            tp=sqrt(tp);\\n            q.pop();\\n            q.push(tp);\\n        }\\n        while(!q.empty()){cnt+=q.top(); q.pop();}\\n        return cnt;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long pickGifts(vector<int>& gifts, int k) {\\n        long long int cnt=0;\\n        priority_queue<int>q;\\n        for(int i=0; i<gifts.size(); i++){\\n            q.push(gifts[i]);\\n        }\\n        while(k--){\\n            int tp=q.top();\\n            tp=sqrt(tp);\\n            q.pop();\\n            q.push(tp);\\n        }\\n        while(!q.empty()){cnt+=q.top(); q.pop();}\\n        return cnt;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3145015,
                "title": "100-faster-solution-using-priority-queue-max-heap",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:$$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:$$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public long pickGifts(int[] gifts, int k) {\\n\\n        PriorityQueue<Integer> pq = new PriorityQueue<>(Collections.reverseOrder());\\n\\n        for( int e : gifts ) pq.add( e );\\n\\n        while(  k-- > 0 && !pq.isEmpty() ){\\n\\n            int max = pq.poll();\\n\\n            max = (int)Math.floor(Math.sqrt( max ));\\n\\n            pq.add( max );\\n\\n        }\\n\\n        long ans = 0;\\n\\n        while( !pq.isEmpty() ){\\n\\n            ans += pq.poll();\\n\\n        }\\n\\n        return ans;\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public long pickGifts(int[] gifts, int k) {\\n\\n        PriorityQueue<Integer> pq = new PriorityQueue<>(Collections.reverseOrder());\\n\\n        for( int e : gifts ) pq.add( e );\\n\\n        while(  k-- > 0 && !pq.isEmpty() ){\\n\\n            int max = pq.poll();\\n\\n            max = (int)Math.floor(Math.sqrt( max ));\\n\\n            pq.add( max );\\n\\n        }\\n\\n        long ans = 0;\\n\\n        while( !pq.isEmpty() ){\\n\\n            ans += pq.poll();\\n\\n        }\\n\\n        return ans;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3144791,
                "title": "java-most-easy-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public long pickGifts(int[] gifts, int k) {\\n        int i=0;\\n        double arr[]=new double[gifts.length];\\n        for(int m=0;m<gifts.length;m++){\\n            arr[m]=gifts[m];\\n        }\\n        \\n        while(i<k){\\n            double max=0;\\n            int ind=0;\\n            for(int j=0;j<gifts.length;j++){\\n                if(arr[j]>max){\\n                    max=arr[j];\\n                    ind=j;\\n                }\\n            }\\n            arr[ind]=Math.floor(Math.sqrt(max));\\n            \\n            i++;\\n        }\\n        \\n        long ans=0;\\n        for(int m=0;m<gifts.length;m++){\\n             ans+=arr[m];\\n        }\\n        return ans;\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public long pickGifts(int[] gifts, int k) {\\n        int i=0;\\n        double arr[]=new double[gifts.length];\\n        for(int m=0;m<gifts.length;m++){\\n            arr[m]=gifts[m];\\n        }\\n        \\n        while(i<k){\\n            double max=0;\\n            int ind=0;\\n            for(int j=0;j<gifts.length;j++){\\n                if(arr[j]>max){\\n                    max=arr[j];\\n                    ind=j;\\n                }\\n            }\\n            arr[ind]=Math.floor(Math.sqrt(max));\\n            \\n            i++;\\n        }\\n        \\n        long ans=0;\\n        for(int m=0;m<gifts.length;m++){\\n             ans+=arr[m];\\n        }\\n        return ans;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3144728,
                "title": "easy-to-understand-python-solution-100-faster-and-memory-efficient",
                "content": "![image.png](https://assets.leetcode.com/users/images/0d8cd792-1c82-418a-9770-4bcc4057065f_1675579197.6044726.png)\\n\\n# Complexity\\n- Time complexity: O(nk)\\n\\n- Space complexity: O(1)\\n\\n# Code\\n```\\nclass Solution:\\n    def pickGifts(self, gifts: List[int], k: int) -> int:\\n      counter = 0\\n      while counter < k:\\n        gifts.sort(reverse = True)\\n        maxPile = gifts[0]\\n        maxPile = math.floor(maxPile**0.5)\\n        gifts[0] = maxPile\\n        counter+=1\\n      return sum(gifts)  \\n        \\n      \\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def pickGifts(self, gifts: List[int], k: int) -> int:\\n      counter = 0\\n      while counter < k:\\n        gifts.sort(reverse = True)\\n        maxPile = gifts[0]\\n        maxPile = math.floor(maxPile**0.5)\\n        gifts[0] = maxPile\\n        counter+=1\\n      return sum(gifts)  \\n        \\n      \\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3144640,
                "title": "c-solution-using-max-heap-priority-queue",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nEach time we need to find the biggest number in the array, remove it from the array and add it\\'s sqaure root value to the array. So we use priority queue to find the largest value at any given time.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n## Steps:\\n- Step 1: Declare a priority queue (max Heap) and store all the array values in the heap.\\n- Step 2: For k times, pop the top value(this will be biggest value in the array at that point of time) and add `sqrt(value)` back to the heap.\\n- Step 3: Repeat Step 2 k times.\\n- Step 4: Add all the remaining elements in the heap and return the summation.\\n# Complexity\\n- Time complexity:O(klogn)\\n    - O(n) to push all the elements in the pririty queue.\\n    - O(k) for each passing second.\\n    - O(logn) to push and pop an element from the priority queue.\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n    - O(n) space complexity to maintain the priority queue.\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long pickGifts(vector<int>& gifts, int k) {\\n        priority_queue <int> pq;\\n        for (int num: gifts) {\\n            pq.push(num);\\n        }\\n        while (k) {\\n            k--;\\n            int curr = pq.top();\\n            pq.pop();\\n            pq.push(sqrt(curr));\\n        }\\n        long long int ans = 0;\\n        while (!pq.empty()) {\\n            ans = 1LL * (ans + pq.top());\\n            pq.pop();\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Math",
                    "Greedy",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long pickGifts(vector<int>& gifts, int k) {\\n        priority_queue <int> pq;\\n        for (int num: gifts) {\\n            pq.push(num);\\n        }\\n        while (k) {\\n            k--;\\n            int curr = pq.top();\\n            pq.pop();\\n            pq.push(sqrt(curr));\\n        }\\n        long long int ans = 0;\\n        while (!pq.empty()) {\\n            ans = 1LL * (ans + pq.top());\\n            pq.pop();\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3144625,
                "title": "100-fast-and-memory-efficient-c-solution-priority-queue",
                "content": "## Complexity\\n- Time complexity: $$O(nlogn)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n## Code\\n```\\nclass Solution {\\npublic:\\n    long long pickGifts(vector<int>& gifts, int k) {\\n        long long cnt=0;\\n        priority_queue<int> pq;\\n        for (int i=0; i<gifts.size(); i++){\\n            pq.push(gifts[i]);\\n        }\\n        while (k--){\\n            if (pq.empty())break;\\n            int element= pq.top();\\n            pq.pop();\\n            pq.push(sqrt(element));\\n        }\\n        while (!pq.empty()){\\n            cnt+= pq.top();\\n            pq.pop();\\n        }\\n        return cnt;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Sort",
                    "Sorting",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long pickGifts(vector<int>& gifts, int k) {\\n        long long cnt=0;\\n        priority_queue<int> pq;\\n        for (int i=0; i<gifts.size(); i++){\\n            pq.push(gifts[i]);\\n        }\\n        while (k--){\\n            if (pq.empty())break;\\n            int element= pq.top();\\n            pq.pop();\\n            pq.push(sqrt(element));\\n        }\\n        while (!pq.empty()){\\n            cnt+= pq.top();\\n            pq.pop();\\n        }\\n        return cnt;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3144228,
                "title": "simple-approach-without-priority-queue-nlogn",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public long pickGifts(int[] gifts, int k) {\\n        \\n         for (int i = 0; i < k; i++) {\\n\\n            Arrays.sort(gifts);\\n\\n            gifts[gifts.length - 1] = (int) Math.sqrt(gifts[gifts.length - 1]);\\n        }\\n\\n        long sum = 0;\\n\\n        for (long i :\\n                gifts) {\\n            sum += i;\\n        }\\n\\n        return sum;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public long pickGifts(int[] gifts, int k) {\\n        \\n         for (int i = 0; i < k; i++) {\\n\\n            Arrays.sort(gifts);\\n\\n            gifts[gifts.length - 1] = (int) Math.sqrt(gifts[gifts.length - 1]);\\n        }\\n\\n        long sum = 0;\\n\\n        for (long i :\\n                gifts) {\\n            sum += i;\\n        }\\n\\n        return sum;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3144127,
                "title": "beats-100-t-c-and-s-c-priority-queue-beginner-friendly-code",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long pickGifts(vector<int>& gifts, int k) {\\n        priority_queue <int> pq;\\n        for(auto &i:gifts)\\n        {\\n            pq.push(i);\\n        }\\n        for(int i=0;i<k;i++)\\n        {\\n            pq.push(floor(pow(pq.top(),0.5)));\\n            pq.pop();\\n        }\\n        \\n        long long sum = 0;\\n        for(int i=0;i<gifts.size();i++)\\n        {\\n            sum = sum+pq.top();\\n            pq.pop();\\n        }\\n        \\n        return sum;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long pickGifts(vector<int>& gifts, int k) {\\n        priority_queue <int> pq;\\n        for(auto &i:gifts)\\n        {\\n            pq.push(i);\\n        }\\n        for(int i=0;i<k;i++)\\n        {\\n            pq.push(floor(pow(pq.top(),0.5)));\\n            pq.pop();\\n        }\\n        \\n        long long sum = 0;\\n        for(int i=0;i<gifts.size();i++)\\n        {\\n            sum = sum+pq.top();\\n            pq.pop();\\n        }\\n        \\n        return sum;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3144060,
                "title": "c-beats-100",
                "content": "\\n# Approach\\n1. We are given that we have to perform for k seconds , there we iterate k times.\\n2. Find the maximum number and it\\'s index\\n3. Find the square root and update the new value at the same index\\n4. Find the sum of all elements\\n<!-- Describe your approach to solving the problem. -->\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long pickGifts(vector<int>& gifts, int k) {\\n        long long sum = 0;\\n\\n        for(int i = k ; i > 0 ; i--){\\n        //\\'it\\' stores the index \\n        auto it = minmax_element(gifts.begin() , gifts.end());\\n        int max_idx = distance(gifts.begin() , it.second);\\n        //square root\\n        int val = pow(gifts[max_idx] , 0.5);\\n        gifts[max_idx]=floor(val);\\n        }\\n        //sum\\n        for(int i = 0 ; i < gifts.size() ; i++){\\n            sum+=gifts[i];\\n        }\\n        \\n        return sum;\\n        \\n    }\\n};\\n```\\n",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long pickGifts(vector<int>& gifts, int k) {\\n        long long sum = 0;\\n\\n        for(int i = k ; i > 0 ; i--){\\n        //\\'it\\' stores the index \\n        auto it = minmax_element(gifts.begin() , gifts.end());\\n        int max_idx = distance(gifts.begin() , it.second);\\n        //square root\\n        int val = pow(gifts[max_idx] , 0.5);\\n        gifts[max_idx]=floor(val);\\n        }\\n        //sum\\n        for(int i = 0 ; i < gifts.size() ; i++){\\n            sum+=gifts[i];\\n        }\\n        \\n        return sum;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3144006,
                "title": "python3-solution",
                "content": "\\n```\\nclass Solution:\\n    def pickGifts(self, gifts: List[int], k: int) -> int:\\n        for i in range(k):\\n            gifts.sort()\\n            gifts[-1]=math.floor(math.sqrt(gifts[-1]))\\n            \\n        ans=0\\n        for i in range(len(gifts)):\\n            ans+=gifts[i]\\n            \\n        return ans    \\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def pickGifts(self, gifts: List[int], k: int) -> int:\\n        for i in range(k):\\n            gifts.sort()\\n            gifts[-1]=math.floor(math.sqrt(gifts[-1]))\\n            \\n        ans=0\\n        for i in range(len(gifts)):\\n            ans+=gifts[i]\\n            \\n        return ans    \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3143933,
                "title": "java-max-heap-explained",
                "content": "---\\n# Please Upvote \\uD83D\\uDE07\\n---\\n``` java []\\nclass Solution {\\n    public long pickGifts(int[] gifts, int k) {\\n        // create a max heap priority queue and push all the elements into it\\n        // we need a max heap because we need the max out of it every time\\n        PriorityQueue<Integer> pq = new PriorityQueue<>((a, b) -> b - a);\\n        for (int i : gifts) {\\n            pq.offer(i);\\n        } \\n        \\n        // we will perform our task k times\\n        while (k-- > 0) {\\n            int x = pq.poll();        // take out the richest pile\\n            x = (int) Math.sqrt(x);   // floor of the square root\\n            pq.offer(x);              // put it back\\n        }\\n        \\n        // now the heap only contains the leftovers\\n        long left = 0;\\n        // get the sum of all leftovers\\n        while (!pq.isEmpty()) {\\n            left += pq.poll();  \\n        }\\n        \\n        return left;    // return the answer\\n    }\\n}\\n```\\n---\\n#### Clean solution:\\n``` java []\\nclass Solution {\\n    public long pickGifts(int[] gifts, int k) {\\n        PriorityQueue<Integer> pq = new PriorityQueue<>((a, b) -> b - a);\\n        for (int i : gifts) {\\n            pq.offer(i);\\n        } \\n\\n        while (k-- > 0) {\\n            int x = pq.poll();       \\n            x = (int) Math.sqrt(x);  \\n            pq.offer(x);             \\n        }\\n        \\n        long left = 0;\\n        while (!pq.isEmpty()) {\\n            left += pq.poll();  \\n        }\\n        \\n        return left;   \\n    }\\n}\\n```\\n---\\n#### Time complexity: $$O(n + k*logn + n * logn)$$\\n#### Space complexity: $$O(n)$$\\n",
                "solutionTags": [
                    "Java",
                    "Heap (Priority Queue)"
                ],
                "code": "``` java []\\nclass Solution {\\n    public long pickGifts(int[] gifts, int k) {\\n        // create a max heap priority queue and push all the elements into it\\n        // we need a max heap because we need the max out of it every time\\n        PriorityQueue<Integer> pq = new PriorityQueue<>((a, b) -> b - a);\\n        for (int i : gifts) {\\n            pq.offer(i);\\n        } \\n        \\n        // we will perform our task k times\\n        while (k-- > 0) {\\n            int x = pq.poll();        // take out the richest pile\\n            x = (int) Math.sqrt(x);   // floor of the square root\\n            pq.offer(x);              // put it back\\n        }\\n        \\n        // now the heap only contains the leftovers\\n        long left = 0;\\n        // get the sum of all leftovers\\n        while (!pq.isEmpty()) {\\n            left += pq.poll();  \\n        }\\n        \\n        return left;    // return the answer\\n    }\\n}\\n```\n``` java []\\nclass Solution {\\n    public long pickGifts(int[] gifts, int k) {\\n        PriorityQueue<Integer> pq = new PriorityQueue<>((a, b) -> b - a);\\n        for (int i : gifts) {\\n            pq.offer(i);\\n        } \\n\\n        while (k-- > 0) {\\n            int x = pq.poll();       \\n            x = (int) Math.sqrt(x);  \\n            pq.offer(x);             \\n        }\\n        \\n        long left = 0;\\n        while (!pq.isEmpty()) {\\n            left += pq.poll();  \\n        }\\n        \\n        return left;   \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3143929,
                "title": "easy-simple-c",
                "content": "<!-- # Intuition -->\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n<!-- # Approach -->\\n<!-- Describe your approach to solving the problem. -->\\n\\n<!-- # Complexity -->\\n<!-- - Time complexity: -->\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n<!-- - Space complexity: -->\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long pickGifts(vector<int>& gifts, int k) {\\n        \\n        priority_queue<int>pq;\\n        for(auto i:gifts)pq.push(i);\\n        for(int i=0;i<k;i++)\\n        {\\n            int t=pq.top();\\n            t=sqrt(t);\\n            pq.pop();\\n            pq.push(t);\\n        }\\n         long long sum=0;\\n        while(!pq.empty())\\n        {\\n            sum+=pq.top();\\n            pq.pop();\\n            }\\n        return sum;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long pickGifts(vector<int>& gifts, int k) {\\n        \\n        priority_queue<int>pq;\\n        for(auto i:gifts)pq.push(i);\\n        for(int i=0;i<k;i++)\\n        {\\n            int t=pq.top();\\n            t=sqrt(t);\\n            pq.pop();\\n            pq.push(t);\\n        }\\n         long long sum=0;\\n        while(!pq.empty())\\n        {\\n            sum+=pq.top();\\n            pq.pop();\\n            }\\n        return sum;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3143921,
                "title": "priority-queue-beats-100-in-runtime-and-space-c",
                "content": "# Code\\n```\\nclass Solution \\n{\\npublic:\\n    long long pickGifts(vector<int>& gifts, int k) \\n    {\\n        priority_queue<int> q;\\n        for(auto it: gifts) q.push(it);\\n        while(k--)\\n        {\\n            int t=q.top();\\n            q.pop();\\n            t=floor(sqrt(t));\\n            q.push(t);\\n        }\\n        long long ans=0;\\n        while(!q.empty())\\n        {\\n            ans+=q.top();\\n            q.pop();\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution \\n{\\npublic:\\n    long long pickGifts(vector<int>& gifts, int k) \\n    {\\n        priority_queue<int> q;\\n        for(auto it: gifts) q.push(it);\\n        while(k--)\\n        {\\n            int t=q.top();\\n            q.pop();\\n            t=floor(sqrt(t));\\n            q.push(t);\\n        }\\n        long long ans=0;\\n        while(!q.empty())\\n        {\\n            ans+=q.top();\\n            q.pop();\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3143912,
                "title": "using-priority-queue-faster-than-100-solutions",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nPush all elements into max-heap, keep taking one-one from it.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nPush elements into max-heap after taking their square roots, then count all elements left in your heap.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(N)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(N)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long pickGifts(vector<int>& gifts, int k) {\\n         priority_queue<int> pq;\\n        int n = gifts.size();\\n        for(int i=0; i<n; i++){\\n            pq.push(gifts[i]);\\n        }\\n        long long sum = 0;\\n        for(int j=0; j<k; j++){\\n            int temp = pq.top();\\n            pq.push(sqrt(temp));\\n            pq.pop();\\n        }\\n        while(!pq.empty()){\\n        sum += pq.top();\\n            pq.pop();\\n        }\\n        return sum;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long pickGifts(vector<int>& gifts, int k) {\\n         priority_queue<int> pq;\\n        int n = gifts.size();\\n        for(int i=0; i<n; i++){\\n            pq.push(gifts[i]);\\n        }\\n        long long sum = 0;\\n        for(int j=0; j<k; j++){\\n            int temp = pq.top();\\n            pq.push(sqrt(temp));\\n            pq.pop();\\n        }\\n        while(!pq.empty()){\\n        sum += pq.top();\\n            pq.pop();\\n        }\\n        return sum;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3143910,
                "title": "using-priority-queue-faster-than-100-solutions",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nPush all elements into max-heap, keep taking one-one from it.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nPush elements into max-heap after taking their square roots, then count all elements left in your heap.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(N)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(N)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long pickGifts(vector<int>& gifts, int k) {\\n         priority_queue<int> pq;\\n        int n = gifts.size();\\n        for(int i=0; i<n; i++){\\n            pq.push(gifts[i]);\\n        }\\n        long long sum = 0;\\n        for(int j=0; j<k; j++){\\n            int temp = pq.top();\\n            pq.push(sqrt(temp));\\n            pq.pop();\\n        }\\n        while(!pq.empty()){\\n        sum += pq.top();\\n            pq.pop();\\n        }\\n        return sum;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long pickGifts(vector<int>& gifts, int k) {\\n         priority_queue<int> pq;\\n        int n = gifts.size();\\n        for(int i=0; i<n; i++){\\n            pq.push(gifts[i]);\\n        }\\n        long long sum = 0;\\n        for(int j=0; j<k; j++){\\n            int temp = pq.top();\\n            pq.push(sqrt(temp));\\n            pq.pop();\\n        }\\n        while(!pq.empty()){\\n        sum += pq.top();\\n            pq.pop();\\n        }\\n        return sum;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3143894,
                "title": "python-solution-using-heap-easy-to-understand-for-beginners",
                "content": "```\\nfrom heapq import heapify,heappush,heappop\\nclass Solution:\\n    def pickGifts(self, gifts: List[int], k: int) -> int:\\n\\t\\t# python stores element as min heap so 1 will be popped out first instead of 2 to do it reverse multiply each\\n\\t\\t# elements by -1 so -2 will be popped out first\\n        gifts = [-gift for gift in gifts]\\n\\t\\t\\n\\t\\t# heapify the new array\\n        heapify(gifts)\\n\\t\\t\\n\\t\\t# iterate till k>0\\n        while k:\\n\\t\\t\\t\\n\\t\\t\\t# pop the element from heap and negative it so that -(-2) => 2\\n            a = -heappop(gifts)\\n\\t\\t\\t\\n\\t\\t\\t# push floor of its square root and add it to the heap (remember to add negative sign)\\n            heappush(gifts,-int(a**0.5))\\n\\t\\t\\t\\n            k -= 1\\n\\t\\t\\t\\n\\t\\t# return the final sum\\n        return -sum(gifts)\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Math",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nfrom heapq import heapify,heappush,heappop\\nclass Solution:\\n    def pickGifts(self, gifts: List[int], k: int) -> int:\\n\\t\\t# python stores element as min heap so 1 will be popped out first instead of 2 to do it reverse multiply each\\n\\t\\t# elements by -1 so -2 will be popped out first\\n        gifts = [-gift for gift in gifts]\\n\\t\\t\\n\\t\\t# heapify the new array\\n        heapify(gifts)\\n\\t\\t\\n\\t\\t# iterate till k>0\\n        while k:\\n\\t\\t\\t\\n\\t\\t\\t# pop the element from heap and negative it so that -(-2) => 2\\n            a = -heappop(gifts)\\n\\t\\t\\t\\n\\t\\t\\t# push floor of its square root and add it to the heap (remember to add negative sign)\\n            heappush(gifts,-int(a**0.5))\\n\\t\\t\\t\\n            k -= 1\\n\\t\\t\\t\\n\\t\\t# return the final sum\\n        return -sum(gifts)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3143854,
                "title": "easy-java-solution-100-faster",
                "content": "\\n```\\nclass Solution {\\n    public long pickGifts(int[] gifts, int k) {\\n        \\n    PriorityQueue<Integer> list=new PriorityQueue<>(Collections.reverseOrder());\\n        long sum=0;\\n      for(int i=0;i<gifts.length;i++)\\n      {\\n          list.add(gifts[i]);\\n      }\\n       for(int i=0;i<k;i++)\\n       {\\n           int a=list.remove();\\n           double b=Math.floor(Math.sqrt(a));\\n           list.add((int)b);\\n       }\\n       for(int i=0;i<gifts.length;i++)\\n       {\\n           sum=sum+list.remove();\\n       }\\n        \\n        return sum;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public long pickGifts(int[] gifts, int k) {\\n        \\n    PriorityQueue<Integer> list=new PriorityQueue<>(Collections.reverseOrder());\\n        long sum=0;\\n      for(int i=0;i<gifts.length;i++)\\n      {\\n          list.add(gifts[i]);\\n      }\\n       for(int i=0;i<k;i++)\\n       {\\n           int a=list.remove();\\n           double b=Math.floor(Math.sqrt(a));\\n           list.add((int)b);\\n       }\\n       for(int i=0;i<gifts.length;i++)\\n       {\\n           sum=sum+list.remove();\\n       }\\n        \\n        return sum;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3143846,
                "title": "max-heap-clean-code",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long pickGifts(vector<int>& gifts, int k) {\\n        priority_queue<int> pq;\\n        for(auto ele:gifts)pq.push(ele);\\n        \\n        while(k--){\\n            auto ele = pq.top();\\n            pq.pop();\\n            pq.push(floor(sqrt(ele)));\\n        };\\n        long long sum = 0;\\n        while(pq.size()){\\n            sum+=pq.top();\\n            pq.pop();\\n        }\\n        return sum;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long pickGifts(vector<int>& gifts, int k) {\\n        priority_queue<int> pq;\\n        for(auto ele:gifts)pq.push(ele);\\n        \\n        while(k--){\\n            auto ele = pq.top();\\n            pq.pop();\\n            pq.push(floor(sqrt(ele)));\\n        };\\n        long long sum = 0;\\n        while(pq.size()){\\n            sum+=pq.top();\\n            pq.pop();\\n        }\\n        return sum;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3143743,
                "title": "easy-short-efficient-clean-code",
                "content": "```\\nclass Solution {\\npublic:\\ntypedef long long ll;\\n    long long pickGifts(vector<int>&v, int k) {\\n        ll sum=accumulate(begin(v), end(v), 0LL);\\n        priority_queue<ll>pq(begin(v), end(v));\\n        while(k>0 && !pq.empty()){\\n            ll it=pq.top();\\n            pq.pop();\\n            ll rem=sqrt(it);\\n            pq.push(rem);\\n            sum-=it-rem; --k;\\n        }\\n        return sum;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\npublic:\\ntypedef long long ll;\\n    long long pickGifts(vector<int>&v, int k) {\\n        ll sum=accumulate(begin(v), end(v), 0LL);\\n        priority_queue<ll>pq(begin(v), end(v));\\n        while(k>0 && !pq.empty()){\\n            ll it=pq.top();\\n            pq.pop();\\n            ll rem=sqrt(it);\\n            pq.push(rem);\\n            sum-=it-rem; --k;\\n        }\\n        return sum;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3143686,
                "title": "easy-python-solution-heap",
                "content": "# Code\\n```\\nclass Solution:\\n    def pickGifts(self, gifts: List[int], k: int) -> int:\\n        res = [-i for i in gifts]\\n        heapq.heapify(res)\\n        for i in range(k):\\n            temp = -heapq.heappop(res)\\n            temp = int(math.sqrt(temp))\\n            heapq.heappush(res, -temp)\\n        ans = [-i for i in res]\\n        return int(sum(ans))       \\n```\\nDo upvote if you like the Solution :)",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def pickGifts(self, gifts: List[int], k: int) -> int:\\n        res = [-i for i in gifts]\\n        heapq.heapify(res)\\n        for i in range(k):\\n            temp = -heapq.heappop(res)\\n            temp = int(math.sqrt(temp))\\n            heapq.heappush(res, -temp)\\n        ans = [-i for i in res]\\n        return int(sum(ans))       \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3143684,
                "title": "python-3-maxheap",
                "content": "```\\nclass Solution:\\n    def pickGifts(self, gifts: List[int], k: int) -> int:\\n        nums = [-i for i in gifts]\\n        heapify(nums)\\n        \\n        for _ in range(k):\\n            t = -heappop(nums)\\n            heappush(nums, -floor(pow(t, 0.5)))\\n        \\n        return -sum(nums)\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution:\\n    def pickGifts(self, gifts: List[int], k: int) -> int:\\n        nums = [-i for i in gifts]\\n        heapify(nums)\\n        \\n        for _ in range(k):\\n            t = -heappop(nums)\\n            heappush(nums, -floor(pow(t, 0.5)))\\n        \\n        return -sum(nums)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4098538,
                "title": "max-heap-priority-queue-easy-sol-beats-85",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long pickGifts(vector<int>& gifts, int k) {\\n        priority_queue<int> pq;\\n        for(auto it: gifts){\\n            pq.push(it);\\n        }\\n\\n        while(k != 0){\\n            int a = sqrt(pq.top());\\n            pq.pop();\\n            pq.push(a);    \\n            k--;        \\n        }\\n\\n        long long count = 0;\\n        while(pq.size() != 0){\\n            count += pq.top();\\n            pq.pop();\\n        }\\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long pickGifts(vector<int>& gifts, int k) {\\n        priority_queue<int> pq;\\n        for(auto it: gifts){\\n            pq.push(it);\\n        }\\n\\n        while(k != 0){\\n            int a = sqrt(pq.top());\\n            pq.pop();\\n            pq.push(a);    \\n            k--;        \\n        }\\n\\n        long long count = 0;\\n        while(pq.size() != 0){\\n            count += pq.top();\\n            pq.pop();\\n        }\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4096380,
                "title": "easy-solution-using-java-and-arrays-sort",
                "content": "# Intuition\\nEvery time we take largest pile.So for every second we sort the array and get largest pile at the end.Do the require task and add all pile\\n\\n# Approach\\nSorting  at every k second give largest pile at the end\\n\\n# Complexity\\n- Time complexity:25ms\\n\\n- Space complexity:\\nO(1) constant space complexity\\n\\n# Code\\n```\\nclass Solution {\\n    public long pickGifts(int[] gifts, int k) {\\n      int n = gifts.length;\\n      long sum = 0;\\n      while(k-->0){\\n          Arrays.sort(gifts);\\n          gifts[n-1] = (int) Math.sqrt((double) gifts[n-1]);\\n      }\\n      for(int i=0;i<n;i++){\\n          sum+=gifts[i];\\n      }   \\n      return sum;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\n    public long pickGifts(int[] gifts, int k) {\\n      int n = gifts.length;\\n      long sum = 0;\\n      while(k-->0){\\n          Arrays.sort(gifts);\\n          gifts[n-1] = (int) Math.sqrt((double) gifts[n-1]);\\n      }\\n      for(int i=0;i<n;i++){\\n          sum+=gifts[i];\\n      }   \\n      return sum;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4094733,
                "title": "simple-c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long pickGifts(vector<int>& gifts, int k) {\\n\\n       long long sum=0;\\n       for(int i=0;i<k;i++){\\n           sort(gifts.begin(),gifts.end());\\n           gifts[gifts.size()-1]=sqrt(gifts[gifts.size()-1]);\\n       } \\n       for(int i=0;i<gifts.size();i++){\\n           sum+=gifts[i];\\n       }\\n       return sum;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long pickGifts(vector<int>& gifts, int k) {\\n\\n       long long sum=0;\\n       for(int i=0;i<k;i++){\\n           sort(gifts.begin(),gifts.end());\\n           gifts[gifts.size()-1]=sqrt(gifts[gifts.size()-1]);\\n       } \\n       for(int i=0;i<gifts.size();i++){\\n           sum+=gifts[i];\\n       }\\n       return sum;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4081011,
                "title": "proud-of-this-one-doesnt-get-any-easier",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def pickGifts(self, gifts: List[int], k: int) -> int:\\n        for i in range(k):\\n            pileindex=gifts.index(max(gifts))  #\\n            gifts[pileindex]=int((gifts[pileindex])**0.5)\\n\\n        return (sum(gifts))\\n\\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def pickGifts(self, gifts: List[int], k: int) -> int:\\n        for i in range(k):\\n            pileindex=gifts.index(max(gifts))  #\\n            gifts[pileindex]=int((gifts[pileindex])**0.5)\\n\\n        return (sum(gifts))\\n\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 4073813,
                "title": "seven-lines",
                "content": "# Code\\n```\\nclass Solution(object):\\n    def pickGifts(self, gifts, k):\\n        while k > 0:\\n            k -= 1\\n            max_num = max(gifts)\\n            max_num_index = gifts.index(max_num)\\n\\n            gifts.remove(max_num)\\n            gifts.insert(max_num_index, int(max_num ** 0.5))\\n\\n        return sum(gifts)\\n            \\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution(object):\\n    def pickGifts(self, gifts, k):\\n        while k > 0:\\n            k -= 1\\n            max_num = max(gifts)\\n            max_num_index = gifts.index(max_num)\\n\\n            gifts.remove(max_num)\\n            gifts.insert(max_num_index, int(max_num ** 0.5))\\n\\n        return sum(gifts)\\n            \\n```",
                "codeTag": "Java"
            },
            {
                "id": 4060525,
                "title": "simple-java-solution",
                "content": "# Intuition\\nPriorityQueue\\n\\n# Complexity\\n- Time complexity:\\n$$O(nlogn)$$\\n\\n- Space complexity:\\n$$O(n)$$\\n\\n# Code\\n```\\nclass Solution {\\n    public long pickGifts(int[] gifts, int k) {\\n        PriorityQueue<Integer> queue = new PriorityQueue<>(Comparator.reverseOrder());\\n        Arrays.stream(gifts).forEach(queue::add);\\n        while(k-- > 0){\\n            int e = queue.poll();\\n            int t = (int)Math.floor(Math.sqrt(e));\\n            queue.add(t);\\n        }\\n        long sum = 0;\\n        while(!queue.isEmpty()){\\n            sum += queue.poll();\\n        }\\n        return sum;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public long pickGifts(int[] gifts, int k) {\\n        PriorityQueue<Integer> queue = new PriorityQueue<>(Comparator.reverseOrder());\\n        Arrays.stream(gifts).forEach(queue::add);\\n        while(k-- > 0){\\n            int e = queue.poll();\\n            int t = (int)Math.floor(Math.sqrt(e));\\n            queue.add(t);\\n        }\\n        long sum = 0;\\n        while(!queue.isEmpty()){\\n            sum += queue.poll();\\n        }\\n        return sum;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4049637,
                "title": "priority-queue-easy-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long pickGifts(vector<int>& gifts, int k) {\\n\\n     priority_queue<int>pq;\\n     \\n    for(int i=0;i<gifts.size();i++){\\n        pq.push(gifts[i]);\\n    }\\n\\n    int temp;\\n    for(int i=0;i<k;i++){\\n\\n     temp = sqrt(pq.top());\\n     pq.push(temp);\\n     pq.pop();\\n    }\\n    long long int ans=0;\\n    while(pq.size())\\n     {\\n   ans+=pq.top();\\n   pq.pop();\\n    }\\n    return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long pickGifts(vector<int>& gifts, int k) {\\n\\n     priority_queue<int>pq;\\n     \\n    for(int i=0;i<gifts.size();i++){\\n        pq.push(gifts[i]);\\n    }\\n\\n    int temp;\\n    for(int i=0;i<k;i++){\\n\\n     temp = sqrt(pq.top());\\n     pq.push(temp);\\n     pq.pop();\\n    }\\n    long long int ans=0;\\n    while(pq.size())\\n     {\\n   ans+=pq.top();\\n   pq.pop();\\n    }\\n    return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4039962,
                "title": "basic-commented-solution-heapc",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    long long pickGifts(vector<int>& gifts, int k) {\\n        priority_queue<int>pq; //creat a max heap\\n        for(auto i:gifts) // fill element in heap\\n        {\\n            pq.push(i);\\n        }\\n        long long sum=0; //this is our answer\\n        for(int i=0;i<k;i++) //loop that run till k times\\n        {\\n            int x=pq.top(); //store top element in x as we have to modify this only\\n            pq.pop();//pop this element out\\n            pq.push(floor(sqrt(x)));//find floor of sqrt  and again push in heap\\n            \\n        }\\n        while(pq.size()>0) // find sum of all element\\n        {\\n            sum+=pq.top();\\n            pq.pop();\\n        }\\n        return sum;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long pickGifts(vector<int>& gifts, int k) {\\n        priority_queue<int>pq; //creat a max heap\\n        for(auto i:gifts) // fill element in heap\\n        {\\n            pq.push(i);\\n        }\\n        long long sum=0; //this is our answer\\n        for(int i=0;i<k;i++) //loop that run till k times\\n        {\\n            int x=pq.top(); //store top element in x as we have to modify this only\\n            pq.pop();//pop this element out\\n            pq.push(floor(sqrt(x)));//find floor of sqrt  and again push in heap\\n            \\n        }\\n        while(pq.size()>0) // find sum of all element\\n        {\\n            sum+=pq.top();\\n            pq.pop();\\n        }\\n        return sum;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4035486,
                "title": "c-solution",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long pickGifts(vector<int>& gifts, int k) {\\n        priority_queue<int>pq;\\n        int n=gifts.size();\\n        // if(n==1) return gifts[0];\\n        for(auto g:gifts){\\n            pq.push(g);\\n        }\\n        while(k-->0){\\n            int n=pq.top();pq.pop();\\n            pq.push(sqrt(n));\\n        }\\n        long long ans=0;\\n        while(!pq.empty()){\\n            ans+=pq.top();\\n            pq.pop();\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long pickGifts(vector<int>& gifts, int k) {\\n        priority_queue<int>pq;\\n        int n=gifts.size();\\n        // if(n==1) return gifts[0];\\n        for(auto g:gifts){\\n            pq.push(g);\\n        }\\n        while(k-->0){\\n            int n=pq.top();pq.pop();\\n            pq.push(sqrt(n));\\n        }\\n        long long ans=0;\\n        while(!pq.empty()){\\n            ans+=pq.top();\\n            pq.pop();\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4025661,
                "title": "easy-and-understandable-solution-for-beginners",
                "content": "\\n# Code\\n```\\nclass Solution {\\n    func pickGifts(_ gifts: [Int], _ k: Int) -> Int {\\n        var giftsToChange = gifts\\n\\n        for _ in 0..<k{\\n            let num = giftsToChange.max()!\\n            let index = giftsToChange.firstIndex(of: num)\\n            let squareRoot = Double(num).squareRoot()\\n            giftsToChange[index!] = Int(squareRoot)\\n        }\\n        return giftsToChange.reduce(0) {\\n            $0 + $1\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nclass Solution {\\n    func pickGifts(_ gifts: [Int], _ k: Int) -> Int {\\n        var giftsToChange = gifts\\n\\n        for _ in 0..<k{\\n            let num = giftsToChange.max()!\\n            let index = giftsToChange.firstIndex(of: num)\\n            let squareRoot = Double(num).squareRoot()\\n            giftsToChange[index!] = Int(squareRoot)\\n        }\\n        return giftsToChange.reduce(0) {\\n            $0 + $1\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4021820,
                "title": "vey-easy-simple-for-beginners",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def pickGifts(self, gifts: List[int], k: int) -> int:\\n        import math\\n        while k>0:\\n            gifts.sort()\\n            gifts[len(gifts)-1]=int(math.sqrt(gifts[len(gifts)-1]))\\n            k-=1\\n        return sum(gifts)\\n        \\n        \\n        \\n\\n\\n\\n\\n\\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def pickGifts(self, gifts: List[int], k: int) -> int:\\n        import math\\n        while k>0:\\n            gifts.sort()\\n            gifts[len(gifts)-1]=int(math.sqrt(gifts[len(gifts)-1]))\\n            k-=1\\n        return sum(gifts)\\n        \\n        \\n        \\n\\n\\n\\n\\n\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 4020439,
                "title": "beat-90-in-space-complexity",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def pickGifts(self, gifts: List[int], k: int) -> int:\\n        j=0\\n        while(j<k):\\n            max=0\\n            pos=0\\n            for i in range(len(gifts)):\\n                if (gifts[i]>max):\\n                    max=gifts[i]\\n                    pos=i\\n            gifts[pos]=math.floor((gifts[pos])**0.5)\\n            j+=1\\n        return sum(gifts)\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def pickGifts(self, gifts: List[int], k: int) -> int:\\n        j=0\\n        while(j<k):\\n            max=0\\n            pos=0\\n            for i in range(len(gifts)):\\n                if (gifts[i]>max):\\n                    max=gifts[i]\\n                    pos=i\\n            gifts[pos]=math.floor((gifts[pos])**0.5)\\n            j+=1\\n        return sum(gifts)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4006466,
                "title": "easy-python-solution-with-heap",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n*logK)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n# Code\\n```\\nclass Solution:\\n    def pickGifts(self, gifts: List[int], k: int) -> int:\\n        heap = [-1*x for x in gifts]\\n        heapq.heapify(heap)\\n        for i in range(k):\\n            a = heapq.heappop(heap)\\n            a = int(sqrt(-a))\\n            heapq.heappush(heap, -a)\\n\\n        return -sum(heap)\\n        \\n        \\n\\n        \\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def pickGifts(self, gifts: List[int], k: int) -> int:\\n        heap = [-1*x for x in gifts]\\n        heapq.heapify(heap)\\n        for i in range(k):\\n            a = heapq.heappop(heap)\\n            a = int(sqrt(-a))\\n            heapq.heappush(heap, -a)\\n\\n        return -sum(heap)\\n        \\n        \\n\\n        \\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 4001133,
                "title": "python-solution-simple-explained",
                "content": "# Intuition\\nFirst thing was abstraction - when you dumb it down, all you need to do is sqaure root the largest value in the array \"k\" number of times...\\n\\n# Approach\\nSo I begin by finding the largest value of the array by using the \"max()\" function, then setting that numbers index under the variable \"largest\". I then square root that index\\'s value, and do that k times.\\n\\nThe second for loop simply goes through the list in sequence adding the values together so that I can return the answer.\\n\\n# Complexity\\n- Time complexity: Quite slow at 81ms, only beats 35.94%\\n\\n- Space complexity: Very efficient, beats 95.31%\\n\\n# Code\\n```\\nclass Solution(object):\\n    def pickGifts(self, gifts, k):\\n        \"\"\"\\n        :type gifts: List[int]\\n        :type k: int\\n        :rtype: int\\n        \"\"\"\\n        import math\\n        for i in range(k):\\n            largest = gifts.index(max(gifts))\\n            gifts[largest] = int(math.sqrt(gifts[largest]))\\n\\n        remaining = 0\\n        for i in range(len(gifts)):\\n            remaining += gifts[i]\\n\\n        return remaining\\n        \\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution(object):\\n    def pickGifts(self, gifts, k):\\n        \"\"\"\\n        :type gifts: List[int]\\n        :type k: int\\n        :rtype: int\\n        \"\"\"\\n        import math\\n        for i in range(k):\\n            largest = gifts.index(max(gifts))\\n            gifts[largest] = int(math.sqrt(gifts[largest]))\\n\\n        remaining = 0\\n        for i in range(len(gifts)):\\n            remaining += gifts[i]\\n\\n        return remaining\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3996363,
                "title": "using-heap",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long pickGifts(vector<int>& gifts, int k) {\\n        priority_queue<int>pq(gifts.begin(),gifts.end());\\n        int m;\\n        while(k>0)\\n        {\\n            m=pq.top();\\n            pq.pop();\\n            pq.push(sqrt(m));\\n            k--;\\n        }\\n        long long sum=0;\\n        while(!pq.empty())\\n        {\\n            sum+=pq.top();\\n            pq.pop();\\n        }\\n        return sum;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long pickGifts(vector<int>& gifts, int k) {\\n        priority_queue<int>pq(gifts.begin(),gifts.end());\\n        int m;\\n        while(k>0)\\n        {\\n            m=pq.top();\\n            pq.pop();\\n            pq.push(sqrt(m));\\n            k--;\\n        }\\n        long long sum=0;\\n        while(!pq.empty())\\n        {\\n            sum+=pq.top();\\n            pq.pop();\\n        }\\n        return sum;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3989070,
                "title": "javascript-heap-with-binary-search",
                "content": "# Code\\n```\\nvar pickGifts = function(gifts, k) {\\n    const pushToHeap = (val, arr) => {\\n        let low = 0;\\n        let high = arr.length;\\n        while (low < high) {\\n            let mid = (low + high) >> 1;\\n            if (val > arr[mid]) {\\n                low = mid + 1;\\n            } else {\\n                high = mid;\\n            }\\n        }\\n        arr.splice(low, 0, val);\\n    }\\n    let heap = [];\\n    for (let gift of gifts) pushToHeap(gift, heap);\\n    while (k--) {\\n        pushToHeap(Math.floor(Math.sqrt(heap.pop())), heap);\\n    }\\n    return heap.reduce((a, b) => a + b, 0);\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar pickGifts = function(gifts, k) {\\n    const pushToHeap = (val, arr) => {\\n        let low = 0;\\n        let high = arr.length;\\n        while (low < high) {\\n            let mid = (low + high) >> 1;\\n            if (val > arr[mid]) {\\n                low = mid + 1;\\n            } else {\\n                high = mid;\\n            }\\n        }\\n        arr.splice(low, 0, val);\\n    }\\n    let heap = [];\\n    for (let gift of gifts) pushToHeap(gift, heap);\\n    while (k--) {\\n        pushToHeap(Math.floor(Math.sqrt(heap.pop())), heap);\\n    }\\n    return heap.reduce((a, b) => a + b, 0);\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3965547,
                "title": "using-max-heap-or-priority-queue",
                "content": "# Intuition\\nYou have to get the maximum number each time.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nTaking a max heap or priority queue by storing numbers in ascending orders and polling from it each time, decrementing k.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(nlog(n))\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n# Code\\n```\\nclass Solution {\\n    public long pickGifts(int[] gifts, int k) {\\n        PriorityQueue<Integer> queue = new PriorityQueue<Integer>((a, b) -> b - a);\\n        for (int gift : gifts) {\\n            queue.add(gift);\\n        }\\n        while (k > 0) {\\n            int n = queue.poll();\\n            queue.add((int)(Math.sqrt(n * 1.0)));\\n            k--;\\n        }\\n        long result = 0;\\n        while (queue.size() > 0) {\\n            result += queue.poll();\\n        }\\n        return result;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\n    public long pickGifts(int[] gifts, int k) {\\n        PriorityQueue<Integer> queue = new PriorityQueue<Integer>((a, b) -> b - a);\\n        for (int gift : gifts) {\\n            queue.add(gift);\\n        }\\n        while (k > 0) {\\n            int n = queue.poll();\\n            queue.add((int)(Math.sqrt(n * 1.0)));\\n            k--;\\n        }\\n        long result = 0;\\n        while (queue.size() > 0) {\\n            result += queue.poll();\\n        }\\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3965089,
                "title": "100-memory-solution-on-go-7ms-2-70mb",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nfunc pickGifts(gifts []int, k int) int64 {\\n\\n\\tfor i := 0; i < k; i++ {\\n\\t\\tmaxVal := gifts[0]\\n\\t\\tmaxIndex := 0\\n\\t\\tfor index, value := range gifts {\\n\\t\\t\\tif value > maxVal {\\n\\t\\t\\t\\tmaxVal = value\\n\\t\\t\\t\\tmaxIndex = index\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tnum := math.Sqrt(float64(maxVal))\\n\\t\\tgifts[maxIndex] = int(num)\\n\\t}\\n\\n\\tcount := 0\\n\\tfor _, v := range gifts {\\n\\t\\tcount += v\\n\\t}\\n\\n\\treturn int64(count)\\n}\\n\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc pickGifts(gifts []int, k int) int64 {\\n\\n\\tfor i := 0; i < k; i++ {\\n\\t\\tmaxVal := gifts[0]\\n\\t\\tmaxIndex := 0\\n\\t\\tfor index, value := range gifts {\\n\\t\\t\\tif value > maxVal {\\n\\t\\t\\t\\tmaxVal = value\\n\\t\\t\\t\\tmaxIndex = index\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tnum := math.Sqrt(float64(maxVal))\\n\\t\\tgifts[maxIndex] = int(num)\\n\\t}\\n\\n\\tcount := 0\\n\\tfor _, v := range gifts {\\n\\t\\tcount += v\\n\\t}\\n\\n\\treturn int64(count)\\n}\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3953813,
                "title": "max-heap-java",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public long pickGifts(int[] gifts, int k) {\\n        \\n        long sum = 0;\\n        int temp = k;\\n        \\n        PriorityQueue<Integer> que = new PriorityQueue<>((a,b)->(b-a));\\n\\n        for(int val : gifts) {\\n             que.add(val);\\n        }\\n\\n        while(!que.isEmpty() && k>0) {\\n            int val = que.remove();\\n            int sqrt = (int)(Math.sqrt(val));\\n          //  System.out.println(val+\"->\"+sqrt);\\n            que.add(sqrt);\\n            k--;\\n        }\\n\\n        while(!que.isEmpty()) {\\n            sum += que.remove();\\n        }\\n\\n\\n        return sum;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public long pickGifts(int[] gifts, int k) {\\n        \\n        long sum = 0;\\n        int temp = k;\\n        \\n        PriorityQueue<Integer> que = new PriorityQueue<>((a,b)->(b-a));\\n\\n        for(int val : gifts) {\\n             que.add(val);\\n        }\\n\\n        while(!que.isEmpty() && k>0) {\\n            int val = que.remove();\\n            int sqrt = (int)(Math.sqrt(val));\\n          //  System.out.println(val+\"->\"+sqrt);\\n            que.add(sqrt);\\n            k--;\\n        }\\n\\n        while(!que.isEmpty()) {\\n            sum += que.remove();\\n        }\\n\\n\\n        return sum;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3953688,
                "title": "java-solution-beats-97-of-other-solutionsp",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n    Traking max element in arr\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n    Solved using priority queue\\n# Code\\n```\\nclass Solution {\\npublic long pickGifts(int[] gifts, int k) {\\n        PriorityQueue<int[]> pq = new PriorityQueue<>((o1, o2) ->{\\n            if(o1[1] > o2[1]){\\n                return -1;\\n            }\\n            else\\n                return 1;\\n        });\\n\\n        for (int i = 0; i < gifts.length; i++) {\\n            int[] ele = new int[]{i,gifts[i]};\\n            pq.add(ele);\\n        }\\n\\n        while (k > 0){\\n            int[] ele = pq.poll();\\n            int[] eleIns = new int[]{\\n                    ele[0]\\n                    ,\\n                    (int)Math.sqrt(ele[1])\\n            };\\n\\n            gifts[ele[0]] = eleIns[1];\\n\\n            pq.add(\\n                    eleIns\\n            );\\n\\n            k--;\\n        }\\n        long ans = 0;\\n\\n        for (int i = 0; i < gifts.length; i++) {\\n            ans += gifts[i];\\n        }\\n        \\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\npublic long pickGifts(int[] gifts, int k) {\\n        PriorityQueue<int[]> pq = new PriorityQueue<>((o1, o2) ->{\\n            if(o1[1] > o2[1]){\\n                return -1;\\n            }\\n            else\\n                return 1;\\n        });\\n\\n        for (int i = 0; i < gifts.length; i++) {\\n            int[] ele = new int[]{i,gifts[i]};\\n            pq.add(ele);\\n        }\\n\\n        while (k > 0){\\n            int[] ele = pq.poll();\\n            int[] eleIns = new int[]{\\n                    ele[0]\\n                    ,\\n                    (int)Math.sqrt(ele[1])\\n            };\\n\\n            gifts[ele[0]] = eleIns[1];\\n\\n            pq.add(\\n                    eleIns\\n            );\\n\\n            k--;\\n        }\\n        long ans = 0;\\n\\n        for (int i = 0; i < gifts.length; i++) {\\n            ans += gifts[i];\\n        }\\n        \\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3951883,
                "title": "easy-to-understand-python3-solution-tc-o-k-log-n-sc-o-1",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def pickGifts(self, gifts: List[int], k: int) -> int:\\n        while k:\\n            gifts.sort()\\n            gifts[-1] = int(math.sqrt(gifts[-1]))\\n            k -= 1\\n        \\n        return sum(gifts)\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def pickGifts(self, gifts: List[int], k: int) -> int:\\n        while k:\\n            gifts.sort()\\n            gifts[-1] = int(math.sqrt(gifts[-1]))\\n            k -= 1\\n        \\n        return sum(gifts)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3936012,
                "title": "easy-java-solution-priority-queue-beats-98",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public long pickGifts(int[] arr, int k) {\\n        PriorityQueue<Integer> pq = new PriorityQueue<>(Comparator.reverseOrder());\\n\\n        for(int i=0; i<arr.length; i++){\\n            pq.add(arr[i]);\\n        }\\n\\n        while(k>0){\\n            int a = pq.remove();\\n            int b = (int)Math.floor(Math.sqrt(a*1.0));\\n            pq.add(b);\\n            k--;\\n        }\\n\\n        long ans = 0;\\n\\n        for(var a : pq){\\n            ans+=a;\\n        }\\n\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public long pickGifts(int[] arr, int k) {\\n        PriorityQueue<Integer> pq = new PriorityQueue<>(Comparator.reverseOrder());\\n\\n        for(int i=0; i<arr.length; i++){\\n            pq.add(arr[i]);\\n        }\\n\\n        while(k>0){\\n            int a = pq.remove();\\n            int b = (int)Math.floor(Math.sqrt(a*1.0));\\n            pq.add(b);\\n            k--;\\n        }\\n\\n        long ans = 0;\\n\\n        for(var a : pq){\\n            ans+=a;\\n        }\\n\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3922938,
                "title": "python3-easy-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nRun for loop untill k \\neach time we need to get the highest element from the list\\ndo the sqaure root operation and append the new element and delete the old one\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n        order of n\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nimport math \\nclass Solution:\\n    def pickGifts(self, gifts: List[int], k: int) -> int:\\n        for i in range(0,k):\\n            max1=max(gifts)\\n            b=floor(math.sqrt(max1))\\n            gifts.append(b)\\n            gifts.remove(max1)\\n        return sum(gifts)\\n\\n\\n\\n\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nimport math \\nclass Solution:\\n    def pickGifts(self, gifts: List[int], k: int) -> int:\\n        for i in range(0,k):\\n            max1=max(gifts)\\n            b=floor(math.sqrt(max1))\\n            gifts.append(b)\\n            gifts.remove(max1)\\n        return sum(gifts)\\n\\n\\n\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3921039,
                "title": "java-solution-using-priority-queue",
                "content": "```\\nclass Solution {\\n    public long pickGifts(int[] gifts, int k) {\\n        PriorityQueue<Integer> pq = new PriorityQueue<>((a, b) -> (b - a));\\n        long res = 0;\\n\\n        for (int i = 0; i < gifts.length; i++) {\\n            pq.add(gifts[i]);\\n        }\\n        while (!pq.isEmpty() && k > 0) {\\n            long val = pq.poll();\\n            int newVal = (int) Math.sqrt(val);\\n            pq.add(newVal);\\n            k--;\\n        }\\n\\n        while (!pq.isEmpty()) {\\n            res += pq.poll();\\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\n    public long pickGifts(int[] gifts, int k) {\\n        PriorityQueue<Integer> pq = new PriorityQueue<>((a, b) -> (b - a));\\n        long res = 0;\\n\\n        for (int i = 0; i < gifts.length; i++) {\\n            pq.add(gifts[i]);\\n        }\\n        while (!pq.isEmpty() && k > 0) {\\n            long val = pq.poll();\\n            int newVal = (int) Math.sqrt(val);\\n            pq.add(newVal);\\n            k--;\\n        }\\n\\n        while (!pq.isEmpty()) {\\n            res += pq.poll();\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3905479,
                "title": "c-o-nlogn-best-solution-explained-short-priority-queue",
                "content": "# Intuition\\nIncase anyone is wondering what\\'s the question and why the test case seems wrong, here\\'s the explanation : \\n\\nThe thing is: you have to always look at the array and reconsider ALL values, INCLUDING the values that you\\'ve already handled.\\n\\ngifts = [25,64,9,4,100]\\n\\nk = 1, max is 100, so we replace it with sqrt(100)\\ngifts = [25,64,9,4,10]\\n\\nk = 2, max is 64, so we replace it with sqrt(64)\\ngifts = [25,8,9,4,10]\\n\\nk = 3, max is 25, so we replace it with sqrt(25)\\ngifts = [5,8,9,4,10]\\n\\nTHIS IS WHERE IT\\'S CONFUSING:\\nk = 4, max is ..not 9, it\\'s the value we modified at step k = 1, aka 10,\\nso we replace this max value with floor of sqrt(10) = 3\\ngifts = [5,8,9,4,3]\\n\\nNow add all vals, and you get 5 + 8 + 9 + 4 + 3 = 29\\n\\nThat\\'s what leetcode forget to tell about\\n# Approach\\napproach is simple first we are creating a max heap and inserting all the elements in it. \\n\\nThen we are poping the top of heap which is indeed max element and inserting it\\'s square root in the array. In this approach if there is any previously handled value seems greater then the rest of the elements at any point the heap algo will push it on the top of heap in advance and by this all the cases will be handled smoothly automatically. Don\\'t forget you have to take only top k elemnts and do the square root of them.\\n\\nNow we are just adding all the values remaining in our heap i.e. gifts remaining after k seconds .This is the answer.\\n# Complexity\\n- Time complexity:\\n$$O(nlogn)$$ \\n\\n- Space complexity:\\n$$O(n)$$\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long pickGifts(vector<int>& gifts, int k) {\\n        priority_queue<int>maxh;\\n\\n        //inserting all the elements to priority queue\\n        for(int i=0;i<gifts.size();i++)\\n        {\\n            maxh.push(gifts[i]);\\n        }\\n        //removing top pile and filling it with the sqrt of max element remaining in priority queue\\n        while(k--)\\n        {\\n            int x=maxh.top();\\n            maxh.pop();\\n            maxh.push(sqrt(x));\\n        }\\n\\n        long long ans=0;\\n\\n        //sum up all the remaining elements which is our answer.\\n        while(maxh.size()>0)\\n        {\\n            ans+=maxh.top();\\n            maxh.pop();\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long pickGifts(vector<int>& gifts, int k) {\\n        priority_queue<int>maxh;\\n\\n        //inserting all the elements to priority queue\\n        for(int i=0;i<gifts.size();i++)\\n        {\\n            maxh.push(gifts[i]);\\n        }\\n        //removing top pile and filling it with the sqrt of max element remaining in priority queue\\n        while(k--)\\n        {\\n            int x=maxh.top();\\n            maxh.pop();\\n            maxh.push(sqrt(x));\\n        }\\n\\n        long long ans=0;\\n\\n        //sum up all the remaining elements which is our answer.\\n        while(maxh.size()>0)\\n        {\\n            ans+=maxh.top();\\n            maxh.pop();\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3901363,
                "title": "python-beginner-friendly",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def pickGifts(self, gifts: List[int], k: int) -> int:\\n        for x in range(k):\\n            max_pile = max(gifts)\\n            sqrt_floor_maxpile = math.floor(math.sqrt(max_pile))\\n            gifts.append(sqrt_floor_maxpile)\\n            gifts.remove(max_pile)\\n        return sum(gifts)\\n```",
                "solutionTags": [
                    "Python3",
                    "Math"
                ],
                "code": "```\\nclass Solution:\\n    def pickGifts(self, gifts: List[int], k: int) -> int:\\n        for x in range(k):\\n            max_pile = max(gifts)\\n            sqrt_floor_maxpile = math.floor(math.sqrt(max_pile))\\n            gifts.append(sqrt_floor_maxpile)\\n            gifts.remove(max_pile)\\n        return sum(gifts)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3892584,
                "title": "easy-js-solution",
                "content": "\\n\\n# Code\\n```\\n/**\\n * @param {number[]} gifts\\n * @param {number} k\\n * @return {number}\\n */\\nvar pickGifts = function(gifts, k) {\\n    \\nfor(let i = 1; i <= k; i++) {\\n//Get max num\\n  let max = Math.max(...gifts);\\n//Get square root of max num\\n  let sqrt = Math.floor(Math.sqrt(max));\\n//Get index of num\\n  let ind = gifts.indexOf(max);\\n//Change num in arr to sqrt num\\n  gifts[ind] = sqrt; \\n}\\n\\n//add all nums in array up\\nlet ans = gifts.reduce((num, acc) => {\\n    return num + acc\\n}, 0);\\n\\nreturn ans\\n};\\n\\n\\n\\n\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} gifts\\n * @param {number} k\\n * @return {number}\\n */\\nvar pickGifts = function(gifts, k) {\\n    \\nfor(let i = 1; i <= k; i++) {\\n//Get max num\\n  let max = Math.max(...gifts);\\n//Get square root of max num\\n  let sqrt = Math.floor(Math.sqrt(max));\\n//Get index of num\\n  let ind = gifts.indexOf(max);\\n//Change num in arr to sqrt num\\n  gifts[ind] = sqrt; \\n}\\n\\n//add all nums in array up\\nlet ans = gifts.reduce((num, acc) => {\\n    return num + acc\\n}, 0);\\n\\nreturn ans\\n};\\n\\n\\n\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3891832,
                "title": "easy-c-priority-queue-max-heap-sqrt-function",
                "content": "**CODE**\\n```\\nclass Solution {\\npublic:\\n    long long pickGifts(vector<int>& gifts, int k) {\\n        priority_queue<long long> q;\\n        long long ans=0;\\n        for(int i=0; i<gifts.size(); i++){\\n            q.push(gifts[i]);\\n            ans+=gifts[i];\\n        }\\n        \\n        while(k--){\\n            long long val=q.top();\\n            int g= floor((double) sqrt(val));\\n            ans = ans - val + g;\\n            q.pop();\\n            q.push(g);\\n        }\\n        return ans;\\n    }\\n};",
                "solutionTags": [
                    "Heap (Priority Queue)"
                ],
                "code": "class Solution {\\npublic:\\n    long long pickGifts(vector<int>& gifts, int k) {\\n        priority_queue<long long> q;\\n        long long ans=0;\\n        for(int i=0; i<gifts.size(); i++){\\n            q.push(gifts[i]);\\n            ans+=gifts[i];\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 3891076,
                "title": "easy-to-understand-best-solution-in-c",
                "content": "\\n# C++\\n```\\nclass Solution {\\npublic:\\n    long long pickGifts(vector<int>& gifts, int k) {\\n        priority_queue <int> pq;\\n        long long a = 0; \\n\\n        for (int i : gifts) {\\n            pq.push(i);\\n        }\\n        for(int i = 0; i < k; i++) {\\n            int p = sqrt(pq.top());\\n            pq.pop();\\n            pq.push(p);\\n        }\\n        while(!pq.empty()) {\\n            a = a + pq.top();\\n            pq.pop();\\n        }\\n        return a;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long pickGifts(vector<int>& gifts, int k) {\\n        priority_queue <int> pq;\\n        long long a = 0; \\n\\n        for (int i : gifts) {\\n            pq.push(i);\\n        }\\n        for(int i = 0; i < k; i++) {\\n            int p = sqrt(pq.top());\\n            pq.pop();\\n            pq.push(p);\\n        }\\n        while(!pq.empty()) {\\n            a = a + pq.top();\\n            pq.pop();\\n        }\\n        return a;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3885388,
                "title": "take-gifts",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def pickGifts(self, gifts: List[int], k: int) -> int:\\n        for k in range(k,0,-1):\\n            gifts[gifts.index(max(gifts))]=int(max(gifts)**0.5)\\n        return sum(gifts)\\n```",
                "solutionTags": [
                    "Python3",
                    "Heap (Priority Queue)",
                    "Simulation"
                ],
                "code": "```\\nclass Solution:\\n    def pickGifts(self, gifts: List[int], k: int) -> int:\\n        for k in range(k,0,-1):\\n            gifts[gifts.index(max(gifts))]=int(max(gifts)**0.5)\\n        return sum(gifts)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3863704,
                "title": "c-max-heap-solution",
                "content": "# Code\\n```\\npublic class Solution {\\n    public long PickGifts(int[] gifts, int k) {\\n\\n        var maxHeap = new PriorityQueue<long, long>(Comparer<long>.Create((x, y) => y.CompareTo(x)));\\n\\n        foreach(var gift in gifts) \\n            maxHeap.Enqueue((long)gift, (long)gift);\\n\\n        while(maxHeap.Count > 0 && k > 0) {\\n             double num = Math.Floor(Math.Sqrt((double)maxHeap.Dequeue()));\\n             maxHeap.Enqueue((long)num, (long)num);\\n             k--;\\n        }\\n\\n        long sum = 0;\\n\\n        while(maxHeap.Count > 0)\\n            sum += maxHeap.Dequeue();\\n        \\n        return sum;\\n    }\\n}\\n\\n// [5,8,9,4,3]\\n\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution {\\n    public long PickGifts(int[] gifts, int k) {\\n\\n        var maxHeap = new PriorityQueue<long, long>(Comparer<long>.Create((x, y) => y.CompareTo(x)));\\n\\n        foreach(var gift in gifts) \\n            maxHeap.Enqueue((long)gift, (long)gift);\\n\\n        while(maxHeap.Count > 0 && k > 0) {\\n             double num = Math.Floor(Math.Sqrt((double)maxHeap.Dequeue()));\\n             maxHeap.Enqueue((long)num, (long)num);\\n             k--;\\n        }\\n\\n        long sum = 0;\\n\\n        while(maxHeap.Count > 0)\\n            sum += maxHeap.Dequeue();\\n        \\n        return sum;\\n    }\\n}\\n\\n// [5,8,9,4,3]\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3861052,
                "title": "java-5ms-beats-98-53",
                "content": "# Intuition & Approach\\nPerform simulation using priority queue\\n\\n# Complexity\\n- Time complexity: O(n log n) (for priority queue)\\n\\n- Space complexity: O(n)\\n\\n\\n# Code\\n```\\n// 5ms Beats 98.53%\\n\\nclass Solution {\\n    public long pickGifts(int[] gifts, int k) {\\n\\n        long numGiftsRemaining = 0L;  // what we\\'ll return\\n\\n        PriorityQueue<Integer> pq = new PriorityQueue<>(Collections.reverseOrder());\\n\\n        for (int g : gifts) {\\n            pq.add(g);\\n            numGiftsRemaining += g;\\n        }\\n\\n        while (k > 0 && pq.peek() != 1) {\\n            int curPile = pq.poll();\\n            int toLeave = floorOfSquareRoot(curPile);\\n            int toTake = curPile - toLeave;\\n            pq.add(toLeave);\\n            numGiftsRemaining -= toTake;\\n            --k;\\n        }\\n\\n        return numGiftsRemaining;\\n    }\\n\\n    private int floorOfSquareRoot(int n) {\\n        return (int)Math.sqrt(n);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n// 5ms Beats 98.53%\\n\\nclass Solution {\\n    public long pickGifts(int[] gifts, int k) {\\n\\n        long numGiftsRemaining = 0L;  // what we\\'ll return\\n\\n        PriorityQueue<Integer> pq = new PriorityQueue<>(Collections.reverseOrder());\\n\\n        for (int g : gifts) {\\n            pq.add(g);\\n            numGiftsRemaining += g;\\n        }\\n\\n        while (k > 0 && pq.peek() != 1) {\\n            int curPile = pq.poll();\\n            int toLeave = floorOfSquareRoot(curPile);\\n            int toTake = curPile - toLeave;\\n            pq.add(toLeave);\\n            numGiftsRemaining -= toTake;\\n            --k;\\n        }\\n\\n        return numGiftsRemaining;\\n    }\\n\\n    private int floorOfSquareRoot(int n) {\\n        return (int)Math.sqrt(n);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3857117,
                "title": "max-heap",
                "content": "# Code\\n```\\nclass Solution:\\n    def pickGifts(self, gifts: List[int], k: int) -> int:\\n        gifts = [-1 * i for i in gifts]\\n        heapq.heapify(gifts)\\n        for _ in range(k):\\n            item = heapq.heappop(gifts)\\n            heapq.heappush(gifts, -1 * int((-1 * item) ** 0.5))\\n        return sum((-1 * i for i in gifts))\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def pickGifts(self, gifts: List[int], k: int) -> int:\\n        gifts = [-1 * i for i in gifts]\\n        heapq.heapify(gifts)\\n        for _ in range(k):\\n            item = heapq.heappop(gifts)\\n            heapq.heappush(gifts, -1 * int((-1 * item) ** 0.5))\\n        return sum((-1 * i for i in gifts))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3851950,
                "title": "python-heapq-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nimport heapq\\nclass Solution:\\n    def pickGifts(self, gifts: List[int], k: int) -> int:\\n        nums = [-num for num in gifts]\\n        heapq.heapify(nums)\\n        for i in range(k):\\n            max_num = heapq.heappop(nums) * -1\\n            sqrt_num = math.floor((max_num ** 0.5)) * -1\\n            heapq.heappush(nums, sqrt_num)\\n        return sum(nums) * -1\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nimport heapq\\nclass Solution:\\n    def pickGifts(self, gifts: List[int], k: int) -> int:\\n        nums = [-num for num in gifts]\\n        heapq.heapify(nums)\\n        for i in range(k):\\n            max_num = heapq.heappop(nums) * -1\\n            sqrt_num = math.floor((max_num ** 0.5)) * -1\\n            heapq.heappush(nums, sqrt_num)\\n        return sum(nums) * -1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3851423,
                "title": "python-brute-force-max-heap",
                "content": "# **1. BRUTE FORCE APPROACH**\\n\\nIn the Brute Force approach, in each second, we will have to traverse the whole list again to get the new maximum index.\\n\\n```\\ndef pickGifts(self, gifts: List[int], k: int) -> int:\\n        # Length of the list\\n        n = len(gifts)\\n        \\n        # Index of pile with maximum number of gifts\\n        maxIdx = 0\\n        for i in range(n): \\n            if gifts[i] > gifts[maxIdx]: maxIdx = i\\n        \\n        # Run the loop for \"k\" seconds\\n        while k > 0:\\n            \\n            # Now, take the required gifts from index \"maxIdx\"\\n            # And leave behind the floor of sqrt of the gifts[maxIdx]\\n            gifts[maxIdx] = floor(sqrt(gifts[maxIdx]))\\n            \\n            # Now, we want the new maximum index pile\\n            for i in range(n): \\n                if gifts[i] > gifts[maxIdx]: maxIdx = i\\n            \\n            # Reduce the seconds (k)\\n            k -= 1\\n        \\n        # Return the sum of values in the list\\n        return sum(gifts)\\n```\\n\\n# **2. HEAP APPROACH**\\nSince at each second, we want the maximum value in the list, there is one data structure that we can use. It is the Max Heap. So, instead of looping over the list again and again at every second to get the maximum at that point, we let heap do this for us. So, as we push into or pop from the heap, the heap will reorder the elements such that the top of the heap always has the maximum value. \\n\\nNote that in Python, there is no standard Max Heap implementation. So, we can use a Min heap but when we push elements, we will first change their signs and then push them which lets us use the MinHeap as a MaxHeap in Python.\\n\\n```\\ndef pickGifts(self, gifts: List[int], k: int) -> int:\\n        # Length of the list\\n        n = len(gifts)\\n        \\n        # Since at each second, we want the maximum value in the list\\n        # We can use a MaxHeap here which has the max value at any time on top\\n        maxHeap = []\\n        for gift in gifts: heappush(maxHeap, -gift)\\n            \\n        while k > 0:\\n            \\n            # Pop the top element (maximum gifts at this point)\\n            maxGifts = -heappop(maxHeap)\\n            \\n            # Leave behind the floor of the square root of the number of gifts\\n            giftsLeftBehind = floor(sqrt(maxGifts))\\n            \\n            # Push back\\n            heappush(maxHeap, -giftsLeftBehind)\\n            \\n            # If the number of gifts left behind are same as previous value, break early\\n            # Since in all next seconds, this index will always be the maximum\\n            # And in all cases, we will not take any gifts at all form this pile\\n            if giftsLeftBehind == maxGifts: break\\n            \\n            # Decrement k\\n            k -= 1\\n        \\n        \\n        # Get the sum of values in the maxHeap\\n        finalSum = 0\\n        while maxHeap: finalSum += -heappop(maxHeap)\\n        \\n        # Return the sum of values in the maxHeap\\n        return finalSum\\n```",
                "solutionTags": [
                    "Python",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\ndef pickGifts(self, gifts: List[int], k: int) -> int:\\n        # Length of the list\\n        n = len(gifts)\\n        \\n        # Index of pile with maximum number of gifts\\n        maxIdx = 0\\n        for i in range(n): \\n            if gifts[i] > gifts[maxIdx]: maxIdx = i\\n        \\n        # Run the loop for \"k\" seconds\\n        while k > 0:\\n            \\n            # Now, take the required gifts from index \"maxIdx\"\\n            # And leave behind the floor of sqrt of the gifts[maxIdx]\\n            gifts[maxIdx] = floor(sqrt(gifts[maxIdx]))\\n            \\n            # Now, we want the new maximum index pile\\n            for i in range(n): \\n                if gifts[i] > gifts[maxIdx]: maxIdx = i\\n            \\n            # Reduce the seconds (k)\\n            k -= 1\\n        \\n        # Return the sum of values in the list\\n        return sum(gifts)\\n```\n```\\ndef pickGifts(self, gifts: List[int], k: int) -> int:\\n        # Length of the list\\n        n = len(gifts)\\n        \\n        # Since at each second, we want the maximum value in the list\\n        # We can use a MaxHeap here which has the max value at any time on top\\n        maxHeap = []\\n        for gift in gifts: heappush(maxHeap, -gift)\\n            \\n        while k > 0:\\n            \\n            # Pop the top element (maximum gifts at this point)\\n            maxGifts = -heappop(maxHeap)\\n            \\n            # Leave behind the floor of the square root of the number of gifts\\n            giftsLeftBehind = floor(sqrt(maxGifts))\\n            \\n            # Push back\\n            heappush(maxHeap, -giftsLeftBehind)\\n            \\n            # If the number of gifts left behind are same as previous value, break early\\n            # Since in all next seconds, this index will always be the maximum\\n            # And in all cases, we will not take any gifts at all form this pile\\n            if giftsLeftBehind == maxGifts: break\\n            \\n            # Decrement k\\n            k -= 1\\n        \\n        \\n        # Get the sum of values in the maxHeap\\n        finalSum = 0\\n        while maxHeap: finalSum += -heappop(maxHeap)\\n        \\n        # Return the sum of values in the maxHeap\\n        return finalSum\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3849125,
                "title": "simple-js-approach-using-math-functions-beats-87-users-runtime-in-js",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {number[]} gifts\\n * @param {number} k\\n * @return {number}\\n */\\nvar pickGifts = function(gifts, k) {\\n    var i,max,idx,sum=0;\\n    while(k){\\n        max=Math.max(...gifts);\\n        idx=gifts.indexOf(max);\\n        max=Math.floor(Math.sqrt(max));\\n        gifts[idx]=max;\\n        k--;\\n    }\\n    for(i=0;i<gifts.length;i++){\\n        sum+=gifts[i];\\n    }\\n    return sum;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} gifts\\n * @param {number} k\\n * @return {number}\\n */\\nvar pickGifts = function(gifts, k) {\\n    var i,max,idx,sum=0;\\n    while(k){\\n        max=Math.max(...gifts);\\n        idx=gifts.indexOf(max);\\n        max=Math.floor(Math.sqrt(max));\\n        gifts[idx]=max;\\n        k--;\\n    }\\n    for(i=0;i<gifts.length;i++){\\n        sum+=gifts[i];\\n    }\\n    return sum;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3848606,
                "title": "beats-100-simple-approach",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nSort the gifts array in increasing order. Start a loop from 0 to k. The last element in gifts array will be biggest, pop it out , take sqrt of it. Now insert the sqrt back into gifts array such that gifts array remains sorted.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {number[]} gifts\\n * @param {number} k\\n * @return {number}\\n */\\nvar pickGifts = function(gifts, k) {\\n    gifts.sort((a,b)=>a-b);\\n    for(let j=0; j<k; j++){\\n        let pile = gifts.pop();\\n        let pile_left = Math.floor(Math.sqrt(pile));\\n        gifts = insert_pile_left(gifts,pile_left)\\n    }\\n    let sum = gifts.reduce((a,b)=>a+b);\\n    return sum;\\n};\\n\\nvar insert_pile_left = function(arr,num){\\n    let check = false;\\n    for(let i=0; i<arr.length; i++){\\n        if(arr[i]>num){\\n            arr.splice(i,0,num);\\n            check = true;\\n            break;\\n        }\\n    }\\n    if(!check) arr.push(num)\\n    return arr;\\n};\\n\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} gifts\\n * @param {number} k\\n * @return {number}\\n */\\nvar pickGifts = function(gifts, k) {\\n    gifts.sort((a,b)=>a-b);\\n    for(let j=0; j<k; j++){\\n        let pile = gifts.pop();\\n        let pile_left = Math.floor(Math.sqrt(pile));\\n        gifts = insert_pile_left(gifts,pile_left)\\n    }\\n    let sum = gifts.reduce((a,b)=>a+b);\\n    return sum;\\n};\\n\\nvar insert_pile_left = function(arr,num){\\n    let check = false;\\n    for(let i=0; i<arr.length; i++){\\n        if(arr[i]>num){\\n            arr.splice(i,0,num);\\n            check = true;\\n            break;\\n        }\\n    }\\n    if(!check) arr.push(num)\\n    return arr;\\n};\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3845849,
                "title": "max-heap-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: \\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long pickGifts(vector<int>& gifts, int k) {\\n        \\n        long long int result = 0;\\n        priority_queue<int> pq(gifts.begin(), gifts.end());\\n\\n        while(k--) {\\n\\n            int max = pq.top(); \\n            pq.pop();\\n            pq.push(sqrt(max));\\n        }\\n\\n        while(!pq.empty()) {\\n            result += pq.top();\\n            pq.pop();\\n        }   \\n\\n        return result;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long pickGifts(vector<int>& gifts, int k) {\\n        \\n        long long int result = 0;\\n        priority_queue<int> pq(gifts.begin(), gifts.end());\\n\\n        while(k--) {\\n\\n            int max = pq.top(); \\n            pq.pop();\\n            pq.push(sqrt(max));\\n        }\\n\\n        while(!pq.empty()) {\\n            result += pq.top();\\n            pq.pop();\\n        }   \\n\\n        return result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3827573,
                "title": "solution-for-beginners",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def pickGifts(self, gifts: List[int], k: int) -> int:\\n        a=[]\\n        b=[]\\n        for i in range(0,k) :\\n            c=gifts\\n            # c.replace(max(gifts),sqrt(max(gifts)))\\n            c.append(sqrt(max(c))//1)\\n            c.remove(max(c))\\n            gifts=c\\n        return int(sum(c))\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def pickGifts(self, gifts: List[int], k: int) -> int:\\n        a=[]\\n        b=[]\\n        for i in range(0,k) :\\n            c=gifts\\n            # c.replace(max(gifts),sqrt(max(gifts)))\\n            c.append(sqrt(max(c))//1)\\n            c.remove(max(c))\\n            gifts=c\\n        return int(sum(c))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3818784,
                "title": "very-easy-to-understand-cpp-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long pickGifts(vector<int>& gifts, int k) {\\n        priority_queue<int>pq;\\n        for(auto i:gifts)pq.push(i);\\n        for(int i=0;i<k;i++)\\n        {\\n            int top=pq.top();\\n            pq.pop();\\n            pq.push(sqrt(top));\\n        }\\n       long long ans=0;\\n        while(!pq.empty())\\n        {\\n            ans+=pq.top();\\n            pq.pop();\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long pickGifts(vector<int>& gifts, int k) {\\n        priority_queue<int>pq;\\n        for(auto i:gifts)pq.push(i);\\n        for(int i=0;i<k;i++)\\n        {\\n            int top=pq.top();\\n            pq.pop();\\n            pq.push(sqrt(top));\\n        }\\n       long long ans=0;\\n        while(!pq.empty())\\n        {\\n            ans+=pq.top();\\n            pq.pop();\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3816307,
                "title": "c-maxheap",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long pickGifts(vector<int>& gifts, int k) {\\n        \\n        priority_queue<int> maxheap;\\n\\n        for( auto it : gifts) maxheap.push(it);\\n\\n        for( int i =0; i< k; i++){\\n\\n            int temp = maxheap.top();\\n            maxheap.pop();\\n            \\n            maxheap.push( sqrt(temp) );\\n        }\\n        long long ans =0;\\n\\n        while( maxheap.size() >0){\\n\\n            ans += maxheap.top();\\n            maxheap.pop();\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long pickGifts(vector<int>& gifts, int k) {\\n        \\n        priority_queue<int> maxheap;\\n\\n        for( auto it : gifts) maxheap.push(it);\\n\\n        for( int i =0; i< k; i++){\\n\\n            int temp = maxheap.top();\\n            maxheap.pop();\\n            \\n            maxheap.push( sqrt(temp) );\\n        }\\n        long long ans =0;\\n\\n        while( maxheap.size() >0){\\n\\n            ans += maxheap.top();\\n            maxheap.pop();\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3811834,
                "title": "dart-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n  int pickGifts(List<int> gifts, int k) {\\n      while (k > 0) {\\n          final maxNum = gifts.reduce(max);\\n          gifts.remove(maxNum);\\n          final res = sqrt(maxNum).toInt();\\n          gifts.add(res);\\n          k -= 1;\\n      }\\n      return gifts.reduce((a, b) => a + b);\\n  }\\n}\\n```",
                "solutionTags": [
                    "Dart"
                ],
                "code": "```\\nclass Solution {\\n  int pickGifts(List<int> gifts, int k) {\\n      while (k > 0) {\\n          final maxNum = gifts.reduce(max);\\n          gifts.remove(maxNum);\\n          final res = sqrt(maxNum).toInt();\\n          gifts.add(res);\\n          k -= 1;\\n      }\\n      return gifts.reduce((a, b) => a + b);\\n  }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3800160,
                "title": "java-solution",
                "content": "# Complexity\\n- Time complexity:O(n)\\n\\n- Space complexity:O(n)\\n# Code\\n```\\nclass Solution {\\n    public long pickGifts(int[] gifts, int k) {\\n        PriorityQueue<Integer> pq=new PriorityQueue<>((a,b)->b-a);\\n        long res=0;\\n        for(int g:gifts) pq.add(g);\\n        while(k--!=0){\\n            int a=pq.poll();\\n            pq.add((int)Math.floor((int)Math.sqrt(a)));\\n        }\\n        while(!pq.isEmpty()) res+=pq.poll();\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public long pickGifts(int[] gifts, int k) {\\n        PriorityQueue<Integer> pq=new PriorityQueue<>((a,b)->b-a);\\n        long res=0;\\n        for(int g:gifts) pq.add(g);\\n        while(k--!=0){\\n            int a=pq.poll();\\n            pq.add((int)Math.floor((int)Math.sqrt(a)));\\n        }\\n        while(!pq.isEmpty()) res+=pq.poll();\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3790896,
                "title": "very-easy-maxheap-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long pickGifts(vector<int>& gifts, int k) \\n    {\\n        priority_queue<int>pq;\\n        long long sum=0;\\n        for(int i=0;i<gifts.size();i++)\\n        {\\n            pq.push(gifts[i]);\\n        }\\n        while(k>0)\\n        {\\n            int x=pq.top();\\n            int y=sqrt(x);\\n            pq.pop();\\n            pq.push(y);\\n            k--;\\n        }\\n        while(!pq.empty())\\n        {\\n            sum+=pq.top();\\n            pq.pop();\\n        }\\n        return sum;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long pickGifts(vector<int>& gifts, int k) \\n    {\\n        priority_queue<int>pq;\\n        long long sum=0;\\n        for(int i=0;i<gifts.size();i++)\\n        {\\n            pq.push(gifts[i]);\\n        }\\n        while(k>0)\\n        {\\n            int x=pq.top();\\n            int y=sqrt(x);\\n            pq.pop();\\n            pq.push(y);\\n            k--;\\n        }\\n        while(!pq.empty())\\n        {\\n            sum+=pq.top();\\n            pq.pop();\\n        }\\n        return sum;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3786363,
                "title": "standard-java-solution",
                "content": "### Theory \\nThis is similar to the merge stones problem. Create a Priority Queue and enqueue how many gifts are remaining. Then empty out the queue and add to the total.\\n\\n### Solution\\n```\\n    public long pickGifts(int[] gifts, int k) {\\n        PriorityQueue<Integer> pq = new PriorityQueue<>((a,b)->{\\n            return b - a;\\n        });\\n        for (int i : gifts)\\n            pq.add(i);\\n        \\n        long total = 0;\\n        for (int i = 0; i < k; i++) {\\n            int numGiftsTotal = pq.poll();\\n            int giftsRemain = (int) Math.floor(Math.sqrt(numGiftsTotal));\\n            pq.add(giftsRemain);\\n        }\\n        \\n        while (!pq.isEmpty())\\n            total += pq.poll();\\n\\n        return total;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    public long pickGifts(int[] gifts, int k) {\\n        PriorityQueue<Integer> pq = new PriorityQueue<>((a,b)->{\\n            return b - a;\\n        });\\n        for (int i : gifts)\\n            pq.add(i);\\n        \\n        long total = 0;\\n        for (int i = 0; i < k; i++) {\\n            int numGiftsTotal = pq.poll();\\n            int giftsRemain = (int) Math.floor(Math.sqrt(numGiftsTotal));\\n            pq.add(giftsRemain);\\n        }\\n        \\n        while (!pq.isEmpty())\\n            total += pq.poll();\\n\\n        return total;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3771984,
                "title": "very-easy-solution-using-set-c",
                "content": "# Intuition\\nThe problem requires distributing gifts from the richest pile to the poorer piles. The idea is to pick the largest pile, take its square root, and distribute the result back into the multiset. Repeat this process `k` times. Finally, calculate the sum of all piles and return it.\\n\\n# Approach\\n1. Create a `multiset` named `st` from the given `gifts` vector to store the piles.\\n2. Run a loop `k` times to distribute gifts from the richest pile to the poorer piles.\\n3. In each iteration:\\n   - Get the largest pile\\'s value using `auto it = st.rbegin();`.\\n   - Take the square root of the largest pile\\'s value and store it in `int sqt`.\\n   - Erase the largest pile from the multiset using `st.erase(prev(it.base()))`, and insert `sqt` back into the multiset using `st.insert(sqt)`.\\n4. Calculate the sum of all piles in the multiset using `long long sum = accumulate(st.begin(), st.end(), 0LL);`.\\n5. Return the `sum`.\\n\\n# Complexity\\n- Time complexity: The time complexity of the `pickGifts` function is O(k * log n), where n is the size of the `gifts` vector. In each iteration, the process involves finding the largest element in the multiset (`log n` time), erasing it (`log n` time), and inserting the square root (`log n` time). Since we repeat this process `k` times, the overall time complexity is O(k * log n).\\n- Space complexity: The space complexity is O(n), where n is the size of the `gifts` vector. The `multiset` stores a copy of the `gifts` vector, which takes up additional space.\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long pickGifts(vector<int>& gifts, int k) {\\n        multiset<int> st(gifts.begin(),gifts.end());\\n        while(k){\\n            auto it=st.rbegin();\\n            int sqt=sqrt(*it);\\n            st.erase(prev(it.base()));\\n            st.insert(sqt);\\n            k--;\\n        }\\n        long long sum=accumulate(st.begin(),st.end(),0LL);\\n        return sum;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long pickGifts(vector<int>& gifts, int k) {\\n        multiset<int> st(gifts.begin(),gifts.end());\\n        while(k){\\n            auto it=st.rbegin();\\n            int sqt=sqrt(*it);\\n            st.erase(prev(it.base()));\\n            st.insert(sqt);\\n            k--;\\n        }\\n        long long sum=accumulate(st.begin(),st.end(),0LL);\\n        return sum;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3771770,
                "title": "optimized-gift-picking-algorithm-using-priority-queue",
                "content": "\\n\\n# Optimized Approach\\n\\nInitialize a priority queue pq with the elements of the gifts vector. The priority queue will be in descending order automatically.\\nRun a loop k times to perform the required operations:\\nGet the maximum gift from pq using top().\\nRemove the maximum gift from pq using pop().\\nCalculate the square root of the maximum gift using sqrt() and push it back into pq using push().\\nDecrement k by 1.\\nInitialize the variable ans to store the sum of all the gifts.\\nRun a loop until pq is empty:\\nAdd the top element of pq to ans.\\nRemove the top element from pq.\\nReturn the value of ans.\\nThe optimized solution directly initializes the priority queue pq with the elements of the gifts vector, eliminating the need for multiple insertions. Additionally, it avoids unnecessary operations and calculates the sum of gifts directly from the priority queue.\\n\\nThe time complexity of this optimized solution is O(k log n), where n is the size of the gifts vector.\\n\\n# Complexity\\n- Time complexity: The time complexity of the optimized solution is O(k log n), where n is the size of the `gifts` vector. This is because the algorithm performs k operations, each involving `log n` time for the operations on the priority queue. Thus, the time complexity grows linearly with k and logarithmically with the size of the `gifts` vector.\\n\\n- Space complexity: The space complexity is O(n), where n is the size of the `gifts` vector. This is because the priority queue `pq` stores all the elements from the `gifts` vector, requiring additional space proportional to the input size. The rest of the variables used in the algorithm require constant space and do not contribute significantly to the overall space complexity.\\n\\n# Code\\n```\\n\\n\\nclass Solution {\\npublic:\\n    long long pickGifts(vector<int>& gifts, int k) {\\n        priority_queue<long long> pq(gifts.begin(), gifts.end());\\n\\n        while (k > 0) {\\n            long long maxGift = pq.top();\\n            pq.pop();\\n            pq.push(sqrt(maxGift));\\n            k--;\\n        }\\n\\n        long long ans = 0;\\n        while (!pq.empty()) {\\n            ans += pq.top();\\n            pq.pop();\\n        }\\n\\n        return ans;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n\\n\\nclass Solution {\\npublic:\\n    long long pickGifts(vector<int>& gifts, int k) {\\n        priority_queue<long long> pq(gifts.begin(), gifts.end());\\n\\n        while (k > 0) {\\n            long long maxGift = pq.top();\\n            pq.pop();\\n            pq.push(sqrt(maxGift));\\n            k--;\\n        }\\n\\n        long long ans = 0;\\n        while (!pq.empty()) {\\n            ans += pq.top();\\n            pq.pop();\\n        }\\n\\n        return ans;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3771726,
                "title": "gift-picking-and-modification-algorithm-using-priority-queue",
                "content": "# Intuition\\nThe code appears to be solving a problem related to picking gifts from a vector. The algorithm uses a priority queue to maintain the maximum element at the top. It then performs some operations on the top element and updates the vector accordingly. Finally, it calculates the sum of all the elements in the modified vector and returns the result.\\n\\n# Approach\\nThe approach followed in the code can be summarized as follows:\\n1. Initialize a priority queue `pq` to store the elements in descending order.\\n2. Initialize a variable `ans` to store the sum of the gifts.\\n3. Set `i` to 0 to track the number of iterations.\\n4. Enter a loop that runs `k` times:\\n   a. Iterate over the `gifts` vector and insert each element into the priority queue `pq`.\\n   b. Get the maximum element from `pq` using `top()` and store it in the variable `max`. Remove it from `pq` using `pop()`.\\n   c. Compute the square root of `max` and take the absolute value of the result. Insert it back into `pq` using `push()`.\\n   d. Reset `j` to 0 to track the index for modifying the `gifts` vector.\\n   e. Enter a loop that runs until `pq` is empty:\\n      - Retrieve the top element from `pq` and store it in `gifts[j]`.\\n      - Remove the element from `pq`.\\n      - Increment `j` by 1.\\n5. Increment `i` by 1 to track the number of iterations.\\n6. Calculate the sum of all elements in the modified `gifts` vector and store it in `ans`.\\n7. Return the value of `ans`.\\n\\n# Complexity\\n- Time complexity: The code consists of nested loops. The outer loop runs `k` times, and the inner loop runs `gifts.size()` times. Therefore, the time complexity can be approximated as O(k * n), where n is the size of the `gifts` vector.\\n- Space complexity: The code uses a priority queue `pq` to store the elements, which can have a maximum size of `gifts.size()`. Additionally, it uses a few variables to track indices and the sum of gifts. Hence, the space complexity is O(n), where n is the size of the `gifts` vector.\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long pickGifts(vector<int>& gifts, int k) {\\n        \\n        priority_queue<int> pq;\\n        long long ans=0;\\n        int i=0;\\n        int max;\\n        int j=0;\\n\\n        while(i<k){\\n        for(int j=0;j<gifts.size();j++){\\n            pq.push(gifts[j]);\\n            \\n        }\\n        max = pq.top();\\n        // cout<< \"Max: \"<< max<< endl;\\n        pq.pop();\\n        pq.push(abs(sqrt(max)));\\n        // cout<< \"sqrt(max): \"<< abs(sqrt(max))<< endl;\\n        j=0;\\n        while(!pq.empty()){\\n            gifts[j] = pq.top();\\n            pq.pop();\\n            j++;\\n        }\\n        i++;\\n        }\\n\\n\\n        // cout<<\"vector\"<< endl;\\n        // cout<< endl;\\n        for(int i=0;i<gifts.size();i++){ \\n            ans += gifts[i];\\n        }\\n\\n\\n    return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long pickGifts(vector<int>& gifts, int k) {\\n        \\n        priority_queue<int> pq;\\n        long long ans=0;\\n        int i=0;\\n        int max;\\n        int j=0;\\n\\n        while(i<k){\\n        for(int j=0;j<gifts.size();j++){\\n            pq.push(gifts[j]);\\n            \\n        }\\n        max = pq.top();\\n        // cout<< \"Max: \"<< max<< endl;\\n        pq.pop();\\n        pq.push(abs(sqrt(max)));\\n        // cout<< \"sqrt(max): \"<< abs(sqrt(max))<< endl;\\n        j=0;\\n        while(!pq.empty()){\\n            gifts[j] = pq.top();\\n            pq.pop();\\n            j++;\\n        }\\n        i++;\\n        }\\n\\n\\n        // cout<<\"vector\"<< endl;\\n        // cout<< endl;\\n        for(int i=0;i<gifts.size();i++){ \\n            ans += gifts[i];\\n        }\\n\\n\\n    return ans;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3769634,
                "title": "java-pq-beats-89-onlyyy",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public long pickGifts(int[] gifts, int k) {\\n        PriorityQueue<Integer> pq = new PriorityQueue<>(Comparator.reverseOrder());\\n        for (int n : gifts) pq.offer(n);\\n        int count = 0;\\n        while (count++ < k) pq.offer((int) Math.sqrt(pq.poll()));\\n        long sum = 0;\\n        while (!pq.isEmpty()) sum += pq.poll();\\n        return sum;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public long pickGifts(int[] gifts, int k) {\\n        PriorityQueue<Integer> pq = new PriorityQueue<>(Comparator.reverseOrder());\\n        for (int n : gifts) pq.offer(n);\\n        int count = 0;\\n        while (count++ < k) pq.offer((int) Math.sqrt(pq.poll()));\\n        long sum = 0;\\n        while (!pq.isEmpty()) sum += pq.poll();\\n        return sum;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3768112,
                "title": "c-using-priority-queue",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long pickGifts(vector<int>& gifts, int k) {\\n        priority_queue<int>pq(gifts.begin(),gifts.end());\\n        while(k--){\\n          int x=sqrt(pq.top());\\n          pq.pop();\\n          pq.push(x);\\n        }\\n        long long int res=0;\\n        while(pq.empty()==false){\\n            res+=pq.top();\\n            pq.pop();\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long pickGifts(vector<int>& gifts, int k) {\\n        priority_queue<int>pq(gifts.begin(),gifts.end());\\n        while(k--){\\n          int x=sqrt(pq.top());\\n          pq.pop();\\n          pq.push(x);\\n        }\\n        long long int res=0;\\n        while(pq.empty()==false){\\n            res+=pq.top();\\n            pq.pop();\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3764488,
                "title": "c-pq-with-complexities",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\nO(k * logn + n), where n is number of gifts.\\nlogn because popping and pushing into heap takes O(logn) - (worst case time complexity).\\n\\n- Space complexity:\\nO(n)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long pickGifts(vector<int>& gifts, int k) {\\n        \\n        priority_queue<int> pq{};\\n\\n        for(const auto& i : gifts) pq.push(i);\\n\\n        while(k--){\\n\\n            int curr = pq.top();\\n            pq.pop();\\n\\n            pq.push(sqrt(curr));\\n        }\\n\\n        long long answer{};\\n\\n        while(!pq.empty()){\\n            answer += pq.top();\\n            pq.pop();\\n        }\\n\\n        return answer;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long pickGifts(vector<int>& gifts, int k) {\\n        \\n        priority_queue<int> pq{};\\n\\n        for(const auto& i : gifts) pq.push(i);\\n\\n        while(k--){\\n\\n            int curr = pq.top();\\n            pq.pop();\\n\\n            pq.push(sqrt(curr));\\n        }\\n\\n        long long answer{};\\n\\n        while(!pq.empty()){\\n            answer += pq.top();\\n            pq.pop();\\n        }\\n\\n        return answer;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3753006,
                "title": "c-simple-and-easy-approach",
                "content": "# Intuition\\nWe have to take gifts from richest pile in such a way that we leave behind the square-root and then we have to return the count of remaining gifts\\n\\n# Approach\\nWe repeatedly check k times for the maximum element and replace it with its square-root and then sum up all the elements of gifts and return the count.\\n\\n# Complexity\\n- Time complexity:\\nO(k*n)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long pickGifts(vector<int>& gifts, int k) {\\n        long long int count = 0;\\n        for(int i=0; i<k; i++)\\n        {\\n            int max = 0;\\n            for(int j=1; j<gifts.size(); j++)\\n            {\\n                if(gifts[j]>gifts[max])\\n                {\\n                    max = j;\\n                }\\n            }\\n            gifts[max] = sqrt(gifts[max]);\\n        }\\n        for(int i=0; i<gifts.size(); i++)\\n        {\\n            count += gifts[i];\\n        }\\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long pickGifts(vector<int>& gifts, int k) {\\n        long long int count = 0;\\n        for(int i=0; i<k; i++)\\n        {\\n            int max = 0;\\n            for(int j=1; j<gifts.size(); j++)\\n            {\\n                if(gifts[j]>gifts[max])\\n                {\\n                    max = j;\\n                }\\n            }\\n            gifts[max] = sqrt(gifts[max]);\\n        }\\n        for(int i=0; i<gifts.size(); i++)\\n        {\\n            count += gifts[i];\\n        }\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3748273,
                "title": "c-priority-queue-easiest-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    long long pickGifts(vector<int>&g , int k){\\n        priority_queue<int>pq(g.begin(),g.end());\\n        while(k--){\\n            pq.push(sqrt(pq.top()));\\n            pq.pop();\\n        }\\n        long long sum=0;\\n        while(!pq.empty()){\\n            sum+=pq.top();\\n            pq.pop();\\n        }\\n        return sum;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long pickGifts(vector<int>&g , int k){\\n        priority_queue<int>pq(g.begin(),g.end());\\n        while(k--){\\n            pq.push(sqrt(pq.top()));\\n            pq.pop();\\n        }\\n        long long sum=0;\\n        while(!pq.empty()){\\n            sum+=pq.top();\\n            pq.pop();\\n        }\\n        return sum;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3740575,
                "title": "python3-using-heap-to-solve-easy-question",
                "content": "\\n# Code\\n```\\nclass Solution:\\n    def pickGifts(self, gifts: List[int], k: int) -> int:\\n        heap = []\\n        for g in gifts:\\n            heapq.heappush(heap, -g)\\n\\n        while k > 0:\\n            x = heapq.heappop(heap)\\n            x = int(math.sqrt(-x))\\n            heapq.heappush(heap, -x)\\n            k-=1\\n        \\n        return -sum(list(heap))\\n        \\n\\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def pickGifts(self, gifts: List[int], k: int) -> int:\\n        heap = []\\n        for g in gifts:\\n            heapq.heappush(heap, -g)\\n\\n        while k > 0:\\n            x = heapq.heappop(heap)\\n            x = int(math.sqrt(-x))\\n            heapq.heappush(heap, -x)\\n            k-=1\\n        \\n        return -sum(list(heap))\\n        \\n\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3739428,
                "title": "simple-javascript-solution",
                "content": "\\n# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {number[]} gifts\\n * @param {number} k\\n * @return {number}\\n */\\nvar pickGifts = function(gifts, k) {\\n    for(let i = 0; i < k; i++){\\n        gifts.sort((a,b) => a - b)\\n        let fsqrt = Math.floor(Math.sqrt(gifts.pop()))\\n        gifts.push(fsqrt)\\n    }\\n    return gifts.reduce((a,b) => a + b)\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} gifts\\n * @param {number} k\\n * @return {number}\\n */\\nvar pickGifts = function(gifts, k) {\\n    for(let i = 0; i < k; i++){\\n        gifts.sort((a,b) => a - b)\\n        let fsqrt = Math.floor(Math.sqrt(gifts.pop()))\\n        gifts.push(fsqrt)\\n    }\\n    return gifts.reduce((a,b) => a + b)\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3738746,
                "title": "max-heap-o-nlogn-o-n-solution",
                "content": "# Code\\n```\\nclass Solution {\\n\\n    // TC: O(nlogn)\\n    // SC: O(n)\\n    public long pickGifts(int[] gifts, int k) {\\n        // Max Heap\\n        PriorityQueue<Integer> pq = new PriorityQueue<>((a,b)->b-a);\\n        for(int g:gifts){\\n            pq.offer(g);\\n        }\\n        while(k!=0){\\n            pq.offer((int)Math.sqrt(pq.poll()));\\n            k--;\\n        }\\n        long ans = 0;\\n        while(!pq.isEmpty()){\\n            ans+=pq.poll();\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\n\\n    // TC: O(nlogn)\\n    // SC: O(n)\\n    public long pickGifts(int[] gifts, int k) {\\n        // Max Heap\\n        PriorityQueue<Integer> pq = new PriorityQueue<>((a,b)->b-a);\\n        for(int g:gifts){\\n            pq.offer(g);\\n        }\\n        while(k!=0){\\n            pq.offer((int)Math.sqrt(pq.poll()));\\n            k--;\\n        }\\n        long ans = 0;\\n        while(!pq.isEmpty()){\\n            ans+=pq.poll();\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3732977,
                "title": "javascript-beats-96-97-o-k-n-time-o-1-memory",
                "content": "# Intuition\\nK is the value of the parameter k.\\nN is the length of the gifts array\\n\\n# Complexity\\n- Time complexity: O(k * n)\\n\\n- Space complexity: 1\\n\\n# Code\\n```\\n/**\\n * @param {number[]} gifts\\n * @param {number} k\\n * @return {number}\\n */\\nvar pickGifts = function(gifts, k) {\\n    let maxIndex;\\n  \\n    do {\\n        let maxNumber = -Infinity;\\n\\n        for (let i = 0; i < gifts.length; i++) {\\n            if (gifts[i] > maxNumber) {\\n                maxNumber = gifts[i];\\n                maxIndex = i;\\n            }\\n        }\\n\\n        gifts[maxIndex] = Math.floor(Math.sqrt(maxNumber));\\n        k--;\\n    } while (k > 0);\\n\\n    return gifts.reduce((acc, cur) => acc + cur);\\n};\\n\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} gifts\\n * @param {number} k\\n * @return {number}\\n */\\nvar pickGifts = function(gifts, k) {\\n    let maxIndex;\\n  \\n    do {\\n        let maxNumber = -Infinity;\\n\\n        for (let i = 0; i < gifts.length; i++) {\\n            if (gifts[i] > maxNumber) {\\n                maxNumber = gifts[i];\\n                maxIndex = i;\\n            }\\n        }\\n\\n        gifts[maxIndex] = Math.floor(Math.sqrt(maxNumber));\\n        k--;\\n    } while (k > 0);\\n\\n    return gifts.reduce((acc, cur) => acc + cur);\\n};\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3721649,
                "title": "easy-go-solution",
                "content": "```\\nfunc pickGifts(gifts []int, k int) int64 {\\n        sort.Ints(gifts)\\n\\n        for i := 0; i < k; i++ {\\n                gift := gifts[len(gifts)-1]\\n                sqrt := int(math.Sqrt(float64(gift)))\\n                gifts[len(gifts)-1] = sqrt\\n                shift(gifts)\\n        }\\n\\n        var sum int64\\n\\n        for i := 0; i < len(gifts); i++ {\\n                sum += int64(gifts[i])\\n        }\\n\\n        return sum\\n}\\n\\nfunc shift(nums []int) {\\n        for i := len(nums) - 1; i >= 1; i-- {\\n                cur := nums[i]\\n                prev := nums[i-1]\\n                if cur < prev {\\n                        nums[i], nums[i-1] = prev, cur\\n                } else {\\n                        break\\n                }\\n        }\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc pickGifts(gifts []int, k int) int64 {\\n        sort.Ints(gifts)\\n\\n        for i := 0; i < k; i++ {\\n                gift := gifts[len(gifts)-1]\\n                sqrt := int(math.Sqrt(float64(gift)))\\n                gifts[len(gifts)-1] = sqrt\\n                shift(gifts)\\n        }\\n\\n        var sum int64\\n\\n        for i := 0; i < len(gifts); i++ {\\n                sum += int64(gifts[i])\\n        }\\n\\n        return sum\\n}\\n\\nfunc shift(nums []int) {\\n        for i := len(nums) - 1; i >= 1; i-- {\\n                cur := nums[i]\\n                prev := nums[i-1]\\n                if cur < prev {\\n                        nums[i], nums[i-1] = prev, cur\\n                } else {\\n                        break\\n                }\\n        }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3716021,
                "title": "pickgifts-solution-in-python3",
                "content": "# Intuition\\nTo sort all the array elements in descending order and replacing the first element of the array with the floor of its sqrt. (k times)\\n# Approach\\n1) Sort the elements of *gifts* array in descending order.\\n2) Find the floor of sqrt of first element (0th index) in the sorted array\\n (let\\'s call it x).\\n3) Replace the value of first element (0th index) with x.\\n4) Repeat steps 1, 2, 3 till *k* = 0\\n5) Return the sum of all the elements in *gifts* array.\\n# Complexity\\n- Time complexity:\\n1. Sorting the gifts array ----> O(nlogn)\\n2. While loop running k times ----> O(k)\\n3. Finding the sum of gifts array --> O(n)\\n4. Overall Time Complexity --> **O(nlogn)**\\n\\n\\n- Space complexity:\\nO(n)\\n\\n# Code\\n```\\nimport math\\nclass Solution:\\n    def pickGifts(self, gifts, k):\\n        while k != 0:\\n            gifts.sort(reverse=True)\\n            x = math.floor(math.sqrt(gifts[0]))\\n            gifts[0] = x\\n            k -= 1\\n        return sum(gifts)\\n```",
                "solutionTags": [
                    "Python3",
                    "Sort"
                ],
                "code": "```\\nimport math\\nclass Solution:\\n    def pickGifts(self, gifts, k):\\n        while k != 0:\\n            gifts.sort(reverse=True)\\n            x = math.floor(math.sqrt(gifts[0]))\\n            gifts[0] = x\\n            k -= 1\\n        return sum(gifts)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3711178,
                "title": "easy-solution-with-both-approaches-explained-java",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nThere are two approaches to solve this question .\\n**1. Brute Force**\\nIn brute force way we solve this question using sorting the array gifts.\\n\\nIn this approach we first sort the array gifts and start a while loop with the condition k greater than zero. \\n\\nWe start with the end from the sorted array because that element will be the maximum in the sorted array.\\n\\nWe than calculate the root of the element selected and store it in the temp variable and then add replace the element with the root \\nAnd again we sort this array to follow the same process until the k reaches to zero.\\n\\nBut this process is taking more time and space so we have the another approach i.e. using PriorityQueue.\\n\\n# Code\\n```\\nclass Solution {\\n    public long pickGifts(int[] gifts, int k) {\\n        \\n        long ans =0;\\n        int n = gifts.length;\\n\\n        Arrays.sort(gifts);\\n\\n        while( k >0){\\n            gifts[n-1] = (int) Math.sqrt(gifts[n-1]);\\n            Arrays.sort(gifts);\\n            k--;\\n        }\\n        for(int i=0; i<n; i++){\\n            ans += gifts[i];\\n        }\\n        return ans;\\n    }\\n}\\n```\\n\\n**2. Priority Queue**\\nIn this method the change we make is instead of sorting the array again and again we are using the PQ which by default provides us the sorted array . \\nHere we are converting it into reverse order because we need to work with the largest element of the array in every second.\\nEverything else is same that is discussed in brute for approach.\\n\\n\\n# Code\\n```\\nclass Solution {\\n    public long pickGifts(int[] gifts, int k) {\\n        \\n       PriorityQueue<Integer> q = new PriorityQueue<>(Collections.reverseOrder());\\n\\n       for(int x : gifts)\\n        q.add(x);\\n\\n        for(int i=0; i<k; i++){\\n            int cur = q.remove();\\n            q.add((int)Math.sqrt(cur));\\n        }\\n\\n        long ans = 0;\\n        while(q.size()>0){\\n            ans += q.remove();\\n        }\\n        return ans;\\n\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Sorting",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\n    public long pickGifts(int[] gifts, int k) {\\n        \\n        long ans =0;\\n        int n = gifts.length;\\n\\n        Arrays.sort(gifts);\\n\\n        while( k >0){\\n            gifts[n-1] = (int) Math.sqrt(gifts[n-1]);\\n            Arrays.sort(gifts);\\n            k--;\\n        }\\n        for(int i=0; i<n; i++){\\n            ans += gifts[i];\\n        }\\n        return ans;\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public long pickGifts(int[] gifts, int k) {\\n        \\n       PriorityQueue<Integer> q = new PriorityQueue<>(Collections.reverseOrder());\\n\\n       for(int x : gifts)\\n        q.add(x);\\n\\n        for(int i=0; i<k; i++){\\n            int cur = q.remove();\\n            q.add((int)Math.sqrt(cur));\\n        }\\n\\n        long ans = 0;\\n        while(q.size()>0){\\n            ans += q.remove();\\n        }\\n        return ans;\\n\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3703375,
                "title": "most-easy-java-solution-to-understand",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\nO(k * n * log n). \\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public long pickGifts(int[] gifts, int k) {\\n        long sum=0;\\n        int n=gifts.length;\\n        for(int i=0;i<k;i++)\\n        {\\n// in this for-loop we are updating the maximum value with its floor value\\n        Arrays.sort(gifts);\\n        int max=gifts[n-1];\\n        int squareroot=(int)Math.sqrt(max);\\n        int floor=(int)Math.floor(squareroot);\\n        gifts[n-1]=floor;            \\n        }\\n//in this for loop we are just find the sum of all gifts \\n        for(int i=0;i<gifts.length;i++)\\n        sum=sum+gifts[i];\\n        return sum;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public long pickGifts(int[] gifts, int k) {\\n        long sum=0;\\n        int n=gifts.length;\\n        for(int i=0;i<k;i++)\\n        {\\n// in this for-loop we are updating the maximum value with its floor value\\n        Arrays.sort(gifts);\\n        int max=gifts[n-1];\\n        int squareroot=(int)Math.sqrt(max);\\n        int floor=(int)Math.floor(squareroot);\\n        gifts[n-1]=floor;            \\n        }\\n//in this for loop we are just find the sum of all gifts \\n        for(int i=0;i<gifts.length;i++)\\n        sum=sum+gifts[i];\\n        return sum;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3699935,
                "title": "java-easiest-solution-simple-code-with-explanation",
                "content": "# Intuition\\n1. Iterate within a for loop upto k.\\n2. Sort array everytime while the for loop is running.\\n3. Change the value of last element in the array with its square root.\\n4. Go back to step 2 until you the for loop is ended.\\n5. Initialize another for loop outside of the previous one upto length of array.\\n6. Add all the elements by increasing the previously initialised count.\\n7. return count.\\n\\n# Code\\n```\\nclass Solution {\\n    public long pickGifts(int[] arr, int k) {\\n        int n = arr.length;\\n        for(int i=0; i<k; i++){\\n            Arrays.sort(arr);\\n            arr[n-1]=(int)(Math.sqrt(arr[n-1]));\\n        }\\n        long c = 0;\\n        for(int i=0; i<arr.length; i++){\\n            c += arr[i];\\n        }\\n        return c;\\n    }\\n}\\n```\\nPlease upvote if reached till end!",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Math",
                    "Sort",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\n    public long pickGifts(int[] arr, int k) {\\n        int n = arr.length;\\n        for(int i=0; i<k; i++){\\n            Arrays.sort(arr);\\n            arr[n-1]=(int)(Math.sqrt(arr[n-1]));\\n        }\\n        long c = 0;\\n        for(int i=0; i<arr.length; i++){\\n            c += arr[i];\\n        }\\n        return c;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3692229,
                "title": "141-ms-easy-to-understand-for-noobs-simple-logic",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def pickGifts(self, gifts: List[int], k: int) -> int:\\n        a=sorted(gifts)[::-1]\\n        for i in range(k):\\n                if(k>0):\\n                    a[0]=int(math.sqrt(a[0]))\\n                    a=sorted(a)[::-1]\\n                    k-=1\\n        sum=0\\n        for i in a:\\n            sum+=i\\n        return sum\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def pickGifts(self, gifts: List[int], k: int) -> int:\\n        a=sorted(gifts)[::-1]\\n        for i in range(k):\\n                if(k>0):\\n                    a[0]=int(math.sqrt(a[0]))\\n                    a=sorted(a)[::-1]\\n                    k-=1\\n        sum=0\\n        for i in a:\\n            sum+=i\\n        return sum\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3689118,
                "title": "c-beginner-friendly-priority-queue",
                "content": "```\\nclass Solution {\\npublic:\\n    long long pickGifts(vector<int>& gifts, int k) \\n    {\\n        priority_queue<int> pq;\\n        for(int i=0;i<gifts.size();i++)\\n        {\\n            pq.push(gifts[i]);\\n        }\\n        while(k)\\n        {\\n            long long a=pq.top();\\n            pq.pop();\\n            a=sqrt(a);\\n            pq.push(a);\\n            k--;\\n        }\\n        long long sum=0;\\n        while(!pq.empty())\\n        {\\n            long long ans=pq.top();\\n            pq.pop();\\n            sum +=ans;\\n        }\\n        return sum;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long pickGifts(vector<int>& gifts, int k) \\n    {\\n        priority_queue<int> pq;\\n        for(int i=0;i<gifts.size();i++)\\n        {\\n            pq.push(gifts[i]);\\n        }\\n        while(k)\\n        {\\n            long long a=pq.top();\\n            pq.pop();\\n            a=sqrt(a);\\n            pq.push(a);\\n            k--;\\n        }\\n        long long sum=0;\\n        while(!pq.empty())\\n        {\\n            long long ans=pq.top();\\n            pq.pop();\\n            sum +=ans;\\n        }\\n        return sum;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3688101,
                "title": "2558-take-gifts-from-the-richest-pile-easy",
                "content": "# Code\\n```\\nimport math\\nclass Solution:\\n    def pickGifts(self, gifts: List[int], k: int) -> int:\\n        for i in range(k):\\n             m=max(gifts)\\n             val=(math.floor(pow(m,0.5)))\\n             gifts.remove(m)\\n             gifts.append(val)\\n        return sum(gifts)\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nimport math\\nclass Solution:\\n    def pickGifts(self, gifts: List[int], k: int) -> int:\\n        for i in range(k):\\n             m=max(gifts)\\n             val=(math.floor(pow(m,0.5)))\\n             gifts.remove(m)\\n             gifts.append(val)\\n        return sum(gifts)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3681011,
                "title": "beginner-friendly-approach-easy-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long pickGifts(vector<int>& gifts, int k) {\\n        sort(gifts.begin(),gifts.end());\\n        int n = gifts.size();\\n        while(k--){\\n            gifts[n-1]= floor(sqrt(gifts[n-1]));\\n            sort(gifts.begin(),gifts.end());\\n        }\\n        long long sum = 0;\\n        for(int x: gifts){\\n            sum+=x;\\n        }\\n        return sum;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long pickGifts(vector<int>& gifts, int k) {\\n        sort(gifts.begin(),gifts.end());\\n        int n = gifts.size();\\n        while(k--){\\n            gifts[n-1]= floor(sqrt(gifts[n-1]));\\n            sort(gifts.begin(),gifts.end());\\n        }\\n        long long sum = 0;\\n        for(int x: gifts){\\n            sum+=x;\\n        }\\n        return sum;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3676102,
                "title": "java-optimized-solution-beats-100-7-lines-code",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nTo solve this problem, we can follow the given steps:\\n\\n1. Initialize a priority queue (max heap) to store the piles of gifts in descending order.\\n2. Insert all the piles into the priority queue.\\n3. For each second from 1 to k, do the following:\\n    * Extract the pile with the maximum number of gifts from the priority queue.\\n    * Calculate the floor of the square root of the number of gifts in the chosen pile.\\n    * Subtract the calculated value from the chosen pile and update it.\\n    * If the updated pile still has gifts, insert it back into the priority queue.\\n4. Calculate the sum of the remaining gifts in all the piles and return the result.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. Create a priority queue (max heap) and insert all the piles into it.\\n2. Initialize a variable \"remainingGifts\" to 0.\\n3. Iterate from 1 to k:\\n    * Extract the maximum element (pile with the maximum number of gifts) from the priority queue.\\n    * Calculate the floor of the square root of the extracted element.\\n    * Subtract the calculated value from the extracted element and update it.\\n    * If the updated element is greater than 0, insert it back into the priority queue.\\n    * Add the updated element to the \"remainingGifts\" variable.\\n4. Return the value of \"remainingGifts\".\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nLet n be the length of the gifts array. Constructing the priority queue takes O(n) time. Each second of the simulation involves extracting an element from the priority queue, which takes O(log n) time. Since we iterate k times, the overall time complexity of the solution is O(k log n). However, since both k and n are bounded by 103, the algorithm will run in a reasonable amount of time for the given constraints.\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n1. Priority Queue (Max Heap): The priority queue is used to store the piles of gifts. The space required to store the priority queue depends on the number of elements in it. In the worst case, all the piles are distinct, so the priority queue can store up to n elements. Therefore, the space complexity for the priority queue is O(n).\\n\\n2. Remaining Gifts Variable: We use a single variable, \"remainingGifts,\" to keep track of the total number of remaining gifts. This variable requires a constant amount of space, so the space complexity is O(1).\\n\\nOverall, the space complexity of the solution is O(n) due to the priority queue.\\n\\n# Code\\n```\\nclass Solution {\\n    public long pickGifts(int[] gifts, int k) {\\n        PriorityQueue<Integer> pq=new PriorityQueue<>(Comparator.reverseOrder());\\n\\n        for(int i=0;i<gifts.length;i++){\\n            pq.add(gifts[i]);\\n        }\\n        int c=k;\\n        while(c>0){\\n            pq.add((int)Math.floor(Math.sqrt(pq.poll())));\\n            c--;\\n        }\\n        c=gifts.length;long sum=0;\\n         while(c>0){\\n            sum=sum+(int)pq.poll();\\n            c--;\\n        }\\n        return sum;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public long pickGifts(int[] gifts, int k) {\\n        PriorityQueue<Integer> pq=new PriorityQueue<>(Comparator.reverseOrder());\\n\\n        for(int i=0;i<gifts.length;i++){\\n            pq.add(gifts[i]);\\n        }\\n        int c=k;\\n        while(c>0){\\n            pq.add((int)Math.floor(Math.sqrt(pq.poll())));\\n            c--;\\n        }\\n        c=gifts.length;long sum=0;\\n         while(c>0){\\n            sum=sum+(int)pq.poll();\\n            c--;\\n        }\\n        return sum;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3663161,
                "title": "easy-solution-using-min-heap",
                "content": "# Complexity\\n- Time complexity: O(n)\\n- Space complexity: O(1)\\n\\n# Code\\n```\\nclass Solution:\\n    def pickGifts(self, gifts: [int], k: int) -> int:\\n\\n        for i in range(len(gifts)):\\n            gifts[i] = gifts[i] * -1\\n\\n        heapq.heapify(gifts)\\n\\n        for sec in range(k):\\n            heapq.heappush(gifts, math.sqrt(heapq.heappop(gifts) * -1) * -1)\\n\\n        rem_gifts = 0\\n        for gift in gifts:\\n            rem_gifts += int((gift * -1))\\n\\n        return rem_gifts\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def pickGifts(self, gifts: [int], k: int) -> int:\\n\\n        for i in range(len(gifts)):\\n            gifts[i] = gifts[i] * -1\\n\\n        heapq.heapify(gifts)\\n\\n        for sec in range(k):\\n            heapq.heappush(gifts, math.sqrt(heapq.heappop(gifts) * -1) * -1)\\n\\n        rem_gifts = 0\\n        for gift in gifts:\\n            rem_gifts += int((gift * -1))\\n\\n        return rem_gifts\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3660426,
                "title": "easy-c-solution-simple-approach",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long pickGifts(vector<int>& gifts, int k) {\\n        long long ans=0;\\n        while(k!=0){\\n            int maxi=*max_element(gifts.begin(),gifts.end());\\n            for(int i=0;i<gifts.size();i++){\\n                if(gifts[i]==maxi){\\n                    gifts[i]=sqrt(gifts[i]);\\n                    break;\\n                }\\n            }\\n            k--;\\n        }\\n        for(int i=0;i<gifts.size();i++){\\n            ans+=gifts[i];\\n        }\\n        return ans;\\n    }\\n};\\n```\\nPLEASE UPVOTE \\u2B06\\uFE0F\\u2B06\\uFE0F IF YOU LIKE THE SOLUTION !!!",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long pickGifts(vector<int>& gifts, int k) {\\n        long long ans=0;\\n        while(k!=0){\\n            int maxi=*max_element(gifts.begin(),gifts.end());\\n            for(int i=0;i<gifts.size();i++){\\n                if(gifts[i]==maxi){\\n                    gifts[i]=sqrt(gifts[i]);\\n                    break;\\n                }\\n            }\\n            k--;\\n        }\\n        for(int i=0;i<gifts.size();i++){\\n            ans+=gifts[i];\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1803541,
                "content": [
                    {
                        "username": "tomfiji",
                        "content": "For the first example, how is the answer 29 and not 30? I imagine the final list would look like: [10, 8, 5, 3, 4]. Am I missing something here?"
                    },
                    {
                        "username": "amanjaiswal159",
                        "content": "[@sandagolcea](/sandagolcea) This explained the complete problem statement and much better than what explained in question."
                    },
                    {
                        "username": "kalaskarrohit7502",
                        "content": "[@sandagolcea](/sandagolcea) thanks for explanation "
                    },
                    {
                        "username": "sandagolcea",
                        "content": "Yes, thing is: you always look at the array and `reconsider ALL values`, INCLUDING the values that you've already handled.\n\n```\ngifts = [25,64,9,4,100]\n\nk = 1, max is 100, so we replace it with sqrt(100)\ngifts = [25,64,9,4,10]\n\nk = 2, max is 64, so we replace it with sqrt(64)\ngifts = [25,8,9,4,10]\n\nk = 3, max is 25, so we replace it with sqrt(25)\ngifts = [5,8,9,4,10]\n\nTHIS IS WHERE IT'S CONFUSING:\nk = 4, max is ..not 9, it's the value we modified at step k = 1, aka 10,\nso we replace this max value with floor of sqrt(10) = 3\ngifts = [5,8,9,4,3]\n\nNow add all vals, and you get 5 + 8 + 9 + 4 + 3 = 29\n```"
                    },
                    {
                        "username": "S_Basu",
                        "content": "*Two approaches that readily come to mind:*\n- Brute force: Sorting `gifts[]` before every operation\n- **Priority Queue** (Reverse Order)\n##### [Link to Solution](https://leetcode.com/problems/take-gifts-from-the-richest-pile/solutions/3144106/2-java-solutions-100-time-space/)"
                    },
                    {
                        "username": "MayuD",
                        "content": "Similar to \\nhttps://leetcode.com/problems/maximal-score-after-applying-k-operations/"
                    },
                    {
                        "username": "satyam47",
                        "content": "Hint :  **priority_queue**"
                    },
                    {
                        "username": "dhruv4023",
                        "content": "My solution in python language:\\n\\n    def pickGifts(self, gifts: List[int], k: int) -> int:\\n        def fun(g,k):\\n            # g=[25,64,9,4,100]\\n            while k!=0:\\n                k=k-1\\n                m=max(g)\\n                i=g.index(m)\\n                g[i]=int(m**(1/2))\\n            return sum(g)\\n        return fun(gifts,k)\\n"
                    },
                    {
                        "username": "shreyaahadkar",
                        "content": "Could someone please tell me what is wrong with my solution?\\nIt\\'s working but only for a few cases...\\n\\n        while k != 0:\\n            for i in range(len(gifts)):\\n                x = math.floor(math.sqrt(max(gifts)))\\n                if gifts[i] == max(gifts):\\n                    gifts[i] = x\\n                    k -= 1\\n        return gifts"
                    },
                    {
                        "username": "bparanj",
                        "content": "Your approach seems to have a nested loop which results in the operation executing `len(gifts) * k` times. However, you need the operation to only run \\'k\\' times. The current structure of the code causes it to modify the pile \\'k\\' times for each pile, which is not what the problem statement specifies.\\n\\nAdditionally, you\\'re finding the maximum value of the array in every iteration, which is a heavy operation and could be optimized.\\n\\nInstead, what you need is a single loop that runs \\'k\\' times. In each iteration, you find the largest pile, take its square root, and replace the original value. One way to efficiently do this is to use a priority queue (heap) data structure which keeps the elements in order and allows efficient extraction of the maximum element."
                    },
                    {
                        "username": "batariloa",
                        "content": "I do not understand whats wrong with my solution. It fails on test 52.\\n\\n\\nfunc pickGifts(gifts []int, k int) int64 {\\n\\n\\tsize := len(gifts)\\n\\n\\tlastLeafNodeIndex := (size - 1) / 2\\n\\n\\tmaxHeapify(&gifts, size, int(lastLeafNodeIndex))\\n\\n\\tfor k > 0 {\\n\\t\\tfloorSqrt := int(math.Sqrt(float64(gifts[0]))) \\n\\t\\tgifts[0] = floorSqrt \\n\\t\\tmaxHeapify(&gifts, size, 0)\\n\\t\\tk--\\n\\t}\\n\\n\\treturn int64(countGifts(gifts))\\n}\\n\\nfunc countGifts(heap []int) int {\\n\\n\\tsum := 0\\n\\tfor _, num := range heap {\\n\\t\\tsum += num\\n\\t}\\n\\n\\treturn sum\\n}\\n\\nfunc maxHeapify(heap *[]int, size int, i int) {\\n\\n\\tl := 2*i + 1\\n\\tr := 2*i + 2\\n\\n\\tlargest := i\\n\\n\\tif l < size && (*heap)[l] > (*heap)[i] {\\n\\t\\tlargest = l\\n\\t}\\n\\n\\tif r < size && (*heap)[r] > (*heap)[largest] {\\n\\t\\tlargest = r\\n\\t}\\n\\n\\tif largest != i {\\n\\t\\t(*heap)[i], (*heap)[largest] = (*heap)[largest], (*heap)[i]\\n\\t\\tmaxHeapify(heap, size, largest)\\n\\t}\\n}\\n\\n"
                    },
                    {
                        "username": "bparanj",
                        "content": "The issue here is likely with how you\\'re building your initial max heap. The max heapify function is being called starting from the last leaf node\\'s parent and you do not iterate backwards to include all parents of the leaf nodes. Because of this, your initial heap might not be a max heap.\\n\\nWhen you start from the last leaf node\\'s parent, you should then go backwards through the array, ensuring all subtrees are max heaps. You can do this by adding a loop that goes from last leaf node\\'s parent to the root of the tree (index 0) in a reverse manner. \\n\\nHere\\'s how you can modify the max heap construction part of your code:\\n\\n```go\\nfor i := lastLeafNodeIndex; i >= 0; i-- {\\n\\tmaxHeapify(&gifts, size, i)\\n}\\n```\\nThis way, you ensure that your heap property is maintained from the start. Then, as you continue to pick gifts, the max heapify function should correctly rearrange the elements to maintain the max heap property.\\n\\nThis change is necessary because in the heap data structure, the parent node must always have a value that is greater than or equal to its children. So, we need to start heapifying from the bottom of the tree and work our way up to the root to ensure this property is maintained."
                    },
                    {
                        "username": "sandagolcea",
                        "content": "For JS - leetcode uses a library for the max priority queue. This is how you use it:\n ```\nlet q = new MaxPriorityQueue();\n// add a val:\n// let giftValue = 7;\nq.enqueue(giftValue);\n// pop (the elem with the biggest val):\nlet maxVal = q.dequeue().element;\n```"
                    },
                    {
                        "username": "izzatullohboy007",
                        "content": "class Solution:\\n    def pickGifts(self, gifts: List[int], k: int) -> int:\\n        import math \\n        for i in range(k):\\n            s = max(gifts)\\n            gifts.append(math.isqrt(s))\\n            gifts.remove(s)\\n        return sum(gifts)\\n\\n"
                    },
                    {
                        "username": "devottam2809",
                        "content": "whats is wrong with this approach??    \\n while(k--)\\n     {\\n       int maxi=INT_MIN;\\n         for(int i=0;i<gifts.size();i++)\\n         {\\n            if(gifts[i]>maxi)\\n            {\\n                maxi=gifts[i];\\n                int temp=sqrt(maxi);\\n                gifts[i]=temp;\\n            }\\n         }\\n     }\\n    int sum=0;\\n        for(int i=0;i<gifts.size();i++)\\n            sum+=gifts[i];\\n    return sum;\\n    }"
                    },
                    {
                        "username": "bparanj",
                        "content": "This approach has several issues:\\n\\n1. **Finding Maximum Incorrectly:** The loop is intended to find the maximum element in `gifts[]` and then update the maximum element with its square root. However, it\\'s incorrectly updating `gifts[i]` with the square root of `maxi` every time it finds a new maximum. As a result, it\\'s possible that not just the maximum element but several elements get updated in each iteration of the outer loop.\\n\\n2. **Wrong Transformation Operation:** According to our original problem, each chosen gift\\'s value should be reduced to half of its original value, but this code is replacing the maximum value with its square root, which doesn\\'t match the problem\\'s requirements.\\n\\n3. **No Breaking Condition:** There is no condition to break out of the loop if all elements in `gifts[]` become 0. The loop continues for `k` times, which could lead to unnecessary computations.\\n\\n4. **Time Complexity:** This code has a time complexity of O(k*n) because for each of `k` iterations, it\\'s performing an O(n) operation to find the maximum value in the array. This would not be efficient for large inputs.\\n\\nHere\\'s the correct approach:\\n\\n```cpp\\nfor(int i=0; i < k; i++) {\\n    int maxIndex = max_element(gifts.begin(), gifts.end()) - gifts.begin();\\n    gifts[maxIndex] = gifts[maxIndex] / 2;\\n}\\n```\\n\\nIn this code, `max_element()` is a built-in function in C++ that returns an iterator pointing to the maximum element in the range [first, last) that we\\'ve passed. We then subtract `gifts.begin()` from this iterator to get the index of the maximum element in our array. We can then directly halve the value at this index. The loop runs for `k` iterations, and in each iteration, we\\'re finding and halving the maximum value in our array."
                    }
                ]
            },
            {
                "id": 1788550,
                "content": [
                    {
                        "username": "tomfiji",
                        "content": "For the first example, how is the answer 29 and not 30? I imagine the final list would look like: [10, 8, 5, 3, 4]. Am I missing something here?"
                    },
                    {
                        "username": "amanjaiswal159",
                        "content": "[@sandagolcea](/sandagolcea) This explained the complete problem statement and much better than what explained in question."
                    },
                    {
                        "username": "kalaskarrohit7502",
                        "content": "[@sandagolcea](/sandagolcea) thanks for explanation "
                    },
                    {
                        "username": "sandagolcea",
                        "content": "Yes, thing is: you always look at the array and `reconsider ALL values`, INCLUDING the values that you've already handled.\n\n```\ngifts = [25,64,9,4,100]\n\nk = 1, max is 100, so we replace it with sqrt(100)\ngifts = [25,64,9,4,10]\n\nk = 2, max is 64, so we replace it with sqrt(64)\ngifts = [25,8,9,4,10]\n\nk = 3, max is 25, so we replace it with sqrt(25)\ngifts = [5,8,9,4,10]\n\nTHIS IS WHERE IT'S CONFUSING:\nk = 4, max is ..not 9, it's the value we modified at step k = 1, aka 10,\nso we replace this max value with floor of sqrt(10) = 3\ngifts = [5,8,9,4,3]\n\nNow add all vals, and you get 5 + 8 + 9 + 4 + 3 = 29\n```"
                    },
                    {
                        "username": "S_Basu",
                        "content": "*Two approaches that readily come to mind:*\n- Brute force: Sorting `gifts[]` before every operation\n- **Priority Queue** (Reverse Order)\n##### [Link to Solution](https://leetcode.com/problems/take-gifts-from-the-richest-pile/solutions/3144106/2-java-solutions-100-time-space/)"
                    },
                    {
                        "username": "MayuD",
                        "content": "Similar to \\nhttps://leetcode.com/problems/maximal-score-after-applying-k-operations/"
                    },
                    {
                        "username": "satyam47",
                        "content": "Hint :  **priority_queue**"
                    },
                    {
                        "username": "dhruv4023",
                        "content": "My solution in python language:\\n\\n    def pickGifts(self, gifts: List[int], k: int) -> int:\\n        def fun(g,k):\\n            # g=[25,64,9,4,100]\\n            while k!=0:\\n                k=k-1\\n                m=max(g)\\n                i=g.index(m)\\n                g[i]=int(m**(1/2))\\n            return sum(g)\\n        return fun(gifts,k)\\n"
                    },
                    {
                        "username": "shreyaahadkar",
                        "content": "Could someone please tell me what is wrong with my solution?\\nIt\\'s working but only for a few cases...\\n\\n        while k != 0:\\n            for i in range(len(gifts)):\\n                x = math.floor(math.sqrt(max(gifts)))\\n                if gifts[i] == max(gifts):\\n                    gifts[i] = x\\n                    k -= 1\\n        return gifts"
                    },
                    {
                        "username": "bparanj",
                        "content": "Your approach seems to have a nested loop which results in the operation executing `len(gifts) * k` times. However, you need the operation to only run \\'k\\' times. The current structure of the code causes it to modify the pile \\'k\\' times for each pile, which is not what the problem statement specifies.\\n\\nAdditionally, you\\'re finding the maximum value of the array in every iteration, which is a heavy operation and could be optimized.\\n\\nInstead, what you need is a single loop that runs \\'k\\' times. In each iteration, you find the largest pile, take its square root, and replace the original value. One way to efficiently do this is to use a priority queue (heap) data structure which keeps the elements in order and allows efficient extraction of the maximum element."
                    },
                    {
                        "username": "batariloa",
                        "content": "I do not understand whats wrong with my solution. It fails on test 52.\\n\\n\\nfunc pickGifts(gifts []int, k int) int64 {\\n\\n\\tsize := len(gifts)\\n\\n\\tlastLeafNodeIndex := (size - 1) / 2\\n\\n\\tmaxHeapify(&gifts, size, int(lastLeafNodeIndex))\\n\\n\\tfor k > 0 {\\n\\t\\tfloorSqrt := int(math.Sqrt(float64(gifts[0]))) \\n\\t\\tgifts[0] = floorSqrt \\n\\t\\tmaxHeapify(&gifts, size, 0)\\n\\t\\tk--\\n\\t}\\n\\n\\treturn int64(countGifts(gifts))\\n}\\n\\nfunc countGifts(heap []int) int {\\n\\n\\tsum := 0\\n\\tfor _, num := range heap {\\n\\t\\tsum += num\\n\\t}\\n\\n\\treturn sum\\n}\\n\\nfunc maxHeapify(heap *[]int, size int, i int) {\\n\\n\\tl := 2*i + 1\\n\\tr := 2*i + 2\\n\\n\\tlargest := i\\n\\n\\tif l < size && (*heap)[l] > (*heap)[i] {\\n\\t\\tlargest = l\\n\\t}\\n\\n\\tif r < size && (*heap)[r] > (*heap)[largest] {\\n\\t\\tlargest = r\\n\\t}\\n\\n\\tif largest != i {\\n\\t\\t(*heap)[i], (*heap)[largest] = (*heap)[largest], (*heap)[i]\\n\\t\\tmaxHeapify(heap, size, largest)\\n\\t}\\n}\\n\\n"
                    },
                    {
                        "username": "bparanj",
                        "content": "The issue here is likely with how you\\'re building your initial max heap. The max heapify function is being called starting from the last leaf node\\'s parent and you do not iterate backwards to include all parents of the leaf nodes. Because of this, your initial heap might not be a max heap.\\n\\nWhen you start from the last leaf node\\'s parent, you should then go backwards through the array, ensuring all subtrees are max heaps. You can do this by adding a loop that goes from last leaf node\\'s parent to the root of the tree (index 0) in a reverse manner. \\n\\nHere\\'s how you can modify the max heap construction part of your code:\\n\\n```go\\nfor i := lastLeafNodeIndex; i >= 0; i-- {\\n\\tmaxHeapify(&gifts, size, i)\\n}\\n```\\nThis way, you ensure that your heap property is maintained from the start. Then, as you continue to pick gifts, the max heapify function should correctly rearrange the elements to maintain the max heap property.\\n\\nThis change is necessary because in the heap data structure, the parent node must always have a value that is greater than or equal to its children. So, we need to start heapifying from the bottom of the tree and work our way up to the root to ensure this property is maintained."
                    },
                    {
                        "username": "sandagolcea",
                        "content": "For JS - leetcode uses a library for the max priority queue. This is how you use it:\n ```\nlet q = new MaxPriorityQueue();\n// add a val:\n// let giftValue = 7;\nq.enqueue(giftValue);\n// pop (the elem with the biggest val):\nlet maxVal = q.dequeue().element;\n```"
                    },
                    {
                        "username": "izzatullohboy007",
                        "content": "class Solution:\\n    def pickGifts(self, gifts: List[int], k: int) -> int:\\n        import math \\n        for i in range(k):\\n            s = max(gifts)\\n            gifts.append(math.isqrt(s))\\n            gifts.remove(s)\\n        return sum(gifts)\\n\\n"
                    },
                    {
                        "username": "devottam2809",
                        "content": "whats is wrong with this approach??    \\n while(k--)\\n     {\\n       int maxi=INT_MIN;\\n         for(int i=0;i<gifts.size();i++)\\n         {\\n            if(gifts[i]>maxi)\\n            {\\n                maxi=gifts[i];\\n                int temp=sqrt(maxi);\\n                gifts[i]=temp;\\n            }\\n         }\\n     }\\n    int sum=0;\\n        for(int i=0;i<gifts.size();i++)\\n            sum+=gifts[i];\\n    return sum;\\n    }"
                    },
                    {
                        "username": "bparanj",
                        "content": "This approach has several issues:\\n\\n1. **Finding Maximum Incorrectly:** The loop is intended to find the maximum element in `gifts[]` and then update the maximum element with its square root. However, it\\'s incorrectly updating `gifts[i]` with the square root of `maxi` every time it finds a new maximum. As a result, it\\'s possible that not just the maximum element but several elements get updated in each iteration of the outer loop.\\n\\n2. **Wrong Transformation Operation:** According to our original problem, each chosen gift\\'s value should be reduced to half of its original value, but this code is replacing the maximum value with its square root, which doesn\\'t match the problem\\'s requirements.\\n\\n3. **No Breaking Condition:** There is no condition to break out of the loop if all elements in `gifts[]` become 0. The loop continues for `k` times, which could lead to unnecessary computations.\\n\\n4. **Time Complexity:** This code has a time complexity of O(k*n) because for each of `k` iterations, it\\'s performing an O(n) operation to find the maximum value in the array. This would not be efficient for large inputs.\\n\\nHere\\'s the correct approach:\\n\\n```cpp\\nfor(int i=0; i < k; i++) {\\n    int maxIndex = max_element(gifts.begin(), gifts.end()) - gifts.begin();\\n    gifts[maxIndex] = gifts[maxIndex] / 2;\\n}\\n```\\n\\nIn this code, `max_element()` is a built-in function in C++ that returns an iterator pointing to the maximum element in the range [first, last) that we\\'ve passed. We then subtract `gifts.begin()` from this iterator to get the index of the maximum element in our array. We can then directly halve the value at this index. The loop runs for `k` iterations, and in each iteration, we\\'re finding and halving the maximum value in our array."
                    }
                ]
            },
            {
                "id": 1817511,
                "content": [
                    {
                        "username": "tomfiji",
                        "content": "For the first example, how is the answer 29 and not 30? I imagine the final list would look like: [10, 8, 5, 3, 4]. Am I missing something here?"
                    },
                    {
                        "username": "amanjaiswal159",
                        "content": "[@sandagolcea](/sandagolcea) This explained the complete problem statement and much better than what explained in question."
                    },
                    {
                        "username": "kalaskarrohit7502",
                        "content": "[@sandagolcea](/sandagolcea) thanks for explanation "
                    },
                    {
                        "username": "sandagolcea",
                        "content": "Yes, thing is: you always look at the array and `reconsider ALL values`, INCLUDING the values that you've already handled.\n\n```\ngifts = [25,64,9,4,100]\n\nk = 1, max is 100, so we replace it with sqrt(100)\ngifts = [25,64,9,4,10]\n\nk = 2, max is 64, so we replace it with sqrt(64)\ngifts = [25,8,9,4,10]\n\nk = 3, max is 25, so we replace it with sqrt(25)\ngifts = [5,8,9,4,10]\n\nTHIS IS WHERE IT'S CONFUSING:\nk = 4, max is ..not 9, it's the value we modified at step k = 1, aka 10,\nso we replace this max value with floor of sqrt(10) = 3\ngifts = [5,8,9,4,3]\n\nNow add all vals, and you get 5 + 8 + 9 + 4 + 3 = 29\n```"
                    },
                    {
                        "username": "S_Basu",
                        "content": "*Two approaches that readily come to mind:*\n- Brute force: Sorting `gifts[]` before every operation\n- **Priority Queue** (Reverse Order)\n##### [Link to Solution](https://leetcode.com/problems/take-gifts-from-the-richest-pile/solutions/3144106/2-java-solutions-100-time-space/)"
                    },
                    {
                        "username": "MayuD",
                        "content": "Similar to \\nhttps://leetcode.com/problems/maximal-score-after-applying-k-operations/"
                    },
                    {
                        "username": "satyam47",
                        "content": "Hint :  **priority_queue**"
                    },
                    {
                        "username": "dhruv4023",
                        "content": "My solution in python language:\\n\\n    def pickGifts(self, gifts: List[int], k: int) -> int:\\n        def fun(g,k):\\n            # g=[25,64,9,4,100]\\n            while k!=0:\\n                k=k-1\\n                m=max(g)\\n                i=g.index(m)\\n                g[i]=int(m**(1/2))\\n            return sum(g)\\n        return fun(gifts,k)\\n"
                    },
                    {
                        "username": "shreyaahadkar",
                        "content": "Could someone please tell me what is wrong with my solution?\\nIt\\'s working but only for a few cases...\\n\\n        while k != 0:\\n            for i in range(len(gifts)):\\n                x = math.floor(math.sqrt(max(gifts)))\\n                if gifts[i] == max(gifts):\\n                    gifts[i] = x\\n                    k -= 1\\n        return gifts"
                    },
                    {
                        "username": "bparanj",
                        "content": "Your approach seems to have a nested loop which results in the operation executing `len(gifts) * k` times. However, you need the operation to only run \\'k\\' times. The current structure of the code causes it to modify the pile \\'k\\' times for each pile, which is not what the problem statement specifies.\\n\\nAdditionally, you\\'re finding the maximum value of the array in every iteration, which is a heavy operation and could be optimized.\\n\\nInstead, what you need is a single loop that runs \\'k\\' times. In each iteration, you find the largest pile, take its square root, and replace the original value. One way to efficiently do this is to use a priority queue (heap) data structure which keeps the elements in order and allows efficient extraction of the maximum element."
                    },
                    {
                        "username": "batariloa",
                        "content": "I do not understand whats wrong with my solution. It fails on test 52.\\n\\n\\nfunc pickGifts(gifts []int, k int) int64 {\\n\\n\\tsize := len(gifts)\\n\\n\\tlastLeafNodeIndex := (size - 1) / 2\\n\\n\\tmaxHeapify(&gifts, size, int(lastLeafNodeIndex))\\n\\n\\tfor k > 0 {\\n\\t\\tfloorSqrt := int(math.Sqrt(float64(gifts[0]))) \\n\\t\\tgifts[0] = floorSqrt \\n\\t\\tmaxHeapify(&gifts, size, 0)\\n\\t\\tk--\\n\\t}\\n\\n\\treturn int64(countGifts(gifts))\\n}\\n\\nfunc countGifts(heap []int) int {\\n\\n\\tsum := 0\\n\\tfor _, num := range heap {\\n\\t\\tsum += num\\n\\t}\\n\\n\\treturn sum\\n}\\n\\nfunc maxHeapify(heap *[]int, size int, i int) {\\n\\n\\tl := 2*i + 1\\n\\tr := 2*i + 2\\n\\n\\tlargest := i\\n\\n\\tif l < size && (*heap)[l] > (*heap)[i] {\\n\\t\\tlargest = l\\n\\t}\\n\\n\\tif r < size && (*heap)[r] > (*heap)[largest] {\\n\\t\\tlargest = r\\n\\t}\\n\\n\\tif largest != i {\\n\\t\\t(*heap)[i], (*heap)[largest] = (*heap)[largest], (*heap)[i]\\n\\t\\tmaxHeapify(heap, size, largest)\\n\\t}\\n}\\n\\n"
                    },
                    {
                        "username": "bparanj",
                        "content": "The issue here is likely with how you\\'re building your initial max heap. The max heapify function is being called starting from the last leaf node\\'s parent and you do not iterate backwards to include all parents of the leaf nodes. Because of this, your initial heap might not be a max heap.\\n\\nWhen you start from the last leaf node\\'s parent, you should then go backwards through the array, ensuring all subtrees are max heaps. You can do this by adding a loop that goes from last leaf node\\'s parent to the root of the tree (index 0) in a reverse manner. \\n\\nHere\\'s how you can modify the max heap construction part of your code:\\n\\n```go\\nfor i := lastLeafNodeIndex; i >= 0; i-- {\\n\\tmaxHeapify(&gifts, size, i)\\n}\\n```\\nThis way, you ensure that your heap property is maintained from the start. Then, as you continue to pick gifts, the max heapify function should correctly rearrange the elements to maintain the max heap property.\\n\\nThis change is necessary because in the heap data structure, the parent node must always have a value that is greater than or equal to its children. So, we need to start heapifying from the bottom of the tree and work our way up to the root to ensure this property is maintained."
                    },
                    {
                        "username": "sandagolcea",
                        "content": "For JS - leetcode uses a library for the max priority queue. This is how you use it:\n ```\nlet q = new MaxPriorityQueue();\n// add a val:\n// let giftValue = 7;\nq.enqueue(giftValue);\n// pop (the elem with the biggest val):\nlet maxVal = q.dequeue().element;\n```"
                    },
                    {
                        "username": "izzatullohboy007",
                        "content": "class Solution:\\n    def pickGifts(self, gifts: List[int], k: int) -> int:\\n        import math \\n        for i in range(k):\\n            s = max(gifts)\\n            gifts.append(math.isqrt(s))\\n            gifts.remove(s)\\n        return sum(gifts)\\n\\n"
                    },
                    {
                        "username": "devottam2809",
                        "content": "whats is wrong with this approach??    \\n while(k--)\\n     {\\n       int maxi=INT_MIN;\\n         for(int i=0;i<gifts.size();i++)\\n         {\\n            if(gifts[i]>maxi)\\n            {\\n                maxi=gifts[i];\\n                int temp=sqrt(maxi);\\n                gifts[i]=temp;\\n            }\\n         }\\n     }\\n    int sum=0;\\n        for(int i=0;i<gifts.size();i++)\\n            sum+=gifts[i];\\n    return sum;\\n    }"
                    },
                    {
                        "username": "bparanj",
                        "content": "This approach has several issues:\\n\\n1. **Finding Maximum Incorrectly:** The loop is intended to find the maximum element in `gifts[]` and then update the maximum element with its square root. However, it\\'s incorrectly updating `gifts[i]` with the square root of `maxi` every time it finds a new maximum. As a result, it\\'s possible that not just the maximum element but several elements get updated in each iteration of the outer loop.\\n\\n2. **Wrong Transformation Operation:** According to our original problem, each chosen gift\\'s value should be reduced to half of its original value, but this code is replacing the maximum value with its square root, which doesn\\'t match the problem\\'s requirements.\\n\\n3. **No Breaking Condition:** There is no condition to break out of the loop if all elements in `gifts[]` become 0. The loop continues for `k` times, which could lead to unnecessary computations.\\n\\n4. **Time Complexity:** This code has a time complexity of O(k*n) because for each of `k` iterations, it\\'s performing an O(n) operation to find the maximum value in the array. This would not be efficient for large inputs.\\n\\nHere\\'s the correct approach:\\n\\n```cpp\\nfor(int i=0; i < k; i++) {\\n    int maxIndex = max_element(gifts.begin(), gifts.end()) - gifts.begin();\\n    gifts[maxIndex] = gifts[maxIndex] / 2;\\n}\\n```\\n\\nIn this code, `max_element()` is a built-in function in C++ that returns an iterator pointing to the maximum element in the range [first, last) that we\\'ve passed. We then subtract `gifts.begin()` from this iterator to get the index of the maximum element in our array. We can then directly halve the value at this index. The loop runs for `k` iterations, and in each iteration, we\\'re finding and halving the maximum value in our array."
                    }
                ]
            },
            {
                "id": 1788448,
                "content": [
                    {
                        "username": "tomfiji",
                        "content": "For the first example, how is the answer 29 and not 30? I imagine the final list would look like: [10, 8, 5, 3, 4]. Am I missing something here?"
                    },
                    {
                        "username": "amanjaiswal159",
                        "content": "[@sandagolcea](/sandagolcea) This explained the complete problem statement and much better than what explained in question."
                    },
                    {
                        "username": "kalaskarrohit7502",
                        "content": "[@sandagolcea](/sandagolcea) thanks for explanation "
                    },
                    {
                        "username": "sandagolcea",
                        "content": "Yes, thing is: you always look at the array and `reconsider ALL values`, INCLUDING the values that you've already handled.\n\n```\ngifts = [25,64,9,4,100]\n\nk = 1, max is 100, so we replace it with sqrt(100)\ngifts = [25,64,9,4,10]\n\nk = 2, max is 64, so we replace it with sqrt(64)\ngifts = [25,8,9,4,10]\n\nk = 3, max is 25, so we replace it with sqrt(25)\ngifts = [5,8,9,4,10]\n\nTHIS IS WHERE IT'S CONFUSING:\nk = 4, max is ..not 9, it's the value we modified at step k = 1, aka 10,\nso we replace this max value with floor of sqrt(10) = 3\ngifts = [5,8,9,4,3]\n\nNow add all vals, and you get 5 + 8 + 9 + 4 + 3 = 29\n```"
                    },
                    {
                        "username": "S_Basu",
                        "content": "*Two approaches that readily come to mind:*\n- Brute force: Sorting `gifts[]` before every operation\n- **Priority Queue** (Reverse Order)\n##### [Link to Solution](https://leetcode.com/problems/take-gifts-from-the-richest-pile/solutions/3144106/2-java-solutions-100-time-space/)"
                    },
                    {
                        "username": "MayuD",
                        "content": "Similar to \\nhttps://leetcode.com/problems/maximal-score-after-applying-k-operations/"
                    },
                    {
                        "username": "satyam47",
                        "content": "Hint :  **priority_queue**"
                    },
                    {
                        "username": "dhruv4023",
                        "content": "My solution in python language:\\n\\n    def pickGifts(self, gifts: List[int], k: int) -> int:\\n        def fun(g,k):\\n            # g=[25,64,9,4,100]\\n            while k!=0:\\n                k=k-1\\n                m=max(g)\\n                i=g.index(m)\\n                g[i]=int(m**(1/2))\\n            return sum(g)\\n        return fun(gifts,k)\\n"
                    },
                    {
                        "username": "shreyaahadkar",
                        "content": "Could someone please tell me what is wrong with my solution?\\nIt\\'s working but only for a few cases...\\n\\n        while k != 0:\\n            for i in range(len(gifts)):\\n                x = math.floor(math.sqrt(max(gifts)))\\n                if gifts[i] == max(gifts):\\n                    gifts[i] = x\\n                    k -= 1\\n        return gifts"
                    },
                    {
                        "username": "bparanj",
                        "content": "Your approach seems to have a nested loop which results in the operation executing `len(gifts) * k` times. However, you need the operation to only run \\'k\\' times. The current structure of the code causes it to modify the pile \\'k\\' times for each pile, which is not what the problem statement specifies.\\n\\nAdditionally, you\\'re finding the maximum value of the array in every iteration, which is a heavy operation and could be optimized.\\n\\nInstead, what you need is a single loop that runs \\'k\\' times. In each iteration, you find the largest pile, take its square root, and replace the original value. One way to efficiently do this is to use a priority queue (heap) data structure which keeps the elements in order and allows efficient extraction of the maximum element."
                    },
                    {
                        "username": "batariloa",
                        "content": "I do not understand whats wrong with my solution. It fails on test 52.\\n\\n\\nfunc pickGifts(gifts []int, k int) int64 {\\n\\n\\tsize := len(gifts)\\n\\n\\tlastLeafNodeIndex := (size - 1) / 2\\n\\n\\tmaxHeapify(&gifts, size, int(lastLeafNodeIndex))\\n\\n\\tfor k > 0 {\\n\\t\\tfloorSqrt := int(math.Sqrt(float64(gifts[0]))) \\n\\t\\tgifts[0] = floorSqrt \\n\\t\\tmaxHeapify(&gifts, size, 0)\\n\\t\\tk--\\n\\t}\\n\\n\\treturn int64(countGifts(gifts))\\n}\\n\\nfunc countGifts(heap []int) int {\\n\\n\\tsum := 0\\n\\tfor _, num := range heap {\\n\\t\\tsum += num\\n\\t}\\n\\n\\treturn sum\\n}\\n\\nfunc maxHeapify(heap *[]int, size int, i int) {\\n\\n\\tl := 2*i + 1\\n\\tr := 2*i + 2\\n\\n\\tlargest := i\\n\\n\\tif l < size && (*heap)[l] > (*heap)[i] {\\n\\t\\tlargest = l\\n\\t}\\n\\n\\tif r < size && (*heap)[r] > (*heap)[largest] {\\n\\t\\tlargest = r\\n\\t}\\n\\n\\tif largest != i {\\n\\t\\t(*heap)[i], (*heap)[largest] = (*heap)[largest], (*heap)[i]\\n\\t\\tmaxHeapify(heap, size, largest)\\n\\t}\\n}\\n\\n"
                    },
                    {
                        "username": "bparanj",
                        "content": "The issue here is likely with how you\\'re building your initial max heap. The max heapify function is being called starting from the last leaf node\\'s parent and you do not iterate backwards to include all parents of the leaf nodes. Because of this, your initial heap might not be a max heap.\\n\\nWhen you start from the last leaf node\\'s parent, you should then go backwards through the array, ensuring all subtrees are max heaps. You can do this by adding a loop that goes from last leaf node\\'s parent to the root of the tree (index 0) in a reverse manner. \\n\\nHere\\'s how you can modify the max heap construction part of your code:\\n\\n```go\\nfor i := lastLeafNodeIndex; i >= 0; i-- {\\n\\tmaxHeapify(&gifts, size, i)\\n}\\n```\\nThis way, you ensure that your heap property is maintained from the start. Then, as you continue to pick gifts, the max heapify function should correctly rearrange the elements to maintain the max heap property.\\n\\nThis change is necessary because in the heap data structure, the parent node must always have a value that is greater than or equal to its children. So, we need to start heapifying from the bottom of the tree and work our way up to the root to ensure this property is maintained."
                    },
                    {
                        "username": "sandagolcea",
                        "content": "For JS - leetcode uses a library for the max priority queue. This is how you use it:\n ```\nlet q = new MaxPriorityQueue();\n// add a val:\n// let giftValue = 7;\nq.enqueue(giftValue);\n// pop (the elem with the biggest val):\nlet maxVal = q.dequeue().element;\n```"
                    },
                    {
                        "username": "izzatullohboy007",
                        "content": "class Solution:\\n    def pickGifts(self, gifts: List[int], k: int) -> int:\\n        import math \\n        for i in range(k):\\n            s = max(gifts)\\n            gifts.append(math.isqrt(s))\\n            gifts.remove(s)\\n        return sum(gifts)\\n\\n"
                    },
                    {
                        "username": "devottam2809",
                        "content": "whats is wrong with this approach??    \\n while(k--)\\n     {\\n       int maxi=INT_MIN;\\n         for(int i=0;i<gifts.size();i++)\\n         {\\n            if(gifts[i]>maxi)\\n            {\\n                maxi=gifts[i];\\n                int temp=sqrt(maxi);\\n                gifts[i]=temp;\\n            }\\n         }\\n     }\\n    int sum=0;\\n        for(int i=0;i<gifts.size();i++)\\n            sum+=gifts[i];\\n    return sum;\\n    }"
                    },
                    {
                        "username": "bparanj",
                        "content": "This approach has several issues:\\n\\n1. **Finding Maximum Incorrectly:** The loop is intended to find the maximum element in `gifts[]` and then update the maximum element with its square root. However, it\\'s incorrectly updating `gifts[i]` with the square root of `maxi` every time it finds a new maximum. As a result, it\\'s possible that not just the maximum element but several elements get updated in each iteration of the outer loop.\\n\\n2. **Wrong Transformation Operation:** According to our original problem, each chosen gift\\'s value should be reduced to half of its original value, but this code is replacing the maximum value with its square root, which doesn\\'t match the problem\\'s requirements.\\n\\n3. **No Breaking Condition:** There is no condition to break out of the loop if all elements in `gifts[]` become 0. The loop continues for `k` times, which could lead to unnecessary computations.\\n\\n4. **Time Complexity:** This code has a time complexity of O(k*n) because for each of `k` iterations, it\\'s performing an O(n) operation to find the maximum value in the array. This would not be efficient for large inputs.\\n\\nHere\\'s the correct approach:\\n\\n```cpp\\nfor(int i=0; i < k; i++) {\\n    int maxIndex = max_element(gifts.begin(), gifts.end()) - gifts.begin();\\n    gifts[maxIndex] = gifts[maxIndex] / 2;\\n}\\n```\\n\\nIn this code, `max_element()` is a built-in function in C++ that returns an iterator pointing to the maximum element in the range [first, last) that we\\'ve passed. We then subtract `gifts.begin()` from this iterator to get the index of the maximum element in our array. We can then directly halve the value at this index. The loop runs for `k` iterations, and in each iteration, we\\'re finding and halving the maximum value in our array."
                    }
                ]
            },
            {
                "id": 2016506,
                "content": [
                    {
                        "username": "tomfiji",
                        "content": "For the first example, how is the answer 29 and not 30? I imagine the final list would look like: [10, 8, 5, 3, 4]. Am I missing something here?"
                    },
                    {
                        "username": "amanjaiswal159",
                        "content": "[@sandagolcea](/sandagolcea) This explained the complete problem statement and much better than what explained in question."
                    },
                    {
                        "username": "kalaskarrohit7502",
                        "content": "[@sandagolcea](/sandagolcea) thanks for explanation "
                    },
                    {
                        "username": "sandagolcea",
                        "content": "Yes, thing is: you always look at the array and `reconsider ALL values`, INCLUDING the values that you've already handled.\n\n```\ngifts = [25,64,9,4,100]\n\nk = 1, max is 100, so we replace it with sqrt(100)\ngifts = [25,64,9,4,10]\n\nk = 2, max is 64, so we replace it with sqrt(64)\ngifts = [25,8,9,4,10]\n\nk = 3, max is 25, so we replace it with sqrt(25)\ngifts = [5,8,9,4,10]\n\nTHIS IS WHERE IT'S CONFUSING:\nk = 4, max is ..not 9, it's the value we modified at step k = 1, aka 10,\nso we replace this max value with floor of sqrt(10) = 3\ngifts = [5,8,9,4,3]\n\nNow add all vals, and you get 5 + 8 + 9 + 4 + 3 = 29\n```"
                    },
                    {
                        "username": "S_Basu",
                        "content": "*Two approaches that readily come to mind:*\n- Brute force: Sorting `gifts[]` before every operation\n- **Priority Queue** (Reverse Order)\n##### [Link to Solution](https://leetcode.com/problems/take-gifts-from-the-richest-pile/solutions/3144106/2-java-solutions-100-time-space/)"
                    },
                    {
                        "username": "MayuD",
                        "content": "Similar to \\nhttps://leetcode.com/problems/maximal-score-after-applying-k-operations/"
                    },
                    {
                        "username": "satyam47",
                        "content": "Hint :  **priority_queue**"
                    },
                    {
                        "username": "dhruv4023",
                        "content": "My solution in python language:\\n\\n    def pickGifts(self, gifts: List[int], k: int) -> int:\\n        def fun(g,k):\\n            # g=[25,64,9,4,100]\\n            while k!=0:\\n                k=k-1\\n                m=max(g)\\n                i=g.index(m)\\n                g[i]=int(m**(1/2))\\n            return sum(g)\\n        return fun(gifts,k)\\n"
                    },
                    {
                        "username": "shreyaahadkar",
                        "content": "Could someone please tell me what is wrong with my solution?\\nIt\\'s working but only for a few cases...\\n\\n        while k != 0:\\n            for i in range(len(gifts)):\\n                x = math.floor(math.sqrt(max(gifts)))\\n                if gifts[i] == max(gifts):\\n                    gifts[i] = x\\n                    k -= 1\\n        return gifts"
                    },
                    {
                        "username": "bparanj",
                        "content": "Your approach seems to have a nested loop which results in the operation executing `len(gifts) * k` times. However, you need the operation to only run \\'k\\' times. The current structure of the code causes it to modify the pile \\'k\\' times for each pile, which is not what the problem statement specifies.\\n\\nAdditionally, you\\'re finding the maximum value of the array in every iteration, which is a heavy operation and could be optimized.\\n\\nInstead, what you need is a single loop that runs \\'k\\' times. In each iteration, you find the largest pile, take its square root, and replace the original value. One way to efficiently do this is to use a priority queue (heap) data structure which keeps the elements in order and allows efficient extraction of the maximum element."
                    },
                    {
                        "username": "batariloa",
                        "content": "I do not understand whats wrong with my solution. It fails on test 52.\\n\\n\\nfunc pickGifts(gifts []int, k int) int64 {\\n\\n\\tsize := len(gifts)\\n\\n\\tlastLeafNodeIndex := (size - 1) / 2\\n\\n\\tmaxHeapify(&gifts, size, int(lastLeafNodeIndex))\\n\\n\\tfor k > 0 {\\n\\t\\tfloorSqrt := int(math.Sqrt(float64(gifts[0]))) \\n\\t\\tgifts[0] = floorSqrt \\n\\t\\tmaxHeapify(&gifts, size, 0)\\n\\t\\tk--\\n\\t}\\n\\n\\treturn int64(countGifts(gifts))\\n}\\n\\nfunc countGifts(heap []int) int {\\n\\n\\tsum := 0\\n\\tfor _, num := range heap {\\n\\t\\tsum += num\\n\\t}\\n\\n\\treturn sum\\n}\\n\\nfunc maxHeapify(heap *[]int, size int, i int) {\\n\\n\\tl := 2*i + 1\\n\\tr := 2*i + 2\\n\\n\\tlargest := i\\n\\n\\tif l < size && (*heap)[l] > (*heap)[i] {\\n\\t\\tlargest = l\\n\\t}\\n\\n\\tif r < size && (*heap)[r] > (*heap)[largest] {\\n\\t\\tlargest = r\\n\\t}\\n\\n\\tif largest != i {\\n\\t\\t(*heap)[i], (*heap)[largest] = (*heap)[largest], (*heap)[i]\\n\\t\\tmaxHeapify(heap, size, largest)\\n\\t}\\n}\\n\\n"
                    },
                    {
                        "username": "bparanj",
                        "content": "The issue here is likely with how you\\'re building your initial max heap. The max heapify function is being called starting from the last leaf node\\'s parent and you do not iterate backwards to include all parents of the leaf nodes. Because of this, your initial heap might not be a max heap.\\n\\nWhen you start from the last leaf node\\'s parent, you should then go backwards through the array, ensuring all subtrees are max heaps. You can do this by adding a loop that goes from last leaf node\\'s parent to the root of the tree (index 0) in a reverse manner. \\n\\nHere\\'s how you can modify the max heap construction part of your code:\\n\\n```go\\nfor i := lastLeafNodeIndex; i >= 0; i-- {\\n\\tmaxHeapify(&gifts, size, i)\\n}\\n```\\nThis way, you ensure that your heap property is maintained from the start. Then, as you continue to pick gifts, the max heapify function should correctly rearrange the elements to maintain the max heap property.\\n\\nThis change is necessary because in the heap data structure, the parent node must always have a value that is greater than or equal to its children. So, we need to start heapifying from the bottom of the tree and work our way up to the root to ensure this property is maintained."
                    },
                    {
                        "username": "sandagolcea",
                        "content": "For JS - leetcode uses a library for the max priority queue. This is how you use it:\n ```\nlet q = new MaxPriorityQueue();\n// add a val:\n// let giftValue = 7;\nq.enqueue(giftValue);\n// pop (the elem with the biggest val):\nlet maxVal = q.dequeue().element;\n```"
                    },
                    {
                        "username": "izzatullohboy007",
                        "content": "class Solution:\\n    def pickGifts(self, gifts: List[int], k: int) -> int:\\n        import math \\n        for i in range(k):\\n            s = max(gifts)\\n            gifts.append(math.isqrt(s))\\n            gifts.remove(s)\\n        return sum(gifts)\\n\\n"
                    },
                    {
                        "username": "devottam2809",
                        "content": "whats is wrong with this approach??    \\n while(k--)\\n     {\\n       int maxi=INT_MIN;\\n         for(int i=0;i<gifts.size();i++)\\n         {\\n            if(gifts[i]>maxi)\\n            {\\n                maxi=gifts[i];\\n                int temp=sqrt(maxi);\\n                gifts[i]=temp;\\n            }\\n         }\\n     }\\n    int sum=0;\\n        for(int i=0;i<gifts.size();i++)\\n            sum+=gifts[i];\\n    return sum;\\n    }"
                    },
                    {
                        "username": "bparanj",
                        "content": "This approach has several issues:\\n\\n1. **Finding Maximum Incorrectly:** The loop is intended to find the maximum element in `gifts[]` and then update the maximum element with its square root. However, it\\'s incorrectly updating `gifts[i]` with the square root of `maxi` every time it finds a new maximum. As a result, it\\'s possible that not just the maximum element but several elements get updated in each iteration of the outer loop.\\n\\n2. **Wrong Transformation Operation:** According to our original problem, each chosen gift\\'s value should be reduced to half of its original value, but this code is replacing the maximum value with its square root, which doesn\\'t match the problem\\'s requirements.\\n\\n3. **No Breaking Condition:** There is no condition to break out of the loop if all elements in `gifts[]` become 0. The loop continues for `k` times, which could lead to unnecessary computations.\\n\\n4. **Time Complexity:** This code has a time complexity of O(k*n) because for each of `k` iterations, it\\'s performing an O(n) operation to find the maximum value in the array. This would not be efficient for large inputs.\\n\\nHere\\'s the correct approach:\\n\\n```cpp\\nfor(int i=0; i < k; i++) {\\n    int maxIndex = max_element(gifts.begin(), gifts.end()) - gifts.begin();\\n    gifts[maxIndex] = gifts[maxIndex] / 2;\\n}\\n```\\n\\nIn this code, `max_element()` is a built-in function in C++ that returns an iterator pointing to the maximum element in the range [first, last) that we\\'ve passed. We then subtract `gifts.begin()` from this iterator to get the index of the maximum element in our array. We can then directly halve the value at this index. The loop runs for `k` iterations, and in each iteration, we\\'re finding and halving the maximum value in our array."
                    }
                ]
            },
            {
                "id": 1955620,
                "content": [
                    {
                        "username": "tomfiji",
                        "content": "For the first example, how is the answer 29 and not 30? I imagine the final list would look like: [10, 8, 5, 3, 4]. Am I missing something here?"
                    },
                    {
                        "username": "amanjaiswal159",
                        "content": "[@sandagolcea](/sandagolcea) This explained the complete problem statement and much better than what explained in question."
                    },
                    {
                        "username": "kalaskarrohit7502",
                        "content": "[@sandagolcea](/sandagolcea) thanks for explanation "
                    },
                    {
                        "username": "sandagolcea",
                        "content": "Yes, thing is: you always look at the array and `reconsider ALL values`, INCLUDING the values that you've already handled.\n\n```\ngifts = [25,64,9,4,100]\n\nk = 1, max is 100, so we replace it with sqrt(100)\ngifts = [25,64,9,4,10]\n\nk = 2, max is 64, so we replace it with sqrt(64)\ngifts = [25,8,9,4,10]\n\nk = 3, max is 25, so we replace it with sqrt(25)\ngifts = [5,8,9,4,10]\n\nTHIS IS WHERE IT'S CONFUSING:\nk = 4, max is ..not 9, it's the value we modified at step k = 1, aka 10,\nso we replace this max value with floor of sqrt(10) = 3\ngifts = [5,8,9,4,3]\n\nNow add all vals, and you get 5 + 8 + 9 + 4 + 3 = 29\n```"
                    },
                    {
                        "username": "S_Basu",
                        "content": "*Two approaches that readily come to mind:*\n- Brute force: Sorting `gifts[]` before every operation\n- **Priority Queue** (Reverse Order)\n##### [Link to Solution](https://leetcode.com/problems/take-gifts-from-the-richest-pile/solutions/3144106/2-java-solutions-100-time-space/)"
                    },
                    {
                        "username": "MayuD",
                        "content": "Similar to \\nhttps://leetcode.com/problems/maximal-score-after-applying-k-operations/"
                    },
                    {
                        "username": "satyam47",
                        "content": "Hint :  **priority_queue**"
                    },
                    {
                        "username": "dhruv4023",
                        "content": "My solution in python language:\\n\\n    def pickGifts(self, gifts: List[int], k: int) -> int:\\n        def fun(g,k):\\n            # g=[25,64,9,4,100]\\n            while k!=0:\\n                k=k-1\\n                m=max(g)\\n                i=g.index(m)\\n                g[i]=int(m**(1/2))\\n            return sum(g)\\n        return fun(gifts,k)\\n"
                    },
                    {
                        "username": "shreyaahadkar",
                        "content": "Could someone please tell me what is wrong with my solution?\\nIt\\'s working but only for a few cases...\\n\\n        while k != 0:\\n            for i in range(len(gifts)):\\n                x = math.floor(math.sqrt(max(gifts)))\\n                if gifts[i] == max(gifts):\\n                    gifts[i] = x\\n                    k -= 1\\n        return gifts"
                    },
                    {
                        "username": "bparanj",
                        "content": "Your approach seems to have a nested loop which results in the operation executing `len(gifts) * k` times. However, you need the operation to only run \\'k\\' times. The current structure of the code causes it to modify the pile \\'k\\' times for each pile, which is not what the problem statement specifies.\\n\\nAdditionally, you\\'re finding the maximum value of the array in every iteration, which is a heavy operation and could be optimized.\\n\\nInstead, what you need is a single loop that runs \\'k\\' times. In each iteration, you find the largest pile, take its square root, and replace the original value. One way to efficiently do this is to use a priority queue (heap) data structure which keeps the elements in order and allows efficient extraction of the maximum element."
                    },
                    {
                        "username": "batariloa",
                        "content": "I do not understand whats wrong with my solution. It fails on test 52.\\n\\n\\nfunc pickGifts(gifts []int, k int) int64 {\\n\\n\\tsize := len(gifts)\\n\\n\\tlastLeafNodeIndex := (size - 1) / 2\\n\\n\\tmaxHeapify(&gifts, size, int(lastLeafNodeIndex))\\n\\n\\tfor k > 0 {\\n\\t\\tfloorSqrt := int(math.Sqrt(float64(gifts[0]))) \\n\\t\\tgifts[0] = floorSqrt \\n\\t\\tmaxHeapify(&gifts, size, 0)\\n\\t\\tk--\\n\\t}\\n\\n\\treturn int64(countGifts(gifts))\\n}\\n\\nfunc countGifts(heap []int) int {\\n\\n\\tsum := 0\\n\\tfor _, num := range heap {\\n\\t\\tsum += num\\n\\t}\\n\\n\\treturn sum\\n}\\n\\nfunc maxHeapify(heap *[]int, size int, i int) {\\n\\n\\tl := 2*i + 1\\n\\tr := 2*i + 2\\n\\n\\tlargest := i\\n\\n\\tif l < size && (*heap)[l] > (*heap)[i] {\\n\\t\\tlargest = l\\n\\t}\\n\\n\\tif r < size && (*heap)[r] > (*heap)[largest] {\\n\\t\\tlargest = r\\n\\t}\\n\\n\\tif largest != i {\\n\\t\\t(*heap)[i], (*heap)[largest] = (*heap)[largest], (*heap)[i]\\n\\t\\tmaxHeapify(heap, size, largest)\\n\\t}\\n}\\n\\n"
                    },
                    {
                        "username": "bparanj",
                        "content": "The issue here is likely with how you\\'re building your initial max heap. The max heapify function is being called starting from the last leaf node\\'s parent and you do not iterate backwards to include all parents of the leaf nodes. Because of this, your initial heap might not be a max heap.\\n\\nWhen you start from the last leaf node\\'s parent, you should then go backwards through the array, ensuring all subtrees are max heaps. You can do this by adding a loop that goes from last leaf node\\'s parent to the root of the tree (index 0) in a reverse manner. \\n\\nHere\\'s how you can modify the max heap construction part of your code:\\n\\n```go\\nfor i := lastLeafNodeIndex; i >= 0; i-- {\\n\\tmaxHeapify(&gifts, size, i)\\n}\\n```\\nThis way, you ensure that your heap property is maintained from the start. Then, as you continue to pick gifts, the max heapify function should correctly rearrange the elements to maintain the max heap property.\\n\\nThis change is necessary because in the heap data structure, the parent node must always have a value that is greater than or equal to its children. So, we need to start heapifying from the bottom of the tree and work our way up to the root to ensure this property is maintained."
                    },
                    {
                        "username": "sandagolcea",
                        "content": "For JS - leetcode uses a library for the max priority queue. This is how you use it:\n ```\nlet q = new MaxPriorityQueue();\n// add a val:\n// let giftValue = 7;\nq.enqueue(giftValue);\n// pop (the elem with the biggest val):\nlet maxVal = q.dequeue().element;\n```"
                    },
                    {
                        "username": "izzatullohboy007",
                        "content": "class Solution:\\n    def pickGifts(self, gifts: List[int], k: int) -> int:\\n        import math \\n        for i in range(k):\\n            s = max(gifts)\\n            gifts.append(math.isqrt(s))\\n            gifts.remove(s)\\n        return sum(gifts)\\n\\n"
                    },
                    {
                        "username": "devottam2809",
                        "content": "whats is wrong with this approach??    \\n while(k--)\\n     {\\n       int maxi=INT_MIN;\\n         for(int i=0;i<gifts.size();i++)\\n         {\\n            if(gifts[i]>maxi)\\n            {\\n                maxi=gifts[i];\\n                int temp=sqrt(maxi);\\n                gifts[i]=temp;\\n            }\\n         }\\n     }\\n    int sum=0;\\n        for(int i=0;i<gifts.size();i++)\\n            sum+=gifts[i];\\n    return sum;\\n    }"
                    },
                    {
                        "username": "bparanj",
                        "content": "This approach has several issues:\\n\\n1. **Finding Maximum Incorrectly:** The loop is intended to find the maximum element in `gifts[]` and then update the maximum element with its square root. However, it\\'s incorrectly updating `gifts[i]` with the square root of `maxi` every time it finds a new maximum. As a result, it\\'s possible that not just the maximum element but several elements get updated in each iteration of the outer loop.\\n\\n2. **Wrong Transformation Operation:** According to our original problem, each chosen gift\\'s value should be reduced to half of its original value, but this code is replacing the maximum value with its square root, which doesn\\'t match the problem\\'s requirements.\\n\\n3. **No Breaking Condition:** There is no condition to break out of the loop if all elements in `gifts[]` become 0. The loop continues for `k` times, which could lead to unnecessary computations.\\n\\n4. **Time Complexity:** This code has a time complexity of O(k*n) because for each of `k` iterations, it\\'s performing an O(n) operation to find the maximum value in the array. This would not be efficient for large inputs.\\n\\nHere\\'s the correct approach:\\n\\n```cpp\\nfor(int i=0; i < k; i++) {\\n    int maxIndex = max_element(gifts.begin(), gifts.end()) - gifts.begin();\\n    gifts[maxIndex] = gifts[maxIndex] / 2;\\n}\\n```\\n\\nIn this code, `max_element()` is a built-in function in C++ that returns an iterator pointing to the maximum element in the range [first, last) that we\\'ve passed. We then subtract `gifts.begin()` from this iterator to get the index of the maximum element in our array. We can then directly halve the value at this index. The loop runs for `k` iterations, and in each iteration, we\\'re finding and halving the maximum value in our array."
                    }
                ]
            },
            {
                "id": 1953246,
                "content": [
                    {
                        "username": "tomfiji",
                        "content": "For the first example, how is the answer 29 and not 30? I imagine the final list would look like: [10, 8, 5, 3, 4]. Am I missing something here?"
                    },
                    {
                        "username": "amanjaiswal159",
                        "content": "[@sandagolcea](/sandagolcea) This explained the complete problem statement and much better than what explained in question."
                    },
                    {
                        "username": "kalaskarrohit7502",
                        "content": "[@sandagolcea](/sandagolcea) thanks for explanation "
                    },
                    {
                        "username": "sandagolcea",
                        "content": "Yes, thing is: you always look at the array and `reconsider ALL values`, INCLUDING the values that you've already handled.\n\n```\ngifts = [25,64,9,4,100]\n\nk = 1, max is 100, so we replace it with sqrt(100)\ngifts = [25,64,9,4,10]\n\nk = 2, max is 64, so we replace it with sqrt(64)\ngifts = [25,8,9,4,10]\n\nk = 3, max is 25, so we replace it with sqrt(25)\ngifts = [5,8,9,4,10]\n\nTHIS IS WHERE IT'S CONFUSING:\nk = 4, max is ..not 9, it's the value we modified at step k = 1, aka 10,\nso we replace this max value with floor of sqrt(10) = 3\ngifts = [5,8,9,4,3]\n\nNow add all vals, and you get 5 + 8 + 9 + 4 + 3 = 29\n```"
                    },
                    {
                        "username": "S_Basu",
                        "content": "*Two approaches that readily come to mind:*\n- Brute force: Sorting `gifts[]` before every operation\n- **Priority Queue** (Reverse Order)\n##### [Link to Solution](https://leetcode.com/problems/take-gifts-from-the-richest-pile/solutions/3144106/2-java-solutions-100-time-space/)"
                    },
                    {
                        "username": "MayuD",
                        "content": "Similar to \\nhttps://leetcode.com/problems/maximal-score-after-applying-k-operations/"
                    },
                    {
                        "username": "satyam47",
                        "content": "Hint :  **priority_queue**"
                    },
                    {
                        "username": "dhruv4023",
                        "content": "My solution in python language:\\n\\n    def pickGifts(self, gifts: List[int], k: int) -> int:\\n        def fun(g,k):\\n            # g=[25,64,9,4,100]\\n            while k!=0:\\n                k=k-1\\n                m=max(g)\\n                i=g.index(m)\\n                g[i]=int(m**(1/2))\\n            return sum(g)\\n        return fun(gifts,k)\\n"
                    },
                    {
                        "username": "shreyaahadkar",
                        "content": "Could someone please tell me what is wrong with my solution?\\nIt\\'s working but only for a few cases...\\n\\n        while k != 0:\\n            for i in range(len(gifts)):\\n                x = math.floor(math.sqrt(max(gifts)))\\n                if gifts[i] == max(gifts):\\n                    gifts[i] = x\\n                    k -= 1\\n        return gifts"
                    },
                    {
                        "username": "bparanj",
                        "content": "Your approach seems to have a nested loop which results in the operation executing `len(gifts) * k` times. However, you need the operation to only run \\'k\\' times. The current structure of the code causes it to modify the pile \\'k\\' times for each pile, which is not what the problem statement specifies.\\n\\nAdditionally, you\\'re finding the maximum value of the array in every iteration, which is a heavy operation and could be optimized.\\n\\nInstead, what you need is a single loop that runs \\'k\\' times. In each iteration, you find the largest pile, take its square root, and replace the original value. One way to efficiently do this is to use a priority queue (heap) data structure which keeps the elements in order and allows efficient extraction of the maximum element."
                    },
                    {
                        "username": "batariloa",
                        "content": "I do not understand whats wrong with my solution. It fails on test 52.\\n\\n\\nfunc pickGifts(gifts []int, k int) int64 {\\n\\n\\tsize := len(gifts)\\n\\n\\tlastLeafNodeIndex := (size - 1) / 2\\n\\n\\tmaxHeapify(&gifts, size, int(lastLeafNodeIndex))\\n\\n\\tfor k > 0 {\\n\\t\\tfloorSqrt := int(math.Sqrt(float64(gifts[0]))) \\n\\t\\tgifts[0] = floorSqrt \\n\\t\\tmaxHeapify(&gifts, size, 0)\\n\\t\\tk--\\n\\t}\\n\\n\\treturn int64(countGifts(gifts))\\n}\\n\\nfunc countGifts(heap []int) int {\\n\\n\\tsum := 0\\n\\tfor _, num := range heap {\\n\\t\\tsum += num\\n\\t}\\n\\n\\treturn sum\\n}\\n\\nfunc maxHeapify(heap *[]int, size int, i int) {\\n\\n\\tl := 2*i + 1\\n\\tr := 2*i + 2\\n\\n\\tlargest := i\\n\\n\\tif l < size && (*heap)[l] > (*heap)[i] {\\n\\t\\tlargest = l\\n\\t}\\n\\n\\tif r < size && (*heap)[r] > (*heap)[largest] {\\n\\t\\tlargest = r\\n\\t}\\n\\n\\tif largest != i {\\n\\t\\t(*heap)[i], (*heap)[largest] = (*heap)[largest], (*heap)[i]\\n\\t\\tmaxHeapify(heap, size, largest)\\n\\t}\\n}\\n\\n"
                    },
                    {
                        "username": "bparanj",
                        "content": "The issue here is likely with how you\\'re building your initial max heap. The max heapify function is being called starting from the last leaf node\\'s parent and you do not iterate backwards to include all parents of the leaf nodes. Because of this, your initial heap might not be a max heap.\\n\\nWhen you start from the last leaf node\\'s parent, you should then go backwards through the array, ensuring all subtrees are max heaps. You can do this by adding a loop that goes from last leaf node\\'s parent to the root of the tree (index 0) in a reverse manner. \\n\\nHere\\'s how you can modify the max heap construction part of your code:\\n\\n```go\\nfor i := lastLeafNodeIndex; i >= 0; i-- {\\n\\tmaxHeapify(&gifts, size, i)\\n}\\n```\\nThis way, you ensure that your heap property is maintained from the start. Then, as you continue to pick gifts, the max heapify function should correctly rearrange the elements to maintain the max heap property.\\n\\nThis change is necessary because in the heap data structure, the parent node must always have a value that is greater than or equal to its children. So, we need to start heapifying from the bottom of the tree and work our way up to the root to ensure this property is maintained."
                    },
                    {
                        "username": "sandagolcea",
                        "content": "For JS - leetcode uses a library for the max priority queue. This is how you use it:\n ```\nlet q = new MaxPriorityQueue();\n// add a val:\n// let giftValue = 7;\nq.enqueue(giftValue);\n// pop (the elem with the biggest val):\nlet maxVal = q.dequeue().element;\n```"
                    },
                    {
                        "username": "izzatullohboy007",
                        "content": "class Solution:\\n    def pickGifts(self, gifts: List[int], k: int) -> int:\\n        import math \\n        for i in range(k):\\n            s = max(gifts)\\n            gifts.append(math.isqrt(s))\\n            gifts.remove(s)\\n        return sum(gifts)\\n\\n"
                    },
                    {
                        "username": "devottam2809",
                        "content": "whats is wrong with this approach??    \\n while(k--)\\n     {\\n       int maxi=INT_MIN;\\n         for(int i=0;i<gifts.size();i++)\\n         {\\n            if(gifts[i]>maxi)\\n            {\\n                maxi=gifts[i];\\n                int temp=sqrt(maxi);\\n                gifts[i]=temp;\\n            }\\n         }\\n     }\\n    int sum=0;\\n        for(int i=0;i<gifts.size();i++)\\n            sum+=gifts[i];\\n    return sum;\\n    }"
                    },
                    {
                        "username": "bparanj",
                        "content": "This approach has several issues:\\n\\n1. **Finding Maximum Incorrectly:** The loop is intended to find the maximum element in `gifts[]` and then update the maximum element with its square root. However, it\\'s incorrectly updating `gifts[i]` with the square root of `maxi` every time it finds a new maximum. As a result, it\\'s possible that not just the maximum element but several elements get updated in each iteration of the outer loop.\\n\\n2. **Wrong Transformation Operation:** According to our original problem, each chosen gift\\'s value should be reduced to half of its original value, but this code is replacing the maximum value with its square root, which doesn\\'t match the problem\\'s requirements.\\n\\n3. **No Breaking Condition:** There is no condition to break out of the loop if all elements in `gifts[]` become 0. The loop continues for `k` times, which could lead to unnecessary computations.\\n\\n4. **Time Complexity:** This code has a time complexity of O(k*n) because for each of `k` iterations, it\\'s performing an O(n) operation to find the maximum value in the array. This would not be efficient for large inputs.\\n\\nHere\\'s the correct approach:\\n\\n```cpp\\nfor(int i=0; i < k; i++) {\\n    int maxIndex = max_element(gifts.begin(), gifts.end()) - gifts.begin();\\n    gifts[maxIndex] = gifts[maxIndex] / 2;\\n}\\n```\\n\\nIn this code, `max_element()` is a built-in function in C++ that returns an iterator pointing to the maximum element in the range [first, last) that we\\'ve passed. We then subtract `gifts.begin()` from this iterator to get the index of the maximum element in our array. We can then directly halve the value at this index. The loop runs for `k` iterations, and in each iteration, we\\'re finding and halving the maximum value in our array."
                    }
                ]
            },
            {
                "id": 1812579,
                "content": [
                    {
                        "username": "tomfiji",
                        "content": "For the first example, how is the answer 29 and not 30? I imagine the final list would look like: [10, 8, 5, 3, 4]. Am I missing something here?"
                    },
                    {
                        "username": "amanjaiswal159",
                        "content": "[@sandagolcea](/sandagolcea) This explained the complete problem statement and much better than what explained in question."
                    },
                    {
                        "username": "kalaskarrohit7502",
                        "content": "[@sandagolcea](/sandagolcea) thanks for explanation "
                    },
                    {
                        "username": "sandagolcea",
                        "content": "Yes, thing is: you always look at the array and `reconsider ALL values`, INCLUDING the values that you've already handled.\n\n```\ngifts = [25,64,9,4,100]\n\nk = 1, max is 100, so we replace it with sqrt(100)\ngifts = [25,64,9,4,10]\n\nk = 2, max is 64, so we replace it with sqrt(64)\ngifts = [25,8,9,4,10]\n\nk = 3, max is 25, so we replace it with sqrt(25)\ngifts = [5,8,9,4,10]\n\nTHIS IS WHERE IT'S CONFUSING:\nk = 4, max is ..not 9, it's the value we modified at step k = 1, aka 10,\nso we replace this max value with floor of sqrt(10) = 3\ngifts = [5,8,9,4,3]\n\nNow add all vals, and you get 5 + 8 + 9 + 4 + 3 = 29\n```"
                    },
                    {
                        "username": "S_Basu",
                        "content": "*Two approaches that readily come to mind:*\n- Brute force: Sorting `gifts[]` before every operation\n- **Priority Queue** (Reverse Order)\n##### [Link to Solution](https://leetcode.com/problems/take-gifts-from-the-richest-pile/solutions/3144106/2-java-solutions-100-time-space/)"
                    },
                    {
                        "username": "MayuD",
                        "content": "Similar to \\nhttps://leetcode.com/problems/maximal-score-after-applying-k-operations/"
                    },
                    {
                        "username": "satyam47",
                        "content": "Hint :  **priority_queue**"
                    },
                    {
                        "username": "dhruv4023",
                        "content": "My solution in python language:\\n\\n    def pickGifts(self, gifts: List[int], k: int) -> int:\\n        def fun(g,k):\\n            # g=[25,64,9,4,100]\\n            while k!=0:\\n                k=k-1\\n                m=max(g)\\n                i=g.index(m)\\n                g[i]=int(m**(1/2))\\n            return sum(g)\\n        return fun(gifts,k)\\n"
                    },
                    {
                        "username": "shreyaahadkar",
                        "content": "Could someone please tell me what is wrong with my solution?\\nIt\\'s working but only for a few cases...\\n\\n        while k != 0:\\n            for i in range(len(gifts)):\\n                x = math.floor(math.sqrt(max(gifts)))\\n                if gifts[i] == max(gifts):\\n                    gifts[i] = x\\n                    k -= 1\\n        return gifts"
                    },
                    {
                        "username": "bparanj",
                        "content": "Your approach seems to have a nested loop which results in the operation executing `len(gifts) * k` times. However, you need the operation to only run \\'k\\' times. The current structure of the code causes it to modify the pile \\'k\\' times for each pile, which is not what the problem statement specifies.\\n\\nAdditionally, you\\'re finding the maximum value of the array in every iteration, which is a heavy operation and could be optimized.\\n\\nInstead, what you need is a single loop that runs \\'k\\' times. In each iteration, you find the largest pile, take its square root, and replace the original value. One way to efficiently do this is to use a priority queue (heap) data structure which keeps the elements in order and allows efficient extraction of the maximum element."
                    },
                    {
                        "username": "batariloa",
                        "content": "I do not understand whats wrong with my solution. It fails on test 52.\\n\\n\\nfunc pickGifts(gifts []int, k int) int64 {\\n\\n\\tsize := len(gifts)\\n\\n\\tlastLeafNodeIndex := (size - 1) / 2\\n\\n\\tmaxHeapify(&gifts, size, int(lastLeafNodeIndex))\\n\\n\\tfor k > 0 {\\n\\t\\tfloorSqrt := int(math.Sqrt(float64(gifts[0]))) \\n\\t\\tgifts[0] = floorSqrt \\n\\t\\tmaxHeapify(&gifts, size, 0)\\n\\t\\tk--\\n\\t}\\n\\n\\treturn int64(countGifts(gifts))\\n}\\n\\nfunc countGifts(heap []int) int {\\n\\n\\tsum := 0\\n\\tfor _, num := range heap {\\n\\t\\tsum += num\\n\\t}\\n\\n\\treturn sum\\n}\\n\\nfunc maxHeapify(heap *[]int, size int, i int) {\\n\\n\\tl := 2*i + 1\\n\\tr := 2*i + 2\\n\\n\\tlargest := i\\n\\n\\tif l < size && (*heap)[l] > (*heap)[i] {\\n\\t\\tlargest = l\\n\\t}\\n\\n\\tif r < size && (*heap)[r] > (*heap)[largest] {\\n\\t\\tlargest = r\\n\\t}\\n\\n\\tif largest != i {\\n\\t\\t(*heap)[i], (*heap)[largest] = (*heap)[largest], (*heap)[i]\\n\\t\\tmaxHeapify(heap, size, largest)\\n\\t}\\n}\\n\\n"
                    },
                    {
                        "username": "bparanj",
                        "content": "The issue here is likely with how you\\'re building your initial max heap. The max heapify function is being called starting from the last leaf node\\'s parent and you do not iterate backwards to include all parents of the leaf nodes. Because of this, your initial heap might not be a max heap.\\n\\nWhen you start from the last leaf node\\'s parent, you should then go backwards through the array, ensuring all subtrees are max heaps. You can do this by adding a loop that goes from last leaf node\\'s parent to the root of the tree (index 0) in a reverse manner. \\n\\nHere\\'s how you can modify the max heap construction part of your code:\\n\\n```go\\nfor i := lastLeafNodeIndex; i >= 0; i-- {\\n\\tmaxHeapify(&gifts, size, i)\\n}\\n```\\nThis way, you ensure that your heap property is maintained from the start. Then, as you continue to pick gifts, the max heapify function should correctly rearrange the elements to maintain the max heap property.\\n\\nThis change is necessary because in the heap data structure, the parent node must always have a value that is greater than or equal to its children. So, we need to start heapifying from the bottom of the tree and work our way up to the root to ensure this property is maintained."
                    },
                    {
                        "username": "sandagolcea",
                        "content": "For JS - leetcode uses a library for the max priority queue. This is how you use it:\n ```\nlet q = new MaxPriorityQueue();\n// add a val:\n// let giftValue = 7;\nq.enqueue(giftValue);\n// pop (the elem with the biggest val):\nlet maxVal = q.dequeue().element;\n```"
                    },
                    {
                        "username": "izzatullohboy007",
                        "content": "class Solution:\\n    def pickGifts(self, gifts: List[int], k: int) -> int:\\n        import math \\n        for i in range(k):\\n            s = max(gifts)\\n            gifts.append(math.isqrt(s))\\n            gifts.remove(s)\\n        return sum(gifts)\\n\\n"
                    },
                    {
                        "username": "devottam2809",
                        "content": "whats is wrong with this approach??    \\n while(k--)\\n     {\\n       int maxi=INT_MIN;\\n         for(int i=0;i<gifts.size();i++)\\n         {\\n            if(gifts[i]>maxi)\\n            {\\n                maxi=gifts[i];\\n                int temp=sqrt(maxi);\\n                gifts[i]=temp;\\n            }\\n         }\\n     }\\n    int sum=0;\\n        for(int i=0;i<gifts.size();i++)\\n            sum+=gifts[i];\\n    return sum;\\n    }"
                    },
                    {
                        "username": "bparanj",
                        "content": "This approach has several issues:\\n\\n1. **Finding Maximum Incorrectly:** The loop is intended to find the maximum element in `gifts[]` and then update the maximum element with its square root. However, it\\'s incorrectly updating `gifts[i]` with the square root of `maxi` every time it finds a new maximum. As a result, it\\'s possible that not just the maximum element but several elements get updated in each iteration of the outer loop.\\n\\n2. **Wrong Transformation Operation:** According to our original problem, each chosen gift\\'s value should be reduced to half of its original value, but this code is replacing the maximum value with its square root, which doesn\\'t match the problem\\'s requirements.\\n\\n3. **No Breaking Condition:** There is no condition to break out of the loop if all elements in `gifts[]` become 0. The loop continues for `k` times, which could lead to unnecessary computations.\\n\\n4. **Time Complexity:** This code has a time complexity of O(k*n) because for each of `k` iterations, it\\'s performing an O(n) operation to find the maximum value in the array. This would not be efficient for large inputs.\\n\\nHere\\'s the correct approach:\\n\\n```cpp\\nfor(int i=0; i < k; i++) {\\n    int maxIndex = max_element(gifts.begin(), gifts.end()) - gifts.begin();\\n    gifts[maxIndex] = gifts[maxIndex] / 2;\\n}\\n```\\n\\nIn this code, `max_element()` is a built-in function in C++ that returns an iterator pointing to the maximum element in the range [first, last) that we\\'ve passed. We then subtract `gifts.begin()` from this iterator to get the index of the maximum element in our array. We can then directly halve the value at this index. The loop runs for `k` iterations, and in each iteration, we\\'re finding and halving the maximum value in our array."
                    }
                ]
            },
            {
                "id": 1800692,
                "content": [
                    {
                        "username": "tomfiji",
                        "content": "For the first example, how is the answer 29 and not 30? I imagine the final list would look like: [10, 8, 5, 3, 4]. Am I missing something here?"
                    },
                    {
                        "username": "amanjaiswal159",
                        "content": "[@sandagolcea](/sandagolcea) This explained the complete problem statement and much better than what explained in question."
                    },
                    {
                        "username": "kalaskarrohit7502",
                        "content": "[@sandagolcea](/sandagolcea) thanks for explanation "
                    },
                    {
                        "username": "sandagolcea",
                        "content": "Yes, thing is: you always look at the array and `reconsider ALL values`, INCLUDING the values that you've already handled.\n\n```\ngifts = [25,64,9,4,100]\n\nk = 1, max is 100, so we replace it with sqrt(100)\ngifts = [25,64,9,4,10]\n\nk = 2, max is 64, so we replace it with sqrt(64)\ngifts = [25,8,9,4,10]\n\nk = 3, max is 25, so we replace it with sqrt(25)\ngifts = [5,8,9,4,10]\n\nTHIS IS WHERE IT'S CONFUSING:\nk = 4, max is ..not 9, it's the value we modified at step k = 1, aka 10,\nso we replace this max value with floor of sqrt(10) = 3\ngifts = [5,8,9,4,3]\n\nNow add all vals, and you get 5 + 8 + 9 + 4 + 3 = 29\n```"
                    },
                    {
                        "username": "S_Basu",
                        "content": "*Two approaches that readily come to mind:*\n- Brute force: Sorting `gifts[]` before every operation\n- **Priority Queue** (Reverse Order)\n##### [Link to Solution](https://leetcode.com/problems/take-gifts-from-the-richest-pile/solutions/3144106/2-java-solutions-100-time-space/)"
                    },
                    {
                        "username": "MayuD",
                        "content": "Similar to \\nhttps://leetcode.com/problems/maximal-score-after-applying-k-operations/"
                    },
                    {
                        "username": "satyam47",
                        "content": "Hint :  **priority_queue**"
                    },
                    {
                        "username": "dhruv4023",
                        "content": "My solution in python language:\\n\\n    def pickGifts(self, gifts: List[int], k: int) -> int:\\n        def fun(g,k):\\n            # g=[25,64,9,4,100]\\n            while k!=0:\\n                k=k-1\\n                m=max(g)\\n                i=g.index(m)\\n                g[i]=int(m**(1/2))\\n            return sum(g)\\n        return fun(gifts,k)\\n"
                    },
                    {
                        "username": "shreyaahadkar",
                        "content": "Could someone please tell me what is wrong with my solution?\\nIt\\'s working but only for a few cases...\\n\\n        while k != 0:\\n            for i in range(len(gifts)):\\n                x = math.floor(math.sqrt(max(gifts)))\\n                if gifts[i] == max(gifts):\\n                    gifts[i] = x\\n                    k -= 1\\n        return gifts"
                    },
                    {
                        "username": "bparanj",
                        "content": "Your approach seems to have a nested loop which results in the operation executing `len(gifts) * k` times. However, you need the operation to only run \\'k\\' times. The current structure of the code causes it to modify the pile \\'k\\' times for each pile, which is not what the problem statement specifies.\\n\\nAdditionally, you\\'re finding the maximum value of the array in every iteration, which is a heavy operation and could be optimized.\\n\\nInstead, what you need is a single loop that runs \\'k\\' times. In each iteration, you find the largest pile, take its square root, and replace the original value. One way to efficiently do this is to use a priority queue (heap) data structure which keeps the elements in order and allows efficient extraction of the maximum element."
                    },
                    {
                        "username": "batariloa",
                        "content": "I do not understand whats wrong with my solution. It fails on test 52.\\n\\n\\nfunc pickGifts(gifts []int, k int) int64 {\\n\\n\\tsize := len(gifts)\\n\\n\\tlastLeafNodeIndex := (size - 1) / 2\\n\\n\\tmaxHeapify(&gifts, size, int(lastLeafNodeIndex))\\n\\n\\tfor k > 0 {\\n\\t\\tfloorSqrt := int(math.Sqrt(float64(gifts[0]))) \\n\\t\\tgifts[0] = floorSqrt \\n\\t\\tmaxHeapify(&gifts, size, 0)\\n\\t\\tk--\\n\\t}\\n\\n\\treturn int64(countGifts(gifts))\\n}\\n\\nfunc countGifts(heap []int) int {\\n\\n\\tsum := 0\\n\\tfor _, num := range heap {\\n\\t\\tsum += num\\n\\t}\\n\\n\\treturn sum\\n}\\n\\nfunc maxHeapify(heap *[]int, size int, i int) {\\n\\n\\tl := 2*i + 1\\n\\tr := 2*i + 2\\n\\n\\tlargest := i\\n\\n\\tif l < size && (*heap)[l] > (*heap)[i] {\\n\\t\\tlargest = l\\n\\t}\\n\\n\\tif r < size && (*heap)[r] > (*heap)[largest] {\\n\\t\\tlargest = r\\n\\t}\\n\\n\\tif largest != i {\\n\\t\\t(*heap)[i], (*heap)[largest] = (*heap)[largest], (*heap)[i]\\n\\t\\tmaxHeapify(heap, size, largest)\\n\\t}\\n}\\n\\n"
                    },
                    {
                        "username": "bparanj",
                        "content": "The issue here is likely with how you\\'re building your initial max heap. The max heapify function is being called starting from the last leaf node\\'s parent and you do not iterate backwards to include all parents of the leaf nodes. Because of this, your initial heap might not be a max heap.\\n\\nWhen you start from the last leaf node\\'s parent, you should then go backwards through the array, ensuring all subtrees are max heaps. You can do this by adding a loop that goes from last leaf node\\'s parent to the root of the tree (index 0) in a reverse manner. \\n\\nHere\\'s how you can modify the max heap construction part of your code:\\n\\n```go\\nfor i := lastLeafNodeIndex; i >= 0; i-- {\\n\\tmaxHeapify(&gifts, size, i)\\n}\\n```\\nThis way, you ensure that your heap property is maintained from the start. Then, as you continue to pick gifts, the max heapify function should correctly rearrange the elements to maintain the max heap property.\\n\\nThis change is necessary because in the heap data structure, the parent node must always have a value that is greater than or equal to its children. So, we need to start heapifying from the bottom of the tree and work our way up to the root to ensure this property is maintained."
                    },
                    {
                        "username": "sandagolcea",
                        "content": "For JS - leetcode uses a library for the max priority queue. This is how you use it:\n ```\nlet q = new MaxPriorityQueue();\n// add a val:\n// let giftValue = 7;\nq.enqueue(giftValue);\n// pop (the elem with the biggest val):\nlet maxVal = q.dequeue().element;\n```"
                    },
                    {
                        "username": "izzatullohboy007",
                        "content": "class Solution:\\n    def pickGifts(self, gifts: List[int], k: int) -> int:\\n        import math \\n        for i in range(k):\\n            s = max(gifts)\\n            gifts.append(math.isqrt(s))\\n            gifts.remove(s)\\n        return sum(gifts)\\n\\n"
                    },
                    {
                        "username": "devottam2809",
                        "content": "whats is wrong with this approach??    \\n while(k--)\\n     {\\n       int maxi=INT_MIN;\\n         for(int i=0;i<gifts.size();i++)\\n         {\\n            if(gifts[i]>maxi)\\n            {\\n                maxi=gifts[i];\\n                int temp=sqrt(maxi);\\n                gifts[i]=temp;\\n            }\\n         }\\n     }\\n    int sum=0;\\n        for(int i=0;i<gifts.size();i++)\\n            sum+=gifts[i];\\n    return sum;\\n    }"
                    },
                    {
                        "username": "bparanj",
                        "content": "This approach has several issues:\\n\\n1. **Finding Maximum Incorrectly:** The loop is intended to find the maximum element in `gifts[]` and then update the maximum element with its square root. However, it\\'s incorrectly updating `gifts[i]` with the square root of `maxi` every time it finds a new maximum. As a result, it\\'s possible that not just the maximum element but several elements get updated in each iteration of the outer loop.\\n\\n2. **Wrong Transformation Operation:** According to our original problem, each chosen gift\\'s value should be reduced to half of its original value, but this code is replacing the maximum value with its square root, which doesn\\'t match the problem\\'s requirements.\\n\\n3. **No Breaking Condition:** There is no condition to break out of the loop if all elements in `gifts[]` become 0. The loop continues for `k` times, which could lead to unnecessary computations.\\n\\n4. **Time Complexity:** This code has a time complexity of O(k*n) because for each of `k` iterations, it\\'s performing an O(n) operation to find the maximum value in the array. This would not be efficient for large inputs.\\n\\nHere\\'s the correct approach:\\n\\n```cpp\\nfor(int i=0; i < k; i++) {\\n    int maxIndex = max_element(gifts.begin(), gifts.end()) - gifts.begin();\\n    gifts[maxIndex] = gifts[maxIndex] / 2;\\n}\\n```\\n\\nIn this code, `max_element()` is a built-in function in C++ that returns an iterator pointing to the maximum element in the range [first, last) that we\\'ve passed. We then subtract `gifts.begin()` from this iterator to get the index of the maximum element in our array. We can then directly halve the value at this index. The loop runs for `k` iterations, and in each iteration, we\\'re finding and halving the maximum value in our array."
                    }
                ]
            },
            {
                "id": 1791742,
                "content": [
                    {
                        "username": "tomfiji",
                        "content": "For the first example, how is the answer 29 and not 30? I imagine the final list would look like: [10, 8, 5, 3, 4]. Am I missing something here?"
                    },
                    {
                        "username": "amanjaiswal159",
                        "content": "[@sandagolcea](/sandagolcea) This explained the complete problem statement and much better than what explained in question."
                    },
                    {
                        "username": "kalaskarrohit7502",
                        "content": "[@sandagolcea](/sandagolcea) thanks for explanation "
                    },
                    {
                        "username": "sandagolcea",
                        "content": "Yes, thing is: you always look at the array and `reconsider ALL values`, INCLUDING the values that you've already handled.\n\n```\ngifts = [25,64,9,4,100]\n\nk = 1, max is 100, so we replace it with sqrt(100)\ngifts = [25,64,9,4,10]\n\nk = 2, max is 64, so we replace it with sqrt(64)\ngifts = [25,8,9,4,10]\n\nk = 3, max is 25, so we replace it with sqrt(25)\ngifts = [5,8,9,4,10]\n\nTHIS IS WHERE IT'S CONFUSING:\nk = 4, max is ..not 9, it's the value we modified at step k = 1, aka 10,\nso we replace this max value with floor of sqrt(10) = 3\ngifts = [5,8,9,4,3]\n\nNow add all vals, and you get 5 + 8 + 9 + 4 + 3 = 29\n```"
                    },
                    {
                        "username": "S_Basu",
                        "content": "*Two approaches that readily come to mind:*\n- Brute force: Sorting `gifts[]` before every operation\n- **Priority Queue** (Reverse Order)\n##### [Link to Solution](https://leetcode.com/problems/take-gifts-from-the-richest-pile/solutions/3144106/2-java-solutions-100-time-space/)"
                    },
                    {
                        "username": "MayuD",
                        "content": "Similar to \\nhttps://leetcode.com/problems/maximal-score-after-applying-k-operations/"
                    },
                    {
                        "username": "satyam47",
                        "content": "Hint :  **priority_queue**"
                    },
                    {
                        "username": "dhruv4023",
                        "content": "My solution in python language:\\n\\n    def pickGifts(self, gifts: List[int], k: int) -> int:\\n        def fun(g,k):\\n            # g=[25,64,9,4,100]\\n            while k!=0:\\n                k=k-1\\n                m=max(g)\\n                i=g.index(m)\\n                g[i]=int(m**(1/2))\\n            return sum(g)\\n        return fun(gifts,k)\\n"
                    },
                    {
                        "username": "shreyaahadkar",
                        "content": "Could someone please tell me what is wrong with my solution?\\nIt\\'s working but only for a few cases...\\n\\n        while k != 0:\\n            for i in range(len(gifts)):\\n                x = math.floor(math.sqrt(max(gifts)))\\n                if gifts[i] == max(gifts):\\n                    gifts[i] = x\\n                    k -= 1\\n        return gifts"
                    },
                    {
                        "username": "bparanj",
                        "content": "Your approach seems to have a nested loop which results in the operation executing `len(gifts) * k` times. However, you need the operation to only run \\'k\\' times. The current structure of the code causes it to modify the pile \\'k\\' times for each pile, which is not what the problem statement specifies.\\n\\nAdditionally, you\\'re finding the maximum value of the array in every iteration, which is a heavy operation and could be optimized.\\n\\nInstead, what you need is a single loop that runs \\'k\\' times. In each iteration, you find the largest pile, take its square root, and replace the original value. One way to efficiently do this is to use a priority queue (heap) data structure which keeps the elements in order and allows efficient extraction of the maximum element."
                    },
                    {
                        "username": "batariloa",
                        "content": "I do not understand whats wrong with my solution. It fails on test 52.\\n\\n\\nfunc pickGifts(gifts []int, k int) int64 {\\n\\n\\tsize := len(gifts)\\n\\n\\tlastLeafNodeIndex := (size - 1) / 2\\n\\n\\tmaxHeapify(&gifts, size, int(lastLeafNodeIndex))\\n\\n\\tfor k > 0 {\\n\\t\\tfloorSqrt := int(math.Sqrt(float64(gifts[0]))) \\n\\t\\tgifts[0] = floorSqrt \\n\\t\\tmaxHeapify(&gifts, size, 0)\\n\\t\\tk--\\n\\t}\\n\\n\\treturn int64(countGifts(gifts))\\n}\\n\\nfunc countGifts(heap []int) int {\\n\\n\\tsum := 0\\n\\tfor _, num := range heap {\\n\\t\\tsum += num\\n\\t}\\n\\n\\treturn sum\\n}\\n\\nfunc maxHeapify(heap *[]int, size int, i int) {\\n\\n\\tl := 2*i + 1\\n\\tr := 2*i + 2\\n\\n\\tlargest := i\\n\\n\\tif l < size && (*heap)[l] > (*heap)[i] {\\n\\t\\tlargest = l\\n\\t}\\n\\n\\tif r < size && (*heap)[r] > (*heap)[largest] {\\n\\t\\tlargest = r\\n\\t}\\n\\n\\tif largest != i {\\n\\t\\t(*heap)[i], (*heap)[largest] = (*heap)[largest], (*heap)[i]\\n\\t\\tmaxHeapify(heap, size, largest)\\n\\t}\\n}\\n\\n"
                    },
                    {
                        "username": "bparanj",
                        "content": "The issue here is likely with how you\\'re building your initial max heap. The max heapify function is being called starting from the last leaf node\\'s parent and you do not iterate backwards to include all parents of the leaf nodes. Because of this, your initial heap might not be a max heap.\\n\\nWhen you start from the last leaf node\\'s parent, you should then go backwards through the array, ensuring all subtrees are max heaps. You can do this by adding a loop that goes from last leaf node\\'s parent to the root of the tree (index 0) in a reverse manner. \\n\\nHere\\'s how you can modify the max heap construction part of your code:\\n\\n```go\\nfor i := lastLeafNodeIndex; i >= 0; i-- {\\n\\tmaxHeapify(&gifts, size, i)\\n}\\n```\\nThis way, you ensure that your heap property is maintained from the start. Then, as you continue to pick gifts, the max heapify function should correctly rearrange the elements to maintain the max heap property.\\n\\nThis change is necessary because in the heap data structure, the parent node must always have a value that is greater than or equal to its children. So, we need to start heapifying from the bottom of the tree and work our way up to the root to ensure this property is maintained."
                    },
                    {
                        "username": "sandagolcea",
                        "content": "For JS - leetcode uses a library for the max priority queue. This is how you use it:\n ```\nlet q = new MaxPriorityQueue();\n// add a val:\n// let giftValue = 7;\nq.enqueue(giftValue);\n// pop (the elem with the biggest val):\nlet maxVal = q.dequeue().element;\n```"
                    },
                    {
                        "username": "izzatullohboy007",
                        "content": "class Solution:\\n    def pickGifts(self, gifts: List[int], k: int) -> int:\\n        import math \\n        for i in range(k):\\n            s = max(gifts)\\n            gifts.append(math.isqrt(s))\\n            gifts.remove(s)\\n        return sum(gifts)\\n\\n"
                    },
                    {
                        "username": "devottam2809",
                        "content": "whats is wrong with this approach??    \\n while(k--)\\n     {\\n       int maxi=INT_MIN;\\n         for(int i=0;i<gifts.size();i++)\\n         {\\n            if(gifts[i]>maxi)\\n            {\\n                maxi=gifts[i];\\n                int temp=sqrt(maxi);\\n                gifts[i]=temp;\\n            }\\n         }\\n     }\\n    int sum=0;\\n        for(int i=0;i<gifts.size();i++)\\n            sum+=gifts[i];\\n    return sum;\\n    }"
                    },
                    {
                        "username": "bparanj",
                        "content": "This approach has several issues:\\n\\n1. **Finding Maximum Incorrectly:** The loop is intended to find the maximum element in `gifts[]` and then update the maximum element with its square root. However, it\\'s incorrectly updating `gifts[i]` with the square root of `maxi` every time it finds a new maximum. As a result, it\\'s possible that not just the maximum element but several elements get updated in each iteration of the outer loop.\\n\\n2. **Wrong Transformation Operation:** According to our original problem, each chosen gift\\'s value should be reduced to half of its original value, but this code is replacing the maximum value with its square root, which doesn\\'t match the problem\\'s requirements.\\n\\n3. **No Breaking Condition:** There is no condition to break out of the loop if all elements in `gifts[]` become 0. The loop continues for `k` times, which could lead to unnecessary computations.\\n\\n4. **Time Complexity:** This code has a time complexity of O(k*n) because for each of `k` iterations, it\\'s performing an O(n) operation to find the maximum value in the array. This would not be efficient for large inputs.\\n\\nHere\\'s the correct approach:\\n\\n```cpp\\nfor(int i=0; i < k; i++) {\\n    int maxIndex = max_element(gifts.begin(), gifts.end()) - gifts.begin();\\n    gifts[maxIndex] = gifts[maxIndex] / 2;\\n}\\n```\\n\\nIn this code, `max_element()` is a built-in function in C++ that returns an iterator pointing to the maximum element in the range [first, last) that we\\'ve passed. We then subtract `gifts.begin()` from this iterator to get the index of the maximum element in our array. We can then directly halve the value at this index. The loop runs for `k` iterations, and in each iteration, we\\'re finding and halving the maximum value in our array."
                    }
                ]
            },
            {
                "id": 1803541,
                "content": [
                    {
                        "username": "tomfiji",
                        "content": "For the first example, how is the answer 29 and not 30? I imagine the final list would look like: [10, 8, 5, 3, 4]. Am I missing something here?"
                    },
                    {
                        "username": "amanjaiswal159",
                        "content": "[@sandagolcea](/sandagolcea) This explained the complete problem statement and much better than what explained in question."
                    },
                    {
                        "username": "kalaskarrohit7502",
                        "content": "[@sandagolcea](/sandagolcea) thanks for explanation "
                    },
                    {
                        "username": "sandagolcea",
                        "content": "Yes, thing is: you always look at the array and `reconsider ALL values`, INCLUDING the values that you've already handled.\n\n```\ngifts = [25,64,9,4,100]\n\nk = 1, max is 100, so we replace it with sqrt(100)\ngifts = [25,64,9,4,10]\n\nk = 2, max is 64, so we replace it with sqrt(64)\ngifts = [25,8,9,4,10]\n\nk = 3, max is 25, so we replace it with sqrt(25)\ngifts = [5,8,9,4,10]\n\nTHIS IS WHERE IT'S CONFUSING:\nk = 4, max is ..not 9, it's the value we modified at step k = 1, aka 10,\nso we replace this max value with floor of sqrt(10) = 3\ngifts = [5,8,9,4,3]\n\nNow add all vals, and you get 5 + 8 + 9 + 4 + 3 = 29\n```"
                    },
                    {
                        "username": "S_Basu",
                        "content": "*Two approaches that readily come to mind:*\n- Brute force: Sorting `gifts[]` before every operation\n- **Priority Queue** (Reverse Order)\n##### [Link to Solution](https://leetcode.com/problems/take-gifts-from-the-richest-pile/solutions/3144106/2-java-solutions-100-time-space/)"
                    },
                    {
                        "username": "MayuD",
                        "content": "Similar to \\nhttps://leetcode.com/problems/maximal-score-after-applying-k-operations/"
                    },
                    {
                        "username": "satyam47",
                        "content": "Hint :  **priority_queue**"
                    },
                    {
                        "username": "dhruv4023",
                        "content": "My solution in python language:\\n\\n    def pickGifts(self, gifts: List[int], k: int) -> int:\\n        def fun(g,k):\\n            # g=[25,64,9,4,100]\\n            while k!=0:\\n                k=k-1\\n                m=max(g)\\n                i=g.index(m)\\n                g[i]=int(m**(1/2))\\n            return sum(g)\\n        return fun(gifts,k)\\n"
                    },
                    {
                        "username": "shreyaahadkar",
                        "content": "Could someone please tell me what is wrong with my solution?\\nIt\\'s working but only for a few cases...\\n\\n        while k != 0:\\n            for i in range(len(gifts)):\\n                x = math.floor(math.sqrt(max(gifts)))\\n                if gifts[i] == max(gifts):\\n                    gifts[i] = x\\n                    k -= 1\\n        return gifts"
                    },
                    {
                        "username": "bparanj",
                        "content": "Your approach seems to have a nested loop which results in the operation executing `len(gifts) * k` times. However, you need the operation to only run \\'k\\' times. The current structure of the code causes it to modify the pile \\'k\\' times for each pile, which is not what the problem statement specifies.\\n\\nAdditionally, you\\'re finding the maximum value of the array in every iteration, which is a heavy operation and could be optimized.\\n\\nInstead, what you need is a single loop that runs \\'k\\' times. In each iteration, you find the largest pile, take its square root, and replace the original value. One way to efficiently do this is to use a priority queue (heap) data structure which keeps the elements in order and allows efficient extraction of the maximum element."
                    },
                    {
                        "username": "batariloa",
                        "content": "I do not understand whats wrong with my solution. It fails on test 52.\\n\\n\\nfunc pickGifts(gifts []int, k int) int64 {\\n\\n\\tsize := len(gifts)\\n\\n\\tlastLeafNodeIndex := (size - 1) / 2\\n\\n\\tmaxHeapify(&gifts, size, int(lastLeafNodeIndex))\\n\\n\\tfor k > 0 {\\n\\t\\tfloorSqrt := int(math.Sqrt(float64(gifts[0]))) \\n\\t\\tgifts[0] = floorSqrt \\n\\t\\tmaxHeapify(&gifts, size, 0)\\n\\t\\tk--\\n\\t}\\n\\n\\treturn int64(countGifts(gifts))\\n}\\n\\nfunc countGifts(heap []int) int {\\n\\n\\tsum := 0\\n\\tfor _, num := range heap {\\n\\t\\tsum += num\\n\\t}\\n\\n\\treturn sum\\n}\\n\\nfunc maxHeapify(heap *[]int, size int, i int) {\\n\\n\\tl := 2*i + 1\\n\\tr := 2*i + 2\\n\\n\\tlargest := i\\n\\n\\tif l < size && (*heap)[l] > (*heap)[i] {\\n\\t\\tlargest = l\\n\\t}\\n\\n\\tif r < size && (*heap)[r] > (*heap)[largest] {\\n\\t\\tlargest = r\\n\\t}\\n\\n\\tif largest != i {\\n\\t\\t(*heap)[i], (*heap)[largest] = (*heap)[largest], (*heap)[i]\\n\\t\\tmaxHeapify(heap, size, largest)\\n\\t}\\n}\\n\\n"
                    },
                    {
                        "username": "bparanj",
                        "content": "The issue here is likely with how you\\'re building your initial max heap. The max heapify function is being called starting from the last leaf node\\'s parent and you do not iterate backwards to include all parents of the leaf nodes. Because of this, your initial heap might not be a max heap.\\n\\nWhen you start from the last leaf node\\'s parent, you should then go backwards through the array, ensuring all subtrees are max heaps. You can do this by adding a loop that goes from last leaf node\\'s parent to the root of the tree (index 0) in a reverse manner. \\n\\nHere\\'s how you can modify the max heap construction part of your code:\\n\\n```go\\nfor i := lastLeafNodeIndex; i >= 0; i-- {\\n\\tmaxHeapify(&gifts, size, i)\\n}\\n```\\nThis way, you ensure that your heap property is maintained from the start. Then, as you continue to pick gifts, the max heapify function should correctly rearrange the elements to maintain the max heap property.\\n\\nThis change is necessary because in the heap data structure, the parent node must always have a value that is greater than or equal to its children. So, we need to start heapifying from the bottom of the tree and work our way up to the root to ensure this property is maintained."
                    },
                    {
                        "username": "sandagolcea",
                        "content": "For JS - leetcode uses a library for the max priority queue. This is how you use it:\n ```\nlet q = new MaxPriorityQueue();\n// add a val:\n// let giftValue = 7;\nq.enqueue(giftValue);\n// pop (the elem with the biggest val):\nlet maxVal = q.dequeue().element;\n```"
                    },
                    {
                        "username": "izzatullohboy007",
                        "content": "class Solution:\\n    def pickGifts(self, gifts: List[int], k: int) -> int:\\n        import math \\n        for i in range(k):\\n            s = max(gifts)\\n            gifts.append(math.isqrt(s))\\n            gifts.remove(s)\\n        return sum(gifts)\\n\\n"
                    },
                    {
                        "username": "devottam2809",
                        "content": "whats is wrong with this approach??    \\n while(k--)\\n     {\\n       int maxi=INT_MIN;\\n         for(int i=0;i<gifts.size();i++)\\n         {\\n            if(gifts[i]>maxi)\\n            {\\n                maxi=gifts[i];\\n                int temp=sqrt(maxi);\\n                gifts[i]=temp;\\n            }\\n         }\\n     }\\n    int sum=0;\\n        for(int i=0;i<gifts.size();i++)\\n            sum+=gifts[i];\\n    return sum;\\n    }"
                    },
                    {
                        "username": "bparanj",
                        "content": "This approach has several issues:\\n\\n1. **Finding Maximum Incorrectly:** The loop is intended to find the maximum element in `gifts[]` and then update the maximum element with its square root. However, it\\'s incorrectly updating `gifts[i]` with the square root of `maxi` every time it finds a new maximum. As a result, it\\'s possible that not just the maximum element but several elements get updated in each iteration of the outer loop.\\n\\n2. **Wrong Transformation Operation:** According to our original problem, each chosen gift\\'s value should be reduced to half of its original value, but this code is replacing the maximum value with its square root, which doesn\\'t match the problem\\'s requirements.\\n\\n3. **No Breaking Condition:** There is no condition to break out of the loop if all elements in `gifts[]` become 0. The loop continues for `k` times, which could lead to unnecessary computations.\\n\\n4. **Time Complexity:** This code has a time complexity of O(k*n) because for each of `k` iterations, it\\'s performing an O(n) operation to find the maximum value in the array. This would not be efficient for large inputs.\\n\\nHere\\'s the correct approach:\\n\\n```cpp\\nfor(int i=0; i < k; i++) {\\n    int maxIndex = max_element(gifts.begin(), gifts.end()) - gifts.begin();\\n    gifts[maxIndex] = gifts[maxIndex] / 2;\\n}\\n```\\n\\nIn this code, `max_element()` is a built-in function in C++ that returns an iterator pointing to the maximum element in the range [first, last) that we\\'ve passed. We then subtract `gifts.begin()` from this iterator to get the index of the maximum element in our array. We can then directly halve the value at this index. The loop runs for `k` iterations, and in each iteration, we\\'re finding and halving the maximum value in our array."
                    }
                ]
            },
            {
                "id": 1788550,
                "content": [
                    {
                        "username": "tomfiji",
                        "content": "For the first example, how is the answer 29 and not 30? I imagine the final list would look like: [10, 8, 5, 3, 4]. Am I missing something here?"
                    },
                    {
                        "username": "amanjaiswal159",
                        "content": "[@sandagolcea](/sandagolcea) This explained the complete problem statement and much better than what explained in question."
                    },
                    {
                        "username": "kalaskarrohit7502",
                        "content": "[@sandagolcea](/sandagolcea) thanks for explanation "
                    },
                    {
                        "username": "sandagolcea",
                        "content": "Yes, thing is: you always look at the array and `reconsider ALL values`, INCLUDING the values that you've already handled.\n\n```\ngifts = [25,64,9,4,100]\n\nk = 1, max is 100, so we replace it with sqrt(100)\ngifts = [25,64,9,4,10]\n\nk = 2, max is 64, so we replace it with sqrt(64)\ngifts = [25,8,9,4,10]\n\nk = 3, max is 25, so we replace it with sqrt(25)\ngifts = [5,8,9,4,10]\n\nTHIS IS WHERE IT'S CONFUSING:\nk = 4, max is ..not 9, it's the value we modified at step k = 1, aka 10,\nso we replace this max value with floor of sqrt(10) = 3\ngifts = [5,8,9,4,3]\n\nNow add all vals, and you get 5 + 8 + 9 + 4 + 3 = 29\n```"
                    },
                    {
                        "username": "S_Basu",
                        "content": "*Two approaches that readily come to mind:*\n- Brute force: Sorting `gifts[]` before every operation\n- **Priority Queue** (Reverse Order)\n##### [Link to Solution](https://leetcode.com/problems/take-gifts-from-the-richest-pile/solutions/3144106/2-java-solutions-100-time-space/)"
                    },
                    {
                        "username": "MayuD",
                        "content": "Similar to \\nhttps://leetcode.com/problems/maximal-score-after-applying-k-operations/"
                    },
                    {
                        "username": "satyam47",
                        "content": "Hint :  **priority_queue**"
                    },
                    {
                        "username": "dhruv4023",
                        "content": "My solution in python language:\\n\\n    def pickGifts(self, gifts: List[int], k: int) -> int:\\n        def fun(g,k):\\n            # g=[25,64,9,4,100]\\n            while k!=0:\\n                k=k-1\\n                m=max(g)\\n                i=g.index(m)\\n                g[i]=int(m**(1/2))\\n            return sum(g)\\n        return fun(gifts,k)\\n"
                    },
                    {
                        "username": "shreyaahadkar",
                        "content": "Could someone please tell me what is wrong with my solution?\\nIt\\'s working but only for a few cases...\\n\\n        while k != 0:\\n            for i in range(len(gifts)):\\n                x = math.floor(math.sqrt(max(gifts)))\\n                if gifts[i] == max(gifts):\\n                    gifts[i] = x\\n                    k -= 1\\n        return gifts"
                    },
                    {
                        "username": "bparanj",
                        "content": "Your approach seems to have a nested loop which results in the operation executing `len(gifts) * k` times. However, you need the operation to only run \\'k\\' times. The current structure of the code causes it to modify the pile \\'k\\' times for each pile, which is not what the problem statement specifies.\\n\\nAdditionally, you\\'re finding the maximum value of the array in every iteration, which is a heavy operation and could be optimized.\\n\\nInstead, what you need is a single loop that runs \\'k\\' times. In each iteration, you find the largest pile, take its square root, and replace the original value. One way to efficiently do this is to use a priority queue (heap) data structure which keeps the elements in order and allows efficient extraction of the maximum element."
                    },
                    {
                        "username": "batariloa",
                        "content": "I do not understand whats wrong with my solution. It fails on test 52.\\n\\n\\nfunc pickGifts(gifts []int, k int) int64 {\\n\\n\\tsize := len(gifts)\\n\\n\\tlastLeafNodeIndex := (size - 1) / 2\\n\\n\\tmaxHeapify(&gifts, size, int(lastLeafNodeIndex))\\n\\n\\tfor k > 0 {\\n\\t\\tfloorSqrt := int(math.Sqrt(float64(gifts[0]))) \\n\\t\\tgifts[0] = floorSqrt \\n\\t\\tmaxHeapify(&gifts, size, 0)\\n\\t\\tk--\\n\\t}\\n\\n\\treturn int64(countGifts(gifts))\\n}\\n\\nfunc countGifts(heap []int) int {\\n\\n\\tsum := 0\\n\\tfor _, num := range heap {\\n\\t\\tsum += num\\n\\t}\\n\\n\\treturn sum\\n}\\n\\nfunc maxHeapify(heap *[]int, size int, i int) {\\n\\n\\tl := 2*i + 1\\n\\tr := 2*i + 2\\n\\n\\tlargest := i\\n\\n\\tif l < size && (*heap)[l] > (*heap)[i] {\\n\\t\\tlargest = l\\n\\t}\\n\\n\\tif r < size && (*heap)[r] > (*heap)[largest] {\\n\\t\\tlargest = r\\n\\t}\\n\\n\\tif largest != i {\\n\\t\\t(*heap)[i], (*heap)[largest] = (*heap)[largest], (*heap)[i]\\n\\t\\tmaxHeapify(heap, size, largest)\\n\\t}\\n}\\n\\n"
                    },
                    {
                        "username": "bparanj",
                        "content": "The issue here is likely with how you\\'re building your initial max heap. The max heapify function is being called starting from the last leaf node\\'s parent and you do not iterate backwards to include all parents of the leaf nodes. Because of this, your initial heap might not be a max heap.\\n\\nWhen you start from the last leaf node\\'s parent, you should then go backwards through the array, ensuring all subtrees are max heaps. You can do this by adding a loop that goes from last leaf node\\'s parent to the root of the tree (index 0) in a reverse manner. \\n\\nHere\\'s how you can modify the max heap construction part of your code:\\n\\n```go\\nfor i := lastLeafNodeIndex; i >= 0; i-- {\\n\\tmaxHeapify(&gifts, size, i)\\n}\\n```\\nThis way, you ensure that your heap property is maintained from the start. Then, as you continue to pick gifts, the max heapify function should correctly rearrange the elements to maintain the max heap property.\\n\\nThis change is necessary because in the heap data structure, the parent node must always have a value that is greater than or equal to its children. So, we need to start heapifying from the bottom of the tree and work our way up to the root to ensure this property is maintained."
                    },
                    {
                        "username": "sandagolcea",
                        "content": "For JS - leetcode uses a library for the max priority queue. This is how you use it:\n ```\nlet q = new MaxPriorityQueue();\n// add a val:\n// let giftValue = 7;\nq.enqueue(giftValue);\n// pop (the elem with the biggest val):\nlet maxVal = q.dequeue().element;\n```"
                    },
                    {
                        "username": "izzatullohboy007",
                        "content": "class Solution:\\n    def pickGifts(self, gifts: List[int], k: int) -> int:\\n        import math \\n        for i in range(k):\\n            s = max(gifts)\\n            gifts.append(math.isqrt(s))\\n            gifts.remove(s)\\n        return sum(gifts)\\n\\n"
                    },
                    {
                        "username": "devottam2809",
                        "content": "whats is wrong with this approach??    \\n while(k--)\\n     {\\n       int maxi=INT_MIN;\\n         for(int i=0;i<gifts.size();i++)\\n         {\\n            if(gifts[i]>maxi)\\n            {\\n                maxi=gifts[i];\\n                int temp=sqrt(maxi);\\n                gifts[i]=temp;\\n            }\\n         }\\n     }\\n    int sum=0;\\n        for(int i=0;i<gifts.size();i++)\\n            sum+=gifts[i];\\n    return sum;\\n    }"
                    },
                    {
                        "username": "bparanj",
                        "content": "This approach has several issues:\\n\\n1. **Finding Maximum Incorrectly:** The loop is intended to find the maximum element in `gifts[]` and then update the maximum element with its square root. However, it\\'s incorrectly updating `gifts[i]` with the square root of `maxi` every time it finds a new maximum. As a result, it\\'s possible that not just the maximum element but several elements get updated in each iteration of the outer loop.\\n\\n2. **Wrong Transformation Operation:** According to our original problem, each chosen gift\\'s value should be reduced to half of its original value, but this code is replacing the maximum value with its square root, which doesn\\'t match the problem\\'s requirements.\\n\\n3. **No Breaking Condition:** There is no condition to break out of the loop if all elements in `gifts[]` become 0. The loop continues for `k` times, which could lead to unnecessary computations.\\n\\n4. **Time Complexity:** This code has a time complexity of O(k*n) because for each of `k` iterations, it\\'s performing an O(n) operation to find the maximum value in the array. This would not be efficient for large inputs.\\n\\nHere\\'s the correct approach:\\n\\n```cpp\\nfor(int i=0; i < k; i++) {\\n    int maxIndex = max_element(gifts.begin(), gifts.end()) - gifts.begin();\\n    gifts[maxIndex] = gifts[maxIndex] / 2;\\n}\\n```\\n\\nIn this code, `max_element()` is a built-in function in C++ that returns an iterator pointing to the maximum element in the range [first, last) that we\\'ve passed. We then subtract `gifts.begin()` from this iterator to get the index of the maximum element in our array. We can then directly halve the value at this index. The loop runs for `k` iterations, and in each iteration, we\\'re finding and halving the maximum value in our array."
                    }
                ]
            },
            {
                "id": 1817511,
                "content": [
                    {
                        "username": "tomfiji",
                        "content": "For the first example, how is the answer 29 and not 30? I imagine the final list would look like: [10, 8, 5, 3, 4]. Am I missing something here?"
                    },
                    {
                        "username": "amanjaiswal159",
                        "content": "[@sandagolcea](/sandagolcea) This explained the complete problem statement and much better than what explained in question."
                    },
                    {
                        "username": "kalaskarrohit7502",
                        "content": "[@sandagolcea](/sandagolcea) thanks for explanation "
                    },
                    {
                        "username": "sandagolcea",
                        "content": "Yes, thing is: you always look at the array and `reconsider ALL values`, INCLUDING the values that you've already handled.\n\n```\ngifts = [25,64,9,4,100]\n\nk = 1, max is 100, so we replace it with sqrt(100)\ngifts = [25,64,9,4,10]\n\nk = 2, max is 64, so we replace it with sqrt(64)\ngifts = [25,8,9,4,10]\n\nk = 3, max is 25, so we replace it with sqrt(25)\ngifts = [5,8,9,4,10]\n\nTHIS IS WHERE IT'S CONFUSING:\nk = 4, max is ..not 9, it's the value we modified at step k = 1, aka 10,\nso we replace this max value with floor of sqrt(10) = 3\ngifts = [5,8,9,4,3]\n\nNow add all vals, and you get 5 + 8 + 9 + 4 + 3 = 29\n```"
                    },
                    {
                        "username": "S_Basu",
                        "content": "*Two approaches that readily come to mind:*\n- Brute force: Sorting `gifts[]` before every operation\n- **Priority Queue** (Reverse Order)\n##### [Link to Solution](https://leetcode.com/problems/take-gifts-from-the-richest-pile/solutions/3144106/2-java-solutions-100-time-space/)"
                    },
                    {
                        "username": "MayuD",
                        "content": "Similar to \\nhttps://leetcode.com/problems/maximal-score-after-applying-k-operations/"
                    },
                    {
                        "username": "satyam47",
                        "content": "Hint :  **priority_queue**"
                    },
                    {
                        "username": "dhruv4023",
                        "content": "My solution in python language:\\n\\n    def pickGifts(self, gifts: List[int], k: int) -> int:\\n        def fun(g,k):\\n            # g=[25,64,9,4,100]\\n            while k!=0:\\n                k=k-1\\n                m=max(g)\\n                i=g.index(m)\\n                g[i]=int(m**(1/2))\\n            return sum(g)\\n        return fun(gifts,k)\\n"
                    },
                    {
                        "username": "shreyaahadkar",
                        "content": "Could someone please tell me what is wrong with my solution?\\nIt\\'s working but only for a few cases...\\n\\n        while k != 0:\\n            for i in range(len(gifts)):\\n                x = math.floor(math.sqrt(max(gifts)))\\n                if gifts[i] == max(gifts):\\n                    gifts[i] = x\\n                    k -= 1\\n        return gifts"
                    },
                    {
                        "username": "bparanj",
                        "content": "Your approach seems to have a nested loop which results in the operation executing `len(gifts) * k` times. However, you need the operation to only run \\'k\\' times. The current structure of the code causes it to modify the pile \\'k\\' times for each pile, which is not what the problem statement specifies.\\n\\nAdditionally, you\\'re finding the maximum value of the array in every iteration, which is a heavy operation and could be optimized.\\n\\nInstead, what you need is a single loop that runs \\'k\\' times. In each iteration, you find the largest pile, take its square root, and replace the original value. One way to efficiently do this is to use a priority queue (heap) data structure which keeps the elements in order and allows efficient extraction of the maximum element."
                    },
                    {
                        "username": "batariloa",
                        "content": "I do not understand whats wrong with my solution. It fails on test 52.\\n\\n\\nfunc pickGifts(gifts []int, k int) int64 {\\n\\n\\tsize := len(gifts)\\n\\n\\tlastLeafNodeIndex := (size - 1) / 2\\n\\n\\tmaxHeapify(&gifts, size, int(lastLeafNodeIndex))\\n\\n\\tfor k > 0 {\\n\\t\\tfloorSqrt := int(math.Sqrt(float64(gifts[0]))) \\n\\t\\tgifts[0] = floorSqrt \\n\\t\\tmaxHeapify(&gifts, size, 0)\\n\\t\\tk--\\n\\t}\\n\\n\\treturn int64(countGifts(gifts))\\n}\\n\\nfunc countGifts(heap []int) int {\\n\\n\\tsum := 0\\n\\tfor _, num := range heap {\\n\\t\\tsum += num\\n\\t}\\n\\n\\treturn sum\\n}\\n\\nfunc maxHeapify(heap *[]int, size int, i int) {\\n\\n\\tl := 2*i + 1\\n\\tr := 2*i + 2\\n\\n\\tlargest := i\\n\\n\\tif l < size && (*heap)[l] > (*heap)[i] {\\n\\t\\tlargest = l\\n\\t}\\n\\n\\tif r < size && (*heap)[r] > (*heap)[largest] {\\n\\t\\tlargest = r\\n\\t}\\n\\n\\tif largest != i {\\n\\t\\t(*heap)[i], (*heap)[largest] = (*heap)[largest], (*heap)[i]\\n\\t\\tmaxHeapify(heap, size, largest)\\n\\t}\\n}\\n\\n"
                    },
                    {
                        "username": "bparanj",
                        "content": "The issue here is likely with how you\\'re building your initial max heap. The max heapify function is being called starting from the last leaf node\\'s parent and you do not iterate backwards to include all parents of the leaf nodes. Because of this, your initial heap might not be a max heap.\\n\\nWhen you start from the last leaf node\\'s parent, you should then go backwards through the array, ensuring all subtrees are max heaps. You can do this by adding a loop that goes from last leaf node\\'s parent to the root of the tree (index 0) in a reverse manner. \\n\\nHere\\'s how you can modify the max heap construction part of your code:\\n\\n```go\\nfor i := lastLeafNodeIndex; i >= 0; i-- {\\n\\tmaxHeapify(&gifts, size, i)\\n}\\n```\\nThis way, you ensure that your heap property is maintained from the start. Then, as you continue to pick gifts, the max heapify function should correctly rearrange the elements to maintain the max heap property.\\n\\nThis change is necessary because in the heap data structure, the parent node must always have a value that is greater than or equal to its children. So, we need to start heapifying from the bottom of the tree and work our way up to the root to ensure this property is maintained."
                    },
                    {
                        "username": "sandagolcea",
                        "content": "For JS - leetcode uses a library for the max priority queue. This is how you use it:\n ```\nlet q = new MaxPriorityQueue();\n// add a val:\n// let giftValue = 7;\nq.enqueue(giftValue);\n// pop (the elem with the biggest val):\nlet maxVal = q.dequeue().element;\n```"
                    },
                    {
                        "username": "izzatullohboy007",
                        "content": "class Solution:\\n    def pickGifts(self, gifts: List[int], k: int) -> int:\\n        import math \\n        for i in range(k):\\n            s = max(gifts)\\n            gifts.append(math.isqrt(s))\\n            gifts.remove(s)\\n        return sum(gifts)\\n\\n"
                    },
                    {
                        "username": "devottam2809",
                        "content": "whats is wrong with this approach??    \\n while(k--)\\n     {\\n       int maxi=INT_MIN;\\n         for(int i=0;i<gifts.size();i++)\\n         {\\n            if(gifts[i]>maxi)\\n            {\\n                maxi=gifts[i];\\n                int temp=sqrt(maxi);\\n                gifts[i]=temp;\\n            }\\n         }\\n     }\\n    int sum=0;\\n        for(int i=0;i<gifts.size();i++)\\n            sum+=gifts[i];\\n    return sum;\\n    }"
                    },
                    {
                        "username": "bparanj",
                        "content": "This approach has several issues:\\n\\n1. **Finding Maximum Incorrectly:** The loop is intended to find the maximum element in `gifts[]` and then update the maximum element with its square root. However, it\\'s incorrectly updating `gifts[i]` with the square root of `maxi` every time it finds a new maximum. As a result, it\\'s possible that not just the maximum element but several elements get updated in each iteration of the outer loop.\\n\\n2. **Wrong Transformation Operation:** According to our original problem, each chosen gift\\'s value should be reduced to half of its original value, but this code is replacing the maximum value with its square root, which doesn\\'t match the problem\\'s requirements.\\n\\n3. **No Breaking Condition:** There is no condition to break out of the loop if all elements in `gifts[]` become 0. The loop continues for `k` times, which could lead to unnecessary computations.\\n\\n4. **Time Complexity:** This code has a time complexity of O(k*n) because for each of `k` iterations, it\\'s performing an O(n) operation to find the maximum value in the array. This would not be efficient for large inputs.\\n\\nHere\\'s the correct approach:\\n\\n```cpp\\nfor(int i=0; i < k; i++) {\\n    int maxIndex = max_element(gifts.begin(), gifts.end()) - gifts.begin();\\n    gifts[maxIndex] = gifts[maxIndex] / 2;\\n}\\n```\\n\\nIn this code, `max_element()` is a built-in function in C++ that returns an iterator pointing to the maximum element in the range [first, last) that we\\'ve passed. We then subtract `gifts.begin()` from this iterator to get the index of the maximum element in our array. We can then directly halve the value at this index. The loop runs for `k` iterations, and in each iteration, we\\'re finding and halving the maximum value in our array."
                    }
                ]
            },
            {
                "id": 1788448,
                "content": [
                    {
                        "username": "tomfiji",
                        "content": "For the first example, how is the answer 29 and not 30? I imagine the final list would look like: [10, 8, 5, 3, 4]. Am I missing something here?"
                    },
                    {
                        "username": "amanjaiswal159",
                        "content": "[@sandagolcea](/sandagolcea) This explained the complete problem statement and much better than what explained in question."
                    },
                    {
                        "username": "kalaskarrohit7502",
                        "content": "[@sandagolcea](/sandagolcea) thanks for explanation "
                    },
                    {
                        "username": "sandagolcea",
                        "content": "Yes, thing is: you always look at the array and `reconsider ALL values`, INCLUDING the values that you've already handled.\n\n```\ngifts = [25,64,9,4,100]\n\nk = 1, max is 100, so we replace it with sqrt(100)\ngifts = [25,64,9,4,10]\n\nk = 2, max is 64, so we replace it with sqrt(64)\ngifts = [25,8,9,4,10]\n\nk = 3, max is 25, so we replace it with sqrt(25)\ngifts = [5,8,9,4,10]\n\nTHIS IS WHERE IT'S CONFUSING:\nk = 4, max is ..not 9, it's the value we modified at step k = 1, aka 10,\nso we replace this max value with floor of sqrt(10) = 3\ngifts = [5,8,9,4,3]\n\nNow add all vals, and you get 5 + 8 + 9 + 4 + 3 = 29\n```"
                    },
                    {
                        "username": "S_Basu",
                        "content": "*Two approaches that readily come to mind:*\n- Brute force: Sorting `gifts[]` before every operation\n- **Priority Queue** (Reverse Order)\n##### [Link to Solution](https://leetcode.com/problems/take-gifts-from-the-richest-pile/solutions/3144106/2-java-solutions-100-time-space/)"
                    },
                    {
                        "username": "MayuD",
                        "content": "Similar to \\nhttps://leetcode.com/problems/maximal-score-after-applying-k-operations/"
                    },
                    {
                        "username": "satyam47",
                        "content": "Hint :  **priority_queue**"
                    },
                    {
                        "username": "dhruv4023",
                        "content": "My solution in python language:\\n\\n    def pickGifts(self, gifts: List[int], k: int) -> int:\\n        def fun(g,k):\\n            # g=[25,64,9,4,100]\\n            while k!=0:\\n                k=k-1\\n                m=max(g)\\n                i=g.index(m)\\n                g[i]=int(m**(1/2))\\n            return sum(g)\\n        return fun(gifts,k)\\n"
                    },
                    {
                        "username": "shreyaahadkar",
                        "content": "Could someone please tell me what is wrong with my solution?\\nIt\\'s working but only for a few cases...\\n\\n        while k != 0:\\n            for i in range(len(gifts)):\\n                x = math.floor(math.sqrt(max(gifts)))\\n                if gifts[i] == max(gifts):\\n                    gifts[i] = x\\n                    k -= 1\\n        return gifts"
                    },
                    {
                        "username": "bparanj",
                        "content": "Your approach seems to have a nested loop which results in the operation executing `len(gifts) * k` times. However, you need the operation to only run \\'k\\' times. The current structure of the code causes it to modify the pile \\'k\\' times for each pile, which is not what the problem statement specifies.\\n\\nAdditionally, you\\'re finding the maximum value of the array in every iteration, which is a heavy operation and could be optimized.\\n\\nInstead, what you need is a single loop that runs \\'k\\' times. In each iteration, you find the largest pile, take its square root, and replace the original value. One way to efficiently do this is to use a priority queue (heap) data structure which keeps the elements in order and allows efficient extraction of the maximum element."
                    },
                    {
                        "username": "batariloa",
                        "content": "I do not understand whats wrong with my solution. It fails on test 52.\\n\\n\\nfunc pickGifts(gifts []int, k int) int64 {\\n\\n\\tsize := len(gifts)\\n\\n\\tlastLeafNodeIndex := (size - 1) / 2\\n\\n\\tmaxHeapify(&gifts, size, int(lastLeafNodeIndex))\\n\\n\\tfor k > 0 {\\n\\t\\tfloorSqrt := int(math.Sqrt(float64(gifts[0]))) \\n\\t\\tgifts[0] = floorSqrt \\n\\t\\tmaxHeapify(&gifts, size, 0)\\n\\t\\tk--\\n\\t}\\n\\n\\treturn int64(countGifts(gifts))\\n}\\n\\nfunc countGifts(heap []int) int {\\n\\n\\tsum := 0\\n\\tfor _, num := range heap {\\n\\t\\tsum += num\\n\\t}\\n\\n\\treturn sum\\n}\\n\\nfunc maxHeapify(heap *[]int, size int, i int) {\\n\\n\\tl := 2*i + 1\\n\\tr := 2*i + 2\\n\\n\\tlargest := i\\n\\n\\tif l < size && (*heap)[l] > (*heap)[i] {\\n\\t\\tlargest = l\\n\\t}\\n\\n\\tif r < size && (*heap)[r] > (*heap)[largest] {\\n\\t\\tlargest = r\\n\\t}\\n\\n\\tif largest != i {\\n\\t\\t(*heap)[i], (*heap)[largest] = (*heap)[largest], (*heap)[i]\\n\\t\\tmaxHeapify(heap, size, largest)\\n\\t}\\n}\\n\\n"
                    },
                    {
                        "username": "bparanj",
                        "content": "The issue here is likely with how you\\'re building your initial max heap. The max heapify function is being called starting from the last leaf node\\'s parent and you do not iterate backwards to include all parents of the leaf nodes. Because of this, your initial heap might not be a max heap.\\n\\nWhen you start from the last leaf node\\'s parent, you should then go backwards through the array, ensuring all subtrees are max heaps. You can do this by adding a loop that goes from last leaf node\\'s parent to the root of the tree (index 0) in a reverse manner. \\n\\nHere\\'s how you can modify the max heap construction part of your code:\\n\\n```go\\nfor i := lastLeafNodeIndex; i >= 0; i-- {\\n\\tmaxHeapify(&gifts, size, i)\\n}\\n```\\nThis way, you ensure that your heap property is maintained from the start. Then, as you continue to pick gifts, the max heapify function should correctly rearrange the elements to maintain the max heap property.\\n\\nThis change is necessary because in the heap data structure, the parent node must always have a value that is greater than or equal to its children. So, we need to start heapifying from the bottom of the tree and work our way up to the root to ensure this property is maintained."
                    },
                    {
                        "username": "sandagolcea",
                        "content": "For JS - leetcode uses a library for the max priority queue. This is how you use it:\n ```\nlet q = new MaxPriorityQueue();\n// add a val:\n// let giftValue = 7;\nq.enqueue(giftValue);\n// pop (the elem with the biggest val):\nlet maxVal = q.dequeue().element;\n```"
                    },
                    {
                        "username": "izzatullohboy007",
                        "content": "class Solution:\\n    def pickGifts(self, gifts: List[int], k: int) -> int:\\n        import math \\n        for i in range(k):\\n            s = max(gifts)\\n            gifts.append(math.isqrt(s))\\n            gifts.remove(s)\\n        return sum(gifts)\\n\\n"
                    },
                    {
                        "username": "devottam2809",
                        "content": "whats is wrong with this approach??    \\n while(k--)\\n     {\\n       int maxi=INT_MIN;\\n         for(int i=0;i<gifts.size();i++)\\n         {\\n            if(gifts[i]>maxi)\\n            {\\n                maxi=gifts[i];\\n                int temp=sqrt(maxi);\\n                gifts[i]=temp;\\n            }\\n         }\\n     }\\n    int sum=0;\\n        for(int i=0;i<gifts.size();i++)\\n            sum+=gifts[i];\\n    return sum;\\n    }"
                    },
                    {
                        "username": "bparanj",
                        "content": "This approach has several issues:\\n\\n1. **Finding Maximum Incorrectly:** The loop is intended to find the maximum element in `gifts[]` and then update the maximum element with its square root. However, it\\'s incorrectly updating `gifts[i]` with the square root of `maxi` every time it finds a new maximum. As a result, it\\'s possible that not just the maximum element but several elements get updated in each iteration of the outer loop.\\n\\n2. **Wrong Transformation Operation:** According to our original problem, each chosen gift\\'s value should be reduced to half of its original value, but this code is replacing the maximum value with its square root, which doesn\\'t match the problem\\'s requirements.\\n\\n3. **No Breaking Condition:** There is no condition to break out of the loop if all elements in `gifts[]` become 0. The loop continues for `k` times, which could lead to unnecessary computations.\\n\\n4. **Time Complexity:** This code has a time complexity of O(k*n) because for each of `k` iterations, it\\'s performing an O(n) operation to find the maximum value in the array. This would not be efficient for large inputs.\\n\\nHere\\'s the correct approach:\\n\\n```cpp\\nfor(int i=0; i < k; i++) {\\n    int maxIndex = max_element(gifts.begin(), gifts.end()) - gifts.begin();\\n    gifts[maxIndex] = gifts[maxIndex] / 2;\\n}\\n```\\n\\nIn this code, `max_element()` is a built-in function in C++ that returns an iterator pointing to the maximum element in the range [first, last) that we\\'ve passed. We then subtract `gifts.begin()` from this iterator to get the index of the maximum element in our array. We can then directly halve the value at this index. The loop runs for `k` iterations, and in each iteration, we\\'re finding and halving the maximum value in our array."
                    }
                ]
            },
            {
                "id": 2016506,
                "content": [
                    {
                        "username": "tomfiji",
                        "content": "For the first example, how is the answer 29 and not 30? I imagine the final list would look like: [10, 8, 5, 3, 4]. Am I missing something here?"
                    },
                    {
                        "username": "amanjaiswal159",
                        "content": "[@sandagolcea](/sandagolcea) This explained the complete problem statement and much better than what explained in question."
                    },
                    {
                        "username": "kalaskarrohit7502",
                        "content": "[@sandagolcea](/sandagolcea) thanks for explanation "
                    },
                    {
                        "username": "sandagolcea",
                        "content": "Yes, thing is: you always look at the array and `reconsider ALL values`, INCLUDING the values that you've already handled.\n\n```\ngifts = [25,64,9,4,100]\n\nk = 1, max is 100, so we replace it with sqrt(100)\ngifts = [25,64,9,4,10]\n\nk = 2, max is 64, so we replace it with sqrt(64)\ngifts = [25,8,9,4,10]\n\nk = 3, max is 25, so we replace it with sqrt(25)\ngifts = [5,8,9,4,10]\n\nTHIS IS WHERE IT'S CONFUSING:\nk = 4, max is ..not 9, it's the value we modified at step k = 1, aka 10,\nso we replace this max value with floor of sqrt(10) = 3\ngifts = [5,8,9,4,3]\n\nNow add all vals, and you get 5 + 8 + 9 + 4 + 3 = 29\n```"
                    },
                    {
                        "username": "S_Basu",
                        "content": "*Two approaches that readily come to mind:*\n- Brute force: Sorting `gifts[]` before every operation\n- **Priority Queue** (Reverse Order)\n##### [Link to Solution](https://leetcode.com/problems/take-gifts-from-the-richest-pile/solutions/3144106/2-java-solutions-100-time-space/)"
                    },
                    {
                        "username": "MayuD",
                        "content": "Similar to \\nhttps://leetcode.com/problems/maximal-score-after-applying-k-operations/"
                    },
                    {
                        "username": "satyam47",
                        "content": "Hint :  **priority_queue**"
                    },
                    {
                        "username": "dhruv4023",
                        "content": "My solution in python language:\\n\\n    def pickGifts(self, gifts: List[int], k: int) -> int:\\n        def fun(g,k):\\n            # g=[25,64,9,4,100]\\n            while k!=0:\\n                k=k-1\\n                m=max(g)\\n                i=g.index(m)\\n                g[i]=int(m**(1/2))\\n            return sum(g)\\n        return fun(gifts,k)\\n"
                    },
                    {
                        "username": "shreyaahadkar",
                        "content": "Could someone please tell me what is wrong with my solution?\\nIt\\'s working but only for a few cases...\\n\\n        while k != 0:\\n            for i in range(len(gifts)):\\n                x = math.floor(math.sqrt(max(gifts)))\\n                if gifts[i] == max(gifts):\\n                    gifts[i] = x\\n                    k -= 1\\n        return gifts"
                    },
                    {
                        "username": "bparanj",
                        "content": "Your approach seems to have a nested loop which results in the operation executing `len(gifts) * k` times. However, you need the operation to only run \\'k\\' times. The current structure of the code causes it to modify the pile \\'k\\' times for each pile, which is not what the problem statement specifies.\\n\\nAdditionally, you\\'re finding the maximum value of the array in every iteration, which is a heavy operation and could be optimized.\\n\\nInstead, what you need is a single loop that runs \\'k\\' times. In each iteration, you find the largest pile, take its square root, and replace the original value. One way to efficiently do this is to use a priority queue (heap) data structure which keeps the elements in order and allows efficient extraction of the maximum element."
                    },
                    {
                        "username": "batariloa",
                        "content": "I do not understand whats wrong with my solution. It fails on test 52.\\n\\n\\nfunc pickGifts(gifts []int, k int) int64 {\\n\\n\\tsize := len(gifts)\\n\\n\\tlastLeafNodeIndex := (size - 1) / 2\\n\\n\\tmaxHeapify(&gifts, size, int(lastLeafNodeIndex))\\n\\n\\tfor k > 0 {\\n\\t\\tfloorSqrt := int(math.Sqrt(float64(gifts[0]))) \\n\\t\\tgifts[0] = floorSqrt \\n\\t\\tmaxHeapify(&gifts, size, 0)\\n\\t\\tk--\\n\\t}\\n\\n\\treturn int64(countGifts(gifts))\\n}\\n\\nfunc countGifts(heap []int) int {\\n\\n\\tsum := 0\\n\\tfor _, num := range heap {\\n\\t\\tsum += num\\n\\t}\\n\\n\\treturn sum\\n}\\n\\nfunc maxHeapify(heap *[]int, size int, i int) {\\n\\n\\tl := 2*i + 1\\n\\tr := 2*i + 2\\n\\n\\tlargest := i\\n\\n\\tif l < size && (*heap)[l] > (*heap)[i] {\\n\\t\\tlargest = l\\n\\t}\\n\\n\\tif r < size && (*heap)[r] > (*heap)[largest] {\\n\\t\\tlargest = r\\n\\t}\\n\\n\\tif largest != i {\\n\\t\\t(*heap)[i], (*heap)[largest] = (*heap)[largest], (*heap)[i]\\n\\t\\tmaxHeapify(heap, size, largest)\\n\\t}\\n}\\n\\n"
                    },
                    {
                        "username": "bparanj",
                        "content": "The issue here is likely with how you\\'re building your initial max heap. The max heapify function is being called starting from the last leaf node\\'s parent and you do not iterate backwards to include all parents of the leaf nodes. Because of this, your initial heap might not be a max heap.\\n\\nWhen you start from the last leaf node\\'s parent, you should then go backwards through the array, ensuring all subtrees are max heaps. You can do this by adding a loop that goes from last leaf node\\'s parent to the root of the tree (index 0) in a reverse manner. \\n\\nHere\\'s how you can modify the max heap construction part of your code:\\n\\n```go\\nfor i := lastLeafNodeIndex; i >= 0; i-- {\\n\\tmaxHeapify(&gifts, size, i)\\n}\\n```\\nThis way, you ensure that your heap property is maintained from the start. Then, as you continue to pick gifts, the max heapify function should correctly rearrange the elements to maintain the max heap property.\\n\\nThis change is necessary because in the heap data structure, the parent node must always have a value that is greater than or equal to its children. So, we need to start heapifying from the bottom of the tree and work our way up to the root to ensure this property is maintained."
                    },
                    {
                        "username": "sandagolcea",
                        "content": "For JS - leetcode uses a library for the max priority queue. This is how you use it:\n ```\nlet q = new MaxPriorityQueue();\n// add a val:\n// let giftValue = 7;\nq.enqueue(giftValue);\n// pop (the elem with the biggest val):\nlet maxVal = q.dequeue().element;\n```"
                    },
                    {
                        "username": "izzatullohboy007",
                        "content": "class Solution:\\n    def pickGifts(self, gifts: List[int], k: int) -> int:\\n        import math \\n        for i in range(k):\\n            s = max(gifts)\\n            gifts.append(math.isqrt(s))\\n            gifts.remove(s)\\n        return sum(gifts)\\n\\n"
                    },
                    {
                        "username": "devottam2809",
                        "content": "whats is wrong with this approach??    \\n while(k--)\\n     {\\n       int maxi=INT_MIN;\\n         for(int i=0;i<gifts.size();i++)\\n         {\\n            if(gifts[i]>maxi)\\n            {\\n                maxi=gifts[i];\\n                int temp=sqrt(maxi);\\n                gifts[i]=temp;\\n            }\\n         }\\n     }\\n    int sum=0;\\n        for(int i=0;i<gifts.size();i++)\\n            sum+=gifts[i];\\n    return sum;\\n    }"
                    },
                    {
                        "username": "bparanj",
                        "content": "This approach has several issues:\\n\\n1. **Finding Maximum Incorrectly:** The loop is intended to find the maximum element in `gifts[]` and then update the maximum element with its square root. However, it\\'s incorrectly updating `gifts[i]` with the square root of `maxi` every time it finds a new maximum. As a result, it\\'s possible that not just the maximum element but several elements get updated in each iteration of the outer loop.\\n\\n2. **Wrong Transformation Operation:** According to our original problem, each chosen gift\\'s value should be reduced to half of its original value, but this code is replacing the maximum value with its square root, which doesn\\'t match the problem\\'s requirements.\\n\\n3. **No Breaking Condition:** There is no condition to break out of the loop if all elements in `gifts[]` become 0. The loop continues for `k` times, which could lead to unnecessary computations.\\n\\n4. **Time Complexity:** This code has a time complexity of O(k*n) because for each of `k` iterations, it\\'s performing an O(n) operation to find the maximum value in the array. This would not be efficient for large inputs.\\n\\nHere\\'s the correct approach:\\n\\n```cpp\\nfor(int i=0; i < k; i++) {\\n    int maxIndex = max_element(gifts.begin(), gifts.end()) - gifts.begin();\\n    gifts[maxIndex] = gifts[maxIndex] / 2;\\n}\\n```\\n\\nIn this code, `max_element()` is a built-in function in C++ that returns an iterator pointing to the maximum element in the range [first, last) that we\\'ve passed. We then subtract `gifts.begin()` from this iterator to get the index of the maximum element in our array. We can then directly halve the value at this index. The loop runs for `k` iterations, and in each iteration, we\\'re finding and halving the maximum value in our array."
                    }
                ]
            },
            {
                "id": 1955620,
                "content": [
                    {
                        "username": "tomfiji",
                        "content": "For the first example, how is the answer 29 and not 30? I imagine the final list would look like: [10, 8, 5, 3, 4]. Am I missing something here?"
                    },
                    {
                        "username": "amanjaiswal159",
                        "content": "[@sandagolcea](/sandagolcea) This explained the complete problem statement and much better than what explained in question."
                    },
                    {
                        "username": "kalaskarrohit7502",
                        "content": "[@sandagolcea](/sandagolcea) thanks for explanation "
                    },
                    {
                        "username": "sandagolcea",
                        "content": "Yes, thing is: you always look at the array and `reconsider ALL values`, INCLUDING the values that you've already handled.\n\n```\ngifts = [25,64,9,4,100]\n\nk = 1, max is 100, so we replace it with sqrt(100)\ngifts = [25,64,9,4,10]\n\nk = 2, max is 64, so we replace it with sqrt(64)\ngifts = [25,8,9,4,10]\n\nk = 3, max is 25, so we replace it with sqrt(25)\ngifts = [5,8,9,4,10]\n\nTHIS IS WHERE IT'S CONFUSING:\nk = 4, max is ..not 9, it's the value we modified at step k = 1, aka 10,\nso we replace this max value with floor of sqrt(10) = 3\ngifts = [5,8,9,4,3]\n\nNow add all vals, and you get 5 + 8 + 9 + 4 + 3 = 29\n```"
                    },
                    {
                        "username": "S_Basu",
                        "content": "*Two approaches that readily come to mind:*\n- Brute force: Sorting `gifts[]` before every operation\n- **Priority Queue** (Reverse Order)\n##### [Link to Solution](https://leetcode.com/problems/take-gifts-from-the-richest-pile/solutions/3144106/2-java-solutions-100-time-space/)"
                    },
                    {
                        "username": "MayuD",
                        "content": "Similar to \\nhttps://leetcode.com/problems/maximal-score-after-applying-k-operations/"
                    },
                    {
                        "username": "satyam47",
                        "content": "Hint :  **priority_queue**"
                    },
                    {
                        "username": "dhruv4023",
                        "content": "My solution in python language:\\n\\n    def pickGifts(self, gifts: List[int], k: int) -> int:\\n        def fun(g,k):\\n            # g=[25,64,9,4,100]\\n            while k!=0:\\n                k=k-1\\n                m=max(g)\\n                i=g.index(m)\\n                g[i]=int(m**(1/2))\\n            return sum(g)\\n        return fun(gifts,k)\\n"
                    },
                    {
                        "username": "shreyaahadkar",
                        "content": "Could someone please tell me what is wrong with my solution?\\nIt\\'s working but only for a few cases...\\n\\n        while k != 0:\\n            for i in range(len(gifts)):\\n                x = math.floor(math.sqrt(max(gifts)))\\n                if gifts[i] == max(gifts):\\n                    gifts[i] = x\\n                    k -= 1\\n        return gifts"
                    },
                    {
                        "username": "bparanj",
                        "content": "Your approach seems to have a nested loop which results in the operation executing `len(gifts) * k` times. However, you need the operation to only run \\'k\\' times. The current structure of the code causes it to modify the pile \\'k\\' times for each pile, which is not what the problem statement specifies.\\n\\nAdditionally, you\\'re finding the maximum value of the array in every iteration, which is a heavy operation and could be optimized.\\n\\nInstead, what you need is a single loop that runs \\'k\\' times. In each iteration, you find the largest pile, take its square root, and replace the original value. One way to efficiently do this is to use a priority queue (heap) data structure which keeps the elements in order and allows efficient extraction of the maximum element."
                    },
                    {
                        "username": "batariloa",
                        "content": "I do not understand whats wrong with my solution. It fails on test 52.\\n\\n\\nfunc pickGifts(gifts []int, k int) int64 {\\n\\n\\tsize := len(gifts)\\n\\n\\tlastLeafNodeIndex := (size - 1) / 2\\n\\n\\tmaxHeapify(&gifts, size, int(lastLeafNodeIndex))\\n\\n\\tfor k > 0 {\\n\\t\\tfloorSqrt := int(math.Sqrt(float64(gifts[0]))) \\n\\t\\tgifts[0] = floorSqrt \\n\\t\\tmaxHeapify(&gifts, size, 0)\\n\\t\\tk--\\n\\t}\\n\\n\\treturn int64(countGifts(gifts))\\n}\\n\\nfunc countGifts(heap []int) int {\\n\\n\\tsum := 0\\n\\tfor _, num := range heap {\\n\\t\\tsum += num\\n\\t}\\n\\n\\treturn sum\\n}\\n\\nfunc maxHeapify(heap *[]int, size int, i int) {\\n\\n\\tl := 2*i + 1\\n\\tr := 2*i + 2\\n\\n\\tlargest := i\\n\\n\\tif l < size && (*heap)[l] > (*heap)[i] {\\n\\t\\tlargest = l\\n\\t}\\n\\n\\tif r < size && (*heap)[r] > (*heap)[largest] {\\n\\t\\tlargest = r\\n\\t}\\n\\n\\tif largest != i {\\n\\t\\t(*heap)[i], (*heap)[largest] = (*heap)[largest], (*heap)[i]\\n\\t\\tmaxHeapify(heap, size, largest)\\n\\t}\\n}\\n\\n"
                    },
                    {
                        "username": "bparanj",
                        "content": "The issue here is likely with how you\\'re building your initial max heap. The max heapify function is being called starting from the last leaf node\\'s parent and you do not iterate backwards to include all parents of the leaf nodes. Because of this, your initial heap might not be a max heap.\\n\\nWhen you start from the last leaf node\\'s parent, you should then go backwards through the array, ensuring all subtrees are max heaps. You can do this by adding a loop that goes from last leaf node\\'s parent to the root of the tree (index 0) in a reverse manner. \\n\\nHere\\'s how you can modify the max heap construction part of your code:\\n\\n```go\\nfor i := lastLeafNodeIndex; i >= 0; i-- {\\n\\tmaxHeapify(&gifts, size, i)\\n}\\n```\\nThis way, you ensure that your heap property is maintained from the start. Then, as you continue to pick gifts, the max heapify function should correctly rearrange the elements to maintain the max heap property.\\n\\nThis change is necessary because in the heap data structure, the parent node must always have a value that is greater than or equal to its children. So, we need to start heapifying from the bottom of the tree and work our way up to the root to ensure this property is maintained."
                    },
                    {
                        "username": "sandagolcea",
                        "content": "For JS - leetcode uses a library for the max priority queue. This is how you use it:\n ```\nlet q = new MaxPriorityQueue();\n// add a val:\n// let giftValue = 7;\nq.enqueue(giftValue);\n// pop (the elem with the biggest val):\nlet maxVal = q.dequeue().element;\n```"
                    },
                    {
                        "username": "izzatullohboy007",
                        "content": "class Solution:\\n    def pickGifts(self, gifts: List[int], k: int) -> int:\\n        import math \\n        for i in range(k):\\n            s = max(gifts)\\n            gifts.append(math.isqrt(s))\\n            gifts.remove(s)\\n        return sum(gifts)\\n\\n"
                    },
                    {
                        "username": "devottam2809",
                        "content": "whats is wrong with this approach??    \\n while(k--)\\n     {\\n       int maxi=INT_MIN;\\n         for(int i=0;i<gifts.size();i++)\\n         {\\n            if(gifts[i]>maxi)\\n            {\\n                maxi=gifts[i];\\n                int temp=sqrt(maxi);\\n                gifts[i]=temp;\\n            }\\n         }\\n     }\\n    int sum=0;\\n        for(int i=0;i<gifts.size();i++)\\n            sum+=gifts[i];\\n    return sum;\\n    }"
                    },
                    {
                        "username": "bparanj",
                        "content": "This approach has several issues:\\n\\n1. **Finding Maximum Incorrectly:** The loop is intended to find the maximum element in `gifts[]` and then update the maximum element with its square root. However, it\\'s incorrectly updating `gifts[i]` with the square root of `maxi` every time it finds a new maximum. As a result, it\\'s possible that not just the maximum element but several elements get updated in each iteration of the outer loop.\\n\\n2. **Wrong Transformation Operation:** According to our original problem, each chosen gift\\'s value should be reduced to half of its original value, but this code is replacing the maximum value with its square root, which doesn\\'t match the problem\\'s requirements.\\n\\n3. **No Breaking Condition:** There is no condition to break out of the loop if all elements in `gifts[]` become 0. The loop continues for `k` times, which could lead to unnecessary computations.\\n\\n4. **Time Complexity:** This code has a time complexity of O(k*n) because for each of `k` iterations, it\\'s performing an O(n) operation to find the maximum value in the array. This would not be efficient for large inputs.\\n\\nHere\\'s the correct approach:\\n\\n```cpp\\nfor(int i=0; i < k; i++) {\\n    int maxIndex = max_element(gifts.begin(), gifts.end()) - gifts.begin();\\n    gifts[maxIndex] = gifts[maxIndex] / 2;\\n}\\n```\\n\\nIn this code, `max_element()` is a built-in function in C++ that returns an iterator pointing to the maximum element in the range [first, last) that we\\'ve passed. We then subtract `gifts.begin()` from this iterator to get the index of the maximum element in our array. We can then directly halve the value at this index. The loop runs for `k` iterations, and in each iteration, we\\'re finding and halving the maximum value in our array."
                    }
                ]
            },
            {
                "id": 1953246,
                "content": [
                    {
                        "username": "tomfiji",
                        "content": "For the first example, how is the answer 29 and not 30? I imagine the final list would look like: [10, 8, 5, 3, 4]. Am I missing something here?"
                    },
                    {
                        "username": "amanjaiswal159",
                        "content": "[@sandagolcea](/sandagolcea) This explained the complete problem statement and much better than what explained in question."
                    },
                    {
                        "username": "kalaskarrohit7502",
                        "content": "[@sandagolcea](/sandagolcea) thanks for explanation "
                    },
                    {
                        "username": "sandagolcea",
                        "content": "Yes, thing is: you always look at the array and `reconsider ALL values`, INCLUDING the values that you've already handled.\n\n```\ngifts = [25,64,9,4,100]\n\nk = 1, max is 100, so we replace it with sqrt(100)\ngifts = [25,64,9,4,10]\n\nk = 2, max is 64, so we replace it with sqrt(64)\ngifts = [25,8,9,4,10]\n\nk = 3, max is 25, so we replace it with sqrt(25)\ngifts = [5,8,9,4,10]\n\nTHIS IS WHERE IT'S CONFUSING:\nk = 4, max is ..not 9, it's the value we modified at step k = 1, aka 10,\nso we replace this max value with floor of sqrt(10) = 3\ngifts = [5,8,9,4,3]\n\nNow add all vals, and you get 5 + 8 + 9 + 4 + 3 = 29\n```"
                    },
                    {
                        "username": "S_Basu",
                        "content": "*Two approaches that readily come to mind:*\n- Brute force: Sorting `gifts[]` before every operation\n- **Priority Queue** (Reverse Order)\n##### [Link to Solution](https://leetcode.com/problems/take-gifts-from-the-richest-pile/solutions/3144106/2-java-solutions-100-time-space/)"
                    },
                    {
                        "username": "MayuD",
                        "content": "Similar to \\nhttps://leetcode.com/problems/maximal-score-after-applying-k-operations/"
                    },
                    {
                        "username": "satyam47",
                        "content": "Hint :  **priority_queue**"
                    },
                    {
                        "username": "dhruv4023",
                        "content": "My solution in python language:\\n\\n    def pickGifts(self, gifts: List[int], k: int) -> int:\\n        def fun(g,k):\\n            # g=[25,64,9,4,100]\\n            while k!=0:\\n                k=k-1\\n                m=max(g)\\n                i=g.index(m)\\n                g[i]=int(m**(1/2))\\n            return sum(g)\\n        return fun(gifts,k)\\n"
                    },
                    {
                        "username": "shreyaahadkar",
                        "content": "Could someone please tell me what is wrong with my solution?\\nIt\\'s working but only for a few cases...\\n\\n        while k != 0:\\n            for i in range(len(gifts)):\\n                x = math.floor(math.sqrt(max(gifts)))\\n                if gifts[i] == max(gifts):\\n                    gifts[i] = x\\n                    k -= 1\\n        return gifts"
                    },
                    {
                        "username": "bparanj",
                        "content": "Your approach seems to have a nested loop which results in the operation executing `len(gifts) * k` times. However, you need the operation to only run \\'k\\' times. The current structure of the code causes it to modify the pile \\'k\\' times for each pile, which is not what the problem statement specifies.\\n\\nAdditionally, you\\'re finding the maximum value of the array in every iteration, which is a heavy operation and could be optimized.\\n\\nInstead, what you need is a single loop that runs \\'k\\' times. In each iteration, you find the largest pile, take its square root, and replace the original value. One way to efficiently do this is to use a priority queue (heap) data structure which keeps the elements in order and allows efficient extraction of the maximum element."
                    },
                    {
                        "username": "batariloa",
                        "content": "I do not understand whats wrong with my solution. It fails on test 52.\\n\\n\\nfunc pickGifts(gifts []int, k int) int64 {\\n\\n\\tsize := len(gifts)\\n\\n\\tlastLeafNodeIndex := (size - 1) / 2\\n\\n\\tmaxHeapify(&gifts, size, int(lastLeafNodeIndex))\\n\\n\\tfor k > 0 {\\n\\t\\tfloorSqrt := int(math.Sqrt(float64(gifts[0]))) \\n\\t\\tgifts[0] = floorSqrt \\n\\t\\tmaxHeapify(&gifts, size, 0)\\n\\t\\tk--\\n\\t}\\n\\n\\treturn int64(countGifts(gifts))\\n}\\n\\nfunc countGifts(heap []int) int {\\n\\n\\tsum := 0\\n\\tfor _, num := range heap {\\n\\t\\tsum += num\\n\\t}\\n\\n\\treturn sum\\n}\\n\\nfunc maxHeapify(heap *[]int, size int, i int) {\\n\\n\\tl := 2*i + 1\\n\\tr := 2*i + 2\\n\\n\\tlargest := i\\n\\n\\tif l < size && (*heap)[l] > (*heap)[i] {\\n\\t\\tlargest = l\\n\\t}\\n\\n\\tif r < size && (*heap)[r] > (*heap)[largest] {\\n\\t\\tlargest = r\\n\\t}\\n\\n\\tif largest != i {\\n\\t\\t(*heap)[i], (*heap)[largest] = (*heap)[largest], (*heap)[i]\\n\\t\\tmaxHeapify(heap, size, largest)\\n\\t}\\n}\\n\\n"
                    },
                    {
                        "username": "bparanj",
                        "content": "The issue here is likely with how you\\'re building your initial max heap. The max heapify function is being called starting from the last leaf node\\'s parent and you do not iterate backwards to include all parents of the leaf nodes. Because of this, your initial heap might not be a max heap.\\n\\nWhen you start from the last leaf node\\'s parent, you should then go backwards through the array, ensuring all subtrees are max heaps. You can do this by adding a loop that goes from last leaf node\\'s parent to the root of the tree (index 0) in a reverse manner. \\n\\nHere\\'s how you can modify the max heap construction part of your code:\\n\\n```go\\nfor i := lastLeafNodeIndex; i >= 0; i-- {\\n\\tmaxHeapify(&gifts, size, i)\\n}\\n```\\nThis way, you ensure that your heap property is maintained from the start. Then, as you continue to pick gifts, the max heapify function should correctly rearrange the elements to maintain the max heap property.\\n\\nThis change is necessary because in the heap data structure, the parent node must always have a value that is greater than or equal to its children. So, we need to start heapifying from the bottom of the tree and work our way up to the root to ensure this property is maintained."
                    },
                    {
                        "username": "sandagolcea",
                        "content": "For JS - leetcode uses a library for the max priority queue. This is how you use it:\n ```\nlet q = new MaxPriorityQueue();\n// add a val:\n// let giftValue = 7;\nq.enqueue(giftValue);\n// pop (the elem with the biggest val):\nlet maxVal = q.dequeue().element;\n```"
                    },
                    {
                        "username": "izzatullohboy007",
                        "content": "class Solution:\\n    def pickGifts(self, gifts: List[int], k: int) -> int:\\n        import math \\n        for i in range(k):\\n            s = max(gifts)\\n            gifts.append(math.isqrt(s))\\n            gifts.remove(s)\\n        return sum(gifts)\\n\\n"
                    },
                    {
                        "username": "devottam2809",
                        "content": "whats is wrong with this approach??    \\n while(k--)\\n     {\\n       int maxi=INT_MIN;\\n         for(int i=0;i<gifts.size();i++)\\n         {\\n            if(gifts[i]>maxi)\\n            {\\n                maxi=gifts[i];\\n                int temp=sqrt(maxi);\\n                gifts[i]=temp;\\n            }\\n         }\\n     }\\n    int sum=0;\\n        for(int i=0;i<gifts.size();i++)\\n            sum+=gifts[i];\\n    return sum;\\n    }"
                    },
                    {
                        "username": "bparanj",
                        "content": "This approach has several issues:\\n\\n1. **Finding Maximum Incorrectly:** The loop is intended to find the maximum element in `gifts[]` and then update the maximum element with its square root. However, it\\'s incorrectly updating `gifts[i]` with the square root of `maxi` every time it finds a new maximum. As a result, it\\'s possible that not just the maximum element but several elements get updated in each iteration of the outer loop.\\n\\n2. **Wrong Transformation Operation:** According to our original problem, each chosen gift\\'s value should be reduced to half of its original value, but this code is replacing the maximum value with its square root, which doesn\\'t match the problem\\'s requirements.\\n\\n3. **No Breaking Condition:** There is no condition to break out of the loop if all elements in `gifts[]` become 0. The loop continues for `k` times, which could lead to unnecessary computations.\\n\\n4. **Time Complexity:** This code has a time complexity of O(k*n) because for each of `k` iterations, it\\'s performing an O(n) operation to find the maximum value in the array. This would not be efficient for large inputs.\\n\\nHere\\'s the correct approach:\\n\\n```cpp\\nfor(int i=0; i < k; i++) {\\n    int maxIndex = max_element(gifts.begin(), gifts.end()) - gifts.begin();\\n    gifts[maxIndex] = gifts[maxIndex] / 2;\\n}\\n```\\n\\nIn this code, `max_element()` is a built-in function in C++ that returns an iterator pointing to the maximum element in the range [first, last) that we\\'ve passed. We then subtract `gifts.begin()` from this iterator to get the index of the maximum element in our array. We can then directly halve the value at this index. The loop runs for `k` iterations, and in each iteration, we\\'re finding and halving the maximum value in our array."
                    }
                ]
            },
            {
                "id": 1812579,
                "content": [
                    {
                        "username": "tomfiji",
                        "content": "For the first example, how is the answer 29 and not 30? I imagine the final list would look like: [10, 8, 5, 3, 4]. Am I missing something here?"
                    },
                    {
                        "username": "amanjaiswal159",
                        "content": "[@sandagolcea](/sandagolcea) This explained the complete problem statement and much better than what explained in question."
                    },
                    {
                        "username": "kalaskarrohit7502",
                        "content": "[@sandagolcea](/sandagolcea) thanks for explanation "
                    },
                    {
                        "username": "sandagolcea",
                        "content": "Yes, thing is: you always look at the array and `reconsider ALL values`, INCLUDING the values that you've already handled.\n\n```\ngifts = [25,64,9,4,100]\n\nk = 1, max is 100, so we replace it with sqrt(100)\ngifts = [25,64,9,4,10]\n\nk = 2, max is 64, so we replace it with sqrt(64)\ngifts = [25,8,9,4,10]\n\nk = 3, max is 25, so we replace it with sqrt(25)\ngifts = [5,8,9,4,10]\n\nTHIS IS WHERE IT'S CONFUSING:\nk = 4, max is ..not 9, it's the value we modified at step k = 1, aka 10,\nso we replace this max value with floor of sqrt(10) = 3\ngifts = [5,8,9,4,3]\n\nNow add all vals, and you get 5 + 8 + 9 + 4 + 3 = 29\n```"
                    },
                    {
                        "username": "S_Basu",
                        "content": "*Two approaches that readily come to mind:*\n- Brute force: Sorting `gifts[]` before every operation\n- **Priority Queue** (Reverse Order)\n##### [Link to Solution](https://leetcode.com/problems/take-gifts-from-the-richest-pile/solutions/3144106/2-java-solutions-100-time-space/)"
                    },
                    {
                        "username": "MayuD",
                        "content": "Similar to \\nhttps://leetcode.com/problems/maximal-score-after-applying-k-operations/"
                    },
                    {
                        "username": "satyam47",
                        "content": "Hint :  **priority_queue**"
                    },
                    {
                        "username": "dhruv4023",
                        "content": "My solution in python language:\\n\\n    def pickGifts(self, gifts: List[int], k: int) -> int:\\n        def fun(g,k):\\n            # g=[25,64,9,4,100]\\n            while k!=0:\\n                k=k-1\\n                m=max(g)\\n                i=g.index(m)\\n                g[i]=int(m**(1/2))\\n            return sum(g)\\n        return fun(gifts,k)\\n"
                    },
                    {
                        "username": "shreyaahadkar",
                        "content": "Could someone please tell me what is wrong with my solution?\\nIt\\'s working but only for a few cases...\\n\\n        while k != 0:\\n            for i in range(len(gifts)):\\n                x = math.floor(math.sqrt(max(gifts)))\\n                if gifts[i] == max(gifts):\\n                    gifts[i] = x\\n                    k -= 1\\n        return gifts"
                    },
                    {
                        "username": "bparanj",
                        "content": "Your approach seems to have a nested loop which results in the operation executing `len(gifts) * k` times. However, you need the operation to only run \\'k\\' times. The current structure of the code causes it to modify the pile \\'k\\' times for each pile, which is not what the problem statement specifies.\\n\\nAdditionally, you\\'re finding the maximum value of the array in every iteration, which is a heavy operation and could be optimized.\\n\\nInstead, what you need is a single loop that runs \\'k\\' times. In each iteration, you find the largest pile, take its square root, and replace the original value. One way to efficiently do this is to use a priority queue (heap) data structure which keeps the elements in order and allows efficient extraction of the maximum element."
                    },
                    {
                        "username": "batariloa",
                        "content": "I do not understand whats wrong with my solution. It fails on test 52.\\n\\n\\nfunc pickGifts(gifts []int, k int) int64 {\\n\\n\\tsize := len(gifts)\\n\\n\\tlastLeafNodeIndex := (size - 1) / 2\\n\\n\\tmaxHeapify(&gifts, size, int(lastLeafNodeIndex))\\n\\n\\tfor k > 0 {\\n\\t\\tfloorSqrt := int(math.Sqrt(float64(gifts[0]))) \\n\\t\\tgifts[0] = floorSqrt \\n\\t\\tmaxHeapify(&gifts, size, 0)\\n\\t\\tk--\\n\\t}\\n\\n\\treturn int64(countGifts(gifts))\\n}\\n\\nfunc countGifts(heap []int) int {\\n\\n\\tsum := 0\\n\\tfor _, num := range heap {\\n\\t\\tsum += num\\n\\t}\\n\\n\\treturn sum\\n}\\n\\nfunc maxHeapify(heap *[]int, size int, i int) {\\n\\n\\tl := 2*i + 1\\n\\tr := 2*i + 2\\n\\n\\tlargest := i\\n\\n\\tif l < size && (*heap)[l] > (*heap)[i] {\\n\\t\\tlargest = l\\n\\t}\\n\\n\\tif r < size && (*heap)[r] > (*heap)[largest] {\\n\\t\\tlargest = r\\n\\t}\\n\\n\\tif largest != i {\\n\\t\\t(*heap)[i], (*heap)[largest] = (*heap)[largest], (*heap)[i]\\n\\t\\tmaxHeapify(heap, size, largest)\\n\\t}\\n}\\n\\n"
                    },
                    {
                        "username": "bparanj",
                        "content": "The issue here is likely with how you\\'re building your initial max heap. The max heapify function is being called starting from the last leaf node\\'s parent and you do not iterate backwards to include all parents of the leaf nodes. Because of this, your initial heap might not be a max heap.\\n\\nWhen you start from the last leaf node\\'s parent, you should then go backwards through the array, ensuring all subtrees are max heaps. You can do this by adding a loop that goes from last leaf node\\'s parent to the root of the tree (index 0) in a reverse manner. \\n\\nHere\\'s how you can modify the max heap construction part of your code:\\n\\n```go\\nfor i := lastLeafNodeIndex; i >= 0; i-- {\\n\\tmaxHeapify(&gifts, size, i)\\n}\\n```\\nThis way, you ensure that your heap property is maintained from the start. Then, as you continue to pick gifts, the max heapify function should correctly rearrange the elements to maintain the max heap property.\\n\\nThis change is necessary because in the heap data structure, the parent node must always have a value that is greater than or equal to its children. So, we need to start heapifying from the bottom of the tree and work our way up to the root to ensure this property is maintained."
                    },
                    {
                        "username": "sandagolcea",
                        "content": "For JS - leetcode uses a library for the max priority queue. This is how you use it:\n ```\nlet q = new MaxPriorityQueue();\n// add a val:\n// let giftValue = 7;\nq.enqueue(giftValue);\n// pop (the elem with the biggest val):\nlet maxVal = q.dequeue().element;\n```"
                    },
                    {
                        "username": "izzatullohboy007",
                        "content": "class Solution:\\n    def pickGifts(self, gifts: List[int], k: int) -> int:\\n        import math \\n        for i in range(k):\\n            s = max(gifts)\\n            gifts.append(math.isqrt(s))\\n            gifts.remove(s)\\n        return sum(gifts)\\n\\n"
                    },
                    {
                        "username": "devottam2809",
                        "content": "whats is wrong with this approach??    \\n while(k--)\\n     {\\n       int maxi=INT_MIN;\\n         for(int i=0;i<gifts.size();i++)\\n         {\\n            if(gifts[i]>maxi)\\n            {\\n                maxi=gifts[i];\\n                int temp=sqrt(maxi);\\n                gifts[i]=temp;\\n            }\\n         }\\n     }\\n    int sum=0;\\n        for(int i=0;i<gifts.size();i++)\\n            sum+=gifts[i];\\n    return sum;\\n    }"
                    },
                    {
                        "username": "bparanj",
                        "content": "This approach has several issues:\\n\\n1. **Finding Maximum Incorrectly:** The loop is intended to find the maximum element in `gifts[]` and then update the maximum element with its square root. However, it\\'s incorrectly updating `gifts[i]` with the square root of `maxi` every time it finds a new maximum. As a result, it\\'s possible that not just the maximum element but several elements get updated in each iteration of the outer loop.\\n\\n2. **Wrong Transformation Operation:** According to our original problem, each chosen gift\\'s value should be reduced to half of its original value, but this code is replacing the maximum value with its square root, which doesn\\'t match the problem\\'s requirements.\\n\\n3. **No Breaking Condition:** There is no condition to break out of the loop if all elements in `gifts[]` become 0. The loop continues for `k` times, which could lead to unnecessary computations.\\n\\n4. **Time Complexity:** This code has a time complexity of O(k*n) because for each of `k` iterations, it\\'s performing an O(n) operation to find the maximum value in the array. This would not be efficient for large inputs.\\n\\nHere\\'s the correct approach:\\n\\n```cpp\\nfor(int i=0; i < k; i++) {\\n    int maxIndex = max_element(gifts.begin(), gifts.end()) - gifts.begin();\\n    gifts[maxIndex] = gifts[maxIndex] / 2;\\n}\\n```\\n\\nIn this code, `max_element()` is a built-in function in C++ that returns an iterator pointing to the maximum element in the range [first, last) that we\\'ve passed. We then subtract `gifts.begin()` from this iterator to get the index of the maximum element in our array. We can then directly halve the value at this index. The loop runs for `k` iterations, and in each iteration, we\\'re finding and halving the maximum value in our array."
                    }
                ]
            },
            {
                "id": 1800692,
                "content": [
                    {
                        "username": "tomfiji",
                        "content": "For the first example, how is the answer 29 and not 30? I imagine the final list would look like: [10, 8, 5, 3, 4]. Am I missing something here?"
                    },
                    {
                        "username": "amanjaiswal159",
                        "content": "[@sandagolcea](/sandagolcea) This explained the complete problem statement and much better than what explained in question."
                    },
                    {
                        "username": "kalaskarrohit7502",
                        "content": "[@sandagolcea](/sandagolcea) thanks for explanation "
                    },
                    {
                        "username": "sandagolcea",
                        "content": "Yes, thing is: you always look at the array and `reconsider ALL values`, INCLUDING the values that you've already handled.\n\n```\ngifts = [25,64,9,4,100]\n\nk = 1, max is 100, so we replace it with sqrt(100)\ngifts = [25,64,9,4,10]\n\nk = 2, max is 64, so we replace it with sqrt(64)\ngifts = [25,8,9,4,10]\n\nk = 3, max is 25, so we replace it with sqrt(25)\ngifts = [5,8,9,4,10]\n\nTHIS IS WHERE IT'S CONFUSING:\nk = 4, max is ..not 9, it's the value we modified at step k = 1, aka 10,\nso we replace this max value with floor of sqrt(10) = 3\ngifts = [5,8,9,4,3]\n\nNow add all vals, and you get 5 + 8 + 9 + 4 + 3 = 29\n```"
                    },
                    {
                        "username": "S_Basu",
                        "content": "*Two approaches that readily come to mind:*\n- Brute force: Sorting `gifts[]` before every operation\n- **Priority Queue** (Reverse Order)\n##### [Link to Solution](https://leetcode.com/problems/take-gifts-from-the-richest-pile/solutions/3144106/2-java-solutions-100-time-space/)"
                    },
                    {
                        "username": "MayuD",
                        "content": "Similar to \\nhttps://leetcode.com/problems/maximal-score-after-applying-k-operations/"
                    },
                    {
                        "username": "satyam47",
                        "content": "Hint :  **priority_queue**"
                    },
                    {
                        "username": "dhruv4023",
                        "content": "My solution in python language:\\n\\n    def pickGifts(self, gifts: List[int], k: int) -> int:\\n        def fun(g,k):\\n            # g=[25,64,9,4,100]\\n            while k!=0:\\n                k=k-1\\n                m=max(g)\\n                i=g.index(m)\\n                g[i]=int(m**(1/2))\\n            return sum(g)\\n        return fun(gifts,k)\\n"
                    },
                    {
                        "username": "shreyaahadkar",
                        "content": "Could someone please tell me what is wrong with my solution?\\nIt\\'s working but only for a few cases...\\n\\n        while k != 0:\\n            for i in range(len(gifts)):\\n                x = math.floor(math.sqrt(max(gifts)))\\n                if gifts[i] == max(gifts):\\n                    gifts[i] = x\\n                    k -= 1\\n        return gifts"
                    },
                    {
                        "username": "bparanj",
                        "content": "Your approach seems to have a nested loop which results in the operation executing `len(gifts) * k` times. However, you need the operation to only run \\'k\\' times. The current structure of the code causes it to modify the pile \\'k\\' times for each pile, which is not what the problem statement specifies.\\n\\nAdditionally, you\\'re finding the maximum value of the array in every iteration, which is a heavy operation and could be optimized.\\n\\nInstead, what you need is a single loop that runs \\'k\\' times. In each iteration, you find the largest pile, take its square root, and replace the original value. One way to efficiently do this is to use a priority queue (heap) data structure which keeps the elements in order and allows efficient extraction of the maximum element."
                    },
                    {
                        "username": "batariloa",
                        "content": "I do not understand whats wrong with my solution. It fails on test 52.\\n\\n\\nfunc pickGifts(gifts []int, k int) int64 {\\n\\n\\tsize := len(gifts)\\n\\n\\tlastLeafNodeIndex := (size - 1) / 2\\n\\n\\tmaxHeapify(&gifts, size, int(lastLeafNodeIndex))\\n\\n\\tfor k > 0 {\\n\\t\\tfloorSqrt := int(math.Sqrt(float64(gifts[0]))) \\n\\t\\tgifts[0] = floorSqrt \\n\\t\\tmaxHeapify(&gifts, size, 0)\\n\\t\\tk--\\n\\t}\\n\\n\\treturn int64(countGifts(gifts))\\n}\\n\\nfunc countGifts(heap []int) int {\\n\\n\\tsum := 0\\n\\tfor _, num := range heap {\\n\\t\\tsum += num\\n\\t}\\n\\n\\treturn sum\\n}\\n\\nfunc maxHeapify(heap *[]int, size int, i int) {\\n\\n\\tl := 2*i + 1\\n\\tr := 2*i + 2\\n\\n\\tlargest := i\\n\\n\\tif l < size && (*heap)[l] > (*heap)[i] {\\n\\t\\tlargest = l\\n\\t}\\n\\n\\tif r < size && (*heap)[r] > (*heap)[largest] {\\n\\t\\tlargest = r\\n\\t}\\n\\n\\tif largest != i {\\n\\t\\t(*heap)[i], (*heap)[largest] = (*heap)[largest], (*heap)[i]\\n\\t\\tmaxHeapify(heap, size, largest)\\n\\t}\\n}\\n\\n"
                    },
                    {
                        "username": "bparanj",
                        "content": "The issue here is likely with how you\\'re building your initial max heap. The max heapify function is being called starting from the last leaf node\\'s parent and you do not iterate backwards to include all parents of the leaf nodes. Because of this, your initial heap might not be a max heap.\\n\\nWhen you start from the last leaf node\\'s parent, you should then go backwards through the array, ensuring all subtrees are max heaps. You can do this by adding a loop that goes from last leaf node\\'s parent to the root of the tree (index 0) in a reverse manner. \\n\\nHere\\'s how you can modify the max heap construction part of your code:\\n\\n```go\\nfor i := lastLeafNodeIndex; i >= 0; i-- {\\n\\tmaxHeapify(&gifts, size, i)\\n}\\n```\\nThis way, you ensure that your heap property is maintained from the start. Then, as you continue to pick gifts, the max heapify function should correctly rearrange the elements to maintain the max heap property.\\n\\nThis change is necessary because in the heap data structure, the parent node must always have a value that is greater than or equal to its children. So, we need to start heapifying from the bottom of the tree and work our way up to the root to ensure this property is maintained."
                    },
                    {
                        "username": "sandagolcea",
                        "content": "For JS - leetcode uses a library for the max priority queue. This is how you use it:\n ```\nlet q = new MaxPriorityQueue();\n// add a val:\n// let giftValue = 7;\nq.enqueue(giftValue);\n// pop (the elem with the biggest val):\nlet maxVal = q.dequeue().element;\n```"
                    },
                    {
                        "username": "izzatullohboy007",
                        "content": "class Solution:\\n    def pickGifts(self, gifts: List[int], k: int) -> int:\\n        import math \\n        for i in range(k):\\n            s = max(gifts)\\n            gifts.append(math.isqrt(s))\\n            gifts.remove(s)\\n        return sum(gifts)\\n\\n"
                    },
                    {
                        "username": "devottam2809",
                        "content": "whats is wrong with this approach??    \\n while(k--)\\n     {\\n       int maxi=INT_MIN;\\n         for(int i=0;i<gifts.size();i++)\\n         {\\n            if(gifts[i]>maxi)\\n            {\\n                maxi=gifts[i];\\n                int temp=sqrt(maxi);\\n                gifts[i]=temp;\\n            }\\n         }\\n     }\\n    int sum=0;\\n        for(int i=0;i<gifts.size();i++)\\n            sum+=gifts[i];\\n    return sum;\\n    }"
                    },
                    {
                        "username": "bparanj",
                        "content": "This approach has several issues:\\n\\n1. **Finding Maximum Incorrectly:** The loop is intended to find the maximum element in `gifts[]` and then update the maximum element with its square root. However, it\\'s incorrectly updating `gifts[i]` with the square root of `maxi` every time it finds a new maximum. As a result, it\\'s possible that not just the maximum element but several elements get updated in each iteration of the outer loop.\\n\\n2. **Wrong Transformation Operation:** According to our original problem, each chosen gift\\'s value should be reduced to half of its original value, but this code is replacing the maximum value with its square root, which doesn\\'t match the problem\\'s requirements.\\n\\n3. **No Breaking Condition:** There is no condition to break out of the loop if all elements in `gifts[]` become 0. The loop continues for `k` times, which could lead to unnecessary computations.\\n\\n4. **Time Complexity:** This code has a time complexity of O(k*n) because for each of `k` iterations, it\\'s performing an O(n) operation to find the maximum value in the array. This would not be efficient for large inputs.\\n\\nHere\\'s the correct approach:\\n\\n```cpp\\nfor(int i=0; i < k; i++) {\\n    int maxIndex = max_element(gifts.begin(), gifts.end()) - gifts.begin();\\n    gifts[maxIndex] = gifts[maxIndex] / 2;\\n}\\n```\\n\\nIn this code, `max_element()` is a built-in function in C++ that returns an iterator pointing to the maximum element in the range [first, last) that we\\'ve passed. We then subtract `gifts.begin()` from this iterator to get the index of the maximum element in our array. We can then directly halve the value at this index. The loop runs for `k` iterations, and in each iteration, we\\'re finding and halving the maximum value in our array."
                    }
                ]
            },
            {
                "id": 1791742,
                "content": [
                    {
                        "username": "tomfiji",
                        "content": "For the first example, how is the answer 29 and not 30? I imagine the final list would look like: [10, 8, 5, 3, 4]. Am I missing something here?"
                    },
                    {
                        "username": "amanjaiswal159",
                        "content": "[@sandagolcea](/sandagolcea) This explained the complete problem statement and much better than what explained in question."
                    },
                    {
                        "username": "kalaskarrohit7502",
                        "content": "[@sandagolcea](/sandagolcea) thanks for explanation "
                    },
                    {
                        "username": "sandagolcea",
                        "content": "Yes, thing is: you always look at the array and `reconsider ALL values`, INCLUDING the values that you've already handled.\n\n```\ngifts = [25,64,9,4,100]\n\nk = 1, max is 100, so we replace it with sqrt(100)\ngifts = [25,64,9,4,10]\n\nk = 2, max is 64, so we replace it with sqrt(64)\ngifts = [25,8,9,4,10]\n\nk = 3, max is 25, so we replace it with sqrt(25)\ngifts = [5,8,9,4,10]\n\nTHIS IS WHERE IT'S CONFUSING:\nk = 4, max is ..not 9, it's the value we modified at step k = 1, aka 10,\nso we replace this max value with floor of sqrt(10) = 3\ngifts = [5,8,9,4,3]\n\nNow add all vals, and you get 5 + 8 + 9 + 4 + 3 = 29\n```"
                    },
                    {
                        "username": "S_Basu",
                        "content": "*Two approaches that readily come to mind:*\n- Brute force: Sorting `gifts[]` before every operation\n- **Priority Queue** (Reverse Order)\n##### [Link to Solution](https://leetcode.com/problems/take-gifts-from-the-richest-pile/solutions/3144106/2-java-solutions-100-time-space/)"
                    },
                    {
                        "username": "MayuD",
                        "content": "Similar to \\nhttps://leetcode.com/problems/maximal-score-after-applying-k-operations/"
                    },
                    {
                        "username": "satyam47",
                        "content": "Hint :  **priority_queue**"
                    },
                    {
                        "username": "dhruv4023",
                        "content": "My solution in python language:\\n\\n    def pickGifts(self, gifts: List[int], k: int) -> int:\\n        def fun(g,k):\\n            # g=[25,64,9,4,100]\\n            while k!=0:\\n                k=k-1\\n                m=max(g)\\n                i=g.index(m)\\n                g[i]=int(m**(1/2))\\n            return sum(g)\\n        return fun(gifts,k)\\n"
                    },
                    {
                        "username": "shreyaahadkar",
                        "content": "Could someone please tell me what is wrong with my solution?\\nIt\\'s working but only for a few cases...\\n\\n        while k != 0:\\n            for i in range(len(gifts)):\\n                x = math.floor(math.sqrt(max(gifts)))\\n                if gifts[i] == max(gifts):\\n                    gifts[i] = x\\n                    k -= 1\\n        return gifts"
                    },
                    {
                        "username": "bparanj",
                        "content": "Your approach seems to have a nested loop which results in the operation executing `len(gifts) * k` times. However, you need the operation to only run \\'k\\' times. The current structure of the code causes it to modify the pile \\'k\\' times for each pile, which is not what the problem statement specifies.\\n\\nAdditionally, you\\'re finding the maximum value of the array in every iteration, which is a heavy operation and could be optimized.\\n\\nInstead, what you need is a single loop that runs \\'k\\' times. In each iteration, you find the largest pile, take its square root, and replace the original value. One way to efficiently do this is to use a priority queue (heap) data structure which keeps the elements in order and allows efficient extraction of the maximum element."
                    },
                    {
                        "username": "batariloa",
                        "content": "I do not understand whats wrong with my solution. It fails on test 52.\\n\\n\\nfunc pickGifts(gifts []int, k int) int64 {\\n\\n\\tsize := len(gifts)\\n\\n\\tlastLeafNodeIndex := (size - 1) / 2\\n\\n\\tmaxHeapify(&gifts, size, int(lastLeafNodeIndex))\\n\\n\\tfor k > 0 {\\n\\t\\tfloorSqrt := int(math.Sqrt(float64(gifts[0]))) \\n\\t\\tgifts[0] = floorSqrt \\n\\t\\tmaxHeapify(&gifts, size, 0)\\n\\t\\tk--\\n\\t}\\n\\n\\treturn int64(countGifts(gifts))\\n}\\n\\nfunc countGifts(heap []int) int {\\n\\n\\tsum := 0\\n\\tfor _, num := range heap {\\n\\t\\tsum += num\\n\\t}\\n\\n\\treturn sum\\n}\\n\\nfunc maxHeapify(heap *[]int, size int, i int) {\\n\\n\\tl := 2*i + 1\\n\\tr := 2*i + 2\\n\\n\\tlargest := i\\n\\n\\tif l < size && (*heap)[l] > (*heap)[i] {\\n\\t\\tlargest = l\\n\\t}\\n\\n\\tif r < size && (*heap)[r] > (*heap)[largest] {\\n\\t\\tlargest = r\\n\\t}\\n\\n\\tif largest != i {\\n\\t\\t(*heap)[i], (*heap)[largest] = (*heap)[largest], (*heap)[i]\\n\\t\\tmaxHeapify(heap, size, largest)\\n\\t}\\n}\\n\\n"
                    },
                    {
                        "username": "bparanj",
                        "content": "The issue here is likely with how you\\'re building your initial max heap. The max heapify function is being called starting from the last leaf node\\'s parent and you do not iterate backwards to include all parents of the leaf nodes. Because of this, your initial heap might not be a max heap.\\n\\nWhen you start from the last leaf node\\'s parent, you should then go backwards through the array, ensuring all subtrees are max heaps. You can do this by adding a loop that goes from last leaf node\\'s parent to the root of the tree (index 0) in a reverse manner. \\n\\nHere\\'s how you can modify the max heap construction part of your code:\\n\\n```go\\nfor i := lastLeafNodeIndex; i >= 0; i-- {\\n\\tmaxHeapify(&gifts, size, i)\\n}\\n```\\nThis way, you ensure that your heap property is maintained from the start. Then, as you continue to pick gifts, the max heapify function should correctly rearrange the elements to maintain the max heap property.\\n\\nThis change is necessary because in the heap data structure, the parent node must always have a value that is greater than or equal to its children. So, we need to start heapifying from the bottom of the tree and work our way up to the root to ensure this property is maintained."
                    },
                    {
                        "username": "sandagolcea",
                        "content": "For JS - leetcode uses a library for the max priority queue. This is how you use it:\n ```\nlet q = new MaxPriorityQueue();\n// add a val:\n// let giftValue = 7;\nq.enqueue(giftValue);\n// pop (the elem with the biggest val):\nlet maxVal = q.dequeue().element;\n```"
                    },
                    {
                        "username": "izzatullohboy007",
                        "content": "class Solution:\\n    def pickGifts(self, gifts: List[int], k: int) -> int:\\n        import math \\n        for i in range(k):\\n            s = max(gifts)\\n            gifts.append(math.isqrt(s))\\n            gifts.remove(s)\\n        return sum(gifts)\\n\\n"
                    },
                    {
                        "username": "devottam2809",
                        "content": "whats is wrong with this approach??    \\n while(k--)\\n     {\\n       int maxi=INT_MIN;\\n         for(int i=0;i<gifts.size();i++)\\n         {\\n            if(gifts[i]>maxi)\\n            {\\n                maxi=gifts[i];\\n                int temp=sqrt(maxi);\\n                gifts[i]=temp;\\n            }\\n         }\\n     }\\n    int sum=0;\\n        for(int i=0;i<gifts.size();i++)\\n            sum+=gifts[i];\\n    return sum;\\n    }"
                    },
                    {
                        "username": "bparanj",
                        "content": "This approach has several issues:\\n\\n1. **Finding Maximum Incorrectly:** The loop is intended to find the maximum element in `gifts[]` and then update the maximum element with its square root. However, it\\'s incorrectly updating `gifts[i]` with the square root of `maxi` every time it finds a new maximum. As a result, it\\'s possible that not just the maximum element but several elements get updated in each iteration of the outer loop.\\n\\n2. **Wrong Transformation Operation:** According to our original problem, each chosen gift\\'s value should be reduced to half of its original value, but this code is replacing the maximum value with its square root, which doesn\\'t match the problem\\'s requirements.\\n\\n3. **No Breaking Condition:** There is no condition to break out of the loop if all elements in `gifts[]` become 0. The loop continues for `k` times, which could lead to unnecessary computations.\\n\\n4. **Time Complexity:** This code has a time complexity of O(k*n) because for each of `k` iterations, it\\'s performing an O(n) operation to find the maximum value in the array. This would not be efficient for large inputs.\\n\\nHere\\'s the correct approach:\\n\\n```cpp\\nfor(int i=0; i < k; i++) {\\n    int maxIndex = max_element(gifts.begin(), gifts.end()) - gifts.begin();\\n    gifts[maxIndex] = gifts[maxIndex] / 2;\\n}\\n```\\n\\nIn this code, `max_element()` is a built-in function in C++ that returns an iterator pointing to the maximum element in the range [first, last) that we\\'ve passed. We then subtract `gifts.begin()` from this iterator to get the index of the maximum element in our array. We can then directly halve the value at this index. The loop runs for `k` iterations, and in each iteration, we\\'re finding and halving the maximum value in our array."
                    }
                ]
            }
        ]
    }
]