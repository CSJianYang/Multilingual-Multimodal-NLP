[
    {
        "title": "Count Pairs Of Similar Strings",
        "question_content": "You are given a 0-indexed string array words.\nTwo strings are similar if they consist of the same characters.\n\n\tFor example, \"abca\" and \"cba\" are similar since both consist of characters 'a', 'b', and 'c'.\n\tHowever, \"abacba\" and \"bcfd\" are not similar since they do not consist of the same characters.\n\nReturn the number of pairs (i, j) such that 0 <= i < j <= word.length - 1 and the two strings words[i] and words[j] are similar.\n&nbsp;\nExample 1:\n\nInput: words = [\"aba\",\"aabb\",\"abcd\",\"bac\",\"aabc\"]\nOutput: 2\nExplanation: There are 2 pairs that satisfy the conditions:\n- i = 0 and j = 1 : both words[0] and words[1] only consist of characters 'a' and 'b'. \n- i = 3 and j = 4 : both words[3] and words[4] only consist of characters 'a', 'b', and 'c'. \n\nExample 2:\n\nInput: words = [\"aabb\",\"ab\",\"ba\"]\nOutput: 3\nExplanation: There are 3 pairs that satisfy the conditions:\n- i = 0 and j = 1 : both words[0] and words[1] only consist of characters 'a' and 'b'. \n- i = 0 and j = 2 : both words[0] and words[2] only consist of characters 'a' and 'b'.\n- i = 1 and j = 2 : both words[1] and words[2] only consist of characters 'a' and 'b'.\n\nExample 3:\n\nInput: words = [\"nba\",\"cba\",\"dba\"]\nOutput: 0\nExplanation: Since there does not exist any pair that satisfies the conditions, we return 0.\n&nbsp;\nConstraints:\n\n\t1 <= words.length <= 100\n\t1 <= words[i].length <= 100\n\twords[i] consist of only lowercase English letters.",
        "solutions": [
            {
                "id": 2923505,
                "title": "c-java-python3-frequency-table-mask",
                "content": "Please pull this [commit](https://github.com/gaosanyong/leetcode/commit/af6e415cd101768ea8743ea9e4d22d788c9461c3) for solutions of weekly 324. \\n\\n**Intuition**\\nHere, we can use a mask to indicate what characters appear in a word, and use a hash table to indicate the frequency of a mask. \\n**Implementation**\\n**C++**\\n```\\nclass Solution {\\npublic: \\n\\tint similarPairs(vector<string>& words) {\\n\\t\\tint ans = 0; \\n\\t\\tunordered_map<int, int> freq; \\n\\t\\tfor (auto& word : words) {\\n\\t\\t\\tint mask = 0; \\n\\t\\t\\tfor (auto& c : word) mask |= 1 << (c-\\'a\\'); \\n\\t\\t\\tans += freq[mask]++; \\n\\t\\t}\\n\\t\\treturn ans; \\n\\t}\\n};\\n```\\n**Java**\\n```\\nclass Solution {\\n\\tpublic int similarPairs(String[] words) {\\n\\t\\tint ans = 0; \\n\\t\\tHashMap<Integer, Integer> freq = new HashMap(); \\n\\t\\tfor (var word : words) {\\n\\t\\t\\tint mask = 0; \\n\\t\\t\\tfor (var ch : word.toCharArray()) \\n\\t\\t\\t\\tmask |= 1<<ch-\\'a\\'; \\n\\t\\t\\tans += freq.getOrDefault(mask, 0); \\n\\t\\t\\tfreq.merge(mask, 1, Integer::sum); \\n\\t\\t}\\n\\t\\treturn ans; \\n\\t}\\n}\\n```\\n**Python3**\\n```\\nclass Solution: \\n\\tdef similarPairs(self, words: List[str]) -> int: \\n\\t\\tans = 0\\n\\t\\tfreq = Counter()\\n\\t\\tfor word in words: \\n\\t\\t\\tmask = reduce(or_, (1<<ord(ch)-97 for ch in word))\\n\\t\\t\\tans += freq[mask]\\n\\t\\t\\tfreq[mask] += 1\\n\\t\\treturn ans\\n```\\n**Complexity**\\nTime O(NW) \\nSpace O(N) \\n",
                "solutionTags": [
                    "Java",
                    "Python3",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic: \\n\\tint similarPairs(vector<string>& words) {\\n\\t\\tint ans = 0; \\n\\t\\tunordered_map<int, int> freq; \\n\\t\\tfor (auto& word : words) {\\n\\t\\t\\tint mask = 0; \\n\\t\\t\\tfor (auto& c : word) mask |= 1 << (c-\\'a\\'); \\n\\t\\t\\tans += freq[mask]++; \\n\\t\\t}\\n\\t\\treturn ans; \\n\\t}\\n};\\n```\n```\\nclass Solution {\\n\\tpublic int similarPairs(String[] words) {\\n\\t\\tint ans = 0; \\n\\t\\tHashMap<Integer, Integer> freq = new HashMap(); \\n\\t\\tfor (var word : words) {\\n\\t\\t\\tint mask = 0; \\n\\t\\t\\tfor (var ch : word.toCharArray()) \\n\\t\\t\\t\\tmask |= 1<<ch-\\'a\\'; \\n\\t\\t\\tans += freq.getOrDefault(mask, 0); \\n\\t\\t\\tfreq.merge(mask, 1, Integer::sum); \\n\\t\\t}\\n\\t\\treturn ans; \\n\\t}\\n}\\n```\n```\\nclass Solution: \\n\\tdef similarPairs(self, words: List[str]) -> int: \\n\\t\\tans = 0\\n\\t\\tfreq = Counter()\\n\\t\\tfor word in words: \\n\\t\\t\\tmask = reduce(or_, (1<<ord(ch)-97 for ch in word))\\n\\t\\t\\tans += freq[mask]\\n\\t\\t\\tfreq[mask] += 1\\n\\t\\treturn ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3166484,
                "title": "o-1-space-o-n-k-time-hashmap-approach-python3",
                "content": "Bear with me, answer isn\\'t hard at all\\njust follow the intuition\\n> Please Leave a like if you liked the approach\\n\\n# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nAnalyzing the input array `words` and the problem description `Two strings are similar if they consist of the same characters.` we can see that words can be broken down into their unique characters. For example: *abba* is just \\'ab\\' and *acab* is just \\'acb\\'\\n\\nwith that, I realized that we could store all of the unique chars as keys for a hash and the corresponding values would be the **counts of similar strings**\\n{ KEY (unique value): VALUE (**count of similar strings**) }\\n\\nFor example \\n`Example 1: Input: words = [\"aba\",\"aabb\",\"abcd\",\"bac\",\"aabc\"]`\\nwould look something like this:\\n![image.png](https://assets.leetcode.com/users/images/b002a5be-55dc-44bc-8405-549d499529ed_1675999877.4854085.png)\\n\\nNow that we know how many words share the same letters we can find out how many unique pairs there are by using the n(n-1) /2 formula which finds the non-repeating pairs (idk the name of that formula, and YOU\\'RE NOT EXPECTED TO KNOW THAT FORMULA).\\n\\n *Wondering that if I know the number of elements, how would I know how many unique pairs we can form -> I googled that and found that formula.*\\n\\nanyway, now that we know that formula and how many instances there are for similar strings, we can iterate through every similar string key in the map, apply that formula to the value and add the result to a counter\\n![image.png](https://assets.leetcode.com/users/images/0c616454-80c8-43c9-9675-d8f6465e0edb_1676001084.1398206.png)\\nlastly, we return that counter\\n\\n\\n# How to convert the word to a key\\nTo convert the word to a key we do this in order:\\n1. convert string into a set (time complexity of this operation will be K: the average length of word[i])\\n`This has a flaw,\\nif words are in order like \\'abba\\' it will work ok since it will store it as \\'ab\\' but if words are not in order like \"bac\" it will store it out of order, and it will not match with it\\'s corresponding \\'abc\\' key`\\n2. To \"order\" the characters we will sort the set (time complexity will be O(26) at most, since the set made sure we only have unique characters and we know the string only contains lowercase characters)\\n3. Finally we convert this sorted list into a string by using the \".join() operator. This is also constant time since there are max 26 characters.\\n\\n# Complexity\\n- Time complexity: O(n * k) where n is the size of `words` and k is the average length of `words[i]`\\n    - we traverse the whole `words` array : O(n)  \\n        - inside that traversal, we create create a set for every word: O(k)\\n        - we sort that set: O(26) -> O(1)\\n        - we `\"\".join()` to create sorted array into a string: O(26) -> O(1)\\n\\n    - we traverse the hashmap: O(26) -> O(1)\\n\\n- Space complexity: O(1)\\n    - we create a set but it will have at most (26) characters\\n  - we create a hash, but since the keys will only be unique chars we know that this takes constant space (see image)\\n![image.png](https://assets.leetcode.com/users/images/9d866712-185f-4021-a8b9-36dd85e0132e_1676002074.0238433.png)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n> Please Leave a like if you liked the approach\\n\\n# Code\\n``` python []\\nclass Solution:\\n    def similarPairs(self, words: List[str]) -> int:\\n        wordMap = {}\\n\\n        #we traverse the input array\\n        for word in words:\\n            #convert the word into a (unique characters) hashable key\\n            #(see notes above for explanation)\\n            curr = sorted(set(word))\\n            curr = \\'\\'.join(curr)\\n\\n            #add count of this \"similar string\" instances\\n            if curr in wordMap:\\n                wordMap[curr]+=1\\n            else:\\n                wordMap[curr]=1\\n\\n        pairs = 0\\n        #traverse through all \"similar string\" keys\\n            #and add pairs using the unique combination formula\\n            #(see notes above for explanation)\\n        for word in wordMap:\\n            count = wordMap[word]\\n            pairs += (count* (count-1))//2\\n\\n        \\n        return pairs\\n        #Time Compelxity: O(N*K)\\n        #Space Complexity: O(26) -> O(1)\\n\\n\\n```\\n\\n> Please Leave a like if you liked the approach",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "``` python []\\nclass Solution:\\n    def similarPairs(self, words: List[str]) -> int:\\n        wordMap = {}\\n\\n        #we traverse the input array\\n        for word in words:\\n            #convert the word into a (unique characters) hashable key\\n            #(see notes above for explanation)\\n            curr = sorted(set(word))\\n            curr = \\'\\'.join(curr)\\n\\n            #add count of this \"similar string\" instances\\n            if curr in wordMap:\\n                wordMap[curr]+=1\\n            else:\\n                wordMap[curr]=1\\n\\n        pairs = 0\\n        #traverse through all \"similar string\" keys\\n            #and add pairs using the unique combination formula\\n            #(see notes above for explanation)\\n        for word in wordMap:\\n            count = wordMap[word]\\n            pairs += (count* (count-1))//2\\n\\n        \\n        return pairs\\n        #Time Compelxity: O(N*K)\\n        #Space Complexity: O(26) -> O(1)\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2923556,
                "title": "set-string",
                "content": "```\\nclass Solution {\\npublic:\\n    int similarPairs(vector<string>& words) {\\n        int ans = 0;\\n        vector<string> v;\\n        for(auto w: words){\\n            set<char> s;\\n            for(auto c: w) s.insert(c);\\n            string t = \"\";\\n            for(auto m: s) t += m;\\n            v.push_back(t);\\n        }\\n        for(int i = 0; i < v.size(); ++i){\\n            for(int j = i+1; j < v.size(); ++j){\\n                if(v[i] == v[j]) ans++;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int similarPairs(vector<string>& words) {\\n        int ans = 0;\\n        vector<string> v;\\n        for(auto w: words){\\n            set<char> s;\\n            for(auto c: w) s.insert(c);\\n            string t = \"\";\\n            for(auto m: s) t += m;\\n            v.push_back(t);\\n        }\\n        for(int i = 0; i < v.size(); ++i){\\n            for(int j = i+1; j < v.size(); ++j){\\n                if(v[i] == v[j]) ans++;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2923520,
                "title": "python-set-bonus-one-liner",
                "content": "**\\u2705 IF YOU LIKE THIS SOLUTION, PLEASE UPVOTE.**\\n****\\nThis solution employs the comparison of unique characters using `set`. \\n****\\n\\n**Python #1.**\\n```\\nclass Solution:\\n    def similarPairs(self, words: List[str]) -> int:\\n        cnt = 0\\n        for i,w1 in enumerate(words):\\n            for w2 in words[i+1:]:\\n                cnt += set(w1) == set(w2)\\n        return cnt\\n```\\n\\n**Python #2.** One-liner for the above solution.\\n```\\nclass Solution:\\n    def similarPairs(self, w: List[str]) -> int:\\n        \\n        return sum(set(x) == set(y) for i,x in enumerate(w) for y in w[i+1:])\\n\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def similarPairs(self, words: List[str]) -> int:\\n        cnt = 0\\n        for i,w1 in enumerate(words):\\n            for w2 in words[i+1:]:\\n                cnt += set(w1) == set(w2)\\n        return cnt\\n```\n```\\nclass Solution:\\n    def similarPairs(self, w: List[str]) -> int:\\n        \\n        return sum(set(x) == set(y) for i,x in enumerate(w) for y in w[i+1:])\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2923509,
                "title": "c-easy-and-simple-solution-brute-force-approach",
                "content": "***Guy\\'s if you find this solution helpful \\uD83D\\uDE0A, PLEASE do UPVOTE. By doing that it motivate\\'s me to create more better post like this \\u270D\\uFE0F***\\n# Complexity\\n- Time complexity:\\nO(N* N *N)\\n\\n- Space complexity:\\nO(N)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int similarPairs(vector<string>& words) {\\n        int count=0;\\n        for(int i=0;i<words.size();i++){\\n            vector<int>mapping1(26,0);\\n            for(auto b : words[i]){\\n                mapping1[b-\\'a\\']++;\\n            }\\n            \\n            for(int j=i+1;j<words.size();j++){\\n                vector<int>mapping2(26,0);\\n                for(auto k:words[j]){\\n                    mapping2[k-\\'a\\']++;\\n                }\\n                bool equal=true;\\n                for(int k=0;k<mapping1.size();k++){\\n                    if((mapping1[k]!=0 && mapping2[k]==0) || (mapping1[k]==0 && mapping2[k]!=0) ){\\n                        equal=false;\\n                        break;\\n                    }\\n                }\\n\\n            if(equal) count++;\\n            \\n            }\\n            \\n        }\\n        return count;\\n    }\\n};\\n```\\n***Guy\\'s if you find this solution helpful \\uD83D\\uDE0A, PLEASE do UPVOTE. By doing that it motivate\\'s me to create more better post like this \\u270D\\uFE0F***",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int similarPairs(vector<string>& words) {\\n        int count=0;\\n        for(int i=0;i<words.size();i++){\\n            vector<int>mapping1(26,0);\\n            for(auto b : words[i]){\\n                mapping1[b-\\'a\\']++;\\n            }\\n            \\n            for(int j=i+1;j<words.size();j++){\\n                vector<int>mapping2(26,0);\\n                for(auto k:words[j]){\\n                    mapping2[k-\\'a\\']++;\\n                }\\n                bool equal=true;\\n                for(int k=0;k<mapping1.size();k++){\\n                    if((mapping1[k]!=0 && mapping2[k]==0) || (mapping1[k]==0 && mapping2[k]!=0) ){\\n                        equal=false;\\n                        break;\\n                    }\\n                }\\n\\n            if(equal) count++;\\n            \\n            }\\n            \\n        }\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2923540,
                "title": "bitmask",
                "content": "Since there are up to 26 letters, we use a bitmask to represent a string. Each bitmask, therefore, represents a group of similar strings.\\n\\nWe use a hash map to count similar strings in each bitmask group.\\n\\nIf we have `n` strings in a group, we can form `n * (n - 1) / 2` pairs.\\n\\n> Or, we can just add existing number of similar strings to the result when we found another one.\\n\\n## No Raw Loops Version\\n**C++**\\n```cpp\\nint similarPairs(vector<string>& words) {\\n    unordered_map<int, int> m;\\n    return accumulate(begin(words), end(words), 0, [&](int cnt, const auto &w){\\n        return cnt + m[accumulate(begin(w), end(w), 0, [](int res, char ch) {\\n            return res | (1 << (ch - \\'a\\')); })]++;\\n    });\\n}\\n```\\n\\n## Raw Loops Version\\n**C++**\\n```cpp\\nint similarPairs(vector<string>& words) {\\n    unordered_map<int, int> m;\\n    int res = 0;\\n    for (const auto &w : words) {\\n        int bits = 0;\\n        for (auto ch : w)\\n            bits |= (1 << (ch - \\'a\\'));\\n        res += m[bits]++;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```cpp\\nint similarPairs(vector<string>& words) {\\n    unordered_map<int, int> m;\\n    return accumulate(begin(words), end(words), 0, [&](int cnt, const auto &w){\\n        return cnt + m[accumulate(begin(w), end(w), 0, [](int res, char ch) {\\n            return res | (1 << (ch - \\'a\\')); })]++;\\n    });\\n}\\n```\n```cpp\\nint similarPairs(vector<string>& words) {\\n    unordered_map<int, int> m;\\n    int res = 0;\\n    for (const auto &w : words) {\\n        int bits = 0;\\n        for (auto ch : w)\\n            bits |= (1 << (ch - \\'a\\'));\\n        res += m[bits]++;\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2923542,
                "title": "c-intuitive-easy-solution-count-equal-set",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int similarPairs(vector<string>& w) {\\n        int cnt=0;\\n        vector<set<char>> v;\\n        for(int i=0;i<w.size();i++){\\n            set<char> st(w[i].begin(),w[i].end());\\n            v.push_back(st);\\n        }\\n        for(int i=0;i<w.size()-1;i++){\\n            for(int j=i+1;j<w.size();j++){\\n                if(v[i]==v[j]){\\n                    cnt++;\\n                }\\n            }\\n        }\\n        return cnt;\\n    }\\n};\\n```\\n",
                "solutionTags": [
                    "C++",
                    "Ordered Set"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int similarPairs(vector<string>& w) {\\n        int cnt=0;\\n        vector<set<char>> v;\\n        for(int i=0;i<w.size();i++){\\n            set<char> st(w[i].begin(),w[i].end());\\n            v.push_back(st);\\n        }\\n        for(int i=0;i<w.size()-1;i++){\\n            for(int j=i+1;j<w.size();j++){\\n                if(v[i]==v[j]){\\n                    cnt++;\\n                }\\n            }\\n        }\\n        return cnt;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2923567,
                "title": "java-solution-hashset",
                "content": "\\n# Code\\n```\\nclass Solution {\\n    public int similarPairs(String[] words) {\\n        int count = 0;\\n        for(int i=0; i<words.length-1; i++){\\n            for(int j=i+1; j<words.length; j++){\\n                count += check(words[i], words[j]);\\n            }\\n        }\\n        return count;\\n    }\\n    private int check(String s, String t){\\n        Set sset = new HashSet();\\n        for(char c: s.toCharArray())    sset.add(c);\\n        Set tset = new HashSet();\\n        for(char c: t.toCharArray())    tset.add(c);\\n        return sset.equals(tset) ? 1 : 0;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int similarPairs(String[] words) {\\n        int count = 0;\\n        for(int i=0; i<words.length-1; i++){\\n            for(int j=i+1; j<words.length; j++){\\n                count += check(words[i], words[j]);\\n            }\\n        }\\n        return count;\\n    }\\n    private int check(String s, String t){\\n        Set sset = new HashSet();\\n        for(char c: s.toCharArray())    sset.add(c);\\n        Set tset = new HashSet();\\n        for(char c: t.toCharArray())    tset.add(c);\\n        return sset.equals(tset) ? 1 : 0;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2923473,
                "title": "simple-java-solution",
                "content": "\\n# Complexity\\n- Time complexity: O(n^2)\\n\\n- Space complexity: O(1) as the array size is constant\\n\\n# Code\\n```\\nclass Solution {\\n    public int similarPairs(String[] words) {\\n        int m=0;\\n        for(int i=0;i<words.length-1;i++)\\n        {\\n            for(int j=i+1;j<words.length;j++)\\n            {\\n                int a[]=new int[26];\\n                int b[]=new int[26];\\n                for(char c:words[i].toCharArray())\\n                {\\n                    a[c-\\'a\\']++;\\n                }\\n                for(char c:words[j].toCharArray())\\n                {\\n                    b[c-\\'a\\']++;\\n                }\\n                int k;\\n                for(k=0;k<26;k++)\\n                {\\n                    if((a[k]==0 && b[k]!=0) || (a[k]!=0 && b[k]==0))\\n                    {\\n                        break;\\n                    }\\n                }\\n                if(k==26)\\n                {\\n                    m++;\\n                }\\n            }\\n        }\\n        return m;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int similarPairs(String[] words) {\\n        int m=0;\\n        for(int i=0;i<words.length-1;i++)\\n        {\\n            for(int j=i+1;j<words.length;j++)\\n            {\\n                int a[]=new int[26];\\n                int b[]=new int[26];\\n                for(char c:words[i].toCharArray())\\n                {\\n                    a[c-\\'a\\']++;\\n                }\\n                for(char c:words[j].toCharArray())\\n                {\\n                    b[c-\\'a\\']++;\\n                }\\n                int k;\\n                for(k=0;k<26;k++)\\n                {\\n                    if((a[k]==0 && b[k]!=0) || (a[k]!=0 && b[k]==0))\\n                    {\\n                        break;\\n                    }\\n                }\\n                if(k==26)\\n                {\\n                    m++;\\n                }\\n            }\\n        }\\n        return m;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2923487,
                "title": "python-accepted",
                "content": "```\\nclass Solution:\\n    def similarPairs(self, w: List[str]) -> int:\\n        cnt=0\\n        for i in range(len(w)):\\n            for j in range(i):\\n                # print(i,j)\\n                if set(w[i])==set(w[j]):\\n                    cnt+=1\\n        return cnt\\n        \\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def similarPairs(self, w: List[str]) -> int:\\n        cnt=0\\n        for i in range(len(w)):\\n            for j in range(i):\\n                # print(i,j)\\n                if set(w[i])==set(w[j]):\\n                    cnt+=1\\n        return cnt\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3147441,
                "title": "very-easy-c-code-100",
                "content": "# Code\\n\\nSimple using set\\n```\\nclass Solution {\\npublic:\\n    int similarPairs(vector<string>& w){\\n        int n = w.size();\\n        int count = 0;\\n        for(int i=0;i<n;i++){\\n            set<char> s(w[i].begin(),w[i].end());\\n            string s1(s.begin(),s.end());\\n            w[i] = s1;\\n        }\\n        for(int i =0;i<n-1;i++)\\n            for(int j = i+1; j<n; j++)\\n                if(w[i]==w[j])\\n                    count++;\\n        return count;\\n    }\\n};\\n```\\nor using map\\n```\\nclass Solution {\\npublic:\\n    int similarPairs(vector<string>& w){\\n        int n = w.size();\\n        int count = 0;\\n        for(int i=0;i<n;i++){\\n            set<char> s(w[i].begin(),w[i].end());\\n            string s1(s.begin(),s.end());\\n            w[i] = s1;\\n        }\\n        map<string,int> m;\\n        for(int i=0; i<n; i++)\\n            m[w[i]]++;\\n        for(auto i:m)\\n            count += ((i.second)*(i.second-1))/2;\\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int similarPairs(vector<string>& w){\\n        int n = w.size();\\n        int count = 0;\\n        for(int i=0;i<n;i++){\\n            set<char> s(w[i].begin(),w[i].end());\\n            string s1(s.begin(),s.end());\\n            w[i] = s1;\\n        }\\n        for(int i =0;i<n-1;i++)\\n            for(int j = i+1; j<n; j++)\\n                if(w[i]==w[j])\\n                    count++;\\n        return count;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int similarPairs(vector<string>& w){\\n        int n = w.size();\\n        int count = 0;\\n        for(int i=0;i<n;i++){\\n            set<char> s(w[i].begin(),w[i].end());\\n            string s1(s.begin(),s.end());\\n            w[i] = s1;\\n        }\\n        map<string,int> m;\\n        for(int i=0; i<n; i++)\\n            m[w[i]]++;\\n        for(auto i:m)\\n            count += ((i.second)*(i.second-1))/2;\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2939618,
                "title": "python-easy-solution",
                "content": "# Code\\u2705\\n```\\nclass Solution:\\n    def similarPairs(self, words: List[str]) -> int:\\n        count = 0\\n        for i in range(len(words)):\\n            for j in range(i):\\n                if set(words[i]) == set(words[j]):\\n                    count +=1\\n        return count\\n\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "String"
                ],
                "code": "```\\nclass Solution:\\n    def similarPairs(self, words: List[str]) -> int:\\n        count = 0\\n        for i in range(len(words)):\\n            for j in range(i):\\n                if set(words[i]) == set(words[j]):\\n                    count +=1\\n        return count\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2925971,
                "title": "python-o-n",
                "content": "# Intuition\\nEach word can be converted into canonical form, which is a sorted\\nset of the letters in it. So \"baacab\" becomes \"abc\". If we have\\nk words which\\'s canonical form is \"abc\", the number of pairs of\\nsimilar words of this canonical form is `k * (k-1) / 2`.\\n\\n# Approach\\nWe iterate over words and convert them to their canonical form. If\\nwe have already seen `w` words of this canonical form, the new word\\ncan be paired with each one of these `w` words and we increase\\nthe number of similar words by `w`.\\n\\n# Complexity\\n- Time complexity:\\n $$O(n)$$ for n words.\\n\\n- Space complexity:\\n $$O(n)$$ for n words.\\n\\n# Code\\n```\\nfrom collections import defaultdict\\n\\nclass Solution(object):\\n    def similarPairs(self, words):\\n        count = defaultdict(int)\\n        ans = 0\\n        for w in words:\\n            key = \\' \\'.join(sorted(set(w)))\\n            ans += count[key]\\n            count[key] += 1\\n        return ans\\n```\\n\\nBonus one liner:\\n```\\nfrom collections import Counter\\n\\nclass Solution(object):\\n    def similarPairs(self, words):\\n        return sum([k * (k-1) / 2 for k in Counter([\\' \\'.join(sorted(set(w))) for w in words]).values()])\\n```           \\n",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nfrom collections import defaultdict\\n\\nclass Solution(object):\\n    def similarPairs(self, words):\\n        count = defaultdict(int)\\n        ans = 0\\n        for w in words:\\n            key = \\' \\'.join(sorted(set(w)))\\n            ans += count[key]\\n            count[key] += 1\\n        return ans\\n```\n```\\nfrom collections import Counter\\n\\nclass Solution(object):\\n    def similarPairs(self, words):\\n        return sum([k * (k-1) / 2 for k in Counter([\\' \\'.join(sorted(set(w))) for w in words]).values()])\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3162221,
                "title": "python-3-1-5-lines-tuple-and-counter-w-explanation-t-m-61-ms-13-9-mb",
                "content": "```\\nclass Solution:\\n    def similarPairs(self, words: List[str]) -> int:\\n\\n        words = [set   (w) for w in words]          # <\\u2013\\u2013 map each word to its letter-set\\n        words = [sorted(w) for w in words]          # <\\u2013\\u2013 map each letter-set to its sorted list\\n        words = [tuple (w) for w in words]          # <\\u2013\\u2013 map each list to a tuple to facilitate\\n                                                    #     the use of `Counter`.\\n\\n        c     = Counter(words)\\n        \\n        return  sum(n*(n-1) for n in c.values())//2 # <\\u2013\\u2013 count the piars of similar strings\\n```\\nThe one-liner:\\n```\\nclass Solution:\\n    def similarPairs(self, words: List[str]) -> int:\\n\\n        return  sum(n*(n-1) for n in Counter([tuple(sorted(set(w)))\\n                    for w in words]).values())//2\\n```\\n\\n[https://leetcode.com/problems/count-pairs-of-similar-strings/submissions/861730499/](http://)\\n\\nI could be wrong, but I think that time is *O*(*N*) and space is *O*(*N*).",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def similarPairs(self, words: List[str]) -> int:\\n\\n        words = [set   (w) for w in words]          # <\\u2013\\u2013 map each word to its letter-set\\n        words = [sorted(w) for w in words]          # <\\u2013\\u2013 map each letter-set to its sorted list\\n        words = [tuple (w) for w in words]          # <\\u2013\\u2013 map each list to a tuple to facilitate\\n                                                    #     the use of `Counter`.\\n\\n        c     = Counter(words)\\n        \\n        return  sum(n*(n-1) for n in c.values())//2 # <\\u2013\\u2013 count the piars of similar strings\\n```\n```\\nclass Solution:\\n    def similarPairs(self, words: List[str]) -> int:\\n\\n        return  sum(n*(n-1) for n in Counter([tuple(sorted(set(w)))\\n                    for w in words]).values())//2\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2923657,
                "title": "javascript-solution",
                "content": "\\n# Code\\n```\\n/**\\n * @param {string[]} words\\n * @return {number}\\n */\\nvar similarPairs = function(words) {\\n  let count = 0;\\n  for (let i = 0; i < words.length; i++) {\\n    for (let j = i + 1; j < words.length; j++) {\\n      if (sameCharacters(words[i], words[j]) && i !== j) {\\n        count++;\\n      }\\n    }\\n  }\\n\\n  return count;\\n};\\n\\nconst sameCharacters = function (wordOne, wordTwo) {\\n  const set1 = new Set(wordOne);\\n  const set2 = new Set(wordTwo);\\n  if (set1.size !== set2.size) {\\n    return false;\\n  }\\n\\n  return [...set1].every((i) => set2.has(i));\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {string[]} words\\n * @return {number}\\n */\\nvar similarPairs = function(words) {\\n  let count = 0;\\n  for (let i = 0; i < words.length; i++) {\\n    for (let j = i + 1; j < words.length; j++) {\\n      if (sameCharacters(words[i], words[j]) && i !== j) {\\n        count++;\\n      }\\n    }\\n  }\\n\\n  return count;\\n};\\n\\nconst sameCharacters = function (wordOne, wordTwo) {\\n  const set1 = new Set(wordOne);\\n  const set2 = new Set(wordTwo);\\n  if (set1.size !== set2.size) {\\n    return false;\\n  }\\n\\n  return [...set1].every((i) => set2.has(i));\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2923475,
                "title": "java-bitmask-and-counting",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nFilter each char in word and compare to others.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nConvert word to integer with bit mask, then use map to collect the count of each integer.\\n\\n# Complexity\\n- Time complexity: $$O(M*N)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(N)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n  public int similarPairs(String[] words) {\\n    Map<Integer, Integer> group = new HashMap<>();\\n    for (String word : words) {\\n      group.merge(convert(word), 1, Integer::sum);\\n    }\\n\\n    int count = 0;\\n    for (int value : group.values()) {\\n      count += value * (value - 1) / 2;\\n    }\\n\\n    return count;\\n  }\\n\\n  private int convert(String word) {\\n    int n = 0;\\n    for (char c : word.toCharArray()) {\\n      n |= 1 << (c - \\'a\\');\\n    }\\n\\n    return n;\\n  }\\n}\\n\\n```",
                "solutionTags": [
                    "Java",
                    "Bit Manipulation",
                    "Counting"
                ],
                "code": "```\\nclass Solution {\\n  public int similarPairs(String[] words) {\\n    Map<Integer, Integer> group = new HashMap<>();\\n    for (String word : words) {\\n      group.merge(convert(word), 1, Integer::sum);\\n    }\\n\\n    int count = 0;\\n    for (int value : group.values()) {\\n      count += value * (value - 1) / 2;\\n    }\\n\\n    return count;\\n  }\\n\\n  private int convert(String word) {\\n    int n = 0;\\n    for (char c : word.toCharArray()) {\\n      n |= 1 << (c - \\'a\\');\\n    }\\n\\n    return n;\\n  }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2923595,
                "title": "c-hashing-easy-solution",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int similarPairs(vector<string>& words) {\\n        map<set<int> , int> mp;\\n        for(auto s:words){\\n            set<int> st;\\n            for(char c:s){\\n                st.insert(c);// it finds all the unique character in a string store it to set\\n            }\\n            \\n            mp[st]++;//above set is maped here \\n                     // i.e. counting number of string contain these unique characters \\n        }\\n        int res=0;\\n        for(auto p:mp){\\n            if(p.second>1){\\n                int n=p.second;\\n                res = res + (n*(n-1))/2; // here just counting number of pair possible (it\\'s simple mathematics)\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int similarPairs(vector<string>& words) {\\n        map<set<int> , int> mp;\\n        for(auto s:words){\\n            set<int> st;\\n            for(char c:s){\\n                st.insert(c);// it finds all the unique character in a string store it to set\\n            }\\n            \\n            mp[st]++;//above set is maped here \\n                     // i.e. counting number of string contain these unique characters \\n        }\\n        int res=0;\\n        for(auto p:mp){\\n            if(p.second>1){\\n                int n=p.second;\\n                res = res + (n*(n-1))/2; // here just counting number of pair possible (it\\'s simple mathematics)\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3830270,
                "title": "python-3-dictionary-key-is-tuple-of-sorted-set-beats-100-51ms",
                "content": "```python3 []\\nclass Solution:\\n    def similarPairs(self, words: List[str]) -> int:\\n        d = defaultdict(int)\\n        for n in words:\\n            d[tuple(sorted(set(n)))] += 1\\n\\n        return sum(v * (v-1) // 2 for v in d.values())\\n```\\n![Screenshot 2023-07-28 at 21.01.45.png](https://assets.leetcode.com/users/images/fefd5433-38d2-4053-bf75-8be47f7a176f_1690567432.924887.png)\\n",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Hash Table",
                    "Sort",
                    "Ordered Set"
                ],
                "code": "```python3 []\\nclass Solution:\\n    def similarPairs(self, words: List[str]) -> int:\\n        d = defaultdict(int)\\n        for n in words:\\n            d[tuple(sorted(set(n)))] += 1\\n\\n        return sum(v * (v-1) // 2 for v in d.values())\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3441077,
                "title": "smartest-way-with-java-beats-77-75",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\n    public int similarPairs(String[] words) {\\n        int pairs = 0;\\n        Map<Set<Character>, Integer> list = new HashMap<>();\\n        for(String a: words){\\n            Set<Character> newSet = new HashSet<>();\\n            for(int b = 0; b < a.length(); b++){\\n                newSet.add(a.charAt(b));\\n            }\\n            if(list.containsKey(newSet)) list.put(newSet, list.get(newSet)+1);\\n            else list.put(newSet, 1);\\n        }\\n        for(Map.Entry<Set<Character>, Integer> entry: list.entrySet()){\\n            int val = entry.getValue();\\n            pairs += (val*(val-1))/2;\\n        }\\n        return pairs;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int similarPairs(String[] words) {\\n        int pairs = 0;\\n        Map<Set<Character>, Integer> list = new HashMap<>();\\n        for(String a: words){\\n            Set<Character> newSet = new HashSet<>();\\n            for(int b = 0; b < a.length(); b++){\\n                newSet.add(a.charAt(b));\\n            }\\n            if(list.containsKey(newSet)) list.put(newSet, list.get(newSet)+1);\\n            else list.put(newSet, 1);\\n        }\\n        for(Map.Entry<Set<Character>, Integer> entry: list.entrySet()){\\n            int val = entry.getValue();\\n            pairs += (val*(val-1))/2;\\n        }\\n        return pairs;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3229626,
                "title": "c-100-testcase-passed",
                "content": "# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int similarPairs(vector<string>& words) {\\n        for(int i=0; i<words.size(); i++){\\n            map<char, bool> mp;\\n            \\n            // push it to the map and remove duplicates character\\n            for(auto j: words[i]) mp[j] = 1;\\n            string temp;\\n\\n            // covert the map into string\\n            for(auto j: mp) temp.push_back(j.first);\\n            \\n            words[i] = temp;\\n        }\\n\\n        // count the repeated string in the array\\n        map<string, int> mp;\\n        for(auto i: words) mp[i]++;\\n        \\n        // calclute the possible combination\\n        int count = 0;\\n        for(auto i: mp){\\n            int x=(i.second-1)*(i.second)/2;\\n            count+=x;\\n        }\\n\\n        // returning the count\\n        return count;\\n        \\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Hash Table",
                    "String",
                    "Ordered Map"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int similarPairs(vector<string>& words) {\\n        for(int i=0; i<words.size(); i++){\\n            map<char, bool> mp;\\n            \\n            // push it to the map and remove duplicates character\\n            for(auto j: words[i]) mp[j] = 1;\\n            string temp;\\n\\n            // covert the map into string\\n            for(auto j: mp) temp.push_back(j.first);\\n            \\n            words[i] = temp;\\n        }\\n\\n        // count the repeated string in the array\\n        map<string, int> mp;\\n        for(auto i: words) mp[i]++;\\n        \\n        // calclute the possible combination\\n        int count = 0;\\n        for(auto i: mp){\\n            int x=(i.second-1)*(i.second)/2;\\n            count+=x;\\n        }\\n\\n        // returning the count\\n        return count;\\n        \\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2965945,
                "title": "java-94-time-93-memory-solution",
                "content": "# Approach\\n1. For each word I find whether a letter occured at least once. Then I make a key out of alphabet num array by composing String.\\n2. Then I count how many times the key occured.\\n3. Finally, I use arithmetic progression to count pairs for each key.\\n\\n# Code\\n```\\nclass Solution {\\n    public int similarPairs(String[] words) {\\n        int len = words.length;\\n        if (len == 1) return 0;\\n        byte[][] alph = new byte[len][26];\\n        Map<String, Integer> map = new HashMap<>();\\n        for (int i = 0; i < len; i++) {\\n            String word = words[i];\\n            for (char c : word.toCharArray()) {\\n                int idx = c - \\'a\\';\\n                if (alph[i][idx] == 0) alph[i][idx]++;\\n            }\\n            String s = new String(alph[i]);\\n            if (map.containsKey(s)) {\\n                map.put(s, map.get(s) + 1);\\n            } else {\\n                map.put(s, 1);\\n            }\\n        }\\n        int pairs = 0;\\n        //I use arithmetic progression here\\n        for (String key : map.keySet()) {\\n            int freq = map.get(key);\\n            if (freq > 1) {\\n                pairs += (freq * (freq - 1)) / 2;\\n            }\\n        }\\n        return pairs;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int similarPairs(String[] words) {\\n        int len = words.length;\\n        if (len == 1) return 0;\\n        byte[][] alph = new byte[len][26];\\n        Map<String, Integer> map = new HashMap<>();\\n        for (int i = 0; i < len; i++) {\\n            String word = words[i];\\n            for (char c : word.toCharArray()) {\\n                int idx = c - \\'a\\';\\n                if (alph[i][idx] == 0) alph[i][idx]++;\\n            }\\n            String s = new String(alph[i]);\\n            if (map.containsKey(s)) {\\n                map.put(s, map.get(s) + 1);\\n            } else {\\n                map.put(s, 1);\\n            }\\n        }\\n        int pairs = 0;\\n        //I use arithmetic progression here\\n        for (String key : map.keySet()) {\\n            int freq = map.get(key);\\n            if (freq > 1) {\\n                pairs += (freq * (freq - 1)) / 2;\\n            }\\n        }\\n        return pairs;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2933762,
                "title": "javascript-set-and-brute-force",
                "content": "```\\n/**\\n * @param {string[]} words\\n * @return {number}\\n */\\nvar similarPairs = function(words) {\\n    const dist = words.map((word)=>{\\n        return [...new Set(word)].sort().join(\\'\\')\\n    })   \\n    let sum = 0\\n    const n = dist.length\\n\\t\\n    for (let i = 0; i < n; i++) {\\n        for (let j = i + 1; j < n; j++) {\\n            if (dist[i] === dist[j]) sum++\\n        }\\n    }\\n    \\n    return sum\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {string[]} words\\n * @return {number}\\n */\\nvar similarPairs = function(words) {\\n    const dist = words.map((word)=>{\\n        return [...new Set(word)].sort().join(\\'\\')\\n    })   \\n    let sum = 0\\n    const n = dist.length\\n\\t\\n    for (let i = 0; i < n; i++) {\\n        for (let j = i + 1; j < n; j++) {\\n            if (dist[i] === dist[j]) sum++\\n        }\\n    }\\n    \\n    return sum\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2931210,
                "title": "simple-java-solution-using-hashset-array",
                "content": "# 1. Using hashset (Slow 73ms)\\n## Approach\\n<!-- Describe your approach to solving the problem. -->\\nWe are using a hashSet to store the characters of each string and use equals() method to check if size of both the sets are equal and both contain the same elements.\\n\\n## Complexity\\n- Time complexity: $$O(n*n*k)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n*k)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nn is the length of array and k is the number of unique characters of word in array\\n\\n## Code\\n```Java []\\nclass Solution {\\n    public int similarPairs(String[] words) {\\n        int res=0;\\n        Set<Character> sets[] = new Set[words.length];\\n        for(int i=0; i<words.length; ++i){\\n            sets[i] = new HashSet<>();\\n            for(char ch: words[i].toCharArray())    sets[i].add(ch);\\n        }\\n        for(int i=0; i<words.length; ++i){\\n            for(int j=i+1; j<words.length; ++j){\\n                if(sets[i].equals(sets[j]))    res+=1;\\n            }\\n        }\\n        return res;\\n    }\\n}\\n```\\n\\n# 2. Using array to mark visible (Fast 10ms)\\n## Approach\\n<!-- Describe your approach to solving the problem. -->\\nWe are using a Boolean Arrays to mark the presence of characters of each string and use Arrays equals() method to check if both arrays contain the same elements.\\n\\n## Complexity\\n- Time complexity: $$O(n*n*26)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n*26)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nn is the length of array\\n\\n## Code\\n```Java []\\nclass Solution {\\n    boolean[][] arr;\\n    public int similarPairs(String[] words) {\\n        int res=0;\\n        arr = new boolean[words.length][26];\\n        for(int i=0; i<words.length; ++i){\\n            for(char ch: words[i].toCharArray())    arr[i][ch-\\'a\\']=true;\\n        }\\n        for(int i=0; i<words.length; ++i){\\n            for(int j=i+1; j<words.length; ++j){\\n                if(Arrays.equals(arr[i],arr[j]))    res+=1;\\n            }\\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Hash Table"
                ],
                "code": "```Java []\\nclass Solution {\\n    public int similarPairs(String[] words) {\\n        int res=0;\\n        Set<Character> sets[] = new Set[words.length];\\n        for(int i=0; i<words.length; ++i){\\n            sets[i] = new HashSet<>();\\n            for(char ch: words[i].toCharArray())    sets[i].add(ch);\\n        }\\n        for(int i=0; i<words.length; ++i){\\n            for(int j=i+1; j<words.length; ++j){\\n                if(sets[i].equals(sets[j]))    res+=1;\\n            }\\n        }\\n        return res;\\n    }\\n}\\n```\n```Java []\\nclass Solution {\\n    boolean[][] arr;\\n    public int similarPairs(String[] words) {\\n        int res=0;\\n        arr = new boolean[words.length][26];\\n        for(int i=0; i<words.length; ++i){\\n            for(char ch: words[i].toCharArray())    arr[i][ch-\\'a\\']=true;\\n        }\\n        for(int i=0; i<words.length; ++i){\\n            for(int j=i+1; j<words.length; ++j){\\n                if(Arrays.equals(arr[i],arr[j]))    res+=1;\\n            }\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2925408,
                "title": "c-linq",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nWe can turn similarity into equality: two words A and B are similar if f(A) equals to f(B) where f takes distinct characters from the word and sorts them:\\n\\nf(abracadabra) => abcdr\\n\\nthen we can group by similar words and perform a simple arithmetics\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nLinq query\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n`O(n * length(word))`\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n`O(n)`\\n\\n# Code\\n```\\npublic class Solution {\\n    public int SimilarPairs(string[] words) => words\\n        .GroupBy(word => string.Concat(word.Distinct().OrderBy(c => c)))\\n        .Sum(group => (group.Count() - 1) * group.Count() / 2);    \\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution {\\n    public int SimilarPairs(string[] words) => words\\n        .GroupBy(word => string.Concat(word.Distinct().OrderBy(c => c)))\\n        .Sum(group => (group.Count() - 1) * group.Count() / 2);    \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2924842,
                "title": "javascript-bitmasks-hashmap",
                "content": "**Solution: Bitmasks & Hashmap**\\n\\nSince there are only 26 lowercase characters, we can keep track of each word\\'s unique characters in a bitmask.\\nUse a hashmap to count the number of occurances of each bitmask.\\nFrom the occurances of each bitmask, we can find the number of similar pairs.\\n\\n`n = number of words`, `m = max(words[i].length)`\\nTime Complexity: `O(nm)` 105ms\\nSpace Complexity: `O(n)` 44.9MB\\n```\\nvar similarPairs = function(words) {\\n  let count = new Map(), ans = 0;\\n  for (let word of words) {\\n    let mask = getMask(word);\\n    let occurances = count.get(mask) || 0;\\n    ans += occurances;\\n    count.set(mask, occurances + 1);\\n  }\\n  return ans;\\n};\\n\\nfunction getMask(word) {\\n  let mask = 0;\\n  for (let i = 0; i < word.length; i++) {\\n    let charcode = word[i].charCodeAt() - 97;\\n    mask |= (1 << charcode);\\n  }\\n  return mask;\\n}\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar similarPairs = function(words) {\\n  let count = new Map(), ans = 0;\\n  for (let word of words) {\\n    let mask = getMask(word);\\n    let occurances = count.get(mask) || 0;\\n    ans += occurances;\\n    count.set(mask, occurances + 1);\\n  }\\n  return ans;\\n};\\n\\nfunction getMask(word) {\\n  let mask = 0;\\n  for (let i = 0; i < word.length; i++) {\\n    let charcode = word[i].charCodeAt() - 97;\\n    mask |= (1 << charcode);\\n  }\\n  return mask;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2923666,
                "title": "java-brute-force-using-set-array",
                "content": "# Please Upvote :D\\n---\\n##### 1. Using hashset (Slow):\\n``` java []\\nclass Solution {\\n    public int similarPairs(String[] words) {\\n        int n = words.length, count = 0;\\n        Set<Character> set1, set2;\\n\\n        for (int i = 0; i < n - 1; i++) {\\n            set1 = new HashSet<>();\\n            for (char c : words[i].toCharArray()) {\\n                set1.add(c);\\n            }\\n            for (int j = i + 1; j < n; j++) {\\n                set2 = new HashSet<>();\\n                for (char c : words[j].toCharArray()) {\\n                    set2.add(c);\\n                }\\n                if (set1.equals(set2)) count++;\\n            }\\n        }\\n\\n        return count;\\n    }\\n}\\n\\n\\n// TC: O(n^2 * k)\\n// n is the length of array and k is the length of word in array\\n\\n// SC: O(k)\\n```\\n---\\n##### 2. Using array to mark presence (faster):\\n``` java []\\nclass Solution {\\n    public int similarPairs(String[] words) {\\n        int n = words.length, count = 0;\\n        int[] a1, a2;\\n        Set<Character> set1, set2;\\n\\n        for (int i = 0; i < n - 1; i++) {\\n            a1 = new int[26];\\n            for (char c : words[i].toCharArray()) {\\n                a1[c - \\'a\\'] = 1;\\n            }\\n\\n            for (int j = i + 1; j < n; j++) {\\n                a2 = new int[26];\\n                for (char c : words[j].toCharArray()) {\\n                    a2[c - \\'a\\'] = 1;\\n                }\\n\\n                if (Arrays.equals(a1, a2)) {\\n                    count++;\\n                }\\n            }\\n        }\\n\\n        return count;\\n    }\\n}\\n\\n// TC: O(n^2 * k)\\n// n is the length of array and k is the length of word in array\\n\\n// SC: O(1)",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Hash Table"
                ],
                "code": "``` java []\\nclass Solution {\\n    public int similarPairs(String[] words) {\\n        int n = words.length, count = 0;\\n        Set<Character> set1, set2;\\n\\n        for (int i = 0; i < n - 1; i++) {\\n            set1 = new HashSet<>();\\n            for (char c : words[i].toCharArray()) {\\n                set1.add(c);\\n            }\\n            for (int j = i + 1; j < n; j++) {\\n                set2 = new HashSet<>();\\n                for (char c : words[j].toCharArray()) {\\n                    set2.add(c);\\n                }\\n                if (set1.equals(set2)) count++;\\n            }\\n        }\\n\\n        return count;\\n    }\\n}\\n\\n\\n// TC: O(n^2 * k)\\n// n is the length of array and k is the length of word in array\\n\\n// SC: O(k)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2923648,
                "title": "c-using-map",
                "content": "```\\nclass Solution {\\npublic:\\n    int similarPairs(vector<string>& words) {\\n        int ans = 0, n = words.size();\\n        for(int i = 0; i < n - 1; ++i) {\\n            // use a map to count frequency of the current word\\n            unordered_map<char, int> mp1;\\n            for(char &c : words[i]) \\n                mp1[c] = 1;\\n            for(int j = i + 1; j < n; ++j) {\\n                // use this map to compare\\n                unordered_map<char, int> mp2;\\n                for(char &c : words[j]) mp2[c] = 1;\\n                // if same \\n                if(mp1 == mp2) \\n                    ans++;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```\\n\\nThanks a lot for reading! ^_^\\n\\uD83D\\uDCAF An upvote would be appreciated.\\n\\uD83D\\uDC47 Comment down your doubts (if any).",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int similarPairs(vector<string>& words) {\\n        int ans = 0, n = words.size();\\n        for(int i = 0; i < n - 1; ++i) {\\n            // use a map to count frequency of the current word\\n            unordered_map<char, int> mp1;\\n            for(char &c : words[i]) \\n                mp1[c] = 1;\\n            for(int j = i + 1; j < n; ++j) {\\n                // use this map to compare\\n                unordered_map<char, int> mp2;\\n                for(char &c : words[j]) mp2[c] = 1;\\n                // if same \\n                if(mp1 == mp2) \\n                    ans++;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3982020,
                "title": "easy-java-solution",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\n    public int similarPairs(String[] words) {\\n        int count=0;\\n        for(int i=0;i<words.length-1;i++)\\n        {\\n            for(int j=i+1;j<words.length;j++)\\n            {\\n                count+=check(words[i],words[j]);\\n            }\\n        }\\n        return count;\\n    }\\n\\n    private int check(String a,String b)\\n    {\\n        HashSet<Character> aset=new HashSet();\\n        for(char ch:a.toCharArray())\\n            aset.add(ch);\\n\\n        HashSet<Character> bset=new HashSet();\\n        for(char ch:b.toCharArray())\\n            bset.add(ch);\\n        return aset.equals(bset)?1:0;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int similarPairs(String[] words) {\\n        int count=0;\\n        for(int i=0;i<words.length-1;i++)\\n        {\\n            for(int j=i+1;j<words.length;j++)\\n            {\\n                count+=check(words[i],words[j]);\\n            }\\n        }\\n        return count;\\n    }\\n\\n    private int check(String a,String b)\\n    {\\n        HashSet<Character> aset=new HashSet();\\n        for(char ch:a.toCharArray())\\n            aset.add(ch);\\n\\n        HashSet<Character> bset=new HashSet();\\n        for(char ch:b.toCharArray())\\n            bset.add(ch);\\n        return aset.equals(bset)?1:0;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3570876,
                "title": "java-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int similarPairs(String[] words) {\\n        int count = 0;\\n        for(int i = 0; i < words.length; ++i){\\n            String word1 = words[i];\\n            int[] f1 = new int[26]; //frequency array 1\\n            \\n            for(int a = 0; a < word1.length(); ++a){ //making frequency array for word1\\n                char ch = word1.charAt(a);\\n                f1[ch - \\'a\\']++;\\n            }\\n            \\n            for(int j = i + 1; j < words.length; ++j){\\n                String word2 = words[j];\\n                int[] f2 = new int[26]; //frequency array 2\\n    \\n                for(int b = 0; b < word2.length(); ++b){ //making frequency array for word2\\n                    char ch = word2.charAt(b);\\n                    f2[ch - \\'a\\']++;\\n                }\\n                \\n                boolean flag = true;\\n                for(int k = 0; k < 26; ++k){\\n                    if((f1[k] > 0 && f2[k] == 0) || (f1[k] == 0 && f2[k] > 0)){\\n                        flag = false;\\n                        break;\\n                    }\\n                }\\n                \\n                if(flag) count++;\\n            }\\n        }\\n        \\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int similarPairs(String[] words) {\\n        int count = 0;\\n        for(int i = 0; i < words.length; ++i){\\n            String word1 = words[i];\\n            int[] f1 = new int[26]; //frequency array 1\\n            \\n            for(int a = 0; a < word1.length(); ++a){ //making frequency array for word1\\n                char ch = word1.charAt(a);\\n                f1[ch - \\'a\\']++;\\n            }\\n            \\n            for(int j = i + 1; j < words.length; ++j){\\n                String word2 = words[j];\\n                int[] f2 = new int[26]; //frequency array 2\\n    \\n                for(int b = 0; b < word2.length(); ++b){ //making frequency array for word2\\n                    char ch = word2.charAt(b);\\n                    f2[ch - \\'a\\']++;\\n                }\\n                \\n                boolean flag = true;\\n                for(int k = 0; k < 26; ++k){\\n                    if((f1[k] > 0 && f2[k] == 0) || (f1[k] == 0 && f2[k] > 0)){\\n                        flag = false;\\n                        break;\\n                    }\\n                }\\n                \\n                if(flag) count++;\\n            }\\n        }\\n        \\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3558137,
                "title": "easy-cpp-intuitive-approach",
                "content": "# **If helpful pls upvote me \\uD83E\\uDD79**\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int similarPairs(vector<string>& words) {\\n        int count = 0;\\n        \\n        for(int i = 0; i<words.size(); i++){\\n            unordered_set<char>myset;\\n            string temp = words[i];\\n            for(auto &t: temp){\\n                myset.insert(t);\\n            }\\n            \\n            for(int j = i+1; j<words.size(); j++){\\n                unordered_set<char>set2;\\n                string s = words[j];\\n                for(auto &t: s){\\n                    set2.insert(t);\\n                }\\n                if(myset.size() == set2.size() && myset == set2){\\n                    count += 1;\\n                }\\n            }\\n        }\\n        \\n        return count;   \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int similarPairs(vector<string>& words) {\\n        int count = 0;\\n        \\n        for(int i = 0; i<words.size(); i++){\\n            unordered_set<char>myset;\\n            string temp = words[i];\\n            for(auto &t: temp){\\n                myset.insert(t);\\n            }\\n            \\n            for(int j = i+1; j<words.size(); j++){\\n                unordered_set<char>set2;\\n                string s = words[j];\\n                for(auto &t: s){\\n                    set2.insert(t);\\n                }\\n                if(myset.size() == set2.size() && myset == set2){\\n                    count += 1;\\n                }\\n            }\\n        }\\n        \\n        return count;   \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3240855,
                "title": "java-easy-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int similarPairs(String[] words) {\\n        int n = words.length, \\n        count = 0;\\n        Set<Character> set1, set2;\\n\\n        for (int i = 0; i < n - 1; i++) {\\n            set1 = new HashSet<>();\\n            for (char c : words[i].toCharArray()) {\\n                set1.add(c);\\n            }\\n            for (int j = i + 1; j < n; j++) {\\n                set2 = new HashSet<>();\\n                for (char c : words[j].toCharArray()) {\\n                    set2.add(c);\\n                }\\n                if (set1.equals(set2)) \\n                count++;\\n            }\\n        }\\n\\n        return count;\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int similarPairs(String[] words) {\\n        int n = words.length, \\n        count = 0;\\n        Set<Character> set1, set2;\\n\\n        for (int i = 0; i < n - 1; i++) {\\n            set1 = new HashSet<>();\\n            for (char c : words[i].toCharArray()) {\\n                set1.add(c);\\n            }\\n            for (int j = i + 1; j < n; j++) {\\n                set2 = new HashSet<>();\\n                for (char c : words[j].toCharArray()) {\\n                    set2.add(c);\\n                }\\n                if (set1.equals(set2)) \\n                count++;\\n            }\\n        }\\n\\n        return count;\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3179507,
                "title": "one-linear-solution-object-values-filter-map-reduce",
                "content": "# Code\\n```\\n/**\\n * @param {string[]} words\\n * @return {number}\\n */\\nvar similarPairs = function(words) {\\n    return Object.values(\\n            words\\n                .map(str => Array.from(new Set(str)).sort().join(\\'\\'))\\n                .reduce((acc, str) => {\\n                    acc[str] = (acc[str] ?? 0) + 1;\\n                    return acc;\\n                }, {}),\\n        )\\n        .filter(count => count > 1)\\n        .map(count => count / 2 * (count - 1))\\n        .reduce((acc, pairs) => acc + pairs, 0);\\n};\\n\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {string[]} words\\n * @return {number}\\n */\\nvar similarPairs = function(words) {\\n    return Object.values(\\n            words\\n                .map(str => Array.from(new Set(str)).sort().join(\\'\\'))\\n                .reduce((acc, str) => {\\n                    acc[str] = (acc[str] ?? 0) + 1;\\n                    return acc;\\n                }, {}),\\n        )\\n        .filter(count => count > 1)\\n        .map(count => count / 2 * (count - 1))\\n        .reduce((acc, pairs) => acc + pairs, 0);\\n};\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3054871,
                "title": "python-easy-to-understand-code-accepted",
                "content": "# Approach\\nusing sets to check if two words in the array words contain same characters. \\n\\n# Complexity\\n- Time complexity:\\nsince a nested for is used, O(n^2)\\n\\n# Code\\n```\\nclass Solution:\\n    def similarPairs(self, words: List[str]) -> int:\\n        count = 0\\n        for i in range(len(words)):\\n            for j in range(i):\\n            #checking if 2 words has characters and then incrementing count\\n                if set(words[i]) == set(words[j]):\\n                    count += 1\\n        return count\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def similarPairs(self, words: List[str]) -> int:\\n        count = 0\\n        for i in range(len(words)):\\n            for j in range(i):\\n            #checking if 2 words has characters and then incrementing count\\n                if set(words[i]) == set(words[j]):\\n                    count += 1\\n        return count\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3013446,
                "title": "simple-solution-on-swift",
                "content": "# Code\\n```\\nclass Solution {\\n    func similarPairs(_ words: [String]) -> Int {\\n        var result = 0\\n        for i in 0..<words.count {\\n            for j in i+1..<words.count where Set(words[j]) == Set(words[i]) {\\n                result += 1\\n            }\\n        }\\n        return result\\n    }\\n}\\n```\\n### Please upvote if you found the solution useful!",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nclass Solution {\\n    func similarPairs(_ words: [String]) -> Int {\\n        var result = 0\\n        for i in 0..<words.count {\\n            for j in i+1..<words.count where Set(words[j]) == Set(words[i]) {\\n                result += 1\\n            }\\n        }\\n        return result\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2960119,
                "title": "100-0ms-faster-simple-easy",
                "content": "# upvote\\n\\n# Complexity\\n- Time complexity:O(n*n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int similarPairs(String[] W) {\\n        int c=0,L=W.length;\\n        for(int i=0;i<L;i++){\\n            int A[]=feed(W[i]);\\n            for(int j=i+1;j<L;j++){\\n                if(Arrays.equals(A,feed(W[j])))c++;\\n            }\\n        }\\n        return c;\\n    }\\n    private int[] feed(String d){\\n    int[] st=new int[26];\\n        for(char v:d.toCharArray()) st[v-\\'a\\']=1;\\n        return st;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution {\\n    public int similarPairs(String[] W) {\\n        int c=0,L=W.length;\\n        for(int i=0;i<L;i++){\\n            int A[]=feed(W[i]);\\n            for(int j=i+1;j<L;j++){\\n                if(Arrays.equals(A,feed(W[j])))c++;\\n            }\\n        }\\n        return c;\\n    }\\n    private int[] feed(String d){\\n    int[] st=new int[26];\\n        for(char v:d.toCharArray()) st[v-\\'a\\']=1;\\n        return st;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2929755,
                "title": "c-most-easy-solution-with-explanation",
                "content": "# We use set for storing unique characters present in string.We can see that for the value (meaning it.second in code)of 2 there will be 1 pair similarly for 3 it can form 3 pairs for 4 it can form 6 pairs therefore ffor any value n it can form (n*(n-1))/2.\\n```\\nclass Solution {\\npublic:\\n    int similarPairs(vector<string>& words) {\\n        map<set<char>,int> mp;\\n        for(string s:words)\\n        {\\n            set<char> s1;\\n            for(char c:s)\\n            s1.insert(c);\\n            mp[s1]++;\\n        }\\n        int cnt=0;\\n        for(auto it:mp)\\n        {\\n            if(it.second>=2)\\n            {\\n                int x=it.second;\\n                cnt+=(x*(x-1))/2;\\n            }\\n        }\\n        return cnt;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Ordered Set"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int similarPairs(vector<string>& words) {\\n        map<set<char>,int> mp;\\n        for(string s:words)\\n        {\\n            set<char> s1;\\n            for(char c:s)\\n            s1.insert(c);\\n            mp[s1]++;\\n        }\\n        int cnt=0;\\n        for(auto it:mp)\\n        {\\n            if(it.second>=2)\\n            {\\n                int x=it.second;\\n                cnt+=(x*(x-1))/2;\\n            }\\n        }\\n        return cnt;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2925191,
                "title": "java-o-n-solution-using-bitmask",
                "content": "# Approach\\n1. Iteratre through each word, set the bit corresponding to the index. \\n2. Count number of occurences of each bitmask by storing in a map with the bitmask as the key and count as the value. \\n3. Finally calculate the number of pairs from the count using the A.P formula \\n\\nCalculating the number of pairs from the count\\n$$pairs = (count * (count-1))/2$$\\n\\n# Complexity\\n- Time complexity: $$O(n)$$\\n\\n- Space complexity: $$O(n)$$\\n\\n# Code\\n```\\nclass Solution {\\n    public int similarPairs(String[] words) {\\n        var map = new HashMap<Integer, Integer>();\\n        for (var word : words) {\\n            int bitset = 0;\\n            for (int i=0; i<word.length(); i++) {\\n                int index = word.charAt(i)-\\'a\\';\\n                bitset |= (1 << index);\\n            }\\n            map.put(bitset, map.getOrDefault(bitset, 0) + 1);\\n        }\\n        \\n        int pairs = 0;\\n        for (var entry: map.entrySet()) {\\n            var count = entry.getValue();\\n            if (count <= 1) continue;\\n            pairs += (count * (count-1)) / 2;\\n        }\\n        return pairs;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Bitmask"
                ],
                "code": "```\\nclass Solution {\\n    public int similarPairs(String[] words) {\\n        var map = new HashMap<Integer, Integer>();\\n        for (var word : words) {\\n            int bitset = 0;\\n            for (int i=0; i<word.length(); i++) {\\n                int index = word.charAt(i)-\\'a\\';\\n                bitset |= (1 << index);\\n            }\\n            map.put(bitset, map.getOrDefault(bitset, 0) + 1);\\n        }\\n        \\n        int pairs = 0;\\n        for (var entry: map.entrySet()) {\\n            var count = entry.getValue();\\n            if (count <= 1) continue;\\n            pairs += (count * (count-1)) / 2;\\n        }\\n        return pairs;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2925070,
                "title": "my-solution-java",
                "content": "Time Complexity: O(N^2)\\nSpace Complexity: O(N)\\n\\n# Code\\n```\\nclass Solution {\\n    public int similarPairs(String[] words) {\\n        \\n       int out=0;\\n        \\n       for(int i=0;i<words.length;i++){\\n           TreeSet<Character> hs=new TreeSet<>();   \\n           String s=\"\";\\n           for(char c:words[i].toCharArray())\\n                hs.add(c);\\n           for(char c:hs)\\n               s+=String.valueOf(c);\\n                \\n           words[i]=s;\\n       }\\n       \\n        for(int i=0;i<words.length-1;i++){\\n       \\n            for(int j=i+1;j<words.length;j++)\\n               if(words[i].equals(words[j]))\\n                    out++;\\n            \\n           \\n        }\\n        return out;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int similarPairs(String[] words) {\\n        \\n       int out=0;\\n        \\n       for(int i=0;i<words.length;i++){\\n           TreeSet<Character> hs=new TreeSet<>();   \\n           String s=\"\";\\n           for(char c:words[i].toCharArray())\\n                hs.add(c);\\n           for(char c:hs)\\n               s+=String.valueOf(c);\\n                \\n           words[i]=s;\\n       }\\n       \\n        for(int i=0;i<words.length-1;i++){\\n       \\n            for(int j=i+1;j<words.length;j++)\\n               if(words[i].equals(words[j]))\\n                    out++;\\n            \\n           \\n        }\\n        return out;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2924581,
                "title": "c-easy-to-understand-used-formula-to-count-no-of-pairs",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int similarPairs(vector<string>& words) {\\n        unordered_map<string, int> mp;\\n \\n        for(int i=0;i<words.size();i++){\\n            string s=words[i];\\n         sort(s.begin(),s.end());//sorted string\\n            string s1(1, s[0]);\\n            for(int i=1;i<s.size();i++){//removed dublicate characters in string\\n                if(s[i]!=s1[s1.size()-1])\\n                    s1+=s[i];\\n            }\\n            words[i]=s1;\\n            mp[s1]++;//counted the no of occurance\\n            \\n        }\\n    int cnt = 0;\\n     for(auto i:mp){// no of pairs that can be formed by n is n(n-1)/2\\n         int c= i.second;\\n         c=c*(c-1)/2;\\n         cnt+=c;\\n     }\\n    return cnt;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int similarPairs(vector<string>& words) {\\n        unordered_map<string, int> mp;\\n \\n        for(int i=0;i<words.size();i++){\\n            string s=words[i];\\n         sort(s.begin(),s.end());//sorted string\\n            string s1(1, s[0]);\\n            for(int i=1;i<s.size();i++){//removed dublicate characters in string\\n                if(s[i]!=s1[s1.size()-1])\\n                    s1+=s[i];\\n            }\\n            words[i]=s1;\\n            mp[s1]++;//counted the no of occurance\\n            \\n        }\\n    int cnt = 0;\\n     for(auto i:mp){// no of pairs that can be formed by n is n(n-1)/2\\n         int c= i.second;\\n         c=c*(c-1)/2;\\n         cnt+=c;\\n     }\\n    return cnt;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2924152,
                "title": "c-easy-solutions",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int similarPairs(vector<string>& words) {\\n        \\n        int n=words.size();\\n        int count=0;\\n       \\n        vector<string>save;\\n        \\n        for(int i=0;i<n;i++)\\n        {\\n              set<char>s;\\n            for(auto x:words[i])\\n            {\\n                s.insert(x);\\n            }\\n            \\n            string str=\"\";\\n            for(auto y:s)\\n            {\\n                str+=y;\\n            }\\n            \\n            save.push_back(str);\\n        }\\n        \\n        for(int i=0;i<n;i++)\\n        {\\n            for(int j=i+1;j<n;j++)\\n            {\\n                if(save[i]==save[j]){\\n                    count++;\\n                }\\n            }\\n        }\\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int similarPairs(vector<string>& words) {\\n        \\n        int n=words.size();\\n        int count=0;\\n       \\n        vector<string>save;\\n        \\n        for(int i=0;i<n;i++)\\n        {\\n              set<char>s;\\n            for(auto x:words[i])\\n            {\\n                s.insert(x);\\n            }\\n            \\n            string str=\"\";\\n            for(auto y:s)\\n            {\\n                str+=y;\\n            }\\n            \\n            save.push_back(str);\\n        }\\n        \\n        for(int i=0;i<n;i++)\\n        {\\n            for(int j=i+1;j<n;j++)\\n            {\\n                if(save[i]==save[j]){\\n                    count++;\\n                }\\n            }\\n        }\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2923900,
                "title": "python-3-count-distinct-pairs-and-adding-into-count-variable",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def similarPairs(self, words: List[str]) -> int:\\n\\n        d=Counter()\\n        count=0\\n        for current_word in words:\\n            word=\"\".join(sorted(set(current_word)))\\n            count+=d[word]\\n            d[word]+=1\\n\\n        return count    \\n\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def similarPairs(self, words: List[str]) -> int:\\n\\n        d=Counter()\\n        count=0\\n        for current_word in words:\\n            word=\"\".join(sorted(set(current_word)))\\n            count+=d[word]\\n            d[word]+=1\\n\\n        return count    \\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2923829,
                "title": "easy-c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int similarPairs(vector<string>& words) {\\n        vector<string> v;\\n        int ans = 0;\\n        for(int i =0 ; i<words.size() ; i++){\\n            string tmp = words[i];\\n            set<char> st;\\n            for(int j=0 ; j<tmp.size() ; j++){\\n                st.insert(tmp[j]);\\n            }\\n            string rec;\\n            for(auto it=st.begin() ; it!=st.end() ; it++){\\n                rec.push_back(*it);\\n            }\\n            v.push_back(rec);\\n        }\\n        for(int i=0 ; i<v.size()-1 ; i++){\\n            for(int j=i+1 ; j<v.size() ; j++){\\n                if(v[i]==v[j]) ans++;\\n            }  \\n        }\\n        return ans;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int similarPairs(vector<string>& words) {\\n        vector<string> v;\\n        int ans = 0;\\n        for(int i =0 ; i<words.size() ; i++){\\n            string tmp = words[i];\\n            set<char> st;\\n            for(int j=0 ; j<tmp.size() ; j++){\\n                st.insert(tmp[j]);\\n            }\\n            string rec;\\n            for(auto it=st.begin() ; it!=st.end() ; it++){\\n                rec.push_back(*it);\\n            }\\n            v.push_back(rec);\\n        }\\n        for(int i=0 ; i<v.size()-1 ; i++){\\n            for(int j=i+1 ; j<v.size() ; j++){\\n                if(v[i]==v[j]) ans++;\\n            }  \\n        }\\n        return ans;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2923732,
                "title": "hash-bit-mask",
                "content": "<!-- # Intuition -->\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n<!-- # Approach -->\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: *`O(n * l)`*\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: *`O(n)`*\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int similarPairs(vector<string>& words) {\\n        unordered_map<int, int> feq;\\n        for(string& word: words) {\\n            int bit = 0;\\n            for(char& ch: word)\\n                bit |= 1 << (ch - \\'a\\');\\n            feq[bit]++;\\n        }\\n        int pairs = 0;\\n        for(auto el: feq)\\n            pairs += (el.second - 1) * el.second / 2;\\n        return pairs;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Hash Table",
                    "String",
                    "Bitmask"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int similarPairs(vector<string>& words) {\\n        unordered_map<int, int> feq;\\n        for(string& word: words) {\\n            int bit = 0;\\n            for(char& ch: word)\\n                bit |= 1 << (ch - \\'a\\');\\n            feq[bit]++;\\n        }\\n        int pairs = 0;\\n        for(auto el: feq)\\n            pairs += (el.second - 1) * el.second / 2;\\n        return pairs;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2923710,
                "title": "c-set-map",
                "content": "```\\nclass Solution {\\npublic:\\n    int similarPairs(vector<string>& words) {\\n        map<set<char>,int> m;\\n        for(auto& itr : words){\\n            set<char> s;\\n            for(auto& i : itr){\\n                s.insert(i);\\n            }\\n            ++m[s];\\n        }\\n        int p=0;\\n        for(auto& itr : m){\\n            int t = itr.second;\\n            if(t>1){\\n                p += t*(t-1)/2;\\n            }\\n        }\\n        return p;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int similarPairs(vector<string>& words) {\\n        map<set<char>,int> m;\\n        for(auto& itr : words){\\n            set<char> s;\\n            for(auto& i : itr){\\n                s.insert(i);\\n            }\\n            ++m[s];\\n        }\\n        int p=0;\\n        for(auto& itr : m){\\n            int t = itr.second;\\n            if(t>1){\\n                p += t*(t-1)/2;\\n            }\\n        }\\n        return p;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2923680,
                "title": "python-o-nlogn",
                "content": "# Approach\\n- we can process each string in following manner:\\n    - convert string into list of characters.\\n    - convert it into set to get unique characters.\\n    - agin convert it into list and sort them.\\n    - now join all the characters to make string.\\n- In this way we will have all atrings with unique and sorted characters.\\n- Now we can make frequency dictionary of each string.\\n- apply the formula n*(n-1)/2 to get number of pairs formed by n same strings.\\n\\n\\n# Complexity\\n- Time complexity: O(nlogn)\\n\\n- Space complexity: O(n)\\n\\n# Code\\n```\\nclass Solution:\\n    def similarPairs(self, words: List[str]) -> int:\\n        words = [\"\".join(sorted(list(set(list(i))))) for i in words]\\n        d = {}\\n        for word in words:\\n            d[word] = d.get(word, 0)+1\\n        count = 0\\n        for k in d:\\n            count += ((d[k]*(d[k]-1))//2)\\n        return count\\n```\\n-------------------\\n- Upvote the post if you find it helpful.\\nHappy coding.",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def similarPairs(self, words: List[str]) -> int:\\n        words = [\"\".join(sorted(list(set(list(i))))) for i in words]\\n        d = {}\\n        for word in words:\\n            d[word] = d.get(word, 0)+1\\n        count = 0\\n        for k in d:\\n            count += ((d[k]*(d[k]-1))//2)\\n        return count\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2923590,
                "title": "java-easy-to-understand",
                "content": "# Code\\n```\\nclass Solution {\\n    public int similarPairs(String[] words) {\\n        HashMap<String, Integer> map = new HashMap();\\n        for(String str:words){\\n            Set<Character> set = new HashSet();\\n            for(int i = 0; i < str.length(); i++){\\n                char ch = str.charAt(i);\\n                set.add(ch);\\n            }\\n            String s = set.toString();\\n            map.putIfAbsent(s,0);\\n            map.put(s,map.get(s)+1);\\n        }\\n        int ans = 0;\\n        for(String s:map.keySet()){\\n            int items = map.get(s);\\n            ans += (items*(items-1))/2;\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int similarPairs(String[] words) {\\n        HashMap<String, Integer> map = new HashMap();\\n        for(String str:words){\\n            Set<Character> set = new HashSet();\\n            for(int i = 0; i < str.length(); i++){\\n                char ch = str.charAt(i);\\n                set.add(ch);\\n            }\\n            String s = set.toString();\\n            map.putIfAbsent(s,0);\\n            map.put(s,map.get(s)+1);\\n        }\\n        int ans = 0;\\n        for(String s:map.keySet()){\\n            int items = map.get(s);\\n            ans += (items*(items-1))/2;\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2923539,
                "title": "brute-force-c",
                "content": "# Intuition\\nBrute force comparing all pairs of strings\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool func(string &word1, string &word2)\\n    {\\n        vector<int>v(26, 0);\\n        for(int i=0;i<word1.size();i++)\\n        {\\n           v[word1[i]- \\'a\\']++;\\n        }\\n        for(int i=0;i<word2.size();i++)\\n        {\\n            int x = v[word2[i]-\\'a\\'];\\n            if(x == 0) return false;\\n        }\\n        return true;\\n    }\\n    int similarPairs(vector<string>& words) {\\n        sort(words.begin(), words.end());\\n        for(auto &i:words)\\n        {\\n            sort(i.begin(), i.end());\\n        }\\n        int n = words.size();\\n        int cnt = 0;\\n        for(int i=0;i<n;i++)\\n        {\\n            for(int j = i+1;j<n;j++)\\n               { \\n                if(func(words[i], words[j]) and func(words[j], words[i]))\\n                    cnt++;\\n               }\\n        }\\n        return cnt;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool func(string &word1, string &word2)\\n    {\\n        vector<int>v(26, 0);\\n        for(int i=0;i<word1.size();i++)\\n        {\\n           v[word1[i]- \\'a\\']++;\\n        }\\n        for(int i=0;i<word2.size();i++)\\n        {\\n            int x = v[word2[i]-\\'a\\'];\\n            if(x == 0) return false;\\n        }\\n        return true;\\n    }\\n    int similarPairs(vector<string>& words) {\\n        sort(words.begin(), words.end());\\n        for(auto &i:words)\\n        {\\n            sort(i.begin(), i.end());\\n        }\\n        int n = words.size();\\n        int cnt = 0;\\n        for(int i=0;i<n;i++)\\n        {\\n            for(int j = i+1;j<n;j++)\\n               { \\n                if(func(words[i], words[j]) and func(words[j], words[i]))\\n                    cnt++;\\n               }\\n        }\\n        return cnt;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2923502,
                "title": "swift-character-set-frequency-then-n-n-1-2",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nCharacter Set Frequency\\ncombination formulat: (N * (N-1)) / 2\\n(pair [1, 2] and [2, 1] are the same)\\n\\n# Code\\n```\\nclass Solution {\\n    func similarPairs(_ words: [String]) -> Int {\\n        var charSetFrequency = [Set<Character>: Int]()\\n        for word in words {\\n            charSetFrequency[countCharSet(word), default: 0] += 1\\n        }\\n        var pair = 0\\n        charSetFrequency.values\\n            .filter { $0 > 1 }\\n            .forEach {\\n                pair += ($0 * ($0-1)) / 2\\n            }\\n        return pair\\n    }\\n    \\n    func countCharSet(_ word: String) -> Set<Character> {\\n        var charSet = Set<Character>()\\n        word.forEach {\\n            charSet.insert($0)\\n        }\\n        return charSet\\n    }\\n}\\n```",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nclass Solution {\\n    func similarPairs(_ words: [String]) -> Int {\\n        var charSetFrequency = [Set<Character>: Int]()\\n        for word in words {\\n            charSetFrequency[countCharSet(word), default: 0] += 1\\n        }\\n        var pair = 0\\n        charSetFrequency.values\\n            .filter { $0 > 1 }\\n            .forEach {\\n                pair += ($0 * ($0-1)) / 2\\n            }\\n        return pair\\n    }\\n    \\n    func countCharSet(_ word: String) -> Set<Character> {\\n        var charSet = Set<Character>()\\n        word.forEach {\\n            charSet.insert($0)\\n        }\\n        return charSet\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4050318,
                "title": "easy-set-solution",
                "content": "# Intuition\\nSet stores all unique occurences\\n\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int similarPairs(vector<string>& words) {\\n        int count =0;\\n        for(int i=0;i<words.size();i++){\\n            unordered_set<char> st;\\n            for(auto w:words[i]){\\n                st.insert(w);\\n            }   \\n            for(int j=i+1;j<words.size();j++){\\n                bool flag = true;\\n                unordered_set<int> temp;\\n                for(auto w:words[j]){\\n                    temp.insert(w);\\n                    if(st.find(w) == st.end()){\\n                        flag = false;\\n                        break;\\n                    }\\n                }\\n                if(flag && temp.size() == st.size()) {\\n                    cout<<words[i]<<\"-->\"<<words[j]<<endl;\\n                    count++;\\n                }\\n            }  \\n        }\\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int similarPairs(vector<string>& words) {\\n        int count =0;\\n        for(int i=0;i<words.size();i++){\\n            unordered_set<char> st;\\n            for(auto w:words[i]){\\n                st.insert(w);\\n            }   \\n            for(int j=i+1;j<words.size();j++){\\n                bool flag = true;\\n                unordered_set<int> temp;\\n                for(auto w:words[j]){\\n                    temp.insert(w);\\n                    if(st.find(w) == st.end()){\\n                        flag = false;\\n                        break;\\n                    }\\n                }\\n                if(flag && temp.size() == st.size()) {\\n                    cout<<words[i]<<\"-->\"<<words[j]<<endl;\\n                    count++;\\n                }\\n            }  \\n        }\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3955498,
                "title": "o-n-solution-in-python-100-better",
                "content": "# Intuition\\n\\n# Approach\\n\\n# Complexity\\n- Time complexity:\\no(n)\\n\\n- Space complexity:\\no(n)\\n# Code\\n```\\nclass Solution(object):\\n    def similarPairs(self, words):\\n        \"\"\"\\n        :type words: List[str]\\n        :rtype: int\\n        \"\"\"\\n        my_map = {}\\n        for word in words:\\n         unique_chars = frozenset(word)\\n         if unique_chars in my_map:\\n          my_map[unique_chars] += 1\\n         else:\\n          my_map[unique_chars] = 1\\n        count=0\\n        for key,value in my_map.items():\\n            if value==1:\\n                continue\\n            while value!=0:\\n                count+=value-1\\n                value-=1\\n        return count\\n        \\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution(object):\\n    def similarPairs(self, words):\\n        \"\"\"\\n        :type words: List[str]\\n        :rtype: int\\n        \"\"\"\\n        my_map = {}\\n        for word in words:\\n         unique_chars = frozenset(word)\\n         if unique_chars in my_map:\\n          my_map[unique_chars] += 1\\n         else:\\n          my_map[unique_chars] = 1\\n        count=0\\n        for key,value in my_map.items():\\n            if value==1:\\n                continue\\n            while value!=0:\\n                count+=value-1\\n                value-=1\\n        return count\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3885395,
                "title": "count-pairs-of-similar-strings",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def similarPairs(self, words: List[str]) -> int:\\n        count = 0\\n        for i in range(len(words)):\\n            for j in range(i + 1, len(words)):\\n                if set(words[i]) == set(words[j]):\\n                    count += 1\\n        return count\\n```",
                "solutionTags": [
                    "Python3",
                    "Array",
                    "Hash Table",
                    "String"
                ],
                "code": "```\\nclass Solution:\\n    def similarPairs(self, words: List[str]) -> int:\\n        count = 0\\n        for i in range(len(words)):\\n            for j in range(i + 1, len(words)):\\n                if set(words[i]) == set(words[j]):\\n                    count += 1\\n        return count\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3328934,
                "title": "count-pairs-of-similar-strings-solution-in-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n^3)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1)\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int similarPairs(vector<string>& words) {\\n        int i, j, k, count=0;\\n        for(i=0 ; i<words.size() ; i++)\\n        {\\n            for(j=0 ; j<words[i].length() ; j++)\\n            {\\n                k=j+1;\\n                while(k<words[i].size())\\n                {\\n                    if(words[i][j]==words[i][k])\\n                    {\\n                        words[i].erase(words[i].begin()+k);\\n                    }\\n                    else\\n                    {\\n                        k++;\\n                    }\\n                }\\n            }\\n            sort(words[i].begin(), words[i].end());\\n        }\\n        for(i=0 ; i<words.size() ; i++)\\n        {\\n            for(j=i+1 ; j<words.size() ; j++)\\n            {\\n                if(words[i]==words[j])\\n                {\\n                    count++;\\n                }\\n            }\\n        }\\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int similarPairs(vector<string>& words) {\\n        int i, j, k, count=0;\\n        for(i=0 ; i<words.size() ; i++)\\n        {\\n            for(j=0 ; j<words[i].length() ; j++)\\n            {\\n                k=j+1;\\n                while(k<words[i].size())\\n                {\\n                    if(words[i][j]==words[i][k])\\n                    {\\n                        words[i].erase(words[i].begin()+k);\\n                    }\\n                    else\\n                    {\\n                        k++;\\n                    }\\n                }\\n            }\\n            sort(words[i].begin(), words[i].end());\\n        }\\n        for(i=0 ; i<words.size() ; i++)\\n        {\\n            for(j=i+1 ; j<words.size() ; j++)\\n            {\\n                if(words[i]==words[j])\\n                {\\n                    count++;\\n                }\\n            }\\n        }\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3265792,
                "title": "c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n        \\n\\n    vector<int> mapping(string &words)\\n    {\\n        vector<int> ans(26, 0);\\n        for (int i = 0; i < words.size(); i++)\\n        {\\n            ans[words[i] - \\'a\\']++;\\n        }\\n        return ans;\\n    }\\n\\n    int similarPairs(vector<string>& words) {\\n\\n    int n=words.size();\\n    int count = 0;\\n    for (int i = 0; i < n; i++)\\n    {\\n        vector<int> mapping1 = mapping(words[i]);\\n        for (int j = i + 1; j < n; j++)\\n        {\\n            vector<int> mapping2 = mapping(words[j]);\\n            bool equal = true;\\n            for (int k = 0; k < 26; k++)\\n            {\\n                if ((mapping1[k] != 0 && mapping2[k] == 0) || mapping1[k] == 0 && mapping2[k] != 0)\\n                {\\n                    equal = false;\\n                    break;\\n                }\\n            }\\n            if (equal)\\n                count++;\\n        }\\n    }\\n    return count;\\n\\n \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n        \\n\\n    vector<int> mapping(string &words)\\n    {\\n        vector<int> ans(26, 0);\\n        for (int i = 0; i < words.size(); i++)\\n        {\\n            ans[words[i] - \\'a\\']++;\\n        }\\n        return ans;\\n    }\\n\\n    int similarPairs(vector<string>& words) {\\n\\n    int n=words.size();\\n    int count = 0;\\n    for (int i = 0; i < n; i++)\\n    {\\n        vector<int> mapping1 = mapping(words[i]);\\n        for (int j = i + 1; j < n; j++)\\n        {\\n            vector<int> mapping2 = mapping(words[j]);\\n            bool equal = true;\\n            for (int k = 0; k < 26; k++)\\n            {\\n                if ((mapping1[k] != 0 && mapping2[k] == 0) || mapping1[k] == 0 && mapping2[k] != 0)\\n                {\\n                    equal = false;\\n                    break;\\n                }\\n            }\\n            if (equal)\\n                count++;\\n        }\\n    }\\n    return count;\\n\\n \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3160201,
                "title": "python-solution-using-set",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nfrom collections import defaultdict\\nclass Solution:\\n    def similarPairs(self, w: List[str]) -> int:\\n        c = 0\\n        for i in range(len(w)):\\n            for j in range(i+1,len(w)):\\n                if(set(w[i]) == set(w[j])):\\n                    c+=1\\n        return c\\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nfrom collections import defaultdict\\nclass Solution:\\n    def similarPairs(self, w: List[str]) -> int:\\n        c = 0\\n        for i in range(len(w)):\\n            for j in range(i+1,len(w)):\\n                if(set(w[i]) == set(w[j])):\\n                    c+=1\\n        return c\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3047860,
                "title": "python-symmetric-difference-of-two-set-explained",
                "content": "We get the character set for each word, and then, we just need to check the difference between any pair of two character sets.\\n\\nThe python set method: `symmetric_difference` can do the job.\\n\\n```\\nclass Solution:\\n    def similarPairs(self, words: List[str]) -> int:\\n        wd_set = collections.defaultdict(set)\\n        for idx, wd in enumerate(words):\\n            wd_set[idx] = set(wd)\\n        \\n        ans = 0\\n        for i in range(len(words) - 1):\\n            for j in range(i + 1, len(words)):\\n                if len(wd_set[i].symmetric_difference(wd_set[j])) == 0:\\n                    ans += 1\\n        return ans\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def similarPairs(self, words: List[str]) -> int:\\n        wd_set = collections.defaultdict(set)\\n        for idx, wd in enumerate(words):\\n            wd_set[idx] = set(wd)\\n        \\n        ans = 0\\n        for i in range(len(words) - 1):\\n            for j in range(i + 1, len(words)):\\n                if len(wd_set[i].symmetric_difference(wd_set[j])) == 0:\\n                    ans += 1\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2989069,
                "title": "stl-set-to-find-similar-pairs-c",
                "content": "\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n- We use STL `unordered_set` to find similar strings and store the frequency in an `unordered_map`.\\n- Keep in mind we should sort the string to handle similar strings. (i.e., `abc` and `cab`)\\n- Finding the pair is quite simple after this. TLDR; The formula is `n(n-1)/2` where n is the number of items in the list.\\n\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int similarPairs(vector<string>& arr) {\\n        unordered_map<string, int> c;\\n\\n        for (auto& str: arr) {\\n            unordered_set<char> s(str.begin(), str.end());\\n            string t(s.begin(), s.end());\\n            sort(t.begin(), t.end());\\n            c[t]++;\\n        }\\n\\n        int ans = 0;\\n        for (auto& it: c) {\\n            int p = it.second;\\n            ans += (p * (p-1))/2;\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int similarPairs(vector<string>& arr) {\\n        unordered_map<string, int> c;\\n\\n        for (auto& str: arr) {\\n            unordered_set<char> s(str.begin(), str.end());\\n            string t(s.begin(), s.end());\\n            sort(t.begin(), t.end());\\n            c[t]++;\\n        }\\n\\n        int ans = 0;\\n        for (auto& it: c) {\\n            int p = it.second;\\n            ans += (p * (p-1))/2;\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2929467,
                "title": "c-using-vector-of-vector-of-26-size",
                "content": "**Time Complexity: O(N * N)\\nSpace Complexity: O(N * 26)**\\nInstead of using maps or sets, I thought of using a double dimensional array or vector of vector, and then I just checked if the vectors are equal or not!\\n```\\nclass Solution {\\npublic:\\n    int similarPairs(vector<string>& words) {\\n        vector<vector<int>> v;\\n        for(auto i:words){\\n            vector<int> ch(26,0);\\n            string t=\"\";\\n            for(auto j:i){\\n                if(ch[j-\\'a\\']==0)\\n                ch[j-\\'a\\']++;\\n            }\\n            v.push_back(ch);\\n        }\\n        int ans=0;\\n        for(int i=0;i<words.size();i++){\\n            for(int j=i+1;j<words.size();j++){\\n                if(v[i]==v[j]) ++ans;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int similarPairs(vector<string>& words) {\\n        vector<vector<int>> v;\\n        for(auto i:words){\\n            vector<int> ch(26,0);\\n            string t=\"\";\\n            for(auto j:i){\\n                if(ch[j-\\'a\\']==0)\\n                ch[j-\\'a\\']++;\\n            }\\n            v.push_back(ch);\\n        }\\n        int ans=0;\\n        for(int i=0;i<words.size();i++){\\n            for(int j=i+1;j<words.size();j++){\\n                if(v[i]==v[j]) ++ans;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2928947,
                "title": "c-15-ms-optimized-solution-using-map-and-bitmask",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nI converted the given strings into a bitmask and counted the frequency of those bitmask in an unordered map.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n0(n*l) where l is length of longest string\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int similarPairs(vector<string>& words) {\\n        unordered_map <int,int> mp;\\n        for(auto x:words){\\n            int mask = 0;\\n            for(int i = 0; i <x.size(); i++){\\n                mask |= 1<<(x[i]-\\'a\\');\\n            }\\n            mp[mask]++;\\n        }\\n        int count = 0;\\n        for(auto x:mp){\\n            int c = x.second;\\n            count+= c*(c-1)/2;\\n        }\\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int similarPairs(vector<string>& words) {\\n        unordered_map <int,int> mp;\\n        for(auto x:words){\\n            int mask = 0;\\n            for(int i = 0; i <x.size(); i++){\\n                mask |= 1<<(x[i]-\\'a\\');\\n            }\\n            mp[mask]++;\\n        }\\n        int count = 0;\\n        for(auto x:mp){\\n            int c = x.second;\\n            count+= c*(c-1)/2;\\n        }\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2928216,
                "title": "c-easy-to-understand-solution",
                "content": "# Intuition\\nTwo strings are similar if they contain the same set of characters(order and frequency of characters is not important)\\n# Approach\\nDeclare a map of set of characters and store the frequency of the  set of characters obtained from the given vector of strings. Then count the identical pairs in a single iteration\\n\\n# Complexity\\n- Time complexity:\\nO(N)\\n\\n- Space complexity:\\nO(N)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int similarPairs(vector<string>& words) {\\n        map<set<char>,int> mp;int count=0;  map<set<char>,int>::iterator it;\\n        for(int i=0;i<words.size();i++){\\n            set<char> st;\\n            for(int j=0;j<words[i].size();j++){\\n            st.insert(words[i][j]);\\n            }\\n            mp[st]++;\\n        }\\n        for(it=mp.begin();it!=mp.end();it++){\\n            count+=(((it->second)*(it->second-1))/2);\\n        }\\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Ordered Map",
                    "Counting",
                    "Ordered Set"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int similarPairs(vector<string>& words) {\\n        map<set<char>,int> mp;int count=0;  map<set<char>,int>::iterator it;\\n        for(int i=0;i<words.size();i++){\\n            set<char> st;\\n            for(int j=0;j<words[i].size();j++){\\n            st.insert(words[i][j]);\\n            }\\n            mp[st]++;\\n        }\\n        for(it=mp.begin();it!=mp.end();it++){\\n            count+=(((it->second)*(it->second-1))/2);\\n        }\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2926681,
                "title": "golang-4-ms-4-1-mb",
                "content": "# Complexity\\n- Time complexity: $$O(n)$$\\n- Space complexity: $$O(n)$$\\n# Code\\n```\\nfunc similarPairs(words []string) int {\\n\\tresult := 0\\n\\th := make(map[int32]byte)\\n\\tfor _, word := range words {\\n\\t\\tvar chars int32\\n\\t\\tfor i := 0; i < len(word); i++ {\\n\\t\\t\\tchars |= 1 << (word[i] - \\'a\\')\\n\\t\\t}\\n\\t\\tc := h[chars]\\n\\t\\tresult += int(c)\\n\\t\\th[chars] = c + 1\\n\\t}\\n\\treturn result\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc similarPairs(words []string) int {\\n\\tresult := 0\\n\\th := make(map[int32]byte)\\n\\tfor _, word := range words {\\n\\t\\tvar chars int32\\n\\t\\tfor i := 0; i < len(word); i++ {\\n\\t\\t\\tchars |= 1 << (word[i] - \\'a\\')\\n\\t\\t}\\n\\t\\tc := h[chars]\\n\\t\\tresult += int(c)\\n\\t\\th[chars] = c + 1\\n\\t}\\n\\treturn result\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2926180,
                "title": "c-easy-simple-solution-brute-force-approach",
                "content": "## Guy\\'s if you find this solution helpful \\uD83D\\uDE0A, PLEASE do UPVOTE.\\n\\n# Complexity\\n- Time complexity: O(N*N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int similarPairs(vector<string>& words) \\n    {\\n        int n=words.size(),ans=0;\\n        for(int i=0;i<n;i++)\\n        {\\n            string s1=words[i];\\n            sort(s1.begin(),s1.end());\\n            s1.erase(unique(s1.begin(),s1.end()) , s1.end());\\n            \\n             for(int j=i+1;j<n;j++)\\n             {\\n                string s2=words[j];\\n                sort(s2.begin(),s2.end());\\n                s2.erase(unique(s2.begin(),s2.end()) , s2.end());\\n                 if(s1==s2)\\n                 {\\n                     ans++;\\n                 }\\n             }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int similarPairs(vector<string>& words) \\n    {\\n        int n=words.size(),ans=0;\\n        for(int i=0;i<n;i++)\\n        {\\n            string s1=words[i];\\n            sort(s1.begin(),s1.end());\\n            s1.erase(unique(s1.begin(),s1.end()) , s1.end());\\n            \\n             for(int j=i+1;j<n;j++)\\n             {\\n                string s2=words[j];\\n                sort(s2.begin(),s2.end());\\n                s2.erase(unique(s2.begin(),s2.end()) , s2.end());\\n                 if(s1==s2)\\n                 {\\n                     ans++;\\n                 }\\n             }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2926008,
                "title": "c-solution-using-set-stl",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int similarPairs(vector<string>& words) {\\n        int n = words.size();\\n        vector<string> ans;\\n        int cnt = 0;\\n       for(auto w:words){\\n           set<char>s;\\n           for(auto ch : w){\\n               s.insert(ch);\\n           }\\n           string temp = \"\";\\n           for(auto x : s){\\n               temp += x;\\n           }\\n            ans.push_back(temp);\\n       }\\n       for(int i=0 ; i<ans.size() ; i++){\\n           for(int j=i+1; j<ans.size(); j++){\\n               if(ans[i]==ans[j])cnt++;\\n           }\\n           \\n    }\\n    return cnt;\\n    }\\n\\n\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int similarPairs(vector<string>& words) {\\n        int n = words.size();\\n        vector<string> ans;\\n        int cnt = 0;\\n       for(auto w:words){\\n           set<char>s;\\n           for(auto ch : w){\\n               s.insert(ch);\\n           }\\n           string temp = \"\";\\n           for(auto x : s){\\n               temp += x;\\n           }\\n            ans.push_back(temp);\\n       }\\n       for(int i=0 ; i<ans.size() ; i++){\\n           for(int j=i+1; j<ans.size(); j++){\\n               if(ans[i]==ans[j])cnt++;\\n           }\\n           \\n    }\\n    return cnt;\\n    }\\n\\n\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2925789,
                "title": "golang-bitmask-tc-o-n-m-sc-o-n",
                "content": "# Complexity\\n- Time complexity: O(n*m)\\n- Space complexity: O(n)\\n> n - words.length, m - word.length\\n\\n# Code\\n```\\nfunc similarPairs(words []string) (result int) {\\n\\tcounter := make(map[int]int)\\n\\tfor i := 0; i < len(words); i++ {\\n\\t\\tcounter[toMask(words[i])]++\\n\\t}\\n\\n\\tfor _, x := range counter {\\n\\t\\tresult += (x - 1) * x / 2\\n\\t}\\n\\n\\treturn result\\n}\\n\\nfunc toMask(s string) (result int) {\\n\\tfor i := 0; i < len(s); i++ {\\n\\t\\tresult |= 1 << (s[i] - \\'a\\')\\n\\t}\\n\\n\\treturn result\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc similarPairs(words []string) (result int) {\\n\\tcounter := make(map[int]int)\\n\\tfor i := 0; i < len(words); i++ {\\n\\t\\tcounter[toMask(words[i])]++\\n\\t}\\n\\n\\tfor _, x := range counter {\\n\\t\\tresult += (x - 1) * x / 2\\n\\t}\\n\\n\\treturn result\\n}\\n\\nfunc toMask(s string) (result int) {\\n\\tfor i := 0; i < len(s); i++ {\\n\\t\\tresult |= 1 << (s[i] - \\'a\\')\\n\\t}\\n\\n\\treturn result\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2924928,
                "title": "c-set",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int similarPairs(vector<string>& words) {\\n        vector<string> v;\\n        for(int i=0;i<words.size();i++)\\n        {\\n            set<char> s;\\n            for(int j=0;j<words[i].size();j++)\\n            {\\n                if(s.count(words[i][j])==0)\\n                    s.insert(words[i][j]);\\n            }\\n            string temp=\"\";\\n            for(auto& i:s)\\n            {\\n                temp.push_back(i);\\n            }\\n            sort(temp.begin(),temp.end());\\n            cout<<temp<<\" \";\\n            v.push_back(temp);\\n        }\\n        map<string,int> mp;\\n        for(int i=0;i<words.size();i++)\\n        {\\n            mp[v[i]]++;\\n        }\\n        int c=0;\\n        for(auto i:mp)\\n        {\\n            if(i.second>1)\\n                c=c+(i.second*(i.second-1))/2;\\n        }\\n        return c;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Math",
                    "Ordered Set"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int similarPairs(vector<string>& words) {\\n        vector<string> v;\\n        for(int i=0;i<words.size();i++)\\n        {\\n            set<char> s;\\n            for(int j=0;j<words[i].size();j++)\\n            {\\n                if(s.count(words[i][j])==0)\\n                    s.insert(words[i][j]);\\n            }\\n            string temp=\"\";\\n            for(auto& i:s)\\n            {\\n                temp.push_back(i);\\n            }\\n            sort(temp.begin(),temp.end());\\n            cout<<temp<<\" \";\\n            v.push_back(temp);\\n        }\\n        map<string,int> mp;\\n        for(int i=0;i<words.size();i++)\\n        {\\n            mp[v[i]]++;\\n        }\\n        int c=0;\\n        for(auto i:mp)\\n        {\\n            if(i.second>1)\\n                c=c+(i.second*(i.second-1))/2;\\n        }\\n        return c;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2924711,
                "title": "python-set-set",
                "content": "```python\\nclass Solution:\\n    def similarPairs(self, words: List[str]) -> int:\\n        total = 0\\n\\n        for i in range(len(words)):\\n            for j in range(i + 1, len(words)):\\n                if not (set(words[i]) ^ set(words[j])):\\n                    total += 1\\n                    \\n        return total\\n```",
                "solutionTags": [
                    "Python",
                    "Ordered Set"
                ],
                "code": "```python\\nclass Solution:\\n    def similarPairs(self, words: List[str]) -> int:\\n        total = 0\\n\\n        for i in range(len(words)):\\n            for j in range(i + 1, len(words)):\\n                if not (set(words[i]) ^ set(words[j])):\\n                    total += 1\\n                    \\n        return total\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2924651,
                "title": "javascript-js",
                "content": "```\\n/**\\n * @param {string[]} words\\n * @return {number}\\n */\\nvar similarPairs = function (words) {\\n  let result = 0;\\n\\n  for (let i = 0; i < words.length; i++) {\\n    for (let j = 0; j < words.length; j++) {\\n      let firstWord = [...new Set(words[i])]\\n        .sort((a, b) => (a > b ? 1 : -1))\\n        .join(\"\");\\n      let secondWord = [...new Set(words[j])]\\n        .sort((a, b) => (a > b ? 1 : -1))\\n        .join(\"\");\\n      if (i !== j && firstWord === secondWord) {\\n        result++;\\n      }\\n    }\\n  }\\n\\n  return result / 2;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {string[]} words\\n * @return {number}\\n */\\nvar similarPairs = function (words) {\\n  let result = 0;\\n\\n  for (let i = 0; i < words.length; i++) {\\n    for (let j = 0; j < words.length; j++) {\\n      let firstWord = [...new Set(words[i])]\\n        .sort((a, b) => (a > b ? 1 : -1))\\n        .join(\"\");\\n      let secondWord = [...new Set(words[j])]\\n        .sort((a, b) => (a > b ? 1 : -1))\\n        .join(\"\");\\n      if (i !== j && firstWord === secondWord) {\\n        result++;\\n      }\\n    }\\n  }\\n\\n  return result / 2;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2924097,
                "title": "java-hashset-sorting-simple-solution",
                "content": "# Code\\n```\\nclass Solution {\\n    public int similarPairs(String[] words) {\\n        for(int i=0;i<words.length;i++){\\n            String str = words[i];\\n            HashSet<Character> set = new HashSet<>();\\n            for(int j=0;j<str.length();j++){\\n                set.add(str.charAt(j));\\n            }\\n            char arr[] = new char[set.size()];\\n            Iterator<Character> itr = set.iterator();  \\n            String temp = \"\";\\n            while(itr.hasNext())  {  \\n                temp=temp+Character.toString(itr.next());  \\n            } \\n            words[i]=temp;\\n        }\\n        int count=0;\\n        for(int i=0;i<words.length-1;i++){\\n            for(int j=i+1;j<words.length;j++){\\n                if(words[i].equals(words[j]))\\n                    count++;\\n            }\\n        }\\n        return count;\\n    }\\n}\\n```\\n\\nKindly upvote if you like the code.",
                "solutionTags": [
                    "Java",
                    "Array",
                    "String",
                    "Sort",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\n    public int similarPairs(String[] words) {\\n        for(int i=0;i<words.length;i++){\\n            String str = words[i];\\n            HashSet<Character> set = new HashSet<>();\\n            for(int j=0;j<str.length();j++){\\n                set.add(str.charAt(j));\\n            }\\n            char arr[] = new char[set.size()];\\n            Iterator<Character> itr = set.iterator();  \\n            String temp = \"\";\\n            while(itr.hasNext())  {  \\n                temp=temp+Character.toString(itr.next());  \\n            } \\n            words[i]=temp;\\n        }\\n        int count=0;\\n        for(int i=0;i<words.length-1;i++){\\n            for(int j=i+1;j<words.length;j++){\\n                if(words[i].equals(words[j]))\\n                    count++;\\n            }\\n        }\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2924051,
                "title": "codedominar-solution",
                "content": "# Code\\n```\\n@1st approach \\n\\nclass Solution:\\n    def similarPairs(self, words: List[str]) -> int:\\n        d=Counter()\\n        count=0\\n        for current_word in words:\\n            word=\"\".join(sorted(set(current_word)))\\n            count+=d[word]\\n            d[word]+=1\\n        return count   \\n#####################################\\n@2nd approach\\n\\nclass Solution:\\n    def similarPairs(self, words: List[str]) -> int:\\n        return sum(set(words[i])==set(words[j]) for i in range(len(words)) for j in range(i+1,len(words)))\\n\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\n@1st approach \\n\\nclass Solution:\\n    def similarPairs(self, words: List[str]) -> int:\\n        d=Counter()\\n        count=0\\n        for current_word in words:\\n            word=\"\".join(sorted(set(current_word)))\\n            count+=d[word]\\n            d[word]+=1\\n        return count   \\n#####################################\\n@2nd approach\\n\\nclass Solution:\\n    def similarPairs(self, words: List[str]) -> int:\\n        return sum(set(words[i])==set(words[j]) for i in range(len(words)) for j in range(i+1,len(words)))\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2923894,
                "title": "c-beginer-friendly-clean-simple-easy-to-understand",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nfirst find the similar strings by using mao if characters then using that create a vector of string and then using another map count the number of stirng which are equal and then using logic to count the different pairs return the ans.\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int similarPairs(vector<string>& words) {\\n        // m<char,int>m;\\n        vector<string> v;\\n        for(int i=0;i<words.size();++i)\\n        {\\n            map<char,int>m;\\n            int l=words[i].size();\\n            for(int j=0;j<l;++j)\\n            \\n            {\\n                m[words[i][j]]++;\\n            }\\n            string s=\"\";\\n            for(auto it:m)\\n            {\\n                \\n                if(it.second>0)\\n                {\\n                    s=s+it.first;\\n                }\\n            }\\n         v.push_back(s);\\n        }\\n        map<string ,int>mm;\\n        for(int i=0;i<v.size();++i)\\n        {\\n            mm[v[i]]++;\\n        }\\n        int ans=0;\\n        for(auto it:mm)\\n            \\n        {\\n             if(it.second>1)\\n             {\\n                int p=(pow(it.second,2))-it.second;\\n                 ans+=ceil(p/2);\\n             }\\n        }\\n        \\n       return ans ;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int similarPairs(vector<string>& words) {\\n        // m<char,int>m;\\n        vector<string> v;\\n        for(int i=0;i<words.size();++i)\\n        {\\n            map<char,int>m;\\n            int l=words[i].size();\\n            for(int j=0;j<l;++j)\\n            \\n            {\\n                m[words[i][j]]++;\\n            }\\n            string s=\"\";\\n            for(auto it:m)\\n            {\\n                \\n                if(it.second>0)\\n                {\\n                    s=s+it.first;\\n                }\\n            }\\n         v.push_back(s);\\n        }\\n        map<string ,int>mm;\\n        for(int i=0;i<v.size();++i)\\n        {\\n            mm[v[i]]++;\\n        }\\n        int ans=0;\\n        for(auto it:mm)\\n            \\n        {\\n             if(it.second>1)\\n             {\\n                int p=(pow(it.second,2))-it.second;\\n                 ans+=ceil(p/2);\\n             }\\n        }\\n        \\n       return ans ;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2923701,
                "title": "simple-c-solution",
                "content": "# Code\\n```\\nclass Solution {\\n    int helper(int n){\\n        if(n == 1)\\n            return 1;\\n        return n + helper(n-1);\\n    }\\npublic:\\n    int similarPairs(vector<string>& words) {\\n        unordered_map <string,int> ump;\\n        for(auto &it:words){\\n            set <char> st;\\n            for(auto &jt:it)\\n                st.insert(jt);\\n            string tmp = \"\";\\n            for(auto &s:st)\\n                tmp += s;\\n            ump[tmp]++;\\n        }\\n        int ans = 0;\\n        for(auto &it:ump){\\n            if(it.second > 1)\\n                ans += helper(it.second-1);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Hash Table",
                    "Ordered Map",
                    "Ordered Set"
                ],
                "code": "```\\nclass Solution {\\n    int helper(int n){\\n        if(n == 1)\\n            return 1;\\n        return n + helper(n-1);\\n    }\\npublic:\\n    int similarPairs(vector<string>& words) {\\n        unordered_map <string,int> ump;\\n        for(auto &it:words){\\n            set <char> st;\\n            for(auto &jt:it)\\n                st.insert(jt);\\n            string tmp = \"\";\\n            for(auto &s:st)\\n                tmp += s;\\n            ump[tmp]++;\\n        }\\n        int ans = 0;\\n        for(auto &it:ump){\\n            if(it.second > 1)\\n                ans += helper(it.second-1);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2923676,
                "title": "simple-and-easy-to-understand-beginners-friendly-c",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int similarPairs(vector<string>& words) {\\n        int ans=0;\\n        int n = words.size();\\n        for(int i=0;i<n;i++)\\n        {\\n            for(int j=i+1;j<n;j++)\\n            {\\n                bool flag = false;\\n                for(int h = 0;h<26;h++)\\n                {\\n                    char ch = \\'a\\'+h;\\n                    if(words[i].find(ch) == -1 && words[j].find(ch) != -1 || words[j].find(ch) == -1 && words[i].find(ch) != -1){\\n                        flag = true;\\n                        break;\\n                    }\\n                }\\n                if(!flag)\\n                    ans++;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int similarPairs(vector<string>& words) {\\n        int ans=0;\\n        int n = words.size();\\n        for(int i=0;i<n;i++)\\n        {\\n            for(int j=i+1;j<n;j++)\\n            {\\n                bool flag = false;\\n                for(int h = 0;h<26;h++)\\n                {\\n                    char ch = \\'a\\'+h;\\n                    if(words[i].find(ch) == -1 && words[j].find(ch) != -1 || words[j].find(ch) == -1 && words[i].find(ch) != -1){\\n                        flag = true;\\n                        break;\\n                    }\\n                }\\n                if(!flag)\\n                    ans++;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2923656,
                "title": "python3-solution",
                "content": "\\n```\\nclass Solution:\\n    def similarPairs(self, words: List[str]) -> int:\\n        count=0\\n        N=len(words)\\n        for i in range(N):\\n            for j in range(i+1,N):\\n                if set(words[i])==set(words[j]):\\n                    count+=1\\n\\n        return count            \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def similarPairs(self, words: List[str]) -> int:\\n        count=0\\n        N=len(words)\\n        for i in range(N):\\n            for j in range(i+1,N):\\n                if set(words[i])==set(words[j]):\\n                    count+=1\\n\\n        return count            \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2923639,
                "title": "python3-simple-hash-map-solution",
                "content": "\\n# Approach\\n1. We can hash the word as its unique characters sorted i.e `bacddd == abcd`.\\n2. Now loop through the words updating the counts of each word type to find the amount of similar words. \\n3. To find how many pairs there are we use the $$nC_2$$ formula which is simplified as $$\\\\frac{n*(n-1)}{2}$$\\n\\n# Code\\n```\\nclass Solution:\\n    def similarPairs(self, words: List[str]) -> int:\\n        counts = {}\\n        \\n        for word in words:\\n            s = str(sorted(set(word)))\\n            \\n            if s in counts:\\n                counts[s] += 1\\n            else:\\n                counts[s] = 1\\n                \\n        return sum(int(n*(n-1)/2) for n in counts.values())\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def similarPairs(self, words: List[str]) -> int:\\n        counts = {}\\n        \\n        for word in words:\\n            s = str(sorted(set(word)))\\n            \\n            if s in counts:\\n                counts[s] += 1\\n            else:\\n                counts[s] = 1\\n                \\n        return sum(int(n*(n-1)/2) for n in counts.values())\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2923628,
                "title": "java-my-easy-to-understand-solution-beginner-friendly",
                "content": "```\\nTC : O(n * n)\\nSC : O(26) ~ O(1)\\nclass Solution {\\n    public int similarPairs(String[] words) {\\n        int count = 0;\\n        for(int i = 0; i < words.length; ++i){\\n            String word1 = words[i];\\n            int[] f1 = new int[26]; //frequency array 1\\n            \\n            for(int a = 0; a < word1.length(); ++a){ //making frequency array for word1\\n                char ch = word1.charAt(a);\\n                f1[ch - \\'a\\']++;\\n            }\\n            \\n            for(int j = i + 1; j < words.length; ++j){\\n                String word2 = words[j];\\n                int[] f2 = new int[26]; //frequency array 2\\n    \\n                for(int b = 0; b < word2.length(); ++b){ //making frequency array for word2\\n                    char ch = word2.charAt(b);\\n                    f2[ch - \\'a\\']++;\\n                }\\n                \\n                boolean flag = true;\\n                for(int k = 0; k < 26; ++k){\\n                    if((f1[k] > 0 && f2[k] == 0) || (f1[k] == 0 && f2[k] > 0)){\\n                        flag = false;\\n                        break;\\n                    }\\n                }\\n                \\n                if(flag) count++;\\n            }\\n        }\\n        \\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array"
                ],
                "code": "```\\nTC : O(n * n)\\nSC : O(26) ~ O(1)\\nclass Solution {\\n    public int similarPairs(String[] words) {\\n        int count = 0;\\n        for(int i = 0; i < words.length; ++i){\\n            String word1 = words[i];\\n            int[] f1 = new int[26]; //frequency array 1\\n            \\n            for(int a = 0; a < word1.length(); ++a){ //making frequency array for word1\\n                char ch = word1.charAt(a);\\n                f1[ch - \\'a\\']++;\\n            }\\n            \\n            for(int j = i + 1; j < words.length; ++j){\\n                String word2 = words[j];\\n                int[] f2 = new int[26]; //frequency array 2\\n    \\n                for(int b = 0; b < word2.length(); ++b){ //making frequency array for word2\\n                    char ch = word2.charAt(b);\\n                    f2[ch - \\'a\\']++;\\n                }\\n                \\n                boolean flag = true;\\n                for(int k = 0; k < 26; ++k){\\n                    if((f1[k] > 0 && f2[k] == 0) || (f1[k] == 0 && f2[k] > 0)){\\n                        flag = false;\\n                        break;\\n                    }\\n                }\\n                \\n                if(flag) count++;\\n            }\\n        }\\n        \\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2923622,
                "title": "c-using-set-and-sort",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    \\n    int solve(int n)\\n    {\\n        return n*(n-1)/2;\\n    }\\n    int similarPairs(vector<string>& words) {\\n    \\n        int n = words.size();\\n        \\n        for(int i =0;i<n;i++)\\n        {\\n            set<char> s;\\n            for(auto c : words[i])\\n            {\\n                s.insert(c);\\n            }\\n            words[i]=\"\";\\n            for(auto j = s.begin();j !=s.end();j++)words[i]+=(*j);\\n            \\n        }\\n        \\n        sort(words.begin(),words.end());\\n        \\n        string prev = words[0];\\n        int count = 1,ans=0;\\n        for(int i =1;i<n;i++)\\n        {\\n            if(words[i]==prev)count++;\\n            else\\n            {\\n                ans+=solve(count);\\n                prev = words[i];\\n                count=1;\\n            }\\n        }\\n        if(count!=1)ans+=solve(count);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    int solve(int n)\\n    {\\n        return n*(n-1)/2;\\n    }\\n    int similarPairs(vector<string>& words) {\\n    \\n        int n = words.size();\\n        \\n        for(int i =0;i<n;i++)\\n        {\\n            set<char> s;\\n            for(auto c : words[i])\\n            {\\n                s.insert(c);\\n            }\\n            words[i]=\"\";\\n            for(auto j = s.begin();j !=s.end();j++)words[i]+=(*j);\\n            \\n        }\\n        \\n        sort(words.begin(),words.end());\\n        \\n        string prev = words[0];\\n        int count = 1,ans=0;\\n        for(int i =1;i<n;i++)\\n        {\\n            if(words[i]==prev)count++;\\n            else\\n            {\\n                ans+=solve(count);\\n                prev = words[i];\\n                count=1;\\n            }\\n        }\\n        if(count!=1)ans+=solve(count);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2923511,
                "title": "i-know-its-ugly",
                "content": "```\\nclass Solution {\\npublic:\\n    int similarPairs(vector<string>& words) {\\n        vector<string> vals;\\n        for(auto word: words) {\\n            vals.push_back(get(word));\\n        }\\n        int result = 0;\\n        for(int i = 0; i < vals.size(); i++) {\\n            string word1 = vals[i];\\n            for(int j = i + 1; j < vals.size(); j++) {\\n                string word2 = vals[j];\\n                if(word1 == word2) {\\n                    result++;\\n                }\\n                \\n            }\\n        }\\n        return result;\\n        \\n    }\\n    string get(string word) {\\n        unordered_set<char> st;\\n        string str = \"\";\\n        for(auto c: word) {\\n            if(st.count(c)) {\\n                continue;\\n            }\\n            str += c;\\n            st.insert(c);\\n        }\\n        sort(str.begin(), str.end());\\n        return str;\\n    }\\n   \\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int similarPairs(vector<string>& words) {\\n        vector<string> vals;\\n        for(auto word: words) {\\n            vals.push_back(get(word));\\n        }\\n        int result = 0;\\n        for(int i = 0; i < vals.size(); i++) {\\n            string word1 = vals[i];\\n            for(int j = i + 1; j < vals.size(); j++) {\\n                string word2 = vals[j];\\n                if(word1 == word2) {\\n                    result++;\\n                }\\n                \\n            }\\n        }\\n        return result;\\n        \\n    }\\n    string get(string word) {\\n        unordered_set<char> st;\\n        string str = \"\";\\n        for(auto c: word) {\\n            if(st.count(c)) {\\n                continue;\\n            }\\n            str += c;\\n            st.insert(c);\\n        }\\n        sort(str.begin(), str.end());\\n        return str;\\n    }\\n   \\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2923471,
                "title": "python-solution",
                "content": "```\\nclass Solution(object):\\n    def similarPairs(self, words):\\n        \"\"\"\\n        :type words: List[str]\\n        :rtype: int\\n        \"\"\"\\n        def nCr(n, r):\\n\\n            return (fact(n) / (fact(r)\\n                        * fact(n - r)))\\n\\n        def fact(n):\\n            if n == 0:\\n                return 1\\n            res = 1\\n\\n            for i in range(2, n+1):\\n                res = res * i\\n\\n            return res\\n        for i in range(len(words)):\\n            words[i] = \"\".join(set(words[i]))\\n        d = {}\\n        for i in words:\\n            if i not in d:\\n                d[i] = 0\\n            d[i] += 1\\n        count = 0\\n        for i in d:\\n            if d[i] > 1:\\n                count += nCr(d[i],2)\\n        return count\\n        \\n        \\n            \\n        \\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution(object):\\n    def similarPairs(self, words):\\n        \"\"\"\\n        :type words: List[str]\\n        :rtype: int\\n        \"\"\"\\n        def nCr(n, r):\\n\\n            return (fact(n) / (fact(r)\\n                        * fact(n - r)))\\n\\n        def fact(n):\\n            if n == 0:\\n                return 1\\n            res = 1\\n\\n            for i in range(2, n+1):\\n                res = res * i\\n\\n            return res\\n        for i in range(len(words)):\\n            words[i] = \"\".join(set(words[i]))\\n        d = {}\\n        for i in words:\\n            if i not in d:\\n                d[i] = 0\\n            d[i] += 1\\n        count = 0\\n        for i in d:\\n            if d[i] > 1:\\n                count += nCr(d[i],2)\\n        return count\\n        \\n        \\n            \\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 4097926,
                "title": "one-line-solution",
                "content": "```\\nclass Solution:\\n    def similarPairs(self, words: List[str]) -> int:\\n        return sum(a == b for a, b in combinations(map(set, words), 2))\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def similarPairs(self, words: List[str]) -> int:\\n        return sum(a == b for a, b in combinations(map(set, words), 2))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4091934,
                "title": "simple-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n   func similarPairs(_ words: [String]) -> Int {\\n    guard words.count != 1 else {return 0}\\n    var sum = 0\\n    \\n    for i in 0...words.count - 2 {\\n        let word1 = Set(words[i])\\n        for j in i + 1..<words.count {\\n            let word2 = Set(words[j])\\n            if word2 == word1 {\\n                sum += 1\\n            }\\n        }\\n    }\\n    \\n    return sum\\n}\\n}\\n```",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nclass Solution {\\n   func similarPairs(_ words: [String]) -> Int {\\n    guard words.count != 1 else {return 0}\\n    var sum = 0\\n    \\n    for i in 0...words.count - 2 {\\n        let word1 = Set(words[i])\\n        for j in i + 1..<words.count {\\n            let word2 = Set(words[j])\\n            if word2 == word1 {\\n                sum += 1\\n            }\\n        }\\n    }\\n    \\n    return sum\\n}\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4066895,
                "title": "easy-solution-in-java-100",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int similarPairs(String[] a) {\\n        int n=a.length;\\n        int m=0;\\n        for(int i=0;i<n-1;i++){\\n             Set<Character> t1=new TreeSet<Character>();\\n             String s1=a[i];\\n            for(int k=0;k<s1.length();k++){\\n                t1.add(s1.charAt(k));\\n            }\\n            String a1=\"\";\\n            for(char c:t1){\\n                a1+=c+\"\";\\n            }\\n            for(int j=i+1;j<n;j++){\\n                 Set<Character> t2=new TreeSet<Character>();\\n                String s2=a[j];\\n                for(int k=0;k<s2.length();k++){\\n                    t2.add(s2.charAt(k));\\n                }\\n                  String a2=\"\";\\n               for(char c:t2){\\n                   a2+=c+\"\";\\n                }\\n                if(a1.equals(a2)){\\n                    m++;\\n                }\\n            }\\n\\n        }\\n        return m;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int similarPairs(String[] a) {\\n        int n=a.length;\\n        int m=0;\\n        for(int i=0;i<n-1;i++){\\n             Set<Character> t1=new TreeSet<Character>();\\n             String s1=a[i];\\n            for(int k=0;k<s1.length();k++){\\n                t1.add(s1.charAt(k));\\n            }\\n            String a1=\"\";\\n            for(char c:t1){\\n                a1+=c+\"\";\\n            }\\n            for(int j=i+1;j<n;j++){\\n                 Set<Character> t2=new TreeSet<Character>();\\n                String s2=a[j];\\n                for(int k=0;k<s2.length();k++){\\n                    t2.add(s2.charAt(k));\\n                }\\n                  String a2=\"\";\\n               for(char c:t2){\\n                   a2+=c+\"\";\\n                }\\n                if(a1.equals(a2)){\\n                    m++;\\n                }\\n            }\\n\\n        }\\n        return m;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4057267,
                "title": "brute-force-approach-easily-understand-set-cpp",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\nprivate:\\n    bool checkSimilar(string s, string t){\\n        //CALCULATING THE NUMBER OF UNIQUE CHARACTERS IN FORST STRING\\n        unordered_set<char> st;\\n        for(auto i : s){\\n            st.insert(i);\\n        }\\n        //CALCULATING THE NUMBER OF UNIQUE CHARACTERS IN SECOND STRING\\n        unordered_set<char> tt;\\n        for(auto i : t){\\n            tt.insert(i);\\n        }\\n\\n        //CHECKING FOR THE EQUALITY OF THE STRING USING SET\\n        if(st == tt){\\n            return true;\\n        }else{\\n            return false;\\n        }\\n    }\\npublic:\\n    int similarPairs(vector<string>& words) {\\n        int ans = 0;\\n        for(int i = 0 ; i < words.size() ; i++){\\n            for(int j = i+1 ; j < words.size() ; j++){\\n                if(checkSimilar(words[i], words[j])){\\n                    ans++;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\nprivate:\\n    bool checkSimilar(string s, string t){\\n        //CALCULATING THE NUMBER OF UNIQUE CHARACTERS IN FORST STRING\\n        unordered_set<char> st;\\n        for(auto i : s){\\n            st.insert(i);\\n        }\\n        //CALCULATING THE NUMBER OF UNIQUE CHARACTERS IN SECOND STRING\\n        unordered_set<char> tt;\\n        for(auto i : t){\\n            tt.insert(i);\\n        }\\n\\n        //CHECKING FOR THE EQUALITY OF THE STRING USING SET\\n        if(st == tt){\\n            return true;\\n        }else{\\n            return false;\\n        }\\n    }\\npublic:\\n    int similarPairs(vector<string>& words) {\\n        int ans = 0;\\n        for(int i = 0 ; i < words.size() ; i++){\\n            for(int j = i+1 ; j < words.size() ; j++){\\n                if(checkSimilar(words[i], words[j])){\\n                    ans++;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4049435,
                "title": "99-runrime-78-memory-using-frozenset-and-dict",
                "content": "![image.png](https://assets.leetcode.com/users/images/38d098af-e658-464e-b7f1-5504f4ef5b3d_1694815287.3323157.png)\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def similarPairs(self, words: List[str]) -> int:\\n        d: dict = {}\\n        d_get = d.get\\n\\n        for word in words:\\n            word = frozenset(word)\\n            d[word] = d_get(word,0) + 1\\n\\n        return sum(v * (v - 1) // 2 for v in d.values())\\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def similarPairs(self, words: List[str]) -> int:\\n        d: dict = {}\\n        d_get = d.get\\n\\n        for word in words:\\n            word = frozenset(word)\\n            d[word] = d_get(word,0) + 1\\n\\n        return sum(v * (v - 1) // 2 for v in d.values())\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 4045400,
                "title": "beginners-friendly-c-easy-to-understand-solution",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\nvector<int> create(string s){\\nvector<int> v(26);\\nfor(int i=0;i<26;i++){\\n    v.push_back(0);\\n}\\nfor(int i=0;i<s.length();i++){\\n    int index=s[i]-\\'a\\';\\n    v[index]++;\\n}return v;\\n}\\nbool check(vector<int> v1,vector<int> v2){\\n    for(int i=0;i<26; i++){\\n        if(v1[i]!=0 && v2[i]==0){\\n            return false;\\n        }\\n        if(v2[i]!=0 && v1[i]==0){\\n            return false;\\n        }\\n        if(v1[i]==0 && v2[i]==0){\\n            continue;}\\n\\n        \\n        if(v1[i]!=0 && v2[i]!=0){\\n            continue;}\\n}\\n        \\n        return true;\\n    }\\n\\n\\n    int similarPairs(vector<string>& words) {\\n       vector<string> num;\\n       int i=0;\\n       int j=words.size()-1;\\n       for(i=0;i<words.size();i++){\\n           j=words.size()-1;\\n       while(i<j) {\\n           vector<int> v1= create(words[i]);\\n            vector<int> v2= create(words[j]);\\n           if(check(v1,v2)==1){\\n               num.push_back(words[i]);\\n               num.push_back(words[j]);\\n\\n           }\\n           j--;\\n       }}\\n       return (num.size())/2;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\nvector<int> create(string s){\\nvector<int> v(26);\\nfor(int i=0;i<26;i++){\\n    v.push_back(0);\\n}\\nfor(int i=0;i<s.length();i++){\\n    int index=s[i]-\\'a\\';\\n    v[index]++;\\n}return v;\\n}\\nbool check(vector<int> v1,vector<int> v2){\\n    for(int i=0;i<26; i++){\\n        if(v1[i]!=0 && v2[i]==0){\\n            return false;\\n        }\\n        if(v2[i]!=0 && v1[i]==0){\\n            return false;\\n        }\\n        if(v1[i]==0 && v2[i]==0){\\n            continue;}\\n\\n        \\n        if(v1[i]!=0 && v2[i]!=0){\\n            continue;}\\n}\\n        \\n        return true;\\n    }\\n\\n\\n    int similarPairs(vector<string>& words) {\\n       vector<string> num;\\n       int i=0;\\n       int j=words.size()-1;\\n       for(i=0;i<words.size();i++){\\n           j=words.size()-1;\\n       while(i<j) {\\n           vector<int> v1= create(words[i]);\\n            vector<int> v2= create(words[j]);\\n           if(check(v1,v2)==1){\\n               num.push_back(words[i]);\\n               num.push_back(words[j]);\\n\\n           }\\n           j--;\\n       }}\\n       return (num.size())/2;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4038114,
                "title": "easy-but-not-great-approch",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(n2)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(2n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    private int check(String s1, String s2){\\n        HashSet<Character> set = new HashSet<>();\\n        for(int i=0; i<s1.length(); i++){\\n            set.add(s1.charAt(i));\\n        }\\n        HashSet<Character> set2 = new HashSet<>();\\n        for(int i=0; i<s2.length(); i++){\\n            set2.add(s2.charAt(i));\\n        }\\n\\n        return set.equals(set2)?1:0;\\n    }\\n\\n    public int similarPairs(String[] words) {\\n        int count=0;\\n        for(int i=0; i<words.length-1; i++){\\n            for(int j=i+1; j<words.length; j++){\\n                count+=check(words[i], words[j]);\\n            }\\n        }\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Hash Table",
                    "String"
                ],
                "code": "```\\nclass Solution {\\n    private int check(String s1, String s2){\\n        HashSet<Character> set = new HashSet<>();\\n        for(int i=0; i<s1.length(); i++){\\n            set.add(s1.charAt(i));\\n        }\\n        HashSet<Character> set2 = new HashSet<>();\\n        for(int i=0; i<s2.length(); i++){\\n            set2.add(s2.charAt(i));\\n        }\\n\\n        return set.equals(set2)?1:0;\\n    }\\n\\n    public int similarPairs(String[] words) {\\n        int count=0;\\n        for(int i=0; i<words.length-1; i++){\\n            for(int j=i+1; j<words.length; j++){\\n                count+=check(words[i], words[j]);\\n            }\\n        }\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4019367,
                "title": "o-n-java-using-biginteger-as-hash",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nimport java.math.BigInteger;\\n\\nclass Solution {\\n    public int similarPairs(String[] words) {\\n    Map<BigInteger, Integer> map = new HashMap();\\n    BigInteger hash;\\n    for(String word : words){\\n      hash = hash(word);\\n      if(map.get(hash) == null)\\n        map.put(hash, 1);\\n      else\\n        map.put(hash, map.get(hash) + 1);\\n    }\\n    int count = 0;\\n    int v;\\n    for(BigInteger key : map.keySet()){\\n      v = map.get(key);\\n      // C(v, 2)\\n      count += v * (v - 1) / 2;\\n    }\\n    return count;\\n  }\\n\\n  private BigInteger hash(String word){\\n    BigInteger bi = new BigInteger(\"0\");\\n    int wordLen = word.length();\\n    BigInteger ten = new BigInteger(\"10\");\\n    BigInteger zero = new BigInteger(\"0\");\\n    for(int i = 0; i < wordLen; i++){\\n      if(bi.mod(ten.pow(word.charAt(i) - \\'a\\' + 1)).divide(ten.pow(word.charAt(i) - \\'a\\')).equals(zero))\\n        bi = bi.add(ten.pow(word.charAt(i) - \\'a\\'));\\n    }\\n    return bi;\\n  }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nimport java.math.BigInteger;\\n\\nclass Solution {\\n    public int similarPairs(String[] words) {\\n    Map<BigInteger, Integer> map = new HashMap();\\n    BigInteger hash;\\n    for(String word : words){\\n      hash = hash(word);\\n      if(map.get(hash) == null)\\n        map.put(hash, 1);\\n      else\\n        map.put(hash, map.get(hash) + 1);\\n    }\\n    int count = 0;\\n    int v;\\n    for(BigInteger key : map.keySet()){\\n      v = map.get(key);\\n      // C(v, 2)\\n      count += v * (v - 1) / 2;\\n    }\\n    return count;\\n  }\\n\\n  private BigInteger hash(String word){\\n    BigInteger bi = new BigInteger(\"0\");\\n    int wordLen = word.length();\\n    BigInteger ten = new BigInteger(\"10\");\\n    BigInteger zero = new BigInteger(\"0\");\\n    for(int i = 0; i < wordLen; i++){\\n      if(bi.mod(ten.pow(word.charAt(i) - \\'a\\' + 1)).divide(ten.pow(word.charAt(i) - \\'a\\')).equals(zero))\\n        bi = bi.add(ten.pow(word.charAt(i) - \\'a\\'));\\n    }\\n    return bi;\\n  }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4017417,
                "title": "beats-easy-beginner-friendly-solution-simple-and-easy-java-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int similarPairs(String[] words) {\\n        int n=words.length,c=0;\\n        for(int i=0;i<words.length;i++){\\n            words[i]=dis(words[i]);\\n        }\\n        Map<String,Integer>m= new HashMap();\\n        for(int i=0;i<words.length;i++){\\n            m.put(words[i],m.getOrDefault(words[i],0)+1);\\n        }\\n        int ans=0;\\n        for(String s : m.keySet()){\\n            ans+=(m.get(s)*(m.get(s)-1))/2;\\n        }\\n        return ans;\\n    }\\n    public String dis(String s){\\n        Set<Character>h= new TreeSet();\\n        for(int i=0;i<s.length();i++){\\n            if(!h.contains(s.charAt(i))){\\n                h.add(s.charAt(i));\\n            }\\n        }\\n        StringBuilder sb = new StringBuilder();\\n        for(Character c: h){\\n            sb.append(c);\\n        }\\n        return sb.toString();\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int similarPairs(String[] words) {\\n        int n=words.length,c=0;\\n        for(int i=0;i<words.length;i++){\\n            words[i]=dis(words[i]);\\n        }\\n        Map<String,Integer>m= new HashMap();\\n        for(int i=0;i<words.length;i++){\\n            m.put(words[i],m.getOrDefault(words[i],0)+1);\\n        }\\n        int ans=0;\\n        for(String s : m.keySet()){\\n            ans+=(m.get(s)*(m.get(s)-1))/2;\\n        }\\n        return ans;\\n    }\\n    public String dis(String s){\\n        Set<Character>h= new TreeSet();\\n        for(int i=0;i<s.length();i++){\\n            if(!h.contains(s.charAt(i))){\\n                h.add(s.charAt(i));\\n            }\\n        }\\n        StringBuilder sb = new StringBuilder();\\n        for(Character c: h){\\n            sb.append(c);\\n        }\\n        return sb.toString();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4016533,
                "title": "c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    std::size_t hash (const string &str) const noexcept\\n    {\\n        std::size_t res = 0;\\n        for (int i = 0; i < str.length(); i++)\\n        {\\n            res = res | (1 << (str[i] - \\'a\\'));\\n        }\\n        return res;\\n    }\\npublic:\\n    int similarPairs(vector<string>& words) {\\n        std::unordered_map<int, int> m;\\n        for (string &str: words)\\n        {\\n            m[hash(str)]++;\\n        }\\n        int result = 0;\\n        for (auto &p: m)\\n        {\\n            result = result + ((p.second * (p.second - 1)) / 2);\\n        }\\n        return result;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\n    std::size_t hash (const string &str) const noexcept\\n    {\\n        std::size_t res = 0;\\n        for (int i = 0; i < str.length(); i++)\\n        {\\n            res = res | (1 << (str[i] - \\'a\\'));\\n        }\\n        return res;\\n    }\\npublic:\\n    int similarPairs(vector<string>& words) {\\n        std::unordered_map<int, int> m;\\n        for (string &str: words)\\n        {\\n            m[hash(str)]++;\\n        }\\n        int result = 0;\\n        for (auto &p: m)\\n        {\\n            result = result + ((p.second * (p.second - 1)) / 2);\\n        }\\n        return result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4004773,
                "title": "a-brute-force-solution-that-gives-94-26-runtime",
                "content": "# Approach\\nBrute Force\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {string[]} words\\n * @return {number}\\n */\\nvar similarPairs = function (words) {\\n  const map = new Map();\\n  let count = 0;\\n\\n  const itemToSet = (item) => {\\n    const arr = item.split(\\'\\');\\n    const set = new Set(arr);\\n    const newArr = [...set];\\n\\n    newArr.sort();\\n\\n    return newArr.join(\\'\\');\\n  };\\n\\n  const calc = (n) => {\\n    return n * (n - 1) / 2;\\n  }\\n\\n  for (let word of words) {\\n    const newWord = itemToSet(word);\\n    map.set(newWord, (map.get(newWord) || 0) + 1);\\n  }\\n\\n  for (let [key, value] of map) {\\n    count += calc(value);\\n  }\\n  \\n  return count;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {string[]} words\\n * @return {number}\\n */\\nvar similarPairs = function (words) {\\n  const map = new Map();\\n  let count = 0;\\n\\n  const itemToSet = (item) => {\\n    const arr = item.split(\\'\\');\\n    const set = new Set(arr);\\n    const newArr = [...set];\\n\\n    newArr.sort();\\n\\n    return newArr.join(\\'\\');\\n  };\\n\\n  const calc = (n) => {\\n    return n * (n - 1) / 2;\\n  }\\n\\n  for (let word of words) {\\n    const newWord = itemToSet(word);\\n    map.set(newWord, (map.get(newWord) || 0) + 1);\\n  }\\n\\n  for (let [key, value] of map) {\\n    count += calc(value);\\n  }\\n  \\n  return count;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3992482,
                "title": "easy-for-beginners",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def similarPairs(self, words: List[str]) -> int:\\n        c=0\\n        for j in range(len(words)):\\n            for i in range(j):\\n                if(set(words[i])==set(words[j])):\\n                    c+=1\\n        return c\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def similarPairs(self, words: List[str]) -> int:\\n        c=0\\n        for j in range(len(words)):\\n            for i in range(j):\\n                if(set(words[i])==set(words[j])):\\n                    c+=1\\n        return c\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3985041,
                "title": "100",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    int similarPairs(vector<string>& w) {\\n        unordered_map<vector<bool>,int>mp;\\n        for(int i=0;i<w.size();i++){\\n            vector<bool>t(26);\\n            for(auto it:w[i]){\\n                t[it-\\'a\\']=1;\\n            }\\n            mp[t]++;\\n        }\\n        int cnt=0;\\n        for(auto it:mp){\\n            if(it.second>1){\\n                cnt+=(it.second*(it.second-1)/2);\\n            }\\n        }\\n        return cnt;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Hash Table",
                    "String"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int similarPairs(vector<string>& w) {\\n        unordered_map<vector<bool>,int>mp;\\n        for(int i=0;i<w.size();i++){\\n            vector<bool>t(26);\\n            for(auto it:w[i]){\\n                t[it-\\'a\\']=1;\\n            }\\n            mp[t]++;\\n        }\\n        int cnt=0;\\n        for(auto it:mp){\\n            if(it.second>1){\\n                cnt+=(it.second*(it.second-1)/2);\\n            }\\n        }\\n        return cnt;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3976512,
                "title": "double-hashmap-easy-but-not-efficient",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int similarPairs(String[] words) {\\n    Set<Character> hmi = new HashSet<>();\\n    Set<Character> hmj = new HashSet<>();\\n    int count = 0 ; \\n        for(int  i = 0 ; i< words.length-1 ;i++){\\n                String s =words[i];\\n                for(int k=0 ; k<s.length() ;k++){\\n                    char ch = s.charAt(k);\\n                    hmi.add(ch) ;\\n                }\\n            for(int j=i+1 ; j< words.length ; j++){\\n                 String t =words[j];\\n                for(int k=0 ; k<t.length() ;k++)\\n                {\\n                    char ch = t.charAt(k);\\n                    hmj.add(ch);\\n                }\\n                 if(hmi.equals(hmj)==true)  count++ ;\\n                  hmj.clear();\\n            }\\n            hmi.clear();\\n        }\\n        return count ; \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int similarPairs(String[] words) {\\n    Set<Character> hmi = new HashSet<>();\\n    Set<Character> hmj = new HashSet<>();\\n    int count = 0 ; \\n        for(int  i = 0 ; i< words.length-1 ;i++){\\n                String s =words[i];\\n                for(int k=0 ; k<s.length() ;k++){\\n                    char ch = s.charAt(k);\\n                    hmi.add(ch) ;\\n                }\\n            for(int j=i+1 ; j< words.length ; j++){\\n                 String t =words[j];\\n                for(int k=0 ; k<t.length() ;k++)\\n                {\\n                    char ch = t.charAt(k);\\n                    hmj.add(ch);\\n                }\\n                 if(hmi.equals(hmj)==true)  count++ ;\\n                  hmj.clear();\\n            }\\n            hmi.clear();\\n        }\\n        return count ; \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3956472,
                "title": "super-duper-easy-solution-in-c-short-and-unerstadable-code",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int similarPairs(vector<string>& words) \\n    {\\n        const size_t LEN = words.size();\\n        int count = 0;\\n\\n        for (size_t i = 0; i < LEN; ++i) {\\n            set<char> curr_word(words[i].begin(), words[i].end());\\n            for (size_t j = i + 1; j < LEN; ++j) {\\n                set<char> next_word(words[j].begin(), words[j].end());\\n                if (curr_word == next_word) ++count;\\n            }\\n        }\\n\\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int similarPairs(vector<string>& words) \\n    {\\n        const size_t LEN = words.size();\\n        int count = 0;\\n\\n        for (size_t i = 0; i < LEN; ++i) {\\n            set<char> curr_word(words[i].begin(), words[i].end());\\n            for (size_t j = i + 1; j < LEN; ++j) {\\n                set<char> next_word(words[j].begin(), words[j].end());\\n                if (curr_word == next_word) ++count;\\n            }\\n        }\\n\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3953073,
                "title": "using-set-easy-to-understand",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:o(n^2)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: o(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int similarPairs(vector<string>& w) {\\n    \\n       int n=w.size();\\n       int ans=0;\\n       for(int i=0;i<n;i++)\\n       {\\n          set<char>s1(w[i].begin(),w[i].end());\\n          for(int j=i+1;j<n;j++)\\n          {\\n                set<char>s2(w[j].begin(),w[j].end());\\n                if(s1==s2)\\n                {\\n                    ans++;\\n                }\\n          }\\n       }\\n       return ans;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int similarPairs(vector<string>& w) {\\n    \\n       int n=w.size();\\n       int ans=0;\\n       for(int i=0;i<n;i++)\\n       {\\n          set<char>s1(w[i].begin(),w[i].end());\\n          for(int j=i+1;j<n;j++)\\n          {\\n                set<char>s2(w[j].begin(),w[j].end());\\n                if(s1==s2)\\n                {\\n                    ans++;\\n                }\\n          }\\n       }\\n       return ans;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3945012,
                "title": "easy-to-understand-set-map-typescript",
                "content": "# Intuition\\nFirst removes all the duplicate characters from each word. Then, it compares each word to every other word in the array. If the two words have the same set of characters, then they are considered to be similar pairs.\\n\\n# Approach\\nFirst, collect distinct characters from each word using a \\'Set\\'. Then, consolidate these characters into a sorted string and record it in the \\'arr\\' map. After processing all words, calculate the total pairs by summing up the counts of identical words.\\n\\n# Complexity\\n- Time complexity: $$O(n*m)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n+m)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nfunction similarPairs(words: string[]): number {\\n     let arr = new Map<string,number>();\\n     let sum = 0;\\n     for(let word of words){\\n         let str: { [key: string]: number } = {};\\n          for(let i=0;i<word.length;i++){\\n                str[word[i]]++;\\n          }\\n          let tmp:string=\"\";\\n          for(let key in str){\\n               tmp+=key;\\n          }\\n          tmp = tmp.split(\\'\\').sort().join(\\'\\');\\n          console.log(tmp);\\n          if(arr.has(tmp)){\\n                arr.set(tmp,arr.get(tmp)+1);\\n          }\\n          else{\\n               arr.set(tmp,1);\\n          }\\n     }\\n\\n     for(let val of arr.values()){\\n          if(val>1){\\n                val--;\\n                sum+= val*(val+1)/2 ;\\n          }\\n     }\\n     return sum;\\n\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "TypeScript"
                ],
                "code": "```\\nfunction similarPairs(words: string[]): number {\\n     let arr = new Map<string,number>();\\n     let sum = 0;\\n     for(let word of words){\\n         let str: { [key: string]: number } = {};\\n          for(let i=0;i<word.length;i++){\\n                str[word[i]]++;\\n          }\\n          let tmp:string=\"\";\\n          for(let key in str){\\n               tmp+=key;\\n          }\\n          tmp = tmp.split(\\'\\').sort().join(\\'\\');\\n          console.log(tmp);\\n          if(arr.has(tmp)){\\n                arr.set(tmp,arr.get(tmp)+1);\\n          }\\n          else{\\n               arr.set(tmp,1);\\n          }\\n     }\\n\\n     for(let val of arr.values()){\\n          if(val>1){\\n                val--;\\n                sum+= val*(val+1)/2 ;\\n          }\\n     }\\n     return sum;\\n\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3942748,
                "title": "python-fast-and-easy-beats-95",
                "content": "# Code\\n```\\nclass Solution:\\n    def similarPairs(self, words: List[str]) -> int:\\n        d = {}\\n        c = 0\\n        for word in words:\\n            # We need tuple as only immutable data type can be key\\n            q = tuple(sorted(set(word)))\\n            if q in d:\\n                c += d[q]\\n                d[q] += 1\\n            else:\\n                d[q] = 1\\n        return c\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def similarPairs(self, words: List[str]) -> int:\\n        d = {}\\n        c = 0\\n        for word in words:\\n            # We need tuple as only immutable data type can be key\\n            q = tuple(sorted(set(word)))\\n            if q in d:\\n                c += d[q]\\n                d[q] += 1\\n            else:\\n                d[q] = 1\\n        return c\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3933629,
                "title": "python-easy-clean-solution-bitwise-or",
                "content": "# Complexity\\n- Time complexity: O(n^2)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def similarPairs(self, words: List[str]) -> int:\\n        res = 0\\n        tmp = defaultdict(int)\\n        def count_letters(s):\\n            value = 0\\n            for i in s:\\n                value = value | (1 << (ord(i) - 96))\\n            return value\\n\\n        for word in words:\\n            word = count_letters(word)\\n            if t := tmp.get(word):\\n                res += 1 if t == 1 else t\\n                tmp[word] += 1\\n            else:\\n                tmp[word] = 1\\n\\n        return res\\n```\\n![catty.png](https://assets.leetcode.com/users/images/514e1f32-284e-4042-bedd-e398493dd2ca_1692484757.7840433.png)\\n",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def similarPairs(self, words: List[str]) -> int:\\n        res = 0\\n        tmp = defaultdict(int)\\n        def count_letters(s):\\n            value = 0\\n            for i in s:\\n                value = value | (1 << (ord(i) - 96))\\n            return value\\n\\n        for word in words:\\n            word = count_letters(word)\\n            if t := tmp.get(word):\\n                res += 1 if t == 1 else t\\n                tmp[word] += 1\\n            else:\\n                tmp[word] = 1\\n\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3932673,
                "title": "hashset-simple-solution",
                "content": "\\n# Code\\n```\\nclass Solution {\\n    public int similarPairs(String[] words) {\\n        \\n        String[] w = new String[words.length];\\n\\n        for (int i = 0; i < words.length; i++) {\\n            Set<Character> s = new HashSet<>();\\n\\n            for (int j = 0; j < words[i].length(); j++) {\\n                s.add(words[i].charAt(j));\\n            }\\n\\n            String str = \"\";\\n\\n            for (Character c : s) {\\n                str += c;\\n            }\\n\\n            if (!str.isEmpty()) {\\n                w[i] = str;\\n            }\\n        }\\n\\n        int cnt = 0;\\n\\n        for (int i = 0; i < w.length; i++) {\\n            for (int j = i + 1; j < w.length; j++) {\\n                if (w[i].equals(w[j])) {\\n                    cnt++;\\n                }\\n            }\\n        }\\n\\n        return cnt;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int similarPairs(String[] words) {\\n        \\n        String[] w = new String[words.length];\\n\\n        for (int i = 0; i < words.length; i++) {\\n            Set<Character> s = new HashSet<>();\\n\\n            for (int j = 0; j < words[i].length(); j++) {\\n                s.add(words[i].charAt(j));\\n            }\\n\\n            String str = \"\";\\n\\n            for (Character c : s) {\\n                str += c;\\n            }\\n\\n            if (!str.isEmpty()) {\\n                w[i] = str;\\n            }\\n        }\\n\\n        int cnt = 0;\\n\\n        for (int i = 0; i < w.length; i++) {\\n            for (int j = i + 1; j < w.length; j++) {\\n                if (w[i].equals(w[j])) {\\n                    cnt++;\\n                }\\n            }\\n        }\\n\\n        return cnt;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3924292,
                "title": "java-1pass-use-hashing-o-n",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int similarPairs(String[] words) {\\n        long[] hash = new long[words.length];\\n\\n        for(int i = 0; i < words.length; i++) {\\n            String s = words[i];\\n            long l = 0;\\n            HashSet<Character> set = new HashSet();\\n            for(char c : s.toCharArray()) {\\n                if(set.contains(c)) continue;\\n                int diff = c - \\'a\\';\\n                long h = 1;\\n                while(diff-- > 0) h *= 26;\\n                l += h;\\n                set.add(c);\\n            }\\n            hash[i] = l;\\n        }\\n\\n        //Arrays.sort(hash);\\n        HashMap<Long, Integer> map = new HashMap();\\n        for(long l : hash) {\\n            map.put(l, map.getOrDefault(l, 0) + 1);\\n        }\\n\\n        int res = 0;\\n        //System.out.println(map);\\n        for(int cnt : map.values()) {\\n            if(cnt == 1) continue;\\n            int combo = 0;\\n            while(cnt-- > 0)  {\\n                //System.out.println(cnt);\\n                combo += cnt;\\n            }\\n            res += combo;\\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int similarPairs(String[] words) {\\n        long[] hash = new long[words.length];\\n\\n        for(int i = 0; i < words.length; i++) {\\n            String s = words[i];\\n            long l = 0;\\n            HashSet<Character> set = new HashSet();\\n            for(char c : s.toCharArray()) {\\n                if(set.contains(c)) continue;\\n                int diff = c - \\'a\\';\\n                long h = 1;\\n                while(diff-- > 0) h *= 26;\\n                l += h;\\n                set.add(c);\\n            }\\n            hash[i] = l;\\n        }\\n\\n        //Arrays.sort(hash);\\n        HashMap<Long, Integer> map = new HashMap();\\n        for(long l : hash) {\\n            map.put(l, map.getOrDefault(l, 0) + 1);\\n        }\\n\\n        int res = 0;\\n        //System.out.println(map);\\n        for(int cnt : map.values()) {\\n            if(cnt == 1) continue;\\n            int combo = 0;\\n            while(cnt-- > 0)  {\\n                //System.out.println(cnt);\\n                combo += cnt;\\n            }\\n            res += combo;\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3919785,
                "title": "word-to-int-solution",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\nEach word can be represented as set of 26 letters. Whereas set of 26 letters actually can be represented as `int32` by setting bits according the presented letters order.\\n\\nThe rest is easy. Each repeated `int32`, lets call it `hash`, adds `n` pairs, where `n` is the count of previously found `hash` number.\\n\\n# Complexity\\n- Time complexity: $$O(n)$$, where $$n$$ - is sum of all letters of all words\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(m)$$, where $$m$$ - is number of unique combinations of letters\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    fun similarPairs(words: Array<String>): Int {\\n        val set = HashMap<Int, Int>()\\n        var result = 0\\n        for (word in words) {\\n            val i = wordToInt(word)\\n            set[i] = set[i]?.also { result += it }?.plus(1) ?: 1\\n        }\\n        return result\\n    }\\n\\n    private fun wordToInt(word: String): Int {\\n        var i = 0\\n        for (ch in word) {\\n            i = i or (1 shl ch - \\'a\\')\\n        }\\n        return i\\n    }\\n}\\n```",
                "solutionTags": [
                    "Kotlin"
                ],
                "code": "```\\nclass Solution {\\n    fun similarPairs(words: Array<String>): Int {\\n        val set = HashMap<Int, Int>()\\n        var result = 0\\n        for (word in words) {\\n            val i = wordToInt(word)\\n            set[i] = set[i]?.also { result += it }?.plus(1) ?: 1\\n        }\\n        return result\\n    }\\n\\n    private fun wordToInt(word: String): Int {\\n        var i = 0\\n        for (ch in word) {\\n            i = i or (1 shl ch - \\'a\\')\\n        }\\n        return i\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3918647,
                "title": "beats-100-00-of-users-with-javascript-easy-solution-with-line-by-line-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {string[]} words\\n * @return {number}\\n */\\nvar similarPairs = function (words) {\\n\\n    // initialize count to zero\\n    let count = 0;\\n\\n    // initialize function checkSimilar with parameter word1 and word2\\n    function checkSimilar(word1, word2) {\\n\\n        // initialize temp to zero\\n        let temp = 0;\\n\\n        // loop through every character of word2\\n        for (let k = 0; k < word2.length; k++) {\\n\\n            // if every character of word2 is not includes in word1 then increment temp and break the loop\\n            if (!word1.includes(word2.charAt(k))) {\\n                temp++;\\n                break;\\n            }\\n        }\\n\\n        // if temp is equal to zero then return true\\n        if (temp == 0) {\\n            return true;\\n        }\\n\\n        // return false\\n        return false;\\n    }\\n\\n    // loop through every element of words from 0\\n    for (let i = 0; i < words.length; i++) {\\n\\n        // loop through every element of words from i+1\\n        for (let j = i + 1; j < words.length; j++) {\\n\\n            // call checkSimilar function with argument words[i] and words[j]\\n            let similar1 = checkSimilar(words[i], words[j])\\n\\n            // call checkSimilar function with argument words[j] and words[i]\\n            let similar2 = checkSimilar(words[j], words[i])\\n\\n            // if similar1 and similar2 both are true then increment count\\n            if (similar1 && similar2) {\\n                count++;\\n            }\\n        }\\n    }\\n\\n    // return count\\n    return count;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {string[]} words\\n * @return {number}\\n */\\nvar similarPairs = function (words) {\\n\\n    // initialize count to zero\\n    let count = 0;\\n\\n    // initialize function checkSimilar with parameter word1 and word2\\n    function checkSimilar(word1, word2) {\\n\\n        // initialize temp to zero\\n        let temp = 0;\\n\\n        // loop through every character of word2\\n        for (let k = 0; k < word2.length; k++) {\\n\\n            // if every character of word2 is not includes in word1 then increment temp and break the loop\\n            if (!word1.includes(word2.charAt(k))) {\\n                temp++;\\n                break;\\n            }\\n        }\\n\\n        // if temp is equal to zero then return true\\n        if (temp == 0) {\\n            return true;\\n        }\\n\\n        // return false\\n        return false;\\n    }\\n\\n    // loop through every element of words from 0\\n    for (let i = 0; i < words.length; i++) {\\n\\n        // loop through every element of words from i+1\\n        for (let j = i + 1; j < words.length; j++) {\\n\\n            // call checkSimilar function with argument words[i] and words[j]\\n            let similar1 = checkSimilar(words[i], words[j])\\n\\n            // call checkSimilar function with argument words[j] and words[i]\\n            let similar2 = checkSimilar(words[j], words[i])\\n\\n            // if similar1 and similar2 both are true then increment count\\n            if (similar1 && similar2) {\\n                count++;\\n            }\\n        }\\n    }\\n\\n    // return count\\n    return count;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3916241,
                "title": "beats-easy-beginner-friendly-solution-simple-and-easy-java-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int similarPairs(String[] words) {\\n        int n=words.length,c=0;\\n        for(int i=0;i<n;i++){\\n            int[] c1 = new int[26];\\n            for(int k=0;k<words[i].length();k++){\\n                c1[words[i].charAt(k)-\\'a\\']++;\\n            }\\n            for(int j=i+1;j<n;j++){\\n                int[] c2 = new int[26];         \\n                for(int l=0;l<words[j].length();l++){\\n                    c2[words[j].charAt(l)-\\'a\\']++;\\n                }\\n                if(compare(c1,c2)){\\n                    c++;\\n                }\\n            }\\n        }\\n        return c;\\n    }\\n    public boolean compare(int[] c1,int[] c2){\\n        for(int i=0;i<26;i++){\\n            if(c1[i]==0 && c2[i]!=0){\\n                return false;\\n            }\\n            if(c1[i]!=0 && c2[i]==0){\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int similarPairs(String[] words) {\\n        int n=words.length,c=0;\\n        for(int i=0;i<n;i++){\\n            int[] c1 = new int[26];\\n            for(int k=0;k<words[i].length();k++){\\n                c1[words[i].charAt(k)-\\'a\\']++;\\n            }\\n            for(int j=i+1;j<n;j++){\\n                int[] c2 = new int[26];         \\n                for(int l=0;l<words[j].length();l++){\\n                    c2[words[j].charAt(l)-\\'a\\']++;\\n                }\\n                if(compare(c1,c2)){\\n                    c++;\\n                }\\n            }\\n        }\\n        return c;\\n    }\\n    public boolean compare(int[] c1,int[] c2){\\n        for(int i=0;i<26;i++){\\n            if(c1[i]==0 && c2[i]!=0){\\n                return false;\\n            }\\n            if(c1[i]!=0 && c2[i]==0){\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3911101,
                "title": "easy-cpp-solution-using-map",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\n- Using st to collect unique sorted chars and then convert that into string and increase its freq in main map.\\n- Finally, traverse the main map and their could be nC2 combination pairs can be formed for each so, shortcut formula (n*n-1)/2 can be added into cnt.\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int similarPairs(vector<string>& words) {\\n        unordered_map<string, int> mp;\\n\\n        for(auto i : words){\\n            set<char> st(i.begin(), i.end());\\n            string s(st.begin(), st.end());\\n            mp[s]++;\\n        }\\n\\n        int cnt = 0;\\n        for(auto i : mp){\\n            cnt += ((i.second*(i.second-1))/2);\\n        }\\n        return cnt;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int similarPairs(vector<string>& words) {\\n        unordered_map<string, int> mp;\\n\\n        for(auto i : words){\\n            set<char> st(i.begin(), i.end());\\n            string s(st.begin(), st.end());\\n            mp[s]++;\\n        }\\n\\n        int cnt = 0;\\n        for(auto i : mp){\\n            cnt += ((i.second*(i.second-1))/2);\\n        }\\n        return cnt;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3891549,
                "title": "simple-o-n-k-solution-using-combinatorics-and-hashing",
                "content": "# Note about the Combinatorics Part\\n<!-- Initial Thoughts on Problem Solving Approach -->\\nThis solution use some mathematical concepts to arrive at the result more efficiently. However, understanding the maths isn\\'t essential to use the solution.\\n![image.png](https://assets.leetcode.com/users/images/46e6b5f6-5793-427a-a6b1-34b69a9f4198_1691686079.0316522.png)\\nOur primary concern is determining the count of pairs.\\nIn the maths formula, r is basically two, because we want pairs.\\nFor n total objects, we can, after some simplification i won\\'t annoy you with, get n(n+1)/2 pairs and you can use it to go even faster, but I used factorial to stick to the first formula.\\n\\n# Approach\\n<!-- Problem Solving Approach Description -->\\nTo calculate the number of similar pairs, we need to identify words that share the same letters. I achieved that using hashmap. I found the count of distinct words and, based on their repetition count, applied the aforementioned formula to determine the number of pairs.\\n\\n# Identifying Distinct Words\\nTo differentiate these words, I used a set(). This operation removes repeating letters from the string. If two sets are identical, their corresponding words are composed of the same letters.\\n\\n# Counting Word Repetitions\\nI employed a dictionary for tracking word repetitions. However, a challenge emerged: let\\'s say the same set appears twice in the list. How do we keep track of this? While using sets as keys and incrementing their values could be a solution, sets are mutable and thus unsuitable as keys. In this case, I opted for frozenset(), which is basically sets but frozen,whoops, i meant immutable.\\n\\n# Calculating the Number of Pairs\\nUltimately, for each word type, the counting dictionary holds the number of times it appears. By leveraging combinatorics principles and wizardry, we can determine the count of pairs. Summing up these values provides the desired result.\\n\\n\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(nk), k because we have to convert n words into cold-ass sets.\\n\\n\\n# Code\\n```\\nclass Solution:\\n    def similarPairs(self, words: List[str]) -> int:\\n        #First section: count for a given word, the number of word with exactly the same letter\\n\\n        temp=[frozenset(word) for word in words]\\n        #set to get rid of repetition\\n        #Frozen set because we need it to be immutable to use it as a key and count the nb of repetition\\n        countingdic={}\\n        for i in temp:\\n            countingdic[i]=countingdic.get(i,0)+1\\n        \\n        #Second section: Using combinatorics,count the number of pair possible for a given type of word\\n\\n        #For each wordtype of word i, countingdic[i] gives us the number of times it appears in the list. If it appears 2 time we can just add one pair, but if it appears 3,4,...n times we need to use more maths. This is basically the number of combination of 2 terms among n=countingdic[i]\\n        \\n        nbPair=lambda n: factorial(n)//(2*factorial(n-2))\\n        \\n        #Now we just sum the number of pair for each type of word that appears at least 2 times\\n        return sum([nbPair(val)for key,val in countingdic.items() if val>1])\\n\\n```",
                "solutionTags": [
                    "Python3",
                    "Hash Table",
                    "Combinatorics"
                ],
                "code": "```\\nclass Solution:\\n    def similarPairs(self, words: List[str]) -> int:\\n        #First section: count for a given word, the number of word with exactly the same letter\\n\\n        temp=[frozenset(word) for word in words]\\n        #set to get rid of repetition\\n        #Frozen set because we need it to be immutable to use it as a key and count the nb of repetition\\n        countingdic={}\\n        for i in temp:\\n            countingdic[i]=countingdic.get(i,0)+1\\n        \\n        #Second section: Using combinatorics,count the number of pair possible for a given type of word\\n\\n        #For each wordtype of word i, countingdic[i] gives us the number of times it appears in the list. If it appears 2 time we can just add one pair, but if it appears 3,4,...n times we need to use more maths. This is basically the number of combination of 2 terms among n=countingdic[i]\\n        \\n        nbPair=lambda n: factorial(n)//(2*factorial(n-2))\\n        \\n        #Now we just sum the number of pair for each type of word that appears at least 2 times\\n        return sum([nbPair(val)for key,val in countingdic.items() if val>1])\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3885366,
                "title": "pairs-of-similar-strings",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def similarPairs(self, words: List[str]) -> int:\\n        num=0\\n        for i in range(len(words)):\\n            for j in range(i+1,len(words)):\\n                if set(words[i])==(set(words[j])):\\n                    num+=1\\n        return num\\n\\n```",
                "solutionTags": [
                    "Python3",
                    "Array",
                    "Hash Table",
                    "String"
                ],
                "code": "```\\nclass Solution:\\n    def similarPairs(self, words: List[str]) -> int:\\n        num=0\\n        for i in range(len(words)):\\n            for j in range(i+1,len(words)):\\n                if set(words[i])==(set(words[j])):\\n                    num+=1\\n        return num\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3860426,
                "title": "java-28ms-beats-68-95",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int similarPairs(String[] words) {\\n\\n        Map<String, Integer> map = new HashMap<>();\\n\\n        for (String s : words) {\\n            map.merge(hash(s), 1, Integer::sum);\\n        }\\n\\n        int numPairs = 0;  // what we\\'ll return\\n        for (int v : map.values()) {\\n            numPairs += getTriangularNumber(v);\\n        }\\n\\n        return numPairs;\\n    }\\n\\n    private String hash(String s) {\\n        TreeSet<Character> chars = new TreeSet<>();\\n        for (char c : s.toCharArray()) {\\n            chars.add(c);\\n        }\\n\\n        StringBuilder sb = new StringBuilder();\\n        while (!chars.isEmpty()) {\\n            sb.append(chars.pollFirst());\\n        }\\n\\n        return sb.toString();\\n    }\\n\\n    private int getTriangularNumber(int n) {\\n        --n;\\n        return n * (n + 1) / 2;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int similarPairs(String[] words) {\\n\\n        Map<String, Integer> map = new HashMap<>();\\n\\n        for (String s : words) {\\n            map.merge(hash(s), 1, Integer::sum);\\n        }\\n\\n        int numPairs = 0;  // what we\\'ll return\\n        for (int v : map.values()) {\\n            numPairs += getTriangularNumber(v);\\n        }\\n\\n        return numPairs;\\n    }\\n\\n    private String hash(String s) {\\n        TreeSet<Character> chars = new TreeSet<>();\\n        for (char c : s.toCharArray()) {\\n            chars.add(c);\\n        }\\n\\n        StringBuilder sb = new StringBuilder();\\n        while (!chars.isEmpty()) {\\n            sb.append(chars.pollFirst());\\n        }\\n\\n        return sb.toString();\\n    }\\n\\n    private int getTriangularNumber(int n) {\\n        --n;\\n        return n * (n + 1) / 2;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3859181,
                "title": "easy-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\no(n2)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int similarPairs(String[] words) {\\n        int temp=0;\\n      for(int i=0;i<words.length;i++){\\n          String str1=words[i];\\n          HashSet<Character> hs1=new HashSet<>();\\n          for(int j=0;j<str1.length();j++){\\n              hs1.add(str1.charAt(j));\\n\\n          }\\n          for(int k=i+1;k<words.length;k++){\\n              String str2=words[k];\\n                HashSet<Character> hs2=new HashSet<>();\\n                for(int l=0;l<str2.length();l++){\\n                    hs2.add(str2.charAt(l));\\n                }\\n                int count=0;\\n                if(hs1.size()==hs2.size()){\\n                    ArrayList<Character> al1=new ArrayList<>(hs1);\\n                    ArrayList<Character> al2=new ArrayList<>(hs2);\\n                    for(int m=0;m<hs1.size();m++){\\n                        if(al1.get(m)!=al2.get(m)){\\n                            break;\\n                        }\\n                        else{\\n                            count=count+1;\\n                        }\\n                    }\\n                }\\n                if(count==hs2.size()){\\n                    temp=temp+1;\\n                }\\n          }\\n\\n      }\\n      return temp;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int similarPairs(String[] words) {\\n        int temp=0;\\n      for(int i=0;i<words.length;i++){\\n          String str1=words[i];\\n          HashSet<Character> hs1=new HashSet<>();\\n          for(int j=0;j<str1.length();j++){\\n              hs1.add(str1.charAt(j));\\n\\n          }\\n          for(int k=i+1;k<words.length;k++){\\n              String str2=words[k];\\n                HashSet<Character> hs2=new HashSet<>();\\n                for(int l=0;l<str2.length();l++){\\n                    hs2.add(str2.charAt(l));\\n                }\\n                int count=0;\\n                if(hs1.size()==hs2.size()){\\n                    ArrayList<Character> al1=new ArrayList<>(hs1);\\n                    ArrayList<Character> al2=new ArrayList<>(hs2);\\n                    for(int m=0;m<hs1.size();m++){\\n                        if(al1.get(m)!=al2.get(m)){\\n                            break;\\n                        }\\n                        else{\\n                            count=count+1;\\n                        }\\n                    }\\n                }\\n                if(count==hs2.size()){\\n                    temp=temp+1;\\n                }\\n          }\\n\\n      }\\n      return temp;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3849708,
                "title": "c-simple-solution-using-hashmap",
                "content": "\\n# Complexity\\n- Time complexity: O(n*n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int similarPairs(vector<string>& w) {\\n        int ans = 0;\\n        // APPROACH - \\n        // consider all pairs in O(n*n) and then compare w[i] and w[j]\\n\\n        for(int i = 0; i< w.size(); i++){\\n            unordered_map<char,int> m1; // for w[i]\\n            for(int k =0; k<w[i].length();k++){\\n                if(m1[w[i][k]] == 0){ // values must be same in order to compare keys\\n                    m1[w[i][k]]++;\\n                }  \\n            }        \\n            for(int j = i+1 ; j<w.size(); j++){\\n                unordered_map<char,int> m2; // for w[j]\\n                for(int l =0; l<w[j].length();l++){\\n                    if(m2[w[j][l]] == 0){ // values must be same in order to compare keys\\n                        m2[w[j][l]]++;\\n                    }\\n                }\\n\\n                // both key values must be same then it will return true\\n                if(m1 == m2){\\n                    ans++;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int similarPairs(vector<string>& w) {\\n        int ans = 0;\\n        // APPROACH - \\n        // consider all pairs in O(n*n) and then compare w[i] and w[j]\\n\\n        for(int i = 0; i< w.size(); i++){\\n            unordered_map<char,int> m1; // for w[i]\\n            for(int k =0; k<w[i].length();k++){\\n                if(m1[w[i][k]] == 0){ // values must be same in order to compare keys\\n                    m1[w[i][k]]++;\\n                }  \\n            }        \\n            for(int j = i+1 ; j<w.size(); j++){\\n                unordered_map<char,int> m2; // for w[j]\\n                for(int l =0; l<w[j].length();l++){\\n                    if(m2[w[j][l]] == 0){ // values must be same in order to compare keys\\n                        m2[w[j][l]]++;\\n                    }\\n                }\\n\\n                // both key values must be same then it will return true\\n                if(m1 == m2){\\n                    ans++;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3846657,
                "title": "swift-one-liner",
                "content": "# Code\\n```\\nclass Solution {\\n    func similarPairs(_ words: [String]) -> Int {\\n        words.reduce(into: [Set<Character>:Int]()) { $0[Set($1), default: 0] += 1 }\\n             .reduce(0) { $0 + $1.value * ($1.value - 1) / 2}\\n    }\\n}\\n```",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nclass Solution {\\n    func similarPairs(_ words: [String]) -> Int {\\n        words.reduce(into: [Set<Character>:Int]()) { $0[Set($1), default: 0] += 1 }\\n             .reduce(0) { $0 + $1.value * ($1.value - 1) / 2}\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3846575,
                "title": "hash-table-vs-brute-force-with-set-xor",
                "content": "## Hash table\\n```\\nclass Solution:\\n    def similarPairs(self, words: List[str]) -> int:\\n        counter = defaultdict(int)\\n        for i in words:\\n            counter[\"\".join(sorted(set(i)))] += 1\\n        return sum(v * (v - 1) // 2 for v in counter.values())\\n\\n \\n```\\n\\n## Brute force\\n```\\nclass Solution:\\n    def similarPairs(self, words: List[str]) -> int:\\n        result = 0\\n        for i in range(len(words)):\\n            words[i] = set(words[i])\\n\\n        for i in range(len(words) - 1):\\n            for j in range(i + 1, len(words)):\\n                if len(words[i] ^ words[j]) == 0:\\n                    result += 1\\n        return result\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def similarPairs(self, words: List[str]) -> int:\\n        counter = defaultdict(int)\\n        for i in words:\\n            counter[\"\".join(sorted(set(i)))] += 1\\n        return sum(v * (v - 1) // 2 for v in counter.values())\\n\\n \\n```\n```\\nclass Solution:\\n    def similarPairs(self, words: List[str]) -> int:\\n        result = 0\\n        for i in range(len(words)):\\n            words[i] = set(words[i])\\n\\n        for i in range(len(words) - 1):\\n            for j in range(i + 1, len(words)):\\n                if len(words[i] ^ words[j]) == 0:\\n                    result += 1\\n        return result\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3838482,
                "title": "with-explanation-comments-time-xx-ms-98-97-space-xx-mb-89-9",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int similarPairs(vector<string>& words) {\\n        \\n        int counter=0;\\n        vector<string> uni;\\n\\n        for(auto w:words){\\n\\n            set<char> st;\\n            for(auto ch:w)\\n                st.insert(ch);\\n                \\n            string temp=\"\";\\n            for(auto s:st)\\n                temp+=s;\\n            uni.push_back(temp);\\n        }\\n\\n        for(int i=0;i<uni.size();i++)\\n            for(int j=i+1;j<uni.size();j++)\\n                if(uni[i]==uni[j])\\n                    counter++;\\n\\n        return counter;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int similarPairs(vector<string>& words) {\\n        \\n        int counter=0;\\n        vector<string> uni;\\n\\n        for(auto w:words){\\n\\n            set<char> st;\\n            for(auto ch:w)\\n                st.insert(ch);\\n                \\n            string temp=\"\";\\n            for(auto s:st)\\n                temp+=s;\\n            uni.push_back(temp);\\n        }\\n\\n        for(int i=0;i<uni.size();i++)\\n            for(int j=i+1;j<uni.size();j++)\\n                if(uni[i]==uni[j])\\n                    counter++;\\n\\n        return counter;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3827920,
                "title": "c-different-solution-using-ncr-approach-to-find-total-number-of-pairs",
                "content": "# Intuition\\nIf we can sort the string and remove the duplicates, we get the key\\n\\n# Approach\\nCreate a dictionary kind of data structure and construct it with the logic of same characters into one list.\\nOnce, you have the dictionary ready iterate each list and find the number of entries in that\\ne.g. Dictionary comes something like\\n\\'ab\\' -> \\'abab\\', \\'abbb\\'\\n\\'abc\\' -> \\'abccc\\', \\'ccbbaa\\'\\n\\'abcd\\' -> \\'abddc\\'\\n\\nNow how many pairs could be form in each list -> nC2 where n is the size of individual list\\n\\nTotal ans = 2C2 + 2C2 + 1C2 = 1 + 1 + 0 = 2\\n\\n\\n# Code\\n```\\npublic class Solution {\\n    public int SimilarPairs(string[] words) {\\n        long ans = 0 ;\\n        Dictionary<string, List<string>> dc = new Dictionary<string, List<string>>();\\n        foreach(string s in words)\\n        {\\n            string sorted_s = String.Concat(s.Distinct().OrderBy(x => x));\\n            if(!dc.ContainsKey(sorted_s))\\n                dc.Add(sorted_s, new List<string>());\\n            dc[sorted_s].Add(s);\\n        }\\n        foreach(KeyValuePair<string, List<string>> kvp in dc)\\n        {\\n            ans += PermutationsAndCombinations.nCr(kvp.Value.Count, 2);\\n        }\\n        return (int)ans;\\n    }\\n}\\n\\npublic static class PermutationsAndCombinations\\n{\\n    public static long nCr(int n, int r)\\n    {\\n        // naive: return Factorial(n) / (Factorial(r) * Factorial(n - r));\\n        return nPr(n, r) / Factorial(r);\\n    }\\n\\n    public static long nPr(int n, int r)\\n    {\\n        // naive: return Factorial(n) / Factorial(n - r);\\n        return FactorialDivision(n, n - r);\\n    }\\n\\n    private static long FactorialDivision(int topFactorial, int divisorFactorial)\\n    {\\n        long result = 1;\\n        for (int i = topFactorial; i > divisorFactorial; i--)\\n            result *= i;\\n        return result;\\n    }\\n\\n    private static long Factorial(int i)\\n    {\\n        if (i <= 1)\\n            return 1;\\n        return i * Factorial(i - 1);\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution {\\n    public int SimilarPairs(string[] words) {\\n        long ans = 0 ;\\n        Dictionary<string, List<string>> dc = new Dictionary<string, List<string>>();\\n        foreach(string s in words)\\n        {\\n            string sorted_s = String.Concat(s.Distinct().OrderBy(x => x));\\n            if(!dc.ContainsKey(sorted_s))\\n                dc.Add(sorted_s, new List<string>());\\n            dc[sorted_s].Add(s);\\n        }\\n        foreach(KeyValuePair<string, List<string>> kvp in dc)\\n        {\\n            ans += PermutationsAndCombinations.nCr(kvp.Value.Count, 2);\\n        }\\n        return (int)ans;\\n    }\\n}\\n\\npublic static class PermutationsAndCombinations\\n{\\n    public static long nCr(int n, int r)\\n    {\\n        // naive: return Factorial(n) / (Factorial(r) * Factorial(n - r));\\n        return nPr(n, r) / Factorial(r);\\n    }\\n\\n    public static long nPr(int n, int r)\\n    {\\n        // naive: return Factorial(n) / Factorial(n - r);\\n        return FactorialDivision(n, n - r);\\n    }\\n\\n    private static long FactorialDivision(int topFactorial, int divisorFactorial)\\n    {\\n        long result = 1;\\n        for (int i = topFactorial; i > divisorFactorial; i--)\\n            result *= i;\\n        return result;\\n    }\\n\\n    private static long Factorial(int i)\\n    {\\n        if (i <= 1)\\n            return 1;\\n        return i * Factorial(i - 1);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3815545,
                "title": "java-easy-solution-using-hashmap",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int similarPairs(String[] words) {\\n       int count=0;\\n       for(int i=0;i<words.length;i++){\\n          TreeSet<Character> set=new TreeSet<>(); \\n          String str=\"\";\\n          for(char ch:words[i].toCharArray()){\\n              set.add(ch);\\n          }  \\n          for(char ch:set){\\n              str+=String.valueOf(ch);\\n          }\\n          words[i]=str;\\n       }\\n       for(int i=0;i<words.length;i++){\\n           for(int j=i+1;j<words.length;j++){\\n               if(words[i].equals(words[j]))\\n                   count++;\\n           }\\n       }\\n       return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int similarPairs(String[] words) {\\n       int count=0;\\n       for(int i=0;i<words.length;i++){\\n          TreeSet<Character> set=new TreeSet<>(); \\n          String str=\"\";\\n          for(char ch:words[i].toCharArray()){\\n              set.add(ch);\\n          }  \\n          for(char ch:set){\\n              str+=String.valueOf(ch);\\n          }\\n          words[i]=str;\\n       }\\n       for(int i=0;i<words.length;i++){\\n           for(int j=i+1;j<words.length;j++){\\n               if(words[i].equals(words[j]))\\n                   count++;\\n           }\\n       }\\n       return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3807277,
                "title": "c-using-bitmasks-97-89",
                "content": "\\n# Approach\\nFirst, we convert each word into a 32-bit value such that the $$i$$th bit is set if the $$i$$th character in the English alphabet is present in the word.\\n\\nThen, we store each of these in a hash table, keys are the 32-bit values, and the value is the number of times it occurs.\\n\\nFinally, we add use the summation formula to calculate how many  pairs we have (we add $$1 + 2 + 3 + 4...+n$$ on every iteration for every pair we encounter, because every $$n$$th new word makes a pair with all the $$n-1$$ previous words).\\n\\n# Complexity\\n- Time complexity:\\n$$O(n \\\\times m)$$\\n\\n- Space complexity:\\n$$O(n)$$\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int similarPairs(vector<string>& words) {\\n        unordered_map<int, int> m;\\n        int ans = 0;\\n        for (auto &word : words) {\\n            unsigned cur = 0;\\n            for (auto &c : word) \\n                cur |= 1UL << (c - \\'a\\');\\n            ans += m[cur]++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Bitmask"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int similarPairs(vector<string>& words) {\\n        unordered_map<int, int> m;\\n        int ans = 0;\\n        for (auto &word : words) {\\n            unsigned cur = 0;\\n            for (auto &c : word) \\n                cur |= 1UL << (c - \\'a\\');\\n            ans += m[cur]++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3806831,
                "title": "easy-c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int similarPairs(vector<string>& w){\\n        int n = w.size();\\n        int count = 0;\\n        for(int i=0;i<n;i++){\\n            set<char> s(w[i].begin(),w[i].end());\\n            string s1(s.begin(),s.end());\\n            w[i] = s1;\\n        }\\n        for(int i =0;i<n-1;i++)\\n            for(int j = i+1; j<n; j++)\\n                if(w[i]==w[j])\\n                    count++;\\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int similarPairs(vector<string>& w){\\n        int n = w.size();\\n        int count = 0;\\n        for(int i=0;i<n;i++){\\n            set<char> s(w[i].begin(),w[i].end());\\n            string s1(s.begin(),s.end());\\n            w[i] = s1;\\n        }\\n        for(int i =0;i<n-1;i++)\\n            for(int j = i+1; j<n; j++)\\n                if(w[i]==w[j])\\n                    count++;\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3806825,
                "title": "easy-c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int similarPairs(vector<string>& w){\\n        int n = w.size();\\n        int count = 0;\\n        for(int i=0;i<n;i++){\\n            set<char> s(w[i].begin(),w[i].end());\\n            string s1(s.begin(),s.end());\\n            w[i] = s1;\\n        }\\n        for(int i =0;i<n-1;i++)\\n            for(int j = i+1; j<n; j++)\\n                if(w[i]==w[j])\\n                    count++;\\n        return count;\\n    }\\n};\\n\\n\\n\\n// class Solution {\\n// public:\\n//     int similarPairs(vector<string>& words) {\\n\\n//         vector<string> newStrings;\\n//         for(auto word: words)\\n//         {\\n//             set<char> temp;\\n//             for(auto ch: word)\\n//              {\\n//                     temp.insert(ch);\\n//              }\\n//              string s=\"\";\\n//              for(auto i: temp)\\n//                s+=i;\\n\\n//              newStrings.push_back(s);\\n//         }\\n// int max=0;\\n\\n//     for(int i=0; i< newStrings.size()-1; i++)\\n//        {  int count=1;\\n//            for(int j=i+1; j<newStrings.size(); j++)\\n//            {\\n//                if(newStrings[i]==newStrings[j])\\n//                count++;\\n//            }\\n//            if(max < count) max=count;\\n//        }\\n//        if(max>1)\\n//        return max;\\n//        return 0;\\n//     }\\n// };\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int similarPairs(vector<string>& w){\\n        int n = w.size();\\n        int count = 0;\\n        for(int i=0;i<n;i++){\\n            set<char> s(w[i].begin(),w[i].end());\\n            string s1(s.begin(),s.end());\\n            w[i] = s1;\\n        }\\n        for(int i =0;i<n-1;i++)\\n            for(int j = i+1; j<n; j++)\\n                if(w[i]==w[j])\\n                    count++;\\n        return count;\\n    }\\n};\\n\\n\\n\\n// class Solution {\\n// public:\\n//     int similarPairs(vector<string>& words) {\\n\\n//         vector<string> newStrings;\\n//         for(auto word: words)\\n//         {\\n//             set<char> temp;\\n//             for(auto ch: word)\\n//              {\\n//                     temp.insert(ch);\\n//              }\\n//              string s=\"\";\\n//              for(auto i: temp)\\n//                s+=i;\\n\\n//              newStrings.push_back(s);\\n//         }\\n// int max=0;\\n\\n//     for(int i=0; i< newStrings.size()-1; i++)\\n//        {  int count=1;\\n//            for(int j=i+1; j<newStrings.size(); j++)\\n//            {\\n//                if(newStrings[i]==newStrings[j])\\n//                count++;\\n//            }\\n//            if(max < count) max=count;\\n//        }\\n//        if(max>1)\\n//        return max;\\n//        return 0;\\n//     }\\n// };\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3799948,
                "title": "c-simple-brute-force-unordered-set",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int similarPairs(vector<string>& words) {\\n        int n  = words.size();\\n        int pairs=0;\\n        for(int i=0; i<n; i++)\\n        {\\n            unordered_set<char> st1;\\n            for(auto ch:words[i])\\n            {\\n                st1.insert(ch);\\n            }\\n\\n\\n            for(int j=i+1; j<n; j++)\\n            {\\n                unordered_set<char> st2;\\n                for(auto ch:words[j])\\n                {\\n                    st2.insert(ch);\\n                }\\n\\n\\n                if(st1 == st2) pairs++;\\n            }\\n        }\\n        return pairs;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int similarPairs(vector<string>& words) {\\n        int n  = words.size();\\n        int pairs=0;\\n        for(int i=0; i<n; i++)\\n        {\\n            unordered_set<char> st1;\\n            for(auto ch:words[i])\\n            {\\n                st1.insert(ch);\\n            }\\n\\n\\n            for(int j=i+1; j<n; j++)\\n            {\\n                unordered_set<char> st2;\\n                for(auto ch:words[j])\\n                {\\n                    st2.insert(ch);\\n                }\\n\\n\\n                if(st1 == st2) pairs++;\\n            }\\n        }\\n        return pairs;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3799656,
                "title": "easy-c-solution-sort-map",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string getUniqueOrdered(string s)\\n    {\\n        string ans = \"\";\\n        sort(s.begin(),s.end());\\n        ans += s[0];\\n        int j = 0;\\n        for(int i=1;i<s.length();i++)\\n        {\\n            if(ans[j]!=s[i])\\n            {\\n                ans+=s[i];\\n                j++;\\n            }\\n        }\\n        return ans;\\n    }\\n   \\n    int similarPairs(vector<string>& words) {\\n        map<string,int> m;\\n        int count = 0;\\n        for(int i=0;i<words.size();i++)\\n        {\\n            string temp = getUniqueOrdered(words[i]);\\n            m[temp]++;\\n        }\\n\\n        for(auto i:m)\\n        {\\n            int n = i.second;\\n            count += (n * (n-1)/2);\\n           \\n        }\\n        \\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string getUniqueOrdered(string s)\\n    {\\n        string ans = \"\";\\n        sort(s.begin(),s.end());\\n        ans += s[0];\\n        int j = 0;\\n        for(int i=1;i<s.length();i++)\\n        {\\n            if(ans[j]!=s[i])\\n            {\\n                ans+=s[i];\\n                j++;\\n            }\\n        }\\n        return ans;\\n    }\\n   \\n    int similarPairs(vector<string>& words) {\\n        map<string,int> m;\\n        int count = 0;\\n        for(int i=0;i<words.size();i++)\\n        {\\n            string temp = getUniqueOrdered(words[i]);\\n            m[temp]++;\\n        }\\n\\n        for(auto i:m)\\n        {\\n            int n = i.second;\\n            count += (n * (n-1)/2);\\n           \\n        }\\n        \\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3784342,
                "title": "c-solution-using-hash-table-explained",
                "content": "\\n# Code\\n```\\nclass Solution {\\n    int total_pairs(int n) {\\n        // formula to calculate sum of \\'n\\' natural numbers = Sn => n(n+1)/2\\n        // we want to calculate sum of \\'n - 1\\' natural numbers, so\\n        int sum = ((n - 1) * (n)) / 2;\\n        return sum;\\n    }\\npublic:\\n    int similarPairs(vector<string>& words) {\\n        int count = 0;\\n        map<set<char>, int> mp; // getting number of words with similar charracters\\n        for(auto i : words) {\\n            set<char> st(i.begin(), i.end());\\n            mp[st]++;\\n        }\\n\\n        // {word_count -> pair}\\n        // 2 -> 1\\n        // 3 -> 3\\n        // 4 -> 6\\n        // 5 -> 10\\n        // 6 -> 15\\n        \\n        // in this sequence, each term is obtained by summing the numbers from 1  to (n - 1), where n is the position of the term in the sequence.\\n\\n        // Let\\'s verify the pattern:\\n\\n        // 2 -> Sum of numbers from 1 to (2 - 1) = 1\\n        // 3 -> Sum of numbers from 1 to (3 - 1) = 3\\n        // 4 -> Sum of numbers from 1 to (4 - 1) = 6\\n        // 5 -> Sum of numbers from 1 to (5 - 1) = 10\\n        // 6 -> Sum of numbers from 1 to (6 - 1) = 15\\n        // and so on...\\n\\n        for(auto i : mp) {\\n            if(i.second > 1) {\\n                count += total_pairs(i.second);\\n            }\\n        }\\n\\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Hash Table",
                    "String",
                    "Ordered Set"
                ],
                "code": "```\\nclass Solution {\\n    int total_pairs(int n) {\\n        // formula to calculate sum of \\'n\\' natural numbers = Sn => n(n+1)/2\\n        // we want to calculate sum of \\'n - 1\\' natural numbers, so\\n        int sum = ((n - 1) * (n)) / 2;\\n        return sum;\\n    }\\npublic:\\n    int similarPairs(vector<string>& words) {\\n        int count = 0;\\n        map<set<char>, int> mp; // getting number of words with similar charracters\\n        for(auto i : words) {\\n            set<char> st(i.begin(), i.end());\\n            mp[st]++;\\n        }\\n\\n        // {word_count -> pair}\\n        // 2 -> 1\\n        // 3 -> 3\\n        // 4 -> 6\\n        // 5 -> 10\\n        // 6 -> 15\\n        \\n        // in this sequence, each term is obtained by summing the numbers from 1  to (n - 1), where n is the position of the term in the sequence.\\n\\n        // Let\\'s verify the pattern:\\n\\n        // 2 -> Sum of numbers from 1 to (2 - 1) = 1\\n        // 3 -> Sum of numbers from 1 to (3 - 1) = 3\\n        // 4 -> Sum of numbers from 1 to (4 - 1) = 6\\n        // 5 -> Sum of numbers from 1 to (5 - 1) = 10\\n        // 6 -> Sum of numbers from 1 to (6 - 1) = 15\\n        // and so on...\\n\\n        for(auto i : mp) {\\n            if(i.second > 1) {\\n                count += total_pairs(i.second);\\n            }\\n        }\\n\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3784065,
                "title": "c-brute-force",
                "content": "\\n# Complexity\\n- Time complexity: $$O(n\\xB2 * m)$$\\nn = size of array\\nm = size of uniques characters in a word\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(m)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int similarPairs(vector<string>& words) {\\n        int count = 0;\\n        for(int i = 0; i < words.size()-1; i++) {\\n            unordered_set<char> s1(words[i].begin(), words[i].end());\\n            for(int j = i + 1; j < words.size(); j++) {\\n                unordered_set<char> s2(words[j].begin(), words[j].end());\\n                if(s1 == s2) count++;\\n            }\\n        }\\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Hash Table",
                    "String"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int similarPairs(vector<string>& words) {\\n        int count = 0;\\n        for(int i = 0; i < words.size()-1; i++) {\\n            unordered_set<char> s1(words[i].begin(), words[i].end());\\n            for(int j = i + 1; j < words.size(); j++) {\\n                unordered_set<char> s2(words[j].begin(), words[j].end());\\n                if(s1 == s2) count++;\\n            }\\n        }\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3783099,
                "title": "c-easy-explanatory-comments-set-maps",
                "content": "```\\nclass Solution {\\npublic:\\n    int similarPairs(vector<string>& words) {\\n        map<set<int>,int> mp;\\n        int len=0;\\n        for(auto i:words){\\n            set<int> a;\\n            for(auto j:i) a.insert(j);\\n            if(mp.count(a)) {\\n\\t\\t\\t// the current we are dealing now will form mp[a] pairs ..so len += mp[a]\\n                len+=mp[a];\\n                mp[a]++;\\n            }\\n            else mp[a]++;\\n        }\\n        return len;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Ordered Set"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int similarPairs(vector<string>& words) {\\n        map<set<int>,int> mp;\\n        int len=0;\\n        for(auto i:words){\\n            set<int> a;\\n            for(auto j:i) a.insert(j);\\n            if(mp.count(a)) {\\n\\t\\t\\t// the current we are dealing now will form mp[a] pairs ..so len += mp[a]\\n                len+=mp[a];\\n                mp[a]++;\\n            }\\n            else mp[a]++;\\n        }\\n        return len;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3777819,
                "title": "easy-javascript-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {string[]} words\\n * @return {number}\\n */\\nvar similarPairs = function(words) {\\n    let uniqArr =[];\\n    uniqArr = words.map(word => {\\n        return [...new Set(word)].sort().join(\"\");\\n    });\\n\\n    let pairs = 0;\\n    for (let i=0;i< uniqArr.length;i++) {\\n        for (let j=i+1; j< uniqArr.length;j++) {\\n            if(uniqArr[i] === uniqArr[j]) {\\n                pairs++;\\n            }\\n        }    \\n    }\\n\\n    return pairs;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {string[]} words\\n * @return {number}\\n */\\nvar similarPairs = function(words) {\\n    let uniqArr =[];\\n    uniqArr = words.map(word => {\\n        return [...new Set(word)].sort().join(\"\");\\n    });\\n\\n    let pairs = 0;\\n    for (let i=0;i< uniqArr.length;i++) {\\n        for (let j=i+1; j< uniqArr.length;j++) {\\n            if(uniqArr[i] === uniqArr[j]) {\\n                pairs++;\\n            }\\n        }    \\n    }\\n\\n    return pairs;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3749454,
                "title": "easy-solution-and-understandable",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. --> \\n\\n# Complexity\\n- Time complexity:$$O(n*n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:$$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int similarPairs(String[] words) {\\n        List<String> list = new ArrayList<>();\\n        int count =0 ;\\n        for(int i=0;i<words.length-1;i++){\\n            String str = stringWords(words[i]);\\n           for(int j=i+1;j<words.length;j++){\\n               String str2 = stringWords(words[j]);\\n               if(str.equals(str2)){\\n                   count++;\\n               }\\n           }\\n        }\\n        return count;\\n    }\\n    public static String stringWords(String s){\\n        char[] ch = s.toCharArray();\\n        Arrays.sort(ch);\\n        Set<Character> set = new HashSet<>();\\n\\n        for(char c: ch){\\n            set.add(c);\\n        }\\n        List<Character> list = new ArrayList<>(set);\\n        String str = \"\";\\n        for(int i=0;i<set.size();i++){\\n            str += list.get(i);\\n        }\\n        return str;\\n    }\\n    // public boolean isCompare(String s1,String s2){\\n    //     int s = Math.min(s1.length(),s2.length());\\n    //     for(int i=0;i<s;i++){\\n    //         if(!s2.contains(\"\"+s1.charAt(i))){\\n    //             return false;\\n    //         }\\n    //     }\\n    //     return true;\\n    // }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Hash Table"
                ],
                "code": "```\\nclass Solution {\\n    public int similarPairs(String[] words) {\\n        List<String> list = new ArrayList<>();\\n        int count =0 ;\\n        for(int i=0;i<words.length-1;i++){\\n            String str = stringWords(words[i]);\\n           for(int j=i+1;j<words.length;j++){\\n               String str2 = stringWords(words[j]);\\n               if(str.equals(str2)){\\n                   count++;\\n               }\\n           }\\n        }\\n        return count;\\n    }\\n    public static String stringWords(String s){\\n        char[] ch = s.toCharArray();\\n        Arrays.sort(ch);\\n        Set<Character> set = new HashSet<>();\\n\\n        for(char c: ch){\\n            set.add(c);\\n        }\\n        List<Character> list = new ArrayList<>(set);\\n        String str = \"\";\\n        for(int i=0;i<set.size();i++){\\n            str += list.get(i);\\n        }\\n        return str;\\n    }\\n    // public boolean isCompare(String s1,String s2){\\n    //     int s = Math.min(s1.length(),s2.length());\\n    //     for(int i=0;i<s;i++){\\n    //         if(!s2.contains(\"\"+s1.charAt(i))){\\n    //             return false;\\n    //         }\\n    //     }\\n    //     return true;\\n    // }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3739950,
                "title": "c-easy-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int similarPairs(vector<string>&w){\\n        vector<string>v;\\n        for(auto i:w){\\n            set<char>st;\\n            string s;\\n            for(auto j:i){\\n                st.insert(j);\\n            }\\n            for(auto j:st){\\n                s+=j;\\n            }\\n            v.push_back(s);\\n        }\\n        int c=0;\\n        for(int i=0; i<v.size()-1; i++){\\n            for(int j=i+1; j<v.size(); j++){\\n                if(v[i]==v[j]){\\n                    c++;\\n                }\\n            }\\n        }\\n        return c;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int similarPairs(vector<string>&w){\\n        vector<string>v;\\n        for(auto i:w){\\n            set<char>st;\\n            string s;\\n            for(auto j:i){\\n                st.insert(j);\\n            }\\n            for(auto j:st){\\n                s+=j;\\n            }\\n            v.push_back(s);\\n        }\\n        int c=0;\\n        for(int i=0; i<v.size()-1; i++){\\n            for(int j=i+1; j<v.size(); j++){\\n                if(v[i]==v[j]){\\n                    c++;\\n                }\\n            }\\n        }\\n        return c;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3739324,
                "title": "c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nI thought to first sort the given vector and then iterate over whole vector and on each string, I thought to put all its elements in set, so that I will have only unique chars. Then I thought to run two loops and check for strings which are same.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nSame as Intutiom\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(words.size()^2)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(st.size()) ---> not sure, please correct me if someone can!!\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int similarPairs(vector<string>& words) {\\n        int ans=0;\\n        for(int i=0;i<words.size();i++)\\n        {\\n            sort(words[i].begin(),words[i].end());   \\n        }\\n\\n        for(int i=0;i<words.size();i++)\\n        {\\n            set<char>st;\\n            for(int j=0;j<words[i].length();j++)\\n            {\\n                st.insert(words[i][j]);\\n            }\\n\\n            string str=\"\";\\n            for(auto it=st.begin();it!=st.end();it++)\\n                {\\n                    str+=*it;\\n                }\\n            words[i]=str;\\n        }\\n\\n        for(int i=0;i<words.size();i++)\\n        {\\n            for(int j=i+1;j<words.size();j++)\\n            {\\n                if(words[i]==words[j])\\n                    ans++;\\n            }\\n\\n        }\\n\\n        return ans;\\n  }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int similarPairs(vector<string>& words) {\\n        int ans=0;\\n        for(int i=0;i<words.size();i++)\\n        {\\n            sort(words[i].begin(),words[i].end());   \\n        }\\n\\n        for(int i=0;i<words.size();i++)\\n        {\\n            set<char>st;\\n            for(int j=0;j<words[i].length();j++)\\n            {\\n                st.insert(words[i][j]);\\n            }\\n\\n            string str=\"\";\\n            for(auto it=st.begin();it!=st.end();it++)\\n                {\\n                    str+=*it;\\n                }\\n            words[i]=str;\\n        }\\n\\n        for(int i=0;i<words.size();i++)\\n        {\\n            for(int j=i+1;j<words.size();j++)\\n            {\\n                if(words[i]==words[j])\\n                    ans++;\\n            }\\n\\n        }\\n\\n        return ans;\\n  }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3729196,
                "title": "hashed-value-o-n-java-hashmap",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\nInstead of looping over all pairs in the trivial approach, we generate a hash for each string representing its equality to its compared pairs. We store each \"category\" of hashes in a map for O(1) access, then summ the pairs at the end.\\n\\n# Complexity\\n- Time complexity: $O(n)$ where $n$ is the amount of words.\\n\\n- Space complexity: $O(n)$\\n\\n# Code\\n```\\nclass Solution {\\n    public int similarPairs(String[] words) {\\n        Map<String, Integer> counts = new HashMap<>();\\n\\n        for (String word : words) {\\n            String h = computeHash(word);\\n            counts.put(h, counts.getOrDefault(h, 0) + 1);\\n            System.out.println(h);\\n        }\\n\\n        int sum = 0;\\n        for (int c : counts.values())\\n            sum += pairs(c);\\n        \\n        return sum;\\n    }\\n\\n    private int pairs(int n) {\\n        // n Choose 2\\n        return n * (n - 1) / 2;\\n    }\\n\\n    private String computeHash(String s) {\\n        boolean[] a = new boolean[26];\\n        for (char c : s.toCharArray()) {\\n            a[c - \\'a\\'] = true;\\n        }\\n\\n        StringBuilder sb = new StringBuilder();\\n        for (int i = 0; i < 26; i++)\\n            if (a[i])\\n                sb.append((char)(\\'a\\' + i));\\n        return sb.toString();\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Hash Table",
                    "String",
                    "Hash Function"
                ],
                "code": "```\\nclass Solution {\\n    public int similarPairs(String[] words) {\\n        Map<String, Integer> counts = new HashMap<>();\\n\\n        for (String word : words) {\\n            String h = computeHash(word);\\n            counts.put(h, counts.getOrDefault(h, 0) + 1);\\n            System.out.println(h);\\n        }\\n\\n        int sum = 0;\\n        for (int c : counts.values())\\n            sum += pairs(c);\\n        \\n        return sum;\\n    }\\n\\n    private int pairs(int n) {\\n        // n Choose 2\\n        return n * (n - 1) / 2;\\n    }\\n\\n    private String computeHash(String s) {\\n        boolean[] a = new boolean[26];\\n        for (char c : s.toCharArray()) {\\n            a[c - \\'a\\'] = true;\\n        }\\n\\n        StringBuilder sb = new StringBuilder();\\n        for (int i = 0; i < 26; i++)\\n            if (a[i])\\n                sb.append((char)(\\'a\\' + i));\\n        return sb.toString();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3717945,
                "title": "using-set",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    func similarPairs(_ words: [String]) -> Int {\\n        var count = 0\\n        for i in 0..<words.count-1{\\n            for j in i+1..<words.count{\\n                if Set(words[i]) == Set(words[j]){\\n                    count += 1\\n                }\\n            }\\n        }\\n        return count\\n    }\\n}\\n```",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nclass Solution {\\n    func similarPairs(_ words: [String]) -> Int {\\n        var count = 0\\n        for i in 0..<words.count-1{\\n            for j in i+1..<words.count{\\n                if Set(words[i]) == Set(words[j]){\\n                    count += 1\\n                }\\n            }\\n        }\\n        return count\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3705908,
                "title": "java-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int similarPairs(String[] words) {\\n        int count=0,n=words.length;\\n        int[][] wordArray = new int[n][26];\\n        for(int row=0;row<n;row++){\\n            for(int step=0;step<words[row].length();step++){\\n                int column = words[row].charAt(step)-\\'a\\';\\n                if(wordArray[row][column]==0){\\n                    wordArray[row][column]++;\\n                }\\n            }           \\n        }\\n        for(int i=0;i<n;i++){\\n            for(int j=i+1;j<n;j++){\\n                count = Arrays.equals(wordArray[i],wordArray[j]) ? count+1 : count;\\n            }\\n        }\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int similarPairs(String[] words) {\\n        int count=0,n=words.length;\\n        int[][] wordArray = new int[n][26];\\n        for(int row=0;row<n;row++){\\n            for(int step=0;step<words[row].length();step++){\\n                int column = words[row].charAt(step)-\\'a\\';\\n                if(wordArray[row][column]==0){\\n                    wordArray[row][column]++;\\n                }\\n            }           \\n        }\\n        for(int i=0;i<n;i++){\\n            for(int j=i+1;j<n;j++){\\n                count = Arrays.equals(wordArray[i],wordArray[j]) ? count+1 : count;\\n            }\\n        }\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3704998,
                "title": "direct-approach-using-hashset-bitmask",
                "content": "# Intuition\\nFind all sets of similar strings.\\nCount pairs use formula C(n, 2) = (n-1)*n/2.\\n\\n# Approach\\n1. Using dictionary to store sets parameters.\\n2. Using bitmask approach to store HashSet<char> as a number. (Better to fill bitmask without using HashSet itself, you can update the code yourself).\\n3. Fill the dictionary going through the array.\\n4. Count the answer.\\n \\n# Complexity\\n- Time complexity: O(n+k), where k is a number of not similar string sets.\\n- Space complexity: O(k).\\n\\n# Code\\n```\\npublic class Solution {\\n    private const int _start = 97;\\n    // A-Z - 65-90\\n    // a-z - 97-122\\n\\n    public int SimilarPairs(string[] words) {\\n        var dictHash = new Dictionary<int, int>();\\n        int ans = 0;\\n        for (int i=0; i<words.Length; i++) {\\n            int hs = SetHS(words[i]);\\n            if (dictHash.ContainsKey(hs))\\n                dictHash[hs]++;\\n            else dictHash.Add(hs,1); \\n        }\\n        // count ans\\n        foreach (var pair in dictHash) \\n            ans += (pair.Value-1)*pair.Value / 2;\\n\\n        return ans;\\n    }\\n\\n    private int SetHS(string word) {\\n        var hs = new HashSet<char>(word);\\n        // using bitmask to store letters from the string\\n        int ret = 0;\\n        foreach (char ch in hs) {\\n            int plus = 1 << (ch - _start);\\n            ret += plus;\\n        }\\n        return ret;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#",
                    "Hash Table",
                    "Bitmask"
                ],
                "code": "```\\npublic class Solution {\\n    private const int _start = 97;\\n    // A-Z - 65-90\\n    // a-z - 97-122\\n\\n    public int SimilarPairs(string[] words) {\\n        var dictHash = new Dictionary<int, int>();\\n        int ans = 0;\\n        for (int i=0; i<words.Length; i++) {\\n            int hs = SetHS(words[i]);\\n            if (dictHash.ContainsKey(hs))\\n                dictHash[hs]++;\\n            else dictHash.Add(hs,1); \\n        }\\n        // count ans\\n        foreach (var pair in dictHash) \\n            ans += (pair.Value-1)*pair.Value / 2;\\n\\n        return ans;\\n    }\\n\\n    private int SetHS(string word) {\\n        var hs = new HashSet<char>(word);\\n        // using bitmask to store letters from the string\\n        int ret = 0;\\n        foreach (char ch in hs) {\\n            int plus = 1 << (ch - _start);\\n            ret += plus;\\n        }\\n        return ret;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3701504,
                "title": "easy-java-solution-set",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int similarPairs(String[] words) {\\n        int count=0;\\n        for(int i=0;i<words.length-1;i++){\\n          Set<Character> ith=new HashSet<>();\\n          for(int j=0;j<words[i].length();j++){\\n              ith.add(words[i].charAt(j));\\n          }\\n             for(int m=i+1;m<words.length;m++){\\n               Set<Character> mth=new HashSet<>();\\n                for(int k=0;k<words[m].length();k++){\\n                  mth.add(words[m].charAt(k));\\n                }\\n                if(ith.equals(mth)){\\n                  count++;\\n                }\\n               \\n            }\\n        }\\n      return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int similarPairs(String[] words) {\\n        int count=0;\\n        for(int i=0;i<words.length-1;i++){\\n          Set<Character> ith=new HashSet<>();\\n          for(int j=0;j<words[i].length();j++){\\n              ith.add(words[i].charAt(j));\\n          }\\n             for(int m=i+1;m<words.length;m++){\\n               Set<Character> mth=new HashSet<>();\\n                for(int k=0;k<words[m].length();k++){\\n                  mth.add(words[m].charAt(k));\\n                }\\n                if(ith.equals(mth)){\\n                  count++;\\n                }\\n               \\n            }\\n        }\\n      return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3701501,
                "title": "easy-solution-javascript",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {string[]} words\\n * @return {number}\\n */\\nfunction areequal(set1, set2) {\\n    if (set1.size !== set2.size) {\\n        return false;\\n    }\\n    \\n    for (let char of set1) {\\n        if (!set2.has(char)) {\\n            return false;\\n        }\\n    }\\n    \\n    return true;\\n}\\nvar similarPairs = function(words) {\\n    var count=0;\\n    for(var i =0;i<words.length;i++){\\n        var str=words[i];\\n        var strToArr1 = (str) => str.split(\"\");\\n        var strToSet1 = (str) => new Set(strToArr1(str));\\n        var set1 = strToSet1(str);\\n      for(var j=i+1;j<words.length;j++)\\n      {\\n        var str2=words[j];\\n        var strToArr2 = (str2) => str2.split(\"\");\\n        var strToSet2 = (str2) => new Set(strToArr2(str2));\\n        var set2= strToSet2(str2);\\n        if(areequal(set1,set2))\\n        {\\n            count++;\\n        }\\n      }  \\n    }\\n    return count;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {string[]} words\\n * @return {number}\\n */\\nfunction areequal(set1, set2) {\\n    if (set1.size !== set2.size) {\\n        return false;\\n    }\\n    \\n    for (let char of set1) {\\n        if (!set2.has(char)) {\\n            return false;\\n        }\\n    }\\n    \\n    return true;\\n}\\nvar similarPairs = function(words) {\\n    var count=0;\\n    for(var i =0;i<words.length;i++){\\n        var str=words[i];\\n        var strToArr1 = (str) => str.split(\"\");\\n        var strToSet1 = (str) => new Set(strToArr1(str));\\n        var set1 = strToSet1(str);\\n      for(var j=i+1;j<words.length;j++)\\n      {\\n        var str2=words[j];\\n        var strToArr2 = (str2) => str2.split(\"\");\\n        var strToSet2 = (str2) => new Set(strToArr2(str2));\\n        var set2= strToSet2(str2);\\n        if(areequal(set1,set2))\\n        {\\n            count++;\\n        }\\n      }  \\n    }\\n    return count;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3692430,
                "title": "c-simplest-solution-using-hashmap",
                "content": "# Complexity\\n- Time complexity:\\nO(n * n * m) **where n is length of words and m is length of string.**\\n\\n- Space complexity:\\nO(n)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int similarPairs(vector<string>& words) {\\n\\n        int ans = 0;\\n\\n        for(int i=0; i<words.size(); i++) {\\n            map<char, int> mp1;\\n            for(int k=0; k<words[i].size(); k++)\\n                    if(mp1[words[i][k]] == 0) \\n                        mp1[words[i][k]]++;\\n            for(int j=i+1; j<words.size(); j++) {\\n                map<char, int> mp2;\\n                for(int k=0; k<words[j].size(); k++)\\n                    if(mp2[words[j][k]] == 0) \\n                        mp2[words[j][k]]++;\\n                if(mp1 == mp2) ans++;\\n            }\\n        }\\n\\n        return ans;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Hash Table",
                    "String"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int similarPairs(vector<string>& words) {\\n\\n        int ans = 0;\\n\\n        for(int i=0; i<words.size(); i++) {\\n            map<char, int> mp1;\\n            for(int k=0; k<words[i].size(); k++)\\n                    if(mp1[words[i][k]] == 0) \\n                        mp1[words[i][k]]++;\\n            for(int j=i+1; j<words.size(); j++) {\\n                map<char, int> mp2;\\n                for(int k=0; k<words[j].size(); k++)\\n                    if(mp2[words[j][k]] == 0) \\n                        mp2[words[j][k]]++;\\n                if(mp1 == mp2) ans++;\\n            }\\n        }\\n\\n        return ans;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3690127,
                "title": "java-very-easy-to-understand-solution",
                "content": "\\n# Code\\n```\\nclass Solution {\\n    public int similarPairs(String[] words) {\\n        int len = words.length;\\n        int ans = 0;\\n        for(int i = 0; i<len; i++)\\n        {\\n            for(int j = i+1; j<len; j++)\\n            {\\n               // counting the number of similar string in ans \\n                if(isSimilar(words[i],words[j])) ans++;\\n            }\\n        }\\n        return ans;\\n    }\\n   // additional function for checking similar string\\n    public boolean isSimilar(String a,String b)\\n    {\\n        for(int i=0; i<a.length(); i++)\\n        {\\n            // \"\" + a.charAt(i)  is to make char as string\\n            if(!b.contains(\"\" + a.charAt(i))) return false; \\n        }\\n        for(int i=0; i<b.length(); i++)\\n        {\\n            // \"\" + a.charAt(i)  is to make char as string\\n            if(!a.contains(\"\" + b.charAt(i))) return false;\\n        }\\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int similarPairs(String[] words) {\\n        int len = words.length;\\n        int ans = 0;\\n        for(int i = 0; i<len; i++)\\n        {\\n            for(int j = i+1; j<len; j++)\\n            {\\n               // counting the number of similar string in ans \\n                if(isSimilar(words[i],words[j])) ans++;\\n            }\\n        }\\n        return ans;\\n    }\\n   // additional function for checking similar string\\n    public boolean isSimilar(String a,String b)\\n    {\\n        for(int i=0; i<a.length(); i++)\\n        {\\n            // \"\" + a.charAt(i)  is to make char as string\\n            if(!b.contains(\"\" + a.charAt(i))) return false; \\n        }\\n        for(int i=0; i<b.length(); i++)\\n        {\\n            // \"\" + a.charAt(i)  is to make char as string\\n            if(!a.contains(\"\" + b.charAt(i))) return false;\\n        }\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3658357,
                "title": "one-liner-97-faster",
                "content": "# Intuition\\nUse Counter\\n\\n# Complexity\\n- Time complexity: $$O(n)$$\\n\\n- Space complexity: $$O(n)$$\\n\\nIf you like it, please up-vote. Thank you!\\n\\n# Code\\n```\\nclass Solution:\\n    def similarPairs(self, words: List[str]) -> int:\\n        return sum((c*(c-1))>>1 for c in Counter([frozenset(w) for w in words]).values())\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def similarPairs(self, words: List[str]) -> int:\\n        return sum((c*(c-1))>>1 for c in Counter([frozenset(w) for w in words]).values())\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3654204,
                "title": "easy-to-understand-with-sets",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def similarPairs(self, words: List[str]) -> int:\\n        i = 0\\n        for w in range(len(words)):\\n            for j in range(w):\\n                if set(words[w]) == set(words[j]):\\n                    i +=1\\n\\n        return i\\n\\n            \\n\\n\\n```",
                "solutionTags": [
                    "Python3",
                    "Ordered Set"
                ],
                "code": "```\\nclass Solution:\\n    def similarPairs(self, words: List[str]) -> int:\\n        i = 0\\n        for w in range(len(words)):\\n            for j in range(w):\\n                if set(words[w]) == set(words[j]):\\n                    i +=1\\n\\n        return i\\n\\n            \\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3639265,
                "title": "o-1-space-complexity-using-c-stl",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int similarPairs(vector<string>& words) {\\n        int cnt=0;\\n        for(int i=0;i<words.size();i++)\\n        {\\n            string vec=words[i];\\n            sort( vec.begin(), vec.end() );\\n            vec.erase( unique( vec.begin(), vec.end() ), vec.end() );\\n         \\n            for(int j=i+1;j<words.size();j++)\\n            {\\n                string vec1=words[j];\\n            sort( vec1.begin(), vec1.end() );\\n            vec1.erase( unique( vec1.begin(), vec1.end() ), vec1.end() );\\n                \\n                if(vec1==vec)\\n                    cnt++;\\n                 \\n            }\\n            \\n        }\\n        return cnt;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int similarPairs(vector<string>& words) {\\n        int cnt=0;\\n        for(int i=0;i<words.size();i++)\\n        {\\n            string vec=words[i];\\n            sort( vec.begin(), vec.end() );\\n            vec.erase( unique( vec.begin(), vec.end() ), vec.end() );\\n         \\n            for(int j=i+1;j<words.size();j++)\\n            {\\n                string vec1=words[j];\\n            sort( vec1.begin(), vec1.end() );\\n            vec1.erase( unique( vec1.begin(), vec1.end() ), vec1.end() );\\n                \\n                if(vec1==vec)\\n                    cnt++;\\n                 \\n            }\\n            \\n        }\\n        return cnt;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3636777,
                "title": "c-not-easy",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int similarPairs(vector<string>& words) {\\n        \\n             \\n        int n = words.size();\\n        \\n        map<char, int> maps[n];\\n        \\n        for(int i=0; i<n; i++){\\n            \\n            string temp = words[i];\\n            for(int j=0; j<temp.length(); j++){\\n                \\n                maps[i][temp[j]] = 1;\\n                \\n            }\\n            \\n        }\\n        \\n        int ans = 0;\\n        \\n        for(int i=0; i<n; i++){\\n            \\n            for(int j=i+1; j<n; j++){\\n                \\n                if(maps[i] == maps[j]){\\n                    ans++;\\n                }\\n                \\n            }\\n            \\n        }\\n        \\n        return ans;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int similarPairs(vector<string>& words) {\\n        \\n             \\n        int n = words.size();\\n        \\n        map<char, int> maps[n];\\n        \\n        for(int i=0; i<n; i++){\\n            \\n            string temp = words[i];\\n            for(int j=0; j<temp.length(); j++){\\n                \\n                maps[i][temp[j]] = 1;\\n                \\n            }\\n            \\n        }\\n        \\n        int ans = 0;\\n        \\n        for(int i=0; i<n; i++){\\n            \\n            for(int j=i+1; j<n; j++){\\n                \\n                if(maps[i] == maps[j]){\\n                    ans++;\\n                }\\n                \\n            }\\n            \\n        }\\n        \\n        return ans;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3622870,
                "title": "factorial",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def similarPairs(self, words: List[str]) -> int:\\n        result = 0\\n        temp = []\\n        from math import factorial as f\\n        for i in range(len(words)):\\n            words[i] = list(set(words[i]))\\n            words[i].sort()\\n        for w in words:\\n            if w in temp:\\n                continue\\n            n = words.count(w)\\n            if n < 2:\\n                continue\\n            result += f(n) / (f(2)*f(n-2))\\n            temp.append(w)\\n        return int(result)\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def similarPairs(self, words: List[str]) -> int:\\n        result = 0\\n        temp = []\\n        from math import factorial as f\\n        for i in range(len(words)):\\n            words[i] = list(set(words[i]))\\n            words[i].sort()\\n        for w in words:\\n            if w in temp:\\n                continue\\n            n = words.count(w)\\n            if n < 2:\\n                continue\\n            result += f(n) / (f(2)*f(n-2))\\n            temp.append(w)\\n        return int(result)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3622668,
                "title": "java-solution-using-map-and-combinations-23ms",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\nHere we use a counting map to keep track of the amount of each **\"similar set\"**.\\nThen we get the number of valid combinations of pairs in the value set.\\n\\nThe math formula to calculate the number of pairs (i, j) such that `0 <= i < j <= words.length - 1` can be determined using combinatorics.\\n\\nThe total number of possible pairs of indices (i, j) without any restrictions is given by the combination formula, denoted as $$C(n, r)$$, where n represents the total number of elements (length of the sequence) and r represents the number of elements to choose (2 in this case for pairs). The formula for combination is:\\n\\n$$C(n, r) = n! / (r!(n - r)!)$$\\n\\nHowever, in this case, we need to subtract the pairs where i is equal to j. So the formula becomes:\\n\\n$$C(n, r) - C(n, 1)$$\\n\\nSimplifying further, we get:\\n\\n$$n! / (r!(n - r)!) - n$$\\n\\nSo, the formula to calculate the number of pairs (i, j) such that `0 <= i < j <= words.length - 1` is:\\n\\n$$n! / (2!(n - 2)!) - n$$\\n\\nor equivalently:\\n\\n$$n(n - 1) / 2$$\\n\\n# Code\\n```\\nclass Solution {\\n    public int similarPairs(String[] words) {\\n        Map<Set<Character>, Integer> map = new HashMap<>();\\n        for (String s: words) {\\n            Set<Character> cSet = new HashSet<>();\\n            for (char c: s.toCharArray()) {\\n                cSet.add(c);\\n            }\\n            map.put(cSet, map.getOrDefault(cSet, 0) + 1);\\n        }\\n        int n = 0;\\n        for (Integer v: map.values()) {\\n            n += v * (v - 1) / 2;\\n        }\\n        return n;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Hash Table"
                ],
                "code": "```\\nclass Solution {\\n    public int similarPairs(String[] words) {\\n        Map<Set<Character>, Integer> map = new HashMap<>();\\n        for (String s: words) {\\n            Set<Character> cSet = new HashSet<>();\\n            for (char c: s.toCharArray()) {\\n                cSet.add(c);\\n            }\\n            map.put(cSet, map.getOrDefault(cSet, 0) + 1);\\n        }\\n        int n = 0;\\n        for (Integer v: map.values()) {\\n            n += v * (v - 1) / 2;\\n        }\\n        return n;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3619651,
                "title": "trivial-c-beats-100",
                "content": "\\n```\\nclass Solution {\\npublic:\\n    int similarPairs(vector<string>& words) {\\n        unordered_map<vector<bool>, int> map;\\n        for (const auto& word : words) {\\n            vector<bool> counter(26);\\n            for (const auto& letter : word)\\n                counter[letter - \\'a\\'] = true;\\n            ++map[counter];\\n        }\\n        auto result = 0;\\n        for (const auto& pair : map)\\n            if (pair.second > 1)\\n                result += pair.second * (pair.second - 1) / 2;\\n        return result;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int similarPairs(vector<string>& words) {\\n        unordered_map<vector<bool>, int> map;\\n        for (const auto& word : words) {\\n            vector<bool> counter(26);\\n            for (const auto& letter : word)\\n                counter[letter - \\'a\\'] = true;\\n            ++map[counter];\\n        }\\n        auto result = 0;\\n        for (const auto& pair : map)\\n            if (pair.second > 1)\\n                result += pair.second * (pair.second - 1) / 2;\\n        return result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3599101,
                "title": "java-single-loop-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int similarPairs(String[] words) {\\n        Map<Integer,Integer> map = new HashMap<>();\\n   int count  = 0 ;\\n        for(String str: words){\\n\\n            int k = 0 ;\\n            for(char ch : str.toCharArray()){\\n                k|=1<<(ch-\\'a\\');\\n            }\\n\\n            map.put(k,map.getOrDefault(k,0)+1);\\n\\n             count+= map.get(k)-1;\\n        }\\n\\n\\n     \\n\\n\\n        return count;\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int similarPairs(String[] words) {\\n        Map<Integer,Integer> map = new HashMap<>();\\n   int count  = 0 ;\\n        for(String str: words){\\n\\n            int k = 0 ;\\n            for(char ch : str.toCharArray()){\\n                k|=1<<(ch-\\'a\\');\\n            }\\n\\n            map.put(k,map.getOrDefault(k,0)+1);\\n\\n             count+= map.get(k)-1;\\n        }\\n\\n\\n     \\n\\n\\n        return count;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3594688,
                "title": "easy-approach-using-set-and-hash-combination",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def similarPairs(self, words: List[str]) -> int:\\n        # ab\\n        # ab\\n        # abcd\\n        # bac - abc\\n        # abc\\n\\n        test = []\\n        k = 0\\n\\n        for i in words:\\n            word = set(i)\\n            \\n            test.append(\\'\\'.join(sorted(word)))\\n        print(test)\\n        # return k\\n\\n        hm = {}\\n        \\n        for i in test:\\n            if i not in hm:\\n                hm[i] = 1\\n            else:\\n                hm[i] += 1\\n        print(hm)\\n                \\n    #  {\\'ab\\': 2, \\'abcd\\': 1, \\'abc\\': 2}\\n\\n        count = 0\\n        for k,v in hm.items():\\n            if v>1:\\n                count = count + v * (v - 1) // 2\\n\\n        return count\\n\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def similarPairs(self, words: List[str]) -> int:\\n        # ab\\n        # ab\\n        # abcd\\n        # bac - abc\\n        # abc\\n\\n        test = []\\n        k = 0\\n\\n        for i in words:\\n            word = set(i)\\n            \\n            test.append(\\'\\'.join(sorted(word)))\\n        print(test)\\n        # return k\\n\\n        hm = {}\\n        \\n        for i in test:\\n            if i not in hm:\\n                hm[i] = 1\\n            else:\\n                hm[i] += 1\\n        print(hm)\\n                \\n    #  {\\'ab\\': 2, \\'abcd\\': 1, \\'abc\\': 2}\\n\\n        count = 0\\n        for k,v in hm.items():\\n            if v>1:\\n                count = count + v * (v - 1) // 2\\n\\n        return count\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3582765,
                "title": "python-easy-solution-for-beginners",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n^2)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def similarPairs(self, words: List[str]) -> int:\\n        count = 0\\n        n = len(words)\\n        for i in range(n):\\n            for j in range(i+1, n):\\n                if set(words[i]) == set(words[j]):\\n                    count +=1\\n        return count\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def similarPairs(self, words: List[str]) -> int:\\n        count = 0\\n        n = len(words)\\n        for i in range(n):\\n            for j in range(i+1, n):\\n                if set(words[i]) == set(words[j]):\\n                    count +=1\\n        return count\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3582620,
                "title": "easy-solution-with-hashset",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int similarPairs(String[] words) {\\n        int pair = 0;\\n      for(int i = 0 ; i<words.length; i++){\\n          HashSet<Character> set = new HashSet<>();\\n          for(int j = 0 ; j<words[i].length(); j++){\\n              set.add(words[i].charAt(j));\\n          }\\n\\n          for(int k = i+1; k<words.length; k++){\\n              HashSet<Character> set2 = new HashSet<>();\\n              for(int m = 0 ; m<words[k].length(); m++){\\n                  set2.add(words[k].charAt(m));\\n              }\\n\\n              if(set.equals(set2)){\\n                  pair++;\\n              }\\n\\n              set2.clear();\\n          }\\n\\n          set.clear();\\n      }\\n\\n      return pair;  \\n      \\n\\n\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int similarPairs(String[] words) {\\n        int pair = 0;\\n      for(int i = 0 ; i<words.length; i++){\\n          HashSet<Character> set = new HashSet<>();\\n          for(int j = 0 ; j<words[i].length(); j++){\\n              set.add(words[i].charAt(j));\\n          }\\n\\n          for(int k = i+1; k<words.length; k++){\\n              HashSet<Character> set2 = new HashSet<>();\\n              for(int m = 0 ; m<words[k].length(); m++){\\n                  set2.add(words[k].charAt(m));\\n              }\\n\\n              if(set.equals(set2)){\\n                  pair++;\\n              }\\n\\n              set2.clear();\\n          }\\n\\n          set.clear();\\n      }\\n\\n      return pair;  \\n      \\n\\n\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3581474,
                "title": "easy-approach-beats-100",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n  int similarPairs(List<String> words) {\\n    List<Set<String>> checker=List.generate(words.length, (index) => {});\\n    int result=0;\\n    for(int i=0;i<words.length;i++){\\n      for(int j=0;j<words[i].length;j++){\\n        checker[i].add(words[i][j]);\\n      }\\n    }\\n    while(checker.isNotEmpty){\\n      Set<String> temp=checker.removeLast();\\n      for(var word in checker){\\n        if(charChecker(temp, word))result++;\\n      }\\n    }\\n    return result;\\n  }\\n  bool charChecker(Set<String>a,Set<String>b){\\n    if(a.length!=b.length)return false;\\n    return a.containsAll(b)?true:false;\\n  }\\n}\\n```",
                "solutionTags": [
                    "Dart"
                ],
                "code": "```\\nclass Solution {\\n  int similarPairs(List<String> words) {\\n    List<Set<String>> checker=List.generate(words.length, (index) => {});\\n    int result=0;\\n    for(int i=0;i<words.length;i++){\\n      for(int j=0;j<words[i].length;j++){\\n        checker[i].add(words[i][j]);\\n      }\\n    }\\n    while(checker.isNotEmpty){\\n      Set<String> temp=checker.removeLast();\\n      for(var word in checker){\\n        if(charChecker(temp, word))result++;\\n      }\\n    }\\n    return result;\\n  }\\n  bool charChecker(Set<String>a,Set<String>b){\\n    if(a.length!=b.length)return false;\\n    return a.containsAll(b)?true:false;\\n  }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3580899,
                "title": "dart-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n  int similarPairs(List<String> words) {\\n    int count = 0;\\n    \\n    for (int i = 0; i < words.length; i++) {\\n      List<int> charCodes = Set.from(words[i].codeUnits).map((code) => code as int).toList();\\n      charCodes.sort();\\n      String sortedWord = String.fromCharCodes(charCodes);\\n      words[i] = sortedWord;\\n    }\\n    \\n    for (int i = 0; i < words.length; i++) {\\n      for (int j = i + 1; j < words.length; j++) {\\n        if (words[i] == words[j]) {\\n          count++;\\n        }\\n      }\\n    }\\n    \\n    return count;\\n  }\\n}\\n\\n```",
                "solutionTags": [
                    "Dart"
                ],
                "code": "```\\nclass Solution {\\n  int similarPairs(List<String> words) {\\n    int count = 0;\\n    \\n    for (int i = 0; i < words.length; i++) {\\n      List<int> charCodes = Set.from(words[i].codeUnits).map((code) => code as int).toList();\\n      charCodes.sort();\\n      String sortedWord = String.fromCharCodes(charCodes);\\n      words[i] = sortedWord;\\n    }\\n    \\n    for (int i = 0; i < words.length; i++) {\\n      for (int j = i + 1; j < words.length; j++) {\\n        if (words[i] == words[j]) {\\n          count++;\\n        }\\n      }\\n    }\\n    \\n    return count;\\n  }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3580887,
                "title": "dart-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n  int similarPairs(List<String> words) {\\nint count=0;\\nfor(int i=0;i<words.length-1;i++){\\n    for(int j=i+1;j<words.length;j++){\\nif(isSimilar(words[i],words[j])){\\n    count ++;\\n}\\n    }\\n}\\n\\nreturn count;\\n  }\\n  bool isSimilar(String word1, String word2) {\\n  Set<String> set1 = word1.split(\\'\\').toSet();\\n  Set<String> set2 = word2.split(\\'\\').toSet();\\n\\n  return set1.length == set2.length && set1.containsAll(set2);\\n}\\n}\\n```",
                "solutionTags": [
                    "Dart"
                ],
                "code": "```\\nclass Solution {\\n  int similarPairs(List<String> words) {\\nint count=0;\\nfor(int i=0;i<words.length-1;i++){\\n    for(int j=i+1;j<words.length;j++){\\nif(isSimilar(words[i],words[j])){\\n    count ++;\\n}\\n    }\\n}\\n\\nreturn count;\\n  }\\n  bool isSimilar(String word1, String word2) {\\n  Set<String> set1 = word1.split(\\'\\').toSet();\\n  Set<String> set2 = word2.split(\\'\\').toSet();\\n\\n  return set1.length == set2.length && set1.containsAll(set2);\\n}\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3579629,
                "title": "simple-easy-to-understand",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    func similarPairs(_ words: [String]) -> Int {\\n        var setArray = [Set<Character>]()\\nvar count = 0\\n\\nfor word in words{\\n    var mySet: Set<Character> = []\\n\\n    for char in word{\\n        mySet.insert(char)\\n    }\\n    setArray.append(mySet)\\n}\\n\\nfor i in 0..<setArray.count-1{\\n    for j in i+1..<setArray.count{\\n        if setArray[i] == setArray[j]{\\n            count += 1\\n        }\\n    }\\n}\\nreturn count\\n    }\\n}\\n```",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nclass Solution {\\n    func similarPairs(_ words: [String]) -> Int {\\n        var setArray = [Set<Character>]()\\nvar count = 0\\n\\nfor word in words{\\n    var mySet: Set<Character> = []\\n\\n    for char in word{\\n        mySet.insert(char)\\n    }\\n    setArray.append(mySet)\\n}\\n\\nfor i in 0..<setArray.count-1{\\n    for j in i+1..<setArray.count{\\n        if setArray[i] == setArray[j]{\\n            count += 1\\n        }\\n    }\\n}\\nreturn count\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3565558,
                "title": "java-solution",
                "content": "# Code\\n```\\nclass Solution {\\n    public int similarPairs(String[] words) {\\n        Set<Character> tmp1 = new HashSet<>();\\n        Set<Character> tmp2 = new HashSet<>();\\n        int result = 0;\\n\\n        for (int i = 0; i < words.length; i++) {\\n            tmp1.addAll(words[i].chars().mapToObj(chr -> (char) chr).toList());\\n\\n            for (int j = i + 1; j < words.length; j++) {\\n                tmp2.clear();\\n                tmp2.addAll(words[j].chars().mapToObj(chr -> (char) chr).toList());\\n\\n                if (tmp1.size() == tmp2.size() && tmp1.containsAll(tmp2)) {\\n                    result++;\\n                }\\n\\n            }\\n\\n            tmp1.clear();\\n        }\\n\\n        return result;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int similarPairs(String[] words) {\\n        Set<Character> tmp1 = new HashSet<>();\\n        Set<Character> tmp2 = new HashSet<>();\\n        int result = 0;\\n\\n        for (int i = 0; i < words.length; i++) {\\n            tmp1.addAll(words[i].chars().mapToObj(chr -> (char) chr).toList());\\n\\n            for (int j = i + 1; j < words.length; j++) {\\n                tmp2.clear();\\n                tmp2.addAll(words[j].chars().mapToObj(chr -> (char) chr).toList());\\n\\n                if (tmp1.size() == tmp2.size() && tmp1.containsAll(tmp2)) {\\n                    result++;\\n                }\\n\\n            }\\n\\n            tmp1.clear();\\n        }\\n\\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3563267,
                "title": "aesthetic-very-simple-typescript-solution-o-n",
                "content": "\\n\\n# Intutiton\\n- Instead of comparing each word, we can jus get the unique sorted alphabets and count them for the given words so that we can do O(N) instead of O(N * N)\\n\\n# Code\\n- prepare `getCode()` function that returns code of word.\\n    - \"Code\" here is defined as a string with unique sorted alphabets\\n    - i.e) ab\\n    - i,e) de\\n    - NOT ed (not sorted)\\n    - NOT aab (not unique)\\n- prepare `getTotalPairs()` function that returns the total count of the same code (Detailed explain below)\\n    - ![image.png](https://assets.leetcode.com/users/images/cd013846-56d5-45d2-a225-2dbb914f4f7d_1685054333.8837683.png)\\n    - ![image.png](https://assets.leetcode.com/users/images/ff3632bf-5441-442c-b7e3-eade14a91cf3_1685054399.2597115.png)\\n    - Do you see the pattern here?\\n    - ![image.png](https://assets.leetcode.com/users/images/f0a8ca2d-ad61-4e78-8950-4600f01ba261_1685054447.0269556.png)\\n- The main function:\\n    - Loop through each word and get the code with the `getCode()` and we will count each total number of each code\\n    - Then we can figure out the total pairs of the each count with the `getTotalPairs()`\\n    - Return the `totalPairs`\\n\\n```ts\\nconst getCode = (word: string): string => { // O(N)\\n    const set = new Set<string>()\\n    for (const c of word) set.add(c)\\n    return Array.from(set).sort().join()\\n}\\n\\nconst getTotalPairs = (n: number) => (n * n - n) / 2\\n\\nfunction similarPairs(words: string[]): number {\\n    const map = new Map<string, number>()\\n    words.forEach(word => { // O(N)\\n        const code = getCode(word)\\n        map.set(code, (map.get(code) || 0) + 1)\\n    })\\n\\n    let totalPairs = 0\\n    map.forEach((count) => totalPairs += getTotalPairs(count)) // O(N)\\n    return totalPairs\\n}\\n```",
                "solutionTags": [
                    "TypeScript"
                ],
                "code": "```ts\\nconst getCode = (word: string): string => { // O(N)\\n    const set = new Set<string>()\\n    for (const c of word) set.add(c)\\n    return Array.from(set).sort().join()\\n}\\n\\nconst getTotalPairs = (n: number) => (n * n - n) / 2\\n\\nfunction similarPairs(words: string[]): number {\\n    const map = new Map<string, number>()\\n    words.forEach(word => { // O(N)\\n        const code = getCode(word)\\n        map.set(code, (map.get(code) || 0) + 1)\\n    })\\n\\n    let totalPairs = 0\\n    map.forEach((count) => totalPairs += getTotalPairs(count)) // O(N)\\n    return totalPairs\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3556347,
                "title": "java-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int similarPairs(String[] words) {\\n         int count=0;\\n        String mystr=\"\";\\n        String array[]=new String[words.length];\\n        for(int i=0;i< words.length;i++){\\n            String str=words[i];\\n            HashSet<String> hs=new HashSet<>();\\n            for(int j=0;j<str.length();j++){\\n                hs.add(Character.toString(str.charAt(j)));\\n            }\\n            String temp=String.join(\"\",hs);\\n           array[i]=temp;\\n\\n        }\\n     //   System.out.println(Arrays.toString(array));\\n        HashMap<String,Integer> map=new HashMap<>();\\n        for(int i=0;i<array.length;i++){\\n           map.put(array[i],map.getOrDefault(array[i],0)+1);\\n        }\\n        for(Map.Entry<String,Integer> e : map.entrySet()){\\n            int value =  e.getValue();\\n            count+=value*(value-1)/2;\\n        }\\n        \\n        return count;\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int similarPairs(String[] words) {\\n         int count=0;\\n        String mystr=\"\";\\n        String array[]=new String[words.length];\\n        for(int i=0;i< words.length;i++){\\n            String str=words[i];\\n            HashSet<String> hs=new HashSet<>();\\n            for(int j=0;j<str.length();j++){\\n                hs.add(Character.toString(str.charAt(j)));\\n            }\\n            String temp=String.join(\"\",hs);\\n           array[i]=temp;\\n\\n        }\\n     //   System.out.println(Arrays.toString(array));\\n        HashMap<String,Integer> map=new HashMap<>();\\n        for(int i=0;i<array.length;i++){\\n           map.put(array[i],map.getOrDefault(array[i],0)+1);\\n        }\\n        for(Map.Entry<String,Integer> e : map.entrySet()){\\n            int value =  e.getValue();\\n            count+=value*(value-1)/2;\\n        }\\n        \\n        return count;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1743967,
                "content": [
                    {
                        "username": "JeliHacker",
                        "content": "My solution passes a different number of solutions every time I hit submit (165/225 one time, 164/225 the next, etc.) If I manually add a test case and hit \"Run\", it sometimes passes and sometimes doesn't. Is this a common problem on Leetcode? I can add the code if someone's interested."
                    },
                    {
                        "username": "naxal",
                        "content": "Please re-judge this question.\n1. Unordered Set gets Accepted in some submissions\n2. Unordered Set gives TLE in some submissions\n\nThis gets accepted - https://leetcode.com/problems/count-pairs-of-similar-strings/submissions/861462780/\n\nThis gives TLE - https://leetcode.com/problems/count-pairs-of-similar-strings/submissions/861390225/\n"
                    },
                    {
                        "username": "Jenjoy",
                        "content": "Using a `Set` is probably an overkill. https://leetcode.com/problems/count-pairs-of-similar-strings/discussion/comments/1724870"
                    },
                    {
                        "username": "freakin_rkb",
                        "content": "clear the set after comparing the sets.\\n  bool check(string a, string b)\\n    {\\n            unordered_set<char> A;\\n            unordered_set<char> B;\\n        \\n            for(auto &x:a)\\n                A.insert(x);\\n        \\n        \\n            for(auto &x:b)\\n                B.insert(x);\\n        \\n        return A==B;\\n        B.clear();\\n    }\\n    int similarPairs(vector<string>& words) {\\n        \\n        int n = words.size();\\n        int ans = 0;\\n        for(int i = 0; i < n; i++)\\n        {\\n            for(int j = i+1; j < n; j++)\\n            {\\n                if(check(words[i],words[j]))\\n                    ans++;\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "Jenjoy",
                        "content": "Instead of a `Set` use a single `int` as bitset to record chars.\nIf String is \"abc\" integer bitset will be 111(3) and for \"abdb\" it will be1011(11) etc.\n\n ```\npublic int similarPairs(String[] words) {\n        Map<Integer, Integer> counts = new HashMap<>();\n        for(String word : words) {\n            int bits = 0;\n            for(char ch : word.toCharArray()) {\n                bits = bits | (1 << (ch-'a'));\n            }\n            counts.put(bits, counts.getOrDefault(bits, 0) + 1);\n        }\n\n        int result = 0;\n        for(int n : counts.values()) {\n            result += (n * (n-1))/2;\n        }\n        return result;\n}\n```"
                    },
                    {
                        "username": "rhuzaifa",
                        "content": "I think this question should also having \\'counting\\' as a related topic. Thoughts?"
                    },
                    {
                        "username": "saadkhan123456789",
                        "content": "Yes !"
                    },
                    {
                        "username": "Jasur_4422",
                        "content": " @I use two hashSet my solution[Solution](https://leetcode.com/problems/count-pairs-of-similar-strings/post-solution/?submissionId=890647558)"
                    },
                    {
                        "username": "MikeSparrow",
                        "content": "This problem became much easier when I realize they are asking for all possible pairs "
                    },
                    {
                        "username": "sodha",
                        "content": "I am able to solve the problem in n square complexity, but I am not getting any idea about the n or n * log n complexity.\nhttps://leetcode.com/problems/count-pairs-of-similar-strings/solutions/3032500/java-good-for-begginners-94-treeset/ "
                    },
                    {
                        "username": "mandliyarajendra11",
                        "content": "use set and store all string \\n\\nex- \\n1. baa 2. ab 3. ba\\no/p - 3 \\nso set make \\n1. ab 2. ab 3. ab (sorted and unique )\\n\\nthen compare with loop"
                    }
                ]
            },
            {
                "id": 1720046,
                "content": [
                    {
                        "username": "JeliHacker",
                        "content": "My solution passes a different number of solutions every time I hit submit (165/225 one time, 164/225 the next, etc.) If I manually add a test case and hit \"Run\", it sometimes passes and sometimes doesn't. Is this a common problem on Leetcode? I can add the code if someone's interested."
                    },
                    {
                        "username": "naxal",
                        "content": "Please re-judge this question.\n1. Unordered Set gets Accepted in some submissions\n2. Unordered Set gives TLE in some submissions\n\nThis gets accepted - https://leetcode.com/problems/count-pairs-of-similar-strings/submissions/861462780/\n\nThis gives TLE - https://leetcode.com/problems/count-pairs-of-similar-strings/submissions/861390225/\n"
                    },
                    {
                        "username": "Jenjoy",
                        "content": "Using a `Set` is probably an overkill. https://leetcode.com/problems/count-pairs-of-similar-strings/discussion/comments/1724870"
                    },
                    {
                        "username": "freakin_rkb",
                        "content": "clear the set after comparing the sets.\\n  bool check(string a, string b)\\n    {\\n            unordered_set<char> A;\\n            unordered_set<char> B;\\n        \\n            for(auto &x:a)\\n                A.insert(x);\\n        \\n        \\n            for(auto &x:b)\\n                B.insert(x);\\n        \\n        return A==B;\\n        B.clear();\\n    }\\n    int similarPairs(vector<string>& words) {\\n        \\n        int n = words.size();\\n        int ans = 0;\\n        for(int i = 0; i < n; i++)\\n        {\\n            for(int j = i+1; j < n; j++)\\n            {\\n                if(check(words[i],words[j]))\\n                    ans++;\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "Jenjoy",
                        "content": "Instead of a `Set` use a single `int` as bitset to record chars.\nIf String is \"abc\" integer bitset will be 111(3) and for \"abdb\" it will be1011(11) etc.\n\n ```\npublic int similarPairs(String[] words) {\n        Map<Integer, Integer> counts = new HashMap<>();\n        for(String word : words) {\n            int bits = 0;\n            for(char ch : word.toCharArray()) {\n                bits = bits | (1 << (ch-'a'));\n            }\n            counts.put(bits, counts.getOrDefault(bits, 0) + 1);\n        }\n\n        int result = 0;\n        for(int n : counts.values()) {\n            result += (n * (n-1))/2;\n        }\n        return result;\n}\n```"
                    },
                    {
                        "username": "rhuzaifa",
                        "content": "I think this question should also having \\'counting\\' as a related topic. Thoughts?"
                    },
                    {
                        "username": "saadkhan123456789",
                        "content": "Yes !"
                    },
                    {
                        "username": "Jasur_4422",
                        "content": " @I use two hashSet my solution[Solution](https://leetcode.com/problems/count-pairs-of-similar-strings/post-solution/?submissionId=890647558)"
                    },
                    {
                        "username": "MikeSparrow",
                        "content": "This problem became much easier when I realize they are asking for all possible pairs "
                    },
                    {
                        "username": "sodha",
                        "content": "I am able to solve the problem in n square complexity, but I am not getting any idea about the n or n * log n complexity.\nhttps://leetcode.com/problems/count-pairs-of-similar-strings/solutions/3032500/java-good-for-begginners-94-treeset/ "
                    },
                    {
                        "username": "mandliyarajendra11",
                        "content": "use set and store all string \\n\\nex- \\n1. baa 2. ab 3. ba\\no/p - 3 \\nso set make \\n1. ab 2. ab 3. ab (sorted and unique )\\n\\nthen compare with loop"
                    }
                ]
            },
            {
                "id": 1724870,
                "content": [
                    {
                        "username": "JeliHacker",
                        "content": "My solution passes a different number of solutions every time I hit submit (165/225 one time, 164/225 the next, etc.) If I manually add a test case and hit \"Run\", it sometimes passes and sometimes doesn't. Is this a common problem on Leetcode? I can add the code if someone's interested."
                    },
                    {
                        "username": "naxal",
                        "content": "Please re-judge this question.\n1. Unordered Set gets Accepted in some submissions\n2. Unordered Set gives TLE in some submissions\n\nThis gets accepted - https://leetcode.com/problems/count-pairs-of-similar-strings/submissions/861462780/\n\nThis gives TLE - https://leetcode.com/problems/count-pairs-of-similar-strings/submissions/861390225/\n"
                    },
                    {
                        "username": "Jenjoy",
                        "content": "Using a `Set` is probably an overkill. https://leetcode.com/problems/count-pairs-of-similar-strings/discussion/comments/1724870"
                    },
                    {
                        "username": "freakin_rkb",
                        "content": "clear the set after comparing the sets.\\n  bool check(string a, string b)\\n    {\\n            unordered_set<char> A;\\n            unordered_set<char> B;\\n        \\n            for(auto &x:a)\\n                A.insert(x);\\n        \\n        \\n            for(auto &x:b)\\n                B.insert(x);\\n        \\n        return A==B;\\n        B.clear();\\n    }\\n    int similarPairs(vector<string>& words) {\\n        \\n        int n = words.size();\\n        int ans = 0;\\n        for(int i = 0; i < n; i++)\\n        {\\n            for(int j = i+1; j < n; j++)\\n            {\\n                if(check(words[i],words[j]))\\n                    ans++;\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "Jenjoy",
                        "content": "Instead of a `Set` use a single `int` as bitset to record chars.\nIf String is \"abc\" integer bitset will be 111(3) and for \"abdb\" it will be1011(11) etc.\n\n ```\npublic int similarPairs(String[] words) {\n        Map<Integer, Integer> counts = new HashMap<>();\n        for(String word : words) {\n            int bits = 0;\n            for(char ch : word.toCharArray()) {\n                bits = bits | (1 << (ch-'a'));\n            }\n            counts.put(bits, counts.getOrDefault(bits, 0) + 1);\n        }\n\n        int result = 0;\n        for(int n : counts.values()) {\n            result += (n * (n-1))/2;\n        }\n        return result;\n}\n```"
                    },
                    {
                        "username": "rhuzaifa",
                        "content": "I think this question should also having \\'counting\\' as a related topic. Thoughts?"
                    },
                    {
                        "username": "saadkhan123456789",
                        "content": "Yes !"
                    },
                    {
                        "username": "Jasur_4422",
                        "content": " @I use two hashSet my solution[Solution](https://leetcode.com/problems/count-pairs-of-similar-strings/post-solution/?submissionId=890647558)"
                    },
                    {
                        "username": "MikeSparrow",
                        "content": "This problem became much easier when I realize they are asking for all possible pairs "
                    },
                    {
                        "username": "sodha",
                        "content": "I am able to solve the problem in n square complexity, but I am not getting any idea about the n or n * log n complexity.\nhttps://leetcode.com/problems/count-pairs-of-similar-strings/solutions/3032500/java-good-for-begginners-94-treeset/ "
                    },
                    {
                        "username": "mandliyarajendra11",
                        "content": "use set and store all string \\n\\nex- \\n1. baa 2. ab 3. ba\\no/p - 3 \\nso set make \\n1. ab 2. ab 3. ab (sorted and unique )\\n\\nthen compare with loop"
                    }
                ]
            },
            {
                "id": 1858803,
                "content": [
                    {
                        "username": "JeliHacker",
                        "content": "My solution passes a different number of solutions every time I hit submit (165/225 one time, 164/225 the next, etc.) If I manually add a test case and hit \"Run\", it sometimes passes and sometimes doesn't. Is this a common problem on Leetcode? I can add the code if someone's interested."
                    },
                    {
                        "username": "naxal",
                        "content": "Please re-judge this question.\n1. Unordered Set gets Accepted in some submissions\n2. Unordered Set gives TLE in some submissions\n\nThis gets accepted - https://leetcode.com/problems/count-pairs-of-similar-strings/submissions/861462780/\n\nThis gives TLE - https://leetcode.com/problems/count-pairs-of-similar-strings/submissions/861390225/\n"
                    },
                    {
                        "username": "Jenjoy",
                        "content": "Using a `Set` is probably an overkill. https://leetcode.com/problems/count-pairs-of-similar-strings/discussion/comments/1724870"
                    },
                    {
                        "username": "freakin_rkb",
                        "content": "clear the set after comparing the sets.\\n  bool check(string a, string b)\\n    {\\n            unordered_set<char> A;\\n            unordered_set<char> B;\\n        \\n            for(auto &x:a)\\n                A.insert(x);\\n        \\n        \\n            for(auto &x:b)\\n                B.insert(x);\\n        \\n        return A==B;\\n        B.clear();\\n    }\\n    int similarPairs(vector<string>& words) {\\n        \\n        int n = words.size();\\n        int ans = 0;\\n        for(int i = 0; i < n; i++)\\n        {\\n            for(int j = i+1; j < n; j++)\\n            {\\n                if(check(words[i],words[j]))\\n                    ans++;\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "Jenjoy",
                        "content": "Instead of a `Set` use a single `int` as bitset to record chars.\nIf String is \"abc\" integer bitset will be 111(3) and for \"abdb\" it will be1011(11) etc.\n\n ```\npublic int similarPairs(String[] words) {\n        Map<Integer, Integer> counts = new HashMap<>();\n        for(String word : words) {\n            int bits = 0;\n            for(char ch : word.toCharArray()) {\n                bits = bits | (1 << (ch-'a'));\n            }\n            counts.put(bits, counts.getOrDefault(bits, 0) + 1);\n        }\n\n        int result = 0;\n        for(int n : counts.values()) {\n            result += (n * (n-1))/2;\n        }\n        return result;\n}\n```"
                    },
                    {
                        "username": "rhuzaifa",
                        "content": "I think this question should also having \\'counting\\' as a related topic. Thoughts?"
                    },
                    {
                        "username": "saadkhan123456789",
                        "content": "Yes !"
                    },
                    {
                        "username": "Jasur_4422",
                        "content": " @I use two hashSet my solution[Solution](https://leetcode.com/problems/count-pairs-of-similar-strings/post-solution/?submissionId=890647558)"
                    },
                    {
                        "username": "MikeSparrow",
                        "content": "This problem became much easier when I realize they are asking for all possible pairs "
                    },
                    {
                        "username": "sodha",
                        "content": "I am able to solve the problem in n square complexity, but I am not getting any idea about the n or n * log n complexity.\nhttps://leetcode.com/problems/count-pairs-of-similar-strings/solutions/3032500/java-good-for-begginners-94-treeset/ "
                    },
                    {
                        "username": "mandliyarajendra11",
                        "content": "use set and store all string \\n\\nex- \\n1. baa 2. ab 3. ba\\no/p - 3 \\nso set make \\n1. ab 2. ab 3. ab (sorted and unique )\\n\\nthen compare with loop"
                    }
                ]
            },
            {
                "id": 1785964,
                "content": [
                    {
                        "username": "JeliHacker",
                        "content": "My solution passes a different number of solutions every time I hit submit (165/225 one time, 164/225 the next, etc.) If I manually add a test case and hit \"Run\", it sometimes passes and sometimes doesn't. Is this a common problem on Leetcode? I can add the code if someone's interested."
                    },
                    {
                        "username": "naxal",
                        "content": "Please re-judge this question.\n1. Unordered Set gets Accepted in some submissions\n2. Unordered Set gives TLE in some submissions\n\nThis gets accepted - https://leetcode.com/problems/count-pairs-of-similar-strings/submissions/861462780/\n\nThis gives TLE - https://leetcode.com/problems/count-pairs-of-similar-strings/submissions/861390225/\n"
                    },
                    {
                        "username": "Jenjoy",
                        "content": "Using a `Set` is probably an overkill. https://leetcode.com/problems/count-pairs-of-similar-strings/discussion/comments/1724870"
                    },
                    {
                        "username": "freakin_rkb",
                        "content": "clear the set after comparing the sets.\\n  bool check(string a, string b)\\n    {\\n            unordered_set<char> A;\\n            unordered_set<char> B;\\n        \\n            for(auto &x:a)\\n                A.insert(x);\\n        \\n        \\n            for(auto &x:b)\\n                B.insert(x);\\n        \\n        return A==B;\\n        B.clear();\\n    }\\n    int similarPairs(vector<string>& words) {\\n        \\n        int n = words.size();\\n        int ans = 0;\\n        for(int i = 0; i < n; i++)\\n        {\\n            for(int j = i+1; j < n; j++)\\n            {\\n                if(check(words[i],words[j]))\\n                    ans++;\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "Jenjoy",
                        "content": "Instead of a `Set` use a single `int` as bitset to record chars.\nIf String is \"abc\" integer bitset will be 111(3) and for \"abdb\" it will be1011(11) etc.\n\n ```\npublic int similarPairs(String[] words) {\n        Map<Integer, Integer> counts = new HashMap<>();\n        for(String word : words) {\n            int bits = 0;\n            for(char ch : word.toCharArray()) {\n                bits = bits | (1 << (ch-'a'));\n            }\n            counts.put(bits, counts.getOrDefault(bits, 0) + 1);\n        }\n\n        int result = 0;\n        for(int n : counts.values()) {\n            result += (n * (n-1))/2;\n        }\n        return result;\n}\n```"
                    },
                    {
                        "username": "rhuzaifa",
                        "content": "I think this question should also having \\'counting\\' as a related topic. Thoughts?"
                    },
                    {
                        "username": "saadkhan123456789",
                        "content": "Yes !"
                    },
                    {
                        "username": "Jasur_4422",
                        "content": " @I use two hashSet my solution[Solution](https://leetcode.com/problems/count-pairs-of-similar-strings/post-solution/?submissionId=890647558)"
                    },
                    {
                        "username": "MikeSparrow",
                        "content": "This problem became much easier when I realize they are asking for all possible pairs "
                    },
                    {
                        "username": "sodha",
                        "content": "I am able to solve the problem in n square complexity, but I am not getting any idea about the n or n * log n complexity.\nhttps://leetcode.com/problems/count-pairs-of-similar-strings/solutions/3032500/java-good-for-begginners-94-treeset/ "
                    },
                    {
                        "username": "mandliyarajendra11",
                        "content": "use set and store all string \\n\\nex- \\n1. baa 2. ab 3. ba\\no/p - 3 \\nso set make \\n1. ab 2. ab 3. ab (sorted and unique )\\n\\nthen compare with loop"
                    }
                ]
            },
            {
                "id": 1760420,
                "content": [
                    {
                        "username": "JeliHacker",
                        "content": "My solution passes a different number of solutions every time I hit submit (165/225 one time, 164/225 the next, etc.) If I manually add a test case and hit \"Run\", it sometimes passes and sometimes doesn't. Is this a common problem on Leetcode? I can add the code if someone's interested."
                    },
                    {
                        "username": "naxal",
                        "content": "Please re-judge this question.\n1. Unordered Set gets Accepted in some submissions\n2. Unordered Set gives TLE in some submissions\n\nThis gets accepted - https://leetcode.com/problems/count-pairs-of-similar-strings/submissions/861462780/\n\nThis gives TLE - https://leetcode.com/problems/count-pairs-of-similar-strings/submissions/861390225/\n"
                    },
                    {
                        "username": "Jenjoy",
                        "content": "Using a `Set` is probably an overkill. https://leetcode.com/problems/count-pairs-of-similar-strings/discussion/comments/1724870"
                    },
                    {
                        "username": "freakin_rkb",
                        "content": "clear the set after comparing the sets.\\n  bool check(string a, string b)\\n    {\\n            unordered_set<char> A;\\n            unordered_set<char> B;\\n        \\n            for(auto &x:a)\\n                A.insert(x);\\n        \\n        \\n            for(auto &x:b)\\n                B.insert(x);\\n        \\n        return A==B;\\n        B.clear();\\n    }\\n    int similarPairs(vector<string>& words) {\\n        \\n        int n = words.size();\\n        int ans = 0;\\n        for(int i = 0; i < n; i++)\\n        {\\n            for(int j = i+1; j < n; j++)\\n            {\\n                if(check(words[i],words[j]))\\n                    ans++;\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "Jenjoy",
                        "content": "Instead of a `Set` use a single `int` as bitset to record chars.\nIf String is \"abc\" integer bitset will be 111(3) and for \"abdb\" it will be1011(11) etc.\n\n ```\npublic int similarPairs(String[] words) {\n        Map<Integer, Integer> counts = new HashMap<>();\n        for(String word : words) {\n            int bits = 0;\n            for(char ch : word.toCharArray()) {\n                bits = bits | (1 << (ch-'a'));\n            }\n            counts.put(bits, counts.getOrDefault(bits, 0) + 1);\n        }\n\n        int result = 0;\n        for(int n : counts.values()) {\n            result += (n * (n-1))/2;\n        }\n        return result;\n}\n```"
                    },
                    {
                        "username": "rhuzaifa",
                        "content": "I think this question should also having \\'counting\\' as a related topic. Thoughts?"
                    },
                    {
                        "username": "saadkhan123456789",
                        "content": "Yes !"
                    },
                    {
                        "username": "Jasur_4422",
                        "content": " @I use two hashSet my solution[Solution](https://leetcode.com/problems/count-pairs-of-similar-strings/post-solution/?submissionId=890647558)"
                    },
                    {
                        "username": "MikeSparrow",
                        "content": "This problem became much easier when I realize they are asking for all possible pairs "
                    },
                    {
                        "username": "sodha",
                        "content": "I am able to solve the problem in n square complexity, but I am not getting any idea about the n or n * log n complexity.\nhttps://leetcode.com/problems/count-pairs-of-similar-strings/solutions/3032500/java-good-for-begginners-94-treeset/ "
                    },
                    {
                        "username": "mandliyarajendra11",
                        "content": "use set and store all string \\n\\nex- \\n1. baa 2. ab 3. ba\\no/p - 3 \\nso set make \\n1. ab 2. ab 3. ab (sorted and unique )\\n\\nthen compare with loop"
                    }
                ]
            },
            {
                "id": 1751676,
                "content": [
                    {
                        "username": "JeliHacker",
                        "content": "My solution passes a different number of solutions every time I hit submit (165/225 one time, 164/225 the next, etc.) If I manually add a test case and hit \"Run\", it sometimes passes and sometimes doesn't. Is this a common problem on Leetcode? I can add the code if someone's interested."
                    },
                    {
                        "username": "naxal",
                        "content": "Please re-judge this question.\n1. Unordered Set gets Accepted in some submissions\n2. Unordered Set gives TLE in some submissions\n\nThis gets accepted - https://leetcode.com/problems/count-pairs-of-similar-strings/submissions/861462780/\n\nThis gives TLE - https://leetcode.com/problems/count-pairs-of-similar-strings/submissions/861390225/\n"
                    },
                    {
                        "username": "Jenjoy",
                        "content": "Using a `Set` is probably an overkill. https://leetcode.com/problems/count-pairs-of-similar-strings/discussion/comments/1724870"
                    },
                    {
                        "username": "freakin_rkb",
                        "content": "clear the set after comparing the sets.\\n  bool check(string a, string b)\\n    {\\n            unordered_set<char> A;\\n            unordered_set<char> B;\\n        \\n            for(auto &x:a)\\n                A.insert(x);\\n        \\n        \\n            for(auto &x:b)\\n                B.insert(x);\\n        \\n        return A==B;\\n        B.clear();\\n    }\\n    int similarPairs(vector<string>& words) {\\n        \\n        int n = words.size();\\n        int ans = 0;\\n        for(int i = 0; i < n; i++)\\n        {\\n            for(int j = i+1; j < n; j++)\\n            {\\n                if(check(words[i],words[j]))\\n                    ans++;\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "Jenjoy",
                        "content": "Instead of a `Set` use a single `int` as bitset to record chars.\nIf String is \"abc\" integer bitset will be 111(3) and for \"abdb\" it will be1011(11) etc.\n\n ```\npublic int similarPairs(String[] words) {\n        Map<Integer, Integer> counts = new HashMap<>();\n        for(String word : words) {\n            int bits = 0;\n            for(char ch : word.toCharArray()) {\n                bits = bits | (1 << (ch-'a'));\n            }\n            counts.put(bits, counts.getOrDefault(bits, 0) + 1);\n        }\n\n        int result = 0;\n        for(int n : counts.values()) {\n            result += (n * (n-1))/2;\n        }\n        return result;\n}\n```"
                    },
                    {
                        "username": "rhuzaifa",
                        "content": "I think this question should also having \\'counting\\' as a related topic. Thoughts?"
                    },
                    {
                        "username": "saadkhan123456789",
                        "content": "Yes !"
                    },
                    {
                        "username": "Jasur_4422",
                        "content": " @I use two hashSet my solution[Solution](https://leetcode.com/problems/count-pairs-of-similar-strings/post-solution/?submissionId=890647558)"
                    },
                    {
                        "username": "MikeSparrow",
                        "content": "This problem became much easier when I realize they are asking for all possible pairs "
                    },
                    {
                        "username": "sodha",
                        "content": "I am able to solve the problem in n square complexity, but I am not getting any idea about the n or n * log n complexity.\nhttps://leetcode.com/problems/count-pairs-of-similar-strings/solutions/3032500/java-good-for-begginners-94-treeset/ "
                    },
                    {
                        "username": "mandliyarajendra11",
                        "content": "use set and store all string \\n\\nex- \\n1. baa 2. ab 3. ba\\no/p - 3 \\nso set make \\n1. ab 2. ab 3. ab (sorted and unique )\\n\\nthen compare with loop"
                    }
                ]
            },
            {
                "id": 1720170,
                "content": [
                    {
                        "username": "JeliHacker",
                        "content": "My solution passes a different number of solutions every time I hit submit (165/225 one time, 164/225 the next, etc.) If I manually add a test case and hit \"Run\", it sometimes passes and sometimes doesn't. Is this a common problem on Leetcode? I can add the code if someone's interested."
                    },
                    {
                        "username": "naxal",
                        "content": "Please re-judge this question.\n1. Unordered Set gets Accepted in some submissions\n2. Unordered Set gives TLE in some submissions\n\nThis gets accepted - https://leetcode.com/problems/count-pairs-of-similar-strings/submissions/861462780/\n\nThis gives TLE - https://leetcode.com/problems/count-pairs-of-similar-strings/submissions/861390225/\n"
                    },
                    {
                        "username": "Jenjoy",
                        "content": "Using a `Set` is probably an overkill. https://leetcode.com/problems/count-pairs-of-similar-strings/discussion/comments/1724870"
                    },
                    {
                        "username": "freakin_rkb",
                        "content": "clear the set after comparing the sets.\\n  bool check(string a, string b)\\n    {\\n            unordered_set<char> A;\\n            unordered_set<char> B;\\n        \\n            for(auto &x:a)\\n                A.insert(x);\\n        \\n        \\n            for(auto &x:b)\\n                B.insert(x);\\n        \\n        return A==B;\\n        B.clear();\\n    }\\n    int similarPairs(vector<string>& words) {\\n        \\n        int n = words.size();\\n        int ans = 0;\\n        for(int i = 0; i < n; i++)\\n        {\\n            for(int j = i+1; j < n; j++)\\n            {\\n                if(check(words[i],words[j]))\\n                    ans++;\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "Jenjoy",
                        "content": "Instead of a `Set` use a single `int` as bitset to record chars.\nIf String is \"abc\" integer bitset will be 111(3) and for \"abdb\" it will be1011(11) etc.\n\n ```\npublic int similarPairs(String[] words) {\n        Map<Integer, Integer> counts = new HashMap<>();\n        for(String word : words) {\n            int bits = 0;\n            for(char ch : word.toCharArray()) {\n                bits = bits | (1 << (ch-'a'));\n            }\n            counts.put(bits, counts.getOrDefault(bits, 0) + 1);\n        }\n\n        int result = 0;\n        for(int n : counts.values()) {\n            result += (n * (n-1))/2;\n        }\n        return result;\n}\n```"
                    },
                    {
                        "username": "rhuzaifa",
                        "content": "I think this question should also having \\'counting\\' as a related topic. Thoughts?"
                    },
                    {
                        "username": "saadkhan123456789",
                        "content": "Yes !"
                    },
                    {
                        "username": "Jasur_4422",
                        "content": " @I use two hashSet my solution[Solution](https://leetcode.com/problems/count-pairs-of-similar-strings/post-solution/?submissionId=890647558)"
                    },
                    {
                        "username": "MikeSparrow",
                        "content": "This problem became much easier when I realize they are asking for all possible pairs "
                    },
                    {
                        "username": "sodha",
                        "content": "I am able to solve the problem in n square complexity, but I am not getting any idea about the n or n * log n complexity.\nhttps://leetcode.com/problems/count-pairs-of-similar-strings/solutions/3032500/java-good-for-begginners-94-treeset/ "
                    },
                    {
                        "username": "mandliyarajendra11",
                        "content": "use set and store all string \\n\\nex- \\n1. baa 2. ab 3. ba\\no/p - 3 \\nso set make \\n1. ab 2. ab 3. ab (sorted and unique )\\n\\nthen compare with loop"
                    }
                ]
            }
        ]
    }
]