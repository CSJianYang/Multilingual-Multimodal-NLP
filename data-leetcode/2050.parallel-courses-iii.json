[
    {
        "title": "Parallel Courses III",
        "question_content": "You are given an integer n, which indicates that there are n courses labeled from 1 to n. You are also given a 2D integer array relations where relations[j] = [prevCoursej, nextCoursej] denotes that course prevCoursej has to be completed before course nextCoursej (prerequisite relationship). Furthermore, you are given a 0-indexed integer array time where time[i] denotes how many months it takes to complete the (i+1)th course.\nYou must find the minimum number of months needed to complete all the courses following these rules:\n\n\tYou may start taking a course at any time if the prerequisites are met.\n\tAny number of courses can be taken at the same time.\n\nReturn the minimum number of months needed to complete all the courses.\nNote: The test cases are generated such that it is possible to complete every course (i.e., the graph is a directed acyclic graph).\n&nbsp;\nExample 1:\n\nInput: n = 3, relations = [[1,3],[2,3]], time = [3,2,5]\nOutput: 8\nExplanation: The figure above represents the given graph and the time required to complete each course. \nWe start course 1 and course 2 simultaneously at month 0.\nCourse 1 takes 3 months and course 2 takes 2 months to complete respectively.\nThus, the earliest time we can start course 3 is at month 3, and the total time required is 3 + 5 = 8 months.\n\nExample 2:\n\nInput: n = 5, relations = [[1,5],[2,5],[3,5],[3,4],[4,5]], time = [1,2,3,4,5]\nOutput: 12\nExplanation: The figure above represents the given graph and the time required to complete each course.\nYou can start courses 1, 2, and 3 at month 0.\nYou can complete them after 1, 2, and 3 months respectively.\nCourse 4 can be taken only after course 3 is completed, i.e., after 3 months. It is completed after 3 + 4 = 7 months.\nCourse 5 can be taken only after courses 1, 2, 3, and 4 have been completed, i.e., after max(1,2,3,7) = 7 months.\nThus, the minimum time needed to complete all the courses is 7 + 5 = 12 months.\n\n&nbsp;\nConstraints:\n\n\t1 <= n <= 5 * 104\n\t0 <= relations.length <= min(n * (n - 1) / 2, 5 * 104)\n\trelations[j].length == 2\n\t1 <= prevCoursej, nextCoursej <= n\n\tprevCoursej != nextCoursej\n\tAll the pairs [prevCoursej, nextCoursej] are unique.\n\ttime.length == n\n\t1 <= time[i] <= 104\n\tThe given graph is a directed acyclic graph.",
        "solutions": [
            {
                "id": 1537479,
                "title": "c-python-topology-sort-o-m-n-clean-concise",
                "content": "**Idea**\\n- This problem is an advanced version of **[1494. Parallel Courses II](https://leetcode.com/problems/parallel-courses-ii/)**, which has prerequisite relationship between courses.\\n- To solve prerequisite relationship, we can obviously use Topology Sort idea to complete prev courses before next courses.\\n- Let `dist[u]` is the number of months required to finish `u` course, `dist[u]` is calculated as maximum dist of the predecessor nodes + `times[u]`.\\n\\n![image](https://assets.leetcode.com/users/images/6b75ca03-ea4c-47d9-861e-e1277f4d490e_1635047643.7585802.png)\\n\\n<iframe src=\"https://leetcode.com/playground/CAmSjsXm/shared\" frameBorder=\"0\" width=\"100%\" height=\"590\"></iframe>\\n\\n**Complexity**\\n- Time: `O(N + M)`, where `N <= 5 *10^4` is number of courses, where `M` is number of edges.\\n- Space: `O(N + M)`",
                "solutionTags": [],
                "code": "**Idea**\\n- This problem is an advanced version of **[1494. Parallel Courses II](https://leetcode.com/problems/parallel-courses-ii/)**, which has prerequisite relationship between courses.\\n- To solve prerequisite relationship, we can obviously use Topology Sort idea to complete prev courses before next courses.\\n- Let `dist[u]` is the number of months required to finish `u` course, `dist[u]` is calculated as maximum dist of the predecessor nodes + `times[u]`.\\n\\n![image](https://assets.leetcode.com/users/images/6b75ca03-ea4c-47d9-861e-e1277f4d490e_1635047643.7585802.png)\\n\\n<iframe src=\"https://leetcode.com/playground/CAmSjsXm/shared\" frameBorder=\"0\" width=\"100%\" height=\"590\"></iframe>\\n\\n**Complexity**\\n- Time: `O(N + M)`, where `N <= 5 *10^4` is number of courses, where `M` is number of edges.\\n- Space: `O(N + M)`",
                "codeTag": "Unknown"
            },
            {
                "id": 1537473,
                "title": "python-short-dp-4-lines-explained",
                "content": "The idea is that what we actually need to find is **the longest node weighted path**, that is if we start with some node and move only by allowed arrows, what is the maximum sum we can get when we sum all values in visited nodes. For this purpuse we can use dynamic programming. Let `dp(node)` be the longest path when we reached `node`. Then we need to check from what nodes we can arrive and take the maximum one.\\n\\n#### Complexity\\nTime complexity is `O(E + n)`, where `E` is number of edges. Space complexity is `O(E + n)` as well to keep graph `G` and for dp cache.\\n\\n#### Code\\n```python\\nclass Solution:\\n    def minimumTime(self, n, R, T):\\n        G = defaultdict(list)\\n        for x, y in R:\\n            G[y].append(x)\\n\\n        @lru_cache(None)\\n        def dp(node):\\n            return T[node - 1] + max([dp(child) for child in G[node]] + [0])\\n\\n        return max(dp(i) for i in range(1, n+1))\\n```\\n\\n#### Code 2\\nWe can write it in shorher way\\n```python\\nclass Solution:\\n    def minimumTime(self, n, R, T):\\n        G = defaultdict(list)\\n        for x, y in R: G[y] += [x]\\n        dp = cache(lambda x:T[x - 1] + max([dp(c) for c in G[x]] + [0]))\\n        return max(dp(i+1) for i in range(n))\\n```\\n\\nIf you have any questoins, feel free to ask. If you like the solution and explanation, please **upvote!**",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "```python\\nclass Solution:\\n    def minimumTime(self, n, R, T):\\n        G = defaultdict(list)\\n        for x, y in R:\\n            G[y].append(x)\\n\\n        @lru_cache(None)\\n        def dp(node):\\n            return T[node - 1] + max([dp(child) for child in G[node]] + [0])\\n\\n        return max(dp(i) for i in range(1, n+1))\\n```\n```python\\nclass Solution:\\n    def minimumTime(self, n, R, T):\\n        G = defaultdict(list)\\n        for x, y in R: G[y] += [x]\\n        dp = cache(lambda x:T[x - 1] + max([dp(c) for c in G[x]] + [0]))\\n        return max(dp(i+1) for i in range(n))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1816306,
                "title": "reason-for-10th-test-case-failure-reason-for-wrong-answer",
                "content": "So the inital logic that comes to mind is to greedy take all the courses with indegree 0, take the max time from them and keep on adding them to a solution.\\nHowever, here\\'s the simple testcase that fails with it - \\n\\n<img src=\\'https://assets.leetcode.com/users/images/c2f97b4f-3651-405e-b8d4-507551abe941_1646315711.2128415.jpeg\\' height=500 width = 700>\\n\\n\\nAccording to the naive solution, the result would go something like - \\n`max(1,100) + max(10,1) + max(1) = 111`.\\n\\nHowever, if the student take the course `1` and `3` together, the student can also **complete course 2 within the same timeframe**.\\nThat\\'s because course `2` only requires `1` as it\\'s prerequisite which we have already completed within the first month.\\n\\nBasically, the situation would go something like - \\n\\n```\\nt = 0 month -> Started studying the courses 1 and 3. \\nt = 1 month -> Completed course 1 and now taking course 2.\\nt = 11 month -> Completed course 2 as well. Course 3 is still going on.\\nt = 100 month -> Finally, completed course 3. Registering for course 4 now.\\nt = 101 month -> Completed course 4. Taking course 5.\\nt = 102 month -> Completed all courses.\\n```\\n\\nThat\\'s why we smartly need to maintain an array with each course completion time.\\n\\n",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nt = 0 month -> Started studying the courses 1 and 3. \\nt = 1 month -> Completed course 1 and now taking course 2.\\nt = 11 month -> Completed course 2 as well. Course 3 is still going on.\\nt = 100 month -> Finally, completed course 3. Registering for course 4 now.\\nt = 101 month -> Completed course 4. Taking course 5.\\nt = 102 month -> Completed all courses.\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1537481,
                "title": "c-topological-sort-kahn-s-algorithm-bfs",
                "content": "## Key observations\\n\\n1. One may can notice that at each node/course we want to know the maximum time of it\\'s parent node/previous course to be completed, this would be the starting time of this node/course.\\n1. We can only reach a node/course if all it\\'s previous (pre-requisite) nodes/courses are completed. This essentially means we want to traverse the graph in topological order.\\n\\nAll we want to do now is topologically propogate the maximum time a parent node finishes in to it\\'s child node and store the maximum time required to finish processing that child node. At the end we\\'ll just need to find the maximum of these finish times to get our result.\\n\\n## Solution\\n* We use Kahn\\'s algorithm to traverse the graph topologically.\\n* We want to create and adjacency list to easily traverse the graph and start with the nodes that have `in-degree=0`.\\n* We will store the time taken to complete all nodes and a vector `cTime`.\\n* We will also store the time taken to reach/start processing the node `node` in the queue.\\n\\nAt each node we want to process it from the queue using the following rules.\\n\\n1. Add `time[node]` to the time it took to reach the node, this will give us the completion time of that node. (The time we finish the course)\\n1. We would store this in `cTime` vector.\\n1. Next we go through all it\\'s children and update their `cTime` as maximum of the current completion time and previous noted `cTime`. This is an intermediate value which actually stores the maximum time it took to reach this node.\\n1. We reduce in-degree of all children and if it\\'s `0` we add it to our queue with it\\'s start time as `cTime[child]`.\\n\\nOnce we process all nodes and the queue is empty `cTime` would store the completion time of each `node`.\\n\\nAll we need to do now is get the maximum of them which would mean all nodes have been processed byt hat time.\\n\\n```c++\\nclass Solution {\\npublic:\\n    int minimumTime(int n, vector<vector<int>>& relations, vector<int>& time) {\\n        vector<vector<int>> adjList(n);\\n        vector<int> inDegree(n),cTime(n,0);\\n\\t\\t\\n        for(auto &r:relations) {           // Create adjacency list and in degree count vectors.\\n            adjList[r[0]-1].push_back(r[1]-1);\\n\\t\\t\\tinDegree[r[1]-1]++;\\n\\t\\t}\\n        queue<pair<int,int>> q;\\n\\t\\t\\n        for(int i=0;i<n;i++)             // Get all nodes with in-degree=0 and store add them to the queue.\\n            if(!inDegree[i])\\n                q.push({i,0});\\n\\n        while(!q.empty()) {\\n            auto [node,t]=q.front();     // Process node `node`.\\n            q.pop();\\n\\t\\t\\t\\n\\t\\t\\t// Completion time of the current node the time when the processing started `t`\\n\\t\\t\\t// (Max time at which prerequisutes completed) + the time taken to process it `time[node]`.\\n            int completionTime=t+time[node];\\n            cTime[node]=completionTime;   // Store the final completion time of the node `node`.\\n            \\n\\t\\t\\tfor(int &n:adjList[node]) {\\n\\t\\t\\t\\t// Update the intermediate completion time of the child node `n`.\\n\\t\\t\\t\\t// This means that node `n` would start processing at least at `cTime[n]`.\\n                cTime[n]=max(cTime[n],completionTime);\\n\\t\\t\\t\\t\\n                if(!--inDegree[n])        // Add the node with in-degree=0 to the queue.\\n                    q.push({n,cTime[n]});\\n            }\\n        }\\n\\t\\t// Return the maximum time it took for a node/course to complete as our result.\\n        return *max_element(cTime.begin(),cTime.end());\\n    }\\n};\\n```\\n\\n## Complexity\\nTime: `O(N+E)`. Where `N` is the number of nodes and `E` is the number of edges.\\nSpace: `O(N+E)`. Where `N` is the number of nodes and `E` is the number of edges.",
                "solutionTags": [
                    "C",
                    "Breadth-First Search"
                ],
                "code": "```c++\\nclass Solution {\\npublic:\\n    int minimumTime(int n, vector<vector<int>>& relations, vector<int>& time) {\\n        vector<vector<int>> adjList(n);\\n        vector<int> inDegree(n),cTime(n,0);\\n\\t\\t\\n        for(auto &r:relations) {           // Create adjacency list and in degree count vectors.\\n            adjList[r[0]-1].push_back(r[1]-1);\\n\\t\\t\\tinDegree[r[1]-1]++;\\n\\t\\t}\\n        queue<pair<int,int>> q;\\n\\t\\t\\n        for(int i=0;i<n;i++)             // Get all nodes with in-degree=0 and store add them to the queue.\\n            if(!inDegree[i])\\n                q.push({i,0});\\n\\n        while(!q.empty()) {\\n            auto [node,t]=q.front();     // Process node `node`.\\n            q.pop();\\n\\t\\t\\t\\n\\t\\t\\t// Completion time of the current node the time when the processing started `t`\\n\\t\\t\\t// (Max time at which prerequisutes completed) + the time taken to process it `time[node]`.\\n            int completionTime=t+time[node];\\n            cTime[node]=completionTime;   // Store the final completion time of the node `node`.\\n            \\n\\t\\t\\tfor(int &n:adjList[node]) {\\n\\t\\t\\t\\t// Update the intermediate completion time of the child node `n`.\\n\\t\\t\\t\\t// This means that node `n` would start processing at least at `cTime[n]`.\\n                cTime[n]=max(cTime[n],completionTime);\\n\\t\\t\\t\\t\\n                if(!--inDegree[n])        // Add the node with in-degree=0 to the queue.\\n                    q.push({n,cTime[n]});\\n            }\\n        }\\n\\t\\t// Return the maximum time it took for a node/course to complete as our result.\\n        return *max_element(cTime.begin(),cTime.end());\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1539942,
                "title": "java-topological-sort-bfs",
                "content": "**Intuition:**\\n1. Use in-degree to find the courses to start with. i.e. Courses with no prerequisite will be added first in the pool(in-degree == 0) and set ```completionTime = time[currentCourse]```.\\n2. After completing a course, we update prerequisite courses remaining i.e. decrement (--indegree[v]) and update next course.\\n```completionTime[nextCourse] = max(completionTime[nextCourse], completionTime[prevCourse] + time[nextCourse])```\\n3. If all prerequisite are complete(indegree == 0) we add it to queue\\n4. After visiting all courses we take maximum of completionTime from all courses.\\n```\\nclass Solution {\\n    public int minimumTime(int n, int[][] relations, int[] time) {\\n        List<Integer> adj[] = new ArrayList[n];\\n        int indegree[] = new int[n];\\n        int completionTime[] = new int[n];\\n        for(int i=0; i<n; i++) adj[i] = new ArrayList<>();\\n        for(int relation[]: relations){\\n            int u = relation[0]-1, v = relation[1]-1;\\n            adj[u].add(v);\\n            indegree[v]++;\\n        }\\n        Queue<Integer> q = new LinkedList<>();\\n        for(int i=0; i<n; i++){\\n            if(indegree[i] == 0){ // if no prerequisite add it to queue\\n                completionTime[i] = time[i];\\n                q.add(i);\\n            }\\n        }\\n        \\n        while(!q.isEmpty()){\\n            int u = q.poll();\\n            for(int v: adj[u]){\\n                completionTime[v] = Math.max(completionTime[v], completionTime[u] + time[v]);\\n                if(--indegree[v] == 0){ // when all prerequisite are complete add the next course\\n                    q.add(v);\\n                }\\n            }\\n        }\\n        int res=0;\\n        for(int x: completionTime) res = Math.max(res, x);\\n        return res;\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming",
                    "Breadth-First Search",
                    "Graph",
                    "Topological Sort"
                ],
                "code": "```completionTime = time[currentCourse]```\n```completionTime[nextCourse] = max(completionTime[nextCourse], completionTime[prevCourse] + time[nextCourse])```\n```\\nclass Solution {\\n    public int minimumTime(int n, int[][] relations, int[] time) {\\n        List<Integer> adj[] = new ArrayList[n];\\n        int indegree[] = new int[n];\\n        int completionTime[] = new int[n];\\n        for(int i=0; i<n; i++) adj[i] = new ArrayList<>();\\n        for(int relation[]: relations){\\n            int u = relation[0]-1, v = relation[1]-1;\\n            adj[u].add(v);\\n            indegree[v]++;\\n        }\\n        Queue<Integer> q = new LinkedList<>();\\n        for(int i=0; i<n; i++){\\n            if(indegree[i] == 0){ // if no prerequisite add it to queue\\n                completionTime[i] = time[i];\\n                q.add(i);\\n            }\\n        }\\n        \\n        while(!q.isEmpty()){\\n            int u = q.poll();\\n            for(int v: adj[u]){\\n                completionTime[v] = Math.max(completionTime[v], completionTime[u] + time[v]);\\n                if(--indegree[v] == 0){ // when all prerequisite are complete add the next course\\n                    q.add(v);\\n                }\\n            }\\n        }\\n        int res=0;\\n        for(int x: completionTime) res = Math.max(res, x);\\n        return res;\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1537501,
                "title": "c-topological-sort-bfs-or-dfs-memo-post-order-traversal",
                "content": "See my latest update in repo [LeetCode](https://github.com/lzl124631x/LeetCode)\\n\\n## Solution 1. Topological Sort (BFS)\\n\\nA node\\'s distance is its time plus the maximum distance of all predecessor nodes. We can calculate the distances via a topological sort. The answer is the maximum distance.\\n\\n```cpp\\n// OJ: https://leetcode.com/problems/parallel-courses-iii/\\n// Author: github.com/lzl124631x\\n// Time: O(N + E)\\n// Space: O(N + E)\\nclass Solution {\\npublic:\\n    int minimumTime(int n, vector<vector<int>>& E, vector<int>& T) {\\n        vector<vector<int>> G(n);\\n        vector<int> indegree(n), dist(n);\\n        for (auto &e : E) { // build graph and count indegrees\\n            G[e[0] - 1].push_back(e[1] - 1);\\n            indegree[e[1] - 1]++;\\n        }\\n        queue<int> q;\\n        for (int i = 0; i < n; ++i) {\\n            if (indegree[i] == 0) { // enqueue nodes with 0 indegree.\\n                q.push(i);\\n                dist[i] = T[i]; // source nodes\\' distance is their corresponding time\\n            } \\n        }\\n        while (q.size()) {\\n            int u = q.front();\\n            q.pop();\\n            for (int v : G[u]) {\\n                dist[v] = max(dist[u] + T[v], dist[v]); // update the distance of node `v` using the maximum distance of predecessor nodes.\\n                if (--indegree[v] == 0) q.push(v); // enqueue node `v` when its indegree drops to 0\\n            }\\n        }\\n        return *max_element(begin(dist), end(dist)); // the answer is the maximum distance.\\n    }\\n};\\n```\\n\\n## Solution 2. DFS + Memo (Post-order Traversal)\\n\\n```cpp\\n// OJ: https://leetcode.com/problems/parallel-courses-iii/\\n// Author: github.com/lzl124631x\\n// Time: O(N + E)\\n// Space: O(N + E)\\nclass Solution {\\npublic:\\n    int minimumTime(int n, vector<vector<int>>& E, vector<int>& T) {\\n        vector<vector<int>> G(n);\\n        vector<int> dist(n);\\n        for (auto &e : E) G[e[1] - 1].push_back(e[0] - 1);\\n        function<int(int)> dfs = [&](int u) {\\n            if (dist[u]) return dist[u];\\n            int mx = 0;\\n            for (int v : G[u]) mx = max(mx, dfs(v));\\n            return dist[u] = mx + T[u];\\n        };\\n        for (int i = 0; i < n; ++i) dfs(i);\\n        return *max_element(begin(dist), end(dist));\\n    }\\n};\\n```\\n",
                "solutionTags": [],
                "code": "```cpp\\n// OJ: https://leetcode.com/problems/parallel-courses-iii/\\n// Author: github.com/lzl124631x\\n// Time: O(N + E)\\n// Space: O(N + E)\\nclass Solution {\\npublic:\\n    int minimumTime(int n, vector<vector<int>>& E, vector<int>& T) {\\n        vector<vector<int>> G(n);\\n        vector<int> indegree(n), dist(n);\\n        for (auto &e : E) { // build graph and count indegrees\\n            G[e[0] - 1].push_back(e[1] - 1);\\n            indegree[e[1] - 1]++;\\n        }\\n        queue<int> q;\\n        for (int i = 0; i < n; ++i) {\\n            if (indegree[i] == 0) { // enqueue nodes with 0 indegree.\\n                q.push(i);\\n                dist[i] = T[i]; // source nodes\\' distance is their corresponding time\\n            } \\n        }\\n        while (q.size()) {\\n            int u = q.front();\\n            q.pop();\\n            for (int v : G[u]) {\\n                dist[v] = max(dist[u] + T[v], dist[v]); // update the distance of node `v` using the maximum distance of predecessor nodes.\\n                if (--indegree[v] == 0) q.push(v); // enqueue node `v` when its indegree drops to 0\\n            }\\n        }\\n        return *max_element(begin(dist), end(dist)); // the answer is the maximum distance.\\n    }\\n};\\n```\n```cpp\\n// OJ: https://leetcode.com/problems/parallel-courses-iii/\\n// Author: github.com/lzl124631x\\n// Time: O(N + E)\\n// Space: O(N + E)\\nclass Solution {\\npublic:\\n    int minimumTime(int n, vector<vector<int>>& E, vector<int>& T) {\\n        vector<vector<int>> G(n);\\n        vector<int> dist(n);\\n        for (auto &e : E) G[e[1] - 1].push_back(e[0] - 1);\\n        function<int(int)> dfs = [&](int u) {\\n            if (dist[u]) return dist[u];\\n            int mx = 0;\\n            for (int v : G[u]) mx = max(mx, dfs(v));\\n            return dist[u] = mx + T[u];\\n        };\\n        for (int i = 0; i < n; ++i) dfs(i);\\n        return *max_element(begin(dist), end(dist));\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2186067,
                "title": "two-solutions-dp-topological-sort-min-heap",
                "content": "**DP with Top Down Memoization**\\nJust converting this problem similar to course schedule.. \\nDo the current course if its prerequisites are completed.. and checking which prerequisite will take most time.. lets say the prerequisite that took most time is k months... assume current course to complete will take L months.. so I will wait for k months and after that I will do current course in L months.. So total time is ( L + k ) months to do current course...\\n\\n**WHY DP**\\n\\nIf two nodes N1 and N2 has same prerequisites.. lets say for node N1 we calculated all its prerequisites finishing time... now for N2 instead of calculating its prerequisties finishing time , we can take those values directly since previously we already computed those....\\n\\n```\\nclass Solution:\\n    def minimumTime(self, n: int, relations: List[List[int]], time: List[int]) -> int:\\n        graph = defaultdict(list)\\n        for v1,v2 in relations:\\n            graph[v2].append(v1)\\n            \\n        dp = {}\\n        def dfs(node):\\n            if node in dp:\\n                return dp[node]\\n            \\n            otherCoursesTime = 0\\n            for nei in graph[node]:\\n                otherCoursesTime = max(otherCoursesTime, dfs(nei))\\n                \\n            dp[node] = time[node-1] + otherCoursesTime\\n            return dp[node]\\n                   \\n        ans = 0\\n        for i in range(1,n+1):\\n            ans = max(ans,dfs(i))\\n        return ans\\n```\\n\\n**KAHN\\'S ALGO WITH PRIORITY QUEUE**\\n\\nInserting node in min heap if its indegree is 0.. based on its (wait period + duration to complete)\\nThe course which took longest time will be the duration to complete all courses...\\n```\\nclass Solution:\\n    def minimumTime(self, n: int, relations: List[List[int]], time: List[int]) -> int:\\n        graph = defaultdict(list)\\n        indegree = {}\\n        for i in range(1,n+1):\\n            indegree[i] = 0\\n        for v1,v2 in relations:\\n            graph[v1].append(v2)\\n            indegree[v2] += 1\\n        \\n        minHeap = []\\n       \\n        for key in indegree:\\n            if not indegree[key]:\\n                heappush(minHeap,[time[key-1],key])\\n        \\n        maxTime = 0\\n        while minHeap:\\n            duration,node = heappop(minHeap)\\n            maxTime = max(maxTime, duration)\\n            for nei in graph[node]:\\n                indegree[nei] -= 1\\n                if indegree[nei] == 0:\\n                    heappush(minHeap, [maxTime + time[nei-1],nei])\\n                    \\n        return maxTime\\n```\\n",
                "solutionTags": [
                    "Dynamic Programming",
                    "Depth-First Search",
                    "Topological Sort",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution:\\n    def minimumTime(self, n: int, relations: List[List[int]], time: List[int]) -> int:\\n        graph = defaultdict(list)\\n        for v1,v2 in relations:\\n            graph[v2].append(v1)\\n            \\n        dp = {}\\n        def dfs(node):\\n            if node in dp:\\n                return dp[node]\\n            \\n            otherCoursesTime = 0\\n            for nei in graph[node]:\\n                otherCoursesTime = max(otherCoursesTime, dfs(nei))\\n                \\n            dp[node] = time[node-1] + otherCoursesTime\\n            return dp[node]\\n                   \\n        ans = 0\\n        for i in range(1,n+1):\\n            ans = max(ans,dfs(i))\\n        return ans\\n```\n```\\nclass Solution:\\n    def minimumTime(self, n: int, relations: List[List[int]], time: List[int]) -> int:\\n        graph = defaultdict(list)\\n        indegree = {}\\n        for i in range(1,n+1):\\n            indegree[i] = 0\\n        for v1,v2 in relations:\\n            graph[v1].append(v2)\\n            indegree[v2] += 1\\n        \\n        minHeap = []\\n       \\n        for key in indegree:\\n            if not indegree[key]:\\n                heappush(minHeap,[time[key-1],key])\\n        \\n        maxTime = 0\\n        while minHeap:\\n            duration,node = heappop(minHeap)\\n            maxTime = max(maxTime, duration)\\n            for nei in graph[node]:\\n                indegree[nei] -= 1\\n                if indegree[nei] == 0:\\n                    heappush(minHeap, [maxTime + time[nei-1],nei])\\n                    \\n        return maxTime\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1537500,
                "title": "track-lead-time",
                "content": "This is kind of topological sort, but I always forget that sort so I use a simpler (to remember) version.\\n\\nWhen we build our dependency tree `al` (short for adjacency list), we track how many `prereq` each course has. Then, we find courses with no `prereq` and put them in the queue. As we \"take\" a course, we decrease `prereq` of dependent courses. Courses with `prereq == 0` can be taken during the next iteration.\\n\\nFor each node, we track the `lead` time - minimum time to complete all prerequisites. As we \"take\" a course, we set its completion time (which is, `lead[i] + time[i]`) as the `lead[j]` time for all dependent courses. Note that we need to use the maximum completion time among all prerequisites.\\n\\n**C++**\\n```cpp\\nint minimumTime(int n, vector<vector<int>>& relations, vector<int>& time) {\\n    vector<vector<int>> al(n);\\n    vector<int> prereq(n), lead(n);\\n    for (auto &r : relations) {\\n        al[r[0] - 1].push_back(r[1] - 1);\\n        ++prereq[r[1] - 1];\\n    }\\n    vector<int> q;\\n    for (int i = 0; i < n; ++i)\\n        if (prereq[i] == 0)\\n            q.push_back(i);\\n    while(!q.empty()) {\\n        vector<int> q1;\\n        for (int i : q) {\\n            lead[i] += time[i];\\n            for (int j : al[i]) {\\n                lead[j] = max(lead[j], lead[i]);\\n                if (--prereq[j] == 0)\\n                    q1.push_back(j);\\n            }\\n        }\\n        swap(q, q1);\\n    }\\n    return *max_element(begin(lead), end(lead));\\n}\\n```\\n**Java**\\n```java\\npublic int minimumTime(int n, int[][] relations, int[] time) {\\n    List<List<Integer>> al = new ArrayList<>();\\n    int[] prereq = new int[n], lead = new int[n];\\n    for (int i = 0; i < n; ++i)\\n        al.add(new ArrayList<Integer>());    \\n    for (var r : relations) {\\n        ++prereq[r[1] - 1];\\n        al.get(r[0] - 1).add(r[1] - 1);\\n    }\\n    List<Integer> q = new ArrayList<>();\\n    for (int i = 0; i < n; ++i)\\n        if (prereq[i] == 0)\\n            q.add(i);        \\n    while(!q.isEmpty()) {\\n        List<Integer> q1 = new ArrayList<>();\\n        for (int i : q) {\\n            lead[i] += time[i];\\n            for (int j : al.get(i)) {\\n                lead[j] = Math.max(lead[j], lead[i]);\\n                if (--prereq[j] == 0)\\n                    q1.add(j);\\n            }\\n        }\\n        q = q1;\\n    }\\n    return Arrays.stream(lead).max().getAsInt();\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "C"
                ],
                "code": "```cpp\\nint minimumTime(int n, vector<vector<int>>& relations, vector<int>& time) {\\n    vector<vector<int>> al(n);\\n    vector<int> prereq(n), lead(n);\\n    for (auto &r : relations) {\\n        al[r[0] - 1].push_back(r[1] - 1);\\n        ++prereq[r[1] - 1];\\n    }\\n    vector<int> q;\\n    for (int i = 0; i < n; ++i)\\n        if (prereq[i] == 0)\\n            q.push_back(i);\\n    while(!q.empty()) {\\n        vector<int> q1;\\n        for (int i : q) {\\n            lead[i] += time[i];\\n            for (int j : al[i]) {\\n                lead[j] = max(lead[j], lead[i]);\\n                if (--prereq[j] == 0)\\n                    q1.push_back(j);\\n            }\\n        }\\n        swap(q, q1);\\n    }\\n    return *max_element(begin(lead), end(lead));\\n}\\n```\n```java\\npublic int minimumTime(int n, int[][] relations, int[] time) {\\n    List<List<Integer>> al = new ArrayList<>();\\n    int[] prereq = new int[n], lead = new int[n];\\n    for (int i = 0; i < n; ++i)\\n        al.add(new ArrayList<Integer>());    \\n    for (var r : relations) {\\n        ++prereq[r[1] - 1];\\n        al.get(r[0] - 1).add(r[1] - 1);\\n    }\\n    List<Integer> q = new ArrayList<>();\\n    for (int i = 0; i < n; ++i)\\n        if (prereq[i] == 0)\\n            q.add(i);        \\n    while(!q.isEmpty()) {\\n        List<Integer> q1 = new ArrayList<>();\\n        for (int i : q) {\\n            lead[i] += time[i];\\n            for (int j : al.get(i)) {\\n                lead[j] = Math.max(lead[j], lead[i]);\\n                if (--prereq[j] == 0)\\n                    q1.add(j);\\n            }\\n        }\\n        q = q1;\\n    }\\n    return Arrays.stream(lead).max().getAsInt();\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1538994,
                "title": "python-heap-solution-straightforward",
                "content": "```\\nclass Solution:\\n    def minimumTime(self, n: int, relations: List[List[int]], time: List[int]) -> int:\\n        from collections import defaultdict\\n        import heapq\\n        dependents = defaultdict(list)\\n        indegree = defaultdict(int)\\n        \\n        for x,y in relations:\\n            dependents[x].append(y)\\n            indegree[y] += 1\\n        \\n        heap_list = []\\n        for i in range(1,n+1):\\n            if i not in indegree:\\n                heapq.heappush(heap_list,(time[i-1],i))\\n        \\n        while heap_list:\\n            curr_time,class_num = heapq.heappop(heap_list)\\n            for child in dependents[class_num]:\\n                indegree[child] -= 1\\n                if indegree[child] == 0:\\n                    heapq.heappush(heap_list,(curr_time+time[child-1],child))\\n        return curr_time\\n        \\n\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def minimumTime(self, n: int, relations: List[List[int]], time: List[int]) -> int:\\n        from collections import defaultdict\\n        import heapq\\n        dependents = defaultdict(list)\\n        indegree = defaultdict(int)\\n        \\n        for x,y in relations:\\n            dependents[x].append(y)\\n            indegree[y] += 1\\n        \\n        heap_list = []\\n        for i in range(1,n+1):\\n            if i not in indegree:\\n                heapq.heappush(heap_list,(time[i-1],i))\\n        \\n        while heap_list:\\n            curr_time,class_num = heapq.heappop(heap_list)\\n            for child in dependents[class_num]:\\n                indegree[child] -= 1\\n                if indegree[child] == 0:\\n                    heapq.heappush(heap_list,(curr_time+time[child-1],child))\\n        return curr_time\\n        \\n\\n",
                "codeTag": "Java"
            },
            {
                "id": 1537609,
                "title": "c-topological-sort-bfs-kahn-algo",
                "content": "In this question we have to find the path having max-weight , do same as topological sort via using BFS , in topological sorting we will push new element in queue when the indegree will be zero  here we push in that thing only but for weight we will compare with already stored value with its original time + parent\\'s time -\\n\\n**maxTime[node] = max(maxTime[node],maxTime[parentNode]+time[node-1]);**   // node-1 bcz 0 based indexing used in given time array\\n\\n```\\nclass Solution {\\npublic:\\n    int minimumTime(int n, vector<vector<int>>& rel, vector<int>& time) {\\n        vector<long long int> adj[n+1];\\n        vector<long long int> indegree(n+1,0);\\n        vector<long long int> maxTime(n+1,0);\\n        for(long long int i=0;i<rel.size();i++)\\n        {\\n            adj[rel[i][0]].push_back(rel[i][1]);\\n            indegree[rel[i][1]]++;\\n        }\\n        queue<long long int>q;\\n        for(int i=1;i<=n;i++)\\n        {\\n            maxTime[i] = time[i-1];\\n            if(!indegree[i])\\n            {\\n                q.push(i);\\n            }\\n        }\\n        while(!q.empty())\\n        {\\n            int ss = q.size();\\n            for(int i=0;i<ss;i++)\\n            {\\n                int parentNode = q.front();q.pop();\\n                // cout<<node<<\" \"<<adj[node].size();\\n                for(long long int child : adj[parentNode])\\n                {\\n                    indegree[child]--;\\n                     maxTime[child] = max(maxTime[child],maxTime[parentNode]+time[child-1]);\\n                    if(!indegree[child])\\n                    {\\n                        q.push(child);\\n                    }\\n                }\\n            }\\n            \\n            \\n        }\\n        long long int ans = -1;\\n        for(long long int value : maxTime)\\n            ans = max(ans , value);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Breadth-First Search",
                    "Graph",
                    "Topological Sort"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumTime(int n, vector<vector<int>>& rel, vector<int>& time) {\\n        vector<long long int> adj[n+1];\\n        vector<long long int> indegree(n+1,0);\\n        vector<long long int> maxTime(n+1,0);\\n        for(long long int i=0;i<rel.size();i++)\\n        {\\n            adj[rel[i][0]].push_back(rel[i][1]);\\n            indegree[rel[i][1]]++;\\n        }\\n        queue<long long int>q;\\n        for(int i=1;i<=n;i++)\\n        {\\n            maxTime[i] = time[i-1];\\n            if(!indegree[i])\\n            {\\n                q.push(i);\\n            }\\n        }\\n        while(!q.empty())\\n        {\\n            int ss = q.size();\\n            for(int i=0;i<ss;i++)\\n            {\\n                int parentNode = q.front();q.pop();\\n                // cout<<node<<\" \"<<adj[node].size();\\n                for(long long int child : adj[parentNode])\\n                {\\n                    indegree[child]--;\\n                     maxTime[child] = max(maxTime[child],maxTime[parentNode]+time[child-1]);\\n                    if(!indegree[child])\\n                    {\\n                        q.push(child);\\n                    }\\n                }\\n            }\\n            \\n            \\n        }\\n        long long int ans = -1;\\n        for(long long int value : maxTime)\\n            ans = max(ans , value);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2266591,
                "title": "why-this-approach-is-wrong",
                "content": "WHat i Do is take maximum of all indegree[0] the sum with  maximum of  all indegree[1] ans so on..\\n\\nWHy this approach is wrong\\n\\n```\\nclass Solution {\\npublic:\\n    \\n    int topo(vector<int> adj[],vector<int>  &time,vector<int> &indegree,vector<int> &visit)\\n    {\\n        queue<int> q;\\n        for(int i = 0;i<indegree.size();i++)\\n            if(indegree[i] == 0)\\n        q.push(i);\\n        \\n        int ans = 0;\\n        \\n        while(!q.empty())\\n        {\\n            int size = q.size();\\n            int count = 0;\\n            for(int i = 0;i<size;i++)\\n            {\\n                int parent = q.front();\\n                q.pop();\\n                count = max(count,time[parent]);\\n                for(int child : adj[parent])\\n                {\\n                    indegree[child]--;\\n                    if(indegree[child] == 0)\\n                        q.push(child);\\n                }\\n            }\\n            ans = ans + count;\\n        }\\n        \\n        return ans;\\n    }\\n    \\n    \\n    int minimumTime(int n, vector<vector<int>>& relations, vector<int>& time) {\\n     \\n        vector<int> adj[n];\\n        vector<int>  indegree(n,0);\\n        \\n        for(int i = 0;i<relations.size();i++){\\n            adj[relations[i][0]-1].push_back(relations[i][1]-1);\\n            indegree[relations[i][1]-1]++;\\n        }\\n        \\n    \\n        \\n        \\n        vector<int> visit(n,false);\\n        \\n         return topo(adj,time,indegree,visit);\\n        \\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "Topological Sort"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    int topo(vector<int> adj[],vector<int>  &time,vector<int> &indegree,vector<int> &visit)\\n    {\\n        queue<int> q;\\n        for(int i = 0;i<indegree.size();i++)\\n            if(indegree[i] == 0)\\n        q.push(i);\\n        \\n        int ans = 0;\\n        \\n        while(!q.empty())\\n        {\\n            int size = q.size();\\n            int count = 0;\\n            for(int i = 0;i<size;i++)\\n            {\\n                int parent = q.front();\\n                q.pop();\\n                count = max(count,time[parent]);\\n                for(int child : adj[parent])\\n                {\\n                    indegree[child]--;\\n                    if(indegree[child] == 0)\\n                        q.push(child);\\n                }\\n            }\\n            ans = ans + count;\\n        }\\n        \\n        return ans;\\n    }\\n    \\n    \\n    int minimumTime(int n, vector<vector<int>>& relations, vector<int>& time) {\\n     \\n        vector<int> adj[n];\\n        vector<int>  indegree(n,0);\\n        \\n        for(int i = 0;i<relations.size();i++){\\n            adj[relations[i][0]-1].push_back(relations[i][1]-1);\\n            indegree[relations[i][1]-1]++;\\n        }\\n        \\n    \\n        \\n        \\n        vector<int> visit(n,false);\\n        \\n         return topo(adj,time,indegree,visit);\\n        \\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1656159,
                "title": "please-make-your-interviewer-happy",
                "content": "As someone who interviews candidates to get into big tech companies, I can\\'t emphasize how important CLEAN CODE is.\\n\\nWe want to work with you. So we will have to read your code.\\n\\nWe are also looking for basic object oriented design knowledge.\\n\\nIf you break your spagetti code into smaller pieces, you\\'ll get a lot of benifits during the interview. Your interviewer won\\'t need you to implement less important methods or classes, and you\\'ll get bonus points for making your code readable.\\n\\nFor most interviewers, writing clean and readable code is at least as important as writing a working code with good time complexity, especially for more senior positions.\\n\\nDespite having the best time complexity, this code is not the fastest way to solve the problem, but let\\'s see if you can understand it without my explanations or comments.\\n\\n\\n```\\nMap<Integer, Course> graph;\\n\\npublic int minimumTime(int n, int[][] relations, int[] time) {\\n    createGraph(n, relations, time);\\n    return getMaxTotalTime();\\n}\\n\\n\\tprivate void createGraph(int n, int[][] relations, int[] time) {\\n\\t\\tgraph = new HashMap<>();\\n\\t\\tfor (int i = 1; i <= n; ++i) {\\n\\t\\t\\tCourse course = new Course(time[i - 1]);\\n\\t\\t\\tgraph.put(i, course);\\n\\t\\t}\\n\\t\\tfor (int[] relation : relations) {\\n\\t\\t\\tconnect(relation[0], relation[1]);\\n\\t\\t}\\n\\t}\\n\\n\\t\\tprivate void connect(int preRequisiteCourseId, int futureCourseId) {\\n\\t\\t\\tCourse preRequisiteCourse = graph.get(preRequisiteCourseId);\\n\\t\\t\\tCourse futureCourse = graph.get(futureCourseId);\\n\\t\\t\\tfutureCourse.add(preRequisiteCourse);\\n\\t\\t}\\n\\n\\tprivate int getMaxTotalTime() {\\n\\t\\tint max = 0;\\n\\t\\tfor (int i = 1; i <= graph.size(); ++i) {\\n\\t\\t\\tCourse course = graph.get(i);\\n\\t\\t\\tint totalTime = course.getTotalTime();\\n\\t\\t\\tmax = Math.max(max, totalTime);\\n\\t\\t}\\n\\t\\treturn max;\\n\\t}\\n\\nprivate class Course {\\n    private int time;\\n    private Set<Course> preRequistes;\\n    private boolean isTotalTimeCalculated;\\n\\n    private Course(int time) {\\n        this.time = time;\\n        preRequistes = new HashSet<>();\\n    }\\n\\n    private int getTotalTime() {\\n        if (isTotalTimeCalculated) {\\n            return time;\\n        }\\n        isTotalTimeCalculated = true;\\n        time += getMaxPreRequisite(preRequistes);\\n        return time;\\n    }\\n\\n\\t\\tprivate int getMaxPreRequisite(Set<Course> neighbors) {\\n\\t\\t\\tint max = 0;\\n\\t\\t\\tfor (Course nbr : neighbors) {\\n\\t\\t\\t\\tmax = Math.max(max, nbr.getTotalTime());\\n\\t\\t\\t}\\n\\t\\t\\treturn max;\\n\\t\\t}\\n\\n    private void add(Course preRequisite) {\\n        preRequistes.add(preRequisite);\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nMap<Integer, Course> graph;\\n\\npublic int minimumTime(int n, int[][] relations, int[] time) {\\n    createGraph(n, relations, time);\\n    return getMaxTotalTime();\\n}\\n\\n\\tprivate void createGraph(int n, int[][] relations, int[] time) {\\n\\t\\tgraph = new HashMap<>();\\n\\t\\tfor (int i = 1; i <= n; ++i) {\\n\\t\\t\\tCourse course = new Course(time[i - 1]);\\n\\t\\t\\tgraph.put(i, course);\\n\\t\\t}\\n\\t\\tfor (int[] relation : relations) {\\n\\t\\t\\tconnect(relation[0], relation[1]);\\n\\t\\t}\\n\\t}\\n\\n\\t\\tprivate void connect(int preRequisiteCourseId, int futureCourseId) {\\n\\t\\t\\tCourse preRequisiteCourse = graph.get(preRequisiteCourseId);\\n\\t\\t\\tCourse futureCourse = graph.get(futureCourseId);\\n\\t\\t\\tfutureCourse.add(preRequisiteCourse);\\n\\t\\t}\\n\\n\\tprivate int getMaxTotalTime() {\\n\\t\\tint max = 0;\\n\\t\\tfor (int i = 1; i <= graph.size(); ++i) {\\n\\t\\t\\tCourse course = graph.get(i);\\n\\t\\t\\tint totalTime = course.getTotalTime();\\n\\t\\t\\tmax = Math.max(max, totalTime);\\n\\t\\t}\\n\\t\\treturn max;\\n\\t}\\n\\nprivate class Course {\\n    private int time;\\n    private Set<Course> preRequistes;\\n    private boolean isTotalTimeCalculated;\\n\\n    private Course(int time) {\\n        this.time = time;\\n        preRequistes = new HashSet<>();\\n    }\\n\\n    private int getTotalTime() {\\n        if (isTotalTimeCalculated) {\\n            return time;\\n        }\\n        isTotalTimeCalculated = true;\\n        time += getMaxPreRequisite(preRequistes);\\n        return time;\\n    }\\n\\n\\t\\tprivate int getMaxPreRequisite(Set<Course> neighbors) {\\n\\t\\t\\tint max = 0;\\n\\t\\t\\tfor (Course nbr : neighbors) {\\n\\t\\t\\t\\tmax = Math.max(max, nbr.getTotalTime());\\n\\t\\t\\t}\\n\\t\\t\\treturn max;\\n\\t\\t}\\n\\n    private void add(Course preRequisite) {\\n        preRequistes.add(preRequisite);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1539506,
                "title": "c-topological-sort-dp",
                "content": "```\\nclass Solution {\\npublic:\\n    int minimumTime(int n, vector<vector<int>>& relations, vector<int>& time) {\\n        vector<vector<int>> adj(n+1);\\n        vector<int> indegree(n+1);\\n        for(auto &d : relations){\\n            adj[d[0]].push_back(d[1]);\\n            indegree[d[1]]++;\\n        }\\n        \\n        queue<int> q;\\n        vector<int> dp(n+1,0);\\n        for(int i=1;i<=n;++i){\\n            if(indegree[i]==0){ \\n                q.push(i);\\n                dp[i]=time[i-1];\\n            }\\n        }\\n        \\n        while(!q.empty()){\\n            int size = q.size();\\n            while(size--){\\n                int cur = q.front(); q.pop();\\n                for(auto &child : adj[cur]){\\n                    dp[child]=max(dp[child], dp[cur]+time[child-1]);\\n                    indegree[child]--;\\n                    if(indegree[child]==0){\\n                        q.push(child);\\n                    }\\n                }\\n            }\\n        }\\n        \\n        int maxTime = 0;\\n        for(auto &x : dp) maxTime = max(maxTime,x);\\n        return maxTime;\\n    }\\n};\\n```\\nPlease **UPVOTE**",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming",
                    "Topological Sort",
                    "Queue"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumTime(int n, vector<vector<int>>& relations, vector<int>& time) {\\n        vector<vector<int>> adj(n+1);\\n        vector<int> indegree(n+1);\\n        for(auto &d : relations){\\n            adj[d[0]].push_back(d[1]);\\n            indegree[d[1]]++;\\n        }\\n        \\n        queue<int> q;\\n        vector<int> dp(n+1,0);\\n        for(int i=1;i<=n;++i){\\n            if(indegree[i]==0){ \\n                q.push(i);\\n                dp[i]=time[i-1];\\n            }\\n        }\\n        \\n        while(!q.empty()){\\n            int size = q.size();\\n            while(size--){\\n                int cur = q.front(); q.pop();\\n                for(auto &child : adj[cur]){\\n                    dp[child]=max(dp[child], dp[cur]+time[child-1]);\\n                    indegree[child]--;\\n                    if(indegree[child]==0){\\n                        q.push(child);\\n                    }\\n                }\\n            }\\n        }\\n        \\n        int maxTime = 0;\\n        for(auto &x : dp) maxTime = max(maxTime,x);\\n        return maxTime;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1538175,
                "title": "c-toposort-dfs-no-queue-no-indegree-iterative-dp",
                "content": "For this problem we use the topological sort to know in witch order process the dp states (any toposort is valid for this purpose) because the transitions between states in any dp problem can be represented as a DAG and this case we can use explicity the graph.\\n\\nSteps:\\n1. Inicially all the distances are equal to given time.\\n2. For each node u in the toposort we do the following:\\n\\t2.1 For every vertex v next to u:\\n\\t2.2 dist[v] = max(dist[v], dist[u] + time[v])    \\n\\n```cpp\\nclass Solution {\\n    \\n    vector<vector<int>> AdjList;\\n    vector<int> visited, topoSort;\\n\\n    void dfs(int u) {\\n        visited[u] = true;\\n        for (int v : AdjList[u]) {\\n            if (!visited[v])\\n                dfs(v);\\n        }\\n        topoSort.push_back(u);\\n    }\\n    \\n    int longestPath(int V, vector<int> &time) {\\n        vector<int> dist(V, 0);\\n        for (int i = 0; i < V; i++)\\n            dist[i] = time[i];\\n        \\n        for (int i = 0; i < topoSort.size(); i++) {\\n            int u = topoSort[i];\\n            for (int v : AdjList[u]) {\\n                if (dist[v] < dist[u] + time[v]) // Relaxation\\n                    dist[v] = dist[u] + time[v];\\n            }\\n        }\\n        int longest = *max_element(dist.begin(), dist.end());\\n        return longest;\\n    }\\n    \\npublic:\\n    int minimumTime(int n, vector<vector<int>>& relations, vector<int>& time) {\\n        int V = n;\\n        // Build graph\\n        AdjList.assign(V, vector<int>());\\n        for (int i = 0; i < relations.size(); i++) {\\n            AdjList[relations[i][0] - 1].push_back(relations[i][1] - 1);\\n        }\\n        // Get topological sort\\n        visited.assign(V, false);\\n\\t    for (int i = 0; i < n; i++)\\n            if (!visited[i])\\n                dfs(i);\\n\\t    reverse(topoSort.begin(), topoSort.end());\\n        // Get longest path\\n        return longestPath(V, time);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Depth-First Search",
                    "Topological Sort"
                ],
                "code": "```cpp\\nclass Solution {\\n    \\n    vector<vector<int>> AdjList;\\n    vector<int> visited, topoSort;\\n\\n    void dfs(int u) {\\n        visited[u] = true;\\n        for (int v : AdjList[u]) {\\n            if (!visited[v])\\n                dfs(v);\\n        }\\n        topoSort.push_back(u);\\n    }\\n    \\n    int longestPath(int V, vector<int> &time) {\\n        vector<int> dist(V, 0);\\n        for (int i = 0; i < V; i++)\\n            dist[i] = time[i];\\n        \\n        for (int i = 0; i < topoSort.size(); i++) {\\n            int u = topoSort[i];\\n            for (int v : AdjList[u]) {\\n                if (dist[v] < dist[u] + time[v]) // Relaxation\\n                    dist[v] = dist[u] + time[v];\\n            }\\n        }\\n        int longest = *max_element(dist.begin(), dist.end());\\n        return longest;\\n    }\\n    \\npublic:\\n    int minimumTime(int n, vector<vector<int>>& relations, vector<int>& time) {\\n        int V = n;\\n        // Build graph\\n        AdjList.assign(V, vector<int>());\\n        for (int i = 0; i < relations.size(); i++) {\\n            AdjList[relations[i][0] - 1].push_back(relations[i][1] - 1);\\n        }\\n        // Get topological sort\\n        visited.assign(V, false);\\n\\t    for (int i = 0; i < n; i++)\\n            if (!visited[i])\\n                dfs(i);\\n\\t    reverse(topoSort.begin(), topoSort.end());\\n        // Get longest path\\n        return longestPath(V, time);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2065621,
                "title": "python-topological-sort-bfs-dp",
                "content": "```\\n    def minimumTime(self, n: int, relations: List[List[int]], time: List[int]) -> int:\\n        dp = [t for t in time]\\n        res = 0\\n        indegree = [0 for _ in range(n)]\\n        suc = [set() for _ in range(n)]\\n        for prevCourse, nextCourse in relations:\\n            suc[prevCourse - 1].add(nextCourse - 1)\\n            indegree[nextCourse - 1] += 1\\n        sources = [v for v in range(n) if indegree[v] == 0]\\n        while sources:\\n            s = sources.pop() # can be any sequence to delete\\n            res = max(res, dp[s])\\n            for v in suc[s]:\\n                dp[v] = max(dp[v], dp[s] + time[v])\\n                indegree[v] -= 1\\n                if indegree[v] == 0:\\n                    sources.append(v)\\n        return res\\n```\\nTime complexity: O(|E| + |V|)\\nSpace complexity: O(|V|)",
                "solutionTags": [],
                "code": "```\\n    def minimumTime(self, n: int, relations: List[List[int]], time: List[int]) -> int:\\n        dp = [t for t in time]\\n        res = 0\\n        indegree = [0 for _ in range(n)]\\n        suc = [set() for _ in range(n)]\\n        for prevCourse, nextCourse in relations:\\n            suc[prevCourse - 1].add(nextCourse - 1)\\n            indegree[nextCourse - 1] += 1\\n        sources = [v for v in range(n) if indegree[v] == 0]\\n        while sources:\\n            s = sources.pop() # can be any sequence to delete\\n            res = max(res, dp[s])\\n            for v in suc[s]:\\n                dp[v] = max(dp[v], dp[s] + time[v])\\n                indegree[v] -= 1\\n                if indegree[v] == 0:\\n                    sources.append(v)\\n        return res\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2185893,
                "title": "c-explained-solution-topological-sort-kahn-s-algorithm-bfs",
                "content": "**Key observations**\\n1. One may can notice that at each node/course we want to know the maximum time of it\\'s parent node/previous course to be completed, this would be the starting time of this node/course.\\n1. We can only reach a node/course if all it\\'s previous (pre-requisite) nodes/courses are completed. This essentially means we want to traverse the graph in topological order.\\n\\nAll we want to do now is topologically propogate the maximum time a parent node finishes in to it\\'s child node and store the maximum time required to finish processing that child node. At the end we\\'ll just need to find the maximum of these finish times to get our result.\\n\\n**Solution**\\n* We use Kahn\\'s algorithm to traverse the graph topologically.\\n* We want to create and adjacency list to easily traverse the graph and start with the nodes that have in-degree=0.\\n* We will store the time taken to complete all nodes and a vector cTime.\\n* We will also store the time taken to reach/start processing the node node in the queue.\\n* At each node we want to process it from the queue using the following rules.\\n\\nAdd time[node] to the time it took to reach the node, this will give us the completion time of that node. (The time we finish the course).\\n* We would store this in cTime vector.\\n* Next we go through all it\\'s children and update their cTime as maximum of the current completion time and previous noted cTime. This is an intermediate value which actually stores the maximum time it took to reach this node.\\n* We reduce in-degree of all children and if it\\'s 0 we add it to our queue with it\\'s start time as cTime[child].\\n\\nOnce we process all nodes and the queue is empty cTime would store the completion time of each node.\\nAll we need to do now is get the maximum of them which would mean all nodes have been processed byt hat time.\\n\\n```\\nclass Solution {\\npublic:\\n    int minimumTime(int n, vector<vector<int>>& relations, vector<int>& time) {\\n        vector<vector<int>> adjList(n);\\n        vector<int> inDegree(n),cTime(n,0);\\n\\t\\t\\n        for(auto &r:relations) {           // Create adjacency list and in degree count vectors.\\n            adjList[r[0]-1].push_back(r[1]-1);\\n\\t\\t\\tinDegree[r[1]-1]++;\\n\\t\\t}\\n        queue<pair<int,int>> q;\\n\\t\\t\\n        for(int i=0;i<n;i++)             // Get all nodes with in-degree=0 and store add them to the queue.\\n            if(!inDegree[i])\\n                q.push({i,0});\\n\\n        while(!q.empty()) {\\n            auto [node,t]=q.front();     // Process node `node`.\\n            q.pop();\\n\\t\\t\\t\\n\\t\\t\\t// Completion time of the current node the time when the processing started `t`\\n\\t\\t\\t// (Max time at which prerequisutes completed) + the time taken to process it `time[node]`.\\n            int completionTime=t+time[node];\\n            cTime[node]=completionTime;   // Store the final completion time of the node `node`.\\n            \\n\\t\\t\\tfor(int &n:adjList[node]) {\\n\\t\\t\\t\\t// Update the intermediate completion time of the child node `n`.\\n\\t\\t\\t\\t// This means that node `n` would start processing at least at `cTime[n]`.\\n                cTime[n]=max(cTime[n],completionTime);\\n\\t\\t\\t\\t\\n                if(!--inDegree[n])        // Add the node with in-degree=0 to the queue.\\n                    q.push({n,cTime[n]});\\n            }\\n        }\\n\\t\\t// Return the maximum time it took for a node/course to complete as our result.\\n        return *max_element(cTime.begin(),cTime.end());\\n    }\\n};\\n```\\n**Complexity**\\n*Time: O(N+E). Where N is the number of nodes and E is the number of edges.\\nSpace: O(N+E). Where N is the number of nodes and E is the number of edges.*\\n\\n**Runtime:** 417 ms, faster than 96.58% of C++ online submissions for Parallel Courses III.\\n**Memory Usage:** 132.6 MB, less than 66.56% of C++ online submissions for Parallel Courses III.",
                "solutionTags": [
                    "C",
                    "Breadth-First Search",
                    "Topological Sort"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumTime(int n, vector<vector<int>>& relations, vector<int>& time) {\\n        vector<vector<int>> adjList(n);\\n        vector<int> inDegree(n),cTime(n,0);\\n\\t\\t\\n        for(auto &r:relations) {           // Create adjacency list and in degree count vectors.\\n            adjList[r[0]-1].push_back(r[1]-1);\\n\\t\\t\\tinDegree[r[1]-1]++;\\n\\t\\t}\\n        queue<pair<int,int>> q;\\n\\t\\t\\n        for(int i=0;i<n;i++)             // Get all nodes with in-degree=0 and store add them to the queue.\\n            if(!inDegree[i])\\n                q.push({i,0});\\n\\n        while(!q.empty()) {\\n            auto [node,t]=q.front();     // Process node `node`.\\n            q.pop();\\n\\t\\t\\t\\n\\t\\t\\t// Completion time of the current node the time when the processing started `t`\\n\\t\\t\\t// (Max time at which prerequisutes completed) + the time taken to process it `time[node]`.\\n            int completionTime=t+time[node];\\n            cTime[node]=completionTime;   // Store the final completion time of the node `node`.\\n            \\n\\t\\t\\tfor(int &n:adjList[node]) {\\n\\t\\t\\t\\t// Update the intermediate completion time of the child node `n`.\\n\\t\\t\\t\\t// This means that node `n` would start processing at least at `cTime[n]`.\\n                cTime[n]=max(cTime[n],completionTime);\\n\\t\\t\\t\\t\\n                if(!--inDegree[n])        // Add the node with in-degree=0 to the queue.\\n                    q.push({n,cTime[n]});\\n            }\\n        }\\n\\t\\t// Return the maximum time it took for a node/course to complete as our result.\\n        return *max_element(cTime.begin(),cTime.end());\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1543404,
                "title": "python-topological-sort-beats-93-5",
                "content": "in_degree maintains value of indegree of that particular node.\\ngraph is u-v graph where node goes from u to v.\\nlatest maintains latest updated value of completing work at that particular node.We take max in succesive iterations when that node is the neighbour.\\nSimple topological sort untill all nodes indegree=0.\\nbfs will stop when all nodes are processed once.Simply return max value of latest as it will be the minimum time.\\n\\n```\\nclass Solution:\\n    def minimumTime(self, n: int, relations: List[List[int]], time: List[int]) -> int:\\n        in_degree=defaultdict(int)\\n        graph=defaultdict(list)\\n        latest=[0]*(n+1)\\n        for u,v in relations:\\n            graph[u].append(v)\\n            in_degree[v]+=1\\n        q=[]\\n        for i in range(1,n+1):\\n            if in_degree[i]==0:\\n                latest[i]=time[i-1]\\n                q.append(i)\\n        while q:\\n            node=q.pop()\\n            t0=latest[node]\\n            for nei in graph[node]:\\n                t=time[nei-1]\\n                latest[nei]=max(latest[nei],t0+t)\\n                in_degree[nei]-=1\\n                if in_degree[nei]==0:\\n                    q.append(nei)\\n        return max(latest)\\n                    \\n            \\n            \\n```",
                "solutionTags": [
                    "Python",
                    "Breadth-First Search",
                    "Topological Sort"
                ],
                "code": "```\\nclass Solution:\\n    def minimumTime(self, n: int, relations: List[List[int]], time: List[int]) -> int:\\n        in_degree=defaultdict(int)\\n        graph=defaultdict(list)\\n        latest=[0]*(n+1)\\n        for u,v in relations:\\n            graph[u].append(v)\\n            in_degree[v]+=1\\n        q=[]\\n        for i in range(1,n+1):\\n            if in_degree[i]==0:\\n                latest[i]=time[i-1]\\n                q.append(i)\\n        while q:\\n            node=q.pop()\\n            t0=latest[node]\\n            for nei in graph[node]:\\n                t=time[nei-1]\\n                latest[nei]=max(latest[nei],t0+t)\\n                in_degree[nei]-=1\\n                if in_degree[nei]==0:\\n                    q.append(nei)\\n        return max(latest)\\n                    \\n            \\n            \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3048539,
                "title": "c-topological-sort",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minimumTime(int n, vector<vector<int>>& relations, vector<int>& time) {\\n        queue<int> q;\\n        vector<vector<int>> adj(n+1);\\n        vector<int> rest(n+1,0);\\n        vector<int> indeg(n+1);\\n        for(int i = 0;i<relations.size();i++)\\n        {\\n            adj[relations[i][0]].push_back(relations[i][1]);\\n            indeg[relations[i][1]]++;\\n        }\\n        for(int i=1;i<=n;i++)\\n        {\\n            if(indeg[i] == 0)\\n            {\\n                q.push(i);\\n                rest[i] = time[i-1];\\n            }\\n        }\\n        int result = 0;\\n        while(q.empty() == 0)\\n        {\\n            int size = q.size();\\n            while(size--)\\n            {\\n                int u = q.front();\\n                q.pop();\\n             \\n                for(int v:adj[u])\\n                {\\n                    indeg[v]--;\\n                    rest[v] = max(rest[v],rest[u]+time[v-1]);\\n                    if(indeg[v] == 0)\\n                    {\\n                        q.push(v);\\n                    }\\n                }    \\n            }\\n            \\n        }\\n        result = *max_element(rest.begin(),rest.end());\\n        return result;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Topological Sort"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumTime(int n, vector<vector<int>>& relations, vector<int>& time) {\\n        queue<int> q;\\n        vector<vector<int>> adj(n+1);\\n        vector<int> rest(n+1,0);\\n        vector<int> indeg(n+1);\\n        for(int i = 0;i<relations.size();i++)\\n        {\\n            adj[relations[i][0]].push_back(relations[i][1]);\\n            indeg[relations[i][1]]++;\\n        }\\n        for(int i=1;i<=n;i++)\\n        {\\n            if(indeg[i] == 0)\\n            {\\n                q.push(i);\\n                rest[i] = time[i-1];\\n            }\\n        }\\n        int result = 0;\\n        while(q.empty() == 0)\\n        {\\n            int size = q.size();\\n            while(size--)\\n            {\\n                int u = q.front();\\n                q.pop();\\n             \\n                for(int v:adj[u])\\n                {\\n                    indeg[v]--;\\n                    rest[v] = max(rest[v],rest[u]+time[v-1]);\\n                    if(indeg[v] == 0)\\n                    {\\n                        q.push(v);\\n                    }\\n                }    \\n            }\\n            \\n        }\\n        result = *max_element(rest.begin(),rest.end());\\n        return result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2868545,
                "title": "topological-sort-easy-to-understand-c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int minimumTime(int n, vector<vector<int>>& relations, vector<int>& time) {\\n        vector<int> inDegree(n);\\n        vector<vector<int>> graph(n, vector<int>());\\n        for (auto& edge : relations) {\\n            int prev = edge[0] - 1, next = edge[1] - 1;\\n            graph[prev].push_back(next);\\n            inDegree[next]++;\\n        }\\n        \\n        vector<int> dist(n);\\n        queue<int> q;\\n        for (int u = 0; u < n; ++u) {\\n            if (inDegree[u] == 0) {\\n                q.push(u);\\n                dist[u] = time[u];\\n            }\\n        }\\n        while (!q.empty()) {\\n            int u = q.front(); q.pop();\\n            for (int v : graph[u]) {\\n                dist[v] = max(dist[v], dist[u] + time[v]);\\n                if (--inDegree[v] == 0) \\n                    q.push(v);\\n            }\\n        }\\n        return *max_element(dist.begin(), dist.end());\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming",
                    "Graph",
                    "Topological Sort"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumTime(int n, vector<vector<int>>& relations, vector<int>& time) {\\n        vector<int> inDegree(n);\\n        vector<vector<int>> graph(n, vector<int>());\\n        for (auto& edge : relations) {\\n            int prev = edge[0] - 1, next = edge[1] - 1;\\n            graph[prev].push_back(next);\\n            inDegree[next]++;\\n        }\\n        \\n        vector<int> dist(n);\\n        queue<int> q;\\n        for (int u = 0; u < n; ++u) {\\n            if (inDegree[u] == 0) {\\n                q.push(u);\\n                dist[u] = time[u];\\n            }\\n        }\\n        while (!q.empty()) {\\n            int u = q.front(); q.pop();\\n            for (int v : graph[u]) {\\n                dist[v] = max(dist[v], dist[u] + time[v]);\\n                if (--inDegree[v] == 0) \\n                    q.push(v);\\n            }\\n        }\\n        return *max_element(dist.begin(), dist.end());\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2695727,
                "title": "python-topological-sort-kahn-s-algorithm-bfs-max-path-sum-to-find-minimum-months",
                "content": "since courses can be taken concurrently, we really want the max path sum (b/c choosing the dependency course with the max time cost ensures you complete all the other dependencies at that level. also need topological sort to ensure the pre-req courses are always taken first.  track the max path sum with dist map. for topological sort, we need in_degree map (node: # of incoming edges) and start the queue off with all nodes with in_degree of 0. start off dist with values from time. pop node from queue, explore neighbors (update in_degree and dist, append nodes that now have 0 in_degree). return max of the dist values.  \\n\\ntime: O(V+E) since we have to visit every node (V) \\nspace: O(V+E) queue has every node(V) and graph map has every edge (E)\\n\\n```\\ndef minimumTime(self, n: int, relations: List[List[int]], time: List[int]) -> int:\\n        # n+1 due to input node starting at 1 instead of 0\\n        # initialize map where every node is indegree of 0.\\n\\t\\t\\t\\tin_degree=dict.fromkeys(range(1, n+1, 1), 0)\\n        #print(\"indegree initial\", in_degree)\\n        graph=defaultdict(list)\\n                \\n        for src, dest in relations:\\n            graph[src].append(dest)\\n            in_degree[dest] = in_degree.get(dest,0) + 1\\n        #print(graph)\\n        #print(\"in_degree\", in_degree)\\n        \\n        q = deque([k for k in range(1, n+1, 1) if in_degree[k] == 0])\\n        #print(\"q\", q)\\n        dist=dict.fromkeys(range(1, n, 1), 0)\\n        n = 1\\n        for cost in time:\\n            dist[n] = cost\\n            n += 1\\n        #print(\"dist\", dist)\\n\\n        while q:\\n            node = q.popleft()\\n            #print(node)\\n            for nei in graph[node]:\\n                # Update `dist[nei]` using the maximum dist \\n                # of the predecessor nodes\\n                # print(\"nei\", nei)\\n                # print(\"dist[nei]\", dist[nei])\\n                # print(\"time[nei]\", time[nei-1])\\n                dist[nei] = max(dist[nei], time[nei-1] + dist[node])\\n                # print(\"dist after update\", dist)\\n                in_degree[nei] -= 1\\n                if in_degree[nei] == 0:\\n                    q.append(nei)\\n        \\n        # LC guaranteed a DAG so we always have a topological sort\\n\\t\\t\\t  # so don\\'t need to validate for this problem.\\n        return max(dist.values())\\n```\\n\\nif you\\'re still confused about why max path sum, it\\'s max path only b/c you can do the courses concurrently and ensure you complete all the prereqs by traversing the pre-req at each level with the highest time cost. if we couldn\\'t take courses currently, we\\'d have to sum the duration of the dependent/pre-req courses.\\n\\nin the first example where 1 (3mo) and 2 (2 mo) are on the same level and both prereqs for 3 (5 month). we take the max path of 1 -> 3 (3+5 mo) b/c in the the first 3 months, we also accomplish 2 (which is also a pre-req for course 3).",
                "solutionTags": [
                    "Python",
                    "Breadth-First Search"
                ],
                "code": "```\\ndef minimumTime(self, n: int, relations: List[List[int]], time: List[int]) -> int:\\n        # n+1 due to input node starting at 1 instead of 0\\n        # initialize map where every node is indegree of 0.\\n\\t\\t\\t\\tin_degree=dict.fromkeys(range(1, n+1, 1), 0)\\n        #print(\"indegree initial\", in_degree)\\n        graph=defaultdict(list)\\n                \\n        for src, dest in relations:\\n            graph[src].append(dest)\\n            in_degree[dest] = in_degree.get(dest,0) + 1\\n        #print(graph)\\n        #print(\"in_degree\", in_degree)\\n        \\n        q = deque([k for k in range(1, n+1, 1) if in_degree[k] == 0])\\n        #print(\"q\", q)\\n        dist=dict.fromkeys(range(1, n, 1), 0)\\n        n = 1\\n        for cost in time:\\n            dist[n] = cost\\n            n += 1\\n        #print(\"dist\", dist)\\n\\n        while q:\\n            node = q.popleft()\\n            #print(node)\\n            for nei in graph[node]:\\n                # Update `dist[nei]` using the maximum dist \\n                # of the predecessor nodes\\n                # print(\"nei\", nei)\\n                # print(\"dist[nei]\", dist[nei])\\n                # print(\"time[nei]\", time[nei-1])\\n                dist[nei] = max(dist[nei], time[nei-1] + dist[node])\\n                # print(\"dist after update\", dist)\\n                in_degree[nei] -= 1\\n                if in_degree[nei] == 0:\\n                    q.append(nei)\\n        \\n        # LC guaranteed a DAG so we always have a topological sort\\n\\t\\t\\t  # so don\\'t need to validate for this problem.\\n        return max(dist.values())\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2345802,
                "title": "topological-sort",
                "content": "```\\nclass Solution {\\npublic:\\n    int minimumTime(int n, vector<vector<int>>& r, vector<int>& t) {\\n        vector<int>adj[n+1];\\n        vector<int>in(n+1);\\n        vector<long long int> maxTime(n+1,0);\\n        for(int i=0;i<r.size();i++){\\n            adj[r[i][0]].push_back(r[i][1]);\\n            in[r[i][1]]++;\\n        }\\n        queue<int>q;\\n        for(int i=1;i<=n;i++){\\n            if(in[i]==0){\\n                q.push(i);\\n               maxTime[i]=t[i-1];\\n            }\\n        }\\n        while(!q.empty()){\\n            int a=q.front();\\n            q.pop();\\n            \\n            for(int x:adj[a]){\\n            maxTime[x]=max(maxTime[x],maxTime[a]+t[x-1]);\\n                if(--in[x]==0){\\n                    q.push(x);\\n                }\\n            }\\n        }\\n        return *max_element(maxTime.begin(),maxTime.end());\\n    }\\n};\\n```",
                "solutionTags": [
                    "Queue"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumTime(int n, vector<vector<int>>& r, vector<int>& t) {\\n        vector<int>adj[n+1];\\n        vector<int>in(n+1);\\n        vector<long long int> maxTime(n+1,0);\\n        for(int i=0;i<r.size();i++){\\n            adj[r[i][0]].push_back(r[i][1]);\\n            in[r[i][1]]++;\\n        }\\n        queue<int>q;\\n        for(int i=1;i<=n;i++){\\n            if(in[i]==0){\\n                q.push(i);\\n               maxTime[i]=t[i-1];\\n            }\\n        }\\n        while(!q.empty()){\\n            int a=q.front();\\n            q.pop();\\n            \\n            for(int x:adj[a]){\\n            maxTime[x]=max(maxTime[x],maxTime[a]+t[x-1]);\\n                if(--in[x]==0){\\n                    q.push(x);\\n                }\\n            }\\n        }\\n        return *max_element(maxTime.begin(),maxTime.end());\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2264688,
                "title": "c-topoplogical-sort",
                "content": "I maintained 2 arrays : one for storing the starting time of a particular course (startTime) and one which maintains the highest time for a prerequiste course for a particular course (maxPrevFinish). Then I use topological sort and update the maxPrevFinish and when indegree becomes zero, I update the startTime array for the next course and push it into the queue. \\n\\nHere\\'s the code : \\nclass Solution {\\npublic:\\n    int minimumTime(int n, vector<vector<int>>& relations, vector<int>& time) {\\n        vector<vector<int>> adj(n+1);\\n        vector<int> indeg(n+1);\\n        for(auto r : relations){\\n            adj[r[0]].push_back(r[1]);\\n            indeg[r[1]]++;\\n        }\\n        vector<int> startTime(n+1,0);\\n        queue<int> q;\\n        for(int i=1;i<=n;i++){\\n            if(indeg[i]==0){\\n                q.push(i);\\n            }\\n        }\\n        vector<int> maxPrevFinish(n+1,0);\\n        int ans=0;\\n        \\n        while(!q.empty()){\\n            int sz = q.size();\\n            for(int i=0;i<sz;i++){\\n                int curr = q.front();\\n                q.pop();\\n                // ans=max(ans,startTime[curr]+time[curr-1]);\\n                \\n                if(adj[curr].empty()){\\n                    ans=max(ans,startTime[curr]+time[curr-1]);\\n                }\\n                \\n                for(auto neigh : adj[curr]){\\n                    indeg[neigh]--;\\n                    maxPrevFinish[neigh] = max(maxPrevFinish[neigh],startTime[curr]+time[curr-1]);\\n                    if(indeg[neigh]==0){\\n                        startTime[neigh] = maxPrevFinish[neigh];\\n                        q.push(neigh);\\n                    }\\n                }\\n                \\n            }\\n        }\\n        return ans;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    int minimumTime(int n, vector<vector<int>>& relations, vector<int>& time) {\\n        vector<vector<int>> adj(n+1);\\n        vector<int> indeg(n+1);\\n        for(auto r : relations){\\n            adj[r[0]].push_back(r[1]);\\n            indeg[r[1]]++;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2126291,
                "title": "topo-sort-concise",
                "content": "\\tclass Solution {\\n\\tpublic:\\n    int minimumTime(int n, vector<vector<int>>& relations, vector<int>& time) {\\n        \\n        vector<int>indeg(n);\\n        vector<int>adj[n];\\n        for(int i=0;i<relations.size();i++){\\n            adj[relations[i][0]-1].push_back(relations[i][1]-1);\\n            indeg[relations[i][1]-1]++;\\n        }\\n        queue<pair<int,int>>q;\\n        vector<int>realTime(n,0);\\n        for(int i=0;i<indeg.size();i++){\\n            if(indeg[i]==0){\\n                q.push({i,time[i]});\\n                realTime[i]=time[i];\\n            }\\n        }\\n        while(!q.empty()){\\n            pair<int,int>curr=q.front();\\n            q.pop();\\n            for(int i=0;i<adj[curr.first].size();i++){\\n                indeg[adj[curr.first][i]]--;\\n                realTime[adj[curr.first][i]]=max(realTime[adj[curr.first][i]],curr.second+time[adj[curr.first][i]]);\\n                if(indeg[adj[curr.first][i]]==0){\\n                    q.push({adj[curr.first][i],realTime[adj[curr.first][i]]});\\n                }\\n            }\\n        }\\n        int res=0;\\n        for(int i=0;i<realTime.size();i++)\\n            res=max(realTime[i],res);\\n        return res;\\n    }\\n};",
                "solutionTags": [
                    "Topological Sort"
                ],
                "code": "class Solution {\\n\\tpublic:\\n    int minimumTime(int n, vector<vector<int>>& relations, vector<int>& time) {\\n        \\n        vector<int>indeg(n);\\n        vector<int>adj[n];\\n        for(int i=0;i<relations.size();i++){\\n            adj[relations[i][0]-1].push_back(relations[i][1]-1);\\n            indeg[relations[i][1]-1]++;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1728998,
                "title": "question-to-the-problem-need-help",
                "content": "**Given a testcase to this problem:**\\n    N =  9\\n    relations = [[2,7],[2,6],[3,6],[4,6],[7,6],[2,1],[3,1],[4,1],[6,1],[7,1],[3,8],[5,8],[7,8],[1,9],[2,9],[6,9],[7,9]]\\n    time = [9,5,9,5,8,7,7,8,4]\\n\\tMy solution output is:* 37 *\\n\\t*Expected is 32*\\n\\t**I get the output 37 by :**\\n     Taking this Courses => Max Month\\n \\t (2, 3, 4, 5) => 9\\n\\t (7) => 7\\n\\t (8, 6) => 8\\n\\t (1) => 9\\n\\t (9) => 4\\n\\t \\n\\t I need help because I cannot find how the output should be 32 instead. Thank you :).\\n\\t\\n\\t`#Here is also my solution\\n\\tclass Node:\\n    def __init__(self, id, months):\\n        self.id = id\\n        self.months = months\\n        self.nextNeighbors = []\\n        self.preqNum = 0\\n    \\n    def add_neighbor(self, neighbor):\\n        self.nextNeighbors.append(neighbor)\\n        neighbor.add_preq()\\n\\n    def add_preq(self):\\n        self.preqNum += 1\\n\\n    def sub_preq(self):\\n        self.preqNum -= 1\\n\\n    def isValid(self):\\n        return self.preqNum == 0\\n\\n    def getNeighborsNode(self):\\n        validNeighbors = set()\\n        for neighbor in self.nextNeighbors:\\n            neighbor.sub_preq()\\n            if(neighbor.isValid()):\\n                validNeighbors.add(neighbor.id)\\n\\treturn validNeighbors\\nClass Solution:\\n\\n    def minimumTime(self, n: int, relations: list, time: list) -> int:\\n        # make all Node objects\\n        lstNodes = [None]\\n        currNodes = set()\\n        for i in range(1, n+1):\\n            node = Node(i,time[i-1])\\n            lstNodes.append(node)\\n            currNodes.add(i)\\n        \\n        # make all relation to the nodes and get all unique starting node\\n        for prevC, nextC in relations:\\n            lstNodes[prevC].add_neighbor(lstNodes[nextC])\\n            if(nextC in currNodes):\\n                currNodes.remove(nextC)\\n        # count by level of nodes and add all months\\n        monthsTaken = 0\\n        while True:\\n            print(currNodes,end=\\'\\')\\n            advanceNodes = set()\\n            maxMonth = 0\\n            for nodeID in currNodes:\\n                nodeObj = lstNodes[nodeID]\\n                maxMonth = max(maxMonth, nodeObj.months)\\n                advanceNodes.update(nodeObj.getNeighborsNode())\\n            print(maxMonth)\\n            monthsTaken += maxMonth\\n            currNodes = advanceNodes\\n            if(len(currNodes)==0):\\n                break\\n\\n        return monthsTaken`\\n\\n",
                "solutionTags": [],
                "code": "**Given a testcase to this problem:**\\n    N =  9\\n    relations = [[2,7],[2,6],[3,6],[4,6],[7,6],[2,1],[3,1],[4,1],[6,1],[7,1],[3,8],[5,8],[7,8],[1,9],[2,9],[6,9],[7,9]]\\n    time = [9,5,9,5,8,7,7,8,4]\\n\\tMy solution output is:* 37 *\\n\\t*Expected is 32*\\n\\t**I get the output 37 by :**\\n     Taking this Courses => Max Month\\n \\t (2, 3, 4, 5) => 9\\n\\t (7) => 7\\n\\t (8, 6) => 8\\n\\t (1) => 9\\n\\t (9) => 4\\n\\t \\n\\t I need help because I cannot find how the output should be 32 instead. Thank you :).\\n\\t\\n\\t`#Here is also my solution\\n\\tclass Node:\\n    def __init__(self, id, months):\\n        self.id = id\\n        self.months = months\\n        self.nextNeighbors = []\\n        self.preqNum = 0\\n    \\n    def add_neighbor(self, neighbor):\\n        self.nextNeighbors.append(neighbor)\\n        neighbor.add_preq()\\n\\n    def add_preq(self):\\n        self.preqNum += 1\\n\\n    def sub_preq(self):\\n        self.preqNum -= 1\\n\\n    def isValid(self):\\n        return self.preqNum == 0\\n\\n    def getNeighborsNode(self):\\n        validNeighbors = set()\\n        for neighbor in self.nextNeighbors:\\n            neighbor.sub_preq()\\n            if(neighbor.isValid()):\\n                validNeighbors.add(neighbor.id)\\n\\treturn validNeighbors\\nClass Solution:\\n\\n    def minimumTime(self, n: int, relations: list, time: list) -> int:\\n        # make all Node objects\\n        lstNodes = [None]\\n        currNodes = set()\\n        for i in range(1, n+1):\\n            node = Node(i,time[i-1])\\n            lstNodes.append(node)\\n            currNodes.add(i)\\n        \\n        # make all relation to the nodes and get all unique starting node\\n        for prevC, nextC in relations:\\n            lstNodes[prevC].add_neighbor(lstNodes[nextC])\\n            if(nextC in currNodes):\\n                currNodes.remove(nextC)\\n        # count by level of nodes and add all months\\n        monthsTaken = 0\\n        while True:\\n            print(currNodes,end=\\'\\')\\n            advanceNodes = set()\\n            maxMonth = 0\\n            for nodeID in currNodes:\\n                nodeObj = lstNodes[nodeID]\\n                maxMonth = max(maxMonth, nodeObj.months)\\n                advanceNodes.update(nodeObj.getNeighborsNode())\\n            print(maxMonth)\\n            monthsTaken += maxMonth\\n            currNodes = advanceNodes\\n            if(len(currNodes)==0):\\n                break\\n\\n        return monthsTaken`\\n\\n",
                "codeTag": "Java"
            },
            {
                "id": 1542937,
                "title": "c-priority-queue-o-nlogn",
                "content": "```\\nclass Solution {\\npublic:\\n    int minimumTime(int n, vector<vector<int>>& rel, vector<int>& times) {\\n        vector<int> in(n + 1);\\n\\t\\tvector<vector<int>> out(n + 1);\\n\\t\\tfor(const auto& r : rel){\\n\\t\\t\\tin[r[1]]++;\\n\\t\\t\\tout[r[0]].push_back(r[1]);\\n\\t\\t}\\n\\t\\t\\n\\t\\tusing mp = pair<int, int>;\\n\\t\\tpriority_queue<mp, vector<mp>, greater<mp>> pq;\\n\\t\\tfor(int i = 1; i <= n; i++)\\n\\t\\t\\tif(!in[i]) pq.emplace(times[i - 1], i);\\n\\t\\t\\n\\t\\tint res = 0;\\n\\t\\twhile(!pq.empty()){\\n\\t\\t\\tauto [t, c] = pq.top();\\n\\t\\t\\tpq.pop();\\n\\t\\t\\tres = t;\\n\\t\\t\\tfor(auto i : out[c]){\\n\\t\\t\\t\\tin[i]--;\\n\\t\\t\\t\\tif(!in[i]) pq.emplace(times[i - 1] + t, i);\\n\\t\\t\\t}\\n\\t\\t\\t\\n\\t\\t}\\n\\t\\treturn res;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumTime(int n, vector<vector<int>>& rel, vector<int>& times) {\\n        vector<int> in(n + 1);\\n\\t\\tvector<vector<int>> out(n + 1);\\n\\t\\tfor(const auto& r : rel){\\n\\t\\t\\tin[r[1]]++;\\n\\t\\t\\tout[r[0]].push_back(r[1]);\\n\\t\\t}\\n\\t\\t\\n\\t\\tusing mp = pair<int, int>;\\n\\t\\tpriority_queue<mp, vector<mp>, greater<mp>> pq;\\n\\t\\tfor(int i = 1; i <= n; i++)\\n\\t\\t\\tif(!in[i]) pq.emplace(times[i - 1], i);\\n\\t\\t\\n\\t\\tint res = 0;\\n\\t\\twhile(!pq.empty()){\\n\\t\\t\\tauto [t, c] = pq.top();\\n\\t\\t\\tpq.pop();\\n\\t\\t\\tres = t;\\n\\t\\t\\tfor(auto i : out[c]){\\n\\t\\t\\t\\tin[i]--;\\n\\t\\t\\t\\tif(!in[i]) pq.emplace(times[i - 1] + t, i);\\n\\t\\t\\t}\\n\\t\\t\\t\\n\\t\\t}\\n\\t\\treturn res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1538786,
                "title": "java-bfs-topological-sort-clear-code-beats-100",
                "content": "BFS topological sort keeping track of elapsed time. Elapsed time is the sum of the time spent upstream and the time spent for this course.\\n\\nThe upstream time is the time spent along the path that sets indegree of this node to 0.\\n```\\n    public int minimumTime(int n, int[][] relations, int[] time) {\\n        int[] indeg = new int[n], elapsed = new int[n];\\n        List<Integer>[] adj = new List[n];\\n        Arrays.setAll(adj, x -> new ArrayList<>());\\n        for (int[] r : relations) {\\n            adj[r[0]- 1].add(r[1] - 1);\\n            indeg[r[1]- 1]++;\\n        }\\n        Queue<Integer> q = new ArrayDeque<>();\\n        for (int i = 0; i < n; ++i)\\n            if (indeg[i] == 0) {\\n                q.offer(i);\\n                elapsed[i] += time[i];\\n            }\\n        int res = 0;\\n        while (!q.isEmpty()) {\\n            int f = q.poll();\\n            res = Math.max(res, elapsed[f]);\\n            for (Integer ch : adj[f]) {\\n                elapsed[ch] = Math.max(elapsed[ch], elapsed[f]);\\n                if (--indeg[ch] == 0) {\\n                    elapsed[ch] += time[ch];\\n                    q.offer(ch);\\n                }\\n            }\\n        }\\n        return res;\\n    }",
                "solutionTags": [
                    "Java",
                    "Topological Sort"
                ],
                "code": "BFS topological sort keeping track of elapsed time. Elapsed time is the sum of the time spent upstream and the time spent for this course.\\n\\nThe upstream time is the time spent along the path that sets indegree of this node to 0.\\n```\\n    public int minimumTime(int n, int[][] relations, int[] time) {\\n        int[] indeg = new int[n], elapsed = new int[n];\\n        List<Integer>[] adj = new List[n];\\n        Arrays.setAll(adj, x -> new ArrayList<>());\\n        for (int[] r : relations) {\\n            adj[r[0]- 1].add(r[1] - 1);\\n            indeg[r[1]- 1]++;\\n        }\\n        Queue<Integer> q = new ArrayDeque<>();\\n        for (int i = 0; i < n; ++i)\\n            if (indeg[i] == 0) {\\n                q.offer(i);\\n                elapsed[i] += time[i];\\n            }\\n        int res = 0;\\n        while (!q.isEmpty()) {\\n            int f = q.poll();\\n            res = Math.max(res, elapsed[f]);\\n            for (Integer ch : adj[f]) {\\n                elapsed[ch] = Math.max(elapsed[ch], elapsed[f]);\\n                if (--indeg[ch] == 0) {\\n                    elapsed[ch] += time[ch];\\n                    q.offer(ch);\\n                }\\n            }\\n        }\\n        return res;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1537536,
                "title": "c-topological-sort",
                "content": "\\n#### Idea to solve\\n- Consider all courses that have 0 courses as requirements.\\n- For each such course check how much time it takes to complete the connected course based on time taken to complete current course.  ```dist[v]=max(dist[u]+time[v-1])```\\n- Remove this course from dependancies of the connected node.\\n\\n- Initialy connect all node with node 0 which takes 0 months to complete and now dist array will have total time to complete a course.\\n- Return the maximum.\\n\\n#### C++ code\\n```cpp\\nclass Solution {\\npublic:\\n    int minimumTime(int n, vector<vector<int>>& relations, vector<int>& time) {\\n        vector<int> graph[n+1];\\n        set <int> rev[n+1];// reverse graph , containing dependancies\\n        \\n        // add edges\\n        for(auto t:relations) {\\n        \\tgraph[t[0]].push_back(t[1]);\\n        \\trev[t[1]].insert(t[0]); \\n        }\\n        \\n        //connect them to 0 \\n        for(int i=1;i<=n;++i) {\\n        \\tgraph[0].push_back(i);\\n        \\trev[i].insert(0);\\n        }\\n        \\n        queue<int> q;\\n       \\t// dist[i] -  time to complete course i\\n        vector<int> dist(n+1,0);\\n        \\n        dist[0]=0;\\n        q.push(0);\\n        // BFS Variant\\n        while(!q.empty()){\\n            int u=q.front();q.pop();\\n            for(auto v:graph[u]){\\n            \\t// time to complete next course  = time to complete current one  + time to complete next one.\\n                dist[v]=max(dist[v],dist[u]+time[v-1]);\\n                // remove that edge\\n                rev[v].erase(u);\\n                // if it becomes 0 dependent add to queue\\n                if(rev[v].size()==0) q.push(v);\\n            }\\n        }\\n        \\n        // the maximum among all distances is the answer.\\n        return *max_element(dist.begin(),dist.end());\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Topological Sort"
                ],
                "code": "```dist[v]=max(dist[u]+time[v-1])```\n```cpp\\nclass Solution {\\npublic:\\n    int minimumTime(int n, vector<vector<int>>& relations, vector<int>& time) {\\n        vector<int> graph[n+1];\\n        set <int> rev[n+1];// reverse graph , containing dependancies\\n        \\n        // add edges\\n        for(auto t:relations) {\\n        \\tgraph[t[0]].push_back(t[1]);\\n        \\trev[t[1]].insert(t[0]); \\n        }\\n        \\n        //connect them to 0 \\n        for(int i=1;i<=n;++i) {\\n        \\tgraph[0].push_back(i);\\n        \\trev[i].insert(0);\\n        }\\n        \\n        queue<int> q;\\n       \\t// dist[i] -  time to complete course i\\n        vector<int> dist(n+1,0);\\n        \\n        dist[0]=0;\\n        q.push(0);\\n        // BFS Variant\\n        while(!q.empty()){\\n            int u=q.front();q.pop();\\n            for(auto v:graph[u]){\\n            \\t// time to complete next course  = time to complete current one  + time to complete next one.\\n                dist[v]=max(dist[v],dist[u]+time[v-1]);\\n                // remove that edge\\n                rev[v].erase(u);\\n                // if it becomes 0 dependent add to queue\\n                if(rev[v].size()==0) q.push(v);\\n            }\\n        }\\n        \\n        // the maximum among all distances is the answer.\\n        return *max_element(dist.begin(),dist.end());\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1537469,
                "title": "c-dp-solution-dfs-memo",
                "content": "\\ndp[i] represent max time to finish if start from i-th course.\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int> > adj;\\n    vector<int> t;\\n    vector<int> dp;\\n    int dfs(int node) {\\n        if(dp[node]) return dp[node];\\n        int mx = 0;\\n        for(int next : adj[node]) {\\n            mx = max(mx, dfs(next));\\n        }\\n        return dp[node] = t[node] + mx;\\n    }\\n    int minimumTime(int n, vector<vector<int>>& relations, vector<int>& time) {\\n        adj.resize(n);\\n        dp.resize(n);\\n        t = time;\\n        for(auto &r : relations) {\\n            adj[r[0] - 1].push_back(r[1] - 1);\\n        }\\n        int ans = 0;\\n        for(int i = 0; i < n; i++)\\n            ans = max(dfs(i), ans);\\n        return ans;\\n    }\\n};\\n```\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int> > adj;\\n    vector<int> t;\\n    vector<int> dp;\\n    int dfs(int node) {\\n        if(dp[node]) return dp[node];\\n        int mx = 0;\\n        for(int next : adj[node]) {\\n            mx = max(mx, dfs(next));\\n        }\\n        return dp[node] = t[node] + mx;\\n    }\\n    int minimumTime(int n, vector<vector<int>>& relations, vector<int>& time) {\\n        adj.resize(n);\\n        dp.resize(n);\\n        t = time;\\n        for(auto &r : relations) {\\n            adj[r[0] - 1].push_back(r[1] - 1);\\n        }\\n        int ans = 0;\\n        for(int i = 0; i < n; i++)\\n            ans = max(dfs(i), ans);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3443874,
                "title": "java-dp-memoization-beats-95",
                "content": "```java []\\nclass Solution {\\n    public int minimumTime(int n, int[][] relations, int[] time) {\\n        ArrayList<Integer>[] a = new ArrayList[n+1];\\n        for(int i=0;i<=n;i++){\\n            a[i] = new ArrayList<>();\\n        }\\n        for(int[] x:relations){\\n            a[x[0]].add(x[1]);\\n        }\\n\\n        Integer[] memo = new Integer[n+1];\\n        int ans=0;\\n        for(int i=1;i<=n;i++){\\n            ans=Math.max(dfs(i,memo,a,time),ans);\\n        }\\n        return ans;\\n    }\\n \\n\\n    private int dfs(int curr, Integer[] memo,ArrayList<Integer>[] adj,int[] time){\\n        if(memo[curr]!=null){\\n            return memo[curr];\\n        }\\n        int max=0;\\n        for(int x:adj[curr]){\\n            max = Math.max(max,dfs(x,memo,adj,time));\\n        }\\n        return memo[curr] = max + time[curr-1];\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "```java []\\nclass Solution {\\n    public int minimumTime(int n, int[][] relations, int[] time) {\\n        ArrayList<Integer>[] a = new ArrayList[n+1];\\n        for(int i=0;i<=n;i++){\\n            a[i] = new ArrayList<>();\\n        }\\n        for(int[] x:relations){\\n            a[x[0]].add(x[1]);\\n        }\\n\\n        Integer[] memo = new Integer[n+1];\\n        int ans=0;\\n        for(int i=1;i<=n;i++){\\n            ans=Math.max(dfs(i,memo,a,time),ans);\\n        }\\n        return ans;\\n    }\\n \\n\\n    private int dfs(int curr, Integer[] memo,ArrayList<Integer>[] adj,int[] time){\\n        if(memo[curr]!=null){\\n            return memo[curr];\\n        }\\n        int max=0;\\n        for(int x:adj[curr]){\\n            max = Math.max(max,dfs(x,memo,adj,time));\\n        }\\n        return memo[curr] = max + time[curr-1];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3013310,
                "title": "javascript-100-faster-than-other-solutions",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nthe Intution is simple. We will make an hash where we keep indegree nodes for each node. \\nAlso we will have an array maxTime which will calculate the max time each course takes.\\n\\nNow we\\'ve a function called calculateAbsMax which will calculate absolute max time it take to complete this tasks. \\n\\n# Approach\\napproach is easy. We just loop over all the nodes from 1-n and calculate each absolute max time by looping over all it\\'s indegree nodes and then recursilvely calculating their abs max time. \\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {number} n\\n * @param {number[][]} relations\\n * @param {number[]} time\\n * @return {number}\\n */\\nvar minimumTime = function(n, relations, time) {\\n    const maxTime = new Array(n+1).fill(-1);\\n\\n    const indegree = {};\\n\\n    for(let edge of relations){\\n        let [a,b] = edge;\\n        if(indegree[b]){\\n            indegree[b].push(a);\\n        }\\n        else {\\n            indegree[b] = [a];\\n        }\\n    }\\n\\n    function calculateAbsMax(node){\\n        if(maxTime[node] > -1) return maxTime[node];\\n        let tym = 0;\\n        if(indegree[node] == undefined) tym = time[node-1];\\n        else{\\n            for(let elm of indegree[node]){\\n                tym = Math.max(tym,calculateAbsMax(elm));\\n            }\\n            tym += time[node-1];\\n        }\\n        maxTime[node] = tym;\\n        return tym;\\n    }\\n    let ans = 0;\\n    for(let i = 1; i <=n; i++){\\n        ans = Math.max(ans,calculateAbsMax(i));\\n    }\\n\\n    return ans;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number} n\\n * @param {number[][]} relations\\n * @param {number[]} time\\n * @return {number}\\n */\\nvar minimumTime = function(n, relations, time) {\\n    const maxTime = new Array(n+1).fill(-1);\\n\\n    const indegree = {};\\n\\n    for(let edge of relations){\\n        let [a,b] = edge;\\n        if(indegree[b]){\\n            indegree[b].push(a);\\n        }\\n        else {\\n            indegree[b] = [a];\\n        }\\n    }\\n\\n    function calculateAbsMax(node){\\n        if(maxTime[node] > -1) return maxTime[node];\\n        let tym = 0;\\n        if(indegree[node] == undefined) tym = time[node-1];\\n        else{\\n            for(let elm of indegree[node]){\\n                tym = Math.max(tym,calculateAbsMax(elm));\\n            }\\n            tym += time[node-1];\\n        }\\n        maxTime[node] = tym;\\n        return tym;\\n    }\\n    let ans = 0;\\n    for(let i = 1; i <=n; i++){\\n        ans = Math.max(ans,calculateAbsMax(i));\\n    }\\n\\n    return ans;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2969103,
                "title": "python-solution-topological-sort",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def minimumTime(self, n: int, relations: List[List[int]], time: List[int]) -> int:\\n        time_taken = {}\\n        incoming = [0] * n\\n        graph = {i:[] for i in range(n)}\\n        for i in range(len(relations)):\\n            pre,cour = relations[i]\\n            graph[pre-1].append(cour-1)\\n            incoming[cour-1] += 1\\n\\n        que = deque([])\\n        tot_time = [0] * n\\n\\n        for node in range(n):\\n            if incoming[node] == 0:\\n                que.append(node)\\n                tot_time[node] = time[node]\\n        while que:\\n            node = que.popleft()\\n            for neigh in graph[node]:\\n                tot_time[neigh] = max(tot_time[node] + time[neigh], tot_time[neigh])\\n                incoming[neigh] -= 1\\n                if incoming[neigh] == 0:\\n                    que.append(neigh)\\n        return max(tot_time)    \\n\\n\\n```",
                "solutionTags": [
                    "Python3",
                    "Topological Sort"
                ],
                "code": "```\\nclass Solution:\\n    def minimumTime(self, n: int, relations: List[List[int]], time: List[int]) -> int:\\n        time_taken = {}\\n        incoming = [0] * n\\n        graph = {i:[] for i in range(n)}\\n        for i in range(len(relations)):\\n            pre,cour = relations[i]\\n            graph[pre-1].append(cour-1)\\n            incoming[cour-1] += 1\\n\\n        que = deque([])\\n        tot_time = [0] * n\\n\\n        for node in range(n):\\n            if incoming[node] == 0:\\n                que.append(node)\\n                tot_time[node] = time[node]\\n        while que:\\n            node = que.popleft()\\n            for neigh in graph[node]:\\n                tot_time[neigh] = max(tot_time[node] + time[neigh], tot_time[neigh])\\n                incoming[neigh] -= 1\\n                if incoming[neigh] == 0:\\n                    que.append(neigh)\\n        return max(tot_time)    \\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2951595,
                "title": "javascript-bfs",
                "content": "```\\n/**\\n * @param {number} n\\n * @param {number[][]} relations\\n * @param {number[]} time\\n * @return {number}\\n */\\nvar minimumTime = function (n, relations, time) {\\n  const deps = new Array(n + 1).fill(0);\\n  const graphs = new Array(n + 1).fill().map((_) => []);\\n  const maxTime = new Array(n + 1).fill(0);\\n\\n  for (const [parent, child] of relations) {\\n    graphs[parent].push(child);\\n    deps[child]++;\\n  }\\n\\n  const queue = [];\\n  for (let node = 1; node <= n; node++) {\\n    if (deps[node] === 0) {\\n      queue.push([node, time[node - 1]]);\\n    }\\n  }\\n\\n  let ans = 0;\\n  while (queue.length > 0) {\\n    const [node, currTime] = queue.shift();\\n    ans = Math.max(ans, currTime);\\n\\n    for (const child of graphs[node]) {\\n      deps[child]--;\\n      maxTime[child] = Math.max(maxTime[child], currTime + time[child - 1]);\\n      if (deps[child] === 0) {\\n        queue.push([child, maxTime[child]]);\\n      }\\n    }\\n  }\\n\\n  return ans;\\n};\\n\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Breadth-First Search"
                ],
                "code": "```\\n/**\\n * @param {number} n\\n * @param {number[][]} relations\\n * @param {number[]} time\\n * @return {number}\\n */\\nvar minimumTime = function (n, relations, time) {\\n  const deps = new Array(n + 1).fill(0);\\n  const graphs = new Array(n + 1).fill().map((_) => []);\\n  const maxTime = new Array(n + 1).fill(0);\\n\\n  for (const [parent, child] of relations) {\\n    graphs[parent].push(child);\\n    deps[child]++;\\n  }\\n\\n  const queue = [];\\n  for (let node = 1; node <= n; node++) {\\n    if (deps[node] === 0) {\\n      queue.push([node, time[node - 1]]);\\n    }\\n  }\\n\\n  let ans = 0;\\n  while (queue.length > 0) {\\n    const [node, currTime] = queue.shift();\\n    ans = Math.max(ans, currTime);\\n\\n    for (const child of graphs[node]) {\\n      deps[child]--;\\n      maxTime[child] = Math.max(maxTime[child], currTime + time[child - 1]);\\n      if (deps[child] === 0) {\\n        queue.push([child, maxTime[child]]);\\n      }\\n    }\\n  }\\n\\n  return ans;\\n};\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2714102,
                "title": "python-easy-topological-sort-solution-bfs-approach-with-heap",
                "content": "```\\n\\nclass Solution:\\n    def minimumTime(self, n: int, relations: List[List[int]], time: List[int]) -> int:\\n        graph = defaultdict(list)\\n        indegree = [0] * (n + 1)\\n        for pre , nxt in relations:\\n            graph[pre].append(nxt)\\n            indegree[nxt] += 1\\n        \\n        heap = []\\n        for i in range(1,n + 1):\\n            if not indegree[i]:\\n                heappush(heap,(time[i - 1],i))\\n        \\n        offset = 0 \\n        while heap:\\n            month, course = heappop(heap)\\n            offset = month\\n            for neighbour in graph[course]:\\n                indegree[neighbour] -= 1\\n                if indegree[neighbour] == 0:\\n                    heappush(heap,(time[neighbour - 1] + offset, neighbour))\\n        return offset\\n\\n```",
                "solutionTags": [
                    "Topological Sort",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\n\\nclass Solution:\\n    def minimumTime(self, n: int, relations: List[List[int]], time: List[int]) -> int:\\n        graph = defaultdict(list)\\n        indegree = [0] * (n + 1)\\n        for pre , nxt in relations:\\n            graph[pre].append(nxt)\\n            indegree[nxt] += 1\\n        \\n        heap = []\\n        for i in range(1,n + 1):\\n            if not indegree[i]:\\n                heappush(heap,(time[i - 1],i))\\n        \\n        offset = 0 \\n        while heap:\\n            month, course = heappop(heap)\\n            offset = month\\n            for neighbour in graph[course]:\\n                indegree[neighbour] -= 1\\n                if indegree[neighbour] == 0:\\n                    heappush(heap,(time[neighbour - 1] + offset, neighbour))\\n        return offset\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2704195,
                "title": "python-topological-sort-dp-very-easy-to-read-beat-80",
                "content": "\\n\\tclass Solution:\\n\\t\\tdef minimumTime(self, n: int, relations: List[List[int]], time: List[int]) -> int:\\n\\t\\t\\tgraph, next_info = self.build_graph(n, relations)\\n\\t\\t\\tall_time = self.tp_sort(n, graph, time, next_info)\\n\\t\\t\\treturn all_time\\n\\n\\t\\tdef build_graph(self, n, relations):\\n\\t\\t\\tgraph = {\\n\\t\\t\\t\\ti: {\\'need\\': set([]), \\'meet\\': set([])}\\n\\t\\t\\t\\tfor i in range(1, n + 1)\\n\\t\\t\\t}\\n\\n\\t\\t\\tnext_info = {\\n\\t\\t\\t\\ti: set([])\\n\\t\\t\\t\\tfor i in range(1, n + 1)\\n\\t\\t\\t}\\n\\n\\t\\t\\tfor r in relations:\\n\\t\\t\\t\\tgraph[r[1]][\\'need\\'].add(r[0])\\n\\t\\t\\t\\tnext_info[r[0]].add(r[1])\\n\\n\\t\\t\\treturn graph, next_info\\n\\n\\t\\tdef tp_sort(self, n, graph, time, next_info):\\n\\t\\t\\tdp = [0] * (n + 1)\\n\\n\\t\\t\\tqueue = [key for key in graph if not graph[key][\\'need\\']]\\n\\t\\t\\twhile queue:\\n\\t\\t\\t\\tc = queue.pop(0)\\n\\t\\t\\t\\tfor meet_c in graph[c][\\'meet\\']:\\n\\t\\t\\t\\t\\tdp[c] = max(dp[c], dp[meet_c])\\n\\t\\t\\t\\tdp[c] += time[c - 1]\\n\\n\\t\\t\\t\\tfor next_c in next_info[c]:\\n\\t\\t\\t\\t\\tgraph[next_c][\\'need\\'].remove(c)\\n\\t\\t\\t\\t\\tgraph[next_c][\\'meet\\'].add(c)\\n\\t\\t\\t\\t\\tif not graph[next_c][\\'need\\']:\\n\\t\\t\\t\\t\\t\\tqueue.append(next_c)\\n\\t\\t\\treturn max(dp)",
                "solutionTags": [
                    "Python",
                    "Topological Sort"
                ],
                "code": "class Solution:\\n\\t\\tdef minimumTime(self, n: int, relations: List[List[int]], time: List[int]) -> int:\\n\\t\\t\\tgraph, next_info = self.build_graph(n, relations)\\n\\t\\t\\tall_time = self.tp_sort(n, graph, time, next_info)\\n\\t\\t\\treturn all_time\\n\\n\\t\\tdef build_graph(self, n, relations):\\n\\t\\t\\tgraph = {\\n\\t\\t\\t\\ti: {\\'need\\': set([]), \\'meet\\': set([])}",
                "codeTag": "Java"
            },
            {
                "id": 2603819,
                "title": "python-topological-sort-bfs",
                "content": "```\\nclass Solution:\\n    def minimumTime(self, n: int, relations: List[List[int]], time: List[int]) -> int:\\n        # key is the course, and value is a list of all the prerequiste courses for this current course \\n        indegree = defaultdict(list)\\n        # key is the course, and the value is other courses that needs the key as prerequiste \\n        outdegree = defaultdict(list)\\n        # tracks the min time needed to finish the current course (time[course] + time[prerequisite]) \\n        accumulative_time = defaultdict(int)\\n        \\n        # build the indegree and outdegree dicts \\n        for u, v in relations: \\n            indegree[v].append(u)\\n            outdegree[u].append(v)\\n  \\n        queue = []\\n        # add all the courses that do not need any prerequisite to the queue \\n        for i in range(1, n+1):\\n            if i not in indegree:\\n                queue.append(i)  \\n\\n        while queue:\\n            node = queue.pop(0)\\n            #  add prerequisite time to the current course \\n            accumulative_time[node] += time[node-1]\\n            # process the neighbor \\n            for neighbor in outdegree[node]:\\n                accumulative_time[neighbor] = max(accumulative_time[neighbor], accumulative_time[node])\\n                # remove the node after it\\'sprocessed \\n                indegree[neighbor].remove(node)\\n                # process the neighbor if it doesn\\'t have any prerequisite\\n                if indegree[neighbor] == []:\\n                    queue.append(neighbor) \\n                   \\n        all_values = accumulative_time.values()\\n        # the returned value is the max in all the values in the time dict \\n        total = max(all_values)\\n        return total \\n```",
                "solutionTags": [
                    "Python",
                    "Breadth-First Search",
                    "Topological Sort"
                ],
                "code": "```\\nclass Solution:\\n    def minimumTime(self, n: int, relations: List[List[int]], time: List[int]) -> int:\\n        # key is the course, and value is a list of all the prerequiste courses for this current course \\n        indegree = defaultdict(list)\\n        # key is the course, and the value is other courses that needs the key as prerequiste \\n        outdegree = defaultdict(list)\\n        # tracks the min time needed to finish the current course (time[course] + time[prerequisite]) \\n        accumulative_time = defaultdict(int)\\n        \\n        # build the indegree and outdegree dicts \\n        for u, v in relations: \\n            indegree[v].append(u)\\n            outdegree[u].append(v)\\n  \\n        queue = []\\n        # add all the courses that do not need any prerequisite to the queue \\n        for i in range(1, n+1):\\n            if i not in indegree:\\n                queue.append(i)  \\n\\n        while queue:\\n            node = queue.pop(0)\\n            #  add prerequisite time to the current course \\n            accumulative_time[node] += time[node-1]\\n            # process the neighbor \\n            for neighbor in outdegree[node]:\\n                accumulative_time[neighbor] = max(accumulative_time[neighbor], accumulative_time[node])\\n                # remove the node after it\\'sprocessed \\n                indegree[neighbor].remove(node)\\n                # process the neighbor if it doesn\\'t have any prerequisite\\n                if indegree[neighbor] == []:\\n                    queue.append(neighbor) \\n                   \\n        all_values = accumulative_time.values()\\n        # the returned value is the max in all the values in the time dict \\n        total = max(all_values)\\n        return total \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2559276,
                "title": "dp-without-dp-using-maps-and-graph",
                "content": "```\\n int tom(vector<vector<int>>& v,vector<int>& time,int time1,int i,unordered_map<int,int>& mp){\\n             \\n        int j;\\n        int c=0;\\n    \\n        for(j=0;j<v[i].size();j++){\\n       \\n            if(mp.find(v[i][j])==mp.end()){\\n          \\n               c=max(c,tom(v,time,time1,v[i][j],mp));\\n               \\n            }\\n            else if(mp.find(v[i][j])!=mp.end()){\\n                c=max(c,mp[v[i][j]]);\\n            }\\n                        \\n        }\\n        \\n       \\n        time1=c+time[i];\\n     mp[i]=time1;\\n       \\n          if(mp.size()==v.size()){\\n             \\n            return time1;\\n        }\\n        \\n        \\n        return time1;\\n                \\n    }\\n    int minimumTime(int n, vector<vector<int>>& relations, vector<int>& time) {\\n        \\n        int i;\\n          vector<vector<int>> v(n);\\n        for(i=0;i<relations.size();i++){\\n            v[relations[i][1]-1].push_back(relations[i][0]-1);\\n        }\\n        \\n        int time1=0,ans=INT_MIN;\\n        unordered_map<int,int> mp;\\n        for(i=0;i<n;i++){\\n            \\n            if(mp.find(i)==mp.end()){\\n             \\n                time1=0;\\n                       int c= tom(v,time,time1,i,mp);\\n                if(mp.size()==n){\\n                   break;\\n                }\\n            }\\n            \\n                        \\n        }\\n        for(auto it=mp.begin();it!=mp.end();it++){\\n            ans=max(ans,it->second);\\n        }\\n        \\n        return ans;\\n                 \\n    }\\n```",
                "solutionTags": [
                    "Topological Sort"
                ],
                "code": "```\\n int tom(vector<vector<int>>& v,vector<int>& time,int time1,int i,unordered_map<int,int>& mp){\\n             \\n        int j;\\n        int c=0;\\n    \\n        for(j=0;j<v[i].size();j++){\\n       \\n            if(mp.find(v[i][j])==mp.end()){\\n          \\n               c=max(c,tom(v,time,time1,v[i][j],mp));\\n               \\n            }\\n            else if(mp.find(v[i][j])!=mp.end()){\\n                c=max(c,mp[v[i][j]]);\\n            }\\n                        \\n        }\\n        \\n       \\n        time1=c+time[i];\\n     mp[i]=time1;\\n       \\n          if(mp.size()==v.size()){\\n             \\n            return time1;\\n        }\\n        \\n        \\n        return time1;\\n                \\n    }\\n    int minimumTime(int n, vector<vector<int>>& relations, vector<int>& time) {\\n        \\n        int i;\\n          vector<vector<int>> v(n);\\n        for(i=0;i<relations.size();i++){\\n            v[relations[i][1]-1].push_back(relations[i][0]-1);\\n        }\\n        \\n        int time1=0,ans=INT_MIN;\\n        unordered_map<int,int> mp;\\n        for(i=0;i<n;i++){\\n            \\n            if(mp.find(i)==mp.end()){\\n             \\n                time1=0;\\n                       int c= tom(v,time,time1,i,mp);\\n                if(mp.size()==n){\\n                   break;\\n                }\\n            }\\n            \\n                        \\n        }\\n        for(auto it=mp.begin();it!=mp.end();it++){\\n            ans=max(ans,it->second);\\n        }\\n        \\n        return ans;\\n                 \\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2238872,
                "title": "java-topological-sort-priorityqueue",
                "content": "Intuitive idea: execute the most expensive task before entering to next dependency\\n```\\nclass Solution {\\n    public int minimumTime(int n, int[][] rs, int[] t) {\\n        Map<Integer, List<Integer>> map = new HashMap<>();\\n        int d[] = new int[n+1], res = 0;\\n        for (int[] r : rs) {\\n            d[r[1]]++;\\n            map.computeIfAbsent(r[0], x -> new ArrayList<>()).add(r[1]);\\n        }\\n        \\n        PriorityQueue<int[]> q = new PriorityQueue<>((a, b)->(a[1]-b[1]));\\n        for (int i = 1; i <= n; i++) if (d[i] == 0) q.offer(new int[]{i, t[i-1]});\\n        \\n        while (!q.isEmpty()) {\\n            int cur[] = q.poll();\\n            res = Math.max(res, cur[1]);\\n\\n            for (int next : map.getOrDefault(cur[0], new ArrayList<>())) {\\n                if (--d[next] == 0) q.offer(new int[]{next, cur[1]+t[next-1]});\\n            }\\n            \\n        }\\n        \\n        return res;\\n    }\\n\\n}\\n\\n```",
                "solutionTags": [
                    "Java",
                    "Topological Sort",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\n    public int minimumTime(int n, int[][] rs, int[] t) {\\n        Map<Integer, List<Integer>> map = new HashMap<>();\\n        int d[] = new int[n+1], res = 0;\\n        for (int[] r : rs) {\\n            d[r[1]]++;\\n            map.computeIfAbsent(r[0], x -> new ArrayList<>()).add(r[1]);\\n        }\\n        \\n        PriorityQueue<int[]> q = new PriorityQueue<>((a, b)->(a[1]-b[1]));\\n        for (int i = 1; i <= n; i++) if (d[i] == 0) q.offer(new int[]{i, t[i-1]});\\n        \\n        while (!q.isEmpty()) {\\n            int cur[] = q.poll();\\n            res = Math.max(res, cur[1]);\\n\\n            for (int next : map.getOrDefault(cur[0], new ArrayList<>())) {\\n                if (--d[next] == 0) q.offer(new int[]{next, cur[1]+t[next-1]});\\n            }\\n            \\n        }\\n        \\n        return res;\\n    }\\n\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2231278,
                "title": "c-toposort-bfs-commented",
                "content": "**Upvote if you found solution helpful**\\n```C++\\nclass Solution {\\npublic:\\n    int minimumTime(int n, vector<vector<int>>& relations, vector<int>& time) {\\n        vector<int> adj[n];\\n        vector<int> indegree(n, 0), completeTime(n, 0);\\n        for (auto rel : relations) {\\n\\t\\t   // store the indegree of every next course\\n            indegree[rel[1] - 1]++;\\n            adj[rel[0] - 1].push_back(rel[1] - 1);\\n        }\\n        queue<pair<int,int>> q;\\n\\t\\t\\n\\t\\t// store those courses whose indegree is zero\\n        for (int i = 0; i < n; i++) {\\n            if (indegree[i] == 0) q.push({i, 0});\\n        }\\n\\n        while (!q.empty()) {\\n\\t\\t    // pop the current course\\n            int src = q.front().first;\\n\\t\\t\\t// pop the time need to complete previous courses\\n            int comptime = q.front().second;\\n            q.pop();\\n\\n            // total time needed to complete current course\\n            int timeNeeded = time[src] + comptime;\\n\\t\\t\\t// update its final value that is update the completeTime array\\n            completeTime[src] = timeNeeded;\\n\\n            for (auto nbr : adj[src]) {\\n                indegree[nbr]--;\\n\\t\\t\\t\\t\\n                // update the nbr\\'s time needed to complete the course;\\n                completeTime[nbr] = max(completeTime[nbr], timeNeeded);\\n                if (indegree[nbr] == 0) q.push({nbr,completeTime[nbr]});\\n            }\\n        }\\n\\n        // find the maximum time needed to complete all course\\n        int ans = 0;\\n        for (auto time : completeTime) ans = max(ans, time);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Breadth-First Search",
                    "Topological Sort"
                ],
                "code": "```C++\\nclass Solution {\\npublic:\\n    int minimumTime(int n, vector<vector<int>>& relations, vector<int>& time) {\\n        vector<int> adj[n];\\n        vector<int> indegree(n, 0), completeTime(n, 0);\\n        for (auto rel : relations) {\\n\\t\\t   // store the indegree of every next course\\n            indegree[rel[1] - 1]++;\\n            adj[rel[0] - 1].push_back(rel[1] - 1);\\n        }\\n        queue<pair<int,int>> q;\\n\\t\\t\\n\\t\\t// store those courses whose indegree is zero\\n        for (int i = 0; i < n; i++) {\\n            if (indegree[i] == 0) q.push({i, 0});\\n        }\\n\\n        while (!q.empty()) {\\n\\t\\t    // pop the current course\\n            int src = q.front().first;\\n\\t\\t\\t// pop the time need to complete previous courses\\n            int comptime = q.front().second;\\n            q.pop();\\n\\n            // total time needed to complete current course\\n            int timeNeeded = time[src] + comptime;\\n\\t\\t\\t// update its final value that is update the completeTime array\\n            completeTime[src] = timeNeeded;\\n\\n            for (auto nbr : adj[src]) {\\n                indegree[nbr]--;\\n\\t\\t\\t\\t\\n                // update the nbr\\'s time needed to complete the course;\\n                completeTime[nbr] = max(completeTime[nbr], timeNeeded);\\n                if (indegree[nbr] == 0) q.push({nbr,completeTime[nbr]});\\n            }\\n        }\\n\\n        // find the maximum time needed to complete all course\\n        int ans = 0;\\n        for (auto time : completeTime) ans = max(ans, time);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2187665,
                "title": "c-dp-on-graphs-with-proper-comments-easy-to-understand",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> adj; // Adjecancy List for the graph\\n    vector<int> in; // In-degree of every node\\n    vector<int> dp; // dp array to store minimun time to complete that course\\n    \\n    // dfs for solution in Top-Down manner\\n    int dfs(int i,vector<int> &time){\\n        if(dp[i] != -1){\\n            return dp[i];\\n        }\\n        int ans = 0;\\n        for(auto j:adj[i]){\\n            ans = max(ans,dfs(j,time));\\n        }\\n        return dp[i] = (time[i] + ans);\\n    }\\n    \\n    int minimumTime(int n, vector<vector<int>>& relations, vector<int>& time) {\\n        adj = vector<vector<int>>(n);\\n        in = vector<int> (n);\\n        dp = vector<int> (n,-1);\\n        \\n        for(auto i:relations){\\n            // reversing the direction while inserting in adjecancy list so it will be easy to traverse\\n            adj[i[1] - 1].push_back(i[0] - 1);\\n            // incrementing in-degree\\n            in[i[0] - 1]++;\\n        }\\n        \\n        int ans = 0;\\n        for(int i=0;i < n;i++){\\n            // call dfs only if current node isn\\'t visited and its in-degree is 0. \\n            if(dp[i] == -1 && in[i] == 0){\\n                ans = max(ans,dfs(i,time));\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Depth-First Search",
                    "Graph"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> adj; // Adjecancy List for the graph\\n    vector<int> in; // In-degree of every node\\n    vector<int> dp; // dp array to store minimun time to complete that course\\n    \\n    // dfs for solution in Top-Down manner\\n    int dfs(int i,vector<int> &time){\\n        if(dp[i] != -1){\\n            return dp[i];\\n        }\\n        int ans = 0;\\n        for(auto j:adj[i]){\\n            ans = max(ans,dfs(j,time));\\n        }\\n        return dp[i] = (time[i] + ans);\\n    }\\n    \\n    int minimumTime(int n, vector<vector<int>>& relations, vector<int>& time) {\\n        adj = vector<vector<int>>(n);\\n        in = vector<int> (n);\\n        dp = vector<int> (n,-1);\\n        \\n        for(auto i:relations){\\n            // reversing the direction while inserting in adjecancy list so it will be easy to traverse\\n            adj[i[1] - 1].push_back(i[0] - 1);\\n            // incrementing in-degree\\n            in[i[0] - 1]++;\\n        }\\n        \\n        int ans = 0;\\n        for(int i=0;i < n;i++){\\n            // call dfs only if current node isn\\'t visited and its in-degree is 0. \\n            if(dp[i] == -1 && in[i] == 0){\\n                ans = max(ans,dfs(i,time));\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2185421,
                "title": "java-topology-sort-kahn-s-algo-bfs",
                "content": "```\\nclass Solution {\\n    public int minimumTime(int n, int[][] relations, int[] time) {\\n        int[] indegrees = new int[n];\\n        List<List<Integer>> adjList = new ArrayList<>();\\n        \\n        for(int i=0; i<n; i++) {\\n            adjList.add(new ArrayList<>());\\n        }\\n        \\n        for(int i=0; i< relations.length; i++) {\\n            int[] curr = relations[i];\\n            \\n            adjList.get(curr[0]-1).add(curr[1]-1);\\n            indegrees[curr[1]-1]++;\\n        }\\n        \\n        Queue<Integer> queue = new LinkedList<>();\\n        int[] maxTimes = new int[n];\\n        \\n        for(int i=0; i<n; i++) {\\n            if(indegrees[i]==0) queue.offer(i);\\n            maxTimes[i] = time[i];\\n        }\\n        \\n        int duration = 0;\\n        \\n        while(!queue.isEmpty()) {\\n            int curr = queue.poll();\\n            List<Integer> nextCourses = adjList.get(curr);\\n            for(int nextCourse: nextCourses) {\\n                indegrees[nextCourse]--;\\n                maxTimes[nextCourse] = Math.max(maxTimes[nextCourse], maxTimes[curr]+time[nextCourse]);\\n                if(indegrees[nextCourse] == 0) {\\n                    queue.offer(nextCourse);\\n                }\\n            }\\n            duration = Math.max(duration, maxTimes[curr]);\\n        }\\n        \\n        return duration;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Breadth-First Search",
                    "Topological Sort"
                ],
                "code": "```\\nclass Solution {\\n    public int minimumTime(int n, int[][] relations, int[] time) {\\n        int[] indegrees = new int[n];\\n        List<List<Integer>> adjList = new ArrayList<>();\\n        \\n        for(int i=0; i<n; i++) {\\n            adjList.add(new ArrayList<>());\\n        }\\n        \\n        for(int i=0; i< relations.length; i++) {\\n            int[] curr = relations[i];\\n            \\n            adjList.get(curr[0]-1).add(curr[1]-1);\\n            indegrees[curr[1]-1]++;\\n        }\\n        \\n        Queue<Integer> queue = new LinkedList<>();\\n        int[] maxTimes = new int[n];\\n        \\n        for(int i=0; i<n; i++) {\\n            if(indegrees[i]==0) queue.offer(i);\\n            maxTimes[i] = time[i];\\n        }\\n        \\n        int duration = 0;\\n        \\n        while(!queue.isEmpty()) {\\n            int curr = queue.poll();\\n            List<Integer> nextCourses = adjList.get(curr);\\n            for(int nextCourse: nextCourses) {\\n                indegrees[nextCourse]--;\\n                maxTimes[nextCourse] = Math.max(maxTimes[nextCourse], maxTimes[curr]+time[nextCourse]);\\n                if(indegrees[nextCourse] == 0) {\\n                    queue.offer(nextCourse);\\n                }\\n            }\\n            duration = Math.max(duration, maxTimes[curr]);\\n        }\\n        \\n        return duration;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2185340,
                "title": "c-topological-sort-bfs",
                "content": "```\\nclass Solution {\\npublic:\\n    int minimumTime(int n, vector<vector<int>>& relations, vector<int>& time) {\\n            \\n        vector<int>inDegree(n,0);  //inDegree[i] no. of prerequisites\\n        \\n        vector<vector<int>> graph(n);\\n        \\n        for(int i=0;i<relations.size();i++)\\n        {\\n            graph[relations[i][0]-1].push_back(relations[i][1]-1);\\n            inDegree[relations[i][1]-1]++;\\n        }\\n        \\n        vector<int> endTime(n,0);//end time of a course\\n        vector<int> vis(n,0); //visited courses\\n        \\n        queue<int> q;\\n        \\n        //insert all courses which have inDegree equal to 0\\n        for(int i=0;i<n;i++)\\n        {\\n            if(inDegree[i]==0)\\n            {\\n                q.push(i);\\n                endTime[i]=time[i];\\n                vis[i]=1;\\n            }\\n        }\\n        \\n        while(!q.empty())\\n        {\\n            int u = q.front();\\n            q.pop();\\n            \\n            for(auto &v: graph[u])\\n            {\\n                if(!vis[v]&&endTime[v]<endTime[u]+time[v])\\n                    endTime[v]=endTime[u]+time[v];\\n                \\n                inDegree[v]--;\\n                \\n                if(inDegree[v]==0&&vis[v]==0)\\n                {\\n                    vis[v]=1;\\n                    q.push(v);\\n                }\\n                    \\n            }\\n        }\\n        \\n        int maxEndTime=0;\\n        \\n        for(int i=0;i<n;i++)\\n            maxEndTime=max(maxEndTime,endTime[i]);\\n        \\n        return maxEndTime;\\n    }\\n};\\n\\n/*\\nWe can consider this relation of courses as weighted graph with edge weight equal to time required to complete its prev course.\\nEach course can start at the max ending time among all of its prev courses.\\n\\nTo do this, first we store all the courses which don\\'t have any prerequisites in a queue and end time is equal to their corresponding time given in the input.\\nAt each extraction from the queue, we update its related courses end time and all the prev courses of a related course are visited then we push that course into the queue\\nWe use an array to store the end time of each course and the answer will be equal to maximum of all courses end time.\\nTC: we are visiting all courses and edges(relations) for only once so TC is O(EN) where E is the no. of edges and N is the no. of courses.\\nThis same as BFS algo.\\n*/\\n```",
                "solutionTags": [
                    "C",
                    "Breadth-First Search",
                    "Topological Sort"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumTime(int n, vector<vector<int>>& relations, vector<int>& time) {\\n            \\n        vector<int>inDegree(n,0);  //inDegree[i] no. of prerequisites\\n        \\n        vector<vector<int>> graph(n);\\n        \\n        for(int i=0;i<relations.size();i++)\\n        {\\n            graph[relations[i][0]-1].push_back(relations[i][1]-1);\\n            inDegree[relations[i][1]-1]++;\\n        }\\n        \\n        vector<int> endTime(n,0);//end time of a course\\n        vector<int> vis(n,0); //visited courses\\n        \\n        queue<int> q;\\n        \\n        //insert all courses which have inDegree equal to 0\\n        for(int i=0;i<n;i++)\\n        {\\n            if(inDegree[i]==0)\\n            {\\n                q.push(i);\\n                endTime[i]=time[i];\\n                vis[i]=1;\\n            }\\n        }\\n        \\n        while(!q.empty())\\n        {\\n            int u = q.front();\\n            q.pop();\\n            \\n            for(auto &v: graph[u])\\n            {\\n                if(!vis[v]&&endTime[v]<endTime[u]+time[v])\\n                    endTime[v]=endTime[u]+time[v];\\n                \\n                inDegree[v]--;\\n                \\n                if(inDegree[v]==0&&vis[v]==0)\\n                {\\n                    vis[v]=1;\\n                    q.push(v);\\n                }\\n                    \\n            }\\n        }\\n        \\n        int maxEndTime=0;\\n        \\n        for(int i=0;i<n;i++)\\n            maxEndTime=max(maxEndTime,endTime[i]);\\n        \\n        return maxEndTime;\\n    }\\n};\\n\\n/*\\nWe can consider this relation of courses as weighted graph with edge weight equal to time required to complete its prev course.\\nEach course can start at the max ending time among all of its prev courses.\\n\\nTo do this, first we store all the courses which don\\'t have any prerequisites in a queue and end time is equal to their corresponding time given in the input.\\nAt each extraction from the queue, we update its related courses end time and all the prev courses of a related course are visited then we push that course into the queue\\nWe use an array to store the end time of each course and the answer will be equal to maximum of all courses end time.\\nTC: we are visiting all courses and edges(relations) for only once so TC is O(EN) where E is the no. of edges and N is the no. of courses.\\nThis same as BFS algo.\\n*/\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2109216,
                "title": "c-topological-sorting-extremly-fast-c-sol-beats-95",
                "content": "```\\nclass Solution {\\npublic:\\n    int minimumTime(int n, vector<vector<int>>& relations, vector<int>& time) {\\n        vector<vector<int>> gp (n);\\n        for(int i = 0 ;i < relations.size();i++){\\n                gp[relations[i][0]-1].push_back(relations[i][1]-1);\\n        }\\n        return lp(gp,time);\\n    }\\n    int lp(vector<vector<int>>& adjList,vector<int>& time){\\n        int sz = adjList.size();\\n\\tvector<int> indegree(sz, 0);\\n\\tfor (int i = 0; i < sz; ++i)\\n\\t\\tfor (int j : adjList[i])\\n\\t\\t\\tindegree[j]++;\\n    vector<int> completionTime(sz);\\n\\tqueue<int> ready;\\n\\tfor (int i = 0; i < sz; ++i)\\n\\t\\tif (!indegree[i])\\n\\t\\t\\tready.push(i);\\n\\twhile (!ready.empty()) {\\n\\t\\t// level by level like BFS\\n\\t\\t\\tint i = ready.front();\\n            completionTime[i] += time[i];\\n\\t\\t\\tready.pop();\\n\\t\\t\\tfor (int j : adjList[i]){\\n\\t\\t\\t\\tif (--indegree[j] == 0)\\n\\t\\t\\t\\t\\tready.push(j);\\n             completionTime[j] = max(completionTime[i],completionTime[j]);\\n            }\\n\\t\\t}\\n        return *max_element(completionTime.begin(),completionTime.end());\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Topological Sort"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumTime(int n, vector<vector<int>>& relations, vector<int>& time) {\\n        vector<vector<int>> gp (n);\\n        for(int i = 0 ;i < relations.size();i++){\\n                gp[relations[i][0]-1].push_back(relations[i][1]-1);\\n        }\\n        return lp(gp,time);\\n    }\\n    int lp(vector<vector<int>>& adjList,vector<int>& time){\\n        int sz = adjList.size();\\n\\tvector<int> indegree(sz, 0);\\n\\tfor (int i = 0; i < sz; ++i)\\n\\t\\tfor (int j : adjList[i])\\n\\t\\t\\tindegree[j]++;\\n    vector<int> completionTime(sz);\\n\\tqueue<int> ready;\\n\\tfor (int i = 0; i < sz; ++i)\\n\\t\\tif (!indegree[i])\\n\\t\\t\\tready.push(i);\\n\\twhile (!ready.empty()) {\\n\\t\\t// level by level like BFS\\n\\t\\t\\tint i = ready.front();\\n            completionTime[i] += time[i];\\n\\t\\t\\tready.pop();\\n\\t\\t\\tfor (int j : adjList[i]){\\n\\t\\t\\t\\tif (--indegree[j] == 0)\\n\\t\\t\\t\\t\\tready.push(j);\\n             completionTime[j] = max(completionTime[i],completionTime[j]);\\n            }\\n\\t\\t}\\n        return *max_element(completionTime.begin(),completionTime.end());\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2108913,
                "title": "short-dfs-solution",
                "content": "```\\nclass Solution:\\n    def minimumTime(self, n: int, relations: List[List[int]], time: List[int]) -> int:\\n        graph = defaultdict(dict)\\n        for src, dest in relations:\\n            graph[src][dest] = 1\\n        \\n\\t\\t# save the maximum time starting from the course\\n        self.visited = dict()\\n        def dfs(node):\\n            if node in self.visited:\\n                return self.visited[node]\\n            maxTime = 0\\n            for dest in graph[node]:\\n                maxTime = max(maxTime, dfs(dest))\\n            self.visited[node] = time[node-1] + maxTime\\n            return self.visited[node]\\n        res = 0\\n        for i in range(1, n+1):\\n            res = max(res, dfs(i))\\n        return res",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def minimumTime(self, n: int, relations: List[List[int]], time: List[int]) -> int:\\n        graph = defaultdict(dict)\\n        for src, dest in relations:\\n            graph[src][dest] = 1\\n        \\n\\t\\t# save the maximum time starting from the course\\n        self.visited = dict()\\n        def dfs(node):\\n            if node in self.visited:\\n                return self.visited[node]\\n            maxTime = 0\\n            for dest in graph[node]:\\n                maxTime = max(maxTime, dfs(dest))\\n            self.visited[node] = time[node-1] + maxTime\\n            return self.visited[node]\\n        res = 0\\n        for i in range(1, n+1):\\n            res = max(res, dfs(i))\\n        return res",
                "codeTag": "Java"
            },
            {
                "id": 2002731,
                "title": "c-topological-sort-bfs-easy-to-understand",
                "content": "```\\nclass Solution {\\npublic:\\n    int minimumTime(int n, vector<vector<int>>& relations, vector<int>& time)\\n    {\\n        vector<int>indeg(n+1,0),cost(n+1,0);\\n        vector<int>adj[n+1];\\n        for(auto v:relations)\\n        {\\n            adj[v[0]].push_back(v[1]);\\n            indeg[v[1]]++;\\n        }\\n        queue<pair<int,int>>q;\\n        for(int i=1;i<=n;i++)// we only push in queue which node indegree =0\\n        {\\n            if(indeg[i]==0)\\n            {\\n               // cout<<time[i-1]<<\" \";\\n                q.push({i,time[i-1]});\\n                cost[i]=time[i-1];\\n            }\\n        }\\n        int ans=0;\\n        \\n        while(!q.empty())\\n        {\\n            int u=q.front().first;\\n            int cost1=q.front().second;\\n            ans=max(ans,cost1);\\n            q.pop();\\n            for(int v:adj[u])\\n            {\\n                indeg[v]--;\\n               cost[v]=max(cost[v],cost1+time[v-1]);/// cost to  reach node v\\n                if(indeg[v]==0)/// if degrre 0 push that node into q\\n                {   \\n                    q.push({v,cost[v]});\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n// if you like the solution plz upvote.",
                "solutionTags": [
                    "C",
                    "Breadth-First Search",
                    "Topological Sort",
                    "Queue"
                ],
                "code": "class Solution {\\npublic:\\n    int minimumTime(int n, vector<vector<int>>& relations, vector<int>& time)\\n    {\\n        vector<int>indeg(n+1,0),cost(n+1,0);\\n        vector<int>adj[n+1];\\n        for(auto v:relations)\\n        {\\n            adj[v[0]].push_back(v[1]);\\n            indeg[v[1]]++;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1985187,
                "title": "java-bfs-topological-sort",
                "content": "```\\npublic int minimumTime(int n, int[][] relations, int[] time) {\\n        int v = time.length;\\n        List<List<Integer>> adj = new ArrayList<>();\\n        for(int i = 0 ; i < v ; i++) {\\n            adj.add(new ArrayList<>());\\n        }\\n        int[] indegree = new int[v];\\n        int[] requiredTime = new int[v];\\n        int e1 = relations.length;\\n        for(int i = 0 ; i < e1 ; i++) {\\n            List<Integer> vertices = adj.get(relations[i][0]-1);\\n            vertices.add(relations[i][1]-1);\\n            indegree[relations[i][1]-1]++;\\n        }\\n        \\n        Queue<Integer> q = new ArrayDeque<>();\\n        for(int i = 0 ; i < v ; i++) {\\n            if(indegree[i] == 0) {\\n                q.add(i);\\n                requiredTime[i] = time[i];\\n            }\\n        }\\n        \\n        while(!q.isEmpty()) {\\n            int vertex = q.poll();\\n            List<Integer> edges = adj.get(vertex);\\n            for(Integer e : edges) {\\n                indegree[e]--;\\n                if(indegree[e] == 0) {\\n                    q.add(e);\\n                }\\n                int totalTime = time[e] + requiredTime[vertex];\\n                if(requiredTime[e] < totalTime) {\\n                    requiredTime[e] = totalTime;\\n                }\\n            }\\n        }\\n        int maxMonth = 0;\\n        for(int i = 0 ; i < n ; i++) {\\n            maxMonth = Math.max(maxMonth, requiredTime[i]);\\n        }\\n        return maxMonth;\\n    }\\n```",
                "solutionTags": [
                    "Java",
                    "Breadth-First Search",
                    "Topological Sort"
                ],
                "code": "```\\npublic int minimumTime(int n, int[][] relations, int[] time) {\\n        int v = time.length;\\n        List<List<Integer>> adj = new ArrayList<>();\\n        for(int i = 0 ; i < v ; i++) {\\n            adj.add(new ArrayList<>());\\n        }\\n        int[] indegree = new int[v];\\n        int[] requiredTime = new int[v];\\n        int e1 = relations.length;\\n        for(int i = 0 ; i < e1 ; i++) {\\n            List<Integer> vertices = adj.get(relations[i][0]-1);\\n            vertices.add(relations[i][1]-1);\\n            indegree[relations[i][1]-1]++;\\n        }\\n        \\n        Queue<Integer> q = new ArrayDeque<>();\\n        for(int i = 0 ; i < v ; i++) {\\n            if(indegree[i] == 0) {\\n                q.add(i);\\n                requiredTime[i] = time[i];\\n            }\\n        }\\n        \\n        while(!q.isEmpty()) {\\n            int vertex = q.poll();\\n            List<Integer> edges = adj.get(vertex);\\n            for(Integer e : edges) {\\n                indegree[e]--;\\n                if(indegree[e] == 0) {\\n                    q.add(e);\\n                }\\n                int totalTime = time[e] + requiredTime[vertex];\\n                if(requiredTime[e] < totalTime) {\\n                    requiredTime[e] = totalTime;\\n                }\\n            }\\n        }\\n        int maxMonth = 0;\\n        for(int i = 0 ; i < n ; i++) {\\n            maxMonth = Math.max(maxMonth, requiredTime[i]);\\n        }\\n        return maxMonth;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1824892,
                "title": "easy-c-code-topological-sort",
                "content": "\\n\\n```\\nclass Solution {\\npublic:\\n    int minimumTime(int n, vector<vector<int>>& relations, vector<int>& time) {\\n        vector<int>indeg(n+1,0);\\n        for(auto x:relations)\\n        {\\n            indeg[x[1]]++;\\n        }\\n        vector<vector<int>>adj(n+1);\\n        for(auto x:relations)\\n        {\\n            adj[x[0]].push_back(x[1]);\\n        }\\n       \\n        int answer = 0;\\n        priority_queue<pair<int,int>, vector<pair<int,int>>, greater<pair<int,int>>>pq;\\n        for(int i=1;i<=n;i++)\\n        {\\n            if(indeg[i] == 0)\\n            {\\n               \\n                pq.push({time[i-1],i});\\n            }\\n        }\\n        while(!pq.empty())\\n        {\\n            \\n            \\n               pair<int,int>st = pq.top();\\n                pq.pop();\\n                answer = st.first;\\n                for(auto x:adj[st.second])\\n                {\\n                    indeg[x]--;\\n                    if(indeg[x] == 0)\\n                        pq.push({answer + time[x-1], x});\\n                }\\n                \\n            \\n            \\n        }\\n        return answer;\\n        \\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Topological Sort",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumTime(int n, vector<vector<int>>& relations, vector<int>& time) {\\n        vector<int>indeg(n+1,0);\\n        for(auto x:relations)\\n        {\\n            indeg[x[1]]++;\\n        }\\n        vector<vector<int>>adj(n+1);\\n        for(auto x:relations)\\n        {\\n            adj[x[0]].push_back(x[1]);\\n        }\\n       \\n        int answer = 0;\\n        priority_queue<pair<int,int>, vector<pair<int,int>>, greater<pair<int,int>>>pq;\\n        for(int i=1;i<=n;i++)\\n        {\\n            if(indeg[i] == 0)\\n            {\\n               \\n                pq.push({time[i-1],i});\\n            }\\n        }\\n        while(!pq.empty())\\n        {\\n            \\n            \\n               pair<int,int>st = pq.top();\\n                pq.pop();\\n                answer = st.first;\\n                for(auto x:adj[st.second])\\n                {\\n                    indeg[x]--;\\n                    if(indeg[x] == 0)\\n                        pq.push({answer + time[x-1], x});\\n                }\\n                \\n            \\n            \\n        }\\n        return answer;\\n        \\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1802173,
                "title": "python-solution-simple-clean-dfs",
                "content": "\\n\\n```\\nclass Solution:\\n    def minimumTime(self, n: int, relations: List[List[int]], time: List[int]) -> int:\\n        \\n        prerequisite = collections.defaultdict(set)\\n        \\n        for pre, nex in relations:\\n            prerequisite[nex].add(pre)\\n        \\n        @functools.cache\\n        def earliestTime(i):\\n            ti = time[i-1]\\n            ans = 0\\n            for course in prerequisite[i]:\\n                ans = max(ans, earliestTime(course))\\n            return ans + ti\\n                \\n        totalTime = 0\\n        for i in range(1, n+1):\\n            totalTime = max(totalTime, earliestTime(i))\\n            \\n        return totalTime\\n\\n```",
                "solutionTags": [
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution:\\n    def minimumTime(self, n: int, relations: List[List[int]], time: List[int]) -> int:\\n        \\n        prerequisite = collections.defaultdict(set)\\n        \\n        for pre, nex in relations:\\n            prerequisite[nex].add(pre)\\n        \\n        @functools.cache\\n        def earliestTime(i):\\n            ti = time[i-1]\\n            ans = 0\\n            for course in prerequisite[i]:\\n                ans = max(ans, earliestTime(course))\\n            return ans + ti\\n                \\n        totalTime = 0\\n        for i in range(1, n+1):\\n            totalTime = max(totalTime, earliestTime(i))\\n            \\n        return totalTime\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1626114,
                "title": "python-topological-sort-keep-track-of-the-wait-time-of-every-course",
                "content": "```\\nclass Solution:\\n    def minimumTime(self, n: int, relations: List[List[int]], time: List[int]) -> int:\\n        waitTime = [0] * n\\n        Indegree = [0] * n\\n        \\n        graph = {}\\n        for a, b in relations:\\n            if a-1 in graph:\\n                graph[a-1].append(b-1)\\n            else:\\n                graph[a-1] = [b-1]\\n            \\n            Indegree[b-1] += 1\\n        \\n        finishTime = 0\\n        q = deque()\\n        for i in range(n):\\n            if Indegree[i] == 0:\\n                q.append(i)\\n                \\n        while(q):\\n            size = len(q)\\n            for _ in range(size):\\n                curCourse = q.popleft()\\n                finishTime = max(finishTime, waitTime[curCourse] + time[curCourse])\\n                if curCourse in graph:\\n                    for nextCourse in graph[curCourse]:\\n                        waitTime[nextCourse] = max(waitTime[nextCourse], waitTime[curCourse] + time[curCourse])\\n                        Indegree[nextCourse] -= 1\\n                        if Indegree[nextCourse] == 0:\\n                            q.append(nextCourse)\\n                            \\n        return finishTime\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def minimumTime(self, n: int, relations: List[List[int]], time: List[int]) -> int:\\n        waitTime = [0] * n\\n        Indegree = [0] * n\\n        \\n        graph = {}\\n        for a, b in relations:\\n            if a-1 in graph:\\n                graph[a-1].append(b-1)\\n            else:\\n                graph[a-1] = [b-1]\\n            \\n            Indegree[b-1] += 1\\n        \\n        finishTime = 0\\n        q = deque()\\n        for i in range(n):\\n            if Indegree[i] == 0:\\n                q.append(i)\\n                \\n        while(q):\\n            size = len(q)\\n            for _ in range(size):\\n                curCourse = q.popleft()\\n                finishTime = max(finishTime, waitTime[curCourse] + time[curCourse])\\n                if curCourse in graph:\\n                    for nextCourse in graph[curCourse]:\\n                        waitTime[nextCourse] = max(waitTime[nextCourse], waitTime[curCourse] + time[curCourse])\\n                        Indegree[nextCourse] -= 1\\n                        if Indegree[nextCourse] == 0:\\n                            q.append(nextCourse)\\n                            \\n        return finishTime\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1624715,
                "title": "simple-c-explanation-intuition-and-comments",
                "content": "we can start a certain cource after all its pre-requisites are over so we can only start a cource immediately after the pre-requisite cource that takes max time. so we need to go topologically inside and then for each node we need to see the max_time the of his pre-requisite nodes need and then add its time to it and this will be the time needed to complete the current cource. \\n```\\nclass Solution {\\npublic:\\n    int minimumTime(int n, vector<vector<int>>&R, vector<int>&T) {\\n        vector<int>in(n + 1,0);\\n        unordered_map<int,vector<int>>G;\\n        int n1 = R.size();\\n        vector<int>Time(n,0);\\n        for(int i = 0; i < n1; i++)\\n        {\\n            G[R[i][0]].push_back(R[i][1]);\\n            in[R[i][1]]++;\\n        }\\n        queue<int>q;\\n        for(int i = 1; i <= n; i++)\\n        {\\n            if(in[i] == 0)\\n            {\\n                q.push(i);\\n                Time[i - 1] = T[i - 1];\\n            }\\n        }\\n        while(!q.empty())\\n        {\\n            int size = q.size();\\n            for(int i = 0; i < size; i++)\\n            {\\n                int node = q.front();\\n                q.pop();\\n                vector<int>child  = G[node];\\n                for(int j = 0; j < child.size(); j++)\\n                {\\n                    in[child[j]]--;\\n                    Time[child[j] - 1] = max(Time[child[j] - 1],Time[node - 1] + T[child[j] - 1]);// max of his pre-requisite take and then add its time to it \\n                    if(in[child[j]] == 0)\\n                    {\\n                        q.push(child[j]);\\n                    }\\n                }\\n            }\\n        }\\n        int min_time = *max_element(Time.begin(), Time.end());// the maximum time taken by a cource will be the last cource to be completed.\\n        return min_time;\\n        \\n    }\\n};\\n```\\nPlease if you liked the code and it helped you give a upvote it will motivate me to contribute more",
                "solutionTags": [
                    "Topological Sort"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumTime(int n, vector<vector<int>>&R, vector<int>&T) {\\n        vector<int>in(n + 1,0);\\n        unordered_map<int,vector<int>>G;\\n        int n1 = R.size();\\n        vector<int>Time(n,0);\\n        for(int i = 0; i < n1; i++)\\n        {\\n            G[R[i][0]].push_back(R[i][1]);\\n            in[R[i][1]]++;\\n        }\\n        queue<int>q;\\n        for(int i = 1; i <= n; i++)\\n        {\\n            if(in[i] == 0)\\n            {\\n                q.push(i);\\n                Time[i - 1] = T[i - 1];\\n            }\\n        }\\n        while(!q.empty())\\n        {\\n            int size = q.size();\\n            for(int i = 0; i < size; i++)\\n            {\\n                int node = q.front();\\n                q.pop();\\n                vector<int>child  = G[node];\\n                for(int j = 0; j < child.size(); j++)\\n                {\\n                    in[child[j]]--;\\n                    Time[child[j] - 1] = max(Time[child[j] - 1],Time[node - 1] + T[child[j] - 1]);// max of his pre-requisite take and then add its time to it \\n                    if(in[child[j]] == 0)\\n                    {\\n                        q.push(child[j]);\\n                    }\\n                }\\n            }\\n        }\\n        int min_time = *max_element(Time.begin(), Time.end());// the maximum time taken by a cource will be the last cource to be completed.\\n        return min_time;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1598648,
                "title": "swift-topological-sort",
                "content": "```\\nclass Solution {\\n    func minimumTime(_ n: Int, _ relations: [[Int]], _ time: [Int]) -> Int {\\n        var graph = Array(repeating: [Int](), count: n)\\n        var maxTime = Array(repeating: 0, count: n)\\n        var indegree = [Int: Int]()\\n        var queue = [Int]()\\n        \\n        for relation in relations {\\n            let prevCourse = relation[0] - 1\\n            let nextCourse = relation[1] - 1\\n            indegree[nextCourse, default: 0] += 1\\n            graph[prevCourse].append(nextCourse)\\n        }\\n        \\n        for node in 0..<n {\\n            if indegree[node] == nil {\\n                queue.append(node)\\n                maxTime[node] = time[node]\\n            }\\n        }\\n        \\n        while !queue.isEmpty {\\n            let node = queue.removeFirst()\\n            \\n            for nextCourse in graph[node] {\\n                maxTime[nextCourse] = max(maxTime[nextCourse], time[nextCourse] + maxTime[node])\\n                if let degree = indegree[nextCourse] {\\n                    if degree == 1 {\\n                        indegree[nextCourse]  = nil\\n                        queue.append(nextCourse)\\n                    } else {\\n                        indegree[nextCourse]  = degree - 1\\n                    }\\n                }\\n            }\\n        }\\n        \\n        return maxTime.max() ?? Int.max\\n    }\\n}\\n```",
                "solutionTags": [
                    "Swift",
                    "Topological Sort"
                ],
                "code": "```\\nclass Solution {\\n    func minimumTime(_ n: Int, _ relations: [[Int]], _ time: [Int]) -> Int {\\n        var graph = Array(repeating: [Int](), count: n)\\n        var maxTime = Array(repeating: 0, count: n)\\n        var indegree = [Int: Int]()\\n        var queue = [Int]()\\n        \\n        for relation in relations {\\n            let prevCourse = relation[0] - 1\\n            let nextCourse = relation[1] - 1\\n            indegree[nextCourse, default: 0] += 1\\n            graph[prevCourse].append(nextCourse)\\n        }\\n        \\n        for node in 0..<n {\\n            if indegree[node] == nil {\\n                queue.append(node)\\n                maxTime[node] = time[node]\\n            }\\n        }\\n        \\n        while !queue.isEmpty {\\n            let node = queue.removeFirst()\\n            \\n            for nextCourse in graph[node] {\\n                maxTime[nextCourse] = max(maxTime[nextCourse], time[nextCourse] + maxTime[node])\\n                if let degree = indegree[nextCourse] {\\n                    if degree == 1 {\\n                        indegree[nextCourse]  = nil\\n                        queue.append(nextCourse)\\n                    } else {\\n                        indegree[nextCourse]  = degree - 1\\n                    }\\n                }\\n            }\\n        }\\n        \\n        return maxTime.max() ?? Int.max\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1550095,
                "title": "c-dfs-easy-solution",
                "content": "MAKE THE GRAPH IN REVERSE ORDERE  AND CALL DFS IN REVERSE GRAPH FROM ALL THE NODE THAT HAVE OUT DEGREE 0 IN ORIGINAL GRAPH\\n```\\nclass Solution {\\npublic:\\n    void dfs(vector<int>gr[],int i,vector<int>&vis,vector<int>&mt,vector<int>& t)\\n    {\\n        vis[i]=1;\\n        \\n        mt[i]=t[i-1];\\n        \\n        for(int k=0;k<gr[i].size();k++)\\n        {\\n            int j=gr[i][k];\\n            if(!vis[j])\\n            {\\n               dfs(gr,j,vis,mt,t);\\n            }\\n            mt[i]=max(mt[i],mt[j]+t[i-1]);  \\n        }\\n        \\n        return;\\n    }\\n    int minimumTime(int n, vector<vector<int>>& rel, vector<int>& t) {\\n        \\n        vector<int>gr[n+1];\\n        vector<int>deg(n+1);\\n        for(auto &r:rel)\\n        {\\n            gr[r[1]].push_back(r[0]);  // MAKING REVERSE GRAPH\\n            deg[r[0]]++;  //  CALCULATING OUT DEGREE\\n        }\\n        \\n        vector<int>vis(n+1);\\n        vector<int>mt(n+1);\\n        int ans=0;\\n        for(int i=1;i<=n;i++)\\n        {\\n            if(deg[i]==0)\\n            {\\n              dfs(gr,i,vis,mt,t);\\n              ans=max(ans,mt[i]);  \\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    void dfs(vector<int>gr[],int i,vector<int>&vis,vector<int>&mt,vector<int>& t)\\n    {\\n        vis[i]=1;\\n        \\n        mt[i]=t[i-1];\\n        \\n        for(int k=0;k<gr[i].size();k++)\\n        {\\n            int j=gr[i][k];\\n            if(!vis[j])\\n            {\\n               dfs(gr,j,vis,mt,t);\\n            }\\n            mt[i]=max(mt[i],mt[j]+t[i-1]);  \\n        }\\n        \\n        return;\\n    }\\n    int minimumTime(int n, vector<vector<int>>& rel, vector<int>& t) {\\n        \\n        vector<int>gr[n+1];\\n        vector<int>deg(n+1);\\n        for(auto &r:rel)\\n        {\\n            gr[r[1]].push_back(r[0]);  // MAKING REVERSE GRAPH\\n            deg[r[0]]++;  //  CALCULATING OUT DEGREE\\n        }\\n        \\n        vector<int>vis(n+1);\\n        vector<int>mt(n+1);\\n        int ans=0;\\n        for(int i=1;i<=n;i++)\\n        {\\n            if(deg[i]==0)\\n            {\\n              dfs(gr,i,vis,mt,t);\\n              ans=max(ans,mt[i]);  \\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1547442,
                "title": "c",
                "content": "```\\nclass Solution {\\npublic:\\n    \\n    void dfs(int i, vector<vector<int> >&g, vector<int>&cost, vector<bool>&visited, vector<int>&time) {\\n        visited[i] = true;\\n        \\n        int c = 0;\\n        for(int j = 0; j < g[i].size(); j++){\\n            if(visited[ g[i][j] ] == false) {\\n                dfs(g[i][j], g, cost, visited, time);\\n            }\\n            c = max(c, cost[g[i][j]]);\\n        }\\n        cost[i] = c+time[i-1];        \\n    }\\n    \\n    int minimumTime(int n, vector<vector<int>>& relations, vector<int>& time) {\\n        vector<vector<int> >g(n+1);\\n        \\n        for(int i = 0; i < relations.size(); i++) {\\n            g[relations[i][0]].push_back(relations[i][1]);\\n        }\\n        \\n        vector<int>cost(n+1, 0);\\n        vector<bool>visited(n+1, false);\\n        \\n        for(int i = 1; i <= n;i++) {\\n            if (visited[i] == false)\\n                dfs(i, g, cost, visited,time);\\n        }\\n        int ans = 0;\\n        for(int i = 1;i <= n; i++) {\\n            ans = max(ans, cost[i]);\\n        }\\n        return ans;\\n        \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    void dfs(int i, vector<vector<int> >&g, vector<int>&cost, vector<bool>&visited, vector<int>&time) {\\n        visited[i] = true;\\n        \\n        int c = 0;\\n        for(int j = 0; j < g[i].size(); j++){\\n            if(visited[ g[i][j] ] == false) {\\n                dfs(g[i][j], g, cost, visited, time);\\n            }\\n            c = max(c, cost[g[i][j]]);\\n        }\\n        cost[i] = c+time[i-1];        \\n    }\\n    \\n    int minimumTime(int n, vector<vector<int>>& relations, vector<int>& time) {\\n        vector<vector<int> >g(n+1);\\n        \\n        for(int i = 0; i < relations.size(); i++) {\\n            g[relations[i][0]].push_back(relations[i][1]);\\n        }\\n        \\n        vector<int>cost(n+1, 0);\\n        vector<bool>visited(n+1, false);\\n        \\n        for(int i = 1; i <= n;i++) {\\n            if (visited[i] == false)\\n                dfs(i, g, cost, visited,time);\\n        }\\n        int ans = 0;\\n        for(int i = 1;i <= n; i++) {\\n            ans = max(ans, cost[i]);\\n        }\\n        return ans;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1546258,
                "title": "python-solution-using-topology-sort-and-bfs",
                "content": "```\\n    class Solution:\\n    def minimumTime(self, n: int, relations: List[List[int]], time: List[int]) -> int:\\n        graph = { course:[] for course in range(n)}\\n        inDegree = [0]*n\\n        # 1- build graph\\n        #  convert 1-base into 0-baseindexes and add to graph\\n        # Note: choose Prev->next since it helps to preserve the topology order\\n        for prevCourse,nextCourse in relations:\\n            prevCourse,nextCourse = prevCourse-1, nextCourse-1\\n            graph[prevCourse].append(nextCourse)\\n            inDegree[nextCourse] += 1\\n\\n        # 2 Assign time cost\\n        q = collections.deque()\\n        cost = [0] * n\\n        for course in range(n):\\n            if inDegree[course] == 0:\\n                q.append(course)\\n                cost[course] = time[course] # number of months\\n        # 3- BFS\\n        while q:\\n            prevCourse = q.popleft()\\n            for nextCourse in graph[prevCourse]:\\n                # Update cost[nextCourse] using the maximum cost of the predecessor course\\n                cost[nextCourse] = max(cost[nextCourse], cost[prevCourse] + time[nextCourse])\\n                inDegree[nextCourse] -= 1\\n                if inDegree[nextCourse] == 0:\\n                    q.append(nextCourse)\\n        return max(cost)\\n\\t\\t```",
                "solutionTags": [
                    "Python3",
                    "Breadth-First Search",
                    "Topological Sort"
                ],
                "code": "```\\n    class Solution:\\n    def minimumTime(self, n: int, relations: List[List[int]], time: List[int]) -> int:\\n        graph = { course:[] for course in range(n)}\\n        inDegree = [0]*n\\n        # 1- build graph\\n        #  convert 1-base into 0-baseindexes and add to graph\\n        # Note: choose Prev->next since it helps to preserve the topology order\\n        for prevCourse,nextCourse in relations:\\n            prevCourse,nextCourse = prevCourse-1, nextCourse-1\\n            graph[prevCourse].append(nextCourse)\\n            inDegree[nextCourse] += 1\\n\\n        # 2 Assign time cost\\n        q = collections.deque()\\n        cost = [0] * n\\n        for course in range(n):\\n            if inDegree[course] == 0:\\n                q.append(course)\\n                cost[course] = time[course] # number of months\\n        # 3- BFS\\n        while q:\\n            prevCourse = q.popleft()\\n            for nextCourse in graph[prevCourse]:\\n                # Update cost[nextCourse] using the maximum cost of the predecessor course\\n                cost[nextCourse] = max(cost[nextCourse], cost[prevCourse] + time[nextCourse])\\n                inDegree[nextCourse] -= 1\\n                if inDegree[nextCourse] == 0:\\n                    q.append(nextCourse)\\n        return max(cost)\\n\\t\\t```",
                "codeTag": "Java"
            },
            {
                "id": 1541085,
                "title": "c-topological-sort-and-one-trick",
                "content": "We use one additional variable to hold the passed time. Every node in the queue equally consume that amount of time. Whenever we meet a new node, we add that new node\\'s length to the parent\\'s length.\\n```\\nusing ll = long long;\\nusing pii = pair<int, int>;\\nclass Solution {\\npublic:\\n    int minimumTime(int n, vector<vector<int>>& relations, vector<int>& time) {\\n        vector<vector<int>> g(n + 1);\\n        vector<int> indegrees(n + 1);\\n        for (vector<int>& relation : relations) {\\n            int u = relation[0], v = relation[1];\\n            g[u].emplace_back(v);\\n            ++indegrees[v];\\n        }\\n        priority_queue<pii, vector<pii>, greater<>> q;\\n        for (int i = 1; i <= n; ++i) {\\n            if (indegrees[i] == 0) {\\n                q.emplace(time[i - 1], i);\\n            }\\n        }\\n        int ans = 0;\\n        while (!q.empty()) {\\n            auto [len, i] = q.top(); q.pop();\\n            ans = len;\\n            for (int j : g[i]) {\\n                if (--indegrees[j] == 0) {\\n                    q.emplace(len + time[j - 1], j);\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nusing ll = long long;\\nusing pii = pair<int, int>;\\nclass Solution {\\npublic:\\n    int minimumTime(int n, vector<vector<int>>& relations, vector<int>& time) {\\n        vector<vector<int>> g(n + 1);\\n        vector<int> indegrees(n + 1);\\n        for (vector<int>& relation : relations) {\\n            int u = relation[0], v = relation[1];\\n            g[u].emplace_back(v);\\n            ++indegrees[v];\\n        }\\n        priority_queue<pii, vector<pii>, greater<>> q;\\n        for (int i = 1; i <= n; ++i) {\\n            if (indegrees[i] == 0) {\\n                q.emplace(time[i - 1], i);\\n            }\\n        }\\n        int ans = 0;\\n        while (!q.empty()) {\\n            auto [len, i] = q.top(); q.pop();\\n            ans = len;\\n            for (int j : g[i]) {\\n                if (--indegrees[j] == 0) {\\n                    q.emplace(len + time[j - 1], j);\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1540242,
                "title": "c-kahn-s-algorithm-for-topological-sorting-using-dp",
                "content": "```\\nclass Solution {\\npublic:\\n    int minimumTime(int n, vector<vector<int>>& p, vector<int>& a) {\\n        vector<int> edge[n + 1];\\n        vector<int> deg(n + 1);\\n        for(auto i : p){\\n            edge[i[0]].push_back(i[1]);\\n            deg[i[1]]++;\\n        }\\n        queue<int> q;\\n        for(int i = 1; i <= n; i++) {\\n            if(deg[i] == 0) q.push(i);\\n        }\\n        vector<int> dp(n + 1);\\n        while(!q.empty()) {\\n            int node = q.front();\\n            q.pop();\\n            dp[node] += a[node - 1];\\n            for(auto j : edge[node]) {\\n                if(!--deg[j]){\\n                    q.push(j);\\n                }\\n                dp[j] = max(dp[j], dp[node]);\\n            }\\n        }\\n        return *max_element(dp.begin(), dp.end());\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Breadth-First Search",
                    "Topological Sort",
                    "Queue"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumTime(int n, vector<vector<int>>& p, vector<int>& a) {\\n        vector<int> edge[n + 1];\\n        vector<int> deg(n + 1);\\n        for(auto i : p){\\n            edge[i[0]].push_back(i[1]);\\n            deg[i[1]]++;\\n        }\\n        queue<int> q;\\n        for(int i = 1; i <= n; i++) {\\n            if(deg[i] == 0) q.push(i);\\n        }\\n        vector<int> dp(n + 1);\\n        while(!q.empty()) {\\n            int node = q.front();\\n            q.pop();\\n            dp[node] += a[node - 1];\\n            for(auto j : edge[node]) {\\n                if(!--deg[j]){\\n                    q.push(j);\\n                }\\n                dp[j] = max(dp[j], dp[node]);\\n            }\\n        }\\n        return *max_element(dp.begin(), dp.end());\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1538993,
                "title": "topological-sort-dp-intro-to-topological-sort-concise-comments",
                "content": "\\t\\t\\'\\'\\'\\n\\t\\tclass Solution {\\n\\t\\tpublic int minimumTime(int n, int[][] relations, int[] time) {\\n\\t\\t\\t// 1.We will use a map named inDegree to save the number of precourses for current course\\n\\t\\t\\t// When the value is 0, we can take the course of its key, since we already take all the precourse \\n\\t\\t\\t// E.g. Input: n = 3, relations = [[1,3],[2,3]], time = [3, 2, 5]\\n\\t\\t\\t// inDegree will be like {1:0, 2:0, 3:2}\\n\\t\\t\\t// Since there is no precourses for course 1 and course 2, but for course 3, we need take course 1 and course 2 first\\n\\n\\t\\t\\t// 2.Another map named adj save the relationships with each courses\\n\\t\\t\\t// E.g. Input: n = 3, relations = [[1,3],[2,3]], time = [3, 2, 5]\\n\\t\\t\\t// adj will be like {1 : {3}, 2 : {3}}\\n\\t\\t\\t// After we take course 1,  value of key 3 in the inDegree will reduce 1, since we already take one precourse\\n\\n\\n\\t\\t\\tMap<Integer, Integer> inDegree = new HashMap<>();\\n\\t\\t\\tfor(int i = 1; i <= n; i++) {\\n\\t\\t\\t\\tinDegree.put(i, 0);\\n\\t\\t\\t}\\n\\n\\t\\t\\tMap<Integer, List<Integer>> adj = new HashMap<>();\\n\\t\\t\\tfor(int[] re : relations) {\\n\\t\\t\\t\\tint cur = re[0];\\n\\t\\t\\t\\tint next = re[1];\\n\\t\\t\\t\\tif(inDegree.containsKey(next)) {\\n\\t\\t\\t\\t\\tinDegree.put(next, inDegree.get(next) + 1);\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tif(!adj.containsKey(cur)) {\\n\\t\\t\\t\\t\\tadj.put(cur, new ArrayList<>());\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tadj.get(cur).add(next);\\n\\t\\t\\t}\\n\\n\\t\\t\\t// We need create dp[i], i means course i is the end course, we won\\'t take any more courses, \\n\\t\\t\\t// and the dp[i] menas months we have to spend\\n\\t\\t\\t// Just ignore dp[0], since course number starts from 1\\n\\t\\t\\tint[] dp = new int[n+1];\\n\\t\\t\\t// In the inDegree map, if the value is 0, means we can take this course (key of the value), since there is no precourse\\n\\n\\t\\t\\tDeque<Integer> queue = new ArrayDeque<>();\\n\\t\\t\\tfor(int key : inDegree.keySet()) {\\n\\t\\t\\t\\tif(inDegree.get(key) == 0) {\\n\\t\\t\\t\\t\\tqueue.offer(key);\\n\\t\\t\\t\\t\\t//Initiate dp, finish course key, we have to spend time[k-1] months\\n\\t\\t\\t\\t\\tdp[key] = time[key-1];\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\n\\t\\t\\twhile(!queue.isEmpty()) {\\n\\t\\t\\t\\tint cur = queue.poll();\\n\\t\\t\\t\\tif(!adj.containsKey(cur)) {\\n\\t\\t\\t\\t\\tcontinue;\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tList<Integer> l = adj.get(cur);\\n\\t\\t\\t\\tfor(int next : l) {\\n\\t\\t\\t\\t\\t// dp[next] means course next is our end course. So the total months we need to finish course next,\\n\\t\\t\\t\\t\\t// is the longest time of its precourse and required months of course next.\\n\\t\\t\\t\\t\\tdp[next] = Math.max(dp[next], dp[cur] + time[next - 1]);\\n\\t\\t\\t\\t\\tinDegree.put(next, inDegree.get(next)-1);\\n\\t\\t\\t\\t\\tif(inDegree.get(next) == 0) {\\n\\t\\t\\t\\t\\t\\tqueue.offer(next);\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\t//Iterate the whole dp[] array, find the largest number.\\n\\t\\t\\tint max = 0;\\n\\t\\t\\tfor(int d : dp) {\\n\\t\\t\\t\\tmax = Math.max(d,max);\\n\\t\\t\\t}\\n\\t\\t\\treturn max;\\n\\t\\t}\\n\\t}\\n",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming",
                    "Topological Sort"
                ],
                "code": "class Solution {\\n\\t\\tpublic int minimumTime(int n, int[][] relations, int[] time) {\\n\\t\\t\\t// 1.We will use a map named inDegree to save the number of precourses for current course\\n\\t\\t\\t// When the value is 0, we can take the course of its key, since we already take all the precourse \\n\\t\\t\\t// E.g. Input: n = 3, relations = [[1,3],[2,3]], time = [3, 2, 5]\\n\\t\\t\\t// inDegree will be like {1:0, 2:0, 3:2}",
                "codeTag": "Java"
            },
            {
                "id": 1538703,
                "title": "python3-topo-sort",
                "content": "\\n```\\nclass Solution:\\n    def minimumTime(self, n: int, relations: List[List[int]], time: List[int]) -> int:\\n        graph = [[] for _ in range(n)]\\n        indeg = [0]*n \\n        for u, v in relations: \\n            graph[u-1].append(v-1)\\n            indeg[v-1] += 1\\n        \\n        start = [0]*n\\n        queue = deque((i, time[i]) for i, x in enumerate(indeg) if x == 0)\\n        \\n        while queue: \\n            u, t = queue.popleft() # earlist to finish course u\\n            for v in graph[u]: \\n                start[v] = max(start[v], t) # earlist to start course v\\n                indeg[v] -= 1\\n                if indeg[v] == 0: queue.append((v, start[v] + time[v]))\\n        return max(s+t for s, t in zip(start, time))\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minimumTime(self, n: int, relations: List[List[int]], time: List[int]) -> int:\\n        graph = [[] for _ in range(n)]\\n        indeg = [0]*n \\n        for u, v in relations: \\n            graph[u-1].append(v-1)\\n            indeg[v-1] += 1\\n        \\n        start = [0]*n\\n        queue = deque((i, time[i]) for i, x in enumerate(indeg) if x == 0)\\n        \\n        while queue: \\n            u, t = queue.popleft() # earlist to finish course u\\n            for v in graph[u]: \\n                start[v] = max(start[v], t) # earlist to start course v\\n                indeg[v] -= 1\\n                if indeg[v] == 0: queue.append((v, start[v] + time[v]))\\n        return max(s+t for s, t in zip(start, time))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1538488,
                "title": "rust-solution",
                "content": "Just DFS\\n\\n```rust\\nimpl Solution {\\n    pub fn minimum_time(n: i32, relations: Vec<Vec<i32>>, time: Vec<i32>) -> i32 {\\n        let n = n as usize;\\n        let mut graph = vec![vec![]; n];\\n        for r in relations {\\n            graph[(r[1] - 1) as usize].push((r[0] - 1) as usize);\\n        }\\n        let mut depth = vec![-1; n];\\n        (0..n)\\n            .map(|i| Solution::dfs(i, &mut depth, &graph, &time))\\n            .max()\\n            .unwrap()\\n    }\\n\\n    fn dfs(i: usize, depth: &mut [i32], graph: &[Vec<usize>], time: &[i32]) -> i32 {\\n        if depth[i] == -1 {\\n            depth[i] = graph[i]\\n                .iter()\\n                .map(|&next| Solution::dfs(next, depth, graph, time))\\n                .max()\\n                .unwrap_or(0)\\n                + time[i];\\n        }\\n        depth[i]\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```rust\\nimpl Solution {\\n    pub fn minimum_time(n: i32, relations: Vec<Vec<i32>>, time: Vec<i32>) -> i32 {\\n        let n = n as usize;\\n        let mut graph = vec![vec![]; n];\\n        for r in relations {\\n            graph[(r[1] - 1) as usize].push((r[0] - 1) as usize);\\n        }\\n        let mut depth = vec![-1; n];\\n        (0..n)\\n            .map(|i| Solution::dfs(i, &mut depth, &graph, &time))\\n            .max()\\n            .unwrap()\\n    }\\n\\n    fn dfs(i: usize, depth: &mut [i32], graph: &[Vec<usize>], time: &[i32]) -> i32 {\\n        if depth[i] == -1 {\\n            depth[i] = graph[i]\\n                .iter()\\n                .map(|&next| Solution::dfs(next, depth, graph, time))\\n                .max()\\n                .unwrap_or(0)\\n                + time[i];\\n        }\\n        depth[i]\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1537834,
                "title": "python-bfs-heap-solution",
                "content": "Remove course when it is done and decrese incoming edge degrees of the neighbor. If neighbor becomes available, add finish time of the neighbor in the heap. Time complexity is `O(VlogV+E)`.\\n```\\nfrom heapq import heappush, heappop\\nfrom collections import defaultdict\\nclass Solution:\\n    def minimumTime(self, n: int, relations: List[List[int]], time: List[int]) -> int:\\n        self.incoming= defaultdict(int)\\n        self.outgoing = defaultdict(list)\\n        for prev,nxt in relations:\\n            self.outgoing[prev-1].append(nxt-1)\\n            self.incoming[nxt-1] +=1\\n        \\n        heap = []\\n        for k in range(n):\\n            if self.incoming[k]==0:\\n                heappush(heap, ( time[k],k))\\n        \\n        while heap:\\n            finish_time,idx = heappop(heap)\\n            for neigh in self.outgoing[idx]:\\n                self.incoming[neigh] -=1\\n                if self.incoming[neigh]==0:\\n                    heappush(heap, (finish_time+ time[neigh], neigh))\\n        return finish_time\\n```",
                "solutionTags": [
                    "Python3",
                    "Breadth-First Search",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nfrom heapq import heappush, heappop\\nfrom collections import defaultdict\\nclass Solution:\\n    def minimumTime(self, n: int, relations: List[List[int]], time: List[int]) -> int:\\n        self.incoming= defaultdict(int)\\n        self.outgoing = defaultdict(list)\\n        for prev,nxt in relations:\\n            self.outgoing[prev-1].append(nxt-1)\\n            self.incoming[nxt-1] +=1\\n        \\n        heap = []\\n        for k in range(n):\\n            if self.incoming[k]==0:\\n                heappush(heap, ( time[k],k))\\n        \\n        while heap:\\n            finish_time,idx = heappop(heap)\\n            for neigh in self.outgoing[idx]:\\n                self.incoming[neigh] -=1\\n                if self.incoming[neigh]==0:\\n                    heappush(heap, (finish_time+ time[neigh], neigh))\\n        return finish_time\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1537730,
                "title": "c-solution-using-bfs-similar-to-lc-1857",
                "content": "```\\nclass Solution {\\npublic:\\n    int minimumTime(int n, vector<vector<int>>& relations, vector<int>& time) \\n    {\\n        // time.insert(time.begin(),0);\\n        vector<int>dp[n+100];\\n        vector<int>ind(n,0),dis(n,0);\\n        for(auto it:relations)\\n        {\\n            it[0]--;\\n            it[1]--;\\n            dp[it[0]].push_back(it[1]);\\n            ind[it[1]]++;\\n        }\\n        queue<int>q;\\n        int ans=0;\\n        for(int i=0;i<n;i++)\\n        {\\n            if(ind[i]==0)\\n            {\\n                q.push(i);\\n                dis[i]=time[i];\\n                ans=max(ans,dis[i]);\\n            }\\n        }\\n        while(q.size())\\n        {\\n            auto temp=q.front();\\n            q.pop();\\n            for(auto it:dp[temp])\\n            {\\n                dis[it]=max(dis[it],dis[temp]+time[it]);\\n                ans=max(ans,dis[it]);\\n                if(--ind[it]==0)\\n                {\\n                    q.push(it);\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n# };\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Breadth-First Search",
                    "Topological Sort"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumTime(int n, vector<vector<int>>& relations, vector<int>& time) \\n    {\\n        // time.insert(time.begin(),0);\\n        vector<int>dp[n+100];\\n        vector<int>ind(n,0),dis(n,0);\\n        for(auto it:relations)\\n        {\\n            it[0]--;\\n            it[1]--;\\n            dp[it[0]].push_back(it[1]);\\n            ind[it[1]]++;\\n        }\\n        queue<int>q;\\n        int ans=0;\\n        for(int i=0;i<n;i++)\\n        {\\n            if(ind[i]==0)\\n            {\\n                q.push(i);\\n                dis[i]=time[i];\\n                ans=max(ans,dis[i]);\\n            }\\n        }\\n        while(q.size())\\n        {\\n            auto temp=q.front();\\n            q.pop();\\n            for(auto it:dp[temp])\\n            {\\n                dis[it]=max(dis[it],dis[temp]+time[it]);\\n                ans=max(ans,dis[it]);\\n                if(--ind[it]==0)\\n                {\\n                    q.push(it);\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n# };\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1537694,
                "title": "c-detailed-explanation-topological-sorting-dynamic-programming",
                "content": "**Intuition**\\n\\nThere is at least one path of courses (for eg. course F -> course B -> course C -> course D could take 15 months) that will take the maximum amount of time. All other courses will be less than or equal to this. For each course, lets find the length of the path (and then just find the maximum among all such paths)\\n\\nTopological sorting and a simplified version of dynamic programming. Basically, we first take all courses that have no dependencies, and calculate their durations (we \"remember\" this value in an array). Then we take the next set of dependents, find the maximum time of each of their \\'parents\\' (which has already been pre-computed) and add to each of their times, etc. until we exhaust all courses.\\n\\n**Implementation**\\n\\n* Build an adjacency matrix (directed graph, so only 1 way). The dependent is the child node of the parent. so an input of [child, parent] corresponds to adj[parent] = child.\\n* Count outgoing degrees for every vertex (1 directed edge per relation)\\n* Build a queue with all vertices that have 0 outgoing degree\\n* Examine each vertex in the queue, and calculate its max value so far (i.e. its own time + maximum time of any of its parents). Store this.\\n* For each edge incoming into that vertex, reduce the degree of the outbound vertex. If that degree becomes 0, add it to the queue.\\n* Continue until queue is exhausted and all paths have been processed. The longest path is the answer.\\n\\n\\n```\\n#define ll long long\\n\\nclass Solution {\\npublic:\\n    int minimumTime(int n, vector<vector<int>>& relations, vector<int>& time) {\\n        vector<vector<int>> adj(n);\\n        vector<int> deg(n, 0);\\n        vector<int> ret(n, 0);\\n        for (auto &r : relations) {\\n            int u = r[0] - 1, p = r[1] - 1;\\n            adj[p].push_back(u);\\n            deg[u]++;\\n        }\\n        queue<int> q;\\n        for (int i = 0; i < deg.size(); i++) {\\n            if (deg[i] == 0) {\\n                q.push(i);\\n            }\\n        }\\n        while (!q.empty()) {\\n            int mx = 0;\\n            queue<int> nq;\\n            while (!q.empty()) {\\n                auto u = q.front(); q.pop();\\n                ret[u] += time[u];\\n                mx = max(mx, time[u]);\\n                for (auto &v : adj[u]) {\\n                    deg[v]--;\\n                    if (deg[v] == 0) {\\n                        nq.push(v);\\n                    }\\n                    ret[v] = max(ret[v], ret[u]);                    \\n                }\\n            }\\n            swap(q, nq);\\n        }\\n        return *max_element(ret.begin(), ret.end());\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Topological Sort"
                ],
                "code": "```\\n#define ll long long\\n\\nclass Solution {\\npublic:\\n    int minimumTime(int n, vector<vector<int>>& relations, vector<int>& time) {\\n        vector<vector<int>> adj(n);\\n        vector<int> deg(n, 0);\\n        vector<int> ret(n, 0);\\n        for (auto &r : relations) {\\n            int u = r[0] - 1, p = r[1] - 1;\\n            adj[p].push_back(u);\\n            deg[u]++;\\n        }\\n        queue<int> q;\\n        for (int i = 0; i < deg.size(); i++) {\\n            if (deg[i] == 0) {\\n                q.push(i);\\n            }\\n        }\\n        while (!q.empty()) {\\n            int mx = 0;\\n            queue<int> nq;\\n            while (!q.empty()) {\\n                auto u = q.front(); q.pop();\\n                ret[u] += time[u];\\n                mx = max(mx, time[u]);\\n                for (auto &v : adj[u]) {\\n                    deg[v]--;\\n                    if (deg[v] == 0) {\\n                        nq.push(v);\\n                    }\\n                    ret[v] = max(ret[v], ret[u]);                    \\n                }\\n            }\\n            swap(q, nq);\\n        }\\n        return *max_element(ret.begin(), ret.end());\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1537684,
                "title": "java-dfs-memo",
                "content": "```\\nclass Solution {\\n    int[][]relations;\\n    int[]time;\\n    int[]cache;\\n    Map<Integer, List<Integer>>adj=new HashMap<>();\\n    public int minimumTime(int n, int[][] relations, int[] time) {\\n        this.relations=relations;\\n        this.time=time;\\n        cache=new int[time.length+1];\\n        int max=0;\\n        for(int i=0;i<relations.length;i++){\\n            int next=relations[i][1];\\n            int prev=relations[i][0];\\n            List<Integer> adjlist=adj.computeIfAbsent(next, k->new ArrayList<>());\\n            adjlist.add(prev);\\n            \\n        }\\n        for(int i=0;i<time.length;i++){\\n            int t = cache[i+1]>0?cache[i+1]:calc(i+1);\\n            if(t>max)max=t;\\n        }\\n        return max;\\n    }\\n    int calc(int pos){\\n        if(cache[pos]>0)return cache[pos];\\n        int max=0;\\n        List<Integer>prevs=adj.get(pos);\\n        if(prevs!=null)\\n        for(Integer prev:prevs){\\n            int t = cache[prev]>0?cache[prev]:calc(prev);\\n            if(t>max)max=t;\\n        }\\n        max+=time[pos-1];\\n        cache[pos]=max;\\n        return max;\\n    }\\n}\\n```\\nwas getting TLE in the contest, but solved it now with `adj` map (that is map for incomming nodes)",
                "solutionTags": [
                    "Java",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\n    int[][]relations;\\n    int[]time;\\n    int[]cache;\\n    Map<Integer, List<Integer>>adj=new HashMap<>();\\n    public int minimumTime(int n, int[][] relations, int[] time) {\\n        this.relations=relations;\\n        this.time=time;\\n        cache=new int[time.length+1];\\n        int max=0;\\n        for(int i=0;i<relations.length;i++){\\n            int next=relations[i][1];\\n            int prev=relations[i][0];\\n            List<Integer> adjlist=adj.computeIfAbsent(next, k->new ArrayList<>());\\n            adjlist.add(prev);\\n            \\n        }\\n        for(int i=0;i<time.length;i++){\\n            int t = cache[i+1]>0?cache[i+1]:calc(i+1);\\n            if(t>max)max=t;\\n        }\\n        return max;\\n    }\\n    int calc(int pos){\\n        if(cache[pos]>0)return cache[pos];\\n        int max=0;\\n        List<Integer>prevs=adj.get(pos);\\n        if(prevs!=null)\\n        for(Integer prev:prevs){\\n            int t = cache[prev]>0?cache[prev]:calc(prev);\\n            if(t>max)max=t;\\n        }\\n        max+=time[pos-1];\\n        cache[pos]=max;\\n        return max;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1537681,
                "title": "java-clean",
                "content": "Eveything is similar to courseSchedule https://leetcode.com/problems/course-schedule/ \\nbut now we need to wait for the last prerequisite to finish before we can start, so when we do a topological sort, we can track all its parent, find the last time then start traverse.\\nIn the end we use dp array to show how many month we need to finish ith class\\n```\\n    public int minimumTime(int n, int[][] dependencies, int[] time) {\\n        List<Integer>[] graph = new ArrayList[n];\\n        for (int i = 0; i < n; i++) graph[i] = new ArrayList<>();\\n        int[] indegree = new int[n];\\n        for (int[] dependency : dependencies) {\\n            graph[dependency[0] - 1].add(dependency[1] - 1);\\n            indegree[dependency[1] - 1]++;\\n        }\\n        Queue<Integer> q = new LinkedList<>();\\n        for (int i = 0; i < n; i++) if (indegree[i] == 0) q.add(i);\\n        int[] dp = new int[n];\\n        while (!q.isEmpty()) {\\n            int size = q.size();\\n            for (int i = 0; i < size; i++) {\\n                int cur = q.poll();\\n                dp[cur] += time[cur];\\n                for (int nei : graph[cur]) {\\n                    if (--indegree[nei] == 0) q.add(nei);\\n                    dp[nei] = Math.max(dp[cur], dp[nei]);\\n                }\\n            }\\n        }\\n        int max = 0;\\n        for (int d : dp) max = Math.max(max, d);\\n        return max;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    public int minimumTime(int n, int[][] dependencies, int[] time) {\\n        List<Integer>[] graph = new ArrayList[n];\\n        for (int i = 0; i < n; i++) graph[i] = new ArrayList<>();\\n        int[] indegree = new int[n];\\n        for (int[] dependency : dependencies) {\\n            graph[dependency[0] - 1].add(dependency[1] - 1);\\n            indegree[dependency[1] - 1]++;\\n        }\\n        Queue<Integer> q = new LinkedList<>();\\n        for (int i = 0; i < n; i++) if (indegree[i] == 0) q.add(i);\\n        int[] dp = new int[n];\\n        while (!q.isEmpty()) {\\n            int size = q.size();\\n            for (int i = 0; i < size; i++) {\\n                int cur = q.poll();\\n                dp[cur] += time[cur];\\n                for (int nei : graph[cur]) {\\n                    if (--indegree[nei] == 0) q.add(nei);\\n                    dp[nei] = Math.max(dp[cur], dp[nei]);\\n                }\\n            }\\n        }\\n        int max = 0;\\n        for (int d : dp) max = Math.max(max, d);\\n        return max;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1537646,
                "title": "any-help-figuring-out-tle-with-this-dfs-approach",
                "content": "I received TLE with below, any pointers how this could be optimized?\\n\\n```\\nclass Solution {\\npublic:\\n    int maxAns = 0;\\n    void dfs(vector<vector<int>> &g, int cur, vector<int> &time, vector<int> &maxTime) {\\n        for (auto neigh : g[cur]) {\\n            maxTime[neigh-1] = max(maxTime[cur-1] + time[neigh-1], maxTime[neigh-1]);\\n            // cout << neigh << \" \" << time[neigh-1] << \" \" << maxTime[neigh-1] << \"\\\\n\";\\n            maxAns = max(maxAns, maxTime[neigh-1]);\\n            dfs(g, neigh, time, maxTime);\\n        }\\n    }\\n    \\n    int minimumTime(int n, vector<vector<int>>& relations, vector<int>& time) {\\n        vector<int> maxTime(time.begin(), time.end());\\n        vector<int> indegree(n+1, 0);\\n        vector<vector<int>> graph(n+1);\\n        maxAns = 0;\\n        for (auto r : relations) {\\n            int x = r[0]; int y = r[1];\\n            graph[x].push_back(y);\\n            indegree[y]++;\\n        }\\n        // cout << \"g creaed \\\\n\";\\n        for (int i = 1; i <= n; i++) {\\n            maxAns = max(maxAns, time[i-1]);\\n            if (indegree[i] == 0) {\\n                // cout << \"starting dfs at \" << i << \" \\\\n\";\\n                // start dfs\\n                dfs(graph, i, time, maxTime);\\n            }\\n        }\\n        return maxAns;\\n    }\\n};\\n\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxAns = 0;\\n    void dfs(vector<vector<int>> &g, int cur, vector<int> &time, vector<int> &maxTime) {\\n        for (auto neigh : g[cur]) {\\n            maxTime[neigh-1] = max(maxTime[cur-1] + time[neigh-1], maxTime[neigh-1]);\\n            // cout << neigh << \" \" << time[neigh-1] << \" \" << maxTime[neigh-1] << \"\\\\n\";\\n            maxAns = max(maxAns, maxTime[neigh-1]);\\n            dfs(g, neigh, time, maxTime);\\n        }\\n    }\\n    \\n    int minimumTime(int n, vector<vector<int>>& relations, vector<int>& time) {\\n        vector<int> maxTime(time.begin(), time.end());\\n        vector<int> indegree(n+1, 0);\\n        vector<vector<int>> graph(n+1);\\n        maxAns = 0;\\n        for (auto r : relations) {\\n            int x = r[0]; int y = r[1];\\n            graph[x].push_back(y);\\n            indegree[y]++;\\n        }\\n        // cout << \"g creaed \\\\n\";\\n        for (int i = 1; i <= n; i++) {\\n            maxAns = max(maxAns, time[i-1]);\\n            if (indegree[i] == 0) {\\n                // cout << \"starting dfs at \" << i << \" \\\\n\";\\n                // start dfs\\n                dfs(graph, i, time, maxTime);\\n            }\\n        }\\n        return maxAns;\\n    }\\n};\\n\\n```",
                "codeTag": "C++"
            },
            {
                "id": 1537635,
                "title": "python-solution-with-explanation-and-example",
                "content": "First time posting a solution, This is my attempt at solving this question during the weekly contest.\\n\\nThis question wants us to find the total time that is needed to complete every course, and for certain courses, there are pre-requisites that would need to be done first. \\n\\nThe time of completion of a course for a course **with pre-requisites** is the max completion time out of all the pre-requisite + the time to complete this course. \\nThe time of completion of a course **without pre-requisites** is going to be the required time to take the course from the given list.\\n\\nWe want to find out which course will have the largest time of completion and that will be the minimum number of months needed to complete all courses since courses that have pre-requisites filled or no pre-requisites can be taken at the same time.\\n\\nFor example:\\nWe have case \\n![image](https://assets.leetcode.com/users/images/1fd89541-0049-4d0b-b1b4-5762c596856f_1635048489.8594978.png)\\n\\nThe pre-requisite for course #3 are course #1 with 3 months and course #2 with 2 months.\\nWe want to record the time of compleition for course #1, #2 first.\\nSince they all have no pre-requisite, their time of completion will be\\n```\\nCourse 1: 3\\nCourse 2: 2\\n```\\nNow we can calculate the time needed to complete for course #3, finding the max completion time of its pre-requisite, which is course 1 at 3 months, we will add the required time to complete course #3 to the 3 months from course #1, we now have completeion time of course #3 of 8 months.\\nWe will go through all the courses from 1 to n, adding the max pre-requisite time of completion to its own required compleition time. If the pre-requisite has not been recorded, we will call the function to fill in time for the pre-requisite first. For example, if we call the function on course 3 first, it will check if course 1 and course 2 time of completeion has been stored so far, if not, it will go through them first and record it, and then calculate time for course 3 and store it.\\n\\n**Code**:\\n```\\nclass Solution:\\n    def minimumTime(self, n: int, relations: List[List[int]], time: List[int]) -> int:\\n        self.prereq = defaultdict(list) # The dictionary that stores the pre-requisite of courses\\n        self.comp = {} # The dictionary that stores the completion time of each course\\n\\t\\t\\n\\t\\t# Loop through relations and add pre-requisite to the dictionary\\n        for i in relations:\\n            self.prereq[i[1]].append(i[0])\\n            \\n        def filltime(course):\\n            if course not in self.comp: # If the called course does not have its time of completion calculated yet\\n                if course not in self.prereq: # If the course does not have pre-requisite\\n                    self.comp[course] = time[course-1] \\n\\t\\t\\t\\t\\t# The course will have time of completion as its required time to complete\\n                else: # If the course has pre-reqs\\n                    maxt = 0 \\n                    for pre in self.prereq[course]: # Checking through its pre-reqs\\n                        if pre not in self.comp: # If the pre-req doesn\\'t have time of completion sotred\\n                            filltime(pre) # Use this function to fill it in\\n                        maxt = max(self.comp[pre], maxt) \\n                    self.comp[course] = maxt + time[course-1] # The time of completion stored\\n                \\n        for i in range(1, n+1): # Fill time of completion for all courses\\n            filltime(i)\\n        maxt = 0\\n        for i in self.comp:\\n            maxt = max(self.comp[i], maxt) # Record the max required time\\n        return maxt\\n```\\n",
                "solutionTags": [
                    "Dynamic Programming",
                    "Depth-First Search",
                    "Memoization"
                ],
                "code": "```\\nCourse 1: 3\\nCourse 2: 2\\n```\n```\\nclass Solution:\\n    def minimumTime(self, n: int, relations: List[List[int]], time: List[int]) -> int:\\n        self.prereq = defaultdict(list) # The dictionary that stores the pre-requisite of courses\\n        self.comp = {} # The dictionary that stores the completion time of each course\\n\\t\\t\\n\\t\\t# Loop through relations and add pre-requisite to the dictionary\\n        for i in relations:\\n            self.prereq[i[1]].append(i[0])\\n            \\n        def filltime(course):\\n            if course not in self.comp: # If the called course does not have its time of completion calculated yet\\n                if course not in self.prereq: # If the course does not have pre-requisite\\n                    self.comp[course] = time[course-1] \\n\\t\\t\\t\\t\\t# The course will have time of completion as its required time to complete\\n                else: # If the course has pre-reqs\\n                    maxt = 0 \\n                    for pre in self.prereq[course]: # Checking through its pre-reqs\\n                        if pre not in self.comp: # If the pre-req doesn\\'t have time of completion sotred\\n                            filltime(pre) # Use this function to fill it in\\n                        maxt = max(self.comp[pre], maxt) \\n                    self.comp[course] = maxt + time[course-1] # The time of completion stored\\n                \\n        for i in range(1, n+1): # Fill time of completion for all courses\\n            filltime(i)\\n        maxt = 0\\n        for i in self.comp:\\n            maxt = max(self.comp[i], maxt) # Record the max required time\\n        return maxt\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1537632,
                "title": "java-simple-dfs-solution-with-detailed-comments",
                "content": "```\\n/*\\n  The idea is to find the completion time for each course. The final answer will be the maximum completion time of all the courses.\\n  Completion time of current course = Maximum completion time of all courses on which current course depends + completion time of current course. \\n*/\\nclass Solution {\\n    public int minimumTime(int n, int[][] relations, int[] time) {\\n        \\n        // creating the DAG\\n        List<Integer> list[]=new ArrayList[n+1];\\n        for(int i=0;i<=n;i++)\\n            list[i]=new ArrayList<>();\\n        for(int []ar:relations)\\n            list[ar[1]].add(ar[0]);\\n        \\n        long []comp=new long[n+1]; // stores completion time for each course.\\n        \\n        Arrays.fill(comp,-1l);// initialisation \\n        \\n        long ans=0l;\\n        for(int i=1;i<=n;i++){\\n            if(comp[i]==-1){ // if the node is not explored, explore the node.\\n                dfs(i,list,time,comp);\\n            }\\n            ans=Math.max(ans,comp[i]); // final completion time will be the maximum completion time of all the course.\\n        }        \\n        return (int)ans;\\n    }\\n    \\n    // returns the completion time of the course u.\\n    public long dfs(int u, List<Integer> list[], int []time, long []comp){\\n        long val=0l;\\n        for(int v:list[u]){\\n            \\n            if(comp[v]==-1){ // explore if the node is not explored.\\n                dfs(v,list,time,comp);\\n            }\\n            \\n            val=Math.max(val,comp[v]); // maximum completion time of all the courses which needs to be completed before course u.\\n        }\\n        \\n        comp[u]=val+time[u-1]; // time to complete course u.\\n        \\n        return comp[u];\\n    }\\n}\\n/*\\nT = O(V+E)\\nS = O(V+E)\\n*/\\n```\\nPlease upvote if you find this helpful.",
                "solutionTags": [],
                "code": "```\\n/*\\n  The idea is to find the completion time for each course. The final answer will be the maximum completion time of all the courses.\\n  Completion time of current course = Maximum completion time of all courses on which current course depends + completion time of current course. \\n*/\\nclass Solution {\\n    public int minimumTime(int n, int[][] relations, int[] time) {\\n        \\n        // creating the DAG\\n        List<Integer> list[]=new ArrayList[n+1];\\n        for(int i=0;i<=n;i++)\\n            list[i]=new ArrayList<>();\\n        for(int []ar:relations)\\n            list[ar[1]].add(ar[0]);\\n        \\n        long []comp=new long[n+1]; // stores completion time for each course.\\n        \\n        Arrays.fill(comp,-1l);// initialisation \\n        \\n        long ans=0l;\\n        for(int i=1;i<=n;i++){\\n            if(comp[i]==-1){ // if the node is not explored, explore the node.\\n                dfs(i,list,time,comp);\\n            }\\n            ans=Math.max(ans,comp[i]); // final completion time will be the maximum completion time of all the course.\\n        }        \\n        return (int)ans;\\n    }\\n    \\n    // returns the completion time of the course u.\\n    public long dfs(int u, List<Integer> list[], int []time, long []comp){\\n        long val=0l;\\n        for(int v:list[u]){\\n            \\n            if(comp[v]==-1){ // explore if the node is not explored.\\n                dfs(v,list,time,comp);\\n            }\\n            \\n            val=Math.max(val,comp[v]); // maximum completion time of all the courses which needs to be completed before course u.\\n        }\\n        \\n        comp[u]=val+time[u-1]; // time to complete course u.\\n        \\n        return comp[u];\\n    }\\n}\\n/*\\nT = O(V+E)\\nS = O(V+E)\\n*/\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1537628,
                "title": "c-dfs-memo-hashmap",
                "content": "```\\npublic class Solution {\\n    public int MinimumTime(int n, int[][] relations, int[] time) {\\n        Dictionary<int, List<int>> dic = new Dictionary<int, List<int>>();\\n        bool[] visited = new bool[time.Length];\\n        \\n        int res = 0;\\n        for(int i = 0; i < time.Length; i++)\\n            dic.TryAdd(i+1, new List<int>());\\n        foreach(int[] arr in relations)\\n        {     \\n            dic[arr[1]].Add(arr[0]);            \\n        }\\n        for(int i = 0; i < n; i ++)\\n        {\\n            if(!visited[i])\\n            {\\n                res = Math.Max(res, helper(time,visited, i, ref dic));\\n            }\\n        }\\n        return res;\\n    }\\n    \\n    public int helper(int[] time,bool[] visited ,int index, ref Dictionary<int, List<int>> dic)\\n    {\\n    \\n        visited[index] = true;\\n        int max = 0;\\n        \\n        foreach(int pre in dic[index+1])\\n        {\\n            if(!visited[pre-1])\\n            {\\n                time[pre-1] = helper(time,visited, pre-1, ref dic);                 \\n            }    \\n            max = Math.Max(time[pre-1], max);\\n        }\\n        time[index] = max+time[index];\\n        \\n        return time[index];\\n    }\\n}",
                "solutionTags": [
                    "Depth-First Search"
                ],
                "code": "class Solution {\\n    public int MinimumTime(int n, int[][] relations, int[] time) {\\n        Dictionary<int, List<int>> dic = new Dictionary<int, List<int>>();\\n        bool[] visited = new bool[time.Length];\\n        \\n        int res = 0;\\n        for(int i = 0; i < time.Length; i++)\\n            dic.TryAdd(i+1, new List<int>());\\n        foreach(int[] arr in relations)\\n        {     \\n            dic[arr[1]].Add(arr[0]);            \\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1537534,
                "title": "simple-dfs-javascript-easy-explained-solution",
                "content": "```\\n/**\\n * @param {number} n\\n * @param {number[][]} relations\\n * @param {number[]} time\\n * @return {number}\\n */\\nvar minimumTime = function(n, relations, time) {\\n    /*\\n    Approach: We can create reverse edges for relation.\\n\\xA0 \\xA0 Then longest path(by weightage of time for each node) from the node will be the minimum time to finish that course(node)\\n\\xA0 \\xA0 Now we can use simple DFS to find the longest path for each node.\\n\\xA0 \\xA0 The node containing the longest path will be course to finish the last.We can also use memo to save the longest path from node, so when we reach to this node, we need not to calculate the longest path again.\\xA0\\n    */\\n    let edges={};\\n    for(let i=0;i<relations.length;i++){\\n        if(edges[relations[i][1]]===undefined){\\n            edges[relations[i][1]] = [];\\n        }\\n        edges[relations[i][1]].push(relations[i][0]);\\n    }\\n\\n    let max=0,timeRequired,memo={};\\n    for(let i=1;i<=n;i++){\\n        timeRequired = longestPath(i);\\n        max = Math.max(max,timeRequired);\\n    }\\n    return max;\\n     function longestPath(node){\\n         if(memo[node]!==undefined){\\n             return memo[node];\\n         }\\n        let len,max=0;\\n         if(edges[node]!==undefined){\\n             for(let i=0;i<edges[node].length;i++){\\n                 len = longestPath(edges[node][i]);\\n                 max = Math.max(max,len);\\n             }\\n         }\\n         memo[node] = time[node-1]+max;//use memo to save the longest path from node, so when we reach to this node, we need not to calculate the longest path again\\n         return memo[node];\\n    }\\n    \\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Depth-First Search"
                ],
                "code": "```\\n/**\\n * @param {number} n\\n * @param {number[][]} relations\\n * @param {number[]} time\\n * @return {number}\\n */\\nvar minimumTime = function(n, relations, time) {\\n    /*\\n    Approach: We can create reverse edges for relation.\\n\\xA0 \\xA0 Then longest path(by weightage of time for each node) from the node will be the minimum time to finish that course(node)\\n\\xA0 \\xA0 Now we can use simple DFS to find the longest path for each node.\\n\\xA0 \\xA0 The node containing the longest path will be course to finish the last.We can also use memo to save the longest path from node, so when we reach to this node, we need not to calculate the longest path again.\\xA0\\n    */\\n    let edges={};\\n    for(let i=0;i<relations.length;i++){\\n        if(edges[relations[i][1]]===undefined){\\n            edges[relations[i][1]] = [];\\n        }\\n        edges[relations[i][1]].push(relations[i][0]);\\n    }\\n\\n    let max=0,timeRequired,memo={};\\n    for(let i=1;i<=n;i++){\\n        timeRequired = longestPath(i);\\n        max = Math.max(max,timeRequired);\\n    }\\n    return max;\\n     function longestPath(node){\\n         if(memo[node]!==undefined){\\n             return memo[node];\\n         }\\n        let len,max=0;\\n         if(edges[node]!==undefined){\\n             for(let i=0;i<edges[node].length;i++){\\n                 len = longestPath(edges[node][i]);\\n                 max = Math.max(max,len);\\n             }\\n         }\\n         memo[node] = time[node-1]+max;//use memo to save the longest path from node, so when we reach to this node, we need not to calculate the longest path again\\n         return memo[node];\\n    }\\n    \\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4053543,
                "title": "java-solution-bfs-topological-sort",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int minimumTime(int n, int[][] relations, int[] time) {\\n        Map<Integer, List<Integer>> graph = new HashMap<>();\\n        for(int i = 1; i <= n; i++){\\n            graph.put(i, new ArrayList<>());\\n        }\\n        int[] indegree = new int[n + 1];\\n        for(int[] relation : relations){\\n            int current = relation[0];\\n            int next = relation[1];\\n            graph.get(current).add(next);\\n            indegree[next]++;\\n        }\\n        int month = 0;\\n        Queue<Integer> queue = new ArrayDeque<>();\\n        int[] currentTime = new int[n + 1];\\n        for(int i = 1; i <= n; i++){\\n            if(indegree[i] == 0){\\n                queue.offer(i);\\n                currentTime[i] = time[i - 1];\\n            }\\n        }\\n        while(!queue.isEmpty()){\\n            int size = queue.size();\\n            for(int i = 0; i < size; i++){\\n                int current = queue.poll();\\n                month = Math.max(month, currentTime[current]);\\n                List<Integer> neighbors = graph.get(current);\\n                if(neighbors != null && neighbors.size() != 0){\\n                    for(Integer nei : neighbors){\\n                        currentTime[nei] = Math.max(currentTime[nei], currentTime[current] + time[nei - 1]);\\n                        indegree[nei]--;\\n                        if(indegree[nei] == 0){\\n                            queue.offer(nei);\\n                        }\\n                    }                    \\n                }\\n            }\\n        }\\n        return month;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int minimumTime(int n, int[][] relations, int[] time) {\\n        Map<Integer, List<Integer>> graph = new HashMap<>();\\n        for(int i = 1; i <= n; i++){\\n            graph.put(i, new ArrayList<>());\\n        }\\n        int[] indegree = new int[n + 1];\\n        for(int[] relation : relations){\\n            int current = relation[0];\\n            int next = relation[1];\\n            graph.get(current).add(next);\\n            indegree[next]++;\\n        }\\n        int month = 0;\\n        Queue<Integer> queue = new ArrayDeque<>();\\n        int[] currentTime = new int[n + 1];\\n        for(int i = 1; i <= n; i++){\\n            if(indegree[i] == 0){\\n                queue.offer(i);\\n                currentTime[i] = time[i - 1];\\n            }\\n        }\\n        while(!queue.isEmpty()){\\n            int size = queue.size();\\n            for(int i = 0; i < size; i++){\\n                int current = queue.poll();\\n                month = Math.max(month, currentTime[current]);\\n                List<Integer> neighbors = graph.get(current);\\n                if(neighbors != null && neighbors.size() != 0){\\n                    for(Integer nei : neighbors){\\n                        currentTime[nei] = Math.max(currentTime[nei], currentTime[current] + time[nei - 1]);\\n                        indegree[nei]--;\\n                        if(indegree[nei] == 0){\\n                            queue.offer(nei);\\n                        }\\n                    }                    \\n                }\\n            }\\n        }\\n        return month;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4050678,
                "title": "solution-using-topo-sort",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minimumTime(int n, vector<vector<int>>& relations, vector<int>& time) {\\n        vector<vector<int>> adj(n);\\n        for(auto x:relations){\\n            adj[x[0]-1].push_back(x[1]-1);\\n        }\\n        vector<int> deg(n,0);\\n        for(int i=0;i<n;i++){\\n            for(auto x:adj[i]){\\n                deg[x]++;\\n            }\\n        }\\n       // int ans=0;\\n        vector<int> dist(n);\\n        queue<int> q;\\n        for(int i=0;i<n;i++){\\n            if(deg[i]==0) \\n            {\\n                q.push(i);\\n                dist[i]=time[i];\\n            }\\n        }\\n        while(!q.empty()){\\n            int node=q.front();\\n            q.pop();\\n            for(auto x:adj[node]){\\n                dist[x]=max(dist[x],dist[node]+time[x]);\\n                deg[x]--;\\n                if(deg[x]==0) q.push(x);\\n            }\\n        }\\n        int ans=INT_MIN;\\n        for(int i=0;i<n;i++){\\n            ans=max(ans,dist[i]);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Dynamic Programming",
                    "Graph",
                    "Topological Sort"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumTime(int n, vector<vector<int>>& relations, vector<int>& time) {\\n        vector<vector<int>> adj(n);\\n        for(auto x:relations){\\n            adj[x[0]-1].push_back(x[1]-1);\\n        }\\n        vector<int> deg(n,0);\\n        for(int i=0;i<n;i++){\\n            for(auto x:adj[i]){\\n                deg[x]++;\\n            }\\n        }\\n       // int ans=0;\\n        vector<int> dist(n);\\n        queue<int> q;\\n        for(int i=0;i<n;i++){\\n            if(deg[i]==0) \\n            {\\n                q.push(i);\\n                dist[i]=time[i];\\n            }\\n        }\\n        while(!q.empty()){\\n            int node=q.front();\\n            q.pop();\\n            for(auto x:adj[node]){\\n                dist[x]=max(dist[x],dist[node]+time[x]);\\n                deg[x]--;\\n                if(deg[x]==0) q.push(x);\\n            }\\n        }\\n        int ans=INT_MIN;\\n        for(int i=0;i<n;i++){\\n            ans=max(ans,dist[i]);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4038711,
                "title": "simple-python-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nTopological sort with collecting the max times\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\nPeform a topological sort\\nLook at the times returned by the pre-requsite (pick max of all the pre-req)\\nAdd the current node\\'s time and pass it up\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n+e) \\nn - number of courses\\ne - edges\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(n+e) \\nn - number of courses\\ne - edges\\n\\n# Code\\n```\\nclass Solution:\\n    def minimumTime(self, n: int, relations: List[List[int]], time: List[int]) -> int:\\n        def getTime(x):\\n            return time[x-1]\\n        \\n        # build adjaceny list representation\\n        graph = defaultdict(list)\\n        for (prereq, course) in relations:\\n            graph[course].append(prereq)\\n        \\n        visited = dict()\\n        def rec(course):\\n            if course in visited:\\n                return visited[course]\\n\\n            visited[course] = float(\\'inf\\')\\n            maxTime = 0\\n            for preReq in graph[course]:\\n                maxTime = max(maxTime, rec(preReq))\\n\\n            visited[course] = maxTime + getTime(course)\\n            return visited[course]\\n        \\n        // Perform topological sort\\n        maxVal = 0\\n        for i in range(n+1):\\n            maxVal = max(maxVal, rec(i))\\n        \\n        if maxVal == float(\\'inf\\'):\\n            return 0\\n        return maxVal\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minimumTime(self, n: int, relations: List[List[int]], time: List[int]) -> int:\\n        def getTime(x):\\n            return time[x-1]\\n        \\n        # build adjaceny list representation\\n        graph = defaultdict(list)\\n        for (prereq, course) in relations:\\n            graph[course].append(prereq)\\n        \\n        visited = dict()\\n        def rec(course):\\n            if course in visited:\\n                return visited[course]\\n\\n            visited[course] = float(\\'inf\\')\\n            maxTime = 0\\n            for preReq in graph[course]:\\n                maxTime = max(maxTime, rec(preReq))\\n\\n            visited[course] = maxTime + getTime(course)\\n            return visited[course]\\n        \\n        // Perform topological sort\\n        maxVal = 0\\n        for i in range(n+1):\\n            maxVal = max(maxVal, rec(i))\\n        \\n        if maxVal == float(\\'inf\\'):\\n            return 0\\n        return maxVal\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3991767,
                "title": "parallel-courses-iii",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nfrom collections import deque\\nclass Solution:\\n    def minimumTime(self, n: int, relations: List[List[int]], time: List[int]) -> int:\\n        ind=[0]*(n+1)\\n        adj=[[] for i in range(n+1)]\\n        for i in relations:\\n            adj[i[0]].append(i[1])\\n            ind[i[1]]+=1\\n        queue=deque()\\n        times=[0]*(n)\\n        for i in range(1,n+1):\\n            if ind[i]==0:\\n                times[i-1]=0\\n                queue.append(i)\\n        ans=0\\n        while queue:\\n           nod=queue.popleft()\\n           for i in adj[nod]:\\n               ind[i]-=1\\n               times[i-1]=max(times[i-1],times[nod-1]+time[nod-1])\\n               if ind[i]==0:\\n                   queue.append(i)\\n           ans=max(ans,times[nod-1]+time[nod-1])        \\n        return  ans          \\n```",
                "solutionTags": [
                    "Python3",
                    "Breadth-First Search",
                    "Queue"
                ],
                "code": "```\\nfrom collections import deque\\nclass Solution:\\n    def minimumTime(self, n: int, relations: List[List[int]], time: List[int]) -> int:\\n        ind=[0]*(n+1)\\n        adj=[[] for i in range(n+1)]\\n        for i in relations:\\n            adj[i[0]].append(i[1])\\n            ind[i[1]]+=1\\n        queue=deque()\\n        times=[0]*(n)\\n        for i in range(1,n+1):\\n            if ind[i]==0:\\n                times[i-1]=0\\n                queue.append(i)\\n        ans=0\\n        while queue:\\n           nod=queue.popleft()\\n           for i in adj[nod]:\\n               ind[i]-=1\\n               times[i-1]=max(times[i-1],times[nod-1]+time[nod-1])\\n               if ind[i]==0:\\n                   queue.append(i)\\n           ans=max(ans,times[nod-1]+time[nod-1])        \\n        return  ans          \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3957889,
                "title": "python-simulation",
                "content": "# Intuition\\nThis is an example of a problem with very few constraints - being able to take *as many courses as you would like* is not a very stringent condition. That said, as the bounds for the parameters are relatively large for such a graph theoretic problem, we are likely going to be unable to do something like iterate through all possible times.\\n\\n# Approach\\nIf we are the student in this case, what would the \"optimal\" strategy be? Well, if you think about it a little bit, the optimal strategy is just to take every single possible course that you can, as early as you can. Because there is no limit on the number of courses we can take, certainly the ideal solution will arise just from taking every course possible at any given time. \\n\\nHow do we simulate this? With a heap! Inside a heap, we store tuples of the following form\\n\\n```\\n(time that we will finish course i, i)\\n```\\nFor some course `j` that doesn\\'t have any pre-requisites, the time that we will finish it will be `time[j-1]` (we take it immediately upon arriving at school). For any other course `k`, the time that we will finish this course will be `time[k-1] + the time that we finished the last pre-requisite for this course`. And thus we simulate this with a heap. Each heap pop represents the completion of a course (as we pop the minimum value, we will always get the most recent course completion). Upon each \"course completion,\" we iterate through the `prereqs_for` dictionary (which maps courses to the list of the courses that theey are a pre-requisite for). For each of these courses, we decrement the value of `num_prereqs` for that course (which maps courses to number of courses we need to take to take it). If this value is zero, then we are able to take the course! And so we add it to the queue.\\n\\n# Complexity\\n- Time complexity:\\n$O(nlog(n))$\\n\\n- Space complexity:\\n- $O(n)$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nimport heapq\\nfrom collections import defaultdict\\nclass Solution:\\n    def minimumTime(self, n: int, relations: List[List[int]], time: List[int]) -> int:\\n        num_prereqs = defaultdict(int)\\n        prereqs_for = defaultdict(list)\\n\\n        for pre_req, course in relations:\\n            num_prereqs[course] += 1\\n            prereqs_for[pre_req].append(course)\\n        \\n        currently_taking = []\\n        for course in range(1,n+1):\\n            if num_prereqs[course] == 0:\\n                heapq.heappush(currently_taking, (time[course-1], course))\\n        curr_time = 0\\n        while currently_taking:\\n            curr_time, finished_course = heapq.heappop(currently_taking)\\n            for course in prereqs_for[finished_course]:\\n                num_prereqs[course] -= 1\\n                if num_prereqs[course] == 0:\\n                    heapq.heappush(currently_taking, (curr_time + time[course-1], course))\\n\\n        return curr_time\\n```\\n\\nAlso note that an $O(n)$ solution is possible with dp, where \\n```\\ndp(i) = time to finish course_i\\n = time[i-1] + max([dp(k) for k in pre_requisites(i)])\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\n(time that we will finish course i, i)\\n```\n```\\nimport heapq\\nfrom collections import defaultdict\\nclass Solution:\\n    def minimumTime(self, n: int, relations: List[List[int]], time: List[int]) -> int:\\n        num_prereqs = defaultdict(int)\\n        prereqs_for = defaultdict(list)\\n\\n        for pre_req, course in relations:\\n            num_prereqs[course] += 1\\n            prereqs_for[pre_req].append(course)\\n        \\n        currently_taking = []\\n        for course in range(1,n+1):\\n            if num_prereqs[course] == 0:\\n                heapq.heappush(currently_taking, (time[course-1], course))\\n        curr_time = 0\\n        while currently_taking:\\n            curr_time, finished_course = heapq.heappop(currently_taking)\\n            for course in prereqs_for[finished_course]:\\n                num_prereqs[course] -= 1\\n                if num_prereqs[course] == 0:\\n                    heapq.heappush(currently_taking, (curr_time + time[course-1], course))\\n\\n        return curr_time\\n```\n```\\ndp(i) = time to finish course_i\\n = time[i-1] + max([dp(k) for k in pre_requisites(i)])\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3952114,
                "title": "java-build-prerequisites-graph-reversely-and-dp-with-graph-35-lines",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n\\n    int[] memo; \\n\\n    public int minimumTime(int n, int[][] relations, int[] time) {\\n        int cost = 0; \\n        Map<Integer, List<Integer>> graph = new HashMap(); \\n        buildGraph(relations, graph);\\n\\n        memo = new int[n];\\n        Arrays.fill(memo, -1);\\n\\n        for (int i = 1; i <= n; i++) {\\n            cost = Math.max(cost, dp(graph, time, i));\\n        }\\n\\n        return cost;\\n    }\\n\\n    public int dp(Map<Integer, List<Integer>> graph, int[] time, int course) {\\n        if (memo[course - 1] != -1) {\\n            return memo[course -1];\\n        }\\n        int curCourseCost = time[course-1];\\n\\n        int maxCost = curCourseCost; \\n        \\n        List<Integer> prerequisites = graph.getOrDefault(course, Collections.EMPTY_LIST); \\n\\n        if (prerequisites.size() == 0) {\\n            return curCourseCost; \\n        }\\n        for (Integer pre : prerequisites) {\\n            maxCost = Math.max(maxCost, curCourseCost + dp(graph, time, pre)); \\n        }\\n        memo[course -1] = maxCost;\\n        return maxCost;\\n    }\\n\\n    public void buildGraph(int[][] relations, Map<Integer, List<Integer>> graph) {\\n        for (int[] edge : relations) {\\n            graph.computeIfAbsent(edge[1], k -> new ArrayList()).add(edge[0]);\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming",
                    "Graph"
                ],
                "code": "```\\nclass Solution {\\n\\n    int[] memo; \\n\\n    public int minimumTime(int n, int[][] relations, int[] time) {\\n        int cost = 0; \\n        Map<Integer, List<Integer>> graph = new HashMap(); \\n        buildGraph(relations, graph);\\n\\n        memo = new int[n];\\n        Arrays.fill(memo, -1);\\n\\n        for (int i = 1; i <= n; i++) {\\n            cost = Math.max(cost, dp(graph, time, i));\\n        }\\n\\n        return cost;\\n    }\\n\\n    public int dp(Map<Integer, List<Integer>> graph, int[] time, int course) {\\n        if (memo[course - 1] != -1) {\\n            return memo[course -1];\\n        }\\n        int curCourseCost = time[course-1];\\n\\n        int maxCost = curCourseCost; \\n        \\n        List<Integer> prerequisites = graph.getOrDefault(course, Collections.EMPTY_LIST); \\n\\n        if (prerequisites.size() == 0) {\\n            return curCourseCost; \\n        }\\n        for (Integer pre : prerequisites) {\\n            maxCost = Math.max(maxCost, curCourseCost + dp(graph, time, pre)); \\n        }\\n        memo[course -1] = maxCost;\\n        return maxCost;\\n    }\\n\\n    public void buildGraph(int[][] relations, Map<Integer, List<Integer>> graph) {\\n        for (int[] edge : relations) {\\n            graph.computeIfAbsent(edge[1], k -> new ArrayList()).add(edge[0]);\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3942072,
                "title": "java-clean-dynamic-programming-dfs-solution",
                "content": "```\\nimport java.util.List;\\nimport java.util.Map;\\nimport java.util.stream.IntStream;\\n\\nimport static java.util.Arrays.fill;\\nimport static java.util.Arrays.stream;\\nimport static java.util.Collections.emptyList;\\nimport static java.util.stream.Collectors.groupingBy;\\nimport static java.util.stream.Collectors.mapping;\\nimport static java.util.stream.Collectors.toList;\\n\\n\\nclass Solution {\\n    private Map<Integer, List<Integer>> graph;\\n    private int[] dp, time;\\n\\n    public int minimumTime(int n, int[][] relations, int[] time) {\\n        this.dp = new int[n];\\n        this.time = time;\\n\\n        fill(dp, -1);\\n        this.graph = stream(relations).collect(groupingBy(x -> x[1], mapping(x -> x[0], toList())));\\n\\n        return IntStream.range(1, n + 1)\\n                .map(this::getTime)\\n                .max()\\n                .orElse(0);\\n    }\\n\\n    private int getTime(int u) {\\n        if (dp[u - 1] == -1)\\n            dp[u - 1] = time[u - 1] + graph.getOrDefault(u, emptyList())\\n                    .stream()\\n                    .mapToInt(this::getTime)\\n                    .max()\\n                    .orElse(0);\\n\\n        return dp[u - 1];\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming",
                    "Depth-First Search"
                ],
                "code": "```\\nimport java.util.List;\\nimport java.util.Map;\\nimport java.util.stream.IntStream;\\n\\nimport static java.util.Arrays.fill;\\nimport static java.util.Arrays.stream;\\nimport static java.util.Collections.emptyList;\\nimport static java.util.stream.Collectors.groupingBy;\\nimport static java.util.stream.Collectors.mapping;\\nimport static java.util.stream.Collectors.toList;\\n\\n\\nclass Solution {\\n    private Map<Integer, List<Integer>> graph;\\n    private int[] dp, time;\\n\\n    public int minimumTime(int n, int[][] relations, int[] time) {\\n        this.dp = new int[n];\\n        this.time = time;\\n\\n        fill(dp, -1);\\n        this.graph = stream(relations).collect(groupingBy(x -> x[1], mapping(x -> x[0], toList())));\\n\\n        return IntStream.range(1, n + 1)\\n                .map(this::getTime)\\n                .max()\\n                .orElse(0);\\n    }\\n\\n    private int getTime(int u) {\\n        if (dp[u - 1] == -1)\\n            dp[u - 1] = time[u - 1] + graph.getOrDefault(u, emptyList())\\n                    .stream()\\n                    .mapToInt(this::getTime)\\n                    .max()\\n                    .orElse(0);\\n\\n        return dp[u - 1];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3932664,
                "title": "topological-sorting-plain-logic",
                "content": "![ex2.png](https://assets.leetcode.com/users/images/7cebf3ca-0dfb-4387-9ebe-ea56232a255b_1692465452.7361753.png)\\n\\n```\\nAt first we\\'ve courses with no pre-requisite are 1, 2, 3. After completing 1, 2 and 3, now\\nwe\\'ve only one course 4. To go to 4 at first we need to complete 3 in 3 months, then 4 is completed\\nin NEXT 4 months.. \\n\\nSo, the total amount of time is needed to complete 1, 2, 3, 4 we need to wait 7 months. Hence, the\\ntime for \\'4\\' is changed to 7 months now. The total minimum month needs to complete 1, 2, 3, 4\\nis 7 months. Then for 5 all the pre-requisite is finished now and so we go to 5, add 7 + 5 = 12,\\nso to complete 1, 2, 3, 4, 5 we need minimum 12 months! time[5] changed to 12.\\n```\\n\\n```Python []\\nclass Solution:\\n    def minimumTime(self, n: int, relations: List[List[int]], time: List[int]) -> int:\\n        adjList = [set() for _ in range(n+1)]\\n        inDegree = [0] * (n+1)\\n\\n        for (fromm, to) in relations:\\n            adjList[fromm].add(to)\\n            inDegree[to] += 1\\n\\n        q = deque()\\n        completeTime = [0] * (n+1)\\n\\n        for i in range(1, n+1):\\n            if inDegree[i] == 0:\\n                q.append(i)\\n                completeTime[i] = time[i-1]\\n        \\n        while q:\\n            for _ in range(len(q)):\\n                cur_course = q.popleft()\\n                for next_course in adjList[cur_course]:\\n                    completeTime[next_course] = max(completeTime[next_course], time[next_course-1]+time[cur_course-1])\\n                    inDegree[next_course] -= 1\\n                    if inDegree[next_course] == 0: # if pre-requisite of the next course is finished\\n                        q.append(next_course)\\n                        time[next_course-1] = completeTime[next_course]\\n\\n        return max(completeTime)\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nAt first we\\'ve courses with no pre-requisite are 1, 2, 3. After completing 1, 2 and 3, now\\nwe\\'ve only one course 4. To go to 4 at first we need to complete 3 in 3 months, then 4 is completed\\nin NEXT 4 months.. \\n\\nSo, the total amount of time is needed to complete 1, 2, 3, 4 we need to wait 7 months. Hence, the\\ntime for \\'4\\' is changed to 7 months now. The total minimum month needs to complete 1, 2, 3, 4\\nis 7 months. Then for 5 all the pre-requisite is finished now and so we go to 5, add 7 + 5 = 12,\\nso to complete 1, 2, 3, 4, 5 we need minimum 12 months! time[5] changed to 12.\\n```\n```Python []\\nclass Solution:\\n    def minimumTime(self, n: int, relations: List[List[int]], time: List[int]) -> int:\\n        adjList = [set() for _ in range(n+1)]\\n        inDegree = [0] * (n+1)\\n\\n        for (fromm, to) in relations:\\n            adjList[fromm].add(to)\\n            inDegree[to] += 1\\n\\n        q = deque()\\n        completeTime = [0] * (n+1)\\n\\n        for i in range(1, n+1):\\n            if inDegree[i] == 0:\\n                q.append(i)\\n                completeTime[i] = time[i-1]\\n        \\n        while q:\\n            for _ in range(len(q)):\\n                cur_course = q.popleft()\\n                for next_course in adjList[cur_course]:\\n                    completeTime[next_course] = max(completeTime[next_course], time[next_course-1]+time[cur_course-1])\\n                    inDegree[next_course] -= 1\\n                    if inDegree[next_course] == 0: # if pre-requisite of the next course is finished\\n                        q.append(next_course)\\n                        time[next_course-1] = completeTime[next_course]\\n\\n        return max(completeTime)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3907955,
                "title": "easy-c-solution",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minimumTime(int n, vector<vector<int>>& relations, vector<int>& time)\\n    {\\n        vector<vector<int>>adj(n);\\n        vector<int>indegree(n,0);\\n        for (auto it: relations)\\n        {\\n            adj[it[0]-1].push_back(it[1]-1);\\n            indegree[it[1]-1]++;\\n        }\\n        queue<int>q;\\n        vector<int>dist(n,0);\\n        for (int i=0;i<n;i++)\\n        {\\n            if (indegree[i]==0)\\n            {\\n                q.push(i);\\n                dist[i]=time[i];\\n            }\\n        }\\n        while(!q.empty())\\n        {\\n            int node=q.front();\\n            q.pop();\\n            for (auto it:adj[node])\\n            {\\n                dist[it]=max(dist[it],dist[node]+time[it]);\\n                indegree[it]--;\\n                if (indegree[it]==0)\\n                {\\n                    q.push(it);\\n                }\\n            }\\n        }\\n        int maxi=0;\\n        for (int i=0;i<n;i++)\\n        {\\n            maxi=max(maxi,dist[i]);\\n        }\\n        return maxi;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumTime(int n, vector<vector<int>>& relations, vector<int>& time)\\n    {\\n        vector<vector<int>>adj(n);\\n        vector<int>indegree(n,0);\\n        for (auto it: relations)\\n        {\\n            adj[it[0]-1].push_back(it[1]-1);\\n            indegree[it[1]-1]++;\\n        }\\n        queue<int>q;\\n        vector<int>dist(n,0);\\n        for (int i=0;i<n;i++)\\n        {\\n            if (indegree[i]==0)\\n            {\\n                q.push(i);\\n                dist[i]=time[i];\\n            }\\n        }\\n        while(!q.empty())\\n        {\\n            int node=q.front();\\n            q.pop();\\n            for (auto it:adj[node])\\n            {\\n                dist[it]=max(dist[it],dist[node]+time[it]);\\n                indegree[it]--;\\n                if (indegree[it]==0)\\n                {\\n                    q.push(it);\\n                }\\n            }\\n        }\\n        int maxi=0;\\n        for (int i=0;i<n;i++)\\n        {\\n            maxi=max(maxi,dist[i]);\\n        }\\n        return maxi;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3875588,
                "title": "topological-sort-in-python-beats-92-time",
                "content": "![image.png](https://assets.leetcode.com/users/images/b5234770-8c7a-4ca2-8c29-a716b9b20a80_1691395262.582657.png)\\n\\n# Code\\n```\\nclass Solution:\\n    def minimumTime(self, n: int, relations: List[List[int]], time: List[int]) -> int:\\n        adj = defaultdict(list)\\n        for src, dst in relations:\\n            adj[dst].append(src)\\n        \\n        visit = set()\\n        @cache\\n        def dfs(node):\\n            if node in visit:\\n                return 0\\n            visit.add(node)\\n            res = 0\\n            for dst in adj[node]:    \\n                res = max(res, dfs(dst))\\n            visit.remove(node)\\n            return time[node-1] + res\\n        res = 0\\n        for node in range(1, n+1):\\n            res = max(res, dfs(node))\\n        return res\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Topological Sort",
                    "Memoization"
                ],
                "code": "```\\nclass Solution:\\n    def minimumTime(self, n: int, relations: List[List[int]], time: List[int]) -> int:\\n        adj = defaultdict(list)\\n        for src, dst in relations:\\n            adj[dst].append(src)\\n        \\n        visit = set()\\n        @cache\\n        def dfs(node):\\n            if node in visit:\\n                return 0\\n            visit.add(node)\\n            res = 0\\n            for dst in adj[node]:    \\n                res = max(res, dfs(dst))\\n            visit.remove(node)\\n            return time[node-1] + res\\n        res = 0\\n        for node in range(1, n+1):\\n            res = max(res, dfs(node))\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3874106,
                "title": "easy-dp-in-python3",
                "content": "\\n# Code\\n```\\nclass Solution:\\n    def minimumTime(self, n: int, relations: List[List[int]], time: List[int]) -> int:\\n        pregraph = {i:set([]) for i in range(1,n+1)}\\n        for s,e in relations:\\n            pregraph[e].add(s)\\n        \\n        @cache\\n        def dp(i):\\n            if not pregraph[i]:\\n                return time[i-1]\\n            else:\\n                return time[i-1] + max(dp(j) for j in pregraph[i])\\n            \\n        res = 0\\n        for i in range(1,n+1):\\n            res = max(res,dp(i))\\n        \\n        return res\\n\\n\\n    \\n```",
                "solutionTags": [
                    "Python3",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution:\\n    def minimumTime(self, n: int, relations: List[List[int]], time: List[int]) -> int:\\n        pregraph = {i:set([]) for i in range(1,n+1)}\\n        for s,e in relations:\\n            pregraph[e].add(s)\\n        \\n        @cache\\n        def dp(i):\\n            if not pregraph[i]:\\n                return time[i-1]\\n            else:\\n                return time[i-1] + max(dp(j) for j in pregraph[i])\\n            \\n        res = 0\\n        for i in range(1,n+1):\\n            res = max(res,dp(i))\\n        \\n        return res\\n\\n\\n    \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3853308,
                "title": "easy-c-bfs-solution-using-kahn-s-algorithm",
                "content": "# Intuition\\nApply Kahn\\'s algorithm to implement a breadth first search algorithm.\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minimumTime(int n, vector<vector<int>>& relations, vector<int>& months) {\\n        \\n        vector<int> distance(n+1,INT_MIN);\\n        vector<int> indegree(n+1,0);\\n        vector<vector<int>> adj(n+1);\\n        for(auto it:relations){\\n            adj[it[0]].push_back(it[1]);\\n            indegree[it[1]]++;\\n        }\\n\\n        // {time,node}\\n        priority_queue<pair<int,int>,vector<pair<int,int>>,greater<pair<int,int>>> pq;\\n        for(int i=1;i<=n;i++){\\n            if(indegree[i]==0){\\n                pq.push({months[i-1],i});\\n                distance[i]=months[i-1];\\n            }\\n        }\\n        int ans=-1;\\n        while(!pq.empty()){\\n\\n            int time=pq.top().first;\\n            int node=pq.top().second;\\n            pq.pop();\\n            ans=max(ans,time);\\n            for(auto it:adj[node]){\\n                indegree[it]--;\\n                distance[it]=max(distance[it],time);\\n                if(indegree[it]==0){\\n                    pq.push({distance[it]+months[it-1],it});\\n                }\\n            }\\n\\n\\n        }\\n        return ans;\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumTime(int n, vector<vector<int>>& relations, vector<int>& months) {\\n        \\n        vector<int> distance(n+1,INT_MIN);\\n        vector<int> indegree(n+1,0);\\n        vector<vector<int>> adj(n+1);\\n        for(auto it:relations){\\n            adj[it[0]].push_back(it[1]);\\n            indegree[it[1]]++;\\n        }\\n\\n        // {time,node}\\n        priority_queue<pair<int,int>,vector<pair<int,int>>,greater<pair<int,int>>> pq;\\n        for(int i=1;i<=n;i++){\\n            if(indegree[i]==0){\\n                pq.push({months[i-1],i});\\n                distance[i]=months[i-1];\\n            }\\n        }\\n        int ans=-1;\\n        while(!pq.empty()){\\n\\n            int time=pq.top().first;\\n            int node=pq.top().second;\\n            pq.pop();\\n            ans=max(ans,time);\\n            for(auto it:adj[node]){\\n                indegree[it]--;\\n                distance[it]=max(distance[it],time);\\n                if(indegree[it]==0){\\n                    pq.push({distance[it]+months[it-1],it});\\n                }\\n            }\\n\\n\\n        }\\n        return ans;\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3832310,
                "title": "priority-queue-bfs-98-solution",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    int minimumTime(int n, vector<vector<int>>& relations, vector<int>& time) {\\n        int ptime = 0;\\n\\n        unordered_map<int, vector<int>>mp;\\n        vector<int>indeg(n+1, 0);\\n        priority_queue<pair<int,int>, vector<pair<int,int>>, greater<pair<int,int>>>pq;\\n\\n        for(auto x:relations){\\n            mp[x[0]].push_back(x[1]);\\n            indeg[x[1]]++;\\n        }\\n\\n        for(int i=1;i<n+1;i++){\\n            if(!indeg[i]){\\n                pq.push({ptime + time[i-1], i});\\n            }\\n        }\\n\\n\\n        while(!pq.empty()){\\n            auto top = pq.top(); pq.pop();\\n\\n            ptime = top.first;\\n\\n            for(auto x:mp[top.second]){\\n                indeg[x]--;\\n                if(!indeg[x]){\\n                    pq.push({ptime + time[x-1], x});\\n                }         \\n            }\\n        }\\n\\n        return ptime;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumTime(int n, vector<vector<int>>& relations, vector<int>& time) {\\n        int ptime = 0;\\n\\n        unordered_map<int, vector<int>>mp;\\n        vector<int>indeg(n+1, 0);\\n        priority_queue<pair<int,int>, vector<pair<int,int>>, greater<pair<int,int>>>pq;\\n\\n        for(auto x:relations){\\n            mp[x[0]].push_back(x[1]);\\n            indeg[x[1]]++;\\n        }\\n\\n        for(int i=1;i<n+1;i++){\\n            if(!indeg[i]){\\n                pq.push({ptime + time[i-1], i});\\n            }\\n        }\\n\\n\\n        while(!pq.empty()){\\n            auto top = pq.top(); pq.pop();\\n\\n            ptime = top.first;\\n\\n            for(auto x:mp[top.second]){\\n                indeg[x]--;\\n                if(!indeg[x]){\\n                    pq.push({ptime + time[x-1], x});\\n                }         \\n            }\\n        }\\n\\n        return ptime;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3830248,
                "title": "c-solution-beats-100-topological-sort",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n\\n    int minimumTime(int n, vector<vector<int>>& relations, vector<int>& time) {\\n\\n        vector<vector<int>> adjList(n, vector<int>());\\n        vector<int> indegree(n, 0);\\n\\n        for(auto &r:relations) {\\n            adjList[r[0]-1].push_back(r[1]-1);\\n\\t\\t\\tindegree[r[1]-1]++;\\n\\t\\t}\\n\\n        vector<int> dist(n);\\n\\n        queue<int> q;\\n        vector<int> ans(n);\\n        for(int i = 0 ; i < n ; i++) if(indegree[i] == 0){\\n            q.push(i);\\n            dist[i] = time[i];\\n        }\\n\\n        while(!q.empty()){\\n            int node = q.front();\\n            q.pop();\\n            ans.push_back(node);\\n\\n            for(auto it : adjList[node]){\\n                dist[it] = max(dist[it], dist[node]+time[it]);\\n                indegree[it]--;\\n                if(indegree[it] == 0) q.push(it);\\n            }\\n        }\\n\\n        return *max_element(dist.begin(), dist.end());\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Graph",
                    "Topological Sort"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\n    int minimumTime(int n, vector<vector<int>>& relations, vector<int>& time) {\\n\\n        vector<vector<int>> adjList(n, vector<int>());\\n        vector<int> indegree(n, 0);\\n\\n        for(auto &r:relations) {\\n            adjList[r[0]-1].push_back(r[1]-1);\\n\\t\\t\\tindegree[r[1]-1]++;\\n\\t\\t}\\n\\n        vector<int> dist(n);\\n\\n        queue<int> q;\\n        vector<int> ans(n);\\n        for(int i = 0 ; i < n ; i++) if(indegree[i] == 0){\\n            q.push(i);\\n            dist[i] = time[i];\\n        }\\n\\n        while(!q.empty()){\\n            int node = q.front();\\n            q.pop();\\n            ans.push_back(node);\\n\\n            for(auto it : adjList[node]){\\n                dist[it] = max(dist[it], dist[node]+time[it]);\\n                indegree[it]--;\\n                if(indegree[it] == 0) q.push(it);\\n            }\\n        }\\n\\n        return *max_element(dist.begin(), dist.end());\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3826458,
                "title": "topo-sort",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minimumTime(int n, vector<vector<int>>& relations, vector<int>& time) {\\n        vector<vector<int>> graph(n);\\n        vector<int> indegrees(n);\\n\\n        for (const auto& r : relations) {\\n            graph[r[0] - 1].push_back(r[1] - 1);\\n            indegrees[r[1] - 1]++;\\n        }\\n\\n        queue<pair<int, int>> q; // course#, complete time\\n        int res = 0;\\n        for (int i = 0; i < indegrees.size(); i++) {\\n            if (!indegrees[i]) {\\n                q.emplace(i, time[i]);\\n            }\\n        }\\n        vector<int> completeTime(n);\\n\\n        while (!q.empty()) {\\n            auto [v, t] = q.front(); q.pop();\\n            res = max(res, t);\\n            for (int i = 0; i < graph[v].size(); i++) {\\n                completeTime[graph[v][i]] = max(completeTime[graph[v][i]], t + time[graph[v][i]]);\\n                indegrees[graph[v][i]]--;\\n                if (!indegrees[graph[v][i]]) {\\n                    q.emplace(graph[v][i], completeTime[graph[v][i]]);\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumTime(int n, vector<vector<int>>& relations, vector<int>& time) {\\n        vector<vector<int>> graph(n);\\n        vector<int> indegrees(n);\\n\\n        for (const auto& r : relations) {\\n            graph[r[0] - 1].push_back(r[1] - 1);\\n            indegrees[r[1] - 1]++;\\n        }\\n\\n        queue<pair<int, int>> q; // course#, complete time\\n        int res = 0;\\n        for (int i = 0; i < indegrees.size(); i++) {\\n            if (!indegrees[i]) {\\n                q.emplace(i, time[i]);\\n            }\\n        }\\n        vector<int> completeTime(n);\\n\\n        while (!q.empty()) {\\n            auto [v, t] = q.front(); q.pop();\\n            res = max(res, t);\\n            for (int i = 0; i < graph[v].size(); i++) {\\n                completeTime[graph[v][i]] = max(completeTime[graph[v][i]], t + time[graph[v][i]]);\\n                indegrees[graph[v][i]]--;\\n                if (!indegrees[graph[v][i]]) {\\n                    q.emplace(graph[v][i], completeTime[graph[v][i]]);\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3822084,
                "title": "my-solutions",
                "content": "**1. Use the `std::priority_queue`**\\n```\\n/**\\n * Time Complexity: O((n + n_relations) * log(n))\\n * Space Complexity: O(n + n_relations)\\n * where `n_relations` is the length of the vector `relations`\\n */\\nclass Solution {\\n public:\\n  int minimumTime(const int n,\\n                  const vector<vector<int>> &relations,\\n                  const vector<int> &time) {\\n    using pq_node_t = pair<int, int>;   // {the finishing months, the course}\\n    vector<int> graph[n];\\n    int indegrees[n];\\n    memset(indegrees, 0, sizeof(indegrees));\\n    for (const vector<int> &relation : relations) {\\n      const int prev = relation.front() - 1;\\n      const int next = relation.back() - 1;\\n      graph[prev].emplace_back(next);\\n      ++indegrees[next];\\n    }\\n    \\n    int ret = 0;\\n    priority_queue<pq_node_t, vector<pq_node_t>, greater<>> pq;\\n    for (int course = 0; course < n; ++course) {\\n      if (indegrees[course] == 0) {\\n        pq.emplace(time[course], course);\\n        ret = max(ret, time[course]);\\n      }\\n    }\\n    \\n    while (!pq.empty()) {\\n      const auto [months, node] = pq.top();\\n      pq.pop();\\n      for (const int next : graph[node]) {\\n        if (--indegrees[next] == 0) {\\n          pq.emplace(months + time[next], next);\\n          ret = max(ret, months + time[next]);\\n        }\\n      }\\n    }\\n    return ret;\\n  }\\n};\\n```\\n**2. Use the DP**\\n```\\n/**\\n * Time Complexity: O(n + n_relations)\\n * Space Complexity: O(n + n_relations)\\n * where `n_relations` is the length of the vector `relations`\\n */\\nclass Solution {\\n public:\\n  int minimumTime(const int n,\\n                  const vector<vector<int>> &relations,\\n                  const vector<int> &time) {\\n    vector<int> graph[n];\\n    int indegrees[n];\\n    memset(indegrees, 0, sizeof(indegrees));\\n    for (const vector<int> &relation : relations) {\\n      const int prev = relation.front() - 1;\\n      const int next = relation.back() - 1;\\n      graph[prev].emplace_back(next);\\n      ++indegrees[next];\\n    }\\n    \\n    int dp[n];\\n    memset(dp, 0, sizeof(dp));\\n    queue<int> q;\\n    for (int course = 0; course < n; ++course) {\\n      if (indegrees[course] == 0) {\\n        q.emplace(course);\\n        dp[course] = time[course];\\n      }\\n    }\\n    \\n    while (!q.empty()) {\\n      const int node = q.front();\\n      q.pop();\\n      for (const int next : graph[node]) {\\n        dp[next] = max(dp[next], dp[node] + time[next]);\\n        if (--indegrees[next] == 0) {\\n          q.emplace(next);\\n        }\\n      }\\n    }\\n    return *max_element(dp, dp + n);\\n  }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n/**\\n * Time Complexity: O((n + n_relations) * log(n))\\n * Space Complexity: O(n + n_relations)\\n * where `n_relations` is the length of the vector `relations`\\n */\\nclass Solution {\\n public:\\n  int minimumTime(const int n,\\n                  const vector<vector<int>> &relations,\\n                  const vector<int> &time) {\\n    using pq_node_t = pair<int, int>;   // {the finishing months, the course}\\n    vector<int> graph[n];\\n    int indegrees[n];\\n    memset(indegrees, 0, sizeof(indegrees));\\n    for (const vector<int> &relation : relations) {\\n      const int prev = relation.front() - 1;\\n      const int next = relation.back() - 1;\\n      graph[prev].emplace_back(next);\\n      ++indegrees[next];\\n    }\\n    \\n    int ret = 0;\\n    priority_queue<pq_node_t, vector<pq_node_t>, greater<>> pq;\\n    for (int course = 0; course < n; ++course) {\\n      if (indegrees[course] == 0) {\\n        pq.emplace(time[course], course);\\n        ret = max(ret, time[course]);\\n      }\\n    }\\n    \\n    while (!pq.empty()) {\\n      const auto [months, node] = pq.top();\\n      pq.pop();\\n      for (const int next : graph[node]) {\\n        if (--indegrees[next] == 0) {\\n          pq.emplace(months + time[next], next);\\n          ret = max(ret, months + time[next]);\\n        }\\n      }\\n    }\\n    return ret;\\n  }\\n};\\n```\n```\\n/**\\n * Time Complexity: O(n + n_relations)\\n * Space Complexity: O(n + n_relations)\\n * where `n_relations` is the length of the vector `relations`\\n */\\nclass Solution {\\n public:\\n  int minimumTime(const int n,\\n                  const vector<vector<int>> &relations,\\n                  const vector<int> &time) {\\n    vector<int> graph[n];\\n    int indegrees[n];\\n    memset(indegrees, 0, sizeof(indegrees));\\n    for (const vector<int> &relation : relations) {\\n      const int prev = relation.front() - 1;\\n      const int next = relation.back() - 1;\\n      graph[prev].emplace_back(next);\\n      ++indegrees[next];\\n    }\\n    \\n    int dp[n];\\n    memset(dp, 0, sizeof(dp));\\n    queue<int> q;\\n    for (int course = 0; course < n; ++course) {\\n      if (indegrees[course] == 0) {\\n        q.emplace(course);\\n        dp[course] = time[course];\\n      }\\n    }\\n    \\n    while (!q.empty()) {\\n      const int node = q.front();\\n      q.pop();\\n      for (const int next : graph[node]) {\\n        dp[next] = max(dp[next], dp[node] + time[next]);\\n        if (--indegrees[next] == 0) {\\n          q.emplace(next);\\n        }\\n      }\\n    }\\n    return *max_element(dp, dp + n);\\n  }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3817088,
                "title": "java-kahn-s-algo-bfs",
                "content": "```\\nclass Solution {\\n    public class Pair{\\n        int val;\\n        int t;\\n        Pair(int val,int t){\\n            this.val=val;\\n            this.t=t;\\n        }\\n    }\\n    public int minimumTime(int n, int[][] relations, int[] time) {\\n        ArrayList<Integer>[]arr=new ArrayList[n+1];\\n        for(int i=0;i<arr.length;i++){\\n            arr[i]=new ArrayList<>();\\n        }\\n        int []inD=new int[n+1];\\n        for(int i=0;i<relations.length;i++){\\n            int x=relations[i][0];\\n            int y=relations[i][1];\\n            \\n            arr[x].add(y);\\n            inD[y]++;\\n        }\\n        \\n        Queue<Pair>q=new LinkedList<>();\\n        for(int i=1;i<inD.length;i++){\\n            if(inD[i]==0){\\n                q.add(new Pair(i,time[i-1]));\\n            }\\n        }\\n        int []cost=new int[n+1];\\n        Arrays.fill(cost,-(int)1e9);\\n        boolean []vis=new boolean[n+1];\\n        int ans=0;\\n        while(q.size()>0){\\n            Pair rem=q.remove();\\n            if(vis[rem.val]==true){\\n                continue;\\n            }\\n            vis[rem.val]=true;\\n            ans=Math.max(ans,rem.t);\\n            for(int e:arr[rem.val]){\\n                if(vis[e]==true){\\n                    continue;\\n                }\\n                inD[e]--;\\n                cost[e]=Math.max(cost[e],rem.t);\\n                \\n                if(inD[e]==0){\\n                    q.add(new Pair(e,cost[e]+time[e-1]));\\n                }\\n            }   \\n        }\\n        return ans;\\n    }\\n}",
                "solutionTags": [
                    "Java",
                    "Breadth-First Search"
                ],
                "code": "class Solution {\\n    public class Pair{\\n        int val;\\n        int t;\\n        Pair(int val,int t){\\n            this.val=val;\\n            this.t=t;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 3810207,
                "title": "bfs-very-simple-toposort-with-minheap",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minimumTime(int n, vector<vector<int>>& relations, vector<int>& time) {\\n        vector<int>adj[n+1];\\n        vector<int>indeg(n+1,0);\\n        for(int i=0;i<relations.size();i++)\\n        {\\n            adj[relations[i][0]].push_back(relations[i][1]);\\n            indeg[relations[i][1]]++;\\n        }\\n        priority_queue<pair<int,int>,vector<pair<int,int>>,greater<pair<int,int>>>pq;\\n        for(int i=1;i<=n;i++)\\n        {\\n            if(indeg[i]==0)\\n            pq.push({time[i-1],i});\\n        }\\n        int ans=0;\\n        while(!pq.empty())\\n        {\\n            int node=pq.top().second;\\n            int t=pq.top().first;\\n            pq.pop();\\n            ans=max(ans,t);\\n            for(auto it:adj[node])\\n            {\\n                indeg[it]--;\\n                if(indeg[it]==0)\\n                pq.push({time[it-1]+t,it});\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Graph",
                    "Topological Sort",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumTime(int n, vector<vector<int>>& relations, vector<int>& time) {\\n        vector<int>adj[n+1];\\n        vector<int>indeg(n+1,0);\\n        for(int i=0;i<relations.size();i++)\\n        {\\n            adj[relations[i][0]].push_back(relations[i][1]);\\n            indeg[relations[i][1]]++;\\n        }\\n        priority_queue<pair<int,int>,vector<pair<int,int>>,greater<pair<int,int>>>pq;\\n        for(int i=1;i<=n;i++)\\n        {\\n            if(indeg[i]==0)\\n            pq.push({time[i-1],i});\\n        }\\n        int ans=0;\\n        while(!pq.empty())\\n        {\\n            int node=pq.top().second;\\n            int t=pq.top().first;\\n            pq.pop();\\n            ans=max(ans,t);\\n            for(auto it:adj[node])\\n            {\\n                indeg[it]--;\\n                if(indeg[it]==0)\\n                pq.push({time[it-1]+t,it});\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3794642,
                "title": "parallel-courses-iii",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {number} n\\n * @param {number[][]} relations\\n * @param {number[]} time\\n * @return {number}\\n */\\nvar minimumTime = function(n, relations, time) {\\n      // Step 1: Create an adjacency list to represent the graph.\\n    let graph = new Map();\\n    for (let i = 0; i < relations.length; i++) {\\n        if (graph.has(relations[i][0])) {\\n            graph.get(relations[i][0]).push(relations[i][1]);\\n        } else {\\n            graph.set(relations[i][0], [relations[i][1]]);\\n        }\\n    }\\n\\n    // Step 2: Initialize a cache to store the time spent on each course.\\n    let cache = new Array(n + 1).fill(-1);\\n\\n    // Step 3: Helper function to find the total time needed for a course.\\n    function findTime(course) {\\n        if (cache[course] !== -1) return cache[course];\\n\\n        let totalTime = time[course - 1];\\n        if (graph.has(course)) {\\n            for (let nextCourse of graph.get(course)) {\\n                totalTime = Math.max(totalTime, time[course - 1] + findTime(nextCourse));\\n            }\\n        }\\n        cache[course] = totalTime;\\n        return totalTime;\\n    }\\n\\n    // Step 4: Find the maximum time needed to complete all courses.\\n    let maxTime = 0;\\n    for (let i = 1; i <= n; i++) {\\n        console.log(findTime(i))\\n        maxTime = Math.max(maxTime, findTime(i));\\n    }\\n    return maxTime;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number} n\\n * @param {number[][]} relations\\n * @param {number[]} time\\n * @return {number}\\n */\\nvar minimumTime = function(n, relations, time) {\\n      // Step 1: Create an adjacency list to represent the graph.\\n    let graph = new Map();\\n    for (let i = 0; i < relations.length; i++) {\\n        if (graph.has(relations[i][0])) {\\n            graph.get(relations[i][0]).push(relations[i][1]);\\n        } else {\\n            graph.set(relations[i][0], [relations[i][1]]);\\n        }\\n    }\\n\\n    // Step 2: Initialize a cache to store the time spent on each course.\\n    let cache = new Array(n + 1).fill(-1);\\n\\n    // Step 3: Helper function to find the total time needed for a course.\\n    function findTime(course) {\\n        if (cache[course] !== -1) return cache[course];\\n\\n        let totalTime = time[course - 1];\\n        if (graph.has(course)) {\\n            for (let nextCourse of graph.get(course)) {\\n                totalTime = Math.max(totalTime, time[course - 1] + findTime(nextCourse));\\n            }\\n        }\\n        cache[course] = totalTime;\\n        return totalTime;\\n    }\\n\\n    // Step 4: Find the maximum time needed to complete all courses.\\n    let maxTime = 0;\\n    for (let i = 1; i <= n; i++) {\\n        console.log(findTime(i))\\n        maxTime = Math.max(maxTime, findTime(i));\\n    }\\n    return maxTime;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3771412,
                "title": "dfs-dp-approach",
                "content": "# Complexity\\n- Time complexity:\\nO(N)\\n\\n- Space complexity:\\nO(N)\\n\\n# Code\\n```\\npublic class Solution\\n{\\n    List<int>[] adjList;\\n    int[] dp;\\n    public int MinimumTime(int n, int[][] relations, int[] time)\\n    {\\n        int maxMonths = 0;\\n        adjList = new List<int>[n + 1];\\n        int[] inDegree = new int[n + 1];\\n        dp = new int[n+1];\\n\\n        for (int i = 0; i <= n; i++){\\n            adjList[i] = new List<int>();\\n            dp[i] = -1;\\n        }\\n\\n        foreach (int[] r in relations)\\n        {\\n            adjList[r[0]].Add(r[1]);\\n            inDegree[r[1]] += 1;\\n        }\\n\\n        for (int i = 1; i <= n; i++)\\n        {\\n            if (inDegree[i] != 0)\\n                continue;\\n\\n            maxMonths = Math.Max(maxMonths, GetMaxMonths(i, time));\\n        }\\n        return maxMonths;\\n    }\\n\\n    private int GetMaxMonths(int node, int[] time)\\n    {\\n        if(dp[node] != -1)\\n            return dp[node];\\n\\n        var adjNodes = adjList[node];\\n        if (adjNodes.Count == 0)\\n            return time[node - 1];\\n\\n        int maxMonth = 0;\\n        foreach (int nd in adjNodes)\\n            maxMonth = Math.Max(maxMonth, time[node - 1] + GetMaxMonths(nd, time));\\n\\n        return dp[node] = maxMonth;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#",
                    "Dynamic Programming",
                    "Depth-First Search",
                    "Graph"
                ],
                "code": "```\\npublic class Solution\\n{\\n    List<int>[] adjList;\\n    int[] dp;\\n    public int MinimumTime(int n, int[][] relations, int[] time)\\n    {\\n        int maxMonths = 0;\\n        adjList = new List<int>[n + 1];\\n        int[] inDegree = new int[n + 1];\\n        dp = new int[n+1];\\n\\n        for (int i = 0; i <= n; i++){\\n            adjList[i] = new List<int>();\\n            dp[i] = -1;\\n        }\\n\\n        foreach (int[] r in relations)\\n        {\\n            adjList[r[0]].Add(r[1]);\\n            inDegree[r[1]] += 1;\\n        }\\n\\n        for (int i = 1; i <= n; i++)\\n        {\\n            if (inDegree[i] != 0)\\n                continue;\\n\\n            maxMonths = Math.Max(maxMonths, GetMaxMonths(i, time));\\n        }\\n        return maxMonths;\\n    }\\n\\n    private int GetMaxMonths(int node, int[] time)\\n    {\\n        if(dp[node] != -1)\\n            return dp[node];\\n\\n        var adjNodes = adjList[node];\\n        if (adjNodes.Count == 0)\\n            return time[node - 1];\\n\\n        int maxMonth = 0;\\n        foreach (int nd in adjNodes)\\n            maxMonth = Math.Max(maxMonth, time[node - 1] + GetMaxMonths(nd, time));\\n\\n        return dp[node] = maxMonth;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3771203,
                "title": "a-little-tweak-on-topo-sort-simple-approach",
                "content": "# Complexity\\n- Time complexity:\\nO(N)\\n\\n- Space complexity:\\nO(N)\\n\\n# Code\\n```\\npublic class Solution\\n{\\n    List<int>[] adjList;\\n    public int MinimumTime(int n, int[][] relations, int[] time)\\n    {\\n        adjList = new List<int>[n + 1];\\n        int[] inDegree = new int[n + 1];\\n        int[] weight = new int[n+1];\\n        Queue<int> topoQueue = new Queue<int>();\\n        for (int i = 0; i <= n; i++)\\n            adjList[i] = new List<int>();\\n\\n        foreach (int[] r in relations){\\n            adjList[r[0]].Add(r[1]);\\n            inDegree[r[1]] += 1;\\n        }\\n\\n        for(int i = 1; i <= n; i++){\\n            if(inDegree[i] == 0)\\n                topoQueue.Enqueue(i);\\n        }\\n\\n        while(topoQueue.Count != 0){\\n            int currNode = topoQueue.Dequeue();\\n            var adjNodes = adjList[currNode];\\n            if(adjNodes.Count == 0){\\n                weight[0] = Math.Max(weight[0], weight[currNode]+time[currNode-1]);\\n                continue;\\n            }\\n\\n            foreach(int nd in adjNodes){\\n                inDegree[nd] -= 1;\\n                weight[nd] = Math.Max(weight[nd], weight[currNode]+time[currNode-1]);\\n                if(inDegree[nd] == 0)\\n                    topoQueue.Enqueue(nd);\\n            }\\n        }\\n        return weight[0];\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#",
                    "Array",
                    "Graph",
                    "Topological Sort"
                ],
                "code": "```\\npublic class Solution\\n{\\n    List<int>[] adjList;\\n    public int MinimumTime(int n, int[][] relations, int[] time)\\n    {\\n        adjList = new List<int>[n + 1];\\n        int[] inDegree = new int[n + 1];\\n        int[] weight = new int[n+1];\\n        Queue<int> topoQueue = new Queue<int>();\\n        for (int i = 0; i <= n; i++)\\n            adjList[i] = new List<int>();\\n\\n        foreach (int[] r in relations){\\n            adjList[r[0]].Add(r[1]);\\n            inDegree[r[1]] += 1;\\n        }\\n\\n        for(int i = 1; i <= n; i++){\\n            if(inDegree[i] == 0)\\n                topoQueue.Enqueue(i);\\n        }\\n\\n        while(topoQueue.Count != 0){\\n            int currNode = topoQueue.Dequeue();\\n            var adjNodes = adjList[currNode];\\n            if(adjNodes.Count == 0){\\n                weight[0] = Math.Max(weight[0], weight[currNode]+time[currNode-1]);\\n                continue;\\n            }\\n\\n            foreach(int nd in adjNodes){\\n                inDegree[nd] -= 1;\\n                weight[nd] = Math.Max(weight[nd], weight[currNode]+time[currNode-1]);\\n                if(inDegree[nd] == 0)\\n                    topoQueue.Enqueue(nd);\\n            }\\n        }\\n        return weight[0];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3757557,
                "title": "c-similar-to-kahn-s-algorithm",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    int minimumTime(int n, vector<vector<int>>& relations, vector<int>& time) {\\n        vector<int>adj[n+1];\\n        vector<int>dist(n+1,0);\\n        vector<int>indegree(n+1,0);\\n        queue<int>q;\\n        int res = 0;\\n        for(int i=0;i<relations.size();i++)\\n        {\\n            int u = relations[i][0];\\n            int v = relations[i][1];\\n            adj[u].push_back(v);\\n            indegree[v]++;\\n        }\\n        for(int i=1;i<=n;i++)\\n        {\\n            if(indegree[i] == 0)\\n            {\\n                q.push(i);\\n                dist[i] = time[i-1];\\n                res = max(res,dist[i]);\\n            }\\n        }\\n        while(!q.empty())\\n        {\\n            int a = q.front();\\n            q.pop();\\n            for(auto x:adj[a])\\n            {\\n                dist[x] = max(dist[x],time[x-1] + dist[a]);\\n                res = max(res,dist[x]);\\n                indegree[x]--;\\n                if(indegree[x] == 0)\\n                q.push(x);\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumTime(int n, vector<vector<int>>& relations, vector<int>& time) {\\n        vector<int>adj[n+1];\\n        vector<int>dist(n+1,0);\\n        vector<int>indegree(n+1,0);\\n        queue<int>q;\\n        int res = 0;\\n        for(int i=0;i<relations.size();i++)\\n        {\\n            int u = relations[i][0];\\n            int v = relations[i][1];\\n            adj[u].push_back(v);\\n            indegree[v]++;\\n        }\\n        for(int i=1;i<=n;i++)\\n        {\\n            if(indegree[i] == 0)\\n            {\\n                q.push(i);\\n                dist[i] = time[i-1];\\n                res = max(res,dist[i]);\\n            }\\n        }\\n        while(!q.empty())\\n        {\\n            int a = q.front();\\n            q.pop();\\n            for(auto x:adj[a])\\n            {\\n                dist[x] = max(dist[x],time[x-1] + dist[a]);\\n                res = max(res,dist[x]);\\n                indegree[x]--;\\n                if(indegree[x] == 0)\\n                q.push(x);\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3749217,
                "title": "topological-sort-update-start-time-for-node",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    int minTimeTopoSort(int n, vector<vector<int>>& relations, vector<int>& time) {\\n        vector<vector<int>> adj(n + 1);\\n        vector<int> indeg(n + 1);\\n        // earliest start time for course\\n        vector<int> start(n + 1);\\n        \\n        for (auto& e : relations) {\\n            adj[e[0]].push_back(e[1]);\\n            indeg[e[1]]++;\\n        }\\n\\n        queue<int> q;\\n        for (int i = 1; i <= n; i++) {\\n            if (indeg[i] == 0) {\\n                q.push(i);\\n            }\\n        }\\n\\n        int ans = 0;\\n        while (!q.empty()) {\\n            int node = q.front(); q.pop();\\n            int finish = start[node] + time[node - 1];\\n            ans = max(ans, finish);\\n            for (auto next : adj[node]) {\\n                start[next] = max(start[next], finish);\\n                if (--indeg[next] == 0) {\\n                    q.push(next);\\n                }\\n            }\\n        }\\n\\n        return ans;\\n    }\\npublic:\\n    /*\\n    Observations:\\n    1. If we can find the earliest start time for each node,\\n       its finish time = start + time[node - 1].\\n\\n       The answer = max{finish time i}, for all i in [1, n]\\n    2. start[node] = max{finish time i}, for all node prev course.\\n       \\n       Apply topological sort. Meanwhile maintain node start time.\\n       Process node when all prev courses have been taken, and\\n       answer is max finish time for graph nodes.\\n\\n       graph; topological sort; dynamic programming;\\n       O(v+e) time and space;\\n    */\\n    int minimumTime(int n, vector<vector<int>>& relations, vector<int>& time) {\\n        return minTimeTopoSort(n, relations, time);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\n    int minTimeTopoSort(int n, vector<vector<int>>& relations, vector<int>& time) {\\n        vector<vector<int>> adj(n + 1);\\n        vector<int> indeg(n + 1);\\n        // earliest start time for course\\n        vector<int> start(n + 1);\\n        \\n        for (auto& e : relations) {\\n            adj[e[0]].push_back(e[1]);\\n            indeg[e[1]]++;\\n        }\\n\\n        queue<int> q;\\n        for (int i = 1; i <= n; i++) {\\n            if (indeg[i] == 0) {\\n                q.push(i);\\n            }\\n        }\\n\\n        int ans = 0;\\n        while (!q.empty()) {\\n            int node = q.front(); q.pop();\\n            int finish = start[node] + time[node - 1];\\n            ans = max(ans, finish);\\n            for (auto next : adj[node]) {\\n                start[next] = max(start[next], finish);\\n                if (--indeg[next] == 0) {\\n                    q.push(next);\\n                }\\n            }\\n        }\\n\\n        return ans;\\n    }\\npublic:\\n    /*\\n    Observations:\\n    1. If we can find the earliest start time for each node,\\n       its finish time = start + time[node - 1].\\n\\n       The answer = max{finish time i}, for all i in [1, n]\\n    2. start[node] = max{finish time i}, for all node prev course.\\n       \\n       Apply topological sort. Meanwhile maintain node start time.\\n       Process node when all prev courses have been taken, and\\n       answer is max finish time for graph nodes.\\n\\n       graph; topological sort; dynamic programming;\\n       O(v+e) time and space;\\n    */\\n    int minimumTime(int n, vector<vector<int>>& relations, vector<int>& time) {\\n        return minTimeTopoSort(n, relations, time);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3736464,
                "title": "why-is-there-a-memory-exceeds-error-for-my-dfs-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nIt\\'s the same DFS solution that others have posted (e.g., https://leetcode.com/problems/parallel-courses-iii/solutions/1537473/python-short-dp-4-lines-explained/). However, I noticed that the code that returns `max` on the fly passes, whereas if I save the intermediate max value, it throws an memory exceeds error. Is it really about saving that one intermediate value that throws a memory exceeds error?\\n\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def minimumTime(self, n: int, relations: List[List[int]], time: List[int]) -> int:\\n        # convert it to a graph\\n        g = defaultdict(list)\\n        ig = defaultdict(list)\\n\\n        for r in relations:\\n            s, t = r[0] - 1, r[1] - 1\\n            g[s].append(t)\\n            ig[t].append(s)\\n        \\n        seeds = []\\n        for i in range(n):\\n            if not g[i]:\\n                seeds.append(i)\\n       \\n        @lru_cache(None)\\n        def dfs(n, time_took):\\n            if not g[n]:\\n                return time_took\\n            max_time = time_took\\n            for r in g[n]:\\n                max_time = max(dfs(r, time_took + time[r]), max_time)\\n            return max_time\\n\\n        max_semester = 0\\n        for i in range(n):\\n            max_semester = max(max_semester, dfs(i, time[i]))\\n        return max_semester\\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minimumTime(self, n: int, relations: List[List[int]], time: List[int]) -> int:\\n        # convert it to a graph\\n        g = defaultdict(list)\\n        ig = defaultdict(list)\\n\\n        for r in relations:\\n            s, t = r[0] - 1, r[1] - 1\\n            g[s].append(t)\\n            ig[t].append(s)\\n        \\n        seeds = []\\n        for i in range(n):\\n            if not g[i]:\\n                seeds.append(i)\\n       \\n        @lru_cache(None)\\n        def dfs(n, time_took):\\n            if not g[n]:\\n                return time_took\\n            max_time = time_took\\n            for r in g[n]:\\n                max_time = max(dfs(r, time_took + time[r]), max_time)\\n            return max_time\\n\\n        max_semester = 0\\n        for i in range(n):\\n            max_semester = max(max_semester, dfs(i, time[i]))\\n        return max_semester\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3709616,
                "title": "topological-sort-and-dp-of-max-ending-time-upto-course",
                "content": "```\\nfrom collections import deque, defaultdict\\n\\nclass Solution:\\n    def minimumTime(self, n: int, relations: List[List[int]], time: List[int]) -> int:\\n        q = deque()\\n        indegree = [0] * n\\n        graph = defaultdict(set)\\n        revgraph = defaultdict(set)\\n        for a, b in relations:\\n            indegree[b - 1] += 1\\n            graph[a - 1].add(b - 1)\\n            revgraph[b - 1].add(a - 1)\\n        for i in range(n):\\n            if indegree[i] == 0:\\n                q.appendleft(i)\\n        res = [0] * n\\n        while len(q) > 0:\\n            curr = q.pop()\\n            res[curr] = time[curr]\\n            for j in revgraph[curr]:\\n                res[curr] = max(res[curr], time[curr] + res[j])\\n            for j in graph[curr]:\\n                indegree[j] -= 1\\n                if indegree[j] == 0:\\n                    q.appendleft(j)\\n        return max(res)\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nfrom collections import deque, defaultdict\\n\\nclass Solution:\\n    def minimumTime(self, n: int, relations: List[List[int]], time: List[int]) -> int:\\n        q = deque()\\n        indegree = [0] * n\\n        graph = defaultdict(set)\\n        revgraph = defaultdict(set)\\n        for a, b in relations:\\n            indegree[b - 1] += 1\\n            graph[a - 1].add(b - 1)\\n            revgraph[b - 1].add(a - 1)\\n        for i in range(n):\\n            if indegree[i] == 0:\\n                q.appendleft(i)\\n        res = [0] * n\\n        while len(q) > 0:\\n            curr = q.pop()\\n            res[curr] = time[curr]\\n            for j in revgraph[curr]:\\n                res[curr] = max(res[curr], time[curr] + res[j])\\n            for j in graph[curr]:\\n                indegree[j] -= 1\\n                if indegree[j] == 0:\\n                    q.appendleft(j)\\n        return max(res)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3667557,
                "title": "simple-dfs-memo",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nMinimum number of months needed to complete all the courses is\\nthe path to leaf course with maximum sum of months. \\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nDFS from all courses that has no prerequisite and update totalMonths. \\nIndegree is used to find all courses without prerequisite.\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n$$O(V + E)$$ as every course will only be visited once\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n$$O(V + E)$$ as it is a DAG\\n# Code\\n```\\nclass Solution {\\n    int dfs(vector<vector<int>>& graph, int pos, const vector<int>& time, vector<int>& memo){\\n        if(memo[pos] != 0){\\n            return memo[pos];\\n        }\\n        int&& maxTime = 0;\\n        for(const auto& next : graph[pos]){\\n            maxTime = max(maxTime, dfs(graph, next, time, memo));\\n        }\\n        return memo[pos] = maxTime + time[pos-1];\\n    }\\npublic:\\n    int minimumTime(int n, vector<vector<int>>& relations, vector<int>& time) {\\n        \\n        vector<vector<int>> graph(n+1);\\n        vector<int> indegree(n+1);\\n        vector<int> memo(n+1, 0);\\n        indegree[0] = -1;\\n\\n        for(const auto& r : relations){\\n            graph[r.front()].push_back(r.back());\\n            indegree[r.back()]++;\\n        }\\n\\n        vector<int> level;\\n        for(const auto& course : indegree){\\n            if(course == 0){\\n                level.push_back(&course - &indegree.front());\\n            }\\n        }\\n\\n        int totalMonths = 0;\\n        \\n        for(const auto& pos : level){\\n            totalMonths = max(totalMonths, dfs(graph, pos, time, memo));\\n        }\\n\\n        return totalMonths;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\n    int dfs(vector<vector<int>>& graph, int pos, const vector<int>& time, vector<int>& memo){\\n        if(memo[pos] != 0){\\n            return memo[pos];\\n        }\\n        int&& maxTime = 0;\\n        for(const auto& next : graph[pos]){\\n            maxTime = max(maxTime, dfs(graph, next, time, memo));\\n        }\\n        return memo[pos] = maxTime + time[pos-1];\\n    }\\npublic:\\n    int minimumTime(int n, vector<vector<int>>& relations, vector<int>& time) {\\n        \\n        vector<vector<int>> graph(n+1);\\n        vector<int> indegree(n+1);\\n        vector<int> memo(n+1, 0);\\n        indegree[0] = -1;\\n\\n        for(const auto& r : relations){\\n            graph[r.front()].push_back(r.back());\\n            indegree[r.back()]++;\\n        }\\n\\n        vector<int> level;\\n        for(const auto& course : indegree){\\n            if(course == 0){\\n                level.push_back(&course - &indegree.front());\\n            }\\n        }\\n\\n        int totalMonths = 0;\\n        \\n        for(const auto& pos : level){\\n            totalMonths = max(totalMonths, dfs(graph, pos, time, memo));\\n        }\\n\\n        return totalMonths;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3658625,
                "title": "c-code-using-priority-queue-and-topological-sorting",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nTotol Time to complete the given course is equal to completion time of parent course + time duration of this course.\\nbut here is a twist:\\nsuppose testcase be like: [[2,3],[2,4]], time = [0,3,4,5]. if you have to complete 2, you have to complete 3 and 4 first. and complete_time[2] = time[parent] + time[2] (if out_degree of two is 0.); if you select \\'4\\' first and complete it, the outdegree of \\'2\\' will become 1 and you cannot use above time relation. after that you will select \\'3\\' and outdegree of 2 will become 0, now you can use above time relation and total time will be time[2] + time[3] = 7. but correct answer is time[2] + time[4] = 8.\\n\\nSo to avoid this error we can use priority_queue or mulitset. In priority_queue the node of shorter time will come first, so that they can be completed in the time period of node with maximum time.\\n\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minimumTime(int n, vector<vector<int>>& rel, vector<int>& time) {\\n        vector<vector<int>>adj(n+1);\\n        vector<int>o_d(n+1,0);// to store outdegree of node.\\n        for(auto&it:rel){\\n            int a= it[0], b = it[1];\\n            adj[b].push_back(a);\\n            o_d[a]++; \\n        }\\n        priority_queue<pair<int,int>,vector<pair<int,int>>,greater<pair<int,int>>>q;\\n        \\n        for(int i = 1; i<=n; i++){\\n            if(o_d[i]==0){\\n                q.push({time[i-1],i});\\n            }\\n        }\\n        \\n        int ans = 0;\\n        while(q.size()){\\n            int u = q.top().second;\\n            int w = q.top().first;\\n            q.pop();\\n            for(auto v:adj[u]){\\n                o_d[v]--;\\n                if(o_d[v]==0){\\n                    int len = time[v-1] + w;\\n                    q.push({len,v});\\n                }\\n            }\\n            ans = max(ans,w);\\n        }\\n       \\n        return ans;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Topological Sort",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumTime(int n, vector<vector<int>>& rel, vector<int>& time) {\\n        vector<vector<int>>adj(n+1);\\n        vector<int>o_d(n+1,0);// to store outdegree of node.\\n        for(auto&it:rel){\\n            int a= it[0], b = it[1];\\n            adj[b].push_back(a);\\n            o_d[a]++; \\n        }\\n        priority_queue<pair<int,int>,vector<pair<int,int>>,greater<pair<int,int>>>q;\\n        \\n        for(int i = 1; i<=n; i++){\\n            if(o_d[i]==0){\\n                q.push({time[i-1],i});\\n            }\\n        }\\n        \\n        int ans = 0;\\n        while(q.size()){\\n            int u = q.top().second;\\n            int w = q.top().first;\\n            q.pop();\\n            for(auto v:adj[u]){\\n                o_d[v]--;\\n                if(o_d[v]==0){\\n                    int len = time[v-1] + w;\\n                    q.push({len,v});\\n                }\\n            }\\n            ans = max(ans,w);\\n        }\\n       \\n        return ans;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3605313,
                "title": "similar-to-dijkstra-bfs",
                "content": "```\\nAny courses\\'s earliest starting time is max(earliest starting of its prerequisite courses)\\nnow we can visulize courses as direct graph in which edges are represntes like,\\nprerequisite of ith course ---> ith course\\nexample:\\nrelations = {{0,1},{2,1},{2,3}}\\n```\\n![graph.png](https://assets.leetcode.com/users/images/0b59c6b0-aeee-46a4-9062-4569d3119fc9_1686061445.7539082.png)\\n```\\nnow to complete course 1 we need to complete course {0 , 2}, and to complete course 2 we need to complete course 3\\nnow we can start BFS from such courses which require no any prerequisite course\\nnow problem is similiar to dijkstra only difference is its for maximum cost \\n```\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minimumTime(int n, vector<vector<int>>& relations, vector<int>& time) {\\n        map<int , bool>mapped;\\n        vector<int>distance(n + 1 , 0); /*completion time*/\\n        vector<vector<int>>Adj(n + 1);\\n        for(auto j : relations){\\n            mapped[j[1]] = true;\\n            Adj[j[0]].push_back(j[1]);\\n        }\\n        priority_queue<pair<int , int>>Courses;\\n        for(int i = 1 ; i <= n; i++)\\n            if(!mapped[i]){\\n                distance[i] = time[i - 1];\\n                /*course which has no prerequisite course*/\\n                Courses.push({distance[i] , i}); \\n            }\\n        while(!Courses.empty()){\\n            int Course = Courses.top().second;\\n            int TimeSoFar = Courses.top().first;\\n            Courses.pop();\\n            for(auto depedency : Adj[Course]){\\n                if(distance[depedency] < TimeSoFar + time[depedency - 1]){\\n                    distance[depedency] = TimeSoFar + time[depedency - 1];\\n                    Courses.push({distance[depedency] , depedency});\\n                }\\n            }\\n        }\\n        int MaxTime = *max_element(begin(distance) , end(distance));\\n        return MaxTime;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nAny courses\\'s earliest starting time is max(earliest starting of its prerequisite courses)\\nnow we can visulize courses as direct graph in which edges are represntes like,\\nprerequisite of ith course ---> ith course\\nexample:\\nrelations = {{0,1},{2,1},{2,3}}\\n```\n```\\nnow to complete course 1 we need to complete course {0 , 2}, and to complete course 2 we need to complete course 3\\nnow we can start BFS from such courses which require no any prerequisite course\\nnow problem is similiar to dijkstra only difference is its for maximum cost \\n```\n```\\nclass Solution {\\npublic:\\n    int minimumTime(int n, vector<vector<int>>& relations, vector<int>& time) {\\n        map<int , bool>mapped;\\n        vector<int>distance(n + 1 , 0); /*completion time*/\\n        vector<vector<int>>Adj(n + 1);\\n        for(auto j : relations){\\n            mapped[j[1]] = true;\\n            Adj[j[0]].push_back(j[1]);\\n        }\\n        priority_queue<pair<int , int>>Courses;\\n        for(int i = 1 ; i <= n; i++)\\n            if(!mapped[i]){\\n                distance[i] = time[i - 1];\\n                /*course which has no prerequisite course*/\\n                Courses.push({distance[i] , i}); \\n            }\\n        while(!Courses.empty()){\\n            int Course = Courses.top().second;\\n            int TimeSoFar = Courses.top().first;\\n            Courses.pop();\\n            for(auto depedency : Adj[Course]){\\n                if(distance[depedency] < TimeSoFar + time[depedency - 1]){\\n                    distance[depedency] = TimeSoFar + time[depedency - 1];\\n                    Courses.push({distance[depedency] , depedency});\\n                }\\n            }\\n        }\\n        int MaxTime = *max_element(begin(distance) , end(distance));\\n        return MaxTime;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3578180,
                "title": "java-iteration-and-recursive-both-explanation-topological-sort",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nFor each node, we will calculate maximum time required to reach the farthest leaf node in the graph from that node.\\n    Assume for a node \\'a\\' , we have a1, a2, a3 three adjancent nodes. Now we have data about maximum time which would take to reach the fathest leaf node if we start from node a1, similarly  for node a2 and a3. Say it is t1, t2 and t3. \\n    Therefore we can clearly see the time maximum time we need to reach the farthest leaf node from node \\'a\\' is equal to : time[a] + max(t1,t2,t3) where time[a] : time which will spent on node \\'a\\'. \\n\\nMemoization: \\nSince a node can be reached from more than one node. For example a -> c and b -> c \\nHere node c can be reached from node a and b. We can use memoization to store data for future references.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(N + E)\\n- Space complexity: O(N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int minimumTime2(int n, int[][] relations, int[] time) {\\n        // Without creating any transpose Graph\\n        ArrayList<ArrayList<Integer>> graph= new ArrayList<>();\\n        for ( int i=0; i < n; i++){\\n            graph.add(new ArrayList<Integer>());\\n        }\\n        for ( int i=0; i < relations.length; i++){\\n            int u = relations[i][0]-1, v = relations[i][1]-1;\\n            graph.get(u).add(v);\\n        }\\n        // graph formation completed\\n\\n        Integer[] max = new Integer[n];\\n        for ( int i=0; i < n; i++){\\n            if ( max[i] != null){\\n                continue;\\n            }\\n            max[i] = 0;\\n            Stack<Integer> stack = new Stack<>(), startStack = new Stack<>(); \\n            stack.push(i); startStack.push(0);\\n            while ( !stack.isEmpty() ){\\n                int v = stack.peek(), start = startStack.pop();\\n                ArrayList<Integer> al = graph.get(v);\\n                while ( start < al.size()){\\n                    int av = al.get(start);\\n                    if ( max[av] == null){\\n                        max[av] = 0;\\n                        // we haven\\'t processed this node yet, therefore we will first process it and then come here to process the current element later\\n                        startStack.push(start); // we will start processing from the same adjancent node where we have currently left.\\n                        stack.push(av);\\n                        startStack.push(0);\\n                        // we will stop processing other child nodes here, until we process the current child\\n                        break;\\n                    }\\n                    // it means that the child is already processed.\\n                    max[v] = (max[v] > max[av])?max[v] : max[av];\\n                    start++;\\n                }\\n                if ( start < al.size() ){\\n                    // we breaked out of while loop\\n                    continue;\\n                }\\n                max[v] += time[v];\\n                stack.pop();\\n            }\\n        }\\n\\n        int maxTime = 0;\\n        for ( int i=0; i < n; i++){\\n            maxTime = (maxTime > max[i])?maxTime : max[i];\\n        }\\n        return maxTime;\\n    }\\n\\n    // A recursive solution to implenment the above approach\\n    public int minimumTime(int n, int[][] relations, int[] time) {\\n        ArrayList<ArrayList<Integer>> graph= new ArrayList<>();\\n        for ( int i=0; i < n; i++){\\n            graph.add(new ArrayList<Integer>());\\n        }\\n        for ( int i=0; i < relations.length; i++){\\n            int u = relations[i][0]-1, v = relations[i][1]-1;\\n            graph.get(u).add(v);\\n        }\\n\\n        Integer[] max = new Integer[n];\\n        int maxTime=0;\\n        for ( int i =0; i < n; i++){\\n            if ( max[i] == null){\\n                max[i] =0;\\n                dfs(graph, max, time, i);\\n            }\\n            maxTime = (maxTime > max[i])?maxTime: max[i];\\n        }\\n        return maxTime;\\n    }\\n\\n    public void dfs(ArrayList<ArrayList<Integer>> graph, Integer[] max, int[] time, int v){\\n        ArrayList<Integer> al = graph.get(v);\\n        for ( int i =0; i < al.size(); i++){\\n            int av = al.get(i);\\n            if ( max[av] == null){\\n                max[av] = 0;\\n                dfs(graph, max, time, av);\\n            }\\n            max[v] = (max[v] > max[av])?max[v]:max[av];\\n        }\\n        max[v] += time[v];\\n    }\\n}\\n        \\n\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int minimumTime2(int n, int[][] relations, int[] time) {\\n        // Without creating any transpose Graph\\n        ArrayList<ArrayList<Integer>> graph= new ArrayList<>();\\n        for ( int i=0; i < n; i++){\\n            graph.add(new ArrayList<Integer>());\\n        }\\n        for ( int i=0; i < relations.length; i++){\\n            int u = relations[i][0]-1, v = relations[i][1]-1;\\n            graph.get(u).add(v);\\n        }\\n        // graph formation completed\\n\\n        Integer[] max = new Integer[n];\\n        for ( int i=0; i < n; i++){\\n            if ( max[i] != null){\\n                continue;\\n            }\\n            max[i] = 0;\\n            Stack<Integer> stack = new Stack<>(), startStack = new Stack<>(); \\n            stack.push(i); startStack.push(0);\\n            while ( !stack.isEmpty() ){\\n                int v = stack.peek(), start = startStack.pop();\\n                ArrayList<Integer> al = graph.get(v);\\n                while ( start < al.size()){\\n                    int av = al.get(start);\\n                    if ( max[av] == null){\\n                        max[av] = 0;\\n                        // we haven\\'t processed this node yet, therefore we will first process it and then come here to process the current element later\\n                        startStack.push(start); // we will start processing from the same adjancent node where we have currently left.\\n                        stack.push(av);\\n                        startStack.push(0);\\n                        // we will stop processing other child nodes here, until we process the current child\\n                        break;\\n                    }\\n                    // it means that the child is already processed.\\n                    max[v] = (max[v] > max[av])?max[v] : max[av];\\n                    start++;\\n                }\\n                if ( start < al.size() ){\\n                    // we breaked out of while loop\\n                    continue;\\n                }\\n                max[v] += time[v];\\n                stack.pop();\\n            }\\n        }\\n\\n        int maxTime = 0;\\n        for ( int i=0; i < n; i++){\\n            maxTime = (maxTime > max[i])?maxTime : max[i];\\n        }\\n        return maxTime;\\n    }\\n\\n    // A recursive solution to implenment the above approach\\n    public int minimumTime(int n, int[][] relations, int[] time) {\\n        ArrayList<ArrayList<Integer>> graph= new ArrayList<>();\\n        for ( int i=0; i < n; i++){\\n            graph.add(new ArrayList<Integer>());\\n        }\\n        for ( int i=0; i < relations.length; i++){\\n            int u = relations[i][0]-1, v = relations[i][1]-1;\\n            graph.get(u).add(v);\\n        }\\n\\n        Integer[] max = new Integer[n];\\n        int maxTime=0;\\n        for ( int i =0; i < n; i++){\\n            if ( max[i] == null){\\n                max[i] =0;\\n                dfs(graph, max, time, i);\\n            }\\n            maxTime = (maxTime > max[i])?maxTime: max[i];\\n        }\\n        return maxTime;\\n    }\\n\\n    public void dfs(ArrayList<ArrayList<Integer>> graph, Integer[] max, int[] time, int v){\\n        ArrayList<Integer> al = graph.get(v);\\n        for ( int i =0; i < al.size(); i++){\\n            int av = al.get(i);\\n            if ( max[av] == null){\\n                max[av] = 0;\\n                dfs(graph, max, time, av);\\n            }\\n            max[v] = (max[v] > max[av])?max[v]:max[av];\\n        }\\n        max[v] += time[v];\\n    }\\n}\\n        \\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3578175,
                "title": "using-in-degree-topological-sort-c-beginner-friendly-solution",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    int minimumTime(int n, vector<vector<int>>& relations, vector<int>& time) {\\n        vector<vector<int>> adj(n+1);\\n        vector<int> deg(n+1,0);\\n        vector<int> tt(n,0);\\n        for(auto i : relations)\\n        {\\n            adj[i[0]].push_back(i[1]);\\n            deg[i[1]]++;\\n        }\\n        int res = 0;\\n        queue<int> q;\\n        for(int i = 1; i < n+1; i++)\\n            if(deg[i] == 0)\\n            {\\n                q.push(i);\\n                tt[i-1] = time[i-1];\\n            }\\n        while(!q.empty())\\n        {\\n            int sz = q.size();\\n            while(sz--)\\n            {\\n                int u = q.front();\\n                q.pop();\\n                for(auto v : adj[u])\\n                {\\n                    deg[v]--;\\n                    tt[v-1] = max(tt[v-1], time[v-1] + tt[u-1]);\\n                    if(deg[v] == 0)\\n                    {\\n                        q.push(v);\\n                    }\\n                }\\n                res = max(res,tt[u-1]);\\n            } \\n        }\\n        return res;\\n    }\\n};\\n```\\nPlease upvote if you find the solution helpful!",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumTime(int n, vector<vector<int>>& relations, vector<int>& time) {\\n        vector<vector<int>> adj(n+1);\\n        vector<int> deg(n+1,0);\\n        vector<int> tt(n,0);\\n        for(auto i : relations)\\n        {\\n            adj[i[0]].push_back(i[1]);\\n            deg[i[1]]++;\\n        }\\n        int res = 0;\\n        queue<int> q;\\n        for(int i = 1; i < n+1; i++)\\n            if(deg[i] == 0)\\n            {\\n                q.push(i);\\n                tt[i-1] = time[i-1];\\n            }\\n        while(!q.empty())\\n        {\\n            int sz = q.size();\\n            while(sz--)\\n            {\\n                int u = q.front();\\n                q.pop();\\n                for(auto v : adj[u])\\n                {\\n                    deg[v]--;\\n                    tt[v-1] = max(tt[v-1], time[v-1] + tt[u-1]);\\n                    if(deg[v] == 0)\\n                    {\\n                        q.push(v);\\n                    }\\n                }\\n                res = max(res,tt[u-1]);\\n            } \\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3539356,
                "title": "topological-sort-clean-c-code",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> topoSort(int numNodes, vector<int> adjList[]) {\\n        queue<int> q;\\n        vector<int> inDegree(numNodes + 1, 0);\\n\\n        // Calculate in-degree for each node\\n        for (int i = 1; i <= numNodes; i++) {\\n            for (auto neighbor : adjList[i])\\n                inDegree[neighbor]++;\\n        }\\n\\n        // Push nodes with in-degree 0 into the queue\\n        for (int i = 1; i <= numNodes; i++) {\\n            if (inDegree[i] == 0) {\\n                q.push(i);\\n            }\\n        }\\n\\n        vector<int> topoOrder;\\n        while (!q.empty()) {\\n            int node = q.front();\\n            q.pop();\\n            topoOrder.push_back(node);\\n\\n            // Decrement the in-degree of adjacent nodes\\n            for (auto neighbor : adjList[node]) {\\n                inDegree[neighbor]--;\\n                if (inDegree[neighbor] == 0) {\\n                    q.push(neighbor);\\n                }\\n            }\\n        }\\n\\n        return topoOrder;\\n    }\\n\\n    int minimumTime(int numNodes, vector<vector<int>>& relationships, vector<int>& time) {\\n        vector<int> adjList[numNodes + 1];\\n        int numEdges = relationships.size();\\n\\n        // Build adjacency list\\n        for (int i = 0; i < numEdges; i++) {\\n            int from = relationships[i][0];\\n            int to = relationships[i][1];\\n            adjList[from].push_back(to);\\n        }\\n\\n        vector<int> topoOrder = topoSort(numNodes, adjList);\\n\\n        vector<int> timeReq(numNodes + 1, INT_MIN);\\n\\n        for (auto node : topoOrder) {\\n            timeReq[node] = max(timeReq[node], time[node - 1]);\\n            for (auto neighbor : adjList[node]) {\\n                timeReq[neighbor] = max(timeReq[neighbor], timeReq[node] + time[neighbor - 1]);\\n            }\\n        }\\n\\n        return *max_element(timeReq.begin(), timeReq.end());\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++",
                    "Breadth-First Search",
                    "Topological Sort"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> topoSort(int numNodes, vector<int> adjList[]) {\\n        queue<int> q;\\n        vector<int> inDegree(numNodes + 1, 0);\\n\\n        // Calculate in-degree for each node\\n        for (int i = 1; i <= numNodes; i++) {\\n            for (auto neighbor : adjList[i])\\n                inDegree[neighbor]++;\\n        }\\n\\n        // Push nodes with in-degree 0 into the queue\\n        for (int i = 1; i <= numNodes; i++) {\\n            if (inDegree[i] == 0) {\\n                q.push(i);\\n            }\\n        }\\n\\n        vector<int> topoOrder;\\n        while (!q.empty()) {\\n            int node = q.front();\\n            q.pop();\\n            topoOrder.push_back(node);\\n\\n            // Decrement the in-degree of adjacent nodes\\n            for (auto neighbor : adjList[node]) {\\n                inDegree[neighbor]--;\\n                if (inDegree[neighbor] == 0) {\\n                    q.push(neighbor);\\n                }\\n            }\\n        }\\n\\n        return topoOrder;\\n    }\\n\\n    int minimumTime(int numNodes, vector<vector<int>>& relationships, vector<int>& time) {\\n        vector<int> adjList[numNodes + 1];\\n        int numEdges = relationships.size();\\n\\n        // Build adjacency list\\n        for (int i = 0; i < numEdges; i++) {\\n            int from = relationships[i][0];\\n            int to = relationships[i][1];\\n            adjList[from].push_back(to);\\n        }\\n\\n        vector<int> topoOrder = topoSort(numNodes, adjList);\\n\\n        vector<int> timeReq(numNodes + 1, INT_MIN);\\n\\n        for (auto node : topoOrder) {\\n            timeReq[node] = max(timeReq[node], time[node - 1]);\\n            for (auto neighbor : adjList[node]) {\\n                timeReq[neighbor] = max(timeReq[neighbor], timeReq[node] + time[neighbor - 1]);\\n            }\\n        }\\n\\n        return *max_element(timeReq.begin(), timeReq.end());\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3486260,
                "title": "c-and-java-bfs-khan-s-algo-of-topo-sort",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# c++\\n```\\nclass Solution {\\npublic:\\n    int minimumTime(int n, vector<vector<int>>& relations, vector<int>& time) {\\n        vector<int> in_deg(n,0);\\n        vector<vector<int>> adj(n);\\n        for(auto& ele: relations){\\n            in_deg[ele[1]-1]++;\\n            adj[ele[0]-1].push_back(ele[1]-1);\\n        } \\n        queue<pair<int,int>> q;\\n        vector<int> arr(n,0);\\n        int ans=0;\\n        for(int i=0;i<n;i++){\\n            if(in_deg[i]==0){\\n                q.push({i,time[i]});\\n            }\\n        }\\n        while(q.size()){\\n            int s=q.size();\\n            while(s--){\\n                auto [node,t]=q.front();\\n                ans=max(ans,t);\\n                q.pop();\\n                for(int& i: adj[node]){\\n                    in_deg[i]--;\\n                    arr[i]=max(arr[i],t);\\n                    if(in_deg[i]==0) q.push({i,arr[i]+time[i]});\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```\\n# java\\n```\\nclass Solution {\\n    public int minimumTime(int n, int[][] relations, int[] time) {\\n        \\n        int in_deg[]=new int[n];\\n        List<Integer> adj[] = new ArrayList[n];\\n        for(int i=0;i<n;i++){\\n            adj[i]=new ArrayList();\\n        }\\n        for(int[] ele: relations){\\n            in_deg[ele[1]-1]++;\\n            int x=ele[0]-1;\\n            int y=ele[1]-1;\\n            adj[x].add(y);\\n        } \\n        Queue<Pair<Integer,Integer>> q=new LinkedList<>();\\n        int[] arr=new int[n];\\n        int ans=0;\\n        for(int i=0;i<n;i++){\\n            if(in_deg[i]==0){\\n                q.add(new Pair<Integer,Integer>(i,time[i]));\\n            }\\n        }\\n        while(!q.isEmpty()){\\n            int s=q.size();\\n            while((s-->0)){\\n                int node=q.peek().getKey();\\n                int t=q.peek().getValue();\\n                ans=Math.max(ans,t);\\n                q.poll();\\n                for(int i: adj[node]){\\n                    in_deg[i]--;\\n                    arr[i]=Math.max(arr[i],t);\\n                    if(in_deg[i]==0) q.add(new Pair<Integer,Integer>(i,arr[i]+time[i]));\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumTime(int n, vector<vector<int>>& relations, vector<int>& time) {\\n        vector<int> in_deg(n,0);\\n        vector<vector<int>> adj(n);\\n        for(auto& ele: relations){\\n            in_deg[ele[1]-1]++;\\n            adj[ele[0]-1].push_back(ele[1]-1);\\n        } \\n        queue<pair<int,int>> q;\\n        vector<int> arr(n,0);\\n        int ans=0;\\n        for(int i=0;i<n;i++){\\n            if(in_deg[i]==0){\\n                q.push({i,time[i]});\\n            }\\n        }\\n        while(q.size()){\\n            int s=q.size();\\n            while(s--){\\n                auto [node,t]=q.front();\\n                ans=max(ans,t);\\n                q.pop();\\n                for(int& i: adj[node]){\\n                    in_deg[i]--;\\n                    arr[i]=max(arr[i],t);\\n                    if(in_deg[i]==0) q.push({i,arr[i]+time[i]});\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```\n```\\nclass Solution {\\n    public int minimumTime(int n, int[][] relations, int[] time) {\\n        \\n        int in_deg[]=new int[n];\\n        List<Integer> adj[] = new ArrayList[n];\\n        for(int i=0;i<n;i++){\\n            adj[i]=new ArrayList();\\n        }\\n        for(int[] ele: relations){\\n            in_deg[ele[1]-1]++;\\n            int x=ele[0]-1;\\n            int y=ele[1]-1;\\n            adj[x].add(y);\\n        } \\n        Queue<Pair<Integer,Integer>> q=new LinkedList<>();\\n        int[] arr=new int[n];\\n        int ans=0;\\n        for(int i=0;i<n;i++){\\n            if(in_deg[i]==0){\\n                q.add(new Pair<Integer,Integer>(i,time[i]));\\n            }\\n        }\\n        while(!q.isEmpty()){\\n            int s=q.size();\\n            while((s-->0)){\\n                int node=q.peek().getKey();\\n                int t=q.peek().getValue();\\n                ans=Math.max(ans,t);\\n                q.poll();\\n                for(int i: adj[node]){\\n                    in_deg[i]--;\\n                    arr[i]=Math.max(arr[i],t);\\n                    if(in_deg[i]==0) q.add(new Pair<Integer,Integer>(i,arr[i]+time[i]));\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3471005,
                "title": "topological-sort-dijkastra-algo-easy-understanding",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    List<List<Integer>> adj=new ArrayList<>();\\n    public int minimumTime(int n, int[][] relations, int[] time) {\\n        for(int i=0;i<=n;i++)adj.add(new ArrayList<>());\\n        for(int a[] : relations){\\n            adj.get(a[0]).add(a[1]);\\n        }\\n\\n        if(n == 1)return time[0];\\n\\n        int indegree[]=new int[n+1];\\n        for(int a[] : relations){\\n            indegree[a[1]]++;\\n        }\\n       \\n        PriorityQueue<int []> pq=new PriorityQueue<>((x,y) -> x[0] - y[0]);\\n        for(int i=1;i<=n;i++){\\n             if(indegree[i] == 0){\\n                 int tn=time[i-1];\\n                 pq.add(new int[] {tn , i});\\n             }\\n        }\\n        \\n        int max=0;\\n        while(pq.size()>0){\\n            int cur[]=pq.remove();\\n             int dist=cur[0];\\n             int node=cur[1];\\n\\n            max=Math.max(max , dist);       // for single node component\\n\\n            for(int edg : adj.get(node)){\\n                 indegree[edg]--;\\n                 if(indegree[edg] == 0){\\n                     int newtime = dist + time[edg-1];\\n                     max=Math.max(max , newtime);\\n                     pq.add(new int[] {newtime , edg});\\n                 }\\n             }\\n        }\\n\\n        return max;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    List<List<Integer>> adj=new ArrayList<>();\\n    public int minimumTime(int n, int[][] relations, int[] time) {\\n        for(int i=0;i<=n;i++)adj.add(new ArrayList<>());\\n        for(int a[] : relations){\\n            adj.get(a[0]).add(a[1]);\\n        }\\n\\n        if(n == 1)return time[0];\\n\\n        int indegree[]=new int[n+1];\\n        for(int a[] : relations){\\n            indegree[a[1]]++;\\n        }\\n       \\n        PriorityQueue<int []> pq=new PriorityQueue<>((x,y) -> x[0] - y[0]);\\n        for(int i=1;i<=n;i++){\\n             if(indegree[i] == 0){\\n                 int tn=time[i-1];\\n                 pq.add(new int[] {tn , i});\\n             }\\n        }\\n        \\n        int max=0;\\n        while(pq.size()>0){\\n            int cur[]=pq.remove();\\n             int dist=cur[0];\\n             int node=cur[1];\\n\\n            max=Math.max(max , dist);       // for single node component\\n\\n            for(int edg : adj.get(node)){\\n                 indegree[edg]--;\\n                 if(indegree[edg] == 0){\\n                     int newtime = dist + time[edg-1];\\n                     max=Math.max(max , newtime);\\n                     pq.add(new int[] {newtime , edg});\\n                 }\\n             }\\n        }\\n\\n        return max;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3446886,
                "title": "c",
                "content": "```\\nclass Solution {\\npublic:\\n    int minimumTime(int n, vector<vector<int>>& relations, vector<int>& time) {\\n        vector<int>inDegree(n+1) ;\\n        vector<vector<int>>graph(n+1) ;\\n        for(auto& r : relations){\\n            int a = r[0] ;\\n            int b = r[1] ;\\n            graph[a].push_back(b) ;\\n            inDegree[b]++ ;\\n        }\\n        vector<int>finishTime(n+1) ;\\n        queue<int>q ;  //vertex\\n        for(int i = 1; i <= n; i++){\\n            if(inDegree[i] == 0)\\n                q.push(i) ;\\n        }\\n        \\n        while(!q.empty()){\\n            int cur = q.front() ;\\n            q.pop() ;\\n            finishTime[cur] += time[cur-1] ;\\n            for(auto& nxt : graph[cur]){\\n                inDegree[nxt]-- ;\\n                finishTime[nxt] = max(finishTime[nxt], finishTime[cur]) ;\\n                if(inDegree[nxt] == 0)\\n                    q.push(nxt) ;\\n            }\\n        }\\n        return *max_element(finishTime.begin(), finishTime.end()) ;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Topological Sort"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumTime(int n, vector<vector<int>>& relations, vector<int>& time) {\\n        vector<int>inDegree(n+1) ;\\n        vector<vector<int>>graph(n+1) ;\\n        for(auto& r : relations){\\n            int a = r[0] ;\\n            int b = r[1] ;\\n            graph[a].push_back(b) ;\\n            inDegree[b]++ ;\\n        }\\n        vector<int>finishTime(n+1) ;\\n        queue<int>q ;  //vertex\\n        for(int i = 1; i <= n; i++){\\n            if(inDegree[i] == 0)\\n                q.push(i) ;\\n        }\\n        \\n        while(!q.empty()){\\n            int cur = q.front() ;\\n            q.pop() ;\\n            finishTime[cur] += time[cur-1] ;\\n            for(auto& nxt : graph[cur]){\\n                inDegree[nxt]-- ;\\n                finishTime[nxt] = max(finishTime[nxt], finishTime[cur]) ;\\n                if(inDegree[nxt] == 0)\\n                    q.push(nxt) ;\\n            }\\n        }\\n        return *max_element(finishTime.begin(), finishTime.end()) ;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3428477,
                "title": "dfs-with-memoization-beats-90-in-python",
                "content": "# Intuition\\nTurn the relations into a graph using a dictionary with key as current course, and values pointing to the prerequisites. Then create table to hold the minimum total time needed to complete up to the current course, accounting for all the prerequisites with memoization. Then just iterate over each course number to compute the time needed to complete the course, the maximum value in the table is the total time needed to complete the program.\\n\\n# Approach\\nDFS with memoization\\n\\n# Complexity\\n- Time complexity:\\n $$O(n)$$ you calculate the time for each course at most once.\\n\\n\\n- Space complexity:\\n $$O(n)$$ since you need to have table of size n to hold time required\\n\\n# Code\\n```\\nclass Solution:\\n    def minimumTime(self, n: int, relations: List[List[int]], time: List[int]) -> int:\\n        from collections import defaultdict, deque\\n        time = [0] + time\\n        prereq_graph = defaultdict(list)\\n        \\n\\n        for prereq, course in relations:\\n            prereq_graph[course] += [prereq]\\n\\n        mincoursetimes = [0 for i in range(n+1)] \\n\\n        def months_to_current(cindex):\\n            nonlocal mincoursetimes, prereq_graph, time\\n\\n            if mincoursetimes[cindex] > 0:\\n                return mincoursetimes[cindex]\\n\\n            time_needed = 0\\n            for prereq in prereq_graph[cindex]:\\n                time_needed = max(time_needed, months_to_current(prereq))\\n            mincoursetimes[cindex] = time_needed + time[cindex]\\n            return mincoursetimes[cindex]\\n\\n        for i in range(1,n+1):\\n            _ = months_to_current(i)\\n        return max(mincoursetimes)\\n            \\n\\n\\n\\n\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minimumTime(self, n: int, relations: List[List[int]], time: List[int]) -> int:\\n        from collections import defaultdict, deque\\n        time = [0] + time\\n        prereq_graph = defaultdict(list)\\n        \\n\\n        for prereq, course in relations:\\n            prereq_graph[course] += [prereq]\\n\\n        mincoursetimes = [0 for i in range(n+1)] \\n\\n        def months_to_current(cindex):\\n            nonlocal mincoursetimes, prereq_graph, time\\n\\n            if mincoursetimes[cindex] > 0:\\n                return mincoursetimes[cindex]\\n\\n            time_needed = 0\\n            for prereq in prereq_graph[cindex]:\\n                time_needed = max(time_needed, months_to_current(prereq))\\n            mincoursetimes[cindex] = time_needed + time[cindex]\\n            return mincoursetimes[cindex]\\n\\n        for i in range(1,n+1):\\n            _ = months_to_current(i)\\n        return max(mincoursetimes)\\n            \\n\\n\\n\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3382712,
                "title": "c-easy-solution-topological-sort-priority-queue-optimal-solution",
                "content": "\\n\\n# Code\\n```\\n\\nclass Solution {\\npublic:\\n    int minimumTime(int n, vector<vector<int>>& relations, vector<int>& time) {\\n        map<int,vector<int>> mp;\\n        vector<int> indegree(n+1,0);\\n        for(int i=0;i<relations.size();i++){\\n            mp[relations[i][0]].push_back(relations[i][1]);\\n            indegree[relations[i][1]]++;\\n        }\\n        priority_queue<pair<int,int>,vector<pair<int,int>>,greater<pair<int,int>>> q;\\n        for(int i=1;i<=n;i++){\\n            if(indegree[i]==0){\\n                q.push({time[i-1],i});\\n            }\\n        }\\n        int mini=INT_MAX;\\n        while(!q.empty()){\\n            int dis=q.top().first;\\n            int node=q.top().second;\\n            q.pop();\\n            mini=dis;\\n            for(auto it:mp[node]){\\n                indegree[it]--;\\n                if(indegree[it]==0){\\n                    q.push({dis+time[it-1],it});\\n                }\\n            }\\n        }\\n        return mini;\\n    }\\n};\\n```\\n# AUTHOR: JAYESH BADGUJAR\\n\\n",
                "solutionTags": [
                    "C++",
                    "Graph",
                    "Topological Sort",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\n\\nclass Solution {\\npublic:\\n    int minimumTime(int n, vector<vector<int>>& relations, vector<int>& time) {\\n        map<int,vector<int>> mp;\\n        vector<int> indegree(n+1,0);\\n        for(int i=0;i<relations.size();i++){\\n            mp[relations[i][0]].push_back(relations[i][1]);\\n            indegree[relations[i][1]]++;\\n        }\\n        priority_queue<pair<int,int>,vector<pair<int,int>>,greater<pair<int,int>>> q;\\n        for(int i=1;i<=n;i++){\\n            if(indegree[i]==0){\\n                q.push({time[i-1],i});\\n            }\\n        }\\n        int mini=INT_MAX;\\n        while(!q.empty()){\\n            int dis=q.top().first;\\n            int node=q.top().second;\\n            q.pop();\\n            mini=dis;\\n            for(auto it:mp[node]){\\n                indegree[it]--;\\n                if(indegree[it]==0){\\n                    q.push({dis+time[it-1],it});\\n                }\\n            }\\n        }\\n        return mini;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3377502,
                "title": "python-easy-to-understand-solution",
                "content": "# Intuition\\nTreating this as a classical topological sort problem, we also need to store the indegree courses value along with the count value. \\n\\n\\n# Approach\\nWhenever the indegree count of a course reaches 0 , we know the value of prequesite courses has been completely calculated. We need to find the max value out of these prequesites and add it to the time taken for the current course value\\n\\n# Complexity\\n- Time complexity:\\nO(N^2)\\n\\n- Space complexity:\\nO(N)\\n\\n# Code\\n```\\nclass Solution:\\n    def minimumTime(self, n: int, relations: List[List[int]], time: List[int]) -> int:\\n\\n        course_completed = [0 for i in range(n)]\\n        graph = defaultdict(set)\\n        indegree_graph = [[0,set()] for i in range(n)] # [indegree_count,indegree_nodes] format\\n\\n        # form graph and indegree graph\\n        for c1,c2 in relations:\\n            if c2 not in graph[c1]:\\n                graph[c1-1].add(c2-1)\\n                indegree_graph[c2-1][1].add(c1-1)\\n                indegree_graph[c2-1][0] += 1\\n\\n        queue = deque([i for i in range(n) if indegree_graph[i][0]==0])\\n\\n        while(queue):\\n            for _ in range(len(queue)):\\n                course = queue.popleft()\\n\\n                max_value = 0\\n                for comp_courses in indegree_graph[course][1]:\\n                    max_value = max(max_value,course_completed[comp_courses])\\n\\n                course_completed[course] = time[course]+ max_value\\n\\n                for neighbor in graph[course]:\\n                    indegree_graph[neighbor][0] -= 1\\n                    if indegree_graph[neighbor][0] == 0:\\n                        queue.append(neighbor)\\n    \\n        return max(course_completed)\\n\\n        \\n```",
                "solutionTags": [
                    "Python3",
                    "Topological Sort"
                ],
                "code": "```\\nclass Solution:\\n    def minimumTime(self, n: int, relations: List[List[int]], time: List[int]) -> int:\\n\\n        course_completed = [0 for i in range(n)]\\n        graph = defaultdict(set)\\n        indegree_graph = [[0,set()] for i in range(n)] # [indegree_count,indegree_nodes] format\\n\\n        # form graph and indegree graph\\n        for c1,c2 in relations:\\n            if c2 not in graph[c1]:\\n                graph[c1-1].add(c2-1)\\n                indegree_graph[c2-1][1].add(c1-1)\\n                indegree_graph[c2-1][0] += 1\\n\\n        queue = deque([i for i in range(n) if indegree_graph[i][0]==0])\\n\\n        while(queue):\\n            for _ in range(len(queue)):\\n                course = queue.popleft()\\n\\n                max_value = 0\\n                for comp_courses in indegree_graph[course][1]:\\n                    max_value = max(max_value,course_completed[comp_courses])\\n\\n                course_completed[course] = time[course]+ max_value\\n\\n                for neighbor in graph[course]:\\n                    indegree_graph[neighbor][0] -= 1\\n                    if indegree_graph[neighbor][0] == 0:\\n                        queue.append(neighbor)\\n    \\n        return max(course_completed)\\n\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3353878,
                "title": "python-solution-topological-sort",
                "content": "```\\ndef minimumTime(self, n: int, relations: List[List[int]], time: List[int]) -> int:\\n\\tg, deg, mx, ans = defaultdict(list), [0]*n, [0]*n, 0\\n\\t# mx is used to record the max time for the previous course\\n\\tfor u, v in relations:\\n\\t\\tg[u-1].append(v-1)\\n\\t\\tdeg[v-1] += 1\\n\\tq = deque([[i, time[i]] for i in range(n) if deg[i]==0])\\n\\twhile(q):\\n\\t\\ti, t = q.popleft()\\n\\t\\tans = max(t, ans)\\n\\t\\tfor j in g[i]:\\n\\t\\t\\tdeg[j] -= 1\\n\\t\\t\\tmx[j] = max(mx[j], t)\\n\\t\\t\\tif deg[j] == 0:\\n\\t\\t\\t\\tq.append([j, time[j]+mx[j]])\\n\\treturn ans\\n```",
                "solutionTags": [],
                "code": "```\\ndef minimumTime(self, n: int, relations: List[List[int]], time: List[int]) -> int:\\n\\tg, deg, mx, ans = defaultdict(list), [0]*n, [0]*n, 0\\n\\t# mx is used to record the max time for the previous course\\n\\tfor u, v in relations:\\n\\t\\tg[u-1].append(v-1)\\n\\t\\tdeg[v-1] += 1\\n\\tq = deque([[i, time[i]] for i in range(n) if deg[i]==0])\\n\\twhile(q):\\n\\t\\ti, t = q.popleft()\\n\\t\\tans = max(t, ans)\\n\\t\\tfor j in g[i]:\\n\\t\\t\\tdeg[j] -= 1\\n\\t\\t\\tmx[j] = max(mx[j], t)\\n\\t\\t\\tif deg[j] == 0:\\n\\t\\t\\t\\tq.append([j, time[j]+mx[j]])\\n\\treturn ans\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3346908,
                "title": "java-bfs-kahn-s-algorithm",
                "content": "```\\nclass Solution {\\n    public int minimumTime(int n, int[][] relations, int[] time) {\\n        int V = n+1;\\n        int ans = 0;\\n        ArrayList<HashSet<Integer>> adj = new ArrayList<>();\\n        int[] inOrder = new int[V];\\n        for(int i = 0 ; i < V ; i++) adj.add(new HashSet<>());\\n        for(int i = 0 ; i < relations.length ; i++){\\n            int s = relations[i][0];\\n            int e = relations[i][1];\\n            adj.get(s).add(e);\\n            inOrder[e]++;\\n            \\n        }\\n        Queue<Integer> queue = new LinkedList<>();\\n        for(int i = 0 ; i < V ; i++){\\n            if(inOrder[i] == 0){\\n                queue.offer(i);\\n            }\\n        }\\n        int[] max = new int[V];\\n        while(!queue.isEmpty()){\\n            int curNode = queue.poll();\\n            for(int ele : adj.get(curNode)){\\n                inOrder[ele]--;\\n                max[ele] = Math.max(time[curNode - 1] + max[curNode] , max[ele]);\\n                if(inOrder[ele] == 0){\\n                    queue.offer(ele);\\n                }\\n            }\\n            if(curNode != 0){\\n                ans = Math.max(ans , max[curNode] + time[curNode - 1]);    \\n            }\\n            \\n        }\\n        return ans;\\n    }\\n}\\n```\\n**Please upVote, if found useful :)**",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int minimumTime(int n, int[][] relations, int[] time) {\\n        int V = n+1;\\n        int ans = 0;\\n        ArrayList<HashSet<Integer>> adj = new ArrayList<>();\\n        int[] inOrder = new int[V];\\n        for(int i = 0 ; i < V ; i++) adj.add(new HashSet<>());\\n        for(int i = 0 ; i < relations.length ; i++){\\n            int s = relations[i][0];\\n            int e = relations[i][1];\\n            adj.get(s).add(e);\\n            inOrder[e]++;\\n            \\n        }\\n        Queue<Integer> queue = new LinkedList<>();\\n        for(int i = 0 ; i < V ; i++){\\n            if(inOrder[i] == 0){\\n                queue.offer(i);\\n            }\\n        }\\n        int[] max = new int[V];\\n        while(!queue.isEmpty()){\\n            int curNode = queue.poll();\\n            for(int ele : adj.get(curNode)){\\n                inOrder[ele]--;\\n                max[ele] = Math.max(time[curNode - 1] + max[curNode] , max[ele]);\\n                if(inOrder[ele] == 0){\\n                    queue.offer(ele);\\n                }\\n            }\\n            if(curNode != 0){\\n                ans = Math.max(ans , max[curNode] + time[curNode - 1]);    \\n            }\\n            \\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3306433,
                "title": "java-solution-from-huifeng-guan-youtube-video",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nhttps://www.youtube.com/watch?v=DoSJGW5aw8k\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int minimumTime(int n, int[][] relations, int[] time) {\\n        Map<Integer, Set<Integer>> next = new HashMap();\\n        int[] indegree = new int[n+1];\\n\\n        for (int[] relation: relations) {\\n            Set<Integer> set = next.getOrDefault(relation[0], new HashSet());\\n            set.add(relation[1]);\\n            next.put(relation[0], set);\\n            indegree[relation[1]]++;\\n        }\\n\\n        Queue<Integer> q = new LinkedList();\\n        int[] t = new int[n+1];\\n\\n        for (int i = 1; i <= n; i++) {\\n            if (indegree[i] == 0) {\\n                q.add(i);\\n                t[i] = time[i-1];\\n            }\\n        }\\n        // System.out.print(\"next:\"+next+\"\\\\n\");\\n        // System.out.print(\"indegree\"+Arrays.toString(indegree)+\"\\\\n\");\\n\\n        int ret = 0;\\n        while (!q.isEmpty()) {\\n\\n            int cur = q.poll();\\n\\n            if (next.containsKey(cur)) {\\n                for (int nxt : next.get(cur)) {\\n                    t[nxt] = Math.max(t[nxt], time[nxt-1] + t[cur]);\\n                    indegree[nxt]--;\\n                    if (indegree[nxt] == 0) {\\n                        q.add(nxt);\\n                    }\\n                }\\n            }\\n\\n            \\n        }\\n\\n        for (int j : t) {\\n            ret = Math.max(ret, j);\\n        }\\n\\n        return ret;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Topological Sort"
                ],
                "code": "```\\nclass Solution {\\n    public int minimumTime(int n, int[][] relations, int[] time) {\\n        Map<Integer, Set<Integer>> next = new HashMap();\\n        int[] indegree = new int[n+1];\\n\\n        for (int[] relation: relations) {\\n            Set<Integer> set = next.getOrDefault(relation[0], new HashSet());\\n            set.add(relation[1]);\\n            next.put(relation[0], set);\\n            indegree[relation[1]]++;\\n        }\\n\\n        Queue<Integer> q = new LinkedList();\\n        int[] t = new int[n+1];\\n\\n        for (int i = 1; i <= n; i++) {\\n            if (indegree[i] == 0) {\\n                q.add(i);\\n                t[i] = time[i-1];\\n            }\\n        }\\n        // System.out.print(\"next:\"+next+\"\\\\n\");\\n        // System.out.print(\"indegree\"+Arrays.toString(indegree)+\"\\\\n\");\\n\\n        int ret = 0;\\n        while (!q.isEmpty()) {\\n\\n            int cur = q.poll();\\n\\n            if (next.containsKey(cur)) {\\n                for (int nxt : next.get(cur)) {\\n                    t[nxt] = Math.max(t[nxt], time[nxt-1] + t[cur]);\\n                    indegree[nxt]--;\\n                    if (indegree[nxt] == 0) {\\n                        q.add(nxt);\\n                    }\\n                }\\n            }\\n\\n            \\n        }\\n\\n        for (int j : t) {\\n            ret = Math.max(ret, j);\\n        }\\n\\n        return ret;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3214839,
                "title": "identical-usaco-problem-w-python3-solution",
                "content": "This problem might be the same as this USACO problem from a decade back:\\nhttp://usaco.org/index.php?page=viewproblem2&cpid=246\\n\\nI thought I\\'d bring this up since maybe their editorial will be helpful to some as an additional resource: http://usaco.org/current/data/sol_msched_feb13.html\\n\\nIn any case, here\\'s my AC solution:\\n```py\\nclass Solution:\\n    def minimumTime(self, n: int, relations: List[List[int]], time: List[int]) -> int:\\n        dag = defaultdict(set)\\n        for a, b in relations:\\n            dag[a - 1].add(b - 1)\\n        \\n        @lru_cache(None)\\n        def dp(curr):\\n            if not dag[curr]:\\n                return time[curr]\\n\\n            return max(time[curr] + dp(child) for child in dag[curr])\\n        \\n        return max(map(dp, range(n)))\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```py\\nclass Solution:\\n    def minimumTime(self, n: int, relations: List[List[int]], time: List[int]) -> int:\\n        dag = defaultdict(set)\\n        for a, b in relations:\\n            dag[a - 1].add(b - 1)\\n        \\n        @lru_cache(None)\\n        def dp(curr):\\n            if not dag[curr]:\\n                return time[curr]\\n\\n            return max(time[curr] + dp(child) for child in dag[curr])\\n        \\n        return max(map(dp, range(n)))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3145533,
                "title": "basic-topological-sort-with-explanation-98-faster",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> adj;\\n    int minimumTime(int n, vector<vector<int>>& edge, vector<int>& time) {\\n        adj.resize(n);\\n        vector<int> indegree(n), mxtime(n);\\n        for(vector<int>& e : edge){\\n            int from = e[0] - 1, to = e[1] - 1;\\n            adj[from].push_back(to);\\n            indegree[to]++;\\n        }\\n        // for every node we calculate the maximum time it took to reach that node from any of its children\\n        // catch is  : \\n        // suppose\\n        /*\\n            1----2--3--5--|\\n                          |\\n                      7---8\\n                          |\\n            4----6--------|  \\n            Suppose this is the graph where time[i] =  i\\n            so while we started course 1 and 4 and 7 at the same time,\\n            Course 1 gets finished in 1 month .. course 4 and 7 are still ongoing, in the meantime we can start course 2\\n            similarly now course 2 gets finished so we can start course 3 and so on so forth\\n            \\n            Now, when course 7 gets completed .. ongoing courses are course 5 and course 6 \\n            here we cannot start course 8 because all of its prerequisites are not completed\\n            \\n            hence course 8 will only be accessible when course 5 ends ( which is the longest path till we reach 8)\\n        */\\n        queue<int> q;\\n        for(int i = 0; i < n; ++i){\\n            if(indegree[i] == 0){\\n                q.push(i);\\n                mxtime[i] = time[i];\\n            }\\n        }\\n        while(q.size()){\\n            int top = q.front(); q.pop();\\n            for(int& ch : adj[top]){\\n                indegree[ch]--;\\n                mxtime[ch] = max(mxtime[ch], mxtime[top] + time[ch]);\\n                if(indegree[ch] == 0){\\n                    q.push(ch);\\n                }\\n            }\\n        }\\n        return *max_element(begin(mxtime), end(mxtime));\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Breadth-First Search",
                    "Topological Sort"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> adj;\\n    int minimumTime(int n, vector<vector<int>>& edge, vector<int>& time) {\\n        adj.resize(n);\\n        vector<int> indegree(n), mxtime(n);\\n        for(vector<int>& e : edge){\\n            int from = e[0] - 1, to = e[1] - 1;\\n            adj[from].push_back(to);\\n            indegree[to]++;\\n        }\\n        // for every node we calculate the maximum time it took to reach that node from any of its children\\n        // catch is  : \\n        // suppose\\n        /*\\n            1----2--3--5--|\\n                          |\\n                      7---8\\n                          |\\n            4----6--------|  \\n            Suppose this is the graph where time[i] =  i\\n            so while we started course 1 and 4 and 7 at the same time,\\n            Course 1 gets finished in 1 month .. course 4 and 7 are still ongoing, in the meantime we can start course 2\\n            similarly now course 2 gets finished so we can start course 3 and so on so forth\\n            \\n            Now, when course 7 gets completed .. ongoing courses are course 5 and course 6 \\n            here we cannot start course 8 because all of its prerequisites are not completed\\n            \\n            hence course 8 will only be accessible when course 5 ends ( which is the longest path till we reach 8)\\n        */\\n        queue<int> q;\\n        for(int i = 0; i < n; ++i){\\n            if(indegree[i] == 0){\\n                q.push(i);\\n                mxtime[i] = time[i];\\n            }\\n        }\\n        while(q.size()){\\n            int top = q.front(); q.pop();\\n            for(int& ch : adj[top]){\\n                indegree[ch]--;\\n                mxtime[ch] = max(mxtime[ch], mxtime[top] + time[ch]);\\n                if(indegree[ch] == 0){\\n                    q.push(ch);\\n                }\\n            }\\n        }\\n        return *max_element(begin(mxtime), end(mxtime));\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3131563,
                "title": "c-solution-toposort",
                "content": "\\n# Code\\n```\\n// Time Complexity: O(V+E) + O(n) + O(n)\\n// Space Complexity: O(V+E) + O(n) + O(n)\\nclass Solution {\\npublic:\\n    int minimumTime(int n, vector<vector<int>>& relations, vector<int>& time) {\\n        // create an adjacency list\\n        vector<vector<int>>adjList(n+1,vector<int>());\\n        \\n        // to store in-degree of each vertex\\n        vector<int>inDegree(n+1,0);\\n\\n        for(auto it: relations)\\n           {\\n               adjList[it[0]].push_back(it[1]);\\n               inDegree[it[1]]++;\\n           }\\n         // to store minimum time to finish course\\n        vector<int>requiredT(n+1,0);\\n\\n        // Pick all the vertex which have in-degree to zero\\n        queue<pair<int,int>>q;\\n        for(int i=1;i<=n;i++)\\n          if(!inDegree[i])\\n            {q.push({time[i-1],i});\\n            requiredT[i]=time[i-1];}\\n\\n       \\n        while(!q.empty())\\n        {\\n            auto it=q.front();\\n            q.pop();\\n            int t=it.first;\\n            int node=it.second;\\n\\n            // traverse over neighbor nodes\\n            for(auto adjNode: adjList[node])\\n            {\\n                // update inDegree of that vertex\\n                inDegree[adjNode]--;\\n                int new_t=time[adjNode-1]+t;\\n                requiredT[adjNode]=max(requiredT[adjNode],new_t);\\n                if(!inDegree[adjNode])\\n                   q.push({requiredT[adjNode],adjNode});  \\n                \\n            }\\n        }\\n\\n        int ans=0;\\n        for(int i=1;i<requiredT.size();i++)\\n          ans=max(ans,requiredT[i]); \\n\\n        return ans;       \\n    }\\n};\\n```\\n![upvote.jpeg](https://assets.leetcode.com/users/images/93fdaba4-b653-49ac-a807-f1ff20fde17d_1675341895.1962063.jpeg)\\n",
                "solutionTags": [
                    "C++",
                    "Graph",
                    "Topological Sort"
                ],
                "code": "```\\n// Time Complexity: O(V+E) + O(n) + O(n)\\n// Space Complexity: O(V+E) + O(n) + O(n)\\nclass Solution {\\npublic:\\n    int minimumTime(int n, vector<vector<int>>& relations, vector<int>& time) {\\n        // create an adjacency list\\n        vector<vector<int>>adjList(n+1,vector<int>());\\n        \\n        // to store in-degree of each vertex\\n        vector<int>inDegree(n+1,0);\\n\\n        for(auto it: relations)\\n           {\\n               adjList[it[0]].push_back(it[1]);\\n               inDegree[it[1]]++;\\n           }\\n         // to store minimum time to finish course\\n        vector<int>requiredT(n+1,0);\\n\\n        // Pick all the vertex which have in-degree to zero\\n        queue<pair<int,int>>q;\\n        for(int i=1;i<=n;i++)\\n          if(!inDegree[i])\\n            {q.push({time[i-1],i});\\n            requiredT[i]=time[i-1];}\\n\\n       \\n        while(!q.empty())\\n        {\\n            auto it=q.front();\\n            q.pop();\\n            int t=it.first;\\n            int node=it.second;\\n\\n            // traverse over neighbor nodes\\n            for(auto adjNode: adjList[node])\\n            {\\n                // update inDegree of that vertex\\n                inDegree[adjNode]--;\\n                int new_t=time[adjNode-1]+t;\\n                requiredT[adjNode]=max(requiredT[adjNode],new_t);\\n                if(!inDegree[adjNode])\\n                   q.push({requiredT[adjNode],adjNode});  \\n                \\n            }\\n        }\\n\\n        int ans=0;\\n        for(int i=1;i<requiredT.size();i++)\\n          ans=max(ans,requiredT[i]); \\n\\n        return ans;       \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3121361,
                "title": "c-o-n-log-n-topological-sort",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nSince there is a priority between courses and the courses can be tken simultaneously, topological sort should be taken into consideration.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nBuild a directed acyclic graph with edges from prerequisite courses to next coures and also keep track of the in-degree of each course. One can refer the in-degree of a course as the number of prerequisite courses that are not yet finished.\\n\\nThen do the topological sort, collecting courses with no pre-requisite(i.e. `in-degree = 0`) and store them in a min-heap as (finishing time, course number).\\n\\nTake the course `course_id` with earliest finishing time `end_time` from the min-heap and update the finish time by `end_time`. Then reduce the in-degree of the `next_course` of `course_id` by one. (because their prerequisite course `course_id` is now finished)\\n1. Start taking **all** the next course of `course_id` with in-degree `=0` at `end_time` and push them into the min-heap.\\n2. Ignore any other `next_course` with in-degree $> 0$ since they have some uncompleted prerequisite.\\n3. Repeat the process until the min-heap is empty.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n$O(n\\\\log n)$\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n$O(n)$\\n# Code\\n```\\ntypedef pair<int, int> pii;\\n\\nclass Solution {\\npublic:\\n    int minimumTime(int n, vector<vector<int>>& relations, vector<int>& time) {\\n        int indeg[n];\\n        memset(indeg, 0, sizeof(indeg));\\n        vector<vector<int>> graph(n);\\n        for (auto &v: relations) {\\n            ++indeg[v[1]-1];\\n            graph[v[0]-1].push_back(v[1]-1);\\n        }\\n\\n        int cur_time = 0;\\n        // (finish time, node course_id)\\n        priority_queue<pii, vector<pii>, greater<pii>> pq;\\n        for (int i = 0; i <n; ++i) {\\n            if (indeg[i] == 0) pq.push({cur_time + time[i], i});\\n        }\\n\\n        while (!pq.empty()) {\\n            auto [endtime, course_id] = pq.top();\\n            pq.pop();\\n            for (int next_course: graph[course_id]) {\\n                if (--indeg[next_course] == 0) {\\n                    pq.push({endtime + time[next_course], next_course});\\n                }\\n            }\\n            cur_time = endtime;\\n        }\\n        return cur_time;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Topological Sort"
                ],
                "code": "```\\ntypedef pair<int, int> pii;\\n\\nclass Solution {\\npublic:\\n    int minimumTime(int n, vector<vector<int>>& relations, vector<int>& time) {\\n        int indeg[n];\\n        memset(indeg, 0, sizeof(indeg));\\n        vector<vector<int>> graph(n);\\n        for (auto &v: relations) {\\n            ++indeg[v[1]-1];\\n            graph[v[0]-1].push_back(v[1]-1);\\n        }\\n\\n        int cur_time = 0;\\n        // (finish time, node course_id)\\n        priority_queue<pii, vector<pii>, greater<pii>> pq;\\n        for (int i = 0; i <n; ++i) {\\n            if (indeg[i] == 0) pq.push({cur_time + time[i], i});\\n        }\\n\\n        while (!pq.empty()) {\\n            auto [endtime, course_id] = pq.top();\\n            pq.pop();\\n            for (int next_course: graph[course_id]) {\\n                if (--indeg[next_course] == 0) {\\n                    pq.push({endtime + time[next_course], next_course});\\n                }\\n            }\\n            cur_time = endtime;\\n        }\\n        return cur_time;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3097471,
                "title": "topological-sort-unlike-others-by-reversing-edges",
                "content": "```\\nint minimumTime(int n, vector<vector<int>>& relations, vector<int>& time) {\\n        vector<int>inDegree(n),dist(n,INT_MIN);\\n        vector<int>adj[n];\\n        for (auto edge:relations) {\\n            int prev=edge[1]-1,next=edge[0]-1;\\n            adj[prev].push_back(next);\\n            inDegree[next]++;\\n        }\\n        queue<int>q;\\n        for (int u=0;u<n;u++){\\n            if(!inDegree[u]) \\n                q.push(u);\\n            dist[u]=time[u];\\n        }\\n        \\n        while (!q.empty()) {\\n            int u=q.front();q.pop();\\n            for (auto v:adj[u]){\\n                dist[v]=max(dist[v],dist[u]+time[v]);\\n                if (--inDegree[v]==0) \\n                    q.push(v);\\n            }\\n        }\\n        return *max_element(dist.begin(), dist.end());\\n    }",
                "solutionTags": [
                    "C++",
                    "Breadth-First Search",
                    "Topological Sort"
                ],
                "code": "```\\nint minimumTime(int n, vector<vector<int>>& relations, vector<int>& time) {\\n        vector<int>inDegree(n),dist(n,INT_MIN);\\n        vector<int>adj[n];\\n        for (auto edge:relations) {\\n            int prev=edge[1]-1,next=edge[0]-1;\\n            adj[prev].push_back(next);\\n            inDegree[next]++;\\n        }\\n        queue<int>q;\\n        for (int u=0;u<n;u++){\\n            if(!inDegree[u]) \\n                q.push(u);\\n            dist[u]=time[u];\\n        }\\n        \\n        while (!q.empty()) {\\n            int u=q.front();q.pop();\\n            for (auto v:adj[u]){\\n                dist[v]=max(dist[v],dist[u]+time[v]);\\n                if (--inDegree[v]==0) \\n                    q.push(v);\\n            }\\n        }\\n        return *max_element(dist.begin(), dist.end());\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 3085370,
                "title": "golang-topological-sort-wait-time",
                "content": "```go\\nfunc minimumTime(n int, relations [][]int, time []int) int {\\n  // Let\\'s form the adjacency list and compute indegrees so we can do a topological\\n  // sorting on the courses and complete the ones that don\\'t have any prerequisites first.\\n  adjacencyList := make([][]int, n+1)\\n  indegrees := make([]int, n+1)\\n  for _, relation := range relations {\\n    adjacencyList[relation[0]] = append(adjacencyList[relation[0]], relation[1])\\n    indegrees[relation[1]]++\\n  }\\n  // We\\'re also going to keep track of the wait time it takes to complete the courses\\n  waitTime := make([]int, n+1)\\n  var queue []int\\n  for i := 1; i <= n; i++ {\\n    if indegrees[i] == 0 {\\n      queue = append(queue, i)\\n    }\\n  }\\n  var course int\\n  for len(queue) > 0 {\\n    course, queue = queue[0], queue[1:]\\n    for _, next := range adjacencyList[course] {\\n      curr := waitTime[course] + time[course-1]\\n      waitTime[next] = max(waitTime[next], curr)\\n      indegrees[next]--\\n      if indegrees[next] == 0 {\\n        queue = append(queue, next)\\n      }\\n    }\\n  }\\n  // Let\\'s go through all the courses one more time and find the course that takes\\n  // the longest to complete (waitTime[course] + time[course])\\n  var res int\\n  for i := 1; i <= n; i++ {\\n    res = max(res, waitTime[i]+time[i-1])\\n  }\\n  return res\\n}\\n\\nfunc max(a, b int) int {\\n  if a > b {\\n    return a\\n  }\\n  return b\\n}\\n```",
                "solutionTags": [
                    "Go",
                    "Topological Sort"
                ],
                "code": "```go\\nfunc minimumTime(n int, relations [][]int, time []int) int {\\n  // Let\\'s form the adjacency list and compute indegrees so we can do a topological\\n  // sorting on the courses and complete the ones that don\\'t have any prerequisites first.\\n  adjacencyList := make([][]int, n+1)\\n  indegrees := make([]int, n+1)\\n  for _, relation := range relations {\\n    adjacencyList[relation[0]] = append(adjacencyList[relation[0]], relation[1])\\n    indegrees[relation[1]]++\\n  }\\n  // We\\'re also going to keep track of the wait time it takes to complete the courses\\n  waitTime := make([]int, n+1)\\n  var queue []int\\n  for i := 1; i <= n; i++ {\\n    if indegrees[i] == 0 {\\n      queue = append(queue, i)\\n    }\\n  }\\n  var course int\\n  for len(queue) > 0 {\\n    course, queue = queue[0], queue[1:]\\n    for _, next := range adjacencyList[course] {\\n      curr := waitTime[course] + time[course-1]\\n      waitTime[next] = max(waitTime[next], curr)\\n      indegrees[next]--\\n      if indegrees[next] == 0 {\\n        queue = append(queue, next)\\n      }\\n    }\\n  }\\n  // Let\\'s go through all the courses one more time and find the course that takes\\n  // the longest to complete (waitTime[course] + time[course])\\n  var res int\\n  for i := 1; i <= n; i++ {\\n    res = max(res, waitTime[i]+time[i-1])\\n  }\\n  return res\\n}\\n\\nfunc max(a, b int) int {\\n  if a > b {\\n    return a\\n  }\\n  return b\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3071671,
                "title": "topological-sort-time-complexity-o-n2-space-complexity-o-n",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nTopologically count Completion time\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nStep:\\n1. Include not dependent node(Subject).\\n2. Traverse connected nodes. If any node complete all input node traversing then include that node  in queue.\\n3. In the traverse process update maximum Completion time according to node.\\n4. Take maximum \"completion time\" of all nodes as output\\n\\n\\n# Complexity\\n- Time complexity:$$O(n2)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:$$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n \\nimport java.util.*;\\nimport java.util.stream.IntStream;\\n\\nclass Solution {\\n    public static void main(String[] args) {\\n        Solution solution = new Solution();\\n\\n        int[] time = new int[]{1, 2, 3, 4, 5};\\n        int[][] relations = new int[][]{{1, 5}, {2, 5}, {3, 5}, {3, 4}, {4, 5}};\\n        int n = 5;\\n        int time = solution.minimumTime(n, relations, time);\\n        System.out.println(time);\\n\\n\\n    }\\n    //O(|V|*|V|)\\n    public int minimumTime(int n, int[][] relations, int[] time) {\\n\\n        int completeTime[] = new int[n] ; \\n        Deque<Integer> queue = new ArrayDeque<Integer>();\\n        int indegree[] = new int[n];\\n\\n        List<Integer>[] con = new ArrayList[n];\\n        Arrays.setAll(con, e -> new ArrayList<Integer>());\\n\\n \\n\\n        \\n        for (int[] r : relations) {\\n            con[r[0] - 1].add(r[1] - 1);\\n            indegree[r[1] - 1]++;\\n        }\\n\\n        //O(|V|)\\n        for (int i = 0; i < n; i++) {\\n            if (indegree[i] == 0) {\\n                completeTime[i] = time[i];\\n                queue.addFirst(i);\\n            }\\n        }\\n \\n        //O(|V|*|V|)\\n        while (queue.size() > 0) {\\n            Integer u = queue.pollLast();\\n            //O(|V|)\\n            for (Integer v : con[u]) {\\n                completeTime[v] = Math.max(completeTime[v], completeTime[u] + time[v]);\\n\\n                if (--indegree[v] == 0) {\\n                    queue.addFirst(v);\\n                }\\n            }\\n        }\\n\\n\\n        return IntStream.of(completeTime).max().getAsInt();\\n\\n    }\\n\\n  \\n\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Breadth-First Search",
                    "Topological Sort"
                ],
                "code": "```\\n \\nimport java.util.*;\\nimport java.util.stream.IntStream;\\n\\nclass Solution {\\n    public static void main(String[] args) {\\n        Solution solution = new Solution();\\n\\n        int[] time = new int[]{1, 2, 3, 4, 5};\\n        int[][] relations = new int[][]{{1, 5}, {2, 5}, {3, 5}, {3, 4}, {4, 5}};\\n        int n = 5;\\n        int time = solution.minimumTime(n, relations, time);\\n        System.out.println(time);\\n\\n\\n    }\\n    //O(|V|*|V|)\\n    public int minimumTime(int n, int[][] relations, int[] time) {\\n\\n        int completeTime[] = new int[n] ; \\n        Deque<Integer> queue = new ArrayDeque<Integer>();\\n        int indegree[] = new int[n];\\n\\n        List<Integer>[] con = new ArrayList[n];\\n        Arrays.setAll(con, e -> new ArrayList<Integer>());\\n\\n \\n\\n        \\n        for (int[] r : relations) {\\n            con[r[0] - 1].add(r[1] - 1);\\n            indegree[r[1] - 1]++;\\n        }\\n\\n        //O(|V|)\\n        for (int i = 0; i < n; i++) {\\n            if (indegree[i] == 0) {\\n                completeTime[i] = time[i];\\n                queue.addFirst(i);\\n            }\\n        }\\n \\n        //O(|V|*|V|)\\n        while (queue.size() > 0) {\\n            Integer u = queue.pollLast();\\n            //O(|V|)\\n            for (Integer v : con[u]) {\\n                completeTime[v] = Math.max(completeTime[v], completeTime[u] + time[v]);\\n\\n                if (--indegree[v] == 0) {\\n                    queue.addFirst(v);\\n                }\\n            }\\n        }\\n\\n\\n        return IntStream.of(completeTime).max().getAsInt();\\n\\n    }\\n\\n  \\n\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3046021,
                "title": "c-solution-using-topological-sort",
                "content": "\\n\\n# Complexity\\n- Time complexity:O(m+n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minimumTime(int n, vector<vector<int>>& relations, vector<int>& time) {\\n        queue<int> q;\\n        vector<vector<int>> adj(n+1);\\n        vector<int> rest(n+1,0);\\n        vector<int> indeg(n+1);\\n        for(int i = 0;i<relations.size();i++)\\n        {\\n            adj[relations[i][0]].push_back(relations[i][1]);\\n            indeg[relations[i][1]]++;\\n        }\\n        for(int i=1;i<=n;i++)\\n        {\\n            if(indeg[i] == 0)\\n            {\\n                q.push(i);\\n                rest[i] = time[i-1];\\n            }\\n        }\\n        int result = 0;\\n        while(q.empty() == 0)\\n        {\\n            int size = q.size();\\n            while(size--)\\n            {\\n                int u = q.front();\\n                q.pop();\\n             \\n                for(int v:adj[u])\\n                {\\n                    indeg[v]--;\\n                    rest[v] = max(rest[v],rest[u]+time[v-1]);\\n                    if(indeg[v] == 0)\\n                    {\\n                        q.push(v);\\n                    }\\n                }    \\n            }\\n            \\n        }\\n        result = *max_element(rest.begin(),rest.end());\\n        return result;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Topological Sort"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumTime(int n, vector<vector<int>>& relations, vector<int>& time) {\\n        queue<int> q;\\n        vector<vector<int>> adj(n+1);\\n        vector<int> rest(n+1,0);\\n        vector<int> indeg(n+1);\\n        for(int i = 0;i<relations.size();i++)\\n        {\\n            adj[relations[i][0]].push_back(relations[i][1]);\\n            indeg[relations[i][1]]++;\\n        }\\n        for(int i=1;i<=n;i++)\\n        {\\n            if(indeg[i] == 0)\\n            {\\n                q.push(i);\\n                rest[i] = time[i-1];\\n            }\\n        }\\n        int result = 0;\\n        while(q.empty() == 0)\\n        {\\n            int size = q.size();\\n            while(size--)\\n            {\\n                int u = q.front();\\n                q.pop();\\n             \\n                for(int v:adj[u])\\n                {\\n                    indeg[v]--;\\n                    rest[v] = max(rest[v],rest[u]+time[v-1]);\\n                    if(indeg[v] == 0)\\n                    {\\n                        q.push(v);\\n                    }\\n                }    \\n            }\\n            \\n        }\\n        result = *max_element(rest.begin(),rest.end());\\n        return result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3036092,
                "title": "simple-top-down-1d-dp-there-is-trap-in-description",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\nit\\'s limitaion is almost zero.. i personaly thinks it it not make sence, but..\\nfollowing description, u can take course whatever you want at any time, at the same time..\\n\\nso, cases you must calculation quite be simple, \\n\\ncalculate maximum time to take courses\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def minimumTime(self, n: int, relations: List[List[int]], time: List[int]) -> int:\\n        graph = defaultdict(list)\\n\\n        for required, course in relations:\\n            graph[course].append(required)\\n        \\n\\n        @cache\\n        def dp(i):\\n            if not graph.get(i, False):\\n                return time[i-1]\\n\\n            taken = -1\\n            for j in graph[i]:\\n                taken = max(taken, dp(j))\\n\\n            return taken + time[i-1]\\n\\n\\n        return max([dp(i+1) for i in range(n)])\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minimumTime(self, n: int, relations: List[List[int]], time: List[int]) -> int:\\n        graph = defaultdict(list)\\n\\n        for required, course in relations:\\n            graph[course].append(required)\\n        \\n\\n        @cache\\n        def dp(i):\\n            if not graph.get(i, False):\\n                return time[i-1]\\n\\n            taken = -1\\n            for j in graph[i]:\\n                taken = max(taken, dp(j))\\n\\n            return taken + time[i-1]\\n\\n\\n        return max([dp(i+1) for i in range(n)])\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3015805,
                "title": "python3-dfs-memoization-to-produce-efficient-topological-sort",
                "content": "# Intuition + Approach\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nSee page 612 of Introduction to Algorithms 3rd edition by Cormen, Leiserson, Rivest, Stein (https://sd.blackball.lv/library/Introduction_to_Algorithms_Third_Edition_(2009).pdf)\\nIn short, you can think of a DAG as a graph which can be read from left to right (leaf nodes on the left: courses which have no prereqs, terminal nodes on the right: courses which are not prereqs for any other class). In this algorithm we start at the terminal nodes and work our way back. \\n\\nAt each non-leaf node there are potentially many prerequisite courses you need to take, but in this problem we only care about the longest prereq, so we retain the `max()` of each dfs call. \\n\\nWe implement memoization so that the algorithm can re-use computed answers. \\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(V) for the main for loop, and O(E + V) for the dfs call. Since we implement memoization, we will only explore the graph one time, and the several DFS calls will all add up to O(E + V); thus the complexity is O(E + V)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nDue to the memoization, we need O(V) space to store our previous results.\\n\\n# Code\\n```\\nclass Solution:\\n    \"\"\"\\n    Determine the topological ordering of courses and the path to follow each topo sorted ordering;\\n    for unrelated graph components, return the maximum between the two\\n    \"\"\"\\n    def minimumTime(self, n: int, relations: List[List[int]], time: List[int]) -> int:\\n        \\n        graph = collections.defaultdict(list)\\n        for prevC, nextC in relations:\\n            if nextC not in graph:\\n                graph[nextC] = [prevC]\\n            else:\\n                graph[nextC].append(prevC)\\n\\n        seenNode = collections.defaultdict(int)\\n        def dfs(nodeId):\\n\\n            if nodeId in seenNode:\\n                return seenNode[nodeId]\\n\\n            ancestors = graph[nodeId]\\n            \\n            longestTimeToLeaf = 0\\n            for a in ancestors:\\n                timeToLeaf = dfs(a)\\n                longestTimeToLeaf = max(longestTimeToLeaf, timeToLeaf)\\n\\n            leafToNode = time[nodeId - 1] + longestTimeToLeaf\\n            seenNode[nodeId] = leafToNode\\n            return leafToNode\\n\\n        longestPath = -1\\n        for nodeId in range(1, n+1):\\n\\n            # go back up the DAG ; right to left(DAG goes from children on left to ancestors on right)\\n            timeToReachLeaf = dfs(nodeId)\\n            print(timeToReachLeaf)\\n\\n            # we are going to revisit nodes pretty often; need to memoize\\n            longestPath = max(longestPath, timeToReachLeaf)\\n        \\n        return longestPath\\n```",
                "solutionTags": [
                    "Python3",
                    "Depth-First Search",
                    "Topological Sort",
                    "Memoization"
                ],
                "code": "```\\nclass Solution:\\n    \"\"\"\\n    Determine the topological ordering of courses and the path to follow each topo sorted ordering;\\n    for unrelated graph components, return the maximum between the two\\n    \"\"\"\\n    def minimumTime(self, n: int, relations: List[List[int]], time: List[int]) -> int:\\n        \\n        graph = collections.defaultdict(list)\\n        for prevC, nextC in relations:\\n            if nextC not in graph:\\n                graph[nextC] = [prevC]\\n            else:\\n                graph[nextC].append(prevC)\\n\\n        seenNode = collections.defaultdict(int)\\n        def dfs(nodeId):\\n\\n            if nodeId in seenNode:\\n                return seenNode[nodeId]\\n\\n            ancestors = graph[nodeId]\\n            \\n            longestTimeToLeaf = 0\\n            for a in ancestors:\\n                timeToLeaf = dfs(a)\\n                longestTimeToLeaf = max(longestTimeToLeaf, timeToLeaf)\\n\\n            leafToNode = time[nodeId - 1] + longestTimeToLeaf\\n            seenNode[nodeId] = leafToNode\\n            return leafToNode\\n\\n        longestPath = -1\\n        for nodeId in range(1, n+1):\\n\\n            # go back up the DAG ; right to left(DAG goes from children on left to ancestors on right)\\n            timeToReachLeaf = dfs(nodeId)\\n            print(timeToReachLeaf)\\n\\n            # we are going to revisit nodes pretty often; need to memoize\\n            longestPath = max(longestPath, timeToReachLeaf)\\n        \\n        return longestPath\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3007616,
                "title": "c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\npublic class Solution {\\n    public int MinimumTime(int n, int[][] relations, int[] time) {\\n                Dictionary<int, List<int>> dic = new Dictionary<int, List<int>>();\\n        bool[] visited = new bool[time.Length];\\n        \\n        int res = 0;\\n        for(int i = 0; i < time.Length; i++)\\n            dic.TryAdd(i+1, new List<int>());\\n        foreach(int[] arr in relations)\\n        {     \\n            dic[arr[1]].Add(arr[0]);            \\n        }\\n        for(int i = 0; i < n; i ++)\\n        {\\n            if(!visited[i])\\n            {\\n                res = Math.Max(res, helper(time,visited, i, ref dic));\\n            }\\n        }\\n        return res;\\n    }\\n    \\n    public int helper(int[] time,bool[] visited ,int index, ref Dictionary<int, List<int>> dic)\\n    {\\n    \\n        visited[index] = true;\\n        int max = 0;\\n        \\n        foreach(int pre in dic[index+1])\\n        {\\n            if(!visited[pre-1])\\n            {\\n                time[pre-1] = helper(time,visited, pre-1, ref dic);                 \\n            }    \\n            max = Math.Max(time[pre-1], max);\\n        }\\n        time[index] = max+time[index];\\n        \\n        return time[index];\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution {\\n    public int MinimumTime(int n, int[][] relations, int[] time) {\\n                Dictionary<int, List<int>> dic = new Dictionary<int, List<int>>();\\n        bool[] visited = new bool[time.Length];\\n        \\n        int res = 0;\\n        for(int i = 0; i < time.Length; i++)\\n            dic.TryAdd(i+1, new List<int>());\\n        foreach(int[] arr in relations)\\n        {     \\n            dic[arr[1]].Add(arr[0]);            \\n        }\\n        for(int i = 0; i < n; i ++)\\n        {\\n            if(!visited[i])\\n            {\\n                res = Math.Max(res, helper(time,visited, i, ref dic));\\n            }\\n        }\\n        return res;\\n    }\\n    \\n    public int helper(int[] time,bool[] visited ,int index, ref Dictionary<int, List<int>> dic)\\n    {\\n    \\n        visited[index] = true;\\n        int max = 0;\\n        \\n        foreach(int pre in dic[index+1])\\n        {\\n            if(!visited[pre-1])\\n            {\\n                time[pre-1] = helper(time,visited, pre-1, ref dic);                 \\n            }    \\n            max = Math.Max(time[pre-1], max);\\n        }\\n        time[index] = max+time[index];\\n        \\n        return time[index];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2989481,
                "title": "super-simple-and-clean-topological-sort-beats-82-o-vlogv",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nClasses that finish first should be crossed off the prereq list first so that you can check the earliest possible time to take the next class.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nFind all courses with no dependencies then push them with their end times to a min heap so that the ones that finish first are picked next. You could instead use a distance array and a regular queue to save time to O(V + E) but this solution felt more intuitive and is the first one I came up with.\\n# Complexity\\n- Time complexity: O(VlogV + E)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(V)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\ntypedef pair<int, int> pi;\\n\\nclass Solution {\\npublic:\\n    int minimumTime(int n, vector<vector<int>>& relations, vector<int>& duration) {\\n        vector<vector<int>> graph(n + 1);\\n        vector<int> deps(n + 1, 0);\\n\\n        for (vector<int> &r : relations)\\n        {\\n            graph[r[0]].push_back(r[1]);\\n            deps[r[1]]++;\\n        }\\n        // finish time, node pair\\n        priority_queue<pi, vector<pi>, greater<pi>> q;\\n        int res = -1;\\n\\n        for (int i = 1; i <= n; i++)\\n            if (deps[i] == 0)\\n                q.push({duration[i - 1], i});\\n\\n        while (!q.empty())\\n        {\\n            auto [endTime, node] = q.top(); q.pop();\\n            res = max(res, endTime);\\n\\n            for (int edge : graph[node])\\n                if (--deps[edge] == 0)\\n                    q.push({endTime + duration[edge - 1], edge});\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\ntypedef pair<int, int> pi;\\n\\nclass Solution {\\npublic:\\n    int minimumTime(int n, vector<vector<int>>& relations, vector<int>& duration) {\\n        vector<vector<int>> graph(n + 1);\\n        vector<int> deps(n + 1, 0);\\n\\n        for (vector<int> &r : relations)\\n        {\\n            graph[r[0]].push_back(r[1]);\\n            deps[r[1]]++;\\n        }\\n        // finish time, node pair\\n        priority_queue<pi, vector<pi>, greater<pi>> q;\\n        int res = -1;\\n\\n        for (int i = 1; i <= n; i++)\\n            if (deps[i] == 0)\\n                q.push({duration[i - 1], i});\\n\\n        while (!q.empty())\\n        {\\n            auto [endTime, node] = q.top(); q.pop();\\n            res = max(res, endTime);\\n\\n            for (int edge : graph[node])\\n                if (--deps[edge] == 0)\\n                    q.push({endTime + duration[edge - 1], edge});\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2981716,
                "title": "c-topological-sort-with-comments",
                "content": "# Approach\\nDescribed in comments\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minimumTime(int n, vector<vector<int>>& relations, vector<int>& time) {\\n        if (relations.empty()) {\\n            return *max_element(time.begin(), time.end());\\n        }\\n\\n        // convert relations to adjList; node id starts from 1\\n        vector<vector<int>> adjList(n + 1, vector<int>());\\n        for (const auto& relation : relations) {\\n            int src = relation[0];\\n            int dst = relation[1];\\n            adjList[src].push_back(dst);\\n        }\\n\\n        // setup visited, indegree, maxCompletionTime\\n        vector<bool> visited(n + 1, false);\\n        vector<int> indegree(n + 1, 0);\\n        for (const auto& relation : relations) {\\n            int dst = relation[1];\\n            ++indegree[dst];\\n        }\\n        vector<int> maxCompletionTime(n + 1, 0);\\n\\n        // use topological sort to traverse the graph\\n        // - use visited array to record unvisited node\\n        // - use indegree array to record unvisited incoming edges\\n        // - use a queue to hold the nodes to be visited\\n        //   => they are unvisited and have no unvisited incoming edges\\n        // use a variable to record path length (sum of time to complete until course i)\\n        queue<int> courseQueue;\\n        for (int i = 1; i <= n; ++i) {\\n            if (indegree[i] == 0) {\\n                courseQueue.emplace(i);\\n                maxCompletionTime[i] = time[i - 1];\\n            }\\n        }\\n        while (!courseQueue.empty()) {\\n            auto src = courseQueue.front();\\n            visited[src] = true;\\n            for (int dst : adjList[src]) {\\n                --indegree[dst];\\n                int curCompletionTime = maxCompletionTime[src] + time[dst-1];\\n                if (curCompletionTime > maxCompletionTime[dst]) {\\n                    maxCompletionTime[dst] = curCompletionTime;\\n                }\\n                if (indegree[dst] == 0 && !visited[dst]) {\\n                    courseQueue.emplace(dst);\\n                }\\n            }\\n            courseQueue.pop();\\n        }\\n        \\n        // check and return the result\\n        for (int i = 1; i <= n; ++i) {\\n            if (visited[i] == false) {\\n                return -1;\\n            }\\n        }\\n        return *max_element(maxCompletionTime.begin(), maxCompletionTime.end());;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumTime(int n, vector<vector<int>>& relations, vector<int>& time) {\\n        if (relations.empty()) {\\n            return *max_element(time.begin(), time.end());\\n        }\\n\\n        // convert relations to adjList; node id starts from 1\\n        vector<vector<int>> adjList(n + 1, vector<int>());\\n        for (const auto& relation : relations) {\\n            int src = relation[0];\\n            int dst = relation[1];\\n            adjList[src].push_back(dst);\\n        }\\n\\n        // setup visited, indegree, maxCompletionTime\\n        vector<bool> visited(n + 1, false);\\n        vector<int> indegree(n + 1, 0);\\n        for (const auto& relation : relations) {\\n            int dst = relation[1];\\n            ++indegree[dst];\\n        }\\n        vector<int> maxCompletionTime(n + 1, 0);\\n\\n        // use topological sort to traverse the graph\\n        // - use visited array to record unvisited node\\n        // - use indegree array to record unvisited incoming edges\\n        // - use a queue to hold the nodes to be visited\\n        //   => they are unvisited and have no unvisited incoming edges\\n        // use a variable to record path length (sum of time to complete until course i)\\n        queue<int> courseQueue;\\n        for (int i = 1; i <= n; ++i) {\\n            if (indegree[i] == 0) {\\n                courseQueue.emplace(i);\\n                maxCompletionTime[i] = time[i - 1];\\n            }\\n        }\\n        while (!courseQueue.empty()) {\\n            auto src = courseQueue.front();\\n            visited[src] = true;\\n            for (int dst : adjList[src]) {\\n                --indegree[dst];\\n                int curCompletionTime = maxCompletionTime[src] + time[dst-1];\\n                if (curCompletionTime > maxCompletionTime[dst]) {\\n                    maxCompletionTime[dst] = curCompletionTime;\\n                }\\n                if (indegree[dst] == 0 && !visited[dst]) {\\n                    courseQueue.emplace(dst);\\n                }\\n            }\\n            courseQueue.pop();\\n        }\\n        \\n        // check and return the result\\n        for (int i = 1; i <= n; ++i) {\\n            if (visited[i] == false) {\\n                return -1;\\n            }\\n        }\\n        return *max_element(maxCompletionTime.begin(), maxCompletionTime.end());;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2973088,
                "title": "javascript-topological-sort-with-minpriorityqueue",
                "content": "```\\nvar minimumTime = function(n, relations, time) {\\n\\n    const prerequisites = new Array(n + 1).fill(0).map((_) => []);\\n    const inDegree = new Array(n + 1).fill(0);\\n\\n    for(const [pre, course] of relations) {\\n        prerequisites[pre].push(course);\\n        inDegree[course]++;\\n    }\\n\\n    const queue = new PriorityQueue({compare : ([id1, time1], [id2, time2]) => time1 - time2});\\n\\n    for(let i = 1; i < inDegree.length; i++) {\\n\\n        if(inDegree[i] === 0) {\\n            queue.enqueue([i, time[i - 1]]);\\n        }\\n    }\\n\\n    let totalTime = 0; \\n\\n    while(queue.size()) {\\n\\n        const [courseId, finishTime] = queue.dequeue(), courses = prerequisites[courseId];\\n        totalTime = finishTime;\\n\\n        for(const id of courses) {\\n            inDegree[id]--;\\n\\n            if(inDegree[id] === 0) {\\n                queue.enqueue([id, finishTime + time[id - 1]]);\\n            }\\n        }\\n\\n    }\\n   \\n    return totalTime;\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Topological Sort"
                ],
                "code": "```\\nvar minimumTime = function(n, relations, time) {\\n\\n    const prerequisites = new Array(n + 1).fill(0).map((_) => []);\\n    const inDegree = new Array(n + 1).fill(0);\\n\\n    for(const [pre, course] of relations) {\\n        prerequisites[pre].push(course);\\n        inDegree[course]++;\\n    }\\n\\n    const queue = new PriorityQueue({compare : ([id1, time1], [id2, time2]) => time1 - time2});\\n\\n    for(let i = 1; i < inDegree.length; i++) {\\n\\n        if(inDegree[i] === 0) {\\n            queue.enqueue([i, time[i - 1]]);\\n        }\\n    }\\n\\n    let totalTime = 0; \\n\\n    while(queue.size()) {\\n\\n        const [courseId, finishTime] = queue.dequeue(), courses = prerequisites[courseId];\\n        totalTime = finishTime;\\n\\n        for(const id of courses) {\\n            inDegree[id]--;\\n\\n            if(inDegree[id] === 0) {\\n                queue.enqueue([id, finishTime + time[id - 1]]);\\n            }\\n        }\\n\\n    }\\n   \\n    return totalTime;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2965839,
                "title": "java-dfs-dp-approach",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(E+V)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int minimumTime(int n, int[][] relations, int[] time) {\\n        int[] indegree = new int[n];\\n        int[] dp = new int[n];\\n\\n        List<Set<Integer>> adjList = new ArrayList<>();\\n        for(int i=0;i<n;i++) adjList.add(new HashSet<>());\\n        for(int[] relation: relations) {\\n            indegree[relation[0]-1]++;\\n            adjList.get(relation[1]-1).add(relation[0]-1);\\n        }\\n\\n        int maxTime = 0;\\n        for(int i=0;i<indegree.length;i++) {\\n            if(indegree[i]==0) {\\n                int timeTaken = minTime(i,adjList,time, dp);\\n                maxTime = Math.max(timeTaken, maxTime);\\n            }\\n        }\\n        return maxTime;\\n    }\\n\\n    private int minTime(int node, List<Set<Integer>> adjList, int[] time, int[] dp) {\\n        if(dp[node]!=0) return dp[node];\\n        int maxTime = 0;\\n        for(int ele: adjList.get(node)) {\\n            int timeTaken = minTime(ele, adjList, time, dp);\\n            maxTime = Math.max(timeTaken, maxTime); \\n        }\\n        dp[node] = maxTime + time[node];\\n        return dp[node];\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int minimumTime(int n, int[][] relations, int[] time) {\\n        int[] indegree = new int[n];\\n        int[] dp = new int[n];\\n\\n        List<Set<Integer>> adjList = new ArrayList<>();\\n        for(int i=0;i<n;i++) adjList.add(new HashSet<>());\\n        for(int[] relation: relations) {\\n            indegree[relation[0]-1]++;\\n            adjList.get(relation[1]-1).add(relation[0]-1);\\n        }\\n\\n        int maxTime = 0;\\n        for(int i=0;i<indegree.length;i++) {\\n            if(indegree[i]==0) {\\n                int timeTaken = minTime(i,adjList,time, dp);\\n                maxTime = Math.max(timeTaken, maxTime);\\n            }\\n        }\\n        return maxTime;\\n    }\\n\\n    private int minTime(int node, List<Set<Integer>> adjList, int[] time, int[] dp) {\\n        if(dp[node]!=0) return dp[node];\\n        int maxTime = 0;\\n        for(int ele: adjList.get(node)) {\\n            int timeTaken = minTime(ele, adjList, time, dp);\\n            maxTime = Math.max(timeTaken, maxTime); \\n        }\\n        dp[node] = maxTime + time[node];\\n        return dp[node];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2965748,
                "title": "python-solution-o-v-e",
                "content": "# class Solution:\\n    def minimumTime(self, n: int, relations: List[List[int]], time: List[int]) -> int:\\n        cmpt = [-1] * (n + 1)\\n        adj = collections.defaultdict(list)\\n        for a, b in relations:\\n            adj[b].append(a)\\n        \\n        \\n        def maxTime(node):\\n            if cmpt[node] != -1:\\n                return cmpt[node]\\n            maxi = 0\\n            \\n            for nei in adj[node]:\\n                maxi = max(maxi, maxTime(nei))\\n            \\n            cmpt[node] = maxi + time[node - 1]\\n            \\n            return cmpt[node]\\n        \\n        for node in range(1, n + 1):\\n            cmpt[node] = maxTime(node)\\n        \\n        return max(cmpt)\\n            \\n",
                "solutionTags": [
                    "Python3",
                    "Depth-First Search"
                ],
                "code": "# class Solution:\\n    def minimumTime(self, n: int, relations: List[List[int]], time: List[int]) -> int:\\n        cmpt = [-1] * (n + 1)\\n        adj = collections.defaultdict(list)\\n        for a, b in relations:\\n            adj[b].append(a)\\n        \\n        \\n        def maxTime(node):\\n            if cmpt[node] != -1:\\n                return cmpt[node]\\n            maxi = 0\\n            \\n            for nei in adj[node]:\\n                maxi = max(maxi, maxTime(nei))\\n            \\n            cmpt[node] = maxi + time[node - 1]\\n            \\n            return cmpt[node]\\n        \\n        for node in range(1, n + 1):\\n            cmpt[node] = maxTime(node)\\n        \\n        return max(cmpt)\\n            \\n",
                "codeTag": "Java"
            },
            {
                "id": 2965457,
                "title": "c-kahn-s-algorithm-for-topological-sort",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    int minimumTime(int n, vector<vector<int>>& relations, vector<int>& time) {\\n        vector<vector<int>> adj(n);\\n        vector<int> indeg(n,0);\\n        vector<int> t(n,0);\\n        for(auto &vec: relations){\\n            int first=vec[0],second=vec[1];\\n            first--;second--;\\n            adj[first].push_back(second);\\n            indeg[second]++;\\n        }\\n\\n        queue<int> q;\\n        for(int i=0;i<n;i++) if(indeg[i]==0) {q.push(i);t[i]=time[i];}\\n        while(!q.empty()){\\n            int u=q.front();\\n            q.pop();\\n\\n            for(auto &v : adj[u]){\\n                indeg[v]--;\\n                t[v]=max(t[v],t[u]+time[v]);\\n                if(indeg[v]==0) q.push(v);\\n            }\\n        }\\n\\n        return *max_element(t.begin(),t.end());\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumTime(int n, vector<vector<int>>& relations, vector<int>& time) {\\n        vector<vector<int>> adj(n);\\n        vector<int> indeg(n,0);\\n        vector<int> t(n,0);\\n        for(auto &vec: relations){\\n            int first=vec[0],second=vec[1];\\n            first--;second--;\\n            adj[first].push_back(second);\\n            indeg[second]++;\\n        }\\n\\n        queue<int> q;\\n        for(int i=0;i<n;i++) if(indeg[i]==0) {q.push(i);t[i]=time[i];}\\n        while(!q.empty()){\\n            int u=q.front();\\n            q.pop();\\n\\n            for(auto &v : adj[u]){\\n                indeg[v]--;\\n                t[v]=max(t[v],t[u]+time[v]);\\n                if(indeg[v]==0) q.push(v);\\n            }\\n        }\\n\\n        return *max_element(t.begin(),t.end());\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2949516,
                "title": "c-modified-toposort-faster-than-100-solution-commented-code",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nSome sort of ordereding is there, thus toposort will be applied.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n- Applied topoSort on basis on preRequisite nodes\\n- used priority queue (maxheap - time,node)\\n- updating universaltime as maximum each iteration\\n\\n# Complexity\\n- Time complexity   :   O(n*relations.size())\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity  :   O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minimumTime(int n, vector<vector<int>>& relations, vector<int>& time) {\\n        \\n        //helping data structures\\n        unordered_map<int,list<int>> adj;\\n        vector<int> preqNodeCount (n+1, 0);\\n        priority_queue<pair<int,int>,vector<pair<int,int>>,greater<pair<int,int>>> pq;\\n        int UniversalTime = 0;\\n\\n        //updating our utility data structures\\n        for(int i=0; i<relations.size(); i++) {\\n            int u = relations[i][0];\\n            int v = relations[i][1];\\n            preqNodeCount[v]++;\\n            adj[u].push_back(v);\\n        }\\n        \\n        unordered_map<int,int> timeMap;\\n        for(int i=0; i<time.size(); i++)    {\\n            timeMap[i+1] = time[i];\\n        }\\n        \\n        for(int i=1; i<n+1; i++)    {\\n            if(preqNodeCount[i]==0)   {\\n                pq.push({timeMap[i],i});\\n            }\\n        }\\n\\n        //modified topo sort\\n        while(!pq.empty())   {\\n            auto it = pq.top();\\n            int currtime = it.first;\\n            int currnode = it.second;\\n            pq.pop();\\n\\n            UniversalTime = max(UniversalTime,currtime);\\n\\n            for(auto it : adj[currnode])    {\\n                preqNodeCount[it]--;\\n                if(preqNodeCount[it]==0)    {\\n                    pq.push({ currtime+timeMap[it],it });\\n                }\\n            }\\n        }\\n\\n        return UniversalTime;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Graph",
                    "Topological Sort",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumTime(int n, vector<vector<int>>& relations, vector<int>& time) {\\n        \\n        //helping data structures\\n        unordered_map<int,list<int>> adj;\\n        vector<int> preqNodeCount (n+1, 0);\\n        priority_queue<pair<int,int>,vector<pair<int,int>>,greater<pair<int,int>>> pq;\\n        int UniversalTime = 0;\\n\\n        //updating our utility data structures\\n        for(int i=0; i<relations.size(); i++) {\\n            int u = relations[i][0];\\n            int v = relations[i][1];\\n            preqNodeCount[v]++;\\n            adj[u].push_back(v);\\n        }\\n        \\n        unordered_map<int,int> timeMap;\\n        for(int i=0; i<time.size(); i++)    {\\n            timeMap[i+1] = time[i];\\n        }\\n        \\n        for(int i=1; i<n+1; i++)    {\\n            if(preqNodeCount[i]==0)   {\\n                pq.push({timeMap[i],i});\\n            }\\n        }\\n\\n        //modified topo sort\\n        while(!pq.empty())   {\\n            auto it = pq.top();\\n            int currtime = it.first;\\n            int currnode = it.second;\\n            pq.pop();\\n\\n            UniversalTime = max(UniversalTime,currtime);\\n\\n            for(auto it : adj[currnode])    {\\n                preqNodeCount[it]--;\\n                if(preqNodeCount[it]==0)    {\\n                    pq.push({ currtime+timeMap[it],it });\\n                }\\n            }\\n        }\\n\\n        return UniversalTime;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2925192,
                "title": "easy-python-o-n",
                "content": "# building graph \\nwe need add the  directed edge form the Nextcourse to previous\\ncourse so that we can easily find the total time for any node .\\n# Complexity\\n- Time complexity: O(N + E)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def minimumTime(self, n: int, re: List[List[int]], time: List[int]) -> int:\\n        \"\"\"\\n          the idea of problem is to take all the prevcourse\\n          for a given course at the same time and take their\\n          max and add it to the time for given course\\n        \"\"\"\\n        # finding time for given node\\n        def tc(n):\\n            if(dp[n]!=-1):return dp[n]\\n            ans=time[n]\\n            z=0\\n            for i in gr[n]:\\n                z=max(z,tc(i))\\n            dp[n]=ans+z\\n            return ans+z\\n        # initalize\\n        gr=defaultdict(list)\\n        dp=defaultdict(lambda:-1)\\n        # building graph \\n        for i,j in re:gr[j-1].append(i-1)\\n        ans=0\\n        # finding the max time across all the subgraphs\\n        for i in range(0,n,1):\\n            ans=max(ans,tc(i))\\n        return ans\\n\\n\\n```",
                "solutionTags": [
                    "Python3",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution:\\n    def minimumTime(self, n: int, re: List[List[int]], time: List[int]) -> int:\\n        \"\"\"\\n          the idea of problem is to take all the prevcourse\\n          for a given course at the same time and take their\\n          max and add it to the time for given course\\n        \"\"\"\\n        # finding time for given node\\n        def tc(n):\\n            if(dp[n]!=-1):return dp[n]\\n            ans=time[n]\\n            z=0\\n            for i in gr[n]:\\n                z=max(z,tc(i))\\n            dp[n]=ans+z\\n            return ans+z\\n        # initalize\\n        gr=defaultdict(list)\\n        dp=defaultdict(lambda:-1)\\n        # building graph \\n        for i,j in re:gr[j-1].append(i-1)\\n        ans=0\\n        # finding the max time across all the subgraphs\\n        for i in range(0,n,1):\\n            ans=max(ans,tc(i))\\n        return ans\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2912976,
                "title": "easy-to-understand-indegree-c",
                "content": "```\\nclass Solution {\\npublic:\\n    int minimumTime(int n, vector<vector<int>>& relations, vector<int>& time) {\\n        int result = 0;\\n        vector<int> inDegree(n,0);\\n        vector<vector<int>> adj(n);\\n        for (auto &e : relations) {\\n            inDegree[e[1]-1]++;\\n            adj[e[0]-1].push_back(e[1]-1);\\n        }\\n        \\n        vector<int> courseCost(n,0);\\n        queue<int> q;\\n        for (int i = 0; i < n; i++) {\\n            if (inDegree[i] == 0)\\n                q.push(i);\\n        }\\n        \\n        while (!q.empty()) {\\n            int sz = q.size();\\n            for (int i = 0; i < sz; i++) {\\n                int idx = q.front();\\n                q.pop();\\n                courseCost[idx] = courseCost[idx] + time[idx];\\n                for (auto &e : adj[idx]) {\\n                    inDegree[e]--;\\n                    courseCost[e] = max(courseCost[e],courseCost[idx]);\\n                    if (inDegree[e] == 0) {\\n                        q.push(e);\\n                    }\\n                }\\n            }\\n        }\\n        return *max_element(begin(courseCost), end(courseCost));\\n    \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumTime(int n, vector<vector<int>>& relations, vector<int>& time) {\\n        int result = 0;\\n        vector<int> inDegree(n,0);\\n        vector<vector<int>> adj(n);\\n        for (auto &e : relations) {\\n            inDegree[e[1]-1]++;\\n            adj[e[0]-1].push_back(e[1]-1);\\n        }\\n        \\n        vector<int> courseCost(n,0);\\n        queue<int> q;\\n        for (int i = 0; i < n; i++) {\\n            if (inDegree[i] == 0)\\n                q.push(i);\\n        }\\n        \\n        while (!q.empty()) {\\n            int sz = q.size();\\n            for (int i = 0; i < sz; i++) {\\n                int idx = q.front();\\n                q.pop();\\n                courseCost[idx] = courseCost[idx] + time[idx];\\n                for (auto &e : adj[idx]) {\\n                    inDegree[e]--;\\n                    courseCost[e] = max(courseCost[e],courseCost[idx]);\\n                    if (inDegree[e] == 0) {\\n                        q.push(e);\\n                    }\\n                }\\n            }\\n        }\\n        return *max_element(begin(courseCost), end(courseCost));\\n    \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2902774,
                "title": "dart-solution-topological-sort-o-n-e",
                "content": "# Intuition\\nA simple (medium level) task as its definition exactly matches topological sort problem. \\n\\n# Approach\\nStandard topological sort algorithm fits out needs the best.\\n\\n# Complexity\\n- Time complexity:\\n $$O(N+E)$$  - while processing every node N in the queue we visit every edge E only once.\\n\\n- Space complexity:\\nN+E - same we built indefgee array (N) and also used a map to store all edges E for quick O(1) access to node\\'s edges.\\n\\n# Code\\n```\\nimport \\'dart:collection\\';\\n\\nclass Solution {\\n  int minimumTime(int n, List<List<int>> relations, List<int> time) {\\n    final dag = Map<int, List<int>>();\\n    final indegree = List<int>.filled(n + 1, 0);\\n    final maxTime = List<int>.filled(n + 1, 0);\\n\\n    for (var r in relations) {\\n      if (!dag.containsKey(r[0]))\\n        dag[r[0]] = [r[1]];\\n      else\\n        dag[r[0]]!.add(r[1]);\\n      indegree[r[1]]++;\\n    }\\n    final queue = Queue<int>();\\n    for (int i = 1; i <= n; i++)\\n      if (indegree[i] == 0) {\\n        maxTime[i] = time[i - 1];\\n        queue.add(i);\\n      }\\n\\n    while (queue.isNotEmpty) {\\n      int q = queue.removeFirst();\\n      if (dag[q] != null)\\n        for (var next in dag[q]!) {\\n          maxTime[next] = max(maxTime[next], maxTime[q] + time[next - 1]);\\n          if (--indegree[next] == 0) queue.add(next);\\n        }\\n    }\\n\\n    return maxTime.reduce(max);\\n  }\\n}\\n\\n```",
                "solutionTags": [
                    "Dart"
                ],
                "code": "```\\nimport \\'dart:collection\\';\\n\\nclass Solution {\\n  int minimumTime(int n, List<List<int>> relations, List<int> time) {\\n    final dag = Map<int, List<int>>();\\n    final indegree = List<int>.filled(n + 1, 0);\\n    final maxTime = List<int>.filled(n + 1, 0);\\n\\n    for (var r in relations) {\\n      if (!dag.containsKey(r[0]))\\n        dag[r[0]] = [r[1]];\\n      else\\n        dag[r[0]]!.add(r[1]);\\n      indegree[r[1]]++;\\n    }\\n    final queue = Queue<int>();\\n    for (int i = 1; i <= n; i++)\\n      if (indegree[i] == 0) {\\n        maxTime[i] = time[i - 1];\\n        queue.add(i);\\n      }\\n\\n    while (queue.isNotEmpty) {\\n      int q = queue.removeFirst();\\n      if (dag[q] != null)\\n        for (var next in dag[q]!) {\\n          maxTime[next] = max(maxTime[next], maxTime[q] + time[next - 1]);\\n          if (--indegree[next] == 0) queue.add(next);\\n        }\\n    }\\n\\n    return maxTime.reduce(max);\\n  }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2901836,
                "title": "easy-to-understand-c-dfs-solution",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    void dfs(vector<int>adj[], int curr, vector<int>&vis, vector<int>&time, vector<int>&t){\\n        vis[curr]=1;\\n        for(auto i:adj[curr]){\\n            if(!vis[i]) dfs(adj,i,vis,time,t);\\n            t[curr]=max(t[curr],time[curr]+t[i]);\\n        }\\n    }\\n    int minimumTime(int n, vector<vector<int>>& relations, vector<int>& time) {\\n        vector<int>adj[n];\\n        for(int i=0;i<relations.size();i++){\\n            adj[relations[i][0]-1].push_back(relations[i][1]-1);\\n        }\\n        vector<int>vis(n,0);\\n        vector<int>t(n);\\n        for(int i=0;i<n;i++) t[i]=time[i];\\n        for(int i=0;i<n;i++){\\n            if(!vis[i]) dfs(adj,i, vis,time, t);\\n        }\\n        int mx=0;\\n        for(int i=0;i<n;i++){\\n            mx=max(mx,t[i]);\\n        }\\n        return mx;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void dfs(vector<int>adj[], int curr, vector<int>&vis, vector<int>&time, vector<int>&t){\\n        vis[curr]=1;\\n        for(auto i:adj[curr]){\\n            if(!vis[i]) dfs(adj,i,vis,time,t);\\n            t[curr]=max(t[curr],time[curr]+t[i]);\\n        }\\n    }\\n    int minimumTime(int n, vector<vector<int>>& relations, vector<int>& time) {\\n        vector<int>adj[n];\\n        for(int i=0;i<relations.size();i++){\\n            adj[relations[i][0]-1].push_back(relations[i][1]-1);\\n        }\\n        vector<int>vis(n,0);\\n        vector<int>t(n);\\n        for(int i=0;i<n;i++) t[i]=time[i];\\n        for(int i=0;i<n;i++){\\n            if(!vis[i]) dfs(adj,i, vis,time, t);\\n        }\\n        int mx=0;\\n        for(int i=0;i<n;i++){\\n            mx=max(mx,t[i]);\\n        }\\n        return mx;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2897749,
                "title": "parallel-courses-o-n-solution-c",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\nSince, we can only complete a course if only if all its previous courses gets completed first. So, we can start from those courses who have no previous courses and each time the previous course gets completed, we can reduce current course degree and when only 1 previous course is left, we can push it to the queue.\\n\\n# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minimumTime(int n, vector<vector<int>>& relations, vector<int>& time) {\\n        vector<int>adj[n+1];\\n        vector<int>times(n,0);\\n        vector<int>in(n+1,0);\\n        for(auto x : relations){\\n            adj[x[0]].push_back(x[1]);\\n            in[x[1]]++;\\n        }\\n        queue<int>q;\\n        for(int i=1;i<=n;i++){\\n            if(in[i]==0){\\n                q.push(i);\\n                times[i-1]=time[i-1];\\n            }\\n        }\\n        int ans=0;\\n        while(!q.empty()){\\n            int u=q.front();\\n            q.pop();\\n            ans=max(ans,times[u-1]);\\n            for(auto x : adj[u]){\\n                if(in[x]==1)q.push(x);\\n                times[x-1]=max(times[x-1],time[x-1]+times[u-1]);\\n                in[x]--;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumTime(int n, vector<vector<int>>& relations, vector<int>& time) {\\n        vector<int>adj[n+1];\\n        vector<int>times(n,0);\\n        vector<int>in(n+1,0);\\n        for(auto x : relations){\\n            adj[x[0]].push_back(x[1]);\\n            in[x[1]]++;\\n        }\\n        queue<int>q;\\n        for(int i=1;i<=n;i++){\\n            if(in[i]==0){\\n                q.push(i);\\n                times[i-1]=time[i-1];\\n            }\\n        }\\n        int ans=0;\\n        while(!q.empty()){\\n            int u=q.front();\\n            q.pop();\\n            ans=max(ans,times[u-1]);\\n            for(auto x : adj[u]){\\n                if(in[x]==1)q.push(x);\\n                times[x-1]=max(times[x-1],time[x-1]+times[u-1]);\\n                in[x]--;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2858948,
                "title": "plain-english-python3-with-a-node-datatype",
                "content": "# Intuition\\nThis is a naive solution to the problem.  There are more optimised ways to solve the problem, but here\\'s a relatively readable solution in plain Python3.\\n\\n# Approach\\nRearrange the inputs as a graph dataclass, and walk the graph.  For each node, calculate the remaining time as the current time + max remaining time of any proceeding nodes.  \\n\\n# Code\\n```\\nfrom dataclasses import dataclass, field\\n\\n\\nclass Solution(object):\\n    @dataclass\\n    class Node:\\n        time: int\\n        _next: list[\"Solution.Node\"] = field(default_factory=list)\\n        _duration_for_next: int = -1\\n\\n        def remaining_time(self) -> int:\\n            if self._duration_for_next == -1:\\n                self._duration_for_next = self.time\\n                if self._next:\\n                    max_remaining_time = self._next[0].remaining_time()\\n                    for r in self._next[1:]:\\n                        next_rt = r.remaining_time()\\n                        if next_rt > max_remaining_time:\\n                            max_remaining_time = next_rt\\n                    self._duration_for_next += max_remaining_time\\n            return self._duration_for_next\\n\\n    def minimumTime(self, n, relations, time):\\n        nodes = []\\n        for i in range(0, n):\\n            nodes.append(Solution.Node(time[i]))\\n\\n        nodes_with_dependencies = set()\\n        # Link relations\\n        for i in relations:\\n            from_node, to_node = i\\n            nodes[from_node - 1]._next.append(nodes[to_node - 1])\\n            nodes_with_dependencies.add(to_node - 1)\\n            pass\\n\\n        # Create a root node\\n        nodes_with_no_dependencies = []\\n        for i in range(0, n):\\n            if i not in nodes_with_dependencies:\\n                nodes_with_no_dependencies.append(nodes[i])\\n        root_node = Solution.Node(0, _next=nodes_with_no_dependencies)\\n\\n        return root_node.remaining_time()\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nfrom dataclasses import dataclass, field\\n\\n\\nclass Solution(object):\\n    @dataclass\\n    class Node:\\n        time: int\\n        _next: list[\"Solution.Node\"] = field(default_factory=list)\\n        _duration_for_next: int = -1\\n\\n        def remaining_time(self) -> int:\\n            if self._duration_for_next == -1:\\n                self._duration_for_next = self.time\\n                if self._next:\\n                    max_remaining_time = self._next[0].remaining_time()\\n                    for r in self._next[1:]:\\n                        next_rt = r.remaining_time()\\n                        if next_rt > max_remaining_time:\\n                            max_remaining_time = next_rt\\n                    self._duration_for_next += max_remaining_time\\n            return self._duration_for_next\\n\\n    def minimumTime(self, n, relations, time):\\n        nodes = []\\n        for i in range(0, n):\\n            nodes.append(Solution.Node(time[i]))\\n\\n        nodes_with_dependencies = set()\\n        # Link relations\\n        for i in relations:\\n            from_node, to_node = i\\n            nodes[from_node - 1]._next.append(nodes[to_node - 1])\\n            nodes_with_dependencies.add(to_node - 1)\\n            pass\\n\\n        # Create a root node\\n        nodes_with_no_dependencies = []\\n        for i in range(0, n):\\n            if i not in nodes_with_dependencies:\\n                nodes_with_no_dependencies.append(nodes[i])\\n        root_node = Solution.Node(0, _next=nodes_with_no_dependencies)\\n\\n        return root_node.remaining_time()\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2856566,
                "title": "c-toposort-bfs",
                "content": "```\\nclass Solution {\\npublic:\\n    int minimumTime(int n, vector<vector<int>>& relations, vector<int>& time) {\\n        \\n        vector < int > adj[n];\\n        vector < int > indegree(n,0);\\n        vector < int > dist(n,0);\\n        int relen = relations.size();\\n        int ans = 0;\\n        int currMax = INT_MIN;\\n        \\n        for(int i = 0; i < relen; i++){\\n            adj[relations[i][0]-1].push_back(relations[i][1]-1);\\n            indegree[relations[i][1]-1] += 1;\\n        }\\n        \\n        queue < int > q;\\n        for(int i = 0; i < n; i++){\\n            if(indegree[i] == 0){\\n                q.push(i);\\n                dist[i] = time[i];\\n            }\\n        }\\n        \\n        while(!q.empty()){\\n            int c = q.size();\\n            for(int i = 0; i < c; i++){\\n                int front = q.front();\\n                q.pop();\\n                for(int x : adj[front]){\\n                    dist[x] = max(dist[front] + time[x], dist[x]);\\n                    indegree[x] -= 1;\\n                    if(indegree[x] == 0)\\n                        q.push(x);\\n                }  \\n            }\\n        }\\n        for(int i = 0; i < n; i++)ans = max(ans, dist[i]);\\n        return ans;\\n    }\\n};",
                "solutionTags": [
                    "C",
                    "Breadth-First Search",
                    "Graph",
                    "Topological Sort"
                ],
                "code": "class Solution {\\npublic:\\n    int minimumTime(int n, vector<vector<int>>& relations, vector<int>& time) {\\n        \\n        vector < int > adj[n];\\n        vector < int > indegree(n,0);\\n        vector < int > dist(n,0);\\n        int relen = relations.size();\\n        int ans = 0;\\n        int currMax = INT_MIN;\\n        \\n        for(int i = 0; i < relen; i++){\\n            adj[relations[i][0]-1].push_back(relations[i][1]-1);\\n            indegree[relations[i][1]-1] += 1;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2854888,
                "title": "java-concise-dfs-memoization-topological-sorting",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThis is a longest path in grapth problem and can be solved on topological sortng algorithm.\\n\\n**G O O G L E** asked me this question in **July 2019**.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nThe idea is to use DFS using a memoization array (DP) to store the calculated time for a visited node so that it can be reused. \\n\\nSince we already have **DP[]** array, we don\\'t need another visited[] array.\\n\\n# Complexity\\n- Time complexity: O(V+E) as of DFS complexity.\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(V+E) for graph, O(V) for DP array.\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    HashMap<Integer, List<Integer>> vertices = new HashMap<>();\\n\\n    public int minTimeCompletionDfs(int[] tasks, int[][] dependencies, int size) {\\n        //Populate graph\\n        IntStream.rangeClosed(1,size).forEach(u -> vertices.put(u, new ArrayList<>()));\\n        Arrays.stream(dependencies).forEach(dep -> vertices.get(dep[0]).add(dep[1]));\\n\\n        //Calculate max time using DFS with memoization DP (DFS topological sorting)\\n        Integer [] DP = new Integer[size+1];\\n        int max=0;\\n        for(int u=1; u<=size; u++) {\\n            max = Math.max(minTimeCompletionDfs(u, tasks, DP), max);\\n        }\\n        return max;\\n    }\\n\\n    public int minTimeCompletionDfs(int u, int[] tasks, Integer []DP) {\\n        if(DP[u]!=null) {\\n            return DP[u];\\n        }\\n\\n        int max=0;\\n        for(int v: vertices.get(u)) {\\n            max = Math.max(minTimeCompletionDfs(v, tasks, DP), max);\\n        }\\n        return DP[u] = max + tasks[u-1];\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Depth-First Search",
                    "Topological Sort",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\n    HashMap<Integer, List<Integer>> vertices = new HashMap<>();\\n\\n    public int minTimeCompletionDfs(int[] tasks, int[][] dependencies, int size) {\\n        //Populate graph\\n        IntStream.rangeClosed(1,size).forEach(u -> vertices.put(u, new ArrayList<>()));\\n        Arrays.stream(dependencies).forEach(dep -> vertices.get(dep[0]).add(dep[1]));\\n\\n        //Calculate max time using DFS with memoization DP (DFS topological sorting)\\n        Integer [] DP = new Integer[size+1];\\n        int max=0;\\n        for(int u=1; u<=size; u++) {\\n            max = Math.max(minTimeCompletionDfs(u, tasks, DP), max);\\n        }\\n        return max;\\n    }\\n\\n    public int minTimeCompletionDfs(int u, int[] tasks, Integer []DP) {\\n        if(DP[u]!=null) {\\n            return DP[u];\\n        }\\n\\n        int max=0;\\n        for(int v: vertices.get(u)) {\\n            max = Math.max(minTimeCompletionDfs(v, tasks, DP), max);\\n        }\\n        return DP[u] = max + tasks[u-1];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2808075,
                "title": "completion-time-of-topological-ordering-java",
                "content": "The competition time of topological ordering is a know practical CS problem Code wise, just minor changes.\\n  Assume the following graph\\n * \\t\\t0-1, 1-2, 3-4, 4-2  with completion times   {10, 20, 7, 15, 5}\\n * \\tRunning the classical topological sort:\\n * \\t\\tready: {0, 3}\\n * \\t\\tPop 0\\n * \\t\\tready {3, 1}\\n * \\t\\tpop 3\\n * \\t\\tread {1, 4}\\n * \\t\\tpop 1\\n * \\t\\tready {4}\\n * \\t\\tpop 4\\n * \\t\\tready {2}\\n * \\t\\tpop 2\\n * \\t\\tNow node(2) has 2 paths before it:  10+20 and 15+5. node(2) has to wait for them.\\n * \\t\\t\\tIt needs max(30, 20) = 30 BEFORE starting\\n * \\t\\t\\tthen it takes 7 units, for a total 37 for node(2)\\n * \\t\\tThe whole idea is to create vector: completionTime\\n * \\t\\t\\tUpdate it during the topological sort to include the full completion time\\n * \\t\\tWe update it in an incremental way\\n * \\t\\tLet\\'s simulate again:\\n * \\t\\tInitially competition {0, 0, 0, 0, 0}\\n * \\t\\tready: {0, 3}\\n * \\t\\tPop 0\\n * \\t\\t\\tcompetition[0] = 10\\t\\t\\t# means I needed 10 time units in the best case\\n * \\t\\t\\tNow what is the effect of node(0) on its neighbor node(1)?\\n * \\t\\t\\t\\tnode(1) can\\'t start before time(10)\\n * \\t\\t\\t\\tcompetition[1] = 10      # means my paths SO FAR need 10 units to finish\\n * \\t\\tready {3, 1}\\n * \\t\\tpop 3\\n * \\t\\t\\tIn a similar logic\\tcompetition[3] = 15. competition[4] = 15.   (3 done - 4 not yet)\\n * \\t\\tread {1, 4}\\n * \\t\\tpop 1\\n * \\t\\t\\tNow node(1) is ready. competition[1] = 10 for its paths. time(1) = 20\\n * \\t\\t\\tSo node(1) needs competition[1] += time(1)   ==> competition[1] = 30\\n * \\t\\t\\tWhat about neighbor node(2)? We just reached with competition[2] = 30\\n * \\t\\tready {4}\\n * \\t\\tpop 4\\n * \\t\\t\\tIn a similar logic, competition[4] += time(4)  ==> competition[4] = 20\\n * \\t\\t\\tWhat about neighbor node(2)?\\n * \\t\\t\\t\\tWe already now it has SO FAR competition[2] = 30  from path 0-1\\n * \\t\\t\\t\\tBut now we have new path which is competition[4] = 20\\n *\\n \\t\\t\\tHowever, as we have to wait, then node(2) still needs to wait[](http://) 30 units\\n * \\t\\t\\t\\t\\tcompletionTime[2] = max(completionTime[2], completionTime[4]) = 30\\n * \\t\\tready {2}\\n * \\t\\tpop 2\\n * \\t\\t\\tcompletionTime[2] += time(2) ==> 30 + 7 = 37\\n\\n* Acknowledgement : [Dr.MostafaSaad Course.](https://www.udemy.com/course-dashboard-redirect/?course_id=4335460)\\n",
                "solutionTags": [
                    "Java",
                    "Topological Sort"
                ],
                "code": "The competition time of topological ordering is a know practical CS problem Code wise, just minor changes.\\n  Assume the following graph\\n * \\t\\t0-1, 1-2, 3-4, 4-2  with completion times   {10, 20, 7, 15, 5}\\n * \\tRunning the classical topological sort:\\n * \\t\\tready: {0, 3}\\n * \\t\\tPop 0\\n * \\t\\tready {3, 1}\\n * \\t\\tpop 3\\n * \\t\\tread {1, 4}\\n * \\t\\tpop 1\\n * \\t\\tready {4}\\n * \\t\\tpop 4\\n * \\t\\tready {2}\\n * \\t\\tpop 2\\n * \\t\\tNow node(2) has 2 paths before it:  10+20 and 15+5. node(2) has to wait for them.\\n * \\t\\t\\tIt needs max(30, 20) = 30 BEFORE starting\\n * \\t\\t\\tthen it takes 7 units, for a total 37 for node(2)\\n * \\t\\tThe whole idea is to create vector: completionTime\\n * \\t\\t\\tUpdate it during the topological sort to include the full completion time\\n * \\t\\tWe update it in an incremental way\\n * \\t\\tLet\\'s simulate again:\\n * \\t\\tInitially competition {0, 0, 0, 0, 0}\\n * \\t\\tready: {0, 3}\\n * \\t\\tPop 0\\n * \\t\\t\\tcompetition[0] = 10\\t\\t\\t# means I needed 10 time units in the best case\\n * \\t\\t\\tNow what is the effect of node(0) on its neighbor node(1)?\\n * \\t\\t\\t\\tnode(1) can\\'t start before time(10)\\n * \\t\\t\\t\\tcompetition[1] = 10      # means my paths SO FAR need 10 units to finish\\n * \\t\\tready {3, 1}\\n * \\t\\tpop 3\\n * \\t\\t\\tIn a similar logic\\tcompetition[3] = 15. competition[4] = 15.   (3 done - 4 not yet)\\n * \\t\\tread {1, 4}\\n * \\t\\tpop 1\\n * \\t\\t\\tNow node(1) is ready. competition[1] = 10 for its paths. time(1) = 20\\n * \\t\\t\\tSo node(1) needs competition[1] += time(1)   ==> competition[1] = 30\\n * \\t\\t\\tWhat about neighbor node(2)? We just reached with competition[2] = 30\\n * \\t\\tready {4}\\n * \\t\\tpop 4\\n * \\t\\t\\tIn a similar logic, competition[4] += time(4)  ==> competition[4] = 20\\n * \\t\\t\\tWhat about neighbor node(2)?\\n * \\t\\t\\t\\tWe already now it has SO FAR competition[2] = 30  from path 0-1\\n * \\t\\t\\t\\tBut now we have new path which is competition[4] = 20\\n *\\n \\t\\t\\tHowever, as we have to wait, then node(2) still needs to wait[](http://) 30 units\\n * \\t\\t\\t\\t\\tcompletionTime[2] = max(completionTime[2], completionTime[4]) = 30\\n * \\t\\tready {2}\\n * \\t\\tpop 2\\n * \\t\\t\\tcompletionTime[2] += time(2) ==> 30 + 7 = 37\\n\\n* Acknowledgement : [Dr.MostafaSaad Course.](https://www.udemy.com/course-dashboard-redirect/?course_id=4335460)\\n",
                "codeTag": "Java"
            },
            {
                "id": 2791357,
                "title": "simple-clearly-explained-depth-first-search-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nDo a depth first search on the prerequisite graph.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\nKeep a time completed for each node, fill it in by first filling every prereq for it. Store the value so that you are not repeating computations.\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n$$O(m + n)$$ \\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n$$O(n)$$\\n\\n# Code\\n```\\nfrom collections import defaultdict\\nclass Solution:\\n    def minimumTime(self, n: int, relations: List[List[int]], time: List[int]) -> int:\\n        prereqGraph = defaultdict(list)\\n\\n        timeCompleted = (n + 1) * [0]\\n\\n        time = [0] + time\\n\\n        for prevCourse, nextCourse in relations:\\n            prereqGraph[nextCourse].append(prevCourse)\\n            \\n        def dfs(src):\\n            if timeCompleted[src] > 0:\\n                return timeCompleted[src]\\n            \\n            timeCompleted[src] = 0\\n\\n            for nxt in prereqGraph[src]:\\n                if timeCompleted[nxt] == 0:\\n                    dfs(nxt)\\n                \\n                timeCompleted[src] = max(timeCompleted[src], timeCompleted[nxt])\\n            \\n            timeCompleted[src] += time[src]\\n        \\n\\n        for src in range(1, n + 1):\\n            if timeCompleted[src] == 0:\\n                dfs(src)\\n        \\n        \\n        return max(timeCompleted)\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nfrom collections import defaultdict\\nclass Solution:\\n    def minimumTime(self, n: int, relations: List[List[int]], time: List[int]) -> int:\\n        prereqGraph = defaultdict(list)\\n\\n        timeCompleted = (n + 1) * [0]\\n\\n        time = [0] + time\\n\\n        for prevCourse, nextCourse in relations:\\n            prereqGraph[nextCourse].append(prevCourse)\\n            \\n        def dfs(src):\\n            if timeCompleted[src] > 0:\\n                return timeCompleted[src]\\n            \\n            timeCompleted[src] = 0\\n\\n            for nxt in prereqGraph[src]:\\n                if timeCompleted[nxt] == 0:\\n                    dfs(nxt)\\n                \\n                timeCompleted[src] = max(timeCompleted[src], timeCompleted[nxt])\\n            \\n            timeCompleted[src] += time[src]\\n        \\n\\n        for src in range(1, n + 1):\\n            if timeCompleted[src] == 0:\\n                dfs(src)\\n        \\n        \\n        return max(timeCompleted)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2781419,
                "title": "c-simple-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n  public:\\n    int minimumTime(int n, vector<vector<int>>& relations, vector<int>& time) {\\n      int ans = INT_MIN;\\n      vector<int> in_degree(n+1);\\n      vector<vector<int>> out(n+1);\\n      for (int i = 0; i < relations.size(); i++) {\\n        out[relations[i][0]].push_back(relations[i][1]);\\n        in_degree[relations[i][1]]++;\\n      }\\n\\n      unordered_map<int, int> dp;\\n      queue<pair<int, int>> q;\\n      for (int i = 1; i < in_degree.size(); i++)\\n        if (in_degree[i] == 0) {\\n          q.push({i, time[i-1]});\\n          dp[i] = time[i-1];\\n        }\\n\\n      while (!q.empty()) {\\n        auto cur = q.front();\\n        q.pop();\\n        ans = max(ans, dp[cur.first]);\\n        for (auto next : out[cur.first]) {\\n          in_degree[next]--;\\n          dp[next] = max(dp[next], dp[cur.first] + time[next-1]);\\n          if (in_degree[next] == 0)\\n            q.push({next, dp[next]});\\n        }\\n      }\\n\\n      return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\n  public:\\n    int minimumTime(int n, vector<vector<int>>& relations, vector<int>& time) {\\n      int ans = INT_MIN;\\n      vector<int> in_degree(n+1);\\n      vector<vector<int>> out(n+1);\\n      for (int i = 0; i < relations.size(); i++) {\\n        out[relations[i][0]].push_back(relations[i][1]);\\n        in_degree[relations[i][1]]++;\\n      }\\n\\n      unordered_map<int, int> dp;\\n      queue<pair<int, int>> q;\\n      for (int i = 1; i < in_degree.size(); i++)\\n        if (in_degree[i] == 0) {\\n          q.push({i, time[i-1]});\\n          dp[i] = time[i-1];\\n        }\\n\\n      while (!q.empty()) {\\n        auto cur = q.front();\\n        q.pop();\\n        ans = max(ans, dp[cur.first]);\\n        for (auto next : out[cur.first]) {\\n          in_degree[next]--;\\n          dp[next] = max(dp[next], dp[cur.first] + time[next-1]);\\n          if (in_degree[next] == 0)\\n            q.push({next, dp[next]});\\n        }\\n      }\\n\\n      return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2762011,
                "title": "python-topological-sort",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nimport heapq\\nfrom collections import defaultdict\\nclass Solution:\\n    def minimumTime(self, n: int, relations: List[List[int]], time: List[int]) -> int:\\n\\n        pre=[0 for i in range(n+1)]\\n        T=[0 for i in range(n+1)]\\n        D=defaultdict(list)\\n        for i in relations:\\n            D[i[0]].append(i[1])\\n            pre[i[1]]+=1\\n\\n        stc=[]\\n        heapq.heapify(stc)\\n        for i in range(1,n+1):\\n            if pre[i]==0:\\n                heapq.heappush(stc,i)\\n        maxx=-1\\n        while stc:\\n            k=stc.pop()\\n            T[k]+=time[k-1]\\n            maxx=max(maxx,T[k])\\n            for j in D[k]:\\n                pre[j]-=1\\n                T[j]=max(T[j],T[k])\\n                if pre[j]==0:\\n                    heapq.heappush(stc,j)\\n        return maxx\\n                \\n                \\n        \\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nimport heapq\\nfrom collections import defaultdict\\nclass Solution:\\n    def minimumTime(self, n: int, relations: List[List[int]], time: List[int]) -> int:\\n\\n        pre=[0 for i in range(n+1)]\\n        T=[0 for i in range(n+1)]\\n        D=defaultdict(list)\\n        for i in relations:\\n            D[i[0]].append(i[1])\\n            pre[i[1]]+=1\\n\\n        stc=[]\\n        heapq.heapify(stc)\\n        for i in range(1,n+1):\\n            if pre[i]==0:\\n                heapq.heappush(stc,i)\\n        maxx=-1\\n        while stc:\\n            k=stc.pop()\\n            T[k]+=time[k-1]\\n            maxx=max(maxx,T[k])\\n            for j in D[k]:\\n                pre[j]-=1\\n                T[j]=max(T[j],T[k])\\n                if pre[j]==0:\\n                    heapq.heappush(stc,j)\\n        return maxx\\n                \\n                \\n        \\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2761657,
                "title": "video-walkthrough",
                "content": "https://youtu.be/gqMOfxlG6UQ\\n\\n```\\nclass Solution:\\n    def minimumTime(self, n: int, relations: List[List[int]], time: List[int]) -> int:\\n        \\n        G = [[] for _ in range(n+1)]\\n        for u,v in relations: G[u].append(v)\\n            \\n            \\n        D = [0] * (n + 1)\\n        \\n        def dfs(u):\\n            if D[u]: return D[u]\\n            D[u] = max((dfs(v) for v in G[u]) ,default=0) + time[u-1]\\n            return D[u]\\n        \\n        for u in range(1,n+1): dfs(u)\\n        return max(D)\\n\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def minimumTime(self, n: int, relations: List[List[int]], time: List[int]) -> int:\\n        \\n        G = [[] for _ in range(n+1)]\\n        for u,v in relations: G[u].append(v)\\n            \\n            \\n        D = [0] * (n + 1)\\n        \\n        def dfs(u):\\n            if D[u]: return D[u]\\n            D[u] = max((dfs(v) for v in G[u]) ,default=0) + time[u-1]\\n            return D[u]\\n        \\n        for u in range(1,n+1): dfs(u)\\n        return max(D)\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2761519,
                "title": "c-python-javascript-bfs",
                "content": "**C++**\\n```\\nclass Solution \\n{\\npublic:\\n    int minimumTime(int n, vector<vector<int>>& relations, vector<int>& time) \\n    {\\n        vector<int> inDegree( n, 0 );\\n        vector<vector<int>> postCources( n, vector<int>{} );\\n        \\n        for ( auto & prePost : relations )\\n        {\\n            ++inDegree[prePost[1] - 1];\\n            postCources[prePost[0] - 1].push_back(prePost[1] - 1);\\n        }      \\n        \\n        int minTime = 0;\\n        vector<Info> options;\\n        vector<int> maxTime = time;\\n        \\n        for ( auto i = 0; i < n; ++i )\\n        {\\n            if ( inDegree[i] == 0 )\\n            {\\n                options.push_back( {i, time[i]} );\\n                minTime = max( minTime, time[i] );\\n            }\\n        }\\n        \\n        while (!options.empty())\\n        {\\n            vector<Info> newOptions;\\n            \\n            for ( auto & el : options )\\n            {\\n                for ( auto & course : postCources[el.idx] )\\n                {\\n                    --inDegree[course];\\n                    maxTime[course] = max( maxTime[course], time[course] + el.time );\\n               \\n                    if ( inDegree[course] == 0 )\\n                    {\\n                        auto tmp = max( maxTime[course], time[course] + el.time );\\n                        newOptions.push_back( {course, tmp} );\\n                        minTime = max( minTime, tmp );\\n                    }                  \\n                }\\n            }\\n            options = newOptions;            \\n        }\\n        \\n        return minTime;\\n    }\\nprivate:\\n    struct Info\\n    {\\n        int idx;\\n        int time;\\n    };\\n};\\n```\\n\\n**Python 3**\\n```\\nclass Solution:            \\n    def minimumTime(self, n: int, relations: List[List[int]], time: List[int]) -> int:\\n        inDegree = [ 0 for i in range(n) ]\\n        postCources = defaultdict(list)\\n        \\n        for pre, post in relations:\\n            inDegree[post - 1] += 1\\n            postCources[pre - 1].append(post - 1)\\n        \\n        minTime = 0\\n        options = []\\n        maxTime = time[:]\\n        \\n        for i in range(n):\\n            if inDegree[i] == 0:\\n                options.append( (i, time[i]) )\\n                minTime = max( minTime, time[i] )\\n                \\n        while options:\\n            newOptions = []\\n            \\n            for idx, months in options:\\n                for course in postCources[idx]:\\n                    inDegree[course] -= 1\\n                    maxTime[course] = max( maxTime[course], time[course] + months )\\n               \\n                    if inDegree[course] == 0:\\n                        tmp = max( maxTime[course], time[course] + months )\\n                        \\n                        newOptions.append( (course, tmp) )\\n                        minTime = max( minTime, tmp )\\n                \\n            options = newOptions          \\n        \\n        return minTime  \\n```\\n\\n**JavaScript**\\n```\\nclass Info {\\n  constructor(idx, months) {\\n    this.idx = idx;\\n    this.months = months;\\n  }\\n}\\n    \\nlet minimumTime = function(n, relations, time) {\\n    let inDegree = new Array(n).fill(0);\\n    let postCources = new Array(n);\\n    for (let i = 0; i < postCources.length; i++) \\n    {\\n        postCources[i] = new Array();\\n    }\\n    \\n    for ( let [pre, post] of relations )\\n    {\\n        ++inDegree[post - 1];\\n        postCources[pre - 1].push(post - 1);\\n    }\\n    \\n    let minTime = 0;\\n    let options = new Array();\\n    let maxTime = time.slice();\\n        \\n    for ( let i = 0; i < n; ++i )\\n    {\\n        if ( inDegree[i] == 0 )\\n        {\\n            options.push( new Info(i, time[i]) );\\n            minTime = Math.max( minTime, time[i] );\\n        }\\n    }\\n    \\n    while (options.length)\\n    {\\n        let newOptions = new Array();\\n\\n        for ( let el of options )\\n        {\\n            for ( let course of postCources[el.idx] )\\n            {\\n                --inDegree[course];\\n                maxTime[course] = Math.max( maxTime[course], time[course] + el.months );\\n\\n                if ( inDegree[course] == 0 )\\n                {\\n                    let tmp = Math.max( maxTime[course], time[course] + el.months );\\n                    newOptions.push( new Info(course, tmp) );\\n                    minTime = Math.max( minTime, tmp );\\n                }                  \\n            }\\n        }\\n        options = newOptions.slice();            \\n    }\\n\\n    return minTime;\\n};\\n```",
                "solutionTags": [
                    "Python",
                    "C",
                    "JavaScript"
                ],
                "code": "```\\nclass Solution \\n{\\npublic:\\n    int minimumTime(int n, vector<vector<int>>& relations, vector<int>& time) \\n    {\\n        vector<int> inDegree( n, 0 );\\n        vector<vector<int>> postCources( n, vector<int>{} );\\n        \\n        for ( auto & prePost : relations )\\n        {\\n            ++inDegree[prePost[1] - 1];\\n            postCources[prePost[0] - 1].push_back(prePost[1] - 1);\\n        }      \\n        \\n        int minTime = 0;\\n        vector<Info> options;\\n        vector<int> maxTime = time;\\n        \\n        for ( auto i = 0; i < n; ++i )\\n        {\\n            if ( inDegree[i] == 0 )\\n            {\\n                options.push_back( {i, time[i]} );\\n                minTime = max( minTime, time[i] );\\n            }\\n        }\\n        \\n        while (!options.empty())\\n        {\\n            vector<Info> newOptions;\\n            \\n            for ( auto & el : options )\\n            {\\n                for ( auto & course : postCources[el.idx] )\\n                {\\n                    --inDegree[course];\\n                    maxTime[course] = max( maxTime[course], time[course] + el.time );\\n               \\n                    if ( inDegree[course] == 0 )\\n                    {\\n                        auto tmp = max( maxTime[course], time[course] + el.time );\\n                        newOptions.push_back( {course, tmp} );\\n                        minTime = max( minTime, tmp );\\n                    }                  \\n                }\\n            }\\n            options = newOptions;            \\n        }\\n        \\n        return minTime;\\n    }\\nprivate:\\n    struct Info\\n    {\\n        int idx;\\n        int time;\\n    };\\n};\\n```\n```\\nclass Solution:            \\n    def minimumTime(self, n: int, relations: List[List[int]], time: List[int]) -> int:\\n        inDegree = [ 0 for i in range(n) ]\\n        postCources = defaultdict(list)\\n        \\n        for pre, post in relations:\\n            inDegree[post - 1] += 1\\n            postCources[pre - 1].append(post - 1)\\n        \\n        minTime = 0\\n        options = []\\n        maxTime = time[:]\\n        \\n        for i in range(n):\\n            if inDegree[i] == 0:\\n                options.append( (i, time[i]) )\\n                minTime = max( minTime, time[i] )\\n                \\n        while options:\\n            newOptions = []\\n            \\n            for idx, months in options:\\n                for course in postCources[idx]:\\n                    inDegree[course] -= 1\\n                    maxTime[course] = max( maxTime[course], time[course] + months )\\n               \\n                    if inDegree[course] == 0:\\n                        tmp = max( maxTime[course], time[course] + months )\\n                        \\n                        newOptions.append( (course, tmp) )\\n                        minTime = max( minTime, tmp )\\n                \\n            options = newOptions          \\n        \\n        return minTime  \\n```\n```\\nclass Info {\\n  constructor(idx, months) {\\n    this.idx = idx;\\n    this.months = months;\\n  }\\n}\\n    \\nlet minimumTime = function(n, relations, time) {\\n    let inDegree = new Array(n).fill(0);\\n    let postCources = new Array(n);\\n    for (let i = 0; i < postCources.length; i++) \\n    {\\n        postCources[i] = new Array();\\n    }\\n    \\n    for ( let [pre, post] of relations )\\n    {\\n        ++inDegree[post - 1];\\n        postCources[pre - 1].push(post - 1);\\n    }\\n    \\n    let minTime = 0;\\n    let options = new Array();\\n    let maxTime = time.slice();\\n        \\n    for ( let i = 0; i < n; ++i )\\n    {\\n        if ( inDegree[i] == 0 )\\n        {\\n            options.push( new Info(i, time[i]) );\\n            minTime = Math.max( minTime, time[i] );\\n        }\\n    }\\n    \\n    while (options.length)\\n    {\\n        let newOptions = new Array();\\n\\n        for ( let el of options )\\n        {\\n            for ( let course of postCources[el.idx] )\\n            {\\n                --inDegree[course];\\n                maxTime[course] = Math.max( maxTime[course], time[course] + el.months );\\n\\n                if ( inDegree[course] == 0 )\\n                {\\n                    let tmp = Math.max( maxTime[course], time[course] + el.months );\\n                    newOptions.push( new Info(course, tmp) );\\n                    minTime = Math.max( minTime, tmp );\\n                }                  \\n            }\\n        }\\n        options = newOptions.slice();            \\n    }\\n\\n    return minTime;\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2717216,
                "title": "easy-short-efficient-clean-code",
                "content": "```\\nclass Solution {\\ntypedef long long ll;\\ntypedef pair<ll, ll> pi;\\n#define vi(x) vector<x>\\n#define pb push_back\\npublic:\\n    class cmp{\\n    public:\\n        bool operator()(const pi&a, const pi&b){\\n            return a.second>b.second;\\n        }\\n    };\\n    int minimumTime(int n, vector<vector<int>>&e, vector<int>&t) {\\n        priority_queue<pi, vi(pi), cmp>pq;\\n        vi(ll)ind(n, 0);\\n        vi(vi(ll))g(n);\\n        for(const auto&edge:e){\\n            ++ind[edge[1]-1];\\n            g[edge[0]-1].pb(edge[1]-1);\\n        }\\n        ll mx=0;\\n        for(ll i=0;i<n;++i){\\n            if(!ind[i]){\\n                pq.push({i, t[i]});\\n            }\\n        }\\n        while(!pq.empty()){\\n            pi p=pq.top();\\n            pq.pop();\\n            mx=max(mx, p.second);\\n            for(const ll&child:g[p.first]){\\n                if(--ind[child]==0){\\n                    pq.push({child, p.second+t[child]});\\n                }\\n            }\\n        }\\n        return mx;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\ntypedef long long ll;\\ntypedef pair<ll, ll> pi;\\n#define vi(x) vector<x>\\n#define pb push_back\\npublic:\\n    class cmp{\\n    public:\\n        bool operator()(const pi&a, const pi&b){\\n            return a.second>b.second;\\n        }\\n    };\\n    int minimumTime(int n, vector<vector<int>>&e, vector<int>&t) {\\n        priority_queue<pi, vi(pi), cmp>pq;\\n        vi(ll)ind(n, 0);\\n        vi(vi(ll))g(n);\\n        for(const auto&edge:e){\\n            ++ind[edge[1]-1];\\n            g[edge[0]-1].pb(edge[1]-1);\\n        }\\n        ll mx=0;\\n        for(ll i=0;i<n;++i){\\n            if(!ind[i]){\\n                pq.push({i, t[i]});\\n            }\\n        }\\n        while(!pq.empty()){\\n            pi p=pq.top();\\n            pq.pop();\\n            mx=max(mx, p.second);\\n            for(const ll&child:g[p.first]){\\n                if(--ind[child]==0){\\n                    pq.push({child, p.second+t[child]});\\n                }\\n            }\\n        }\\n        return mx;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2700595,
                "title": "python-dp-dfs-87-time-12-space",
                "content": "```\\nclass Solution:\\n    def minimumTime(self, n: int, relations: List[List[int]], time: List[int]) -> int:\\n        graph = {}        \\n        for prv, nxt in relations:\\n            if nxt not in graph: graph[nxt] = set()\\n            graph[nxt].add(prv)\\n        \\n        @cache\\n        def dfs(node):\\n            t = time[node - 1]            \\n            max_time = t\\n            for prereq in graph.get(node, []):\\n                max_time = max(max_time, t + dfs(prereq))\\n            return max_time\\n        \\n        output = 0\\n        for node in range(1, n + 1):\\n            output = max(output, dfs(node))\\n        return output",
                "solutionTags": [
                    "Python"
                ],
                "code": "class Solution:\\n    def minimumTime(self, n: int, relations: List[List[int]], time: List[int]) -> int:\\n        graph = {}",
                "codeTag": "Java"
            },
            {
                "id": 2684890,
                "title": "c-topo-sort-dp",
                "content": "```\\nvoid find(vector<vector<int>> &graph,int ind,stack<int> &st,vector<bool> &vis)\\n    {\\n        vis[ind] = true;\\n        for(auto x: graph[ind])\\n        {\\n            if(!vis[x])\\n            {\\n                find(graph,x,st,vis);\\n            }\\n        }\\n        st.push(ind);\\n    }\\n    vector<int> findTopoSort(vector<vector<int>> &graph,int n)\\n    {\\n        stack<int> st;\\n        vector<bool> vis(n,false);\\n        for(int i=0;i<n;i++)\\n        {\\n            if(!vis[i])\\n                find(graph,i,st,vis);\\n        }\\n        \\n        vector<int> ans;\\n        while(!st.empty())\\n        {\\n            ans.push_back(st.top());\\n            st.pop();\\n        }\\n        return ans;\\n    }\\n    int minimumTime(int n, vector<vector<int>>& relations, vector<int>& time) {\\n        vector<vector<int>> graph(n);\\n        vector<vector<int>> incomEdge(n);\\n        for(auto x: relations)\\n        {\\n            graph[x[0]-1].push_back(x[1]-1);\\n            incomEdge[x[1]-1].push_back(x[0]-1);\\n        }\\n        \\n        vector<int> topo = findTopoSort(graph,n);\\n        int ans = INT_MIN;\\n        vector<int> mp(n);\\n        for(int i=0;i<n;i++)\\n        {\\n            int need = 0;\\n            for(auto x: incomEdge[topo[i]])\\n            {\\n                need = max(need,mp[x]);\\n            }\\n            mp[topo[i]] = need+time[topo[i]];\\n            ans = max(ans,mp[topo[i]]);\\n        }\\n        return ans;\\n    }\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Topological Sort"
                ],
                "code": "```\\nvoid find(vector<vector<int>> &graph,int ind,stack<int> &st,vector<bool> &vis)\\n    {\\n        vis[ind] = true;\\n        for(auto x: graph[ind])\\n        {\\n            if(!vis[x])\\n            {\\n                find(graph,x,st,vis);\\n            }\\n        }\\n        st.push(ind);\\n    }\\n    vector<int> findTopoSort(vector<vector<int>> &graph,int n)\\n    {\\n        stack<int> st;\\n        vector<bool> vis(n,false);\\n        for(int i=0;i<n;i++)\\n        {\\n            if(!vis[i])\\n                find(graph,i,st,vis);\\n        }\\n        \\n        vector<int> ans;\\n        while(!st.empty())\\n        {\\n            ans.push_back(st.top());\\n            st.pop();\\n        }\\n        return ans;\\n    }\\n    int minimumTime(int n, vector<vector<int>>& relations, vector<int>& time) {\\n        vector<vector<int>> graph(n);\\n        vector<vector<int>> incomEdge(n);\\n        for(auto x: relations)\\n        {\\n            graph[x[0]-1].push_back(x[1]-1);\\n            incomEdge[x[1]-1].push_back(x[0]-1);\\n        }\\n        \\n        vector<int> topo = findTopoSort(graph,n);\\n        int ans = INT_MIN;\\n        vector<int> mp(n);\\n        for(int i=0;i<n;i++)\\n        {\\n            int need = 0;\\n            for(auto x: incomEdge[topo[i]])\\n            {\\n                need = max(need,mp[x]);\\n            }\\n            mp[topo[i]] = need+time[topo[i]];\\n            ans = max(ans,mp[topo[i]]);\\n        }\\n        return ans;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2684110,
                "title": "very-easy-java-solution-using-khan-s-algorithm",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nTopological Sort\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int minimumTime(int n, int[][] relations, int[] time) {\\n        HashMap<Integer,Integer> hm1 =new HashMap<>();\\n        for(int i=0;i<time.length;i++)\\n        {\\n            hm1.put((i+1),time[i]);\\n        }            \\n        int []dist =new int[n+1];        \\n        ArrayList<ArrayList<Integer>> adj =new ArrayList<ArrayList<Integer>>(n+1);\\n        for(int i=0;i<n+1;i++)\\n        {\\n            adj.add(new ArrayList<Integer>());\\n        }\\n        int []indegree =new int[n+1];\\n        for(int []t1:relations)\\n        {\\n            int u=t1[0];\\n            int v=t1[1];\\n            indegree[v]++;\\n            addEdge(adj,u,v);\\n        }\\n        Queue<Integer> q1 =new LinkedList<Integer>();\\n        for(int i=1;i<indegree.length;i++)\\n        {\\n            if(indegree[i]==0)\\n            {\\n                q1.add(i);\\n                dist[i]=hm1.get(i);\\n            }\\n        }\\n        \\n        int ans=0;\\n        int max=0;\\n        while(q1.isEmpty()==false)\\n        {\\n            int temp=q1.poll();            \\n            for(int u:adj.get(temp))\\n            {\\n                dist[u]=Math.max(dist[temp]+hm1.get(u),dist[u]);\\n                indegree[u]--;\\n                if(indegree[u]==0)\\n                {\\n                    q1.add(u);\\n                }\\n            }            \\n        }\\n       for(int i=0;i<dist.length;i++)\\n       {\\n           ans=Math.max(ans,dist[i]);\\n       }\\n       return ans; \\n    }\\n    public void addEdge(ArrayList<ArrayList<Integer>> adj,int u,int v)\\n    {\\n        adj.get(u).add(v);\\n    }    \\n}\\n\\n\\n\\n\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int minimumTime(int n, int[][] relations, int[] time) {\\n        HashMap<Integer,Integer> hm1 =new HashMap<>();\\n        for(int i=0;i<time.length;i++)\\n        {\\n            hm1.put((i+1),time[i]);\\n        }            \\n        int []dist =new int[n+1];        \\n        ArrayList<ArrayList<Integer>> adj =new ArrayList<ArrayList<Integer>>(n+1);\\n        for(int i=0;i<n+1;i++)\\n        {\\n            adj.add(new ArrayList<Integer>());\\n        }\\n        int []indegree =new int[n+1];\\n        for(int []t1:relations)\\n        {\\n            int u=t1[0];\\n            int v=t1[1];\\n            indegree[v]++;\\n            addEdge(adj,u,v);\\n        }\\n        Queue<Integer> q1 =new LinkedList<Integer>();\\n        for(int i=1;i<indegree.length;i++)\\n        {\\n            if(indegree[i]==0)\\n            {\\n                q1.add(i);\\n                dist[i]=hm1.get(i);\\n            }\\n        }\\n        \\n        int ans=0;\\n        int max=0;\\n        while(q1.isEmpty()==false)\\n        {\\n            int temp=q1.poll();            \\n            for(int u:adj.get(temp))\\n            {\\n                dist[u]=Math.max(dist[temp]+hm1.get(u),dist[u]);\\n                indegree[u]--;\\n                if(indegree[u]==0)\\n                {\\n                    q1.add(u);\\n                }\\n            }            \\n        }\\n       for(int i=0;i<dist.length;i++)\\n       {\\n           ans=Math.max(ans,dist[i]);\\n       }\\n       return ans; \\n    }\\n    public void addEdge(ArrayList<ArrayList<Integer>> adj,int u,int v)\\n    {\\n        adj.get(u).add(v);\\n    }    \\n}\\n\\n\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2683994,
                "title": "python-o-max-n-e-recursive-solution-with-detailed-explanation",
                "content": "**4 Ideas**\\n\\n1. We know that the minimum time to complete a particular course is simply the sum of the minimum time to complete its prerequisites and the time to take the course itself. And because we can take courses simultaneously, we derive a recursive formula: `t(course) = max(t(prereqs)) + time[course]`. Thus the following function to calculate the time taken to complete a particular course:\\n\\t```\\n\\tdef t(course):\\n        tp = 0\\n        for prereq in p[course]: # where p[course] returns the prereqs of course\\n            tp = max(tp, t(prereq))\\n\\t\\treturn tp + time[course - 1]\\n\\t```\\n\\tMore concisely, if you like to think of this in terms of mapping:\\n\\t```\\n\\tdef t(course):\\n\\t\\treturn time[course - 1] + max([*map(t, p[course])], default=0)\\n\\t```\\n2. Since it is guaranteed that we can complete all the courses, our answer would simply be the maximum of the function `t` over all the courses. Thus the following solution:\\n\\t```\\n\\tdef minimumTime(self, n, relations, time):\\n\\t\\tdef t(course):\\n\\t\\t\\treturn time[course - 1] + max([*map(t, p[course])], default=0)\\n\\t\\t\\t\\n\\t\\t# Build the prereq hash map\\n\\t\\tp = collections.defaultdict(list)\\n\\t\\tfor prereq, course in relations:\\n\\t\\t\\tp[course].append(prereq)\\n\\t\\t\\n\\t\\t# Find maximum\\n\\t\\tT = 0\\n\\t\\tfor course in range(1, n + 1):\\n\\t\\t\\tT = max(T, t(course))\\n\\t\\t\\n\\t\\t# Or in terms of mapping as follows:\\n\\t\\t# T = max([*map(t, range(n))])\\n\\t\\t\\n\\t\\treturn T\\n\\t```\\n3. The time complexity of the solution above is `O(NE)` where `N` and `E` are the number of nodes and edges, respectively. We observe that it might calculate the function `t` multiple times for the same course (for example, if course 1 is a prereq for course 5, then when it calculates `t(5)`, it will calculate `t(1)` again). We can avoid this redundancy by store the results in a hash map, i.e. by caching the calculations, using a the `cache` decorator from `functools`.\\n\\t```\\n\\t@cache\\n\\tdef t(course):\\n\\t\\treturn time[course - 1] + max([*map(t, p[course])], default=0)\\n\\t```\\n4. Even with this improvement, the time complexity is `O(N + E)`, since we go through each node and each edge at most once. How can we improve this to `O(max(N, E))`? We make another observation: if the size of `memo` is `N`, then there\\'s no point in continuing the last `for` loop. At that point, `t` must have been calculated for all courses! So we add a condition to the last `for` loop: `if t.cache_info()[3] == n: return T` (where `t.cache_info()[3]` returns the number of values of `t` we have cached). This way, we guarantee that `t` is calculated at most `N` times, and when it is, we return the max value. (The reason why `T` must be the max value is that the time needed to complete any course is greater than the time needed to complete its prerequisites.)\\n\\nThe dominating factor is now either the `for` loop we used to create the prereq hash map (`O(E)`), or the `for` loop at the end (`O(N)`).\\n\\nThe following is the complete `O(max(N, E))` solution as promised:\\n```\\ndef minimumTime(self, n: int, relations: List[List[int]], time: List[int]) -> int:\\n\\t@cache\\n\\tdef t(course):\\n\\t\\treturn time[course - 1] + max([*map(t, p[course])], default=0)\\n        \\n\\t# Build the prereq hash map\\n\\tp = collections.defaultdict(list)\\n\\tfor prereq, course in relations:\\n\\t   p[course].append(prereq)\\n\\n\\t# Find maximum\\n\\tT = 0\\n\\tfor course in range(1, n + 1):\\n\\t\\tT = max(T, t(course))\\n\\t\\tif t.cache_info()[3] == n:\\n\\t\\t\\treturn T\\n```",
                "solutionTags": [],
                "code": "```\\n\\tdef t(course):\\n        tp = 0\\n        for prereq in p[course]: # where p[course] returns the prereqs of course\\n            tp = max(tp, t(prereq))\\n\\t\\treturn tp + time[course - 1]\\n\\t```\n```\\n\\tdef t(course):\\n\\t\\treturn time[course - 1] + max([*map(t, p[course])], default=0)\\n\\t```\n```\\n\\tdef minimumTime(self, n, relations, time):\\n\\t\\tdef t(course):\\n\\t\\t\\treturn time[course - 1] + max([*map(t, p[course])], default=0)\\n\\t\\t\\t\\n\\t\\t# Build the prereq hash map\\n\\t\\tp = collections.defaultdict(list)\\n\\t\\tfor prereq, course in relations:\\n\\t\\t\\tp[course].append(prereq)\\n\\t\\t\\n\\t\\t# Find maximum\\n\\t\\tT = 0\\n\\t\\tfor course in range(1, n + 1):\\n\\t\\t\\tT = max(T, t(course))\\n\\t\\t\\n\\t\\t# Or in terms of mapping as follows:\\n\\t\\t# T = max([*map(t, range(n))])\\n\\t\\t\\n\\t\\treturn T\\n\\t```\n```\\n\\t@cache\\n\\tdef t(course):\\n\\t\\treturn time[course - 1] + max([*map(t, p[course])], default=0)\\n\\t```\n```\\ndef minimumTime(self, n: int, relations: List[List[int]], time: List[int]) -> int:\\n\\t@cache\\n\\tdef t(course):\\n\\t\\treturn time[course - 1] + max([*map(t, p[course])], default=0)\\n        \\n\\t# Build the prereq hash map\\n\\tp = collections.defaultdict(list)\\n\\tfor prereq, course in relations:\\n\\t   p[course].append(prereq)\\n\\n\\t# Find maximum\\n\\tT = 0\\n\\tfor course in range(1, n + 1):\\n\\t\\tT = max(T, t(course))\\n\\t\\tif t.cache_info()[3] == n:\\n\\t\\t\\treturn T\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2676153,
                "title": "python-simple-topological-sort-dynamic-programming",
                "content": "\\n    def minimumTime(self, n, relations, time):\\n        dict1, indegree, latest = defaultdict(list), defaultdict(int), [0] + time\\n        \\n        for i,j in relations:\\n            dict1[i].append(j)\\n            indegree[j] += 1\\n            \\n        stack = [i for i in range(1,n+1) if indegree[i] == 0]\\n        \\n        while stack:\\n            node = stack.pop(0)\\n            for neighbor in dict1[node]:\\n                latest[neighbor] = max(latest[neighbor], time[neighbor-1] + latest[node])\\n                indegree[neighbor] -= 1\\n                if indegree[neighbor] == 0:\\n                    stack.append(neighbor)\\n    \\n        return max(latest)",
                "solutionTags": [],
                "code": "\\n    def minimumTime(self, n, relations, time):\\n        dict1, indegree, latest = defaultdict(list), defaultdict(int), [0] + time\\n        \\n        for i,j in relations:\\n            dict1[i].append(j)\\n            indegree[j] += 1\\n            \\n        stack = [i for i in range(1,n+1) if indegree[i] == 0]\\n        \\n        while stack:\\n            node = stack.pop(0)\\n            for neighbor in dict1[node]:\\n                latest[neighbor] = max(latest[neighbor], time[neighbor-1] + latest[node])\\n                indegree[neighbor] -= 1\\n                if indegree[neighbor] == 0:\\n                    stack.append(neighbor)\\n    \\n        return max(latest)",
                "codeTag": "Python3"
            },
            {
                "id": 2674755,
                "title": "bfs-c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    \\nint minimumTime(int n, vector<vector<int>> &relations, vector<int> &time)\\n{\\n    map<int, vector<pair<int,int> > > adj;\\n    vector<int> indeg(n+1,0);\\n    vector<int> outdeg(n+1,0);\\n   // int i=0;\\n    for(auto it: relations)\\n    {\\n        adj[it[0]].push_back({time[it[0]-1],it[1]});\\n        indeg[it[1]]++;\\n        outdeg[it[0]]++;\\n    }\\n    priority_queue< pair<int,int> , vector<pair<int,int> > > pq;\\n    vector<int> dist(n+1,INT_MIN);\\n    for(int i=1;i<indeg.size();i++)\\n    {\\n        if(indeg[i]==0)\\n        {\\n           pq.push({0,i});\\n           dist[i]=0;\\n           while(!pq.empty())\\n           {\\n            int prevdist= pq.top().first;\\n            int prev=pq.top().second;\\n                  pq.pop();\\n            for(auto it: adj[prev])\\n            {\\n                int next= it.second;\\n                int nextdist=it.first;\\n                 if(dist[prev] + nextdist > dist[next])\\n                 {\\n                    dist[next]= dist[prev]+ nextdist;\\n                    pq.push({dist[next],next});\\n                 }\\n            }\\n           }\\n        }\\n    }\\n    for(int i=1;i<outdeg.size();i++) if(outdeg[i]==0) dist[i] +=time[i-1];\\n    int ans=INT_MIN;\\n    for(auto it: dist) ans=max(ans,it);\\n    return ans;\\n}\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Breadth-First Search",
                    "Graph"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\nint minimumTime(int n, vector<vector<int>> &relations, vector<int> &time)\\n{\\n    map<int, vector<pair<int,int> > > adj;\\n    vector<int> indeg(n+1,0);\\n    vector<int> outdeg(n+1,0);\\n   // int i=0;\\n    for(auto it: relations)\\n    {\\n        adj[it[0]].push_back({time[it[0]-1],it[1]});\\n        indeg[it[1]]++;\\n        outdeg[it[0]]++;\\n    }\\n    priority_queue< pair<int,int> , vector<pair<int,int> > > pq;\\n    vector<int> dist(n+1,INT_MIN);\\n    for(int i=1;i<indeg.size();i++)\\n    {\\n        if(indeg[i]==0)\\n        {\\n           pq.push({0,i});\\n           dist[i]=0;\\n           while(!pq.empty())\\n           {\\n            int prevdist= pq.top().first;\\n            int prev=pq.top().second;\\n                  pq.pop();\\n            for(auto it: adj[prev])\\n            {\\n                int next= it.second;\\n                int nextdist=it.first;\\n                 if(dist[prev] + nextdist > dist[next])\\n                 {\\n                    dist[next]= dist[prev]+ nextdist;\\n                    pq.push({dist[next],next});\\n                 }\\n            }\\n           }\\n        }\\n    }\\n    for(int i=1;i<outdeg.size();i++) if(outdeg[i]==0) dist[i] +=time[i-1];\\n    int ans=INT_MIN;\\n    for(auto it: dist) ans=max(ans,it);\\n    return ans;\\n}\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2671252,
                "title": "python3-topological-sort-priority-queue",
                "content": "\\n```\\nclass Solution:\\n    def minimumTime(self, n: int, relations: List[List[int]], time: List[int]) -> int:\\n        adj_list = collections.defaultdict(list)\\n        indegree = [0] * n\\n        for prev, next in relations:\\n            adj_list[prev].append(next)\\n            indegree[next - 1] += 1\\n\\n        queue = []\\n\\n        for i in range(n):\\n            if not indegree[i]:\\n                heapq.heappush(queue, (time[i], i + 1))\\n\\n        endtime = 0\\n\\n        while queue:\\n            endtime, course = heapq.heappop(queue)\\n\\n            for neighbor in adj_list[course]:\\n                indegree[neighbor - 1] -= 1\\n                if not indegree[neighbor - 1]:\\n                    heapq.heappush(queue, (endtime + time[neighbor - 1], neighbor))\\n\\n        return endtime\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minimumTime(self, n: int, relations: List[List[int]], time: List[int]) -> int:\\n        adj_list = collections.defaultdict(list)\\n        indegree = [0] * n\\n        for prev, next in relations:\\n            adj_list[prev].append(next)\\n            indegree[next - 1] += 1\\n\\n        queue = []\\n\\n        for i in range(n):\\n            if not indegree[i]:\\n                heapq.heappush(queue, (time[i], i + 1))\\n\\n        endtime = 0\\n\\n        while queue:\\n            endtime, course = heapq.heappop(queue)\\n\\n            for neighbor in adj_list[course]:\\n                indegree[neighbor - 1] -= 1\\n                if not indegree[neighbor - 1]:\\n                    heapq.heappush(queue, (endtime + time[neighbor - 1], neighbor))\\n\\n        return endtime\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2640475,
                "title": "java-dfs-dp-98-faster-83-memory",
                "content": "```class Solution {\\n    LinkedList<Integer>[] graph;\\n    int[] weights;\\n    public int minimumTime(int n, int[][] relations, int[] time) {\\n        weights = time;\\n        graph = new LinkedList[n+1];\\n        Integer[] cache = new Integer[n + 1];\\n        for (int i = 0; i < relations.length; i++) {\\n            if (graph[relations[i][1]] == null) {\\n                graph[relations[i][1]] = new LinkedList<>();\\n            } \\n            graph[relations[i][1]].add(relations[i][0]);\\n        }\\n        int max = 0; \\n        for (int i = n; i >= 1; i--) {\\n            if (cache[i] == null) {\\n                int res = dfs(i, cache);\\n                max = max < res ? res : max;\\n            }\\n        }\\n        return max;\\n    }\\n    public int dfs(int vertex, Integer[] cache) {\\n        if (cache[vertex] != null) return cache[vertex];\\n        int max = 0;\\n        if (graph[vertex] != null) {\\n            for (Integer edge : graph[vertex]) {\\n                int res = dfs(edge, cache);\\n                max = max < res ? res : max;\\n            }\\n        }\\n        cache[vertex] = max + weights[vertex - 1];\\n        return max + weights[vertex - 1];\\n    }\\n}```",
                "solutionTags": [
                    "Dynamic Programming",
                    "Depth-First Search"
                ],
                "code": "```class Solution {\\n    LinkedList<Integer>[] graph;\\n    int[] weights;\\n    public int minimumTime(int n, int[][] relations, int[] time) {\\n        weights = time;\\n        graph = new LinkedList[n+1];\\n        Integer[] cache = new Integer[n + 1];\\n        for (int i = 0; i < relations.length; i++) {\\n            if (graph[relations[i][1]] == null) {\\n                graph[relations[i][1]] = new LinkedList<>();\\n            } \\n            graph[relations[i][1]].add(relations[i][0]);\\n        }\\n        int max = 0; \\n        for (int i = n; i >= 1; i--) {\\n            if (cache[i] == null) {\\n                int res = dfs(i, cache);\\n                max = max < res ? res : max;\\n            }\\n        }\\n        return max;\\n    }\\n    public int dfs(int vertex, Integer[] cache) {\\n        if (cache[vertex] != null) return cache[vertex];\\n        int max = 0;\\n        if (graph[vertex] != null) {\\n            for (Integer edge : graph[vertex]) {\\n                int res = dfs(edge, cache);\\n                max = max < res ? res : max;\\n            }\\n        }\\n        cache[vertex] = max + weights[vertex - 1];\\n        return max + weights[vertex - 1];\\n    }\\n}```",
                "codeTag": "Java"
            },
            {
                "id": 2634507,
                "title": "kotlin-solution",
                "content": "\\tclass Solution {\\n\\t\\tfun minimumTime(n: Int, relations: Array<IntArray>, time: IntArray): Int {\\n\\t\\t\\tval allCourses = mutableListOf<Course>()\\n\\n\\t\\t\\tfor (i in 0 until n) {\\n\\t\\t\\t\\tallCourses.add(Course(i).apply {\\n\\t\\t\\t\\t\\tduration = time[i]\\n\\t\\t\\t\\t\\ttotalDuration = duration\\n\\t\\t\\t\\t})\\n\\t\\t\\t}\\n\\n\\t\\t\\tfor (i in relations.indices) {\\n\\t\\t\\t\\tval linkedCourses = relations[i]\\n\\t\\t\\t\\tval nextCourse = allCourses[linkedCourses[1] - 1]\\n\\t\\t\\t\\tval currentCourse = allCourses[linkedCourses[0] - 1]\\n\\n\\t\\t\\t\\tcurrentCourse.nextCourses.add(nextCourse)\\n\\t\\t\\t\\tnextCourse.lockers++\\n\\t\\t\\t}\\n\\n\\t\\t\\tvar allCoursesDuration = 0\\n\\t\\t\\tval inWork: Queue<Course> = ArrayDeque()\\n\\t\\t\\tallCourses.forEach { if (it.lockers == 0) inWork.offer(it) }\\n\\n\\t\\t\\twhile (!inWork.isEmpty()) {\\n\\t\\t\\t\\tval currentCourse = inWork.poll()\\n\\t\\t\\t\\tcurrentCourse?.nextCourses?.forEach {\\n\\t\\t\\t\\t\\tit.lockers--\\n\\t\\t\\t\\t\\tit.totalDuration = Math.max(it.totalDuration, currentCourse.totalDuration + it.duration)\\n\\n\\t\\t\\t\\t\\tif (it.lockers == 0) inWork.offer(it)\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tallCoursesDuration = Math.max(allCoursesDuration, currentCourse?.totalDuration ?: 0)\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn allCoursesDuration\\n\\t\\t}\\n\\n\\t\\tdata class Course(val id: Int) {\\n\\t\\t\\tvar lockers: Int = 0\\n\\t\\t\\tvar nextCourses = mutableListOf<Course>()\\n\\t\\t\\tvar duration: Int = 0\\n\\t\\t\\tvar totalDuration: Int = 0\\n\\t\\t}\\n\\t}",
                "solutionTags": [
                    "Kotlin",
                    "Topological Sort"
                ],
                "code": "class Solution {\\n\\t\\tfun minimumTime(n: Int, relations: Array<IntArray>, time: IntArray): Int {\\n\\t\\t\\tval allCourses = mutableListOf<Course>()\\n\\n\\t\\t\\tfor (i in 0 until n) {\\n\\t\\t\\t\\tallCourses.add(Course(i).apply {\\n\\t\\t\\t\\t\\tduration = time[i]\\n\\t\\t\\t\\t\\ttotalDuration = duration\\n\\t\\t\\t\\t}",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1970655,
                "content": [
                    {
                        "username": "RohitSgh",
                        "content": "Following strategy _**may**_ seem intuitive to have the fastest learning speed.\\n\\n> \"Learn all courses available *(courses with all prerequisites fulfilled)* as a single batch. The time taken for the batch will be maximum time taken for any course in the batch. Thus solving batch-wise, the minimum total time taken to complete all the courses will be the sum of time taken for each batch.\"\\n\\nThis strategy can be labeled as the **Greedy** approach as we are greedily trying to learn all courses available. However, **THIS VERSION** of Greedy is SUB-OPTIMAL, and may not guarantee OPTIMAL minimum time.\\n\\nTo **prove that the greedy algorithm is not optimal**, it suffices to [give one counterexample](https://cs.stackexchange.com/questions/151534/formal-proof-on-why-greedy-isnt-working-on-one-particular-problem#comment318613_151534)\\n\\nHere is one such counterexample\\n\\n> **Input:** `n = 5, relations = [[1,2],[2,5],[3,4],[4,5]], time = [2, 7, 10, 2, 3]`\\n>\\n> ![Parallel-Courses-III.png](https://assets.leetcode.com/users/images/0939fa46-cd0d-4572-86be-ba0cb6d6953f_1689402716.2651248.png)\\n> If we take all available courses as a single batch, and then extend the new batch by adding courses with all prerequisites fulfilled, then the time taken will be $\\\\max(2, 10) + \\\\max(7, 2) + \\\\max(3) = 10 + 7 + 3 = 20$.\\n> \\n> However, we can realize that by end of $12$ months, we can complete courses `[1, 2, 3, 4]`. Then complete `[5]` afterwards. Thus, the minimum time taken is $12 + 3 = 15$. Hence, $15$ is the optimal solution.\\n\\n\\n**Bottom-line:** Solving batch-by-batch and taking the maximum time taken for any course in the batch, and then summing up the time taken for each batch, is not optimal. The logical intuition of failure of THIS VERSION of Greedy is that the moment one course in the current batch is being learned, we may complete other courses which are not in the current batch but available NOW because its prerequisites are satisfied by some just-completed courses of the current batch. _It\\'s not necessary to wait for all courses in the current batch to be completed to start newly available courses._\\n\\n**Solution:** We might have to move to some DIFFERENT VERSION of Greedy, or move to some different algorithm paradigm."
                    },
                    {
                        "username": "ayush6203",
                        "content": "You can use topological sorting along with maintaining one more array which holds the Maximum months invested to reach nth course."
                    },
                    {
                        "username": "lucifer_65",
                        "content": "Should have been medium, as it simply asks to find path with max sum"
                    }
                ]
            },
            {
                "id": 2035813,
                "content": [
                    {
                        "username": "RohitSgh",
                        "content": "Following strategy _**may**_ seem intuitive to have the fastest learning speed.\\n\\n> \"Learn all courses available *(courses with all prerequisites fulfilled)* as a single batch. The time taken for the batch will be maximum time taken for any course in the batch. Thus solving batch-wise, the minimum total time taken to complete all the courses will be the sum of time taken for each batch.\"\\n\\nThis strategy can be labeled as the **Greedy** approach as we are greedily trying to learn all courses available. However, **THIS VERSION** of Greedy is SUB-OPTIMAL, and may not guarantee OPTIMAL minimum time.\\n\\nTo **prove that the greedy algorithm is not optimal**, it suffices to [give one counterexample](https://cs.stackexchange.com/questions/151534/formal-proof-on-why-greedy-isnt-working-on-one-particular-problem#comment318613_151534)\\n\\nHere is one such counterexample\\n\\n> **Input:** `n = 5, relations = [[1,2],[2,5],[3,4],[4,5]], time = [2, 7, 10, 2, 3]`\\n>\\n> ![Parallel-Courses-III.png](https://assets.leetcode.com/users/images/0939fa46-cd0d-4572-86be-ba0cb6d6953f_1689402716.2651248.png)\\n> If we take all available courses as a single batch, and then extend the new batch by adding courses with all prerequisites fulfilled, then the time taken will be $\\\\max(2, 10) + \\\\max(7, 2) + \\\\max(3) = 10 + 7 + 3 = 20$.\\n> \\n> However, we can realize that by end of $12$ months, we can complete courses `[1, 2, 3, 4]`. Then complete `[5]` afterwards. Thus, the minimum time taken is $12 + 3 = 15$. Hence, $15$ is the optimal solution.\\n\\n\\n**Bottom-line:** Solving batch-by-batch and taking the maximum time taken for any course in the batch, and then summing up the time taken for each batch, is not optimal. The logical intuition of failure of THIS VERSION of Greedy is that the moment one course in the current batch is being learned, we may complete other courses which are not in the current batch but available NOW because its prerequisites are satisfied by some just-completed courses of the current batch. _It\\'s not necessary to wait for all courses in the current batch to be completed to start newly available courses._\\n\\n**Solution:** We might have to move to some DIFFERENT VERSION of Greedy, or move to some different algorithm paradigm."
                    },
                    {
                        "username": "ayush6203",
                        "content": "You can use topological sorting along with maintaining one more array which holds the Maximum months invested to reach nth course."
                    },
                    {
                        "username": "lucifer_65",
                        "content": "Should have been medium, as it simply asks to find path with max sum"
                    }
                ]
            }
        ]
    }
]