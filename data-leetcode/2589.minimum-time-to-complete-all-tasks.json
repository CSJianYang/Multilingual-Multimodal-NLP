[
    {
        "title": "Minimum Time to Complete All Tasks",
        "question_content": "There is a computer that can run an unlimited number of tasks at the same time. You are given a 2D integer array tasks where tasks[i] = [starti, endi, durationi] indicates that the ith task should run for a total of durationi seconds (not necessarily continuous) within the inclusive time range [starti, endi].\nYou may turn on the computer only when it needs to run a task. You can also turn it off if it is idle.\nReturn the minimum time during which the computer should be turned on to complete all tasks.\n&nbsp;\nExample 1:\n\nInput: tasks = [[2,3,1],[4,5,1],[1,5,2]]\nOutput: 2\nExplanation: \n- The first task can be run in the inclusive time range [2, 2].\n- The second task can be run in the inclusive time range [5, 5].\n- The third task can be run in the two inclusive time ranges [2, 2] and [5, 5].\nThe computer will be on for a total of 2 seconds.\n\nExample 2:\n\nInput: tasks = [[1,3,2],[2,5,3],[5,6,2]]\nOutput: 4\nExplanation: \n- The first task can be run in the inclusive time range [2, 3].\n- The second task can be run in the inclusive time ranges [2, 3] and [5, 5].\n- The third task can be run in the two inclusive time range [5, 6].\nThe computer will be on for a total of 4 seconds.\n\n&nbsp;\nConstraints:\n\n\t1 <= tasks.length <= 2000\n\ttasks[i].length == 3\n\t1 <= starti, endi <= 2000\n\t1 <= durationi <= endi - starti + 1",
        "solutions": [
            {
                "id": 3286244,
                "title": "number-line",
                "content": "We first sort tasks by the end time. \\n    \\nFor the task with the closest end time, the best strategy is to finish it as late as possible.\\n\\n    \\nThat way, we have the best chance for the computer time to be reused by tasks that end later.\\n\\nWe use `line` to mark the computer \"on\" slots. When we process a task, we count \"on\" slots within the interval.\\n\\n> We can use BIT to get the number of \"on\" slots for an interval - see the solutoin below.\\n\\nIf we still need additional time to finish the task, we pick available slots starting from the end time (as late as possible).\\n    \\n**C++**\\n```cpp\\nint findMinimumTime(vector<vector<int>>& tasks) {\\n    int line[2001] = {};\\n    sort(begin(tasks), end(tasks), [](const auto &t1, const auto &t2){\\n        return t1[1] < t2[1];\\n    });\\n    for (auto &t : tasks) {\\n        int st = t[0], end = t[1], d = t[2];\\n        d -= count(begin(line) + st, begin(line) + end + 1, true);\\n        for (int i = end; d > 0; --i) {\\n            d -= !line[i];\\n            line[i] = true;\\n        }\\n    }\\n    return count(begin(line), end(line), true);\\n}\\n```\\n\\n## BIT\\nSame as above, optimized with mutable prefix sum (BIT) to get the number of \"on\" slots.\\n**C++**\\n```cpp\\nint bt[2002] = {}, n = 2001;\\nint prefix_sum(int i)\\n{\\n    int sum = 0;\\n    for (i = i + 1; i > 0; i -= i & (-i))\\n        sum += bt[i];\\n    return sum;\\n}\\nvoid add(int i, int val)\\n{\\n    for (i = i + 1; i <= n; i += i & (-i))\\n        bt[i] += val;\\n}\\nint findMinimumTime(vector<vector<int>>& tasks) {\\n    sort(begin(tasks), end(tasks), [](const auto &t1, const auto &t2){\\n        return t1[1] < t2[1];\\n    });\\n    for (const auto &t : tasks) {\\n        int start = t[0], end = t[1], d = t[2];\\n        d -= prefix_sum(end) - prefix_sum(start - 1);\\n        for (int i = end; d > 0; --i)\\n            if (prefix_sum(i) == prefix_sum(i - 1)) {\\n                add(i, 1);\\n                --d;\\n            }\\n    }\\n    return prefix_sum(n - 1);\\n}  \\n```",
                "solutionTags": [],
                "code": "```cpp\\nint findMinimumTime(vector<vector<int>>& tasks) {\\n    int line[2001] = {};\\n    sort(begin(tasks), end(tasks), [](const auto &t1, const auto &t2){\\n        return t1[1] < t2[1];\\n    });\\n    for (auto &t : tasks) {\\n        int st = t[0], end = t[1], d = t[2];\\n        d -= count(begin(line) + st, begin(line) + end + 1, true);\\n        for (int i = end; d > 0; --i) {\\n            d -= !line[i];\\n            line[i] = true;\\n        }\\n    }\\n    return count(begin(line), end(line), true);\\n}\\n```\n```cpp\\nint bt[2002] = {}, n = 2001;\\nint prefix_sum(int i)\\n{\\n    int sum = 0;\\n    for (i = i + 1; i > 0; i -= i & (-i))\\n        sum += bt[i];\\n    return sum;\\n}\\nvoid add(int i, int val)\\n{\\n    for (i = i + 1; i <= n; i += i & (-i))\\n        bt[i] += val;\\n}\\nint findMinimumTime(vector<vector<int>>& tasks) {\\n    sort(begin(tasks), end(tasks), [](const auto &t1, const auto &t2){\\n        return t1[1] < t2[1];\\n    });\\n    for (const auto &t : tasks) {\\n        int start = t[0], end = t[1], d = t[2];\\n        d -= prefix_sum(end) - prefix_sum(start - 1);\\n        for (int i = end; d > 0; --i)\\n            if (prefix_sum(i) == prefix_sum(i - 1)) {\\n                add(i, 1);\\n                --d;\\n            }\\n    }\\n    return prefix_sum(n - 1);\\n}  \\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3286311,
                "title": "intuition-explained-video-solution-just-sort-greedy-c-java",
                "content": "# Intuition\\nCan We do this greedily? \\nQ. If a task has the earliest end time would it be beneficial for me to run it as late as possible or as early as possible?\\nA. Obviously I would want to run it as late so that it has maximum overlap (if any) with other tasks. \\n\\n\\n# Approach\\nThe above observation can be extended to all task, so we need to sort the tasks based on their end time. Now for its duration check for the time slices at which we are already having our system on. For those we can run this task too. Let\\u2019s say for the time in the range of this task the system was on for x unit of time. Now if our task requires a runtime of d units where d>x, then we would try to greedily run this for another d-x units (as late as possible). Let\\'s run it as late as possible and then move to the next task in order. \\nThe code is self-explanatory. \\nVideo solution: https://youtu.be/M7CHCuhkYrI\\n\\n\\n# Complexity\\n- Time complexity:\\no(n*TotalTimeDuration)\\n\\n- Space complexity:\\nO(Total Time Duration)\\n\\n# Code\\nC++\\n```C++\\nclass Solution {\\npublic:\\n    int findMinimumTime(vector<vector<int>>& tasks) {\\n        sort(tasks.begin(),tasks.end(),[](vector<int>& a,vector<int>& b){\\n            return (a[1]!=b[1])?a[1]<b[1]:a[0]<b[0];\\n        });\\n        unordered_map<int,bool> used;       // time_slice... used or not ... \\n        \\n        int count=0;\\n        for(auto& task:tasks){\\n            int usedTime=0;\\n            for(int t=task[0];t<=task[1];t++)   if(used.count(t))   usedTime++;      // have used this time slice\\n\\n            for(int t=task[1];usedTime<task[2];t--){\\n                if(!used.count(t)){         // this time slice is available\\n                    usedTime++;             // duration for which I run it\\n                    used[t]=1;              // use this timeslice\\n                    count++;                // time for which my computer is on \\n                }\\n            }\\n        }\\n        return count;\\n    }\\n};\\n\\n```\\n\\nJAVA\\n```JAVA\\nclass Solution {\\n    public int findMinimumTime(int[][] tasks) {\\n        Arrays.sort(tasks,(t1,t2)->(t1[1]==t2[1])?t1[0]-t2[0]:t1[1]-t2[1]);\\n        Set<Integer> used = new HashSet<>();\\n        int answer = 0;\\n        for(int[] task: tasks){\\n            int usedTime = 0;\\n            for(int i=task[0];i<=task[1];i++) if(used.contains(i)) usedTime++;\\n            int time_left = task[2]-usedTime;\\n            for(int i=task[1];time_left>0;i--){\\n                if(used.add(i)){\\n                    answer++;\\n                    time_left--;\\n                }\\n            }\\n        }\\n        return answer;\\n    }\\n}\\n```\\n[Thanks a lot for upvoting and supporting, you can subscribe the channel if you want to see more content on CP, DSA and problem solving:), I am glad this solution helped you!]\\nHappy coding!",
                "solutionTags": [
                    "C++",
                    "Java"
                ],
                "code": "```C++\\nclass Solution {\\npublic:\\n    int findMinimumTime(vector<vector<int>>& tasks) {\\n        sort(tasks.begin(),tasks.end(),[](vector<int>& a,vector<int>& b){\\n            return (a[1]!=b[1])?a[1]<b[1]:a[0]<b[0];\\n        });\\n        unordered_map<int,bool> used;       // time_slice... used or not ... \\n        \\n        int count=0;\\n        for(auto& task:tasks){\\n            int usedTime=0;\\n            for(int t=task[0];t<=task[1];t++)   if(used.count(t))   usedTime++;      // have used this time slice\\n\\n            for(int t=task[1];usedTime<task[2];t--){\\n                if(!used.count(t)){         // this time slice is available\\n                    usedTime++;             // duration for which I run it\\n                    used[t]=1;              // use this timeslice\\n                    count++;                // time for which my computer is on \\n                }\\n            }\\n        }\\n        return count;\\n    }\\n};\\n\\n```\n```JAVA\\nclass Solution {\\n    public int findMinimumTime(int[][] tasks) {\\n        Arrays.sort(tasks,(t1,t2)->(t1[1]==t2[1])?t1[0]-t2[0]:t1[1]-t2[1]);\\n        Set<Integer> used = new HashSet<>();\\n        int answer = 0;\\n        for(int[] task: tasks){\\n            int usedTime = 0;\\n            for(int i=task[0];i<=task[1];i++) if(used.contains(i)) usedTime++;\\n            int time_left = task[2]-usedTime;\\n            for(int i=task[1];time_left>0;i--){\\n                if(used.add(i)){\\n                    answer++;\\n                    time_left--;\\n                }\\n            }\\n        }\\n        return answer;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3287586,
                "title": "simple-diagram-explanation",
                "content": "# Idea\\n- The range for `start` and `end` is $$1$$ to $$2000$$ which is sizable to use a number line in the form of a list to represent it. \\n- We put all previously ran tasks times onto the number line to know when intersection can occur. \\n- Sort tasks by `end` times to maximize possible collisions. \\n- Each time a new task collides with a recorded time on the number line, additional time is not needed to perform this task. \\n- Remaining duration that does not collide must be added to number line starting from `end`.\\n# Example\\n- This is best understood through a simple example. \\n- Consider a smaller range from $$1$$ to $$10$$ with the following tasks: `[1,6,3],[7,9,1],[2,5,2],[5,10,5]`\\n\\n![1.jpg](https://assets.leetcode.com/users/images/0e30b943-ee56-483e-a3cd-08b8662e8628_1678611078.067909.jpeg)\\n\\n![2.jpg](https://assets.leetcode.com/users/images/eae44422-3972-4d3d-8f85-fce3ad409819_1678611101.8878937.jpeg)\\n\\n- We mark from `end` to `start` because we sorted by `end` times.\\n- Any intersection of tasks will be found starting from `end`.\\n- We only mark spots not previously marked to get max number line coverage. \\n\\n![3.jpg](https://assets.leetcode.com/users/images/b35830c7-583f-4e42-90f3-14e5b77d9762_1678611154.861946.jpeg)\\n\\n![4.jpg](https://assets.leetcode.com/users/images/3b0165ef-8731-451b-bc25-004108b86f22_1678611158.0110648.jpeg)\\n\\n![1.jfif](https://assets.leetcode.com/users/images/dafab330-9e7b-4263-b7c6-4bf6d5b55efa_1678896799.9693346.jpeg)\\n\\n![6.jpg](https://assets.leetcode.com/users/images/cf726443-47fa-4c4e-84c3-35b969cbec76_1678611164.1251833.jpeg)\\n\\n# Code\\n```\\nint findMinimumTime(vector<vector<int>>& tasks) {\\n    int res = 0;\\n    // Determines whether work has been done before \\n    int range[2001] = {0};\\n    // Sort by interval end time \\n    sort(tasks.begin(), tasks.end(), [](auto& a, auto& b){return a[1] < b[1];});\\n    for (auto& t : tasks){\\n        int start = t[0], end = t[1], d = t[2];\\n        // If work has been done before, do it simultaneously\\n        for (int i = start; i <= end; i++){\\n            if (range[i]){\\n                d--;\\n            }\\n            if (d == 0){\\n                break;\\n            }\\n        }\\n        // For work that has not been done before \\n        while (d){ \\n            // duration is less than or equal to interval size\\n            // so no worry about going out of bound \\n            if (range[end] == 0){\\n                range[end]++;\\n                d--;\\n                res++;\\n            }\\n            end--;\\n        }\\n    }\\n    return res;\\n}\\n```\\n- **Note:** Sorting by `end` times guarantees that the current interval has checked all possible collisions with the previous interval, whereas sorting by start times does not. Convince yourself by sorting with `start` times and testing it. \\n#### Please leave an upvote if this helped! Thanks :)",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3"
                ],
                "code": "```\\nint findMinimumTime(vector<vector<int>>& tasks) {\\n    int res = 0;\\n    // Determines whether work has been done before \\n    int range[2001] = {0};\\n    // Sort by interval end time \\n    sort(tasks.begin(), tasks.end(), [](auto& a, auto& b){return a[1] < b[1];});\\n    for (auto& t : tasks){\\n        int start = t[0], end = t[1], d = t[2];\\n        // If work has been done before, do it simultaneously\\n        for (int i = start; i <= end; i++){\\n            if (range[i]){\\n                d--;\\n            }\\n            if (d == 0){\\n                break;\\n            }\\n        }\\n        // For work that has not been done before \\n        while (d){ \\n            // duration is less than or equal to interval size\\n            // so no worry about going out of bound \\n            if (range[end] == 0){\\n                range[end]++;\\n                d--;\\n                res++;\\n            }\\n            end--;\\n        }\\n    }\\n    return res;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3286782,
                "title": "image-explanation-not-like-others-greedy-solution-complete-intuition",
                "content": "# Video Solution\\nhttps://youtu.be/yw9l_BXKpno\\n\\n# Approach & Intuition\\n![image.png](https://assets.leetcode.com/users/images/2e90a736-5826-4b39-9b5d-1295be585d68_1678597740.7049289.png)\\n![image.png](https://assets.leetcode.com/users/images/939b35c5-0a3c-4817-a5c4-7b0b80d68d48_1678597749.6526146.png)\\n![image.png](https://assets.leetcode.com/users/images/e0c364c7-9bef-40aa-a991-9da7b78b1ce3_1678597759.5901995.png)\\n![image.png](https://assets.leetcode.com/users/images/49a4a13a-f819-4c09-afb9-6709b99aa0ec_1678597768.7625103.png)\\n![image.png](https://assets.leetcode.com/users/images/58392dbf-6863-4ee6-9314-98b52003251c_1678597776.242485.png)\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int findMinimumTime(vector<vector<int>>& tasks) {\\n        bool timeOn[2001] = {};\\n        // Sorting on the basis of \\'End time\\'\\n        sort(begin(tasks), end(tasks), [](const auto &t1, const auto &t2){\\n            return t1[1] < t2[1];\\n        });\\n\\n        for(auto &task : tasks){\\n            int start=task[0], end=task[1], duration=task[2];\\n            for(int i=start;i<=end;i++) if(timeOn[i]) duration--;\\n            for(int i=end;duration>0;i--){\\n                if(timeOn[i]) continue;\\n                duration--;\\n                timeOn[i] = true;\\n            }\\n        }\\n\\n        int countTimeOn = 0;\\n        for(int i=1;i<=2000;i++) countTimeOn += timeOn[i];\\n        return countTimeOn;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findMinimumTime(vector<vector<int>>& tasks) {\\n        bool timeOn[2001] = {};\\n        // Sorting on the basis of \\'End time\\'\\n        sort(begin(tasks), end(tasks), [](const auto &t1, const auto &t2){\\n            return t1[1] < t2[1];\\n        });\\n\\n        for(auto &task : tasks){\\n            int start=task[0], end=task[1], duration=task[2];\\n            for(int i=start;i<=end;i++) if(timeOn[i]) duration--;\\n            for(int i=end;duration>0;i--){\\n                if(timeOn[i]) continue;\\n                duration--;\\n                timeOn[i] = true;\\n            }\\n        }\\n\\n        int countTimeOn = 0;\\n        for(int i=1;i<=2000;i++) countTimeOn += timeOn[i];\\n        return countTimeOn;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3286288,
                "title": "java-greedy-luogu-p1250-tiktok-oa",
                "content": "It is from Luogu P1250. It was also Tiktok SDE Intern OA. \\n\\n# Idea\\n\\n**Greedy to use time in the middle.**\\n\\n```\\ntasks: [1, 3, 1], [4, 6, 1], [3, 4, 2]\\nwork on [3,3] [4,4]\\n```\\n\\nSo we can sort on **right** end, i.e., `task[1]`.\\n\\nIn additon, use `boolean[] visited` to make if time is used or not. (could use multiple times)\\n\\nFor each task, check from right `task[1]` to left `task[0]`, how much we already completed before. \\n\\nThen complete remainings greedy (from right).\\n\\n![image.png](https://assets.leetcode.com/users/images/b77a4f86-1a1a-45c0-b851-851bc2958206_1678593605.9232166.png)\\n\\n\\n\\n# Code\\n\\n```java\\nclass Solution {\\n    public int findMinimumTime(int[][] tasks) {\\n        Arrays.sort(tasks, (t1, t2) -> (t1[1] - t2[1]));\\n        \\n        boolean[] visited = new boolean[2010];\\n\\t\\tint count = 0;\\n\\t\\tfor (int i = 0; i < tasks.length; i++) {\\n\\t\\t\\tint nums = 0;\\n            // check how many we already completed\\n\\t\\t\\tfor (int j = tasks[i][0]; j <= tasks[i][1]; j++) {\\n\\t\\t\\t\\tif (visited[j]) {\\n\\t\\t\\t\\t\\tnums++;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\tint j = tasks[i][1];\\n            // complete remainings.\\n\\t\\t\\twhile (nums < tasks[i][2]) { \\n\\t\\t\\t\\tif (!visited[j]) {\\n\\t\\t\\t\\t\\tcount++;\\n\\t\\t\\t\\t\\tnums++;\\n\\t\\t\\t\\t\\tvisited[j] = true; \\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tj--;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn count;\\n\\n    }\\n}\\n```\\n## Luogu P1250\\n![image.png](https://assets.leetcode.com/users/images/7173556d-f6c7-4858-8f7d-932777f84aae_1678592611.6552246.png)\\n",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\ntasks: [1, 3, 1], [4, 6, 1], [3, 4, 2]\\nwork on [3,3] [4,4]\\n```\n```java\\nclass Solution {\\n    public int findMinimumTime(int[][] tasks) {\\n        Arrays.sort(tasks, (t1, t2) -> (t1[1] - t2[1]));\\n        \\n        boolean[] visited = new boolean[2010];\\n\\t\\tint count = 0;\\n\\t\\tfor (int i = 0; i < tasks.length; i++) {\\n\\t\\t\\tint nums = 0;\\n            // check how many we already completed\\n\\t\\t\\tfor (int j = tasks[i][0]; j <= tasks[i][1]; j++) {\\n\\t\\t\\t\\tif (visited[j]) {\\n\\t\\t\\t\\t\\tnums++;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\tint j = tasks[i][1];\\n            // complete remainings.\\n\\t\\t\\twhile (nums < tasks[i][2]) { \\n\\t\\t\\t\\tif (!visited[j]) {\\n\\t\\t\\t\\t\\tcount++;\\n\\t\\t\\t\\t\\tnums++;\\n\\t\\t\\t\\t\\tvisited[j] = true; \\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tj--;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn count;\\n\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3286252,
                "title": "o-nlogn-for-n-2000-and-values-2000",
                "content": "\\t\\ttasks.append([10 ** 9 + 1, 10 ** 9 + 1, 1]) \\n        res, q = 0, []\\n        for s, e, d in sorted(tasks) :\\n            while q and q[0][0] + res < s :\\n                if q[0][0] + res >= q[0][1]: heappop(q) \\n                else : res += min(q[0][1], s) - (q[0][0] + res)\\n            heappush(q, [e - d + 1 - res, e + 1])\\n        return res\\n\\t\\t\\n\\n1. Each task has a latest start time. \\n\\n2. If there are several tasks being executed at the same time (i.e., their intervals overlap), the latest start time of all running tasks will be pushed back by a certain amount of time w. \\n\\n3. Sort the tasks by their start times in ascending order. Use a min-heap to maintain the running tasks that have the smallest latest start time. \\n\\n4. Add each task one by one. For the current task T (with the left endpoint ts) and the task T\\' in the task pool with the smallest latest start time (with the latest start time t\\'s), if t\\'e + offset - 1 < ts - 1, it means that task T can start running first for time w without overlapping with task T. Here, w is equal to min(t\\'e, ts-1) - (t\\'s + offset - 1), where offset is the time that the current task pool has already been running. \\n\\n5. Add w to ans, and add w to offset. If this condition is not satisfied, it means that the current task can be added to the task pool and started in parallel with the other tasks in the pool. \\n\\n6. When added to the task pool, the latest start time of task T can be set to te - p + 1 - offset, where p is the time it takes to complete task T.",
                "solutionTags": [
                    "Python"
                ],
                "code": "\\t\\ttasks.append([10 ** 9 + 1, 10 ** 9 + 1, 1]) \\n        res, q = 0, []\\n        for s, e, d in sorted(tasks) :\\n            while q and q[0][0] + res < s :\\n                if q[0][0] + res >= q[0][1]: heappop(q) \\n                else : res += min(q[0][1], s) - (q[0][0] + res)\\n            heappush(q, [e - d + 1 - res, e + 1])\\n        return res\\n\\t\\t\\n\\n1. Each task has a latest start time. \\n\\n2. If there are several tasks being executed at the same time (i.e., their intervals overlap), the latest start time of all running tasks will be pushed back by a certain amount of time w. \\n\\n3. Sort the tasks by their start times in ascending order. Use a min-heap to maintain the running tasks that have the smallest latest start time. \\n\\n4. Add each task one by one. For the current task T (with the left endpoint ts) and the task T\\' in the task pool with the smallest latest start time (with the latest start time t\\'s), if t\\'e + offset - 1 < ts - 1, it means that task T can start running first for time w without overlapping with task T. Here, w is equal to min(t\\'e, ts-1) - (t\\'s + offset - 1), where offset is the time that the current task pool has already been running. \\n\\n5. Add w to ans, and add w to offset. If this condition is not satisfied, it means that the current task can be added to the task pool and started in parallel with the other tasks in the pool. \\n\\n6. When added to the task pool, the latest start time of task T can be set to te - p + 1 - offset, where p is the time it takes to complete task T.",
                "codeTag": "Unknown"
            },
            {
                "id": 3286246,
                "title": "c-greedy-n-2-straightforward-sorting",
                "content": "It is a common idea in interval problems that overlap is always maximized by sorting by the leftmost endpoint. We do this then greedily turn on the computer starting from the right of each task.\\n\\n```\\nclass Solution {\\npublic:\\n    int findMinimumTime(vector<vector<int>>& tasks) {\\n        sort(tasks.begin(), tasks.end(), [](const vector<int>& a, const vector<int>& b){return a[1] < b[1];});\\n        int ans = 0;\\n        int work [2001] = {};\\n        for(auto & i : tasks){\\n            for(int j = i[0]; j <= i[1]; j++) i[2] -= work[j];\\n            if(i[2] > 0){\\n                ans += i[2];\\n                for(int j = i[1]; j >= 0 && i[2]>0; j--){\\n                    if(work[j] == 0) {\\n                        work[j]++;\\n                        i[2]--;\\n                    }\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    int findMinimumTime(vector<vector<int>>& tasks) {\\n        sort(tasks.begin(), tasks.end(), [](const vector<int>& a, const vector<int>& b){return a[1] < b[1];}",
                "codeTag": "Java"
            },
            {
                "id": 3286360,
                "title": "o-n-log-n-with-min-heap",
                "content": "# Intuition\\nIt\\'s always best to take the right most time slots from each task because they have the most potential to be used in later tasks.\\n# Approach\\nIt\\'s hard for me to explain it, but I\\'ll try my best.\\n\\nSort tasks by starting time.\\n\\nGo through each time from 1 to max end time in tasks.\\n\\nKeep a priority queue with all tasks that are in the time range of current time with the values in the queue being the left most time slot that must be used, initially it\\'s `end time - duration + 1`, and the second value will be the end time.\\n\\nPop all tasks from queue that end time is less than current time and push all tasks to queue that start time is equal to current time. \\n\\nWhen we see a task that the left most required time slot is the current time, we increment res. Since current time is used, all left most required time in priority queue can be incremented as well. Instead of incrementing all of them we can just incement res and add res to left most required time when we check it and subtract res when we add a new task.\\n# Complexity\\n- Time complexity:\\nO(n log n)\\n\\n- Space complexity:\\nO(n)\\n\\n# Code\\n```\\nint findMinimumTime(vector<vector<int>>& tasks) {\\n    sort(tasks.begin(), tasks.end());\\n    priority_queue<pair<int, int>, vector<pair<int, int>>, greater<>>pq;\\n    int res = 0, j = 0, mx = 0;\\n    for (vector<int>& t : tasks) mx = max(mx, t[1]);\\n    for (int i = 1; i <= mx; i++) {\\n        while (j < tasks.size() && tasks[j][0] == i)\\n            pq.push({tasks[j][1] - tasks[j][2] - res + 1, tasks[j++][1]});\\n        while (pq.size() && pq.top().second < i) pq.pop();\\n        if (pq.size() && pq.top().first + res == i) res++;\\n    }\\n    return res;\\n}\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nint findMinimumTime(vector<vector<int>>& tasks) {\\n    sort(tasks.begin(), tasks.end());\\n    priority_queue<pair<int, int>, vector<pair<int, int>>, greater<>>pq;\\n    int res = 0, j = 0, mx = 0;\\n    for (vector<int>& t : tasks) mx = max(mx, t[1]);\\n    for (int i = 1; i <= mx; i++) {\\n        while (j < tasks.size() && tasks[j][0] == i)\\n            pq.push({tasks[j][1] - tasks[j][2] - res + 1, tasks[j++][1]});\\n        while (pq.size() && pq.top().second < i) pq.pop();\\n        if (pq.size() && pq.top().first + res == i) res++;\\n    }\\n    return res;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3290450,
                "title": "c-java-python3-sweep-line",
                "content": "Please pull this [commit](https://github.com/gaosanyong/leetcode/commit/15456f4294fa2d2de5e056fc441f28872a0c2a71) for solutions of weekly 336. \\n\\n**C++**\\n```\\nclass Solution {\\npublic:\\n    int findMinimumTime(vector<vector<int>>& tasks) {\\n        vector<int> line(2001); \\n        sort(tasks.begin(), tasks.end(), [](auto& lhs, auto& rhs) {return lhs[1] < rhs[1];}); \\n        for (auto& t : tasks) {\\n            int lo = t[0], hi = t[1], time = t[2], cnt = 0; \\n            for (int x = lo; x <= hi && time; ++x) time -= line[x]; \\n            for (int x = hi; x >= lo && time; --x) \\n                if (!line[x]) {\\n                    line[x] = 1; \\n                    --time; \\n                }\\n        }\\n        return accumulate(line.begin(), line.end(), 0); \\n    }\\n};\\n```\\n**Java**\\n```\\nclass Solution {\\n    public int findMinimumTime(int[][] tasks) {\\n        int[] line = new int[2001]; \\n        Arrays.sort(tasks, (a, b)->Integer.compare(a[1], b[1])); \\n        for (var t : tasks) {\\n            int lo = t[0], hi = t[1], time = t[2]; \\n            for (int x = lo; x <= hi && time > 0; ++x) time -= line[x]; \\n            for (int x = hi; x >= lo && time > 0; --x) {\\n                if (line[x] == 0) {\\n                    line[x] = 1; \\n                    --time; \\n                }\\n            }\\n        }\\n        return Arrays.stream(line).sum(); \\n    }\\n}\\n```\\n**Python3**\\n```\\nclass Solution:\\n    def findMinimumTime(self, tasks: List[List[int]]) -> int:\\n        line = [0]*2001\\n        for i, (lo, hi, time) in enumerate(sorted(tasks, key=lambda x: x[1])): \\n            cnt = sum(line[x] for x in range(lo, hi+1))\\n            time = max(0, time - cnt)\\n            for x in range(hi, lo-1, -1): \\n                if time and not line[x]: \\n                    line[x] = 1\\n                    time -= 1\\n        return sum(line)\\n```",
                "solutionTags": [
                    "Java",
                    "Python3",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findMinimumTime(vector<vector<int>>& tasks) {\\n        vector<int> line(2001); \\n        sort(tasks.begin(), tasks.end(), [](auto& lhs, auto& rhs) {return lhs[1] < rhs[1];}); \\n        for (auto& t : tasks) {\\n            int lo = t[0], hi = t[1], time = t[2], cnt = 0; \\n            for (int x = lo; x <= hi && time; ++x) time -= line[x]; \\n            for (int x = hi; x >= lo && time; --x) \\n                if (!line[x]) {\\n                    line[x] = 1; \\n                    --time; \\n                }\\n        }\\n        return accumulate(line.begin(), line.end(), 0); \\n    }\\n};\\n```\n```\\nclass Solution {\\n    public int findMinimumTime(int[][] tasks) {\\n        int[] line = new int[2001]; \\n        Arrays.sort(tasks, (a, b)->Integer.compare(a[1], b[1])); \\n        for (var t : tasks) {\\n            int lo = t[0], hi = t[1], time = t[2]; \\n            for (int x = lo; x <= hi && time > 0; ++x) time -= line[x]; \\n            for (int x = hi; x >= lo && time > 0; --x) {\\n                if (line[x] == 0) {\\n                    line[x] = 1; \\n                    --time; \\n                }\\n            }\\n        }\\n        return Arrays.stream(line).sum(); \\n    }\\n}\\n```\n```\\nclass Solution:\\n    def findMinimumTime(self, tasks: List[List[int]]) -> int:\\n        line = [0]*2001\\n        for i, (lo, hi, time) in enumerate(sorted(tasks, key=lambda x: x[1])): \\n            cnt = sum(line[x] for x in range(lo, hi+1))\\n            time = max(0, time - cnt)\\n            for x in range(hi, lo-1, -1): \\n                if time and not line[x]: \\n                    line[x] = 1\\n                    time -= 1\\n        return sum(line)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3289691,
                "title": "video-explanation-why-complete-greedy-doesn-t-works-and-building-solution-with-intuitions",
                "content": "# Explanation\\n\\nhttps://youtu.be/HsIC3PFbRrg\\n\\n[Click here if the preview above doesn\\'t works](https://youtu.be/HsIC3PFbRrg)\\n\\n# Code\\n```\\nconst int N = 2002;\\n\\nbool cmp (const vector<int>& lhs, const vector<int>& rhs) {\\n    if (lhs[1] != rhs[1]) return lhs[1] < rhs[1];\\n    return lhs[0] < rhs[0];\\n}\\n\\nclass Solution {\\n    \\npublic:\\n    int findMinimumTime(vector<vector<int>>& tasks) {\\n        sort (tasks.begin(), tasks.end(), cmp);\\n        vector<bool> is_active(N, false);\\n        \\n        for (auto task : tasks) {\\n            int required = task[2], l = task[0], r = task[1];\\n            for (int i = l; i <= r; i ++) \\n                if (is_active[i]) required --;\\n            \\n            while (required > 0 && r >= l) {\\n                if (!is_active[r]) {\\n                    is_active[r] = true;\\n                    required --;\\n                }\\n                r --;\\n            }\\n        }\\n        \\n        int result = 0;\\n        for (int i = 0; i < N; i ++)\\n            if (is_active[i]) result ++;\\n        \\n        return result;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nconst int N = 2002;\\n\\nbool cmp (const vector<int>& lhs, const vector<int>& rhs) {\\n    if (lhs[1] != rhs[1]) return lhs[1] < rhs[1];\\n    return lhs[0] < rhs[0];\\n}\\n\\nclass Solution {\\n    \\npublic:\\n    int findMinimumTime(vector<vector<int>>& tasks) {\\n        sort (tasks.begin(), tasks.end(), cmp);\\n        vector<bool> is_active(N, false);\\n        \\n        for (auto task : tasks) {\\n            int required = task[2], l = task[0], r = task[1];\\n            for (int i = l; i <= r; i ++) \\n                if (is_active[i]) required --;\\n            \\n            while (required > 0 && r >= l) {\\n                if (!is_active[r]) {\\n                    is_active[r] = true;\\n                    required --;\\n                }\\n                r --;\\n            }\\n        }\\n        \\n        int result = 0;\\n        for (int i = 0; i < N; i ++)\\n            if (is_active[i]) result ++;\\n        \\n        return result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3287073,
                "title": "c-slot-selection-from-intuition-to-solution",
                "content": "# Intuition\\n1. Let\\'s reframe the question as , we are given different ranges and for each range we have to select some given number of slots in the range.\\n2. We have to select the slots in such a way that the same slot can be used by multiple ranges.\\n3. Is there a certain way to choose slots , such that it has maximum possibility to overlap with other ranges?\\n4. See this observation\\n range1= [0,0,0,0,1,1,1] select 3 slots from here\\n range2=  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;       [1,1,0,0,0,0,] select 2 slots from here\\n\\n5. From the example in previous point, observe that the overlapps occur most of the times from the end of a range.\\n6. So lets sort the ranges accoring to their endpoint\\n7. Now comes the constraints , the maximum start and enpoints can be [1,2000].\\n8. So we use visited[] where visited[i]=1 denotes ith point has been selected as a slot\\n9. Here is another example  with a slight new observation\\n\\nrange1=&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[0,0,0,1,1,1]\\nrange2=[0,0,0,0,0,1,1,1,0,0,0,0,0,1,1]\\n\\n10. The above example might be a case , in such a situation , we would want to first select the already used slots, and the the remaining slots would be selected form the end of the range\\n\\n\\n# Approach\\n1. Sort the ranges according to the endtime\\n2. Start from the end of each range and select slots which are already taken by some other range , to save moves\\n3. For the remaining moves select the slots from the end\\n\\n# Complexity\\n- Time complexity:\\nO(n*n)\\n- Space complexity:\\nO(n)\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int findMinimumTime(vector<vector<int>>& tasks) {\\n        sort(tasks.begin(),tasks.end() , [&](vector<int> a  , vector<int> b){\\n            return a[1] < b[1];\\n        });\\n        \\n        vector<int> visited(3000);\\n        \\n        int ans=0;\\n        for(int i=0;i<tasks.size();i++){\\n            \\n            int end = tasks[i][1] , start=tasks[i][0] , moves=tasks[i][2];\\n            \\n            for(int j=end;j>=start and tasks[i][2]>0 ;j--){\\n                if(visited[j]==1) tasks[i][2]--;\\n            }\\n            \\n            for(int j=end;j>=start and tasks[i][2]>0;j--){\\n                if(visited[j]==0) {\\n                    visited[j]=1;\\n                    ans++;\\n                    tasks[i][2]--;\\n                }\\n            }\\n            \\n        }\\n            \\n        return ans;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findMinimumTime(vector<vector<int>>& tasks) {\\n        sort(tasks.begin(),tasks.end() , [&](vector<int> a  , vector<int> b){\\n            return a[1] < b[1];\\n        });\\n        \\n        vector<int> visited(3000);\\n        \\n        int ans=0;\\n        for(int i=0;i<tasks.size();i++){\\n            \\n            int end = tasks[i][1] , start=tasks[i][0] , moves=tasks[i][2];\\n            \\n            for(int j=end;j>=start and tasks[i][2]>0 ;j--){\\n                if(visited[j]==1) tasks[i][2]--;\\n            }\\n            \\n            for(int j=end;j>=start and tasks[i][2]>0;j--){\\n                if(visited[j]==0) {\\n                    visited[j]=1;\\n                    ans++;\\n                    tasks[i][2]--;\\n                }\\n            }\\n            \\n        }\\n            \\n        return ans;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3286274,
                "title": "c-sweep-line-clear-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nFor the starting pt, store when it starts and how much time it needs.\\n\\nFor the ending pt, identify its corresponding starting point, and check how much time it still needs. Then substract its time from all active tasks we have met, namely active time now, to ensure the minimum upcoming time.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution { \\npublic:\\n    int findMinimumTime(vector<vector<int>>& tasks) {\\n        vector<vector<int>> stk;\\n        int res = 0;\\n        unordered_map<int, pair<int, int>> active;\\n\\n        for (int i = 0; i < tasks.size(); i++) {\\n            int start = tasks[i][0];\\n            int end = tasks[i][1];\\n            int pt = tasks[i][2];\\n            stk.push_back({start, 0, pt, i});\\n            stk.push_back({end, 1, pt, i});\\n        }\\n\\n        sort(stk.begin(), stk.end());\\n\\n        for (auto item : stk) {\\n            int t = item[0],d = item[1],pt = item[2],i = item[3];\\n            if (1-d) {\\n                active[i] = {t, pt};\\n            } else {\\n                int un_used = active[i].second;\\n                res += un_used;\\n                for (auto& [j, task] : active) {\\n                    int use = min(task.second, min(t-task.first+1, un_used));\\n                    task.second -= use;\\n                    task.first += use;\\n                }\\n                active.erase(i);\\n            }\\n        }\\n        return res;\\n    }\\n};",
                "solutionTags": [
                    "C++"
                ],
                "code": "class Solution { \\npublic:\\n    int findMinimumTime(vector<vector<int>>& tasks) {\\n        vector<vector<int>> stk;\\n        int res = 0;\\n        unordered_map<int, pair<int, int>> active;\\n\\n        for (int i = 0; i < tasks.size(); i++) {\\n            int start = tasks[i][0];\\n            int end = tasks[i][1];\\n            int pt = tasks[i][2];\\n            stk.push_back({start, 0, pt, i}",
                "codeTag": "Java"
            },
            {
                "id": 3286676,
                "title": "python3-easy-solution-greedy-sort-set",
                "content": "\\n\\n# Complexity\\n- Time complexity:O(N^2)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def findMinimumTime(self, tasks: List[List[int]]) -> int:\\n        tasks = sorted(tasks,key=lambda x:x[1])\\n        chosen_set = set()\\n        for task in tasks:\\n            cur_start,cur_end,cur_duration = task[0],task[1],task[2]\\n            for time in chosen_set:\\n                if time >= cur_start and time <=cur_end:\\n                    cur_duration-=1\\n                if cur_duration==0:\\n                    break\\n            while cur_duration>0:\\n                if cur_end not in chosen_set:\\n                    chosen_set.add(cur_end)\\n                    cur_duration-=1\\n                cur_end-=1\\n        return len(chosen_set)\\n                    \\n        \\n        \\n```",
                "solutionTags": [
                    "Python3",
                    "Greedy",
                    "Sort",
                    "Ordered Set"
                ],
                "code": "```\\nclass Solution:\\n    def findMinimumTime(self, tasks: List[List[int]]) -> int:\\n        tasks = sorted(tasks,key=lambda x:x[1])\\n        chosen_set = set()\\n        for task in tasks:\\n            cur_start,cur_end,cur_duration = task[0],task[1],task[2]\\n            for time in chosen_set:\\n                if time >= cur_start and time <=cur_end:\\n                    cur_duration-=1\\n                if cur_duration==0:\\n                    break\\n            while cur_duration>0:\\n                if cur_end not in chosen_set:\\n                    chosen_set.add(cur_end)\\n                    cur_duration-=1\\n                cur_end-=1\\n        return len(chosen_set)\\n                    \\n        \\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3289845,
                "title": "python-100-simple-greedy-what-to-learn-from-this",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nThis problem was eye opening for me for several reasons.\\n\\nThis is an overlapping intervals problem. We are going to calculate the minimum number of seconds the computer needs to be turned on to complete all of the tasks.\\n\\nThe two main insights I had after solving this problem were:\\n\\n1) when the problem gives us a confusing example, we should first create a brand new example ourselves.  The example was purposely confusing so you wouldn\\'t notice the optimal patterns.  Also using longer intervals and durations will give you more data points and room to consider possibilities to assess how exploitable your strategy is.  Intervals of length 3 and duration of 1 or 2 just isn\\'t enough to really form much of an opinion on what a good strategy is.\\n\\n2) in any interval problem, we should always check if sorting by the start time or the end time will allow us to have a greedy solution.  And we should do so with a few good examples.\\n\\nSorting by start point is a bad strategy for the simple example:\\n\\n[1,5,1],[2,3,1]\\n\\nwe\\'d prefer to turn on the computer at time 2 or 3, but we can\\'t know to do that when looking at [1,5,1].  However, if we sort by end point, you can see if we turn it on at 2 or 3, task 1 is also completed.  \\n\\nTo test whether we could sort by endpoint, I created a second example.\\n\\nHere\\'s the example i created to convince myself this strategy is good:\\n[15,20,3],[10,25,5],[6,30,7]\\n\\n[15,20,3],  overlaps: none  duration = 3   times used: **20,19,18**\\n\\nHow do we know we want the computer turned on at times 18,19,20?\\nThe only way we would want it turned on earlier is if we had a task with an end time before 18.  Maybe a task like [13,16,2].  Because we sorted by end point, we will never see this task after [15,20,3].  We will see it before.\\n\\n[10,25,9], what overlaps? 18,19,20  duration (5-3)=2 \\nnew used: **25,24** + old used 18,19,20\\n\\n[6,30,7]\\n        what overlaps? 18,19,20,24,25.  duration = (7-5)\\n        new used: **30,29** + old used\\n\\nIf the computer is already on during a time in our interval, we would want to use that time to run the computer for one second.  So first we iterate through and see which times in our interval the computer is on, and subtract one from duration for this task.  Then, if we still have any duration left, we will turn it on at the latest second possible so we are most likely to overlap with the next task.  The next task has an end point greater than the current task.  It has an unknown starting point. \\nWhen we choose the latest second possible we minimize our computer usage in all cases. \\n\\nSo keep a boolean array and iterate through.  \\nSum the times array to count the number of times used.\\n\\n\\n1<= start,end <= 2000\\n\\n- Time complexity: O(N^2)\\n- Space complexity: O(N)\\n\\n# Code\\n```\\nclass Solution:\\n    def findMinimumTime(self, tasks: List[List[int]]) -> int:\\n        \\n        tasks.sort(key = lambda x:(x[1],x[0]))\\n        \\n        times = [False]*2001\\n        \\n        for start, end, duration in tasks:\\n            dur,e = duration,end\\n            for s in range(start,end+1):\\n                if times[s]:\\n                    dur -= 1\\n                    \\n            while dur > 0:\\n                if not times[e]:\\n                    times[e] = True\\n                    dur -= 1\\n                e -= 1\\n        \\n        return sum(times)\\n                    \\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def findMinimumTime(self, tasks: List[List[int]]) -> int:\\n        \\n        tasks.sort(key = lambda x:(x[1],x[0]))\\n        \\n        times = [False]*2001\\n        \\n        for start, end, duration in tasks:\\n            dur,e = duration,end\\n            for s in range(start,end+1):\\n                if times[s]:\\n                    dur -= 1\\n                    \\n            while dur > 0:\\n                if not times[e]:\\n                    times[e] = True\\n                    dur -= 1\\n                e -= 1\\n        \\n        return sum(times)\\n                    \\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3286414,
                "title": "take-advantage-of-small-time-range-greedy-pickup",
                "content": "Small time range allows tracking of all available time slots that can be greedily selected via sorting by earliest end time. \\n\\n# Code\\n```\\nclass Solution:\\n    def findMinimumTime(self, tasks: List[List[int]]) -> int:\\n        tasks.sort(key = lambda x: x[1])\\n        tot = 0\\n        used = [0] * 2001\\n        for curr_task in tasks:\\n            s, e, d = curr_task\\n            up = sum(used[s:e + 1])\\n            remain = d - up\\n            if remain <= 0:\\n                continue\\n            else:\\n                for i in range(remain):\\n                    while(used[e - i] == 1):\\n                        e -= 1\\n                    used[e-i] = 1\\n        return sum(used)\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def findMinimumTime(self, tasks: List[List[int]]) -> int:\\n        tasks.sort(key = lambda x: x[1])\\n        tot = 0\\n        used = [0] * 2001\\n        for curr_task in tasks:\\n            s, e, d = curr_task\\n            up = sum(used[s:e + 1])\\n            remain = d - up\\n            if remain <= 0:\\n                continue\\n            else:\\n                for i in range(remain):\\n                    while(used[e - i] == 1):\\n                        e -= 1\\n                    used[e-i] = 1\\n        return sum(used)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3287878,
                "title": "2589-minimum-time-to-complete-all-tasks-java",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nSort on basis on end time and utilize overlapping interval and fill extra at end\\n\\n# Complexity\\n# Code\\n```\\nclass Solution {\\n    public int findMinimumTime(int[][] tasks) {\\n        Arrays.sort(tasks,(a,b)->a[1]-b[1]);\\n        boolean[] on=new boolean[2001];\\n        for(int[] t:tasks){\\n            int start=t[0];int end=t[1];int duration=t[2];\\n            for(int i=start;i<=end;i++){\\n                if(on[i])duration--;\\n            }\\n            for(int i=end;duration>0;i--){\\n                if(on[i])continue;\\n                on[i]=true;\\n                duration--;\\n            }\\n        }\\n        int count=0;\\n        for(boolean b:on){\\n            if(b)count++;\\n        }\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int findMinimumTime(int[][] tasks) {\\n        Arrays.sort(tasks,(a,b)->a[1]-b[1]);\\n        boolean[] on=new boolean[2001];\\n        for(int[] t:tasks){\\n            int start=t[0];int end=t[1];int duration=t[2];\\n            for(int i=start;i<=end;i++){\\n                if(on[i])duration--;\\n            }\\n            for(int i=end;duration>0;i--){\\n                if(on[i])continue;\\n                on[i]=true;\\n                duration--;\\n            }\\n        }\\n        int count=0;\\n        for(boolean b:on){\\n            if(b)count++;\\n        }\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3286247,
                "title": "simple-o-n-log-n-n-max-task-duration",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n- Sort by the end times.\\n- It\\'s always better to cover from the right because it may help to cover other tasks.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n- Same as intuition....\\n- Maintain a hashmap to keep track of covered time stamps. \\n\\n# Complexity\\n- Time complexity: $$O(n*logn + n*max(task.duration))$$\\n\\n- Space complexity: $$O(max(task.duration))$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n//Sort by the end times, if equal choose the earlier start time\\nstatic bool cmp(vector<int> &a, vector<int> &b){\\n    if(a[1] == b[1]) return a[0]<b[0];\\n    return a[1]<b[1];\\n}\\n//Calculate answer to cover the ith task\\nvoid cover(vector<int> &v, vector<int> &task){\\n    int to_cover = task[2]; //how much is left to cover\\n    for(int  i = task[0]; i<=task[1]; i++) {\\n        if(v[i]) to_cover--; //how much have we already covered?\\n    }\\n    for(int i = task[1]; to_cover > 0; i--) { //cover from the right \\n        if(v[i]) continue; //already covered\\n        v[i]++; to_cover--;\\n    }\\n}\\nint findMinimumTime(vector<vector<int>>& tasks) {\\n    sort(tasks.begin(), tasks.end(), cmp);\\n    vector<int> v(2001); //keep track of covered time stamps\\n    for(auto &task:tasks){\\n        cover(v, task); //cover this task\\n    }\\n    return accumulate(v.begin(), v.end(), 0);\\n}\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n//Sort by the end times, if equal choose the earlier start time\\nstatic bool cmp(vector<int> &a, vector<int> &b){\\n    if(a[1] == b[1]) return a[0]<b[0];\\n    return a[1]<b[1];\\n}\\n//Calculate answer to cover the ith task\\nvoid cover(vector<int> &v, vector<int> &task){\\n    int to_cover = task[2]; //how much is left to cover\\n    for(int  i = task[0]; i<=task[1]; i++) {\\n        if(v[i]) to_cover--; //how much have we already covered?\\n    }\\n    for(int i = task[1]; to_cover > 0; i--) { //cover from the right \\n        if(v[i]) continue; //already covered\\n        v[i]++; to_cover--;\\n    }\\n}\\nint findMinimumTime(vector<vector<int>>& tasks) {\\n    sort(tasks.begin(), tasks.end(), cmp);\\n    vector<int> v(2001); //keep track of covered time stamps\\n    for(auto &task:tasks){\\n        cover(v, task); //cover this task\\n    }\\n    return accumulate(v.begin(), v.end(), 0);\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3290925,
                "title": "python3-greedy-o-n-n-no-sort-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nIntuition is greedy.The time slot we say [x, x] needs to choose only if there is a task. If you don\\'t start at time x, you won\\'t make it on time. And since we know we need to turn on the machine at time x. Every task can use this time slot use this time slot. We test from the minimum start time of all task to the maximum end time. Keep updating the duration. Since these are constraint in 1~2000. We use it as our range.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nUse **check** function to test if time slot [x,x] (x = time in our code) need to choose.\\nIf [time, time] needs to choose. We substract all duration which is legal 1 in func **elimtate**.\\nAnd test from 1 ~ 2000 and count.\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n$$O(n)$$ for each check func.\\n$$O(n)$$ for each elimtate func.\\n$$O(n^2)$$ for total.\\nn is 2000 in this case.\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nConstant extra space.\\n# Code\\n```\\nclass Solution:\\n    def findMinimumTime(self, tasks: List[List[int]]) -> int:\\n        def check(time, tasks):\\n            # check if time needs to turn on only need to turn on if there is a task task[2] != 0 and task[1] - task[2] == time\\n            # open time to time + 1\\n            for task in tasks:\\n                if task[2] and (task[1] - time + 1 == task[2]):\\n                    return True\\n            return False\\n                \\n        def elimtate(time, tasks):\\n            for i in range(len(tasks)):\\n                if tasks[i][0] <= time and tasks[i][2] > 0:\\n                    tasks[i][2] -= 1 \\n        ans = 0\\n        for i in range(1,2001):\\n            if check(i, tasks):\\n                #print(i)\\n                ans += 1\\n                elimtate(i, tasks)\\n        return ans\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def findMinimumTime(self, tasks: List[List[int]]) -> int:\\n        def check(time, tasks):\\n            # check if time needs to turn on only need to turn on if there is a task task[2] != 0 and task[1] - task[2] == time\\n            # open time to time + 1\\n            for task in tasks:\\n                if task[2] and (task[1] - time + 1 == task[2]):\\n                    return True\\n            return False\\n                \\n        def elimtate(time, tasks):\\n            for i in range(len(tasks)):\\n                if tasks[i][0] <= time and tasks[i][2] > 0:\\n                    tasks[i][2] -= 1 \\n        ans = 0\\n        for i in range(1,2001):\\n            if check(i, tasks):\\n                #print(i)\\n                ans += 1\\n                elimtate(i, tasks)\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3288388,
                "title": "go-python-o-n-max-end-min-start-time-o-max-end-min-start",
                "content": "# Complexity\\n- Time complexity: $$O(n*max(end)-min(start))$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(max(end)-min(start))$$ \\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```golang []\\nfunc findMinimumTime(tasks [][]int) int {\\n    sort.SliceStable(tasks, func(i, j int) bool {return tasks[i][1] < tasks[j][1]})\\n    min_start := math.MaxInt\\n    for _,task := range(tasks){\\n        min_start = min(min_start,task[0])\\n    }\\n    max_end := tasks[len(tasks)-1][1]\\n    time := make([]int, max_end-min_start+1)\\n    for _,task := range(tasks){\\n        start := task[0]-min_start\\n        end := task[1]-min_start\\n        duration := task[2]\\n        used := sum(&time,start,end+1)\\n        duration-=used\\n        for duration > 0{\\n            if time[end] == 0{\\n                time[end] = 1\\n                duration-=1\\n            }\\n            end-=1\\n        }\\n    }\\n    return sum(&time)\\n}\\n\\nfunc sum(array *[]int, args ...int) int{\\n    left := 0\\n    right := len(*array)\\n    if len(args) == 2 {\\n        left = args[0]\\n        right = args[1]\\n    }\\n    item_sum := 0\\n    for i:=left;i<right;i++{\\n        item_sum+=(*array)[i]\\n    }\\n    return item_sum\\n}\\n\\nfunc min(a,b int) int{\\n    if a<b{\\n        return a\\n    }\\n    return b\\n}\\n```\\n```python []\\nclass Solution:\\n    def findMinimumTime(self, tasks: List[List[int]]) -> int:\\n        tasks.sort(key = lambda x : x[1])\\n        min_start = float(\"inf\")\\n        for task in tasks:\\n            min_start = min(min_start,task[0])\\n        max_end = tasks[-1][1]\\n        time = [0 for _ in range(max_end-min_start+1)]\\n        for task in tasks:\\n            start = task[0]-min_start\\n            end = task[1]-min_start\\n            duration = task[2]\\n            used = sum(time[start:end+1])\\n            duration-=used\\n            while duration > 0:\\n                if time[end] == 0:\\n                    time[end] = 1\\n                    duration-=1\\n                end-=1\\n        return sum(time) \\n```",
                "solutionTags": [
                    "Python3",
                    "Go",
                    "Array",
                    "Greedy",
                    "Sort"
                ],
                "code": "```golang []\\nfunc findMinimumTime(tasks [][]int) int {\\n    sort.SliceStable(tasks, func(i, j int) bool {return tasks[i][1] < tasks[j][1]})\\n    min_start := math.MaxInt\\n    for _,task := range(tasks){\\n        min_start = min(min_start,task[0])\\n    }\\n    max_end := tasks[len(tasks)-1][1]\\n    time := make([]int, max_end-min_start+1)\\n    for _,task := range(tasks){\\n        start := task[0]-min_start\\n        end := task[1]-min_start\\n        duration := task[2]\\n        used := sum(&time,start,end+1)\\n        duration-=used\\n        for duration > 0{\\n            if time[end] == 0{\\n                time[end] = 1\\n                duration-=1\\n            }\\n            end-=1\\n        }\\n    }\\n    return sum(&time)\\n}\\n\\nfunc sum(array *[]int, args ...int) int{\\n    left := 0\\n    right := len(*array)\\n    if len(args) == 2 {\\n        left = args[0]\\n        right = args[1]\\n    }\\n    item_sum := 0\\n    for i:=left;i<right;i++{\\n        item_sum+=(*array)[i]\\n    }\\n    return item_sum\\n}\\n\\nfunc min(a,b int) int{\\n    if a<b{\\n        return a\\n    }\\n    return b\\n}\\n```\n```python []\\nclass Solution:\\n    def findMinimumTime(self, tasks: List[List[int]]) -> int:\\n        tasks.sort(key = lambda x : x[1])\\n        min_start = float(\"inf\")\\n        for task in tasks:\\n            min_start = min(min_start,task[0])\\n        max_end = tasks[-1][1]\\n        time = [0 for _ in range(max_end-min_start+1)]\\n        for task in tasks:\\n            start = task[0]-min_start\\n            end = task[1]-min_start\\n            duration = task[2]\\n            used = sum(time[start:end+1])\\n            duration-=used\\n            while duration > 0:\\n                if time[end] == 0:\\n                    time[end] = 1\\n                    duration-=1\\n                end-=1\\n        return sum(time) \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3287072,
                "title": "15-lines-of-code-and-easy-to-understand-in-o-1-space-and-o-n-n-time-complexity",
                "content": "\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nlets take an example of task\\n\\n    startTime=1    endTime=5   duration=3\\n    so,the approach is you have choice to do task at 1 ,2 \\n    but if you haven\\'t touch the task yet then it is mandatory for\\n    you to do task at 3.\\n\\nyes,so I will be traversing thorugh 1 to 2000\\nand when i will get any instance when it is mandatory to do any of task i just mark it and decrement duration from all task in which that instance lies.\\n\\n# Complexity\\n- Time complexity:\\n O(2000*N)\\n\\n- Space complexity:\\n  O(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int findMinimumTime(vector<vector<int>>& a) {\\n        \\n        int n=a.size();\\n        \\n        int ans=0;\\n        \\n        for(int i=1;i<=2000;i++){\\n              int check=0;\\n              for(int j=0;j<n;j++){\\n                   if(a[j][2]>0&&a[j][1]-i+1==a[j][2]){\\n                        check=1;\\n                   }\\n              }\\n              if(check)\\n              {\\n                   ans++;\\n                   for(int j=0;j<n;j++){\\n                       if(a[j][2]>0&&i>=a[j][0]&&i<=a[j][1])\\n                       {\\n                            a[j][2]--;\\n                       }\\n                   }\\n              }\\n        }\\n        \\n        return ans;\\n        \\n        \\n        \\n        return ans;\\n        \\n         \\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findMinimumTime(vector<vector<int>>& a) {\\n        \\n        int n=a.size();\\n        \\n        int ans=0;\\n        \\n        for(int i=1;i<=2000;i++){\\n              int check=0;\\n              for(int j=0;j<n;j++){\\n                   if(a[j][2]>0&&a[j][1]-i+1==a[j][2]){\\n                        check=1;\\n                   }\\n              }\\n              if(check)\\n              {\\n                   ans++;\\n                   for(int j=0;j<n;j++){\\n                       if(a[j][2]>0&&i>=a[j][0]&&i<=a[j][1])\\n                       {\\n                            a[j][2]--;\\n                       }\\n                   }\\n              }\\n        }\\n        \\n        return ans;\\n        \\n        \\n        \\n        return ans;\\n        \\n         \\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3286823,
                "title": "c-line-by-line-commented-code",
                "content": "The code is explained in the comments\\n\\nThe main point to note are:\\n* we break apart the start and end of a task into two\\n* sort them\\n* start traversing \\n* when we hit start of a task we add it into our map\\n* else we process it\\n* finally we return the result\\n\\n```\\nclass Solution {\\npublic:\\n    int findMinimumTime(vector<vector<int>>& tasks) {\\n        vector<vector<int>> vec;\\n        int res = 0;\\n        map<int ,vector<int>> mp;\\n        \\n        for(int i=0;i<tasks.size();i++){//break the interval into starting and ending sections with index to mark an element for future refrence\\n            vec.push_back({tasks[i][0],0,tasks[i][2],i});//0 is indicator of start of a task\\n            vec.push_back({tasks[i][1],1,tasks[i][2],i});//and 1 is indicator of end of a task\\n        }\\n        \\n        sort(vec.begin(),vec.end());//sort based on time then start of task\\n        //we inserted values in that order to get the required order when sorting is applied\\n        \\n        for(auto x:vec){\\n            if(x[1]==0)//if starting of interval add it into the map\\n                mp[x[3]] = {x[0],x[2]};//with starting value and duration\\n            else{\\n                int ending = x[0],ind = x[3];\\n                int curr_dur = mp[ind][1];//get the time remaining to finish the task\\n                res += curr_dur;//add it to res\\n                for(auto &j:mp){//go to every element in the map and\\n                    int use = min(j.second[1],min(ending-j.second[0]+1,curr_dur));//find the minimum duration that can be used from it\\n                    j.second[1] -= use;//subtract the used duration from duration\\n                    j.second[0] += use;// and increase the starting time of the task by that amount of time\\n                }\\n                mp.erase(ind);//erase the current element from map as it is processed completely\\n            }\\n        }\\n        return res;//return the final result\\n\\n    }\\n};\\n \\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findMinimumTime(vector<vector<int>>& tasks) {\\n        vector<vector<int>> vec;\\n        int res = 0;\\n        map<int ,vector<int>> mp;\\n        \\n        for(int i=0;i<tasks.size();i++){//break the interval into starting and ending sections with index to mark an element for future refrence\\n            vec.push_back({tasks[i][0],0,tasks[i][2],i});//0 is indicator of start of a task\\n            vec.push_back({tasks[i][1],1,tasks[i][2],i});//and 1 is indicator of end of a task\\n        }\\n        \\n        sort(vec.begin(),vec.end());//sort based on time then start of task\\n        //we inserted values in that order to get the required order when sorting is applied\\n        \\n        for(auto x:vec){\\n            if(x[1]==0)//if starting of interval add it into the map\\n                mp[x[3]] = {x[0],x[2]};//with starting value and duration\\n            else{\\n                int ending = x[0],ind = x[3];\\n                int curr_dur = mp[ind][1];//get the time remaining to finish the task\\n                res += curr_dur;//add it to res\\n                for(auto &j:mp){//go to every element in the map and\\n                    int use = min(j.second[1],min(ending-j.second[0]+1,curr_dur));//find the minimum duration that can be used from it\\n                    j.second[1] -= use;//subtract the used duration from duration\\n                    j.second[0] += use;// and increase the starting time of the task by that amount of time\\n                }\\n                mp.erase(ind);//erase the current element from map as it is processed completely\\n            }\\n        }\\n        return res;//return the final result\\n\\n    }\\n};\\n \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3286628,
                "title": "greedy-python",
                "content": "# Intuition\\nRun earlier task as late as you can which benefits later tasks.\\n\\n# Approach\\nGREEDY\\n\\n# Complexity\\n- Time complexity: $O(NT)$\\n\\n\\n\\n\\n# Code\\n```\\nclass Solution:\\n    def findMinimumTime(self, tasks: List[List[int]]) -> int:\\n        tasks.sort(key=lambda x:x[1])\\n        on=[0]*2001\\n        for s,e,d in tasks:\\n            cr=sum(on[s:e+1])\\n            while cr<d:\\n                # Greedy: finish the task as late as you can which benefits later tasks\\n                if on[e]!=1:on[e]=1; cr+=1\\n                e-=1\\n        return sum(on)\\n```",
                "solutionTags": [
                    "Python3",
                    "Greedy"
                ],
                "code": "```\\nclass Solution:\\n    def findMinimumTime(self, tasks: List[List[int]]) -> int:\\n        tasks.sort(key=lambda x:x[1])\\n        on=[0]*2001\\n        for s,e,d in tasks:\\n            cr=sum(on[s:e+1])\\n            while cr<d:\\n                # Greedy: finish the task as late as you can which benefits later tasks\\n                if on[e]!=1:on[e]=1; cr+=1\\n                e-=1\\n        return sum(on)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3286454,
                "title": "simple-python3-o-n-2-greedy-solution",
                "content": "\\n# Code\\n```\\nclass Solution:\\n    def findMinimumTime(self, tasks: List[List[int]]) -> int:\\n        runSet = set()\\n        tasks.sort(key = lambda x: [x[1], x[0], -x[2]])\\n        for i, v in enumerate(tasks):\\n            start, end, duration = v\\n            run = end\\n            while duration > 0:\\n                if run not in runSet:\\n                    runSet.add(run)\\n                    duration -= 1\\n                    for j in range(i + 1, len(tasks)):\\n                        if tasks[j][0] <= run:\\n                            tasks[j][2] -= 1\\n                run -= 1\\n        return len(runSet)\\n```\\n\\n\\n# Complexity\\n- Time complexity: O(N^2)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def findMinimumTime(self, tasks: List[List[int]]) -> int:\\n        runSet = set()\\n        tasks.sort(key = lambda x: [x[1], x[0], -x[2]])\\n        for i, v in enumerate(tasks):\\n            start, end, duration = v\\n            run = end\\n            while duration > 0:\\n                if run not in runSet:\\n                    runSet.add(run)\\n                    duration -= 1\\n                    for j in range(i + 1, len(tasks)):\\n                        if tasks[j][0] <= run:\\n                            tasks[j][2] -= 1\\n                run -= 1\\n        return len(runSet)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3996301,
                "title": "number-line-greedy-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    static bool comp(vector <int> &t1,vector <int> &t2){\\n        return t1[1]<t2[1];\\n    }\\n    int findMinimumTime(vector<vector<int>>& tasks) {\\n        vector <int> timeOn(20001,0);\\n        sort(tasks.begin(),tasks.end(),comp);\\n        int ans = 0;\\n        for(int i=0;i<tasks.size();i++){\\n            int start = tasks[i][0];\\n            int remainingDuration = tasks[i][2];\\n            int end = tasks[i][1];\\n            cout << start << \" \" << end << \" \" << remainingDuration << endl;\\n            int time = start;\\n            while(time <= end && remainingDuration){\\n                if(timeOn[time]==1)\\n                    remainingDuration--;\\n                time++;\\n            }\\n\\n            while(remainingDuration){\\n                if(timeOn[end]!=1){\\n                    timeOn[end] = 1;\\n                    remainingDuration--;\\n                    ans++;\\n                }\\n                end--;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    static bool comp(vector <int> &t1,vector <int> &t2){\\n        return t1[1]<t2[1];\\n    }\\n    int findMinimumTime(vector<vector<int>>& tasks) {\\n        vector <int> timeOn(20001,0);\\n        sort(tasks.begin(),tasks.end(),comp);\\n        int ans = 0;\\n        for(int i=0;i<tasks.size();i++){\\n            int start = tasks[i][0];\\n            int remainingDuration = tasks[i][2];\\n            int end = tasks[i][1];\\n            cout << start << \" \" << end << \" \" << remainingDuration << endl;\\n            int time = start;\\n            while(time <= end && remainingDuration){\\n                if(timeOn[time]==1)\\n                    remainingDuration--;\\n                time++;\\n            }\\n\\n            while(remainingDuration){\\n                if(timeOn[end]!=1){\\n                    timeOn[end] = 1;\\n                    remainingDuration--;\\n                    ans++;\\n                }\\n                end--;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3979708,
                "title": "simplest-code-in-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nfor every interval we need to choose duration hours in given range l to r, we will have to take duration hours optimally\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nusgin brute force apporoach first we will sort according to end values then for every interval we need to take sum of l to r, if sum <duration then take last rem hours (non marked) \\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n$$O(n^2)$$\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n$$O(n)$$\\n# Code\\n```\\nclass Solution {\\npublic:\\n\\n    static bool comp(vector<int>&a,vector<int>&b){\\n        if(b[1]==a[1]) return a[0]<b[0];\\n        return a[1]<b[1];\\n    }\\n\\n    int findMinimumTime(vector<vector<int>>& tasks) {\\n        sort(tasks.begin(),tasks.end(),comp);\\n        int n=tasks.size();\\n        vector<int>mark(2000+10,0);\\n        int mx=0;\\n        for(int i=0;i<n;i++){\\n            int sum=0;\\n            for(int j=tasks[i][0];j<=tasks[i][1];j++) sum+=mark[j];\\n            if(sum<tasks[i][2]){\\n                int t=tasks[i][2]-sum;\\n                for(int j=tasks[i][1];(j>=tasks[i][0]) and t;j--) if(mark[j]==0) mark[j]=1,t--,mx++;\\n            }\\n        }\\n        return mx;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\n    static bool comp(vector<int>&a,vector<int>&b){\\n        if(b[1]==a[1]) return a[0]<b[0];\\n        return a[1]<b[1];\\n    }\\n\\n    int findMinimumTime(vector<vector<int>>& tasks) {\\n        sort(tasks.begin(),tasks.end(),comp);\\n        int n=tasks.size();\\n        vector<int>mark(2000+10,0);\\n        int mx=0;\\n        for(int i=0;i<n;i++){\\n            int sum=0;\\n            for(int j=tasks[i][0];j<=tasks[i][1];j++) sum+=mark[j];\\n            if(sum<tasks[i][2]){\\n                int t=tasks[i][2]-sum;\\n                for(int j=tasks[i][1];(j>=tasks[i][0]) and t;j--) if(mark[j]==0) mark[j]=1,t--,mx++;\\n            }\\n        }\\n        return mx;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3977781,
                "title": "easy-c-sort",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int findMinimumTime(vector<vector<int>>& v) {\\n        vector<int>t(2001,0);\\n        sort(v.begin(),v.end(),[](const auto&a, const auto&b){return a[1] < b[1];});\\n        for(int i=0;i<v.size();i++){\\n            int start=v[i][0];\\n            int end=v[i][1];\\n            int duration=v[i][2];\\n            for(int j=start;j<=end;j++) if(t[j]) duration--;\\n            int j=end;\\n            while(duration>0){\\n                if(t[j]){\\n                    j--;\\n                    continue;\\n                }\\n                t[j]=1;\\n                duration--;\\n                j--;\\n            }\\n        }\\n        int count=0;\\n        for(int i=0;i<2001;i++){\\n            if(t[i]) count++;\\n        }\\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findMinimumTime(vector<vector<int>>& v) {\\n        vector<int>t(2001,0);\\n        sort(v.begin(),v.end(),[](const auto&a, const auto&b){return a[1] < b[1];});\\n        for(int i=0;i<v.size();i++){\\n            int start=v[i][0];\\n            int end=v[i][1];\\n            int duration=v[i][2];\\n            for(int j=start;j<=end;j++) if(t[j]) duration--;\\n            int j=end;\\n            while(duration>0){\\n                if(t[j]){\\n                    j--;\\n                    continue;\\n                }\\n                t[j]=1;\\n                duration--;\\n                j--;\\n            }\\n        }\\n        int count=0;\\n        for(int i=0;i<2001;i++){\\n            if(t[i]) count++;\\n        }\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3975608,
                "title": "sort-binary-search-c",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    int findMinimumTime(vector<vector<int>>& tasks) {\\n        sort(tasks.begin(),tasks.end(),[&](const auto &a,const auto &b){\\n            return a[1] < b[1];\\n        });\\n        set<int> st;\\n        for(int i=0;i<tasks.size();i++){\\n            int duration = tasks[i][2];\\n            auto it = st.lower_bound(tasks[i][0]);\\n            while(it!=st.end() && *it<=tasks[i][1] && duration>0){\\n                duration--; it++;\\n            }\\n            int range = tasks[i][1];\\n            while(duration>0 && range>=tasks[i][0]){\\n                if(!st.count(range)){\\n                    // cout<<range<<endl;\\n                    st.insert(range);\\n                    duration--;\\n                }\\n                range--;\\n            }\\n        }\\n        return st.size();\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Binary Search",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findMinimumTime(vector<vector<int>>& tasks) {\\n        sort(tasks.begin(),tasks.end(),[&](const auto &a,const auto &b){\\n            return a[1] < b[1];\\n        });\\n        set<int> st;\\n        for(int i=0;i<tasks.size();i++){\\n            int duration = tasks[i][2];\\n            auto it = st.lower_bound(tasks[i][0]);\\n            while(it!=st.end() && *it<=tasks[i][1] && duration>0){\\n                duration--; it++;\\n            }\\n            int range = tasks[i][1];\\n            while(duration>0 && range>=tasks[i][0]){\\n                if(!st.count(range)){\\n                    // cout<<range<<endl;\\n                    st.insert(range);\\n                    duration--;\\n                }\\n                range--;\\n            }\\n        }\\n        return st.size();\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3835313,
                "title": "python-hard-line-sweep",
                "content": "```\\nclass Solution:\\n    def findMinimumTime(self, tasks: List[List[int]]) -> int:\\n        line = [0] * 2001\\n\\n        tasks.sort(key = lambda x: x[1])\\n\\n        for start, end, time in tasks:\\n            count = sum(line[x] for x in range(start, end+1))\\n            time = max(0, time - count)\\n         \\n            for i in range(end, start - 1, -1):\\n                \\n                if time and not line[i]:\\n                    line[i] = 1\\n                    time -= 1\\n\\n\\n        return sum(line)\\n\\n\\n\\n\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def findMinimumTime(self, tasks: List[List[int]]) -> int:\\n        line = [0] * 2001\\n\\n        tasks.sort(key = lambda x: x[1])\\n\\n        for start, end, time in tasks:\\n            count = sum(line[x] for x in range(start, end+1))\\n            time = max(0, time - count)\\n         \\n            for i in range(end, start - 1, -1):\\n                \\n                if time and not line[i]:\\n                    line[i] = 1\\n                    time -= 1\\n\\n\\n        return sum(line)\\n\\n\\n\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3703454,
                "title": "python-greedy-explained",
                "content": "One thing is easy to understand that if two tasks are overlapping, then the best option will be to run those two tasks parallelly at the same time points where they overlap in order to minimize the overall time.\\n\\nTo best understand the examples, try to make a number line and then represent each task on it based on its start and end. \\n\\nFor example - tasks = [[1,3,2],[2,5,3],[5,6,2]]\\n\\n![image](https://assets.leetcode.com/users/images/f74fc8f8-ee2d-4f81-8cd6-936986f2361e_1688200258.8961112.png)\\n\\nYou will see that the task [2,5,3] will overlap with the task [1,3,2] which means, if we run the task [1,3,2] at some time points, then at the same points, we can also run the task [2,5,3], provided that we choose the most optimal time points. For example, if we decided to run task [1,3,2] at time points \"1\" and \"2\", then it would mean that the task [2,5,3] can only be run at time point \"2\" parallely with task [1,3,2]. So we will require \"2\" extra time point to run the remaining of task [2,5,3]\\n\\nBut if we run the task [1,3,2] in time points \"2\" and \"3\", then the task [2,5,3] can also be run at those two time points parallely. So now, we will only have to use just \"1\" extra time point for the task [2,5,3] to complete it.\\n\\nThis parallel running of tasks at same points is possible only for overlapping tasks.\\n\\nSo the main thing is, how can we efficiently figure out whether a task overlaps with a previous task or not?\\n\\nCan Sorting the tasks help us in this case?\\n\\nYes! If the tasks are sorted based on when they \"end\", then we can easily find if the next task overlaps with pervious task. \\n\\nIn both the examples in this problem, the tasks are already sorted based on the \"end\" time btw.\\n\\nSo after we sort the input list based on the \"end\" time, then after that, we can start our main logic.\\n\\nWe can use a Set here so that if we run a task at some time point where no other task has ran yet, we can put those time points in that set. That will be useful for the next tasks if they overlap. Because in that case, we can quickly check our set and run those tasks at same time points, hence reducing the amount of time computer will take.\\n\\nAs we saw in above example, it is also possible that after running a task parallely with some other task, we still have some duration left to complete the task. In that case, we will use the time point at the end of the range [start,end] for that task.\\n\\nIn above example, task [2,5,3] could run only for \"2\" seconds during the time when task [1,3,2] was also running. But, we still have to run task [2,5,3] for one more second. And we have two time points available -> \"4\" and \"5\" (since \"2\" and \"3\" have already been used for this task). The optimal strategy would be to utilize the rightmost time point(s). \\n\\nThe reason being that if any next task overlaps with this task, then we will be sure that that task will run parallely during those rightmost points.\\n\\nFor example, in the above example, the third task is [5,6,2] and since it starts at time \"5\" and we have ran [2,5,3] at time \"5\" as well, it means, the third task can run parallely with 2nd task for 1 second at time point \"5\". And for remaining \"1\" second, we can put that at the very end. That is at time \"6\".\\n\\nAnd so, for tasks = [[1,3,2],[2,5,3],[5,6,2]], the minimum time comes out as -> 4 -> WHICH IS JUST THE LENGTH OF THE SET.\\n\\n\\n```\\ndef findMinimumTime(self, tasks: List[List[int]]) -> int: \\n        \\n        # We can quickly check if a task overlaps with previous tasks if the tasks are ordered based on the ending time\\n        tasks.sort(key=lambda x : x[1])\\n        \\n        # Set to keep track of points where tasks has been ran already\\n        alreadyRan = set()\\n        \\n        # Go through each task\\n        for task in tasks:\\n            # If the values in this range [start,end] are already in set\\n            # It means, some previous task has ran in those time points\\n            # So we can run current tasks at the same time\\n            for i in range(task[0], task[1] + 1): \\n                \\n                # We can reduce the duration as the current task runs in same time as some previous task\\n                if i in alreadyRan: task[2] -= 1\\n        \\n            # At this point, if the duration is still not 0\\n            # It means, we have to run this task at the rightmost time points in the range [start, end]\\n            if task[2] > 0:\\n                \\n                # We will run this task at the very end of this task\\'s time range\\n                for i in range(task[1], task[0] - 1, -1):\\n                    # If at this time point, we have already ran this current task\\n                    # We cannot run it again at the same point\\n                    # THIS THING RESULTED IN SOME TEST CASES FAILING -_-\\n                    if i in alreadyRan: continue\\n                    \\n                    # We run the task at the current point\\n                    task[2] -= 1\\n                    \\n                    # Put the current time point in the set\\n                    alreadyRan.add(i)\\n                \\n                    # If duration becomes 0, break\\n                    if task[2] == 0: break\\n                        \\n        # Finally, we can simply return the length of the set\\n        # That is, all the time points at which we ran the tasks\\n        return len(alreadyRan)\\n```",
                "solutionTags": [
                    "Python",
                    "Greedy",
                    "Sorting"
                ],
                "code": "```\\ndef findMinimumTime(self, tasks: List[List[int]]) -> int: \\n        \\n        # We can quickly check if a task overlaps with previous tasks if the tasks are ordered based on the ending time\\n        tasks.sort(key=lambda x : x[1])\\n        \\n        # Set to keep track of points where tasks has been ran already\\n        alreadyRan = set()\\n        \\n        # Go through each task\\n        for task in tasks:\\n            # If the values in this range [start,end] are already in set\\n            # It means, some previous task has ran in those time points\\n            # So we can run current tasks at the same time\\n            for i in range(task[0], task[1] + 1): \\n                \\n                # We can reduce the duration as the current task runs in same time as some previous task\\n                if i in alreadyRan: task[2] -= 1\\n        \\n            # At this point, if the duration is still not 0\\n            # It means, we have to run this task at the rightmost time points in the range [start, end]\\n            if task[2] > 0:\\n                \\n                # We will run this task at the very end of this task\\'s time range\\n                for i in range(task[1], task[0] - 1, -1):\\n                    # If at this time point, we have already ran this current task\\n                    # We cannot run it again at the same point\\n                    # THIS THING RESULTED IN SOME TEST CASES FAILING -_-\\n                    if i in alreadyRan: continue\\n                    \\n                    # We run the task at the current point\\n                    task[2] -= 1\\n                    \\n                    # Put the current time point in the set\\n                    alreadyRan.add(i)\\n                \\n                    # If duration becomes 0, break\\n                    if task[2] == 0: break\\n                        \\n        # Finally, we can simply return the length of the set\\n        # That is, all the time points at which we ran the tasks\\n        return len(alreadyRan)\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3569249,
                "title": "python-solution-easy-to-understand",
                "content": "# Code\\n```\\nclass Solution:\\n    def findMinimumTime(self, tasks: List[List[int]]) -> int:\\n        tasks.sort(key=lambda x:[x[1],-x[2],x[1]])\\n        done=[]\\n        for a,b,c in tasks:\\n            for a1,b1 in done[::-1]:\\n                if(b1>=a and c!=0):\\n                    c=max(c-(b1-max(a1,a)+1),0)\\n                else:\\n                    break\\n            if(c!=0):\\n                done.append([b-c+1,b])\\n                i=len(done)-1\\n                j=i-1\\n                while(j>=0):\\n                    if(done[j][1]>=done[i][0]):\\n                        r=done[j][1]-done[i][0]+1\\n                        done[i][0]+=r\\n                        done[j][0]-=r\\n                    else:\\n                        break\\n                    i-=1\\n                    j-=1\\n        totalTime=0\\n        for a,b in done:\\n            totalTime+=(b-a+1)\\n        return totalTime\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def findMinimumTime(self, tasks: List[List[int]]) -> int:\\n        tasks.sort(key=lambda x:[x[1],-x[2],x[1]])\\n        done=[]\\n        for a,b,c in tasks:\\n            for a1,b1 in done[::-1]:\\n                if(b1>=a and c!=0):\\n                    c=max(c-(b1-max(a1,a)+1),0)\\n                else:\\n                    break\\n            if(c!=0):\\n                done.append([b-c+1,b])\\n                i=len(done)-1\\n                j=i-1\\n                while(j>=0):\\n                    if(done[j][1]>=done[i][0]):\\n                        r=done[j][1]-done[i][0]+1\\n                        done[i][0]+=r\\n                        done[j][0]-=r\\n                    else:\\n                        break\\n                    i-=1\\n                    j-=1\\n        totalTime=0\\n        for a,b in done:\\n            totalTime+=(b-a+1)\\n        return totalTime\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3548168,
                "title": "beginner-or-noob-friendly-solution-very-easy-0-n-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\nstatic bool cmp(vector<int> &a , vector<int> &b){\\nreturn a[1]<b[1];\\n}\\n    int findMinimumTime(vector<vector<int>>& t) {\\n        // {a , b , di} {b ,c , d2}\\n        // so basic idea is , we want to sort them.\\n        sort(t.begin() ,t.end() , cmp);\\n        int ct=0;\\n        vector<int> v(2002 , 0);\\n        for(auto z: t){\\n         auto d=z[2] , en=z[1] , st=z[0];\\n         // first check , if there were any previous ones \\n         for(int i=st ;i<=en ; i++){\\n         if(v[i]==1)d--;\\n         }\\n         // allot the rest ones\\n         while(d>0){\\n         if(v[en]==0){\\n         d--;\\n         ct++;\\n         v[en]=1;\\n         en--;\\n         }\\n         else{\\n         en--;\\n         }\\n         }\\n        }\\n        return ct;\\n    }\\n};",
                "solutionTags": [
                    "C++"
                ],
                "code": "class Solution {\\npublic:\\nstatic bool cmp(vector<int> &a , vector<int> &b){\\nreturn a[1]<b[1];\\n}",
                "codeTag": "Java"
            },
            {
                "id": 3486026,
                "title": "simple-easy-and-fastest-way-in-c",
                "content": "# Code\\n```\\nclass Solution {\\n    static bool sortCol(const vector<int>& V1, const vector<int>& V2) {\\n        return (V1[1] < V2[1]);\\n    }\\npublic:\\n    int findMinimumTime(vector<vector<int>>& tasks) {\\n        int s=INT_MAX, e=INT_MIN, res=0;\\n        vector<int> V(2001, 0);\\n\\n        sort(tasks.begin(), tasks.end(), sortCol);\\n        for(vector<int>& t : tasks) {\\n            int dur = t[2], i;\\n            s=min(s,t[0]);\\n            e=max(e,t[1]);\\n            i=t[0];\\n            while(dur != 0 && i<=t[1]) {\\n                if(s<=i && i<=e) {\\n                    if(V[i]) dur--;\\n                }\\n                else {\\n                    break;\\n                }\\n                i++;\\n            }\\n            //cout<<\"dur = \"<<dur<<endl;\\n            res+=dur;\\n            int j=t[1];\\n            while(dur != 0 && j>=t[0]) {\\n                //cout<<j<<\" \"<<V[j]<<endl;\\n                if(!V[j]) {\\n                    V[j] = 1;\\n                    dur--;\\n                }\\n                j--;\\n            }\\n        }\\n\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\n    static bool sortCol(const vector<int>& V1, const vector<int>& V2) {\\n        return (V1[1] < V2[1]);\\n    }\\npublic:\\n    int findMinimumTime(vector<vector<int>>& tasks) {\\n        int s=INT_MAX, e=INT_MIN, res=0;\\n        vector<int> V(2001, 0);\\n\\n        sort(tasks.begin(), tasks.end(), sortCol);\\n        for(vector<int>& t : tasks) {\\n            int dur = t[2], i;\\n            s=min(s,t[0]);\\n            e=max(e,t[1]);\\n            i=t[0];\\n            while(dur != 0 && i<=t[1]) {\\n                if(s<=i && i<=e) {\\n                    if(V[i]) dur--;\\n                }\\n                else {\\n                    break;\\n                }\\n                i++;\\n            }\\n            //cout<<\"dur = \"<<dur<<endl;\\n            res+=dur;\\n            int j=t[1];\\n            while(dur != 0 && j>=t[0]) {\\n                //cout<<j<<\" \"<<V[j]<<endl;\\n                if(!V[j]) {\\n                    V[j] = 1;\\n                    dur--;\\n                }\\n                j--;\\n            }\\n        }\\n\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3454369,
                "title": "small-test-case-for-wrong-greedy-approach",
                "content": "# Wrong Greedy Approach\\n\\nMy first solution for this problem was a simple greedy approach:\\n\\n- Repeat as long as we have **uncompleted tasks**:\\n  - Find the time t with the maximum number of **uncompleted common tasks** (i.e., tasks with current duration >= 1 and start <= t <= end);\\n  - Turn on the computer at time t and complete one second of the previous tasks (i.e., decrease the current duration of the tasks by 1);\\n  - Update the total time needed to complete the tasks (i.e., totalTime += 1);\\n- Return totalTime;\\n\\nThe **above approach** seems promising (it passes 98% of test cases), but it **doesn\\'t always compute** the **minimum time** to complete all the tasks.  \\nThe most challenging part (at least for me) was to find a small test case for which the above greedy solution would return a wrong answer. After few hours (`:)`) of investigation, I found one example.\\n\\n# Small Test Case\\n<!-- Describe your approach to solving the problem. -->\\n**Input:** `[[1, 3, 1],[1, 10, 2],[7, 12, 2],[12, 15, 1],[5, 15, 2]]`\\n**Wrong Output:** `4`\\n**Expected Output:** `3`\\n\\nWrong Greedy Approach (returns wrong result `4`):\\n```text\\nTime -------------------------------------------------------------------->\\n                          1  2  3  4  5  6  7  8  9  10 11 12 13 14 15\\nUncompleted\\nTasks:\\n| Task 0 (duration = 1):  *  *  *\\n| Task 1 (duration = 2):  *  *  *  *  *  *  *  *  *  *\\n| Task 2 (duration = 2):                    *  *  *  *  *  *\\n| Task 3 (duration = 1):                                   *  *  *  *\\n| Task 4 (duration = 2):              *  *  *  *  *  *  *  *  *  *  *\\nv\\n```\\n`1st iteration (select time t = 7):`\\n```text\\nTime -------------------------------------------------------------------->\\n                          1  2  3  4  5  6  7  8  9  10 11 12 13 14 15\\nUncompleted\\nTasks:\\n| Task 0 (duration = 1):  *  *  *\\n| Task 1 (duration = 1):  *  *  *  *  *  *  -  *  *  *\\n| Task 2 (duration = 1):                    -  *  *  *  *  *\\n| Task 3 (duration = 1):                                   *  *  *  *\\n| Task 4 (duration = 1):              *  *  -  *  *  *  *  *  *  *  *\\nv\\n```\\n`2nd iteration (select time t = 8):`\\n```text\\nTime -------------------------------------------------------------------->\\n                          1  2  3  4  5  6  7  8  9  10 11 12 13 14 15\\nUncompleted\\nTasks:\\n| Task 0 (duration = 1):  *  *  *\\n| Task 1 (duration = 0):  *  *  *  *  *  *  -  -  *  *\\n| Task 2 (duration = 0):                    -  -  *  *  *  *\\n| Task 3 (duration = 1):                                   *  *  *  *\\n| Task 4 (duration = 0):              *  *  -  -  *  *  *  *  *  *  *\\nv\\n```\\n`(duration = 0)` <=> the task is completed => remove it from uncompleted tasks lists;\\n```text\\nTime -------------------------------------------------------------------->\\n                          1  2  3  4  5  6  7  8  9  10 11 12 13 14 15\\nUncompleted\\nTasks:\\n| Task 0 (duration = 1):  *  *  *\\n| \\n| \\n| Task 3 (duration = 1):                                   *  *  *  *\\n| \\nv\\n```\\n`3rd iteration (select time t = 1):`\\n```text\\nTime -------------------------------------------------------------------->\\n                          1  2  3  4  5  6  7  8  9  10 11 12 13 14 15\\nUncompleted\\nTasks:\\n| Task 0 (duration = 0):  -  *  *\\n| \\n| \\n| Task 3 (duration = 1):                                   *  *  *  *\\n| \\nv\\n```\\n`4th iteration (select time t = 12):`\\n```text\\nTime -------------------------------------------------------------------->\\n                          1  2  3  4  5  6  7  8  9  10 11 12 13 14 15\\nUncompleted\\nTasks:\\n| \\n| \\n| \\n| Task 3 (duration = 0):                                   -  *  *  *\\n| \\nv\\n```\\nWe completed all tasks in **4** iterations/seconds (using the wrong greedy solution).\\nSelected times: `7 -> 8 -> 1 -> 12`.\\nUnfortunately this is not the minimum time to complete the tasks.\\n\\nWe can complete all tasks in **3** iterations/seconds.\\nOne valid selection of times is `1 -> 7 -> 12`:\\n```text\\nTime --------------------------------------------------------------------------->\\n                                  1  2  3  4  5  6  7  8  9  10 11 12 13 14 15\\nUncompleted\\nTasks:\\n| Task 0 (initial duration = 1):  -  *  *\\n| Task 1 (initial duration = 2):  -  *  *  *  *  *  -  *  *  *\\n| Task 2 (initial duration = 2):                    -  *  *  *  *  -\\n| Task 3 (initial duration = 1):                                   -  *  *  *\\n| Task 4 (initial duration = 2):              *  *  -  *  *  *  *  -  *  *  *\\nv\\n```\\n",
                "solutionTags": [
                    "Greedy"
                ],
                "code": "```text\\nTime -------------------------------------------------------------------->\\n                          1  2  3  4  5  6  7  8  9  10 11 12 13 14 15\\nUncompleted\\nTasks:\\n| Task 0 (duration = 1):  *  *  *\\n| Task 1 (duration = 2):  *  *  *  *  *  *  *  *  *  *\\n| Task 2 (duration = 2):                    *  *  *  *  *  *\\n| Task 3 (duration = 1):                                   *  *  *  *\\n| Task 4 (duration = 2):              *  *  *  *  *  *  *  *  *  *  *\\nv\\n```\n```text\\nTime -------------------------------------------------------------------->\\n                          1  2  3  4  5  6  7  8  9  10 11 12 13 14 15\\nUncompleted\\nTasks:\\n| Task 0 (duration = 1):  *  *  *\\n| Task 1 (duration = 1):  *  *  *  *  *  *  -  *  *  *\\n| Task 2 (duration = 1):                    -  *  *  *  *  *\\n| Task 3 (duration = 1):                                   *  *  *  *\\n| Task 4 (duration = 1):              *  *  -  *  *  *  *  *  *  *  *\\nv\\n```\n```text\\nTime -------------------------------------------------------------------->\\n                          1  2  3  4  5  6  7  8  9  10 11 12 13 14 15\\nUncompleted\\nTasks:\\n| Task 0 (duration = 1):  *  *  *\\n| Task 1 (duration = 0):  *  *  *  *  *  *  -  -  *  *\\n| Task 2 (duration = 0):                    -  -  *  *  *  *\\n| Task 3 (duration = 1):                                   *  *  *  *\\n| Task 4 (duration = 0):              *  *  -  -  *  *  *  *  *  *  *\\nv\\n```\n```text\\nTime -------------------------------------------------------------------->\\n                          1  2  3  4  5  6  7  8  9  10 11 12 13 14 15\\nUncompleted\\nTasks:\\n| Task 0 (duration = 1):  *  *  *\\n| \\n| \\n| Task 3 (duration = 1):                                   *  *  *  *\\n| \\nv\\n```\n```text\\nTime -------------------------------------------------------------------->\\n                          1  2  3  4  5  6  7  8  9  10 11 12 13 14 15\\nUncompleted\\nTasks:\\n| Task 0 (duration = 0):  -  *  *\\n| \\n| \\n| Task 3 (duration = 1):                                   *  *  *  *\\n| \\nv\\n```\n```text\\nTime -------------------------------------------------------------------->\\n                          1  2  3  4  5  6  7  8  9  10 11 12 13 14 15\\nUncompleted\\nTasks:\\n| \\n| \\n| \\n| Task 3 (duration = 0):                                   -  *  *  *\\n| \\nv\\n```\n```text\\nTime --------------------------------------------------------------------------->\\n                                  1  2  3  4  5  6  7  8  9  10 11 12 13 14 15\\nUncompleted\\nTasks:\\n| Task 0 (initial duration = 1):  -  *  *\\n| Task 1 (initial duration = 2):  -  *  *  *  *  *  -  *  *  *\\n| Task 2 (initial duration = 2):                    -  *  *  *  *  -\\n| Task 3 (initial duration = 1):                                   -  *  *  *\\n| Task 4 (initial duration = 2):              *  *  -  *  *  *  *  -  *  *  *\\nv\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3442157,
                "title": "c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    \\n    static bool comp(vector<int>& x,vector<int>& y){\\n        return x[1]<y[1];    \\n    }\\n    \\n    int findMinimumTime(vector<vector<int>>& tasks) {\\n        \\n         int l,r,time_left;\\n         int res=0;\\n         sort(tasks.begin(),tasks.end(),comp);  // sorting based on ending index \\n         vector<bool> active(2001,false);      // timestamp when our computer was active \\n         \\n         for(int i=0;i<tasks.size();++i){\\n             \\n                 time_left=tasks[i][2];\\n                 l=tasks[i][0];\\n                 r=tasks[i][1];\\n             \\n             for(int i=l;i<=r;++i){   // checking time when my task has already been run\\n                 if(active[i]) time_left--;\\n             }\\n             \\n             while(time_left > 0 ){  // running my task for rest duration\\n                 \\n                 if(!active[r]){ \\n                     active[r]=true;\\n                     time_left--;\\n                     res++;                    \\n                 }\\n                 r--;\\n             }\\n         }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    static bool comp(vector<int>& x,vector<int>& y){\\n        return x[1]<y[1];    \\n    }\\n    \\n    int findMinimumTime(vector<vector<int>>& tasks) {\\n        \\n         int l,r,time_left;\\n         int res=0;\\n         sort(tasks.begin(),tasks.end(),comp);  // sorting based on ending index \\n         vector<bool> active(2001,false);      // timestamp when our computer was active \\n         \\n         for(int i=0;i<tasks.size();++i){\\n             \\n                 time_left=tasks[i][2];\\n                 l=tasks[i][0];\\n                 r=tasks[i][1];\\n             \\n             for(int i=l;i<=r;++i){   // checking time when my task has already been run\\n                 if(active[i]) time_left--;\\n             }\\n             \\n             while(time_left > 0 ){  // running my task for rest duration\\n                 \\n                 if(!active[r]){ \\n                     active[r]=true;\\n                     time_left--;\\n                     res++;                    \\n                 }\\n                 r--;\\n             }\\n         }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3430506,
                "title": "c-true-n-logn-solution-independent-from-duration-constraints",
                "content": "# Intuition\\nThe general intuition is the same as in many other solutions, which is to sort the tasks by their end time, and then to schedule them as late as possible.\\n\\nWhat makes it truly $$nlog(n)$$ is the structure used to keep track of schedule.\\n\\nIt is clear that the used runtime can be represented as a collection of non-intersecting intervals, each ending at the end of some task.\\n\\nLet\\'s represent each interval by its $end$ and its $length$, but instead of storing its length directly, we will record the prefix sum of lengths of the current interval and all intervals to the left. We will store $(end, prefix\\\\_sum)$ pairs in a stack (which we implement via 2 `vector`s to allow binary search). This allows us to find the leftmost interval that intersects with the given task in $$O(log(n))$$, along with the overall intersection size. To maintain the structure we need to throw away all the intervals that will be merged together when we add the remaining runtime, which only requires $$O(1)$$ amortized cost.\\n\\n\\n\\n# Complexity\\n- Time complexity: $$O(nlog(n))$$\\n\\n- Space complexity: $$O(n)$$\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int findMinimumTime(vector<vector<int>>& tasks) {\\n        auto cmp = [](vector<int> const& a, vector<int> const& b) { return a[1] < b[1]; };\\n        sort(tasks.begin(), tasks.end(), cmp);\\n        vector<int> ends(1,-1), prefix(1,0);\\n        int busy = 0;\\n        for (auto const& t: tasks) {\\n            // First interval that intersects with current task\\n            auto first = lower_bound(ends.begin(), ends.end(), t[0]);\\n            // How many minutes we could have run this task already\\n            int used = 0;\\n            if (first != ends.end()) {\\n                int i = first - ends.begin();\\n                // All intervals after the first interval plus a part of the first one.\\n                used = busy - prefix[i] + min(prefix[i] - prefix[i-1], ends[i] - t[0] + 1);\\n            }\\n            // We don\\'t need to run this task anymore.\\n            if (used >= t[2]) continue;\\n            busy += t[2] - used;\\n            // We want to remove all intervals that will be \"glued\" together by added minutes.\\n            // The condition is that the distance from their end to the current task end should\\n            // all be covered.\\n            while (t[1] - ends.back() <= busy - prefix.back()) {\\n                ends.pop_back();\\n                prefix.pop_back();\\n            }\\n            ends.push_back(t[1]);\\n            prefix.push_back(busy);\\n        }\\n        return busy;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findMinimumTime(vector<vector<int>>& tasks) {\\n        auto cmp = [](vector<int> const& a, vector<int> const& b) { return a[1] < b[1]; };\\n        sort(tasks.begin(), tasks.end(), cmp);\\n        vector<int> ends(1,-1), prefix(1,0);\\n        int busy = 0;\\n        for (auto const& t: tasks) {\\n            // First interval that intersects with current task\\n            auto first = lower_bound(ends.begin(), ends.end(), t[0]);\\n            // How many minutes we could have run this task already\\n            int used = 0;\\n            if (first != ends.end()) {\\n                int i = first - ends.begin();\\n                // All intervals after the first interval plus a part of the first one.\\n                used = busy - prefix[i] + min(prefix[i] - prefix[i-1], ends[i] - t[0] + 1);\\n            }\\n            // We don\\'t need to run this task anymore.\\n            if (used >= t[2]) continue;\\n            busy += t[2] - used;\\n            // We want to remove all intervals that will be \"glued\" together by added minutes.\\n            // The condition is that the distance from their end to the current task end should\\n            // all be covered.\\n            while (t[1] - ends.back() <= busy - prefix.back()) {\\n                ends.pop_back();\\n                prefix.pop_back();\\n            }\\n            ends.push_back(t[1]);\\n            prefix.push_back(busy);\\n        }\\n        return busy;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3385358,
                "title": "simple-solution-in-python3-with-explanation-faster-than-93",
                "content": "The goal is to minimize the total number of working time slots. Thus, my approach is to maximize the overlap of all tasks. \\nThe tasks are first sorted by their end timestamps.  \\nI try to allocate the time slots that are already on for each task. \\nIf the already on time slots in its [start, end] window is less than its duration, additional time slots should be set to on for it. \\nIn this sitatuion, the later the time slot is better to choose because the coming tasks in the future, whose end timestamp will be greater or equal to that of the current task. \\n\\n```\\nclass Solution:\\n    def findMinimumTime(self, tasks: List[List[int]]) -> int:\\n        tasks.sort(key=lambda x: (x[1], x[0]))\\n        slots = [0] * (tasks[-1][1]+1)\\n        for s, e, d in tasks:\\n            d -= sum(slots[s:e+1])\\n            for i in range(e, s-1, -1):\\n                if d <= 0:\\n                    break\\n                if slots[i] == 0:\\n                    slots[i] = 1\\n                    d -= 1\\n        return sum(slots)\\n",
                "solutionTags": [
                    "Python3",
                    "Greedy",
                    "Sorting"
                ],
                "code": "The goal is to minimize the total number of working time slots. Thus, my approach is to maximize the overlap of all tasks. \\nThe tasks are first sorted by their end timestamps.  \\nI try to allocate the time slots that are already on for each task. \\nIf the already on time slots in its [start, end] window is less than its duration, additional time slots should be set to on for it. \\nIn this sitatuion, the later the time slot is better to choose because the coming tasks in the future, whose end timestamp will be greater or equal to that of the current task. \\n\\n```\\nclass Solution:\\n    def findMinimumTime(self, tasks: List[List[int]]) -> int:\\n        tasks.sort(key=lambda x: (x[1], x[0]))\\n        slots = [0] * (tasks[-1][1]+1)\\n        for s, e, d in tasks:\\n            d -= sum(slots[s:e+1])\\n            for i in range(e, s-1, -1):\\n                if d <= 0:\\n                    break\\n                if slots[i] == 0:\\n                    slots[i] = 1\\n                    d -= 1\\n        return sum(slots)\\n",
                "codeTag": "Java"
            },
            {
                "id": 3364143,
                "title": "python-greedy-o-n-2",
                "content": "1. Consider the example `tasks = [[1,3,2],[2,5,3],[5,6,2]]`.\\nImagine we list all tasks on schedule, like following:\\n![image](https://assets.leetcode.com/users/images/b4e4146f-ba5c-4ede-876a-70ffb2c64b2b_1680318353.9329975.png)\\n1-1. As time increasing, at `time=3`, `tasks[0]` reaches its deadline. At this moment, we have `tasks[0]` and `tasks[1]` waiting, and we want to finish `tasks[0]`. \\nThe later we run, more processes can be done. In this case, we choose to run `time=2` and `time=3`, so `tasks[0]` is done, and `tasks[1]` has 1 process left.\\n1-2. Then we go on. At `time=5`, `tasks[1]` reaches its deadline. We choose to run `time=5` to finish `tasks[1]`, and `tasks[2]` has 1 process left.\\n1-3. Finally we stop at `time=6`. To finish `tasks[2]`, we can only run `time=6`.\\n2. Sort `tasks` by end time to ensure that all tasks can be finished in order.\\n3. We use array `activated` to record time units used . For each task, go back from its `end`, and search for time units not used yet. When we finish the task, we can go on.\\n4. After all tasks are done, the total number of time units used would be the answer.\\n```\\nclass Solution:\\n    def findMinimumTime(self, tasks: List[List[int]]) -> int:\\n        tasks.sort(key=lambda x: x[1])\\n        \\n        activated = [0]*(tasks[-1][1]+1)\\n        for s, e, d in tasks:\\n            d -= activated[s:e+1].count(1)\\n            idx = e\\n            while d > 0:\\n                if activated[idx] == 0:\\n                    activated[idx] = 1\\n                    d -= 1\\n                idx -= 1\\n        return sum(activated)",
                "solutionTags": [
                    "Python3"
                ],
                "code": "1. Consider the example `tasks = [[1,3,2],[2,5,3],[5,6,2]]`.\\nImagine we list all tasks on schedule, like following:\\n![image](https://assets.leetcode.com/users/images/b4e4146f-ba5c-4ede-876a-70ffb2c64b2b_1680318353.9329975.png)\\n1-1. As time increasing, at `time=3`, `tasks[0]` reaches its deadline. At this moment, we have `tasks[0]` and `tasks[1]` waiting, and we want to finish `tasks[0]`. \\nThe later we run, more processes can be done. In this case, we choose to run `time=2` and `time=3`, so `tasks[0]` is done, and `tasks[1]` has 1 process left.\\n1-2. Then we go on. At `time=5`, `tasks[1]` reaches its deadline. We choose to run `time=5` to finish `tasks[1]`, and `tasks[2]` has 1 process left.\\n1-3. Finally we stop at `time=6`. To finish `tasks[2]`, we can only run `time=6`.\\n2. Sort `tasks` by end time to ensure that all tasks can be finished in order.\\n3. We use array `activated` to record time units used . For each task, go back from its `end`, and search for time units not used yet. When we finish the task, we can go on.\\n4. After all tasks are done, the total number of time units used would be the answer.\\n```\\nclass Solution:\\n    def findMinimumTime(self, tasks: List[List[int]]) -> int:\\n        tasks.sort(key=lambda x: x[1])\\n        \\n        activated = [0]*(tasks[-1][1]+1)\\n        for s, e, d in tasks:\\n            d -= activated[s:e+1].count(1)\\n            idx = e\\n            while d > 0:\\n                if activated[idx] == 0:\\n                    activated[idx] = 1\\n                    d -= 1\\n                idx -= 1\\n        return sum(activated)",
                "codeTag": "Java"
            },
            {
                "id": 3341556,
                "title": "using-segmenttree",
                "content": "\\n\\n# Code\\n```\\nclass SegmentTree:\\n\\n    def __init__(self, arr, operator, operationIdentity) -> None:\\n        self.arrLength = len(arr)\\n        self.arr = arr\\n        self.modifiedNumberOfChildren = 2**(math.ceil(math.log(self.arrLength, 2)))\\n        self.segmentTreeLength = 2*self.modifiedNumberOfChildren - 1\\n        self.segmentTree = [None for i in range(self.segmentTreeLength)]\\n        self.operationIdentity = operationIdentity\\n        self.operation = operator\\n        self.buildSegmentTree(0,self.modifiedNumberOfChildren-1, 0)\\n    \\n    \\n    def buildSegmentTree(self, start, end, index):\\n        if(start == end): \\n            self.segmentTree[index] = self.arr[start] if(start < self.arrLength) else self.operationIdentity\\n            return self.segmentTree[index]\\n          \\n        mid = start + (end - start)//2\\n        leftSegmentValue = self.buildSegmentTree(start, mid, 2*index+1)\\n        rightSegmentValue = self.buildSegmentTree(mid+1, end, 2*index+2)\\n        self.segmentTree[index] = self.operation(leftSegmentValue, rightSegmentValue)\\n        return self.segmentTree[index]\\n\\n\\n    def query(self, start, end):\\n\\n        def queryHelper(qstart, qend, start, end, index):\\n            if(qstart>end or qend<start): return self.operationIdentity\\n            if(qstart == start and qend == end): return self.segmentTree[index]\\n\\n            mid = start + (end - start)//2\\n            return self.operation(queryHelper(qstart, min(qend, mid), start, mid, 2*index + 1), \\n                                  queryHelper(max(qstart, mid+1), qend, mid+1, end, 2*index + 2))\\n\\n        return queryHelper(start, end, 0, self.modifiedNumberOfChildren-1, 0)\\n    \\n    def update(self, index, newValue):\\n\\n        def updateHelper(start, end, segIndex, index, newValue):\\n            if(start == end == index): \\n                self.segmentTree[segIndex] = newValue\\n                return\\n\\n            mid = start + (end - start)//2\\n            if(start <= index <= mid): updateHelper(start, mid, 2*segIndex+1, index, newValue)\\n            else: updateHelper(mid+1, end, 2*segIndex+2, index, newValue)\\n\\n            self.segmentTree[segIndex] = self.operation(self.segmentTree[2*segIndex+1], self.segmentTree[2*segIndex+2])\\n        \\n        self.arr[index] = newValue\\n        updateHelper(0, self.modifiedNumberOfChildren -1, 0, index, newValue)\\n    \\n    def fillhelper(self, num, rstart, rend, fillNum, segstart, segend, index):\\n        if(num == 0 or fillNum == 0): return\\n        if(segend<rstart or rend<segstart): return\\n        \\n        # leaf node \\n        if(segstart == segend  and num == 1): \\n            self.segmentTree[index] = fillNum\\n            return\\n\\n        mid = segstart + (segend - segstart)//2\\n        rightSum = self.query(max(mid+1, rstart), rend)\\n        numEmptyToRight = (rend - max(mid+1, rstart)) + 1 - rightSum\\n        if(numEmptyToRight<0): numEmptyToRight = 0\\n        \\n        # enough to fill only right segment\\n        if(numEmptyToRight >= num): self.fillhelper(num, mid+1, rend, fillNum, mid+1, segend, 2*index+2)\\n        else:\\n            # have to fill in both segments\\n            self.fillhelper(numEmptyToRight, mid+1, rend, fillNum, mid+1, segend, 2*index+2)\\n            self.fillhelper(num - numEmptyToRight, rstart, min(mid, rend), fillNum, segstart, mid, 2*index+1)\\n        \\n        self.segmentTree[index] = self.operation(self.segmentTree[2*index+1], self.segmentTree[2*index+2])\\n    \\n    def rightfill(self, num, start, end, fillNum = None):    \\n        if(not fillNum): fillNum = self.operationIdentity \\n        self.fillhelper(num, start, end, fillNum, 0, self.modifiedNumberOfChildren-1, 0)\\n\\n\\n\\nclass Solution:\\n    def findMinimumTime(self, tasks: List[List[int]]) -> int:\\n        tasks.sort(key=lambda x: (x[1], x[0], x[-1]))\\n        timeline = SegmentTree([0 for i in range(2001)], operator=lambda x, y : x+y, operationIdentity=0)\\n        ans = 0\\n        for start, end, duration in tasks:\\n            onTime =  timeline.query(start, end)\\n            if(onTime >= duration): continue\\n\\n            remaining = duration - onTime\\n            ans += remaining\\n            timeline.rightfill(remaining, start, end, fillNum = 1)\\n        \\n        return ans\\n        \\n```",
                "solutionTags": [
                    "Python3",
                    "Segment Tree"
                ],
                "code": "```\\nclass SegmentTree:\\n\\n    def __init__(self, arr, operator, operationIdentity) -> None:\\n        self.arrLength = len(arr)\\n        self.arr = arr\\n        self.modifiedNumberOfChildren = 2**(math.ceil(math.log(self.arrLength, 2)))\\n        self.segmentTreeLength = 2*self.modifiedNumberOfChildren - 1\\n        self.segmentTree = [None for i in range(self.segmentTreeLength)]\\n        self.operationIdentity = operationIdentity\\n        self.operation = operator\\n        self.buildSegmentTree(0,self.modifiedNumberOfChildren-1, 0)\\n    \\n    \\n    def buildSegmentTree(self, start, end, index):\\n        if(start == end): \\n            self.segmentTree[index] = self.arr[start] if(start < self.arrLength) else self.operationIdentity\\n            return self.segmentTree[index]\\n          \\n        mid = start + (end - start)//2\\n        leftSegmentValue = self.buildSegmentTree(start, mid, 2*index+1)\\n        rightSegmentValue = self.buildSegmentTree(mid+1, end, 2*index+2)\\n        self.segmentTree[index] = self.operation(leftSegmentValue, rightSegmentValue)\\n        return self.segmentTree[index]\\n\\n\\n    def query(self, start, end):\\n\\n        def queryHelper(qstart, qend, start, end, index):\\n            if(qstart>end or qend<start): return self.operationIdentity\\n            if(qstart == start and qend == end): return self.segmentTree[index]\\n\\n            mid = start + (end - start)//2\\n            return self.operation(queryHelper(qstart, min(qend, mid), start, mid, 2*index + 1), \\n                                  queryHelper(max(qstart, mid+1), qend, mid+1, end, 2*index + 2))\\n\\n        return queryHelper(start, end, 0, self.modifiedNumberOfChildren-1, 0)\\n    \\n    def update(self, index, newValue):\\n\\n        def updateHelper(start, end, segIndex, index, newValue):\\n            if(start == end == index): \\n                self.segmentTree[segIndex] = newValue\\n                return\\n\\n            mid = start + (end - start)//2\\n            if(start <= index <= mid): updateHelper(start, mid, 2*segIndex+1, index, newValue)\\n            else: updateHelper(mid+1, end, 2*segIndex+2, index, newValue)\\n\\n            self.segmentTree[segIndex] = self.operation(self.segmentTree[2*segIndex+1], self.segmentTree[2*segIndex+2])\\n        \\n        self.arr[index] = newValue\\n        updateHelper(0, self.modifiedNumberOfChildren -1, 0, index, newValue)\\n    \\n    def fillhelper(self, num, rstart, rend, fillNum, segstart, segend, index):\\n        if(num == 0 or fillNum == 0): return\\n        if(segend<rstart or rend<segstart): return\\n        \\n        # leaf node \\n        if(segstart == segend  and num == 1): \\n            self.segmentTree[index] = fillNum\\n            return\\n\\n        mid = segstart + (segend - segstart)//2\\n        rightSum = self.query(max(mid+1, rstart), rend)\\n        numEmptyToRight = (rend - max(mid+1, rstart)) + 1 - rightSum\\n        if(numEmptyToRight<0): numEmptyToRight = 0\\n        \\n        # enough to fill only right segment\\n        if(numEmptyToRight >= num): self.fillhelper(num, mid+1, rend, fillNum, mid+1, segend, 2*index+2)\\n        else:\\n            # have to fill in both segments\\n            self.fillhelper(numEmptyToRight, mid+1, rend, fillNum, mid+1, segend, 2*index+2)\\n            self.fillhelper(num - numEmptyToRight, rstart, min(mid, rend), fillNum, segstart, mid, 2*index+1)\\n        \\n        self.segmentTree[index] = self.operation(self.segmentTree[2*index+1], self.segmentTree[2*index+2])\\n    \\n    def rightfill(self, num, start, end, fillNum = None):    \\n        if(not fillNum): fillNum = self.operationIdentity \\n        self.fillhelper(num, start, end, fillNum, 0, self.modifiedNumberOfChildren-1, 0)\\n\\n\\n\\nclass Solution:\\n    def findMinimumTime(self, tasks: List[List[int]]) -> int:\\n        tasks.sort(key=lambda x: (x[1], x[0], x[-1]))\\n        timeline = SegmentTree([0 for i in range(2001)], operator=lambda x, y : x+y, operationIdentity=0)\\n        ans = 0\\n        for start, end, duration in tasks:\\n            onTime =  timeline.query(start, end)\\n            if(onTime >= duration): continue\\n\\n            remaining = duration - onTime\\n            ans += remaining\\n            timeline.rightfill(remaining, start, end, fillNum = 1)\\n        \\n        return ans\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3335026,
                "title": "c-sorting-easy-to-understand",
                "content": "```\\nclass Solution {\\npublic:\\n    int findMinimumTime(vector<vector<int>>& tasks)\\n    {\\n        sort(tasks.begin(),tasks.end(),[](vector<int>&a,vector<int>&b){return a[1]<b[1];});\\n        map<int,bool> used;\\n        int count=0;\\n        for(auto &v:tasks)\\n        {\\n            int usedtime=0;\\n            for(int i=v[0];i<=v[1];i++)\\n            {\\n                if(used.count(i))\\n                    usedtime++;\\n            }\\n            for(int i=v[1];usedtime<v[2];i--)\\n            {\\n                if(!used.count(i))\\n                {\\n                    usedtime++;\\n                    used[i]=true;\\n                    count++;\\n                }\\n            }\\n        }\\n        return count;\\n        \\n    }\\n};\\n```\\nIf you like the solution plz upvote.\\n=",
                "solutionTags": [
                    "C",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findMinimumTime(vector<vector<int>>& tasks)\\n    {\\n        sort(tasks.begin(),tasks.end(),[](vector<int>&a,vector<int>&b){return a[1]<b[1];});\\n        map<int,bool> used;\\n        int count=0;\\n        for(auto &v:tasks)\\n        {\\n            int usedtime=0;\\n            for(int i=v[0];i<=v[1];i++)\\n            {\\n                if(used.count(i))\\n                    usedtime++;\\n            }\\n            for(int i=v[1];usedtime<v[2];i--)\\n            {\\n                if(!used.count(i))\\n                {\\n                    usedtime++;\\n                    used[i]=true;\\n                    count++;\\n                }\\n            }\\n        }\\n        return count;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3320582,
                "title": "python-solution-explanation",
                "content": "# Approach\\n1. Sort the tasks by the end time.\\n```\\n        tasks.sort(key = (lambda x: x[1]))\\n```\\n2. We want to use list \"work\" to store times when the computer is on.\\nFor each of the tasks we first check if the computer has already been designed to be working during the appropriate time to execute the task. We decrease the task duration accordingly.\\n```\\n        for s,e,d in tasks:\\n            i = -1\\n            while work[i] >= s:\\n                d -=1\\n                i -=1\\n                if d == 0: break\\n```\\n3. Now if we have any remaining duration to perform we want to book the latest possible time on the computer. So we insert d points into \"work\", which represent the latest possible times to run the current task. However, we need to check if the selected times have not been inserted yet. If so, we shift the range of inserted times.\\n```\\n            end = len(work)-1\\n            i = 0\\n            while i < d:\\n                if work[end] != e-i: work.insert(end+1,e-i)\\n                else:\\n                    d+=1\\n                    end -=1\\n                i +=1\\n```\\n\\n\\n# Code\\n```\\nclass Solution:\\n    def findMinimumTime(self, tasks: List[List[int]]) -> int:\\n\\n        tasks.sort(key = (lambda x: x[1]))\\n        work = [-inf]\\n        for s,e,d in tasks:\\n            i = -1\\n            while work[i] >= s:\\n                d -=1\\n                i -=1\\n                if d == 0: break\\n            end = len(work)-1\\n            i = 0\\n            while i < d:\\n                if work[end] != e-i: work.insert(end+1,e-i)\\n                else:\\n                    d+=1\\n                    end -=1\\n                i +=1\\n\\n        return len(work)-1\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\n        tasks.sort(key = (lambda x: x[1]))\\n```\n```\\n        for s,e,d in tasks:\\n            i = -1\\n            while work[i] >= s:\\n                d -=1\\n                i -=1\\n                if d == 0: break\\n```\n```\\n            end = len(work)-1\\n            i = 0\\n            while i < d:\\n                if work[end] != e-i: work.insert(end+1,e-i)\\n                else:\\n                    d+=1\\n                    end -=1\\n                i +=1\\n```\n```\\nclass Solution:\\n    def findMinimumTime(self, tasks: List[List[int]]) -> int:\\n\\n        tasks.sort(key = (lambda x: x[1]))\\n        work = [-inf]\\n        for s,e,d in tasks:\\n            i = -1\\n            while work[i] >= s:\\n                d -=1\\n                i -=1\\n                if d == 0: break\\n            end = len(work)-1\\n            i = 0\\n            while i < d:\\n                if work[end] != e-i: work.insert(end+1,e-i)\\n                else:\\n                    d+=1\\n                    end -=1\\n                i +=1\\n\\n        return len(work)-1\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3318150,
                "title": "simple-video-explanation-in-hindi",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nExplained in detail in the video.\\n\\nhttps://www.youtube.com/watch?v=OOe2tdOkd1k&ab_channel=CodingBeast\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nExplained in detail in the video above.\\n\\n\\n# Complexity\\n- Time complexity: O(nlogn + nT)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(T)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\nWhere \\'T\\' is the max time possible. For eg, `2000` in this problem.\\n\\n# Code\\n```\\nclass Solution {\\n    \\n    public int findMinimumTime(int[][] tasks) {\\n\\n        boolean[] on = new boolean[2001];\\n        \\n        // sort tasks in the ascending order of their end time.\\n        Arrays.sort(tasks, new Comparator<int[]>() {\\n            public int compare(int[] task1, int[] task2) {\\n                return Integer.compare(task1[1], task2[1]);\\n            }\\n        });\\n\\n        for (int[] task: tasks) {\\n\\n            int start = task[0];\\n            int end = task[1];\\n            int dur = task[2];\\n\\n            // reduce dur for when PC is on\\n            for (int i=start; i<=end; i++) {\\n                if (on[i]) dur--;\\n            }\\n\\n            // turn on to run remaining dur at end\\n            for (int i=end; dur > 0; i--) {\\n                if (!on[i]) {\\n                    on[i] = true;\\n                    dur--;\\n                }\\n            }\\n        }\\n\\n        int count = 0;\\n        for (boolean isOn: on) {\\n            if (isOn) count++; \\n        }\\n\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    \\n    public int findMinimumTime(int[][] tasks) {\\n\\n        boolean[] on = new boolean[2001];\\n        \\n        // sort tasks in the ascending order of their end time.\\n        Arrays.sort(tasks, new Comparator<int[]>() {\\n            public int compare(int[] task1, int[] task2) {\\n                return Integer.compare(task1[1], task2[1]);\\n            }\\n        });\\n\\n        for (int[] task: tasks) {\\n\\n            int start = task[0];\\n            int end = task[1];\\n            int dur = task[2];\\n\\n            // reduce dur for when PC is on\\n            for (int i=start; i<=end; i++) {\\n                if (on[i]) dur--;\\n            }\\n\\n            // turn on to run remaining dur at end\\n            for (int i=end; dur > 0; i--) {\\n                if (!on[i]) {\\n                    on[i] = true;\\n                    dur--;\\n                }\\n            }\\n        }\\n\\n        int count = 0;\\n        for (boolean isOn: on) {\\n            if (isOn) count++; \\n        }\\n\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3310803,
                "title": "the-proper-solution-system-of-difference-constraints",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe problem seems to be a sort and greedy one, but the greedy algorithm is hard to prove/disprove. However, the problem could be converted to a system of inequality, and it is solveable by shortest path algorithm.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nDefine `a[i] = 0` if at time i, the computer is off\\nDefine `a[i] = 1` if at time i, the computer is on\\n\\nSo for each task [start, end, duration] we have: `a[start] + .. + a[end] >= duration`. This inspires us to construct a prefix sum array p, where `p[i] = a[0] + ... + a[i]`\\n\\nThen for each task, we have: `p[end] - p[start - 1] >= duration`\\n\\n`a[i] = 0 or 1` could be converted to:\\n\\n`p[i + 1] - p[i] >= 0`\\n`p[i + 1] - p[i] <= 1`\\n\\nrewrite everything in `<=`, we have:\\n\\n`p[start - 1] - p[end] <= -duration`\\n`p[i + 1] - p[i] <= 1`\\n`p[i] - p[i + 1] <= 0`\\n\\n\\nSuch system of inequality is called system of difference constraints and could be solved by shortest path.\\n\\n[Reference](https://courses.csail.mit.edu/6.006/spring11/lectures/lec17.pdf), page 6\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nLet n be the total number of tasks. There are 2001 nodes and n edges in the graph. The time complexity to run bellman-ford algorithm is O(number of nodes * number of edges) = O(2001*(n+4000)) = O(n)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(n+2001) = O(n)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int findMinimumTime(vector<vector<int>>& tasks) {\\n        vector<int> f, t, v;\\n\\n        #define make_edge(_f, _t, _v) \\\\\\n            do { \\\\\\n                f.push_back(_f); \\\\\\n                t.push_back(_t); \\\\\\n                v.push_back(_v); \\\\\\n            } while (0)\\n        \\n        for (const auto &task : tasks) {\\n            int start = task[0];\\n            int end = task[1];\\n            int duration = task[2];\\n            make_edge(end, start - 1, -duration);\\n        }\\n        for (int i = 0; i <= 2000; i++) {\\n            if (i + 1 <= 2000) {\\n                make_edge(i + 1, i, 0);\\n                make_edge(i, i + 1, 1);\\n            }\\n        }\\n\\n        vector<int> dist(2001, 0);\\n        int m = f.size();\\n        while (true) {\\n            bool changed = false;\\n            for (int i = 0; i < m; i++) {\\n                if (dist[t[i]] > dist[f[i]] + v[i]) {\\n                    changed = true;\\n                    dist[t[i]] = dist[f[i]] + v[i];\\n                }\\n            }\\n            if (!changed) {\\n                break;\\n            }\\n        }\\n        return -dist[0];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Shortest Path"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findMinimumTime(vector<vector<int>>& tasks) {\\n        vector<int> f, t, v;\\n\\n        #define make_edge(_f, _t, _v) \\\\\\n            do { \\\\\\n                f.push_back(_f); \\\\\\n                t.push_back(_t); \\\\\\n                v.push_back(_v); \\\\\\n            } while (0)\\n        \\n        for (const auto &task : tasks) {\\n            int start = task[0];\\n            int end = task[1];\\n            int duration = task[2];\\n            make_edge(end, start - 1, -duration);\\n        }\\n        for (int i = 0; i <= 2000; i++) {\\n            if (i + 1 <= 2000) {\\n                make_edge(i + 1, i, 0);\\n                make_edge(i, i + 1, 1);\\n            }\\n        }\\n\\n        vector<int> dist(2001, 0);\\n        int m = f.size();\\n        while (true) {\\n            bool changed = false;\\n            for (int i = 0; i < m; i++) {\\n                if (dist[t[i]] > dist[f[i]] + v[i]) {\\n                    changed = true;\\n                    dist[t[i]] = dist[f[i]] + v[i];\\n                }\\n            }\\n            if (!changed) {\\n                break;\\n            }\\n        }\\n        return -dist[0];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3307029,
                "title": "c-easy-solution-greedy-optimal-solution",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n//Intution:Sort task by end point.Since there are only up to 2000 time points to consider, you can check them one by one.if you have to do task at ith time then within l to r we choose last minute so that it will use in next task schedule.\\n    //TC=O(nlogn)+O(n*(n+n))\\n    //SC=O(m) m=2000\\n    //Greedy\\n    static bool com(vector<int>& a,vector<int>& b){\\n        return a[1]<b[1];\\n    }\\n    int findMinimumTime(vector<vector<int>>& tasks) {\\n        int n=tasks.size();\\n        vector<bool> on(2001,false);\\n        sort(tasks.begin(),tasks.end(),com);\\n        int c=0;\\n        for(int i=0;i<tasks.size();i++){\\n            int total_on=0;\\n            for(int j=tasks[i][0];j<=tasks[i][1];j++){\\n                if(on[j]){\\n                    total_on++;\\n                }\\n\\n            }\\n            if(total_on<tasks[i][2]){\\n                int need=tasks[i][2]-total_on;\\n                for(int j=tasks[i][1];j>=tasks[i][0];j--){\\n                    if(on[j]==false){                       \\n                        c++;\\n                        need--;\\n                        on[j]=true;\\n                    }\\n                    if(need==0){\\n                        break;\\n                    }\\n\\n                }\\n            }\\n        }\\n        return c;\\n    }\\n};\\n```\\n# AUTHOR: JAYESH BADGUJAR\\n",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Greedy",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n//Intution:Sort task by end point.Since there are only up to 2000 time points to consider, you can check them one by one.if you have to do task at ith time then within l to r we choose last minute so that it will use in next task schedule.\\n    //TC=O(nlogn)+O(n*(n+n))\\n    //SC=O(m) m=2000\\n    //Greedy\\n    static bool com(vector<int>& a,vector<int>& b){\\n        return a[1]<b[1];\\n    }\\n    int findMinimumTime(vector<vector<int>>& tasks) {\\n        int n=tasks.size();\\n        vector<bool> on(2001,false);\\n        sort(tasks.begin(),tasks.end(),com);\\n        int c=0;\\n        for(int i=0;i<tasks.size();i++){\\n            int total_on=0;\\n            for(int j=tasks[i][0];j<=tasks[i][1];j++){\\n                if(on[j]){\\n                    total_on++;\\n                }\\n\\n            }\\n            if(total_on<tasks[i][2]){\\n                int need=tasks[i][2]-total_on;\\n                for(int j=tasks[i][1];j>=tasks[i][0];j--){\\n                    if(on[j]==false){                       \\n                        c++;\\n                        need--;\\n                        on[j]=true;\\n                    }\\n                    if(need==0){\\n                        break;\\n                    }\\n\\n                }\\n            }\\n        }\\n        return c;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3306689,
                "title": "c-sort-according-to-tasks-i-1",
                "content": "# Observation\\n- We have to choose time to run which is common for most \\n- And there is one key point for lesser end time it is benificial to do the work as last as possible.\\n\\n# Complexity\\n- Time complexity: $$O(n*maxTimeTaken)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(maxTimeTaken)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n\\n    static bool cmp(vector<int> &a, vector<int> &b){\\n        if(a[1]==b[1]){\\n            return a[0]<b[0];\\n        }\\n        return a[1]<b[1];\\n    }\\n\\n    int findMinimumTime(vector<vector<int>>& tasks) {\\n        vector<int> vist(2001,0);\\n\\n        sort(tasks.begin(),tasks.end(),cmp);\\n        int ans=0;\\n        for(int i=0;i<tasks.size();i++){\\n            int l=tasks[i][0], r=tasks[i][1];\\n          \\n            for(int j=r;j>=l;j--){\\n                if(tasks[i][2]<=0){\\n                    break;\\n                }\\n                if(vist[j]==0){\\n                    ans++;\\n                    vist[j]=1;\\n                    for(int k=i;k<tasks.size();k++){\\n                        if(j>=tasks[k][0] && j<=tasks[k][1]){\\n                            tasks[k][2]--;\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\n    static bool cmp(vector<int> &a, vector<int> &b){\\n        if(a[1]==b[1]){\\n            return a[0]<b[0];\\n        }\\n        return a[1]<b[1];\\n    }\\n\\n    int findMinimumTime(vector<vector<int>>& tasks) {\\n        vector<int> vist(2001,0);\\n\\n        sort(tasks.begin(),tasks.end(),cmp);\\n        int ans=0;\\n        for(int i=0;i<tasks.size();i++){\\n            int l=tasks[i][0], r=tasks[i][1];\\n          \\n            for(int j=r;j>=l;j--){\\n                if(tasks[i][2]<=0){\\n                    break;\\n                }\\n                if(vist[j]==0){\\n                    ans++;\\n                    vist[j]=1;\\n                    for(int k=i;k<tasks.size();k++){\\n                        if(j>=tasks[k][0] && j<=tasks[k][1]){\\n                            tasks[k][2]--;\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3305677,
                "title": "a-few-solutions",
                "content": "Sort the array `A` of intervals `i..j` by end-time `j`, then greedily consume from the end of each interval until we `have` what we `need`.\\n\\n---\\n\\n*Kotlin*\\n```\\nclass Solution {\\n    fun findMinimumTime(A: Array<IntArray>): Int {\\n        var have = IntArray(2000 + 1) { 0 }\\n        for ((i, j, needed) in A.sortedWith(Comparator{ a, b -> a[1] - b[1] })) {\\n            var (k, need) = Pair(j, needed - have.slice(i..j).sum())\\n            while (0 < need) {\\n                need -= if (have[k] == 0) 1 else 0; have[k--] = 1\\n            }\\n        }\\n        return have.sum()\\n    }\\n}\\n```\\n\\n*Javascript*\\n```\\nlet findMinimumTime = (A, have = Array(2000 + 1).fill(0)) => {\\n    for (let [i, j, need] of A.sort((a, b) => a[1] - b[1])) {\\n        need -= _.sum(have.slice(i, j + 1));\\n        while (0 < need)\\n            need -= !have[j], have[j--] = 1;\\n    }\\n    return _.sum(have);\\n};\\n```\\n\\n*Python3*\\n```\\nclass Solution:\\n    def findMinimumTime(self, A: List[List[int]]) -> int:\\n        have = [0] * (2000 + 1)\\n        for i, j, need in sorted(A, key=lambda task: task[1]):\\n            need -= sum(have[i:j + 1])\\n            while 0 < need:\\n                need -= not have[j]; have[j] = 1; j -= 1\\n        return sum(have)\\n```\\n\\n*Rust*\\n```\\nimpl Solution {\\n    pub fn find_minimum_time(mut A: Vec<Vec<i32>>) -> i32 {\\n        let mut have = vec![0; 2000 + 1];\\n        A.sort_by(|a, b| a[1].cmp(&b[1]));\\n        for task in A {\\n            let (i, mut j, mut need) = (task[0] as usize, task[1] as usize, task[2]);\\n            need -= have[i..=j].iter().sum::<i32>();\\n            while 0 < need {\\n                need -= if have[j] == 0 { 1 } else { 0 }; have[j] = 1; j -= 1;\\n            }\\n        }\\n        have.into_iter().sum::<i32>()\\n    }\\n}\\n```\\n\\n*C++*\\n```\\nclass Solution {\\npublic:\\n    using VI = vector<int>;\\n    using VVI = vector<VI>;\\n    int findMinimumTime(VVI& A, VI have = VI(2000 + 1)) {\\n        sort(A.begin(), A.end(), [](auto& a, auto& b) { return a[1] < b[1]; });\\n        for (auto& task: A) {\\n            auto [i, j, need] = make_tuple(task[0], task[1], task[2]);\\n            need -= accumulate(have.begin() + i, have.begin() + j + 1, 0);\\n            while (0 < need)\\n                need -= !have[j], have[j--] = 1;\\n        }\\n        return accumulate(have.begin(), have.end(), 0);\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    fun findMinimumTime(A: Array<IntArray>): Int {\\n        var have = IntArray(2000 + 1) { 0 }\\n        for ((i, j, needed) in A.sortedWith(Comparator{ a, b -> a[1] - b[1] })) {\\n            var (k, need) = Pair(j, needed - have.slice(i..j).sum())\\n            while (0 < need) {\\n                need -= if (have[k] == 0) 1 else 0; have[k--] = 1\\n            }\\n        }\\n        return have.sum()\\n    }\\n}\\n```\n```\\nlet findMinimumTime = (A, have = Array(2000 + 1).fill(0)) => {\\n    for (let [i, j, need] of A.sort((a, b) => a[1] - b[1])) {\\n        need -= _.sum(have.slice(i, j + 1));\\n        while (0 < need)\\n            need -= !have[j], have[j--] = 1;\\n    }\\n    return _.sum(have);\\n};\\n```\n```\\nclass Solution:\\n    def findMinimumTime(self, A: List[List[int]]) -> int:\\n        have = [0] * (2000 + 1)\\n        for i, j, need in sorted(A, key=lambda task: task[1]):\\n            need -= sum(have[i:j + 1])\\n            while 0 < need:\\n                need -= not have[j]; have[j] = 1; j -= 1\\n        return sum(have)\\n```\n```\\nimpl Solution {\\n    pub fn find_minimum_time(mut A: Vec<Vec<i32>>) -> i32 {\\n        let mut have = vec![0; 2000 + 1];\\n        A.sort_by(|a, b| a[1].cmp(&b[1]));\\n        for task in A {\\n            let (i, mut j, mut need) = (task[0] as usize, task[1] as usize, task[2]);\\n            need -= have[i..=j].iter().sum::<i32>();\\n            while 0 < need {\\n                need -= if have[j] == 0 { 1 } else { 0 }; have[j] = 1; j -= 1;\\n            }\\n        }\\n        have.into_iter().sum::<i32>()\\n    }\\n}\\n```\n```\\nclass Solution {\\npublic:\\n    using VI = vector<int>;\\n    using VVI = vector<VI>;\\n    int findMinimumTime(VVI& A, VI have = VI(2000 + 1)) {\\n        sort(A.begin(), A.end(), [](auto& a, auto& b) { return a[1] < b[1]; });\\n        for (auto& task: A) {\\n            auto [i, j, need] = make_tuple(task[0], task[1], task[2]);\\n            need -= accumulate(have.begin() + i, have.begin() + j + 1, 0);\\n            while (0 < need)\\n                need -= !have[j], have[j--] = 1;\\n        }\\n        return accumulate(have.begin(), have.end(), 0);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3302156,
                "title": "python-o-nd-o-2001-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def findMinimumTime(self, tasks: List[List[int]]) -> int:\\n        tasks.sort(key=lambda x: x[1])\\n        turn_on = [False] * 2001\\n        total = 0\\n        for s, e, d in tasks:\\n            d = max(0, d - sum(turn_on[s:e+1]))\\n            total += d\\n            while d:\\n                if not turn_on[e]:\\n                    turn_on[e] = True\\n                    d -= 1\\n                e -= 1\\n        return total\\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def findMinimumTime(self, tasks: List[List[int]]) -> int:\\n        tasks.sort(key=lambda x: x[1])\\n        turn_on = [False] * 2001\\n        total = 0\\n        for s, e, d in tasks:\\n            d = max(0, d - sum(turn_on[s:e+1]))\\n            total += d\\n            while d:\\n                if not turn_on[e]:\\n                    turn_on[e] = True\\n                    d -= 1\\n                e -= 1\\n        return total\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3301400,
                "title": "simple-java-solution",
                "content": "```\\nclass Solution {\\n    public int findMinimumTime(int[][] a) {\\n        \\n        Arrays.sort(a,(x,y)->x[1]-y[1]);\\n        \\n        HashSet<Integer> time= new HashSet<>();\\n        \\n        for(int i=a[0][1];i>a[0][1]-a[0][2];i--)time.add(i);\\n        \\n        for(int i=1;i<a.length;i++){\\n            int d=a[i][2];\\n            for(int j=a[i][0];j<=a[i][1] && d>0;j++){\\n                if(time.contains(j))d--;\\n            }\\n            for(int j=a[i][1];j>a[i][1]-d;j--){\\n                if(time.contains(j))d++;\\n                time.add(j);\\n            }\\n        }\\n        return time.size();\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int findMinimumTime(int[][] a) {\\n        \\n        Arrays.sort(a,(x,y)->x[1]-y[1]);\\n        \\n        HashSet<Integer> time= new HashSet<>();\\n        \\n        for(int i=a[0][1];i>a[0][1]-a[0][2];i--)time.add(i);\\n        \\n        for(int i=1;i<a.length;i++){\\n            int d=a[i][2];\\n            for(int j=a[i][0];j<=a[i][1] && d>0;j++){\\n                if(time.contains(j))d--;\\n            }\\n            for(int j=a[i][1];j>a[i][1]-d;j--){\\n                if(time.contains(j))d++;\\n                time.add(j);\\n            }\\n        }\\n        return time.size();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3300588,
                "title": "scala-recursive-greedy-solution-with-set-int-time-on",
                "content": "# Code\\n```\\nobject Solution {\\n  \\n  case class Task(start: Int, end: Int, duration: Int)\\n    \\n  def findMinimumTime(tasks: Array[Array[Int]]): Int = {\\n    val sorted = tasks.collect { case Array(start, end, duration) => Task(start, end, duration) }.sortBy(_.end)\\n    goFind(sorted.toList, Set.empty)\\n  }\\n\\n  def goFind(tasks: List[Task], on: Set[Int]): Int =\\n    tasks match {\\n      case Nil => on.size\\n      case h :: tail =>\\n        val newOn = h.end.to(h.start, -1).filter(!on.contains(_)).take(h.duration)\\n        goFind(tail.flatMap(minus(_, newOn)), on ++ newOn)\\n    }\\n\\n  private def minus(task: Task, newOn: IndexedSeq[Int]) =\\n    if (newOn.head < task.start) List(task)\\n    else {\\n      val newDuration = task.duration - newOn.iterator.takeWhile(_ >= task.start).size\\n      if (newDuration > 0) List(Task(task.start, task.end, newDuration))\\n      else List.empty\\n    }\\n}\\n```",
                "solutionTags": [
                    "Scala"
                ],
                "code": "```\\nobject Solution {\\n  \\n  case class Task(start: Int, end: Int, duration: Int)\\n    \\n  def findMinimumTime(tasks: Array[Array[Int]]): Int = {\\n    val sorted = tasks.collect { case Array(start, end, duration) => Task(start, end, duration) }.sortBy(_.end)\\n    goFind(sorted.toList, Set.empty)\\n  }\\n\\n  def goFind(tasks: List[Task], on: Set[Int]): Int =\\n    tasks match {\\n      case Nil => on.size\\n      case h :: tail =>\\n        val newOn = h.end.to(h.start, -1).filter(!on.contains(_)).take(h.duration)\\n        goFind(tail.flatMap(minus(_, newOn)), on ++ newOn)\\n    }\\n\\n  private def minus(task: Task, newOn: IndexedSeq[Int]) =\\n    if (newOn.head < task.start) List(task)\\n    else {\\n      val newDuration = task.duration - newOn.iterator.takeWhile(_ >= task.start).size\\n      if (newDuration > 0) List(Task(task.start, task.end, newDuration))\\n      else List.empty\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3298862,
                "title": "greedy-java-solution-commented",
                "content": "```\\nclass Solution {\\n    public int findMinimumTime(int[][] tasks) {\\n        //the main greedy approach here is that we need to complete tasks before their end time and hence we sort the array using end time\\n     int ans=0;\\n        boolean[] time = new boolean[2001];\\n        Arrays.sort(tasks, Comparator.comparingInt(a->a[1]));//sorting on basis of end time\\n        for(int i=tasks[0][1]-tasks[0][2]+1;i<=tasks[0][1];i++){\\n            time[i]=true;//making every sec true as we turn on our computer for our very first task \\n            ans++;\\n        }\\n         //minimum possible time would be for that tasks whose end is earliest\\n        for(int k=1;k<tasks.length;k++){\\n            int[] curr=tasks[k];\\n             for(int i=curr[0];i<=curr[1];i++){\\n                if(time[i])curr[2]--;//running our tasks with prev tasks\\n            }\\n            for(int i=curr[1];i>=curr[0] && curr[2] >0;i--){//what we are doing here is that for remaning duration we will run our tasks backwards from end point upto the point our duration finishes \\n                if(!time[i]){\\n                    time[i]=true;\\n                    ans++;\\n                    curr[2]--;\\n                }\\n            }\\n        }\\n        return ans;   \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Greedy",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\n    public int findMinimumTime(int[][] tasks) {\\n        //the main greedy approach here is that we need to complete tasks before their end time and hence we sort the array using end time\\n     int ans=0;\\n        boolean[] time = new boolean[2001];\\n        Arrays.sort(tasks, Comparator.comparingInt(a->a[1]));//sorting on basis of end time\\n        for(int i=tasks[0][1]-tasks[0][2]+1;i<=tasks[0][1];i++){\\n            time[i]=true;//making every sec true as we turn on our computer for our very first task \\n            ans++;\\n        }\\n         //minimum possible time would be for that tasks whose end is earliest\\n        for(int k=1;k<tasks.length;k++){\\n            int[] curr=tasks[k];\\n             for(int i=curr[0];i<=curr[1];i++){\\n                if(time[i])curr[2]--;//running our tasks with prev tasks\\n            }\\n            for(int i=curr[1];i>=curr[0] && curr[2] >0;i--){//what we are doing here is that for remaning duration we will run our tasks backwards from end point upto the point our duration finishes \\n                if(!time[i]){\\n                    time[i]=true;\\n                    ans++;\\n                    curr[2]--;\\n                }\\n            }\\n        }\\n        return ans;   \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3296220,
                "title": "c-simple-solution-greedy-solution-in-single-iteration-sorting",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nsteps as follows:\\n1. sort the tasks array w.r.t end time.\\n2. create a map which will track that slot is used or not\\n3. if slot is used:- we simply decrease duration\\n    if slot is not used:- we will count slot and make the slot as used\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n^2)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    // bool comp(const vector<int>&a, const vector<int>&b){\\n    //     if(a[1] != b[1]){\\n    //         return a[1] < b[1];\\n    //     }\\n    //     else return a[0]<b[0];\\n    // }\\n    int findMinimumTime(vector<vector<int>>& tasks) {\\n        sort(tasks.begin(),tasks.end(),[]( vector<int>&a, vector<int>&b){\\n        return (a[1] != b[1])? a[1]<b[1] :a[0]<b[0];\\n            \\n    });\\n        \\n        int n=tasks.size();\\n        \\n        unordered_map<int,bool>mp;\\n        int count=0;\\n        \\n        for(auto task:tasks){\\n            \\n            for(int i=task[0] ;i <=task[1];i++) if(mp[i]){task[2]--;}\\n            \\n            if(task[2] <= 0) continue;\\n            \\n            for(int i=task[1];task[2] > 0;i--){\\n                if(!mp[i]){\\n                task[2]--;\\n                mp[i]=1;\\n                count++;\\n                }\\n                \\n            }\\n        }\\n        \\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    // bool comp(const vector<int>&a, const vector<int>&b){\\n    //     if(a[1] != b[1]){\\n    //         return a[1] < b[1];\\n    //     }\\n    //     else return a[0]<b[0];\\n    // }\\n    int findMinimumTime(vector<vector<int>>& tasks) {\\n        sort(tasks.begin(),tasks.end(),[]( vector<int>&a, vector<int>&b){\\n        return (a[1] != b[1])? a[1]<b[1] :a[0]<b[0];\\n            \\n    });\\n        \\n        int n=tasks.size();\\n        \\n        unordered_map<int,bool>mp;\\n        int count=0;\\n        \\n        for(auto task:tasks){\\n            \\n            for(int i=task[0] ;i <=task[1];i++) if(mp[i]){task[2]--;}\\n            \\n            if(task[2] <= 0) continue;\\n            \\n            for(int i=task[1];task[2] > 0;i--){\\n                if(!mp[i]){\\n                task[2]--;\\n                mp[i]=1;\\n                count++;\\n                }\\n                \\n            }\\n        }\\n        \\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3295411,
                "title": "c-rust-greedy-delay-as-much-as-possible",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(N * N)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(N)\\n# Code\\n```\\n// C++\\nclass Solution {\\npublic:\\n    int findMinimumTime(vector<vector<int>>& tasks) {\\n        int ret = 0;\\n\\n        for (int i = 1; i <= 2000; ++i) {\\n            bool selected = false;\\n            for (auto &it: tasks) {\\n                if (it[2] == 0 or it[1] - i + 1 > it[2]) continue;\\n                selected = true;\\n                break;\\n            }\\n            if (not selected) continue;\\n            ret += 1;\\n            for (auto &t: tasks) {\\n                if (t[2] > 0 and t[0] <= i and t[1] >= i) t[2] -= 1;\\n            }\\n        }\\n\\n        return ret;\\n    }\\n};\\n```\\n\\n~~~\\nimpl Solution {\\n    pub fn find_minimum_time(tasks: Vec<Vec<i32>>) -> i32 {\\n        let mut tasks = tasks;\\n        let mut ret = 0;\\n\\n        for i in 1 .. 2001 { \\n            let mut selected = false;\\n            for t in &tasks {\\n                if t[2] == 0 || t[1] - i + 1 > t[2] { continue }\\n                selected = true;\\n                break\\n            }\\n\\n            if selected == false { continue }\\n            ret += 1;\\n\\n            for k in 0 .. tasks.len() {\\n                if tasks[k][2] > 0 && tasks[k][0] <= i && tasks[k][1] >= i { tasks[k][2] -= 1; }\\n            }\\n        }\\n        ret\\n    }\\n}\\n~~~",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n// C++\\nclass Solution {\\npublic:\\n    int findMinimumTime(vector<vector<int>>& tasks) {\\n        int ret = 0;\\n\\n        for (int i = 1; i <= 2000; ++i) {\\n            bool selected = false;\\n            for (auto &it: tasks) {\\n                if (it[2] == 0 or it[1] - i + 1 > it[2]) continue;\\n                selected = true;\\n                break;\\n            }\\n            if (not selected) continue;\\n            ret += 1;\\n            for (auto &t: tasks) {\\n                if (t[2] > 0 and t[0] <= i and t[1] >= i) t[2] -= 1;\\n            }\\n        }\\n\\n        return ret;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3293663,
                "title": "binary-index-tree",
                "content": "The runtime is O(nlgn).\\n\\n```\\nclass BIT{\\npublic:\\n    BIT(int sz){\\n        tree_.resize(sz);\\n    }\\n    \\n    BIT(){\\n        \\n    }\\n    \\n    void ini(int sz){\\n        tree_.resize(sz);\\n    }\\n    \\n    void change(int idx, int val){ // use idx of num\\n        for (int i = ++idx; i < tree_.size(); i += i & -i){\\n            tree_[i] += val;\\n        }\\n    }\\n    \\n    int query(int idx){ // need to add 1\\n        int ans = 0;\\n        for (int i = idx; i >= 1; i -= i & -i){\\n            ans += tree_[i];\\n        }\\n        return ans;\\n    }\\n    \\n    int idx_val(int idx) {\\n        return query(idx + 1) - query(idx);\\n    }\\nprivate:\\n    vector<int> tree_;\\n};\\n\\nclass Solution {\\npublic:\\n    int findMinimumTime(vector<vector<int>>& tasks) {\\n        sort(begin(tasks), end(tasks), [](const vector<int>& a, const vector<int>& b){\\n            if (a[1] == b[1]) return a[0] < b[0];\\n            return a[1] < b[1];\\n        }); \\n        int len = tasks.back()[1];\\n        BIT bit(len + 2);\\n        \\n        for (auto& it: tasks) {\\n            int get = bit.query(it[1] + 1) - bit.query(it[0]);\\n            if (get < it[2]) {\\n                int count = it[2] - get;\\n                for (int i = it[1]; i >= it[0] && count > 0; -- i) {\\n                    if (bit.idx_val(i) != 1) {\\n                        bit.change(i, 1);\\n                        count --;\\n                    }\\n                }\\n            }\\n        }\\n        \\n        return bit.query(len + 1);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Binary Indexed Tree"
                ],
                "code": "```\\nclass BIT{\\npublic:\\n    BIT(int sz){\\n        tree_.resize(sz);\\n    }\\n    \\n    BIT(){\\n        \\n    }\\n    \\n    void ini(int sz){\\n        tree_.resize(sz);\\n    }\\n    \\n    void change(int idx, int val){ // use idx of num\\n        for (int i = ++idx; i < tree_.size(); i += i & -i){\\n            tree_[i] += val;\\n        }\\n    }\\n    \\n    int query(int idx){ // need to add 1\\n        int ans = 0;\\n        for (int i = idx; i >= 1; i -= i & -i){\\n            ans += tree_[i];\\n        }\\n        return ans;\\n    }\\n    \\n    int idx_val(int idx) {\\n        return query(idx + 1) - query(idx);\\n    }\\nprivate:\\n    vector<int> tree_;\\n};\\n\\nclass Solution {\\npublic:\\n    int findMinimumTime(vector<vector<int>>& tasks) {\\n        sort(begin(tasks), end(tasks), [](const vector<int>& a, const vector<int>& b){\\n            if (a[1] == b[1]) return a[0] < b[0];\\n            return a[1] < b[1];\\n        }); \\n        int len = tasks.back()[1];\\n        BIT bit(len + 2);\\n        \\n        for (auto& it: tasks) {\\n            int get = bit.query(it[1] + 1) - bit.query(it[0]);\\n            if (get < it[2]) {\\n                int count = it[2] - get;\\n                for (int i = it[1]; i >= it[0] && count > 0; -- i) {\\n                    if (bit.idx_val(i) != 1) {\\n                        bit.change(i, 1);\\n                        count --;\\n                    }\\n                }\\n            }\\n        }\\n        \\n        return bit.query(len + 1);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3292140,
                "title": "let-s-do-it-as-lazy-late-as-possible",
                "content": "```cpp\\nclass Solution {\\npublic:\\n    int findMinimumTime(vector<vector<int>>& tasks) {\\n        // all the possible computer slots\\n        vector<bool> running(2001);\\n        // counter of the number of slots that should be turn on\\n        int cnt = 0;\\n\\n        // sort the tasks by their end time\\n        sort(begin(tasks), end(tasks), [](const auto &a, const auto &b) {\\n            return a[1] < b[1];\\n        });\\n\\n        for (auto& t : tasks)\\n        {\\n            int start = t[0];\\n            int end = t[1];\\n            int duration = t[2];\\n\\n            // we count how many time slot between [start, end] that are already running,\\n            // since the computer can run an unlimited number of tasks at the same time.\\n            for (int i = start; i <= end && duration > 0; ++i)\\n                if (running[i])\\n                    -- duration;\\n\\n            // if there are any duration left, we scan from `end\\' toward `start\\', \\n            // whenever we encounter an idle slot, we turn it on.\\n            for (int i = end; duration > 0; --i)\\n            {\\n                if (! running[i])\\n                {\\n                    -- duration ;\\n                    running[i] = true;\\n                    ++ cnt;\\n                }\\n            }\\n        }\\n\\n        return cnt;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Simulation"
                ],
                "code": "```cpp\\nclass Solution {\\npublic:\\n    int findMinimumTime(vector<vector<int>>& tasks) {\\n        // all the possible computer slots\\n        vector<bool> running(2001);\\n        // counter of the number of slots that should be turn on\\n        int cnt = 0;\\n\\n        // sort the tasks by their end time\\n        sort(begin(tasks), end(tasks), [](const auto &a, const auto &b) {\\n            return a[1] < b[1];\\n        });\\n\\n        for (auto& t : tasks)\\n        {\\n            int start = t[0];\\n            int end = t[1];\\n            int duration = t[2];\\n\\n            // we count how many time slot between [start, end] that are already running,\\n            // since the computer can run an unlimited number of tasks at the same time.\\n            for (int i = start; i <= end && duration > 0; ++i)\\n                if (running[i])\\n                    -- duration;\\n\\n            // if there are any duration left, we scan from `end\\' toward `start\\', \\n            // whenever we encounter an idle slot, we turn it on.\\n            for (int i = end; duration > 0; --i)\\n            {\\n                if (! running[i])\\n                {\\n                    -- duration ;\\n                    running[i] = true;\\n                    ++ cnt;\\n                }\\n            }\\n        }\\n\\n        return cnt;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3291953,
                "title": "best-solution-in-c-greedy",
                "content": "# Code\\n### PLease Upvote if u liked my Solution\\uD83E\\uDD17\\n```\\nclass Solution {\\npublic:\\n    static bool comp(vector<int>& v1,vector<int>& v2){\\n        if(v1[1]==v2[1])\\n            return v1[0] < v2[0];\\n        return v1[1]<v2[1];\\n    }\\n    int findMinimumTime(vector<vector<int>>& tasks) {\\n        sort(tasks.begin(),tasks.end(),comp);\\n        int n=tasks.size(),count=0;\\n        vector<int> vec(2001);\\n        for(int i=0;i<n;i++){\\n            int duration=tasks[i][2],start=tasks[i][0],end=tasks[i][1];\\n            for(int j=start;j<=end;j++)\\n                if(vec[j])\\n                    duration--;\\n            while(duration>0){\\n                if(!vec[end]){\\n                    vec[end]=1;\\n                    duration--;\\n                }\\n                end--;\\n            }\\n        }\\n        for(auto it:vec)\\n            if(it)\\n                count++;\\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Greedy",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    static bool comp(vector<int>& v1,vector<int>& v2){\\n        if(v1[1]==v2[1])\\n            return v1[0] < v2[0];\\n        return v1[1]<v2[1];\\n    }\\n    int findMinimumTime(vector<vector<int>>& tasks) {\\n        sort(tasks.begin(),tasks.end(),comp);\\n        int n=tasks.size(),count=0;\\n        vector<int> vec(2001);\\n        for(int i=0;i<n;i++){\\n            int duration=tasks[i][2],start=tasks[i][0],end=tasks[i][1];\\n            for(int j=start;j<=end;j++)\\n                if(vec[j])\\n                    duration--;\\n            while(duration>0){\\n                if(!vec[end]){\\n                    vec[end]=1;\\n                    duration--;\\n                }\\n                end--;\\n            }\\n        }\\n        for(auto it:vec)\\n            if(it)\\n                count++;\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3291923,
                "title": "100-beat-hashing-sorting-solution",
                "content": "# Complexity\\n- Time complexity: O(N*N)\\n\\n- Space complexity: O(N)\\n\\n# Code\\n```\\n#define f first\\n#define s second\\nclass Solution {\\npublic:\\n    int findMinimumTime(vector<vector<int>>& tasks) {\\n        vector<pair<int,pair<int,int>>>v;\\n        for(auto it:tasks){\\n            v.push_back({it[1],{it[0],it[2]}});\\n        }\\n        sort(v.begin(),v.end());\\n        int ans=0;\\n        map<int,int>used;\\n        for(int i=0; i<v.size(); i++){\\n            int cnt=0;\\n            for(int j=v[i].s.f; j<=v[i].f; j++){\\n                if(used[j]) cnt++;\\n            }\\n            int end=v[i].f;\\n            while(end>=0 && cnt<v[i].s.s){\\n                if(used[end]==0){\\n                    used[end]++;\\n                    cnt++;\\n                    ans++;\\n                }\\n                end--;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n#define f first\\n#define s second\\nclass Solution {\\npublic:\\n    int findMinimumTime(vector<vector<int>>& tasks) {\\n        vector<pair<int,pair<int,int>>>v;\\n        for(auto it:tasks){\\n            v.push_back({it[1],{it[0],it[2]}});\\n        }\\n        sort(v.begin(),v.end());\\n        int ans=0;\\n        map<int,int>used;\\n        for(int i=0; i<v.size(); i++){\\n            int cnt=0;\\n            for(int j=v[i].s.f; j<=v[i].f; j++){\\n                if(used[j]) cnt++;\\n            }\\n            int end=v[i].f;\\n            while(end>=0 && cnt<v[i].s.s){\\n                if(used[end]==0){\\n                    used[end]++;\\n                    cnt++;\\n                    ans++;\\n                }\\n                end--;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3290837,
                "title": "c-simple-code-greedy",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int findMinimumTime(vector<vector<int>>& tasks) {\\n        int cnt[2001] = {0};\\n        sort(tasks.begin(), tasks.end(), [](const vector<int> &a, const vector<int> &b){           \\n            return a[1] < b[1]; \\n        });\\n                \\n        int ans = 0;\\n        int c = 0;\\n        for (vector<int> &a : tasks) {\\n            c = 0;\\n            for (int k = a[0]; k<=a[1]; ++k) if(cnt[k] == 1) ++c;\\n\\n            c = a[2] - c;\\n            for (int k = a[1]; k>=a[0]; --k) {\\n                if(c <= 0) break;                \\n                if (cnt[k] == 0) {\\n                    ++ans;\\n                    cnt[k] = 1;\\n                    --c;\\n                }                \\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findMinimumTime(vector<vector<int>>& tasks) {\\n        int cnt[2001] = {0};\\n        sort(tasks.begin(), tasks.end(), [](const vector<int> &a, const vector<int> &b){           \\n            return a[1] < b[1]; \\n        });\\n                \\n        int ans = 0;\\n        int c = 0;\\n        for (vector<int> &a : tasks) {\\n            c = 0;\\n            for (int k = a[0]; k<=a[1]; ++k) if(cnt[k] == 1) ++c;\\n\\n            c = a[2] - c;\\n            for (int k = a[1]; k>=a[0]; --k) {\\n                if(c <= 0) break;                \\n                if (cnt[k] == 0) {\\n                    ++ans;\\n                    cnt[k] = 1;\\n                    --c;\\n                }                \\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3290052,
                "title": "simple-java-greedy-solution",
                "content": "# Complexity\\n- Time complexity:\\nO(NlogN)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\n    public int findMinimumTime(int[][] tasks) {\\n        int res = 0;\\n        boolean[] arr = new boolean[2001];\\n        Arrays.sort(tasks, (a, b) -> a[1] - b[1]);\\n        for (int[] task : tasks) {\\n            int start = task[0], end = task[1], dur = task[2];\\n            int cur = 0;\\n            for (int i = start; i <= end; i++) {\\n                if (arr[i]) {\\n                    cur++;\\n                }\\n            }\\n            if (cur < dur) {\\n                for (int i = end; i >= start && cur < dur; i--) {\\n                    if (!arr[i]) {\\n                        arr[i] = true;\\n                        res++;\\n                        cur++;\\n                    }\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\n    public int findMinimumTime(int[][] tasks) {\\n        int res = 0;\\n        boolean[] arr = new boolean[2001];\\n        Arrays.sort(tasks, (a, b) -> a[1] - b[1]);\\n        for (int[] task : tasks) {\\n            int start = task[0], end = task[1], dur = task[2];\\n            int cur = 0;\\n            for (int i = start; i <= end; i++) {\\n                if (arr[i]) {\\n                    cur++;\\n                }\\n            }\\n            if (cur < dur) {\\n                for (int i = end; i >= start && cur < dur; i--) {\\n                    if (!arr[i]) {\\n                        arr[i] = true;\\n                        res++;\\n                        cur++;\\n                    }\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3289941,
                "title": "python-another-interval-problem-simple-solution",
                "content": "# Intuition\\nSort by ending time. Take from the back time not taken previously, substract previously taken overlaps, record currently time units taken.\\n\\n\\n# Approach\\n1. Sort tasks array by the ending time\\n2. Process tasks with lowest non processed ending time.\\n3. go from back (ending time) of the task, this guarantees max overlapp, cause all intervals after have ending time bigger or equal.\\n4. before processing task, substract time units already processed before and are in range of currently processed task.\\n5. Then go from back and use non processed time units.\\n6. Amount of memorized time units is the answer.\\n\\n# Complexity\\n- Time complexity:\\nO($$NlogN  + NT$$), sorting of tasks array plus tasks array times maxtime\\n\\n- Space complexity:\\nO(max(Time))\\n\\n# Code\\n```\\nclass Solution:\\n    def findMinimumTime(self, tasks: List[List[int]]) -> int:\\n        times_used = set()\\n        for i, (s, e, cc) in enumerate(sorted(tasks,key = lambda x: x[1])):\\n            if cc > 0:\\n                for i in range(s, e + 1): cc -= int(i in times_used)\\n                i = e\\n                while cc > 0 and i >= s:                    \\n                    if i not in times_used:\\n                        times_used.add(i)\\n                        cc -= 1\\n                    i -= 1\\n        return len(times_used)\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Sort"
                ],
                "code": "```\\nclass Solution:\\n    def findMinimumTime(self, tasks: List[List[int]]) -> int:\\n        times_used = set()\\n        for i, (s, e, cc) in enumerate(sorted(tasks,key = lambda x: x[1])):\\n            if cc > 0:\\n                for i in range(s, e + 1): cc -= int(i in times_used)\\n                i = e\\n                while cc > 0 and i >= s:                    \\n                    if i not in times_used:\\n                        times_used.add(i)\\n                        cc -= 1\\n                    i -= 1\\n        return len(times_used)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3289756,
                "title": "c-code-with-explanation-beats-100-greedy-approach",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    //Sorting based on the end time\\n    static bool cmp(vector<int> &a, vector<int> &b){\\n        if(a[1] == b[1])\\n            return a[0] < b[0];\\n        return a[1] < b[1];\\n    }\\n\\n    int findMinimumTime(vector<vector<int>>& tasks) {\\n        int dp[2001] = {0}; //dp[i] = 0 i.e. computer is off and 1 means computer is on.\\n        \\n        // sort the tasks on the basis of end time\\n        sort(tasks.begin(), tasks.end(), cmp);\\n\\n        int miniTime = 0;\\n\\n        for(int i=0; i<tasks.size(); i++){\\n            int currStart = tasks[i][0];\\n            int currEnd = tasks[i][1];\\n            int duration = tasks[i][2];\\n\\n            //first we check whether time slot is using by another task or not. If yes then we reduce the duration time.\\n            for(int j= currStart; duration && j<=currEnd; j++){\\n                if(dp[j]){\\n                    duration--;\\n                }\\n            }\\n            \\n            /*IMPORTANT \\uD83D\\uDC47*/\\n            //We are going to fill dp array from the \"end\" so that it\\'s high possibly chances of overlapping the computer time\\n            for(int j=currEnd; duration && j >= 0; j--){\\n                if(dp[j] == 0){\\n                    dp[j] = 1;\\n                    duration--;\\n                }\\n            }\\n        }\\n\\n        //Traverse the entire dp. If dp[i] is 1 i.e. computer is on that particular time.\\n        for(int i=1; i<=2000; i++){\\n            if(dp[i])\\n                miniTime++;\\n        }\\n        return miniTime;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    //Sorting based on the end time\\n    static bool cmp(vector<int> &a, vector<int> &b){\\n        if(a[1] == b[1])\\n            return a[0] < b[0];\\n        return a[1] < b[1];\\n    }\\n\\n    int findMinimumTime(vector<vector<int>>& tasks) {\\n        int dp[2001] = {0}; //dp[i] = 0 i.e. computer is off and 1 means computer is on.\\n        \\n        // sort the tasks on the basis of end time\\n        sort(tasks.begin(), tasks.end(), cmp);\\n\\n        int miniTime = 0;\\n\\n        for(int i=0; i<tasks.size(); i++){\\n            int currStart = tasks[i][0];\\n            int currEnd = tasks[i][1];\\n            int duration = tasks[i][2];\\n\\n            //first we check whether time slot is using by another task or not. If yes then we reduce the duration time.\\n            for(int j= currStart; duration && j<=currEnd; j++){\\n                if(dp[j]){\\n                    duration--;\\n                }\\n            }\\n            \\n            /*IMPORTANT \\uD83D\\uDC47*/\\n            //We are going to fill dp array from the \"end\" so that it\\'s high possibly chances of overlapping the computer time\\n            for(int j=currEnd; duration && j >= 0; j--){\\n                if(dp[j] == 0){\\n                    dp[j] = 1;\\n                    duration--;\\n                }\\n            }\\n        }\\n\\n        //Traverse the entire dp. If dp[i] is 1 i.e. computer is on that particular time.\\n        for(int i=1; i<=2000; i++){\\n            if(dp[i])\\n                miniTime++;\\n        }\\n        return miniTime;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3289587,
                "title": "currently-fastest-java-solution-30-ms-easy-clean-explained",
                "content": "# Intuition\\nSort input array by endTime to be able to make fast interval merge.\\nGo through every task, checking current chosen timestamps and adding new ones.\\n\\n# Approach\\n1. Sort input array by endTime in ***ascending*** order.\\n2. Create boolean array of timestamps where you will collect all already chosen timeStamps.\\n3. Visit every single task.\\n3.1. Check if any of currently chosen timestamps fit your time gap and if yes - decrement the time needed to solve the task.\\n3.2. If any time still needed - add new timestamps starting from the endTime.\\n4. Total amount of timeStamps ***counter*** will be the answer.\\n\\n# Complexity\\n- Time complexity: $$O(n ^ 2)$$\\nWorst case 2000 tasks with timeToSolve = 2000.\\n\\n- Space complexity: $$O(n)$$\\nWorst case 2000 timeStamps.\\n\\n# Code\\n```\\nclass Solution {\\n    public int findMinimumTime(int[][] tasks) {\\n        Arrays.sort(tasks, Comparator.comparing(x -> x[1]));\\n        boolean[] timeStamps = new boolean[2001];\\n        int counter = 0;\\n        for (int[] task : tasks) {\\n            int timeToSolve = task[2];\\n            for (int i = task[0]; i <= task[1] && timeToSolve > 0; i++) {\\n                if (timeStamps[i]) {\\n                    timeToSolve--;\\n                }\\n            }\\n            int endTime = task[1];\\n            while (timeToSolve > 0 && endTime >= task[0]) {\\n                if (!timeStamps[endTime]) {\\n                    counter++;\\n                    timeStamps[endTime] = true;\\n                    timeToSolve--;\\n                }\\n                endTime--;\\n            }\\n        }\\n        return counter;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int findMinimumTime(int[][] tasks) {\\n        Arrays.sort(tasks, Comparator.comparing(x -> x[1]));\\n        boolean[] timeStamps = new boolean[2001];\\n        int counter = 0;\\n        for (int[] task : tasks) {\\n            int timeToSolve = task[2];\\n            for (int i = task[0]; i <= task[1] && timeToSolve > 0; i++) {\\n                if (timeStamps[i]) {\\n                    timeToSolve--;\\n                }\\n            }\\n            int endTime = task[1];\\n            while (timeToSolve > 0 && endTime >= task[0]) {\\n                if (!timeStamps[endTime]) {\\n                    counter++;\\n                    timeStamps[endTime] = true;\\n                    timeToSolve--;\\n                }\\n                endTime--;\\n            }\\n        }\\n        return counter;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3289522,
                "title": "greedy-with-hashset-java",
                "content": "# Intuition\\nSort the array wrt to end. We would like to complete the tasks from last second as chances of getting more overlapes would be greater\\n\\n\\n# Complexity\\n- Time complexity:\\nO(nlogn)\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\n    public int findMinimumTime(int[][] tasks) {\\n        Arrays.sort(tasks, (a, b)->a[1]-b[1]);\\n        Set<Integer> set=new HashSet<>();\\n        for(int i=0;i<tasks.length;i++){\\n            int start=tasks[i][0];\\n            int end=tasks[i][1];\\n            int dur=tasks[i][2];\\n            int j=start;\\n            while(j<=end&&dur>0){\\n                if(set.contains(j)){\\n                    dur--;\\n                }\\n                j++;\\n            }\\n            j=end;\\n            while(j>=start&&dur>0){\\n                if(!set.contains(j)){\\n                    dur--;\\n                    set.add(j);\\n                }\\n                j--;\\n            }\\n        }\\n        return set.size();\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Hash Table",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\n    public int findMinimumTime(int[][] tasks) {\\n        Arrays.sort(tasks, (a, b)->a[1]-b[1]);\\n        Set<Integer> set=new HashSet<>();\\n        for(int i=0;i<tasks.length;i++){\\n            int start=tasks[i][0];\\n            int end=tasks[i][1];\\n            int dur=tasks[i][2];\\n            int j=start;\\n            while(j<=end&&dur>0){\\n                if(set.contains(j)){\\n                    dur--;\\n                }\\n                j++;\\n            }\\n            j=end;\\n            while(j>=start&&dur>0){\\n                if(!set.contains(j)){\\n                    dur--;\\n                    set.add(j);\\n                }\\n                j--;\\n            }\\n        }\\n        return set.size();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3289121,
                "title": "100-acceptance-java-solution",
                "content": "```\\nclass Solution {\\n    public int findMinimumTime(int[][] tasks) {\\n        Arrays.sort(tasks,(a,b)->(a[1]-b[1]));\\n        boolean visited[] = new boolean[2001];\\n        int output = 0;\\n        for(int row[]:tasks){\\n            int num = 0;\\n            for(int i=row[0];i<=row[1];i++) if(visited[i]) num++;\\n            int j = row[1];\\n            while(num<row[2]){\\n                if(!visited[j]){\\n                    visited[j] = true;\\n                    num++;output++;\\n                }\\n                j--;//place true from last \\n            }\\n        }\\n        return output;\\n    }\\n}",
                "solutionTags": [
                    "Java",
                    "Greedy"
                ],
                "code": "class Solution {\\n    public int findMinimumTime(int[][] tasks) {\\n        Arrays.sort(tasks,(a,b)->(a[1]-b[1]));\\n        boolean visited[] = new boolean[2001];\\n        int output = 0;\\n        for(int row[]:tasks){\\n            int num = 0;\\n            for(int i=row[0];i<=row[1];i++) if(visited[i]) num++;\\n            int j = row[1];\\n            while(num<row[2]){\\n                if(!visited[j]){\\n                    visited[j] = true;\\n                    num++;output++;\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 3289043,
                "title": "greedy-overlapping-interval-questions-expained-clear-python-way",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThis is very similar to\\uFF1A\\n- 452 Minimum Number of Arrows to Burst Balloons https://leetcode.com/problems/minimum-number-of-arrows-to-burst-balloons/\\n- 435 Non-overlapping Intervals https://leetcode.com/problems/non-overlapping-intervals/description/\\n\\nThe general way to deal with this is to:\\n1. sort using the end time - **this way earliest finished intervals first**\\n2. from this earliest finished interval, we want to find the largest overlap with the next ones -> **go to the end point**\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. sort using end point\\n2. for each interval, see how much time has already been used in the interval -> record how much time is needed\\n3. traverse from end point to start point(ensure largest overlap first), use the left over time until they are used up\\n# Complexity\\n- Time complexity: O(n^2)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def findMinimumTime(self, tasks: List[List[int]]) -> int:\\n        # sort using end point -> we get earliest finished task first\\n        # from this point, go back n units. if time is already used, then already processed. if not, add to used set\\n        tasks=sorted(tasks, key=lambda x: x[1])\\n        used=set()\\n        for task in tasks:\\n            start, end, duration = task\\n            # see how much time I have already used in interval\\n            timeInInterval=0\\n            for time in range(start, end+1):\\n                if time in used:\\n                    timeInInterval+=1\\n            timeLeft=duration-timeInInterval\\n            # I have to use the time as late as possible to get as much overlap with the next ones as possible\\n            for time in range(end, start-1, -1):\\n                if timeLeft<=0:\\n                    break\\n                if time not in used:\\n                    used.add(time)\\n                    timeLeft-=1\\n\\n        return len(used)\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def findMinimumTime(self, tasks: List[List[int]]) -> int:\\n        # sort using end point -> we get earliest finished task first\\n        # from this point, go back n units. if time is already used, then already processed. if not, add to used set\\n        tasks=sorted(tasks, key=lambda x: x[1])\\n        used=set()\\n        for task in tasks:\\n            start, end, duration = task\\n            # see how much time I have already used in interval\\n            timeInInterval=0\\n            for time in range(start, end+1):\\n                if time in used:\\n                    timeInInterval+=1\\n            timeLeft=duration-timeInInterval\\n            # I have to use the time as late as possible to get as much overlap with the next ones as possible\\n            for time in range(end, start-1, -1):\\n                if timeLeft<=0:\\n                    break\\n                if time not in used:\\n                    used.add(time)\\n                    timeLeft-=1\\n\\n        return len(used)\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3288901,
                "title": "easy-to-understand-c-solution",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int findMinimumTime(vector<vector<int>>& tasks) {\\n        sort(tasks.begin(),tasks.end(),[](vector<int>&a,vector<int>&b){\\n            return (a[1]!=b[1])?a[1]<b[1]:a[0]<b[0];\\n        });\\n        unordered_map<int,bool>m;\\n        int count=0;\\n        for(auto task:tasks){\\n            for(int i=task[0];i<=task[1];i++){\\n                if(m.count(i))task[2]--;\\n            }\\n            \\n            for(int i=task[1];task[2]>0;i--){\\n                if(m.count(i))continue;\\n                task[2]--;\\n                m[i]=1;\\n                count++;\\n            }\\n        }\\n        return count;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findMinimumTime(vector<vector<int>>& tasks) {\\n        sort(tasks.begin(),tasks.end(),[](vector<int>&a,vector<int>&b){\\n            return (a[1]!=b[1])?a[1]<b[1]:a[0]<b[0];\\n        });\\n        unordered_map<int,bool>m;\\n        int count=0;\\n        for(auto task:tasks){\\n            for(int i=task[0];i<=task[1];i++){\\n                if(m.count(i))task[2]--;\\n            }\\n            \\n            for(int i=task[1];task[2]>0;i--){\\n                if(m.count(i))continue;\\n                task[2]--;\\n                m[i]=1;\\n                count++;\\n            }\\n        }\\n        return count;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3288591,
                "title": "python-3-hint-solution",
                "content": "```\\nclass Solution:\\n    def findMinimumTime(self, tasks: List[List[int]]) -> int:\\n\\t\\n\\t\\n        tasks.sort(key=lambda x: (x[1], -x[2], x[0]))\\n\\t\\t# time point already ran\\n        ran = set()\\n\\n        for s, e, d in tasks:\\n\\t\\t\\t# time point not covered before\\n            wait = []\\n            for t in range(s, e + 1):\\n                if t in ran:\\n                    d -= 1\\n                    if not d: break\\n                else:\\n                    wait.append(t)\\n            else:\\n\\t\\t\\t\\t# add later time points first so that later tasks could be potentially covered\\n                ran |= set(wait[-d:])\\n        \\n        return len(ran)\\n\\t```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Sorting"
                ],
                "code": "```\\nclass Solution:\\n    def findMinimumTime(self, tasks: List[List[int]]) -> int:\\n\\t\\n\\t\\n        tasks.sort(key=lambda x: (x[1], -x[2], x[0]))\\n\\t\\t# time point already ran\\n        ran = set()\\n\\n        for s, e, d in tasks:\\n\\t\\t\\t# time point not covered before\\n            wait = []\\n            for t in range(s, e + 1):\\n                if t in ran:\\n                    d -= 1\\n                    if not d: break\\n                else:\\n                    wait.append(t)\\n            else:\\n\\t\\t\\t\\t# add later time points first so that later tasks could be potentially covered\\n                ran |= set(wait[-d:])\\n        \\n        return len(ran)\\n\\t```",
                "codeTag": "Java"
            },
            {
                "id": 3288575,
                "title": "java-coolest-with-expl-tc-o-n-2-sc-o-1",
                "content": "```\\nclass Solution {\\n    public int findMinimumTime(int[][] tasks) {\\n        Arrays.sort(tasks, (a, b) -> Integer.compare(a[1], b[1]));  // Sort by Endtime\\n        boolean[] time = new boolean[2001];\\n        int ans = 0, sp = 0, ep = tasks[0][1], duration = tasks[0][2];\\n        for(int i= ep - duration + 1; i <= ep; i++){ //Do first task backwards from end point to start point, chance of most coverage for reuse\\n            time[i] = true;\\n            ans++;\\n        }\\n        for(int i=1; i<tasks.length; i++){\\n            sp = tasks[i][0];\\n            ep = tasks[i][1];\\n            duration = tasks[i][2];\\n            for(int j = sp; j <= ep; j++){  // Check if computer already on \\n                if(time[j]) duration--;\\n            }\\n            for(int k = ep; k >= sp && duration > 0; k--){  // For the duration left fill empty time from end point\\n                if(!time[k]){\\n                    time[k] = true;\\n                    ans++;\\n                    duration--;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int findMinimumTime(int[][] tasks) {\\n        Arrays.sort(tasks, (a, b) -> Integer.compare(a[1], b[1]));  // Sort by Endtime\\n        boolean[] time = new boolean[2001];\\n        int ans = 0, sp = 0, ep = tasks[0][1], duration = tasks[0][2];\\n        for(int i= ep - duration + 1; i <= ep; i++){ //Do first task backwards from end point to start point, chance of most coverage for reuse\\n            time[i] = true;\\n            ans++;\\n        }\\n        for(int i=1; i<tasks.length; i++){\\n            sp = tasks[i][0];\\n            ep = tasks[i][1];\\n            duration = tasks[i][2];\\n            for(int j = sp; j <= ep; j++){  // Check if computer already on \\n                if(time[j]) duration--;\\n            }\\n            for(int k = ep; k >= sp && duration > 0; k--){  // For the duration left fill empty time from end point\\n                if(!time[k]){\\n                    time[k] = true;\\n                    ans++;\\n                    duration--;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3288429,
                "title": "python-edf-greedy",
                "content": "# Code\\n```\\nclass Solution:\\n    def findMinimumTime(self, tasks: List[List[int]]) -> int:\\n        tasks.sort(key = lambda x: (x[1],x[0]))\\n        used = set()\\n        for s, e, d in tasks:\\n            for t in range(s, e+1):\\n                if t in used:\\n                    d -= 1\\n            for t in range(e, s-1,-1):\\n                if d > 0:\\n                    if t not in used:\\n                        used.add(t)\\n                        d -= 1\\n                else: break\\n        return len(used)\\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def findMinimumTime(self, tasks: List[List[int]]) -> int:\\n        tasks.sort(key = lambda x: (x[1],x[0]))\\n        used = set()\\n        for s, e, d in tasks:\\n            for t in range(s, e+1):\\n                if t in used:\\n                    d -= 1\\n            for t in range(e, s-1,-1):\\n                if d > 0:\\n                    if t not in used:\\n                        used.add(t)\\n                        d -= 1\\n                else: break\\n        return len(used)\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3288328,
                "title": "python-solution-using-sort",
                "content": "# Complexity\\n- Time complexity:$$O(n^2)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:$$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def findMinimumTime(self, tasks: List[List[int]]) -> int:\\n        onArr = [0]*2001\\n        tasks.sort(key=lambda x:x[1])\\n        for s,e,d in tasks:\\n            for i in range(s,e+1):\\n                d -= onArr[i]\\n                if(d == 0):\\n                    break\\n            r = e\\n            while(d > 0 and r >= 0):\\n                if(onArr[r] == 0):\\n                    d-=1\\n                    onArr[r]=1\\n                r-=1\\n\\n        return sum(onArr)\\n            \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def findMinimumTime(self, tasks: List[List[int]]) -> int:\\n        onArr = [0]*2001\\n        tasks.sort(key=lambda x:x[1])\\n        for s,e,d in tasks:\\n            for i in range(s,e+1):\\n                d -= onArr[i]\\n                if(d == 0):\\n                    break\\n            r = e\\n            while(d > 0 and r >= 0):\\n                if(onArr[r] == 0):\\n                    d-=1\\n                    onArr[r]=1\\n                r-=1\\n\\n        return sum(onArr)\\n            \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3288101,
                "title": "python-bit-solution-easy-to-understand-ezz",
                "content": "EZ CODE !!!!\\n\\n# Code\\n```\\nclass BIT():\\n    def __init__(self,n):\\n        self.n=n\\n        self.tree=[0]*(n+1)\\n    def qr(self,i):\\n        i+=1\\n        s=0\\n        while i>0:\\n            s+=self.tree[i]\\n            i-=(i&-i)\\n        return s\\n    def upd(self,vl,i):\\n        i+=1\\n        while i<=self.n:\\n            self.tree[i]+=vl\\n            i+=(i&-i)\\n\\nclass Solution:\\n    def findMinimumTime(self, tasks: List[List[int]]) -> int:\\n        global mx\\n        mx=max(tasks,key=lambda s:s[1])[1]\\n        used=[0]*(mx+1)\\n        tasks.sort(key=lambda s:s[2],reverse=True)\\n        tasks.sort(key=lambda s:s[1])\\n        bt=BIT(mx+1)\\n        res=0\\n        for l,r,vl in tasks:\\n            res=bt.qr(r)-bt.qr(l-1)\\n            if vl<=res:\\n                continue\\n            for ind in range(r,l-1,-1):\\n                if used[ind]:\\n                    continue\\n                used[ind]+=1\\n                res+=1\\n                bt.upd(1,ind)\\n                if res>=vl:\\n                    break\\n        return bt.qr(mx)\\n```",
                "solutionTags": [
                    "Python3",
                    "Binary Indexed Tree"
                ],
                "code": "```\\nclass BIT():\\n    def __init__(self,n):\\n        self.n=n\\n        self.tree=[0]*(n+1)\\n    def qr(self,i):\\n        i+=1\\n        s=0\\n        while i>0:\\n            s+=self.tree[i]\\n            i-=(i&-i)\\n        return s\\n    def upd(self,vl,i):\\n        i+=1\\n        while i<=self.n:\\n            self.tree[i]+=vl\\n            i+=(i&-i)\\n\\nclass Solution:\\n    def findMinimumTime(self, tasks: List[List[int]]) -> int:\\n        global mx\\n        mx=max(tasks,key=lambda s:s[1])[1]\\n        used=[0]*(mx+1)\\n        tasks.sort(key=lambda s:s[2],reverse=True)\\n        tasks.sort(key=lambda s:s[1])\\n        bt=BIT(mx+1)\\n        res=0\\n        for l,r,vl in tasks:\\n            res=bt.qr(r)-bt.qr(l-1)\\n            if vl<=res:\\n                continue\\n            for ind in range(r,l-1,-1):\\n                if used[ind]:\\n                    continue\\n                used[ind]+=1\\n                res+=1\\n                bt.upd(1,ind)\\n                if res>=vl:\\n                    break\\n        return bt.qr(mx)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3288086,
                "title": "c-greedy",
                "content": "# Intuition\\nsort by the task\\'s end time\\ngreedily, prefer to reuse used timepoint, then try to run each task as later as possible\\nuse a vector<bool> to maintain the used time point \\n\\n# Complexity\\n- Time complexity:\\nO(NlogN)\\n\\n- Space complexity:\\nO(N)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int findMinimumTime(vector<vector<int>>& tasks) {\\n        sort(begin(tasks), end(tasks), [](auto& a, auto& b){return a[1] < b[1];});\\n        vector<bool> used(2001, false);\\n        for (auto& t:tasks){\\n            int l = t[0], r = t[1], dur = t[2];\\n            int nonOverlapDur = dur - count(begin(used)+l, begin(used)+r+1, true);\\n            for (int i = r; i>=l && nonOverlapDur>0; i--){\\n                if (!used[i]){\\n                    used[i] = true;\\n                    nonOverlapDur--;\\n                } \\n            }\\n        }\\n        return count(begin(used), end(used), true);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findMinimumTime(vector<vector<int>>& tasks) {\\n        sort(begin(tasks), end(tasks), [](auto& a, auto& b){return a[1] < b[1];});\\n        vector<bool> used(2001, false);\\n        for (auto& t:tasks){\\n            int l = t[0], r = t[1], dur = t[2];\\n            int nonOverlapDur = dur - count(begin(used)+l, begin(used)+r+1, true);\\n            for (int i = r; i>=l && nonOverlapDur>0; i--){\\n                if (!used[i]){\\n                    used[i] = true;\\n                    nonOverlapDur--;\\n                } \\n            }\\n        }\\n        return count(begin(used), end(used), true);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3287463,
                "title": "c-commented-explanation-greedy-sorting",
                "content": "class Solution {\\npublic:\\n    \\n    bool static comp(const vector<int>&x,const vector<int>&y){\\n        return x[1] < y[1];\\n    }\\n    \\n    int findMinimumTime(vector<vector<int>>& tasks) {\\n        \\n        int n = tasks.size();\\n        \\n        // sort intervals on the ascending order of their ending times.\\n        sort(tasks.begin(),tasks.end(),comp); \\n        \\n        int ans = 0;\\n        // an array to memorize all the times which we used already.\\n        int used[2002] = {0};\\n        \\n        for(int i=0;i<n;i++){\\n            \\n            int usedTime = 0;\\n            int l = tasks[i][0];\\n            int r = tasks[i][1];\\n            int d = tasks[i][2];\\n            \\n            for(int j=l;j<=r;j++){\\n                if(used[j]) usedTime++;\\n            }\\n            // try to pick spend some time from the end of the current interval.\\n            for(int j=r;usedTime < d;j--){\\n                if(used[j]) continue;\\n                used[j] = 1;\\n                usedTime++;\\n                ans++;\\n            }\\n            \\n        }\\n        return ans;\\n    }\\n};\\n\\n/*\\n\\nnow forget about n number of intervals.\\nwe gonna focus on a single interval [l,r] , where we have our duration \\'d\\'.\\nmost intuitive way to spend times on the task will be from the beginning or from the end .\\nwhat I mean in which way we will be more beneficial , \\n\\nway1.. spend your time like this [l,l+1,l+2,l+3,....,l+d-1]\\nway2.. spend your time like this [r-d+1,r-d+2,r-d+3,.....,r]\\n\\nsee if we pick way2 , then it is definitely more helpful , why??\\nwhenever we spend some time at the end of that interval , it has a \\nhigh chance of overlapping with the starting time of other intervals.\\n    \\ne.g : intervals = [1,6] [5,9] [7,10]    \\n\\n1 2 3 4 5 6\\n      5 6 7 8 9\\n          7 8 9 10\\n    \\nwhenever we pick [4,5,6] from the first interval , \\nwe can already cover some of the durations for the next interval ,\\ni.e [5,6] and again if some more durations are needed \\nfor the interval [5,9] , we need to pick it \\nfrom the end of the interval , i.e [7,8,9] , \\nwhich is again the starting points of the interval [7,10] and so on.... \\n    \\n\\nCool, now more or less we are done with the problem , \\nbut for applying the above mentioned approach , one thing we have to do ,\\nsort the intervals on the basis of their endTime , doing this \\nwill help us to choose the correct end sequences of an interval \\nand reuse them for the immediate next interval.\\n\\n*/\\n",
                "solutionTags": [
                    "C++",
                    "Greedy",
                    "Sorting"
                ],
                "code": "class Solution {\\npublic:\\n    \\n    bool static comp(const vector<int>&x,const vector<int>&y){\\n        return x[1] < y[1];\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 3287216,
                "title": "earliest-deadline-first",
                "content": "# Intuition\\nTask with earliest deadline must be completed first. Greedily allocate computer usage based on current deadline and iterate towards 0 until the task can be completed. \\n\\nSubsequent task may benefit from computer being on from processing earlier tasks. \\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution\\n{\\npublic:\\n    int findMinimumTime(vector<vector<int>> &tasks)\\n    {\\n        vector<vector<int>> tasks2;\\n        for (auto &t : tasks)\\n            tasks2.push_back({t[1], t[0], t[2]});\\n        sort(begin(tasks2), end(tasks2));\\n        swap(tasks2, tasks);\\n\\n        vector<int> on(tasks.back()[0] + 1);\\n\\n        int n = tasks.size();\\n        for (auto i = 0; i < n; ++i)\\n        {\\n            int duration = tasks[i][2];\\n            int k = tasks[i][0];\\n            for (auto j = tasks[i][1]; duration && j <= tasks[i][0]; ++j)\\n                if (on[j])\\n                    --duration;\\n\\n            while (duration)\\n            {\\n                if (!on[k])\\n                    on[k] = 1, --duration;\\n                --k;\\n            }\\n        }\\n\\n        return accumulate(begin(on), end(on), 0);\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution\\n{\\npublic:\\n    int findMinimumTime(vector<vector<int>> &tasks)\\n    {\\n        vector<vector<int>> tasks2;\\n        for (auto &t : tasks)\\n            tasks2.push_back({t[1], t[0], t[2]});\\n        sort(begin(tasks2), end(tasks2));\\n        swap(tasks2, tasks);\\n\\n        vector<int> on(tasks.back()[0] + 1);\\n\\n        int n = tasks.size();\\n        for (auto i = 0; i < n; ++i)\\n        {\\n            int duration = tasks[i][2];\\n            int k = tasks[i][0];\\n            for (auto j = tasks[i][1]; duration && j <= tasks[i][0]; ++j)\\n                if (on[j])\\n                    --duration;\\n\\n            while (duration)\\n            {\\n                if (!on[k])\\n                    on[k] = 1, --duration;\\n                --k;\\n            }\\n        }\\n\\n        return accumulate(begin(on), end(on), 0);\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3287212,
                "title": "c",
                "content": "```\\nclass Solution {\\n    static bool cmp(vector<int>&a, vector<int>&b){\\n        if(a[1]!=b[1])\\n            return a[1]<b[1];\\n        else\\n            return a[0]>b[0];\\n    }\\npublic:\\n    int findMinimumTime(vector<vector<int>>& tasks) {\\n        sort(tasks.begin(), tasks.end(), cmp) ;\\n        vector<bool>usedTime(2001) ;\\n        int ret = 0 ;\\n        for(int i = 0; i < tasks.size(); i++)\\n        {\\n            int used = 0 ;\\n            for(int j = tasks[i][0] ; j <= tasks[i][1] ; j++)\\n            {\\n                if(usedTime[j])\\n                    used++ ;\\n            }\\n            if(used >= tasks[i][2])\\n                continue ;\\n            int remain = tasks[i][2] - used ;\\n            int p = tasks[i][1] ;\\n            ret += remain ;\\n            while(remain){\\n                if(usedTime[p] == false)\\n                    remain-- ;\\n                usedTime[p] = true ;\\n                p-- ;\\n            }\\n        }\\n        return ret ;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\n    static bool cmp(vector<int>&a, vector<int>&b){\\n        if(a[1]!=b[1])\\n            return a[1]<b[1];\\n        else\\n            return a[0]>b[0];\\n    }\\npublic:\\n    int findMinimumTime(vector<vector<int>>& tasks) {\\n        sort(tasks.begin(), tasks.end(), cmp) ;\\n        vector<bool>usedTime(2001) ;\\n        int ret = 0 ;\\n        for(int i = 0; i < tasks.size(); i++)\\n        {\\n            int used = 0 ;\\n            for(int j = tasks[i][0] ; j <= tasks[i][1] ; j++)\\n            {\\n                if(usedTime[j])\\n                    used++ ;\\n            }\\n            if(used >= tasks[i][2])\\n                continue ;\\n            int remain = tasks[i][2] - used ;\\n            int p = tasks[i][1] ;\\n            ret += remain ;\\n            while(remain){\\n                if(usedTime[p] == false)\\n                    remain-- ;\\n                usedTime[p] = true ;\\n                p-- ;\\n            }\\n        }\\n        return ret ;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3287198,
                "title": "python-solution-reference-to-greedy-and-brute-force",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(n * 2001)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def findMinimumTime(self, tasks: List[List[int]]) -> int:\\n        tasks.sort(key = lambda t:t[1])\\n        run = [False] * 2001\\n        for s, e, d in tasks:\\n            d -= sum(run[s:e+1])\\n            if d > 0:\\n                for i in range(e, s-1, -1):\\n                    #during running this task, we can also run other task\\n                    if run[i]: continue\\n                    run[i] = True\\n                    d -= 1\\n                    if d == 0:\\n                        break\\n        return sum(run)\\n\\n```",
                "solutionTags": [
                    "Python3",
                    "Greedy"
                ],
                "code": "```\\nclass Solution:\\n    def findMinimumTime(self, tasks: List[List[int]]) -> int:\\n        tasks.sort(key = lambda t:t[1])\\n        run = [False] * 2001\\n        for s, e, d in tasks:\\n            d -= sum(run[s:e+1])\\n            if d > 0:\\n                for i in range(e, s-1, -1):\\n                    #during running this task, we can also run other task\\n                    if run[i]: continue\\n                    run[i] = True\\n                    d -= 1\\n                    if d == 0:\\n                        break\\n        return sum(run)\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3287190,
                "title": "bellman-ford-longest-path",
                "content": "# Intuition\\nFor each time unit, t[i], we can have t[i] = 1 means computer on and t[i] = 0, means computer off.\\n\\nWe can also have prefix sum d[i] = t[0] + t[1] + ... + t[i].\\nSince 0 <= t[i] <= 1\\n\\n\\nWe have:\\nd[i - 1] - d[i] >= -1\\nd[i] - d[0] >= 0\\nFor each task, it requires\\nd[task[1]] - d[task[0] - 1] >= task[2]\\n\\nSuppose n = max(task[1]).\\nWe can have a (directed) graph with (n + 1) nodes (0, 1, ... n) \\nand for each d[x] - d[y] >= w we have above, we can create a directed edge from y to x with weight w.\\n\\nAlso, note the graph is connected, so we don\\'t need to add \"super source\".\\nThe original question asks min(d[n]) which is the total number of t[i] == 1, this equals the longest path 0 to n.\\n\\n# Approach\\n\\nJust use bellman-ford algorithm to calculate the longest path.\\n\\n\\n# Complexity\\n- Time complexity:\\nO(n * (n + t)) where n is the max(task[1]) and t is the number of tasks.\\nNote the graph contains (n + 1) nodes and (2 * n + t) edges. The number of rounds for update is at most n. \\n\\n- Space complexity:\\nO(n) where n is the max(task[1])\\n\\n# Code\\n```\\nclass Solution {\\n    bool update(vector<int> &d, int x, int y, int w) {\\n        // d[x] - d[y] >= w\\n        if (d[x] < d[y] + w) {\\n            d[x] = d[y] + w;\\n            return true;\\n        }\\n        return false;\\n    }\\npublic:\\n    int findMinimumTime(vector<vector<int>>& tasks) {\\n        int n = 0;\\n        for (const auto& task : tasks) {\\n            n = max(n, task[1]);\\n        }\\n        vector<int> d(n + 1);\\n        for (bool mark = true; mark;) {\\n            mark = false;\\n            for (const auto& task : tasks) {\\n                mark = update(d, task[1], task[0] - 1, task[2]) || mark;\\n            }\\n            for (int i = 1; i <= n; ++i) {\\n                // d[i] - d[i - 1] >= 0\\n                // d[i - 1] - d[i] >= -1\\n                mark = update(d, i, i - 1, 0) || mark;\\n                mark = update(d, i - 1, i, -1) || mark;\\n            }\\n        }\\n        return d[n];\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\n    bool update(vector<int> &d, int x, int y, int w) {\\n        // d[x] - d[y] >= w\\n        if (d[x] < d[y] + w) {\\n            d[x] = d[y] + w;\\n            return true;\\n        }\\n        return false;\\n    }\\npublic:\\n    int findMinimumTime(vector<vector<int>>& tasks) {\\n        int n = 0;\\n        for (const auto& task : tasks) {\\n            n = max(n, task[1]);\\n        }\\n        vector<int> d(n + 1);\\n        for (bool mark = true; mark;) {\\n            mark = false;\\n            for (const auto& task : tasks) {\\n                mark = update(d, task[1], task[0] - 1, task[2]) || mark;\\n            }\\n            for (int i = 1; i <= n; ++i) {\\n                // d[i] - d[i - 1] >= 0\\n                // d[i - 1] - d[i] >= -1\\n                mark = update(d, i, i - 1, 0) || mark;\\n                mark = update(d, i - 1, i, -1) || mark;\\n            }\\n        }\\n        return d[n];\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3287178,
                "title": "just-a-runnable-solution",
                "content": "# Code\\n```\\nimpl Solution {\\n    pub fn find_minimum_time(tasks: Vec<Vec<i32>>) -> i32 {\\n        let mut line = vec![false; 2001];\\n        let mut tasks = tasks;\\n        tasks.sort_by(|t1, t2| t1[1].cmp(&t2[1]));\\n        for t in tasks.iter() {\\n            let st = t[0] as usize;\\n            let end = t[1] as usize;\\n            let mut d = t[2];\\n            d -= line[st..end + 1].iter().filter(|&&x| x).count() as i32;\\n            let mut i = end;\\n            while d > 0 {\\n                d -= i32::from(!line[i]);\\n                line[i] = true;\\n                i -= 1;\\n            }\\n        }\\n        line.iter().filter(|&&x| x).count() as i32\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nimpl Solution {\\n    pub fn find_minimum_time(tasks: Vec<Vec<i32>>) -> i32 {\\n        let mut line = vec![false; 2001];\\n        let mut tasks = tasks;\\n        tasks.sort_by(|t1, t2| t1[1].cmp(&t2[1]));\\n        for t in tasks.iter() {\\n            let st = t[0] as usize;\\n            let end = t[1] as usize;\\n            let mut d = t[2];\\n            d -= line[st..end + 1].iter().filter(|&&x| x).count() as i32;\\n            let mut i = end;\\n            while d > 0 {\\n                d -= i32::from(!line[i]);\\n                line[i] = true;\\n                i -= 1;\\n            }\\n        }\\n        line.iter().filter(|&&x| x).count() as i32\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3287177,
                "title": "number-line",
                "content": "# Intuition\\nNumber Line \\n\\n# Approach\\nfirst we have to sort the array according to second element(tasks[1] = end), so that we include all overlapping on time in each iteration\\nnow in each iteration of tasks we are traversing from start to end and decreasing the durartion when we get 1 means it can be overlapped,\\nand next we are traversing from end to till duration becomes zero in this loop we have to mark new one which means it needs new second to complete, \\n\\nlast we have returned number of ones present in an array which indicated total seconds\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int findMinimumTime(vector<vector<int>>& tasks) {\\n        int arr[2001] = {};\\n        sort(tasks.begin(), tasks.end(), [](const vector<int>& vect1, const vector<int>& vect2){return vect1[1] < vect2[1];});\\n        int cnt = 0;\\n        for(auto t: tasks){\\n            int l = t[0], r = t[1], dur = t[2];\\n            for(int i = l;i<=r;i ++){\\n                if(arr[i] == 1){\\n                    dur --;\\n                }\\n            }\\n            for(int i = r;dur > 0;i --){\\n                if(arr[i] == 0){\\n                    dur --;\\n                    arr[i] = 1;\\n                }\\n            }\\n        }\\n        for(int i = 1;i<=2000;i ++){\\n            if(arr[i] == 1) \\n            cnt ++;\\n        }\\n        return cnt;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findMinimumTime(vector<vector<int>>& tasks) {\\n        int arr[2001] = {};\\n        sort(tasks.begin(), tasks.end(), [](const vector<int>& vect1, const vector<int>& vect2){return vect1[1] < vect2[1];});\\n        int cnt = 0;\\n        for(auto t: tasks){\\n            int l = t[0], r = t[1], dur = t[2];\\n            for(int i = l;i<=r;i ++){\\n                if(arr[i] == 1){\\n                    dur --;\\n                }\\n            }\\n            for(int i = r;dur > 0;i --){\\n                if(arr[i] == 0){\\n                    dur --;\\n                    arr[i] = 1;\\n                }\\n            }\\n        }\\n        for(int i = 1;i<=2000;i ++){\\n            if(arr[i] == 1) \\n            cnt ++;\\n        }\\n        return cnt;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3287165,
                "title": "the-same-code-was-showing-runtime-error-during-the-contest-but-now-it-is-getting-accepted",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nWe will do a task for duration d at the end of the interval [start, end]\\n\\n# Issue\\nThe same code was showing runtime error during the contest but now it is getting accepted? \\n\\n# Code\\n```\\nbool comp(vector<int>& a, vector<int>& b) {\\n    if(a[1] < b[1]) return true;\\n    else if(a[1] == b[1]) {\\n        if(a[0] < b[0]) return true;\\n        else if(a[0] == b[0]) {\\n            if(a[2] > b[2]) return true;\\n        }\\n    }\\n    \\n    return false;\\n}\\n\\nclass Solution {\\npublic:\\n    int findMinimumTime(vector<vector<int>>& tasks) {\\n        // Sorting according to end time\\n        sort(tasks.begin(), tasks.end(), comp);\\n        vector<int> d(2001, 0);\\n        \\n        int ans = 0;\\n        \\n        for(int i = 0; i < tasks.size(); i++) {\\n            int start = tasks[i][0], end = tasks[i][1];\\n            int dur = tasks[i][2];\\n            int temp = 0;\\n            for(int j = start; j <= end; j++) {\\n                if(d[j] == 1) {\\n                    temp++;\\n                }\\n            }\\n            \\n            if(temp >= dur) {\\n                continue;\\n            }\\n            else {\\n                dur -= temp;\\n            }\\n            \\n            \\n            int j = end;\\n            ans += dur;\\n            while(j >= start && dur > 0) {\\n                if(d[j] == 0){\\n                    d[j] = 1;\\n                    j--;\\n                    dur--;\\n                }\\n                else {\\n                    j--;\\n                }\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nbool comp(vector<int>& a, vector<int>& b) {\\n    if(a[1] < b[1]) return true;\\n    else if(a[1] == b[1]) {\\n        if(a[0] < b[0]) return true;\\n        else if(a[0] == b[0]) {\\n            if(a[2] > b[2]) return true;\\n        }\\n    }\\n    \\n    return false;\\n}\\n\\nclass Solution {\\npublic:\\n    int findMinimumTime(vector<vector<int>>& tasks) {\\n        // Sorting according to end time\\n        sort(tasks.begin(), tasks.end(), comp);\\n        vector<int> d(2001, 0);\\n        \\n        int ans = 0;\\n        \\n        for(int i = 0; i < tasks.size(); i++) {\\n            int start = tasks[i][0], end = tasks[i][1];\\n            int dur = tasks[i][2];\\n            int temp = 0;\\n            for(int j = start; j <= end; j++) {\\n                if(d[j] == 1) {\\n                    temp++;\\n                }\\n            }\\n            \\n            if(temp >= dur) {\\n                continue;\\n            }\\n            else {\\n                dur -= temp;\\n            }\\n            \\n            \\n            int j = end;\\n            ans += dur;\\n            while(j >= start && dur > 0) {\\n                if(d[j] == 0){\\n                    d[j] = 1;\\n                    j--;\\n                    dur--;\\n                }\\n                else {\\n                    j--;\\n                }\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3287114,
                "title": "simplest-solution-o-n-2-brute-force",
                "content": "# Intuition\\nBruet Force Approach | Implementation | Sorting\\n# Approach\\nJust sort the `tasks` array and use basic brute force approach\\n# Complexity\\n- Time complexity:\\nAdd your time complexity here, e.g. $$O(n^2)$$\\n\\n- Space complexity:\\nAdd your space complexity here, e.g. $$O(1)$$\\n\\n# Code\\n```\\nbool comp(vector<int> &v1, vector<int> &v2) {\\n    return v1[1] < v2[1];\\n}\\n\\nclass Solution {\\npublic:\\n    int findMinimumTime(vector<vector<int>>& tasks) {\\n        int i, j;\\n        int n = tasks.size();\\n        vector<bool> mark(2001, false);\\n        sort(tasks.begin(), tasks.end(), comp);\\n        for(i = 0 ; i < n ; ++i) {\\n            int end = tasks[i][1];\\n            int start = tasks[i][0];\\n            int duration = tasks[i][2];\\n            int total = 0;\\n            for(j = start ; j <= end ; ++j) {\\n                total += mark[j];\\n            }\\n            if(total < duration) {\\n                for(j = end ; j >= start && total < duration ; --j) {\\n                    if(!mark[j]) {\\n                        mark[j] = true;\\n                        total++;\\n                    }\\n                }\\n            }\\n        }\\n        int result = 0;\\n        for(i = 0 ; i < 2001 ; ++i) {\\n            result += mark[i];\\n        }\\n        return result;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nbool comp(vector<int> &v1, vector<int> &v2) {\\n    return v1[1] < v2[1];\\n}\\n\\nclass Solution {\\npublic:\\n    int findMinimumTime(vector<vector<int>>& tasks) {\\n        int i, j;\\n        int n = tasks.size();\\n        vector<bool> mark(2001, false);\\n        sort(tasks.begin(), tasks.end(), comp);\\n        for(i = 0 ; i < n ; ++i) {\\n            int end = tasks[i][1];\\n            int start = tasks[i][0];\\n            int duration = tasks[i][2];\\n            int total = 0;\\n            for(j = start ; j <= end ; ++j) {\\n                total += mark[j];\\n            }\\n            if(total < duration) {\\n                for(j = end ; j >= start && total < duration ; --j) {\\n                    if(!mark[j]) {\\n                        mark[j] = true;\\n                        total++;\\n                    }\\n                }\\n            }\\n        }\\n        int result = 0;\\n        for(i = 0 ; i < 2001 ; ++i) {\\n            result += mark[i];\\n        }\\n        return result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3287066,
                "title": "easy-short-efficient-clean-code",
                "content": "```\\nclass Solution {\\npublic:\\n    int findMinimumTime(vector<vector<int>>&v) {\\n        int sz=v.size();\\n        sort(begin(v), end(v), [](const vector<int>&a, const vector<int>&b){return a[1]<b[1];});\\n        bitset<2001>time(0);\\n        for(const auto&task:v){\\n            int start=task[0], end=task[1], req=task[2];\\n            for(int i=start;i<=end && req>0;++i){\\n                req-=time[i];\\n            }\\n            for(int i=end;req>0;--i){\\n                if(!time[i]){\\n                    time[i]=1, --req;\\n                }\\n            }\\n        }\\n        return time.count();\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Greedy",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findMinimumTime(vector<vector<int>>&v) {\\n        int sz=v.size();\\n        sort(begin(v), end(v), [](const vector<int>&a, const vector<int>&b){return a[1]<b[1];});\\n        bitset<2001>time(0);\\n        for(const auto&task:v){\\n            int start=task[0], end=task[1], req=task[2];\\n            for(int i=start;i<=end && req>0;++i){\\n                req-=time[i];\\n            }\\n            for(int i=end;req>0;--i){\\n                if(!time[i]){\\n                    time[i]=1, --req;\\n                }\\n            }\\n        }\\n        return time.count();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3287065,
                "title": "python-easy-solution-100-faster-greedy-sorting",
                "content": "![image](https://assets.leetcode.com/users/images/b0371d2d-e6ba-47b7-aa15-a17ab2d37732_1678601793.5663605.png)\\n```\\nclass Solution:\\n    def findMinimumTime(self, tasks: List[List[int]]) -> int:\\n        tasks.sort(key = lambda x: x[1])\\n        check = [0]*2001\\n\\n        for s,e,d in tasks:\\n            for i in range(s,e+1):\\n                if check[i]:\\n                    d-=1\\n                if d==0:\\n                    break\\n                 \\n            for i in range(e,s-1,-1):\\n                if d==0:\\n                    break\\n                if check[i]==0:\\n                    check[i] = 1\\n                    d-=1   \\n                    \\n        return check.count(1)   \\n\\n",
                "solutionTags": [
                    "Python3",
                    "Greedy",
                    "Sorting"
                ],
                "code": "![image](https://assets.leetcode.com/users/images/b0371d2d-e6ba-47b7-aa15-a17ab2d37732_1678601793.5663605.png)\\n```\\nclass Solution:\\n    def findMinimumTime(self, tasks: List[List[int]]) -> int:\\n        tasks.sort(key = lambda x: x[1])\\n        check = [0]*2001\\n\\n        for s,e,d in tasks:\\n            for i in range(s,e+1):\\n                if check[i]:\\n                    d-=1\\n                if d==0:\\n                    break\\n                 \\n            for i in range(e,s-1,-1):\\n                if d==0:\\n                    break\\n                if check[i]==0:\\n                    check[i] = 1\\n                    d-=1   \\n                    \\n        return check.count(1)   \\n\\n",
                "codeTag": "Java"
            },
            {
                "id": 3287025,
                "title": "h-e-l-p-with-segment-tree",
                "content": "950 / 1059 passed\\n```\\nclass Solution {\\npublic:\\nclass segTree{\\npublic:\\n    vector<int>tree;\\n    segTree(){ tree.resize(4*2001); }\\n    int get(int nd, int l, int r, const int&i, const int&j){\\n        if(l>r || r<i || l>j){\\n            return 0;\\n        }\\n        if(l>=i && r<=j){\\n            return tree[nd];\\n        }\\n        int m=l+((r-l)>>1);\\n        return get(nd*2+1, l, m, i, j)+get(nd*2+2, m+1, r, i, j);\\n    }\\n    void set(int nd, int l, int r, const int&i, const int&j, int&rem){\\n        if(l>r || r<i || l>j || rem<1){\\n            return;\\n        }\\n        if(l>=i && r<=j){\\n            int free=r-l+1-tree[nd];\\n            if(rem<=free){\\n                tree[nd]+=rem;\\n                rem=0;\\n            }\\n            else{\\n                tree[nd]=r-l+1;\\n                rem-=free;\\n            }\\n            return;\\n        }\\n        int m=l+((r-l)>>1);\\n        set(nd*2+2, m+1, r, i, j, rem), set(nd*2+1, l, m, i, j, rem);\\n        tree[nd]=tree[nd*2+1]+tree[nd*2+2];\\n    }\\n};\\n\\nint findMinimumTime(vector<vector<int>>&v) {\\n    segTree st;\\n    sort(begin(v), end(v), [](const vector<int>&a, const vector<int>&b){return a[1]<b[1];});\\n    for(auto task:v){\\n        task[2]=max(0, task[2]-st.get(0, 0, 2000, task[0], task[1]));\\n        st.set(0, 0, 2000, task[0], task[1], task[2]);\\n    }\\n    return st.get(0, 0, 2000, 1, 2000);\\n}\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\nclass segTree{\\npublic:\\n    vector<int>tree;\\n    segTree(){ tree.resize(4*2001); }\\n    int get(int nd, int l, int r, const int&i, const int&j){\\n        if(l>r || r<i || l>j){\\n            return 0;\\n        }\\n        if(l>=i && r<=j){\\n            return tree[nd];\\n        }\\n        int m=l+((r-l)>>1);\\n        return get(nd*2+1, l, m, i, j)+get(nd*2+2, m+1, r, i, j);\\n    }\\n    void set(int nd, int l, int r, const int&i, const int&j, int&rem){\\n        if(l>r || r<i || l>j || rem<1){\\n            return;\\n        }\\n        if(l>=i && r<=j){\\n            int free=r-l+1-tree[nd];\\n            if(rem<=free){\\n                tree[nd]+=rem;\\n                rem=0;\\n            }\\n            else{\\n                tree[nd]=r-l+1;\\n                rem-=free;\\n            }\\n            return;\\n        }\\n        int m=l+((r-l)>>1);\\n        set(nd*2+2, m+1, r, i, j, rem), set(nd*2+1, l, m, i, j, rem);\\n        tree[nd]=tree[nd*2+1]+tree[nd*2+2];\\n    }\\n};\\n\\nint findMinimumTime(vector<vector<int>>&v) {\\n    segTree st;\\n    sort(begin(v), end(v), [](const vector<int>&a, const vector<int>&b){return a[1]<b[1];});\\n    for(auto task:v){\\n        task[2]=max(0, task[2]-st.get(0, 0, 2000, task[0], task[1]));\\n        st.set(0, 0, 2000, task[0], task[1], task[2]);\\n    }\\n    return st.get(0, 0, 2000, 1, 2000);\\n}\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3287024,
                "title": "c-greedy-approach-explained-with-diagram",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\nSort the array with increasing order of ending time.\\nIf they match, sort then in increasing order of starting time.\\n\\nIt\\'s best for a work to be done as late as possible so that it can be overlapped maximally with the future works. We need to maximize the overlapping!.\\n\\nSee the below diagram to get an idea of how the algo will work\\n\\nThe Red data shows the duration\\nThe Blue shows the range of time of each work\\nThe White shows the optimal time the computer to be on\\n\\n![image.png](https://assets.leetcode.com/users/images/2f17efff-f862-44eb-8d35-85a365bc2304_1678600959.263784.png)\\n\\nWe Can store the white times in a set.\\nFor each work, first we will see how much of it has been done, that means how much of it intersects/overlaps with the previously done work.\\nThen we will perform the left work starting from the rightmost time, As I said, as late as possible!\\n\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int findMinimumTime(vector<vector<int>>& tasks) {\\n        \\n        //Step 1: Sort it in inc. end time order, if matches, then inc. start time\\n        sort(tasks.begin(),tasks.end(),[](vector<int>a,vector<int>b)\\n        { return (a[1]!=b[1]) ? a[1]<b[1] : a[0]<b[0];});\\n\\n        unordered_set<int> st; // will store the seconds on which the computer was on\\n\\n        //Step 2: For Each task do the Greedy Approach\\n        for(auto task :tasks){\\n            int alreadyDone = 0;\\n            // check how much already done while overlapping with previous\\n            for(int i=task[0];i<=task[1];i++) if(st.find(i)!=st.end()) alreadyDone++;\\n\\n            // now lets do the left work as late as possible so as to maximize overlapping\\n            for(int i=task[1];alreadyDone<task[2];i--){\\n                if(st.find(i)==st.end()){\\n                    st.insert(i);\\n                    alreadyDone++;\\n                }\\n            } \\n        }\\n\\n        return st.size();\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findMinimumTime(vector<vector<int>>& tasks) {\\n        \\n        //Step 1: Sort it in inc. end time order, if matches, then inc. start time\\n        sort(tasks.begin(),tasks.end(),[](vector<int>a,vector<int>b)\\n        { return (a[1]!=b[1]) ? a[1]<b[1] : a[0]<b[0];});\\n\\n        unordered_set<int> st; // will store the seconds on which the computer was on\\n\\n        //Step 2: For Each task do the Greedy Approach\\n        for(auto task :tasks){\\n            int alreadyDone = 0;\\n            // check how much already done while overlapping with previous\\n            for(int i=task[0];i<=task[1];i++) if(st.find(i)!=st.end()) alreadyDone++;\\n\\n            // now lets do the left work as late as possible so as to maximize overlapping\\n            for(int i=task[1];alreadyDone<task[2];i--){\\n                if(st.find(i)==st.end()){\\n                    st.insert(i);\\n                    alreadyDone++;\\n                }\\n            } \\n        }\\n\\n        return st.size();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3286886,
                "title": "tiktok-oa-javascript-sort-by-end-and-pick-up-from-end",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nSimilar to https://leetcode.com/problems/non-overlapping-intervals/description/\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nSort by end and keep picking up from end as it\\'s the best choice to have max overlap (by this others will reuse it) with following slots\\n\\n# Complexity\\n- Time complexity: $$O(NLogN)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {number[][]} tasks\\n * @return {number}\\n */\\nvar findMinimumTime = function(tasks) {\\n    const maxTimeSlot = tasks.map(el => el[1]+1)\\n    const timeSlots = new Array(Math.max(...maxTimeSlot)).fill(false)\\n    tasks.sort((a,b) => a[1] - b[1])\\n\\n    for(const task of tasks) {\\n        let [start, end, duration] = task\\n\\n        for(let i = start; i <= end; i++) {\\n            duration -= Number(timeSlots[i])\\n        }\\n\\n        let time = end\\n\\n        while(duration > 0) {\\n            if(!timeSlots[time]) {\\n                timeSlots[time] = true\\n                duration--\\n            }\\n            time--\\n        }\\n    }\\n    return timeSlots.reduce((a,b) => a + Number(b), 0)\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[][]} tasks\\n * @return {number}\\n */\\nvar findMinimumTime = function(tasks) {\\n    const maxTimeSlot = tasks.map(el => el[1]+1)\\n    const timeSlots = new Array(Math.max(...maxTimeSlot)).fill(false)\\n    tasks.sort((a,b) => a[1] - b[1])\\n\\n    for(const task of tasks) {\\n        let [start, end, duration] = task\\n\\n        for(let i = start; i <= end; i++) {\\n            duration -= Number(timeSlots[i])\\n        }\\n\\n        let time = end\\n\\n        while(duration > 0) {\\n            if(!timeSlots[time]) {\\n                timeSlots[time] = true\\n                duration--\\n            }\\n            time--\\n        }\\n    }\\n    return timeSlots.reduce((a,b) => a + Number(b), 0)\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3286775,
                "title": "javascript-greedy-fenwick-bit-segmenttreersq-3-solutions",
                "content": "solution 1: greedy + sort 178ms\\n```\\nconst findMinimumTime = (a) => {\\n    let on = Array(2005).fill(false), res = 0;\\n    a.sort((x, y) => x[1] - y[1]);\\n    for (const [l, r, t] of a) {\\n        let cur = 0;\\n        for (let i = l; i <= r; i++) cur += on[i];\\n        let curT = Math.max(0, t - cur);\\n        for (let i = r; i >= l; i--) {\\n            if (!on[i] && curT > 0) {\\n                on[i] = true;\\n                curT--;\\n                res++;\\n            }\\n        }\\n    }\\n    return res;\\n};\\n```\\nsolution 2: 263ms Fenwick/BIT\\n```\\nfunction Fenwick(n) {\\n    let a = Array(n).fill(0);\\n    return { query, update, rangeSum, tree }\\n    function query(i) {\\n        let sum = 0;\\n        for (i++; i > 0; i = parent(i)) sum += a[i];\\n        return sum;\\n    }\\n    function update(i, v) {\\n        for (i++; i < n; i = next(i)) a[i] += v;\\n    }\\n    function rangeSum(l, r) {\\n        return query(r) - query(l - 1);\\n    }\\n    function parent(x) {\\n        return x - lowestOneBit(x);\\n    }\\n    function next(x) {\\n        return x + lowestOneBit(x);\\n    }\\n    function lowestOneBit(x) {\\n        return x & -x;\\n    }\\n    function tree() {\\n        return a;\\n    }\\n}\\n\\nconst findMinimumTime = (a) => {\\n    let fen = new Fenwick(2005);\\n    a.sort((x, y) => x[1] - y[1]);\\n    for (const [l, r, t] of a) {\\n        let curT = t;\\n        curT -= fen.rangeSum(l, r);\\n        for (let i = r; curT > 0; i--) {\\n            if (fen.rangeSum(0, i) == fen.rangeSum(0, i - 1)) {\\n                fen.update(i, 1);\\n                curT--;\\n            }\\n        }\\n    }\\n    return fen.rangeSum(0, 2000);\\n};\\n```\\n\\nsolution 3: 468ms SegmentTreeRSQ, an replacement for Fenwick\\ntranslate:\\nfen.update(i, 1) -> st.update(i, ++f[i])\\n\\nprerequisite:\\nhttps://leetcode.com/problems/range-sum-query-mutable/\\nmy solution:\\nhttps://leetcode.com/problems/range-sum-query-mutable/solutions/3066254/javascript-segmenttreersq-604ms-96-91/\\n```\\nfunction SegmentTreeRSQ(n) {\\n    let h = Math.ceil(Math.log2(n)), len = 2 * 2 ** h, a = Array(len).fill(0);\\n    return { update, query, rangeSum, tree }\\n    function update(pos, v) {\\n        a[n + pos] = v;\\n        for (let i = parent(n + pos); i >= 1; i = parent(i)) pushup(i);\\n    }\\n    function pushup(i) {\\n        a[i] = a[left(i)] + a[right(i)];\\n    }\\n    function query(l, r) { // [L, R)\\n        let sum = 0;\\n        if (l >= r) return 0;\\n        l += n;\\n        r += n;\\n        for (; l < r; l = parent(l), r = parent(r)) {\\n            if (l & 1) sum += a[l++];\\n            if (r & 1) sum += a[--r];\\n        }\\n        return sum;\\n    }\\n    function rangeSum(l, r) {\\n        return query(0, r + 1) - query(0, l);\\n    }\\n    function parent(i) {\\n        return i >> 1;\\n    }\\n    function left(i) {\\n        return 2 * i;\\n    }\\n    function right(i) {\\n        return 2 * i + 1;\\n    }\\n    function tree() {\\n        return a;\\n    }\\n}\\n\\nconst findMinimumTime = (a) => {\\n    let st = new SegmentTreeRSQ(2005), f = Array(2005).fill(0);\\n    a.sort((x, y) => x[1] - y[1]);\\n    for (const [l, r, t] of a) {\\n        let curT = t;\\n        curT -= st.rangeSum(l, r);\\n        for (let i = r; curT > 0; i--) {\\n            if (st.rangeSum(0, i) == st.rangeSum(0, i - 1)) {\\n                st.update(i, ++f[i]);\\n                curT--;\\n            }\\n        }\\n    }\\n    return st.rangeSum(0, 2000);\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Greedy",
                    "Sort",
                    "Binary Indexed Tree",
                    "Segment Tree"
                ],
                "code": "```\\nconst findMinimumTime = (a) => {\\n    let on = Array(2005).fill(false), res = 0;\\n    a.sort((x, y) => x[1] - y[1]);\\n    for (const [l, r, t] of a) {\\n        let cur = 0;\\n        for (let i = l; i <= r; i++) cur += on[i];\\n        let curT = Math.max(0, t - cur);\\n        for (let i = r; i >= l; i--) {\\n            if (!on[i] && curT > 0) {\\n                on[i] = true;\\n                curT--;\\n                res++;\\n            }\\n        }\\n    }\\n    return res;\\n};\\n```\n```\\nfunction Fenwick(n) {\\n    let a = Array(n).fill(0);\\n    return { query, update, rangeSum, tree }\\n    function query(i) {\\n        let sum = 0;\\n        for (i++; i > 0; i = parent(i)) sum += a[i];\\n        return sum;\\n    }\\n    function update(i, v) {\\n        for (i++; i < n; i = next(i)) a[i] += v;\\n    }\\n    function rangeSum(l, r) {\\n        return query(r) - query(l - 1);\\n    }\\n    function parent(x) {\\n        return x - lowestOneBit(x);\\n    }\\n    function next(x) {\\n        return x + lowestOneBit(x);\\n    }\\n    function lowestOneBit(x) {\\n        return x & -x;\\n    }\\n    function tree() {\\n        return a;\\n    }\\n}\\n\\nconst findMinimumTime = (a) => {\\n    let fen = new Fenwick(2005);\\n    a.sort((x, y) => x[1] - y[1]);\\n    for (const [l, r, t] of a) {\\n        let curT = t;\\n        curT -= fen.rangeSum(l, r);\\n        for (let i = r; curT > 0; i--) {\\n            if (fen.rangeSum(0, i) == fen.rangeSum(0, i - 1)) {\\n                fen.update(i, 1);\\n                curT--;\\n            }\\n        }\\n    }\\n    return fen.rangeSum(0, 2000);\\n};\\n```\n```\\nfunction SegmentTreeRSQ(n) {\\n    let h = Math.ceil(Math.log2(n)), len = 2 * 2 ** h, a = Array(len).fill(0);\\n    return { update, query, rangeSum, tree }\\n    function update(pos, v) {\\n        a[n + pos] = v;\\n        for (let i = parent(n + pos); i >= 1; i = parent(i)) pushup(i);\\n    }\\n    function pushup(i) {\\n        a[i] = a[left(i)] + a[right(i)];\\n    }\\n    function query(l, r) { // [L, R)\\n        let sum = 0;\\n        if (l >= r) return 0;\\n        l += n;\\n        r += n;\\n        for (; l < r; l = parent(l), r = parent(r)) {\\n            if (l & 1) sum += a[l++];\\n            if (r & 1) sum += a[--r];\\n        }\\n        return sum;\\n    }\\n    function rangeSum(l, r) {\\n        return query(0, r + 1) - query(0, l);\\n    }\\n    function parent(i) {\\n        return i >> 1;\\n    }\\n    function left(i) {\\n        return 2 * i;\\n    }\\n    function right(i) {\\n        return 2 * i + 1;\\n    }\\n    function tree() {\\n        return a;\\n    }\\n}\\n\\nconst findMinimumTime = (a) => {\\n    let st = new SegmentTreeRSQ(2005), f = Array(2005).fill(0);\\n    a.sort((x, y) => x[1] - y[1]);\\n    for (const [l, r, t] of a) {\\n        let curT = t;\\n        curT -= st.rangeSum(l, r);\\n        for (let i = r; curT > 0; i--) {\\n            if (st.rangeSum(0, i) == st.rangeSum(0, i - 1)) {\\n                st.update(i, ++f[i]);\\n                curT--;\\n            }\\n        }\\n    }\\n    return st.rangeSum(0, 2000);\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3286735,
                "title": "python3-greedy-short",
                "content": "Intuition:\\nIn every task that sorted by the end time, if we take the time slots as late as possible, it should have higher chance to overlap with later tasks.\\n\\ncode:\\n```\\nclass Solution:\\n    def findMinimumTime(self, tasks: List[List[int]]) -> int:\\n        visited = [False] * 2001\\n        for a, b, d in sorted(tasks, key=lambda x: x[1]):\\n            d -= sum(map(lambda x: visited[x], range(a, b + 1)))\\n            for i in range(b, a - 1, -1):\\n                if d <= 0:\\n                    break\\n                d -= not visited[i]\\n                visited[i] = True\\n        return sum(visited)\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def findMinimumTime(self, tasks: List[List[int]]) -> int:\\n        visited = [False] * 2001\\n        for a, b, d in sorted(tasks, key=lambda x: x[1]):\\n            d -= sum(map(lambda x: visited[x], range(a, b + 1)))\\n            for i in range(b, a - 1, -1):\\n                if d <= 0:\\n                    break\\n                d -= not visited[i]\\n                visited[i] = True\\n        return sum(visited)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3286710,
                "title": "greedy-sorting-by-task-end-time",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n* First we sort with the first task earliest end time.\\n* Then we can do this greedily to always set the task in the end, because then we have the most overlap with the possible future tasks. Remember, they will always end after this task.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n* First, sort the tasks.\\n* Then take each, with ones ending earliest first\\n* For each task, first check if there are overlaps, and don\\'t run it for those times.\\n* And then switch the computer on for the remaining, starting with the end time.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(t) * O(h), where t is a number of tasks and h is a number of hours\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(h)\\n# Code\\n```\\nclass Solution {\\n    public int findMinimumTime(int[][] tasks) {\\n        boolean[] running = new boolean[2001];\\n        int result = 0;\\n        Arrays.sort(tasks, (a, b) -> a[1] - b[1]);\\n        for (int[] task : tasks) {\\n            int duration = task[2];\\n            for (int time = task[0]; time <= task[1]; time++) {\\n                if (running[time]) {\\n                    duration--;\\n                    if (duration == 0) {\\n                        break;\\n                    }\\n                }\\n            }\\n            int cur = task[1];\\n            while (duration > 0) {\\n                if (!running[cur]) {\\n                    running[cur] = true;\\n                    duration--;\\n                    result++;\\n                }\\n                cur--;\\n            }\\n        }\\n        return result;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int findMinimumTime(int[][] tasks) {\\n        boolean[] running = new boolean[2001];\\n        int result = 0;\\n        Arrays.sort(tasks, (a, b) -> a[1] - b[1]);\\n        for (int[] task : tasks) {\\n            int duration = task[2];\\n            for (int time = task[0]; time <= task[1]; time++) {\\n                if (running[time]) {\\n                    duration--;\\n                    if (duration == 0) {\\n                        break;\\n                    }\\n                }\\n            }\\n            int cur = task[1];\\n            while (duration > 0) {\\n                if (!running[cur]) {\\n                    running[cur] = true;\\n                    duration--;\\n                    result++;\\n                }\\n                cur--;\\n            }\\n        }\\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3286704,
                "title": "greedy-with-event-pattern",
                "content": "# Intuition\\nFor each interval, create two timestamped `Event`s, one for the beginning and the other the end. Sort these events by their timestamps. \\n\\nWhile running through the events in order, keep all unclosed events in a `std::map`. Every time we see an ending event, we know its remaining number of tasks need to finish. Hence take as many tasks as possible from the existing unclosed events with them. \\n\\nWe need to update each unclosed event so that the tasks taken away from them are in the very beginning of their intervals. \\n \\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    static constexpr bool kDebug = false;\\n    \\n    enum EventType : int {\\n        INIT = 0, DONE  \\n    };\\n\\n    struct Event {\\n        int idx;\\n        int time;\\n        EventType kind;\\n        int volume;\\n        \\n        bool operator<(const Event &rhs) const {\\n            if (time != rhs.time) {\\n                return time < rhs.time;\\n            }\\n            if (kind != rhs.kind) {\\n                return kind == EventType::INIT;\\n            }\\n            return volume > rhs.volume;\\n        }\\n    };\\n    \\n    struct Record {\\n        int init_time;\\n        int volume_request;\\n    };\\n    \\npublic:\\n    int findMinimumTime(vector<vector<int>>& tasks) {\\n        std::vector<Event> events_ord;\\n        events_ord.reserve(tasks.size() * 2);\\n        for (int idx = 0; idx < tasks.size(); ++idx) {\\n            const auto &task = tasks[idx];\\n            events_ord.push_back(Event{\\n                .idx = idx, .time = task[EventType::INIT], .kind = EventType::INIT, .volume = task.back()\\n            });\\n            events_ord.push_back(Event{\\n                .idx = idx, .time = task[EventType::DONE], .kind = EventType::DONE, .volume = task.back()\\n            });\\n        }\\n        std::sort(events_ord.begin(), events_ord.end());\\n        \\n        std::unordered_map<int, Record> idx_to_record;        \\n        int total = 0;\\n        for (auto &&event : events_ord) {\\n            if (event.kind == EventType::INIT) {\\n                idx_to_record[event.idx] = Record {\\n                    .init_time = event.time, .volume_request = event.volume\\n                };\\n                continue;\\n            }\\n            auto it = idx_to_record.find(event.idx);     \\n            const auto event_record = it->second;\\n            const int remaining_volume = event_record.volume_request;  \\n            if (remaining_volume > 0) {\\n                for (auto &[_, record] : idx_to_record) {\\n                    const int curr_vol_limit = std::min(\\n                        record.volume_request, \\n                        event.time - std::max(record.init_time, event_record.init_time) + 1\\n                    );\\n                    const int delta_vol = std::min(curr_vol_limit, remaining_volume);\\n                    // Push all the changed volumes to the beginning of the interval.\\n                    record.init_time += delta_vol;\\n                    record.volume_request -= delta_vol;\\n                }\\n                total += remaining_volume;\\n            }            \\n            idx_to_record.erase(it);            \\n        }\\n        return total;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\n    static constexpr bool kDebug = false;\\n    \\n    enum EventType : int {\\n        INIT = 0, DONE  \\n    };\\n\\n    struct Event {\\n        int idx;\\n        int time;\\n        EventType kind;\\n        int volume;\\n        \\n        bool operator<(const Event &rhs) const {\\n            if (time != rhs.time) {\\n                return time < rhs.time;\\n            }\\n            if (kind != rhs.kind) {\\n                return kind == EventType::INIT;\\n            }\\n            return volume > rhs.volume;\\n        }\\n    };\\n    \\n    struct Record {\\n        int init_time;\\n        int volume_request;\\n    };\\n    \\npublic:\\n    int findMinimumTime(vector<vector<int>>& tasks) {\\n        std::vector<Event> events_ord;\\n        events_ord.reserve(tasks.size() * 2);\\n        for (int idx = 0; idx < tasks.size(); ++idx) {\\n            const auto &task = tasks[idx];\\n            events_ord.push_back(Event{\\n                .idx = idx, .time = task[EventType::INIT], .kind = EventType::INIT, .volume = task.back()\\n            });\\n            events_ord.push_back(Event{\\n                .idx = idx, .time = task[EventType::DONE], .kind = EventType::DONE, .volume = task.back()\\n            });\\n        }\\n        std::sort(events_ord.begin(), events_ord.end());\\n        \\n        std::unordered_map<int, Record> idx_to_record;        \\n        int total = 0;\\n        for (auto &&event : events_ord) {\\n            if (event.kind == EventType::INIT) {\\n                idx_to_record[event.idx] = Record {\\n                    .init_time = event.time, .volume_request = event.volume\\n                };\\n                continue;\\n            }\\n            auto it = idx_to_record.find(event.idx);     \\n            const auto event_record = it->second;\\n            const int remaining_volume = event_record.volume_request;  \\n            if (remaining_volume > 0) {\\n                for (auto &[_, record] : idx_to_record) {\\n                    const int curr_vol_limit = std::min(\\n                        record.volume_request, \\n                        event.time - std::max(record.init_time, event_record.init_time) + 1\\n                    );\\n                    const int delta_vol = std::min(curr_vol_limit, remaining_volume);\\n                    // Push all the changed volumes to the beginning of the interval.\\n                    record.init_time += delta_vol;\\n                    record.volume_request -= delta_vol;\\n                }\\n                total += remaining_volume;\\n            }            \\n            idx_to_record.erase(it);            \\n        }\\n        return total;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3286697,
                "title": "c-greedy-sorting",
                "content": "First we will sort the array based upon the ending time of an interval in ascending order and then we will give the required amount of time to it and will decrease the current required time from each overlapping intervals\\nBut one thing to make sure here is that we won\\'t decrease the time required for an interval twice from a same subinterval, see example below \\nExample - intervals are [8,10,2], [1,12,4], [10,16,3], [10,20,5] \\n-first we will assign two seconds to first process and add it to our answer and subtract the same time from each process where possible.\\n-Now we will assign two more seconds to second process 2 and while we will be subtracting these two seconds from below processess look at the the last one which is from 10 to 20 yoy may think of subtracting two seocnds from it but it is not possible to subtract 2 seconds as we have already keep our cpu on for 10,11 and now we have left 12 as overlapping interval so we need to open our cpu for two seconds at 12 and 9 and only 12 overlaps with last process so for last process still we need to process it for 2 seconds hence ans will be 6 in total .\\nPlease dry run it with given testcase for better understanding.\\n```\\nclass Solution {\\npublic:\\n    static bool comp(vector<int>&a, vector<int>&b){\\n        if(a[1]!=b[1])\\n        return a[1]<b[1];\\n        \\n        return a[0]>b[0];\\n    }\\n    int findMinimumTime(vector<vector<int>>& tasks) {\\n        int ans=0;\\n        int n=tasks.size();\\n        vector<int> req(n,0),cng(n,0);\\n        sort(tasks.begin(),tasks.end(),comp); // Sort the vector based upon ascending order of ending time of interval\\n        for(int i=0;i<n;i++){\\n            req[i]=tasks[i][2];\\n        }\\n        \\n        for(int i=0;i<n;i++){\\n            if(req[i]>0){  // if current task has not yet been completed then work upon it and\\n                ans+=req[i]; // also subtract that time from all possible work where we can work simultaneously\\n                for(int j=0;j<n;j++){\\n                    if(tasks[j][0]<=tasks[i][1] && i!=j){\\n                        int a=req[i];\\n                        int b=tasks[i][1]-tasks[j][0]+1-cng[j];\\n                        req[j]-=min(a,b);\\n                        cng[j]+=min(a,b); // It will make sure that the same interval doesn\\'t count twice.(see explanation)\\n                        if(req[j]<0) req[j]=0;\\n                    }\\n                }\\n                req[i]=0;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Greedy",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    static bool comp(vector<int>&a, vector<int>&b){\\n        if(a[1]!=b[1])\\n        return a[1]<b[1];\\n        \\n        return a[0]>b[0];\\n    }\\n    int findMinimumTime(vector<vector<int>>& tasks) {\\n        int ans=0;\\n        int n=tasks.size();\\n        vector<int> req(n,0),cng(n,0);\\n        sort(tasks.begin(),tasks.end(),comp); // Sort the vector based upon ascending order of ending time of interval\\n        for(int i=0;i<n;i++){\\n            req[i]=tasks[i][2];\\n        }\\n        \\n        for(int i=0;i<n;i++){\\n            if(req[i]>0){  // if current task has not yet been completed then work upon it and\\n                ans+=req[i]; // also subtract that time from all possible work where we can work simultaneously\\n                for(int j=0;j<n;j++){\\n                    if(tasks[j][0]<=tasks[i][1] && i!=j){\\n                        int a=req[i];\\n                        int b=tasks[i][1]-tasks[j][0]+1-cng[j];\\n                        req[j]-=min(a,b);\\n                        cng[j]+=min(a,b); // It will make sure that the same interval doesn\\'t count twice.(see explanation)\\n                        if(req[j]<0) req[j]=0;\\n                    }\\n                }\\n                req[i]=0;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3286668,
                "title": "java-easy-solution-greedy-nlogn",
                "content": "\\n# Approach\\nSorting + Greedy \\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(NlogN)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int findMinimumTime(int[][] tasks) {\\n        int [] onTime=new int[2002];\\n        Arrays.sort(tasks,(a,b)->b[0]-a[0]);\\n        for(int i=0;i<tasks.length;i++){\\n            int duration=0;\\n            for(int j=tasks[i][0];j<=tasks[i][1];j++){\\n                if(onTime[j]==1)duration++;\\n            }\\n            duration=tasks[i][2]-duration;\\n                for(int j=tasks[i][0];j<=tasks[i][1] && duration>0;j++){\\n                if(onTime[j]==0){\\n                    onTime[j]=1;\\n                    duration--;\\n                }            \\n            }\\n        }\\n        int res=0;\\n        for(int i=0;i<2002;i++) if(onTime[i]==1)res++;\\n        return res;\\n    }\\n}\\n```\\n\\n\\nPlease Upvote if you find it usefull  \\n!!",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int findMinimumTime(int[][] tasks) {\\n        int [] onTime=new int[2002];\\n        Arrays.sort(tasks,(a,b)->b[0]-a[0]);\\n        for(int i=0;i<tasks.length;i++){\\n            int duration=0;\\n            for(int j=tasks[i][0];j<=tasks[i][1];j++){\\n                if(onTime[j]==1)duration++;\\n            }\\n            duration=tasks[i][2]-duration;\\n                for(int j=tasks[i][0];j<=tasks[i][1] && duration>0;j++){\\n                if(onTime[j]==0){\\n                    onTime[j]=1;\\n                    duration--;\\n                }            \\n            }\\n        }\\n        int res=0;\\n        for(int i=0;i<2002;i++) if(onTime[i]==1)res++;\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1857477,
                "content": [
                    {
                        "username": "takru",
                        "content": "[[10,16,3],[10,20,5],[1,12,4],[8,11,2]] why this is 6 not 5?"
                    },
                    {
                        "username": "le-incroyable1-dev",
                        "content": "Line 1034: Char 9: runtime error: reference binding to misaligned address 0xbebebebebebebec2 for type \\'int\\', which requires 4 byte alignment (stl_vector.h)\\n0xbebebebebebebec2: note: pointer points here\\n<memory cannot be printed>\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior /usr/bin/../lib/gcc/x86_64-linux-gnu/9/../../../../include/c++/9/bits/stl_vector.h:1043:9\\n\\nWhy I am I getting this error?\\nHere is my code:\\n\\n\\n#include <bits/stdc++.h>\\nusing namespace std;\\n\\nclass Solution {\\npublic:\\n\\n    static bool compare(vector<int> &v1, vector<int> &v2){\\n        if(v1[1] < v2[1]) return true;\\n        else if(v1[1] == v2[1]) return v1[0] >= v2[0];\\n        else return false;\\n    }\\n\\n    int findMinimumTime(vector<vector<int>>& t) {\\n        int n = t.size();\\n        sort(t.begin(), t.end(), compare);\\n\\n        // for(auto v : t){\\n        //     cout << v[0] << v[1] << v[2] << \"\\\\n\";\\n        // }\\n\\n        vector<int> slots(2002, 0); \\n\\n        for(auto v : t){\\n\\n            int s = v[0];\\n            int e = v[1];\\n            int d = v[2];\\n\\n            for(int i = e; i >= s; i--){\\n                if(slots[i] == 1) d--;\\n            }\\n\\n\\n            while(d > 0){\\n\\n                if(slots[e] == 0){\\n                    slots[e] = 1;\\n                    d--;\\n                }\\n\\n                e--;\\n            }\\n            \\n        }\\n\\n\\n        int ans = 0;\\n        for(auto val : slots){\\n            //cout << val << \" \";\\n            if(val == 1) ++ans;\\n        }\\n\\n        return ans; \\n    }\\n};\\n"
                    },
                    {
                        "username": "rupakk",
                        "content": "There shouldn\\'t be constraints difference on leetcode China and US website."
                    },
                    {
                        "username": "sarthak_045",
                        "content": "can we solve it using binary search?\nstart=1 end=2000"
                    },
                    {
                        "username": "salil53",
                        "content": "For people getting 1035/1059 testcases passed, Any idea why 1036th testcase is failing? Click to view testcase:\\n<details><summary>1036th testcase(spoiler):</summary>\\n<p>\\n[[68,129,2],[58,86,9],[112,142,10],[106,108,1],[48,48,1],[116,143,2],[28,43,5],[1,1,1],[75,83,3],[104,136,10],[11,11,1],[60,63,1],[73,111,8],[57,57,1],[117,119,3],[25,38,2],[20,21,1],[78,80,2],[17,17,1],[28,28,1],[77,117,3],[76,109,4],[61,61,1],[84,92,5],[18,41,4],[47,55,9],[74,132,6],[53,87,3],[102,131,7],[26,26,1],[66,68,3],[59,73,1],[22,30,9],[9,13,2],[31,35,2],[90,91,2],[72,72,1],[62,84,8],[105,106,2],[3,3,1],[32,32,1],[99,103,4],[45,52,4],[108,116,3],[91,123,8],[89,114,4],[94,130,7],[103,104,2],[14,17,4],[63,66,4],[98,112,7],[101,140,9],[58,58,1],[109,145,1],[8,15,8],[4,16,5],[115,141,1],[40,50,4],[118,118,1],[81,120,7]]\\n\\nExpected: 68"
                    },
                    {
                        "username": "brinuke",
                        "content": "Two possible solutions to the 1036th testcase yielding time = 68 :\n\n`[[1, 1], [3, 3], [8, 17], [20, 20], [22, 32], [47, 55], [57, 58], [61, 61], [63, 68], [72, 72], [75, 75], [78, 79], [84, 86], [90, 91], [99, 101], [103, 106], [112, 121]]`\n\nand\n\n`[[1, 1], [3, 3], [8, 17], [21, 30], [32, 32], [35, 35], [47, 55], [57, 58], [61, 61], [63, 68], [72, 72], [79, 80], [83, 83], [88, 92], [100, 106], [114, 119], [136, 136], [140, 142]]`.\n\n\n[@Aayush65](/Aayush65) Two possible answers to your testcase yielding the best time = 12 are :\n\n`[[3, 10], [65, 68]]`\n\nand\n\n`[[3, 7], [9, 11], [77, 80]]`."
                    },
                    {
                        "username": "Dev_Juneja_23",
                        "content": "Keep in mind that at a time you can do only 1 second of work. You probably be decreasing the total duration more than one for a second. "
                    },
                    {
                        "username": "Aayush65",
                        "content": "[@Sparks0219](/Sparks0219) I made a custom testcase like the above mentioned, but here one can see where his program is going nuts... \\n`[[3, 7, 5], [4, 11, 7], [6, 6, 1], [65, 80, 4]]`"
                    },
                    {
                        "username": "Sparks0219",
                        "content": "Same issue"
                    }
                ]
            },
            {
                "id": 1835356,
                "content": [
                    {
                        "username": "takru",
                        "content": "[[10,16,3],[10,20,5],[1,12,4],[8,11,2]] why this is 6 not 5?"
                    },
                    {
                        "username": "le-incroyable1-dev",
                        "content": "Line 1034: Char 9: runtime error: reference binding to misaligned address 0xbebebebebebebec2 for type \\'int\\', which requires 4 byte alignment (stl_vector.h)\\n0xbebebebebebebec2: note: pointer points here\\n<memory cannot be printed>\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior /usr/bin/../lib/gcc/x86_64-linux-gnu/9/../../../../include/c++/9/bits/stl_vector.h:1043:9\\n\\nWhy I am I getting this error?\\nHere is my code:\\n\\n\\n#include <bits/stdc++.h>\\nusing namespace std;\\n\\nclass Solution {\\npublic:\\n\\n    static bool compare(vector<int> &v1, vector<int> &v2){\\n        if(v1[1] < v2[1]) return true;\\n        else if(v1[1] == v2[1]) return v1[0] >= v2[0];\\n        else return false;\\n    }\\n\\n    int findMinimumTime(vector<vector<int>>& t) {\\n        int n = t.size();\\n        sort(t.begin(), t.end(), compare);\\n\\n        // for(auto v : t){\\n        //     cout << v[0] << v[1] << v[2] << \"\\\\n\";\\n        // }\\n\\n        vector<int> slots(2002, 0); \\n\\n        for(auto v : t){\\n\\n            int s = v[0];\\n            int e = v[1];\\n            int d = v[2];\\n\\n            for(int i = e; i >= s; i--){\\n                if(slots[i] == 1) d--;\\n            }\\n\\n\\n            while(d > 0){\\n\\n                if(slots[e] == 0){\\n                    slots[e] = 1;\\n                    d--;\\n                }\\n\\n                e--;\\n            }\\n            \\n        }\\n\\n\\n        int ans = 0;\\n        for(auto val : slots){\\n            //cout << val << \" \";\\n            if(val == 1) ++ans;\\n        }\\n\\n        return ans; \\n    }\\n};\\n"
                    },
                    {
                        "username": "rupakk",
                        "content": "There shouldn\\'t be constraints difference on leetcode China and US website."
                    },
                    {
                        "username": "sarthak_045",
                        "content": "can we solve it using binary search?\nstart=1 end=2000"
                    },
                    {
                        "username": "salil53",
                        "content": "For people getting 1035/1059 testcases passed, Any idea why 1036th testcase is failing? Click to view testcase:\\n<details><summary>1036th testcase(spoiler):</summary>\\n<p>\\n[[68,129,2],[58,86,9],[112,142,10],[106,108,1],[48,48,1],[116,143,2],[28,43,5],[1,1,1],[75,83,3],[104,136,10],[11,11,1],[60,63,1],[73,111,8],[57,57,1],[117,119,3],[25,38,2],[20,21,1],[78,80,2],[17,17,1],[28,28,1],[77,117,3],[76,109,4],[61,61,1],[84,92,5],[18,41,4],[47,55,9],[74,132,6],[53,87,3],[102,131,7],[26,26,1],[66,68,3],[59,73,1],[22,30,9],[9,13,2],[31,35,2],[90,91,2],[72,72,1],[62,84,8],[105,106,2],[3,3,1],[32,32,1],[99,103,4],[45,52,4],[108,116,3],[91,123,8],[89,114,4],[94,130,7],[103,104,2],[14,17,4],[63,66,4],[98,112,7],[101,140,9],[58,58,1],[109,145,1],[8,15,8],[4,16,5],[115,141,1],[40,50,4],[118,118,1],[81,120,7]]\\n\\nExpected: 68"
                    },
                    {
                        "username": "brinuke",
                        "content": "Two possible solutions to the 1036th testcase yielding time = 68 :\n\n`[[1, 1], [3, 3], [8, 17], [20, 20], [22, 32], [47, 55], [57, 58], [61, 61], [63, 68], [72, 72], [75, 75], [78, 79], [84, 86], [90, 91], [99, 101], [103, 106], [112, 121]]`\n\nand\n\n`[[1, 1], [3, 3], [8, 17], [21, 30], [32, 32], [35, 35], [47, 55], [57, 58], [61, 61], [63, 68], [72, 72], [79, 80], [83, 83], [88, 92], [100, 106], [114, 119], [136, 136], [140, 142]]`.\n\n\n[@Aayush65](/Aayush65) Two possible answers to your testcase yielding the best time = 12 are :\n\n`[[3, 10], [65, 68]]`\n\nand\n\n`[[3, 7], [9, 11], [77, 80]]`."
                    },
                    {
                        "username": "Dev_Juneja_23",
                        "content": "Keep in mind that at a time you can do only 1 second of work. You probably be decreasing the total duration more than one for a second. "
                    },
                    {
                        "username": "Aayush65",
                        "content": "[@Sparks0219](/Sparks0219) I made a custom testcase like the above mentioned, but here one can see where his program is going nuts... \\n`[[3, 7, 5], [4, 11, 7], [6, 6, 1], [65, 80, 4]]`"
                    },
                    {
                        "username": "Sparks0219",
                        "content": "Same issue"
                    }
                ]
            },
            {
                "id": 1834993,
                "content": [
                    {
                        "username": "takru",
                        "content": "[[10,16,3],[10,20,5],[1,12,4],[8,11,2]] why this is 6 not 5?"
                    },
                    {
                        "username": "le-incroyable1-dev",
                        "content": "Line 1034: Char 9: runtime error: reference binding to misaligned address 0xbebebebebebebec2 for type \\'int\\', which requires 4 byte alignment (stl_vector.h)\\n0xbebebebebebebec2: note: pointer points here\\n<memory cannot be printed>\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior /usr/bin/../lib/gcc/x86_64-linux-gnu/9/../../../../include/c++/9/bits/stl_vector.h:1043:9\\n\\nWhy I am I getting this error?\\nHere is my code:\\n\\n\\n#include <bits/stdc++.h>\\nusing namespace std;\\n\\nclass Solution {\\npublic:\\n\\n    static bool compare(vector<int> &v1, vector<int> &v2){\\n        if(v1[1] < v2[1]) return true;\\n        else if(v1[1] == v2[1]) return v1[0] >= v2[0];\\n        else return false;\\n    }\\n\\n    int findMinimumTime(vector<vector<int>>& t) {\\n        int n = t.size();\\n        sort(t.begin(), t.end(), compare);\\n\\n        // for(auto v : t){\\n        //     cout << v[0] << v[1] << v[2] << \"\\\\n\";\\n        // }\\n\\n        vector<int> slots(2002, 0); \\n\\n        for(auto v : t){\\n\\n            int s = v[0];\\n            int e = v[1];\\n            int d = v[2];\\n\\n            for(int i = e; i >= s; i--){\\n                if(slots[i] == 1) d--;\\n            }\\n\\n\\n            while(d > 0){\\n\\n                if(slots[e] == 0){\\n                    slots[e] = 1;\\n                    d--;\\n                }\\n\\n                e--;\\n            }\\n            \\n        }\\n\\n\\n        int ans = 0;\\n        for(auto val : slots){\\n            //cout << val << \" \";\\n            if(val == 1) ++ans;\\n        }\\n\\n        return ans; \\n    }\\n};\\n"
                    },
                    {
                        "username": "rupakk",
                        "content": "There shouldn\\'t be constraints difference on leetcode China and US website."
                    },
                    {
                        "username": "sarthak_045",
                        "content": "can we solve it using binary search?\nstart=1 end=2000"
                    },
                    {
                        "username": "salil53",
                        "content": "For people getting 1035/1059 testcases passed, Any idea why 1036th testcase is failing? Click to view testcase:\\n<details><summary>1036th testcase(spoiler):</summary>\\n<p>\\n[[68,129,2],[58,86,9],[112,142,10],[106,108,1],[48,48,1],[116,143,2],[28,43,5],[1,1,1],[75,83,3],[104,136,10],[11,11,1],[60,63,1],[73,111,8],[57,57,1],[117,119,3],[25,38,2],[20,21,1],[78,80,2],[17,17,1],[28,28,1],[77,117,3],[76,109,4],[61,61,1],[84,92,5],[18,41,4],[47,55,9],[74,132,6],[53,87,3],[102,131,7],[26,26,1],[66,68,3],[59,73,1],[22,30,9],[9,13,2],[31,35,2],[90,91,2],[72,72,1],[62,84,8],[105,106,2],[3,3,1],[32,32,1],[99,103,4],[45,52,4],[108,116,3],[91,123,8],[89,114,4],[94,130,7],[103,104,2],[14,17,4],[63,66,4],[98,112,7],[101,140,9],[58,58,1],[109,145,1],[8,15,8],[4,16,5],[115,141,1],[40,50,4],[118,118,1],[81,120,7]]\\n\\nExpected: 68"
                    },
                    {
                        "username": "brinuke",
                        "content": "Two possible solutions to the 1036th testcase yielding time = 68 :\n\n`[[1, 1], [3, 3], [8, 17], [20, 20], [22, 32], [47, 55], [57, 58], [61, 61], [63, 68], [72, 72], [75, 75], [78, 79], [84, 86], [90, 91], [99, 101], [103, 106], [112, 121]]`\n\nand\n\n`[[1, 1], [3, 3], [8, 17], [21, 30], [32, 32], [35, 35], [47, 55], [57, 58], [61, 61], [63, 68], [72, 72], [79, 80], [83, 83], [88, 92], [100, 106], [114, 119], [136, 136], [140, 142]]`.\n\n\n[@Aayush65](/Aayush65) Two possible answers to your testcase yielding the best time = 12 are :\n\n`[[3, 10], [65, 68]]`\n\nand\n\n`[[3, 7], [9, 11], [77, 80]]`."
                    },
                    {
                        "username": "Dev_Juneja_23",
                        "content": "Keep in mind that at a time you can do only 1 second of work. You probably be decreasing the total duration more than one for a second. "
                    },
                    {
                        "username": "Aayush65",
                        "content": "[@Sparks0219](/Sparks0219) I made a custom testcase like the above mentioned, but here one can see where his program is going nuts... \\n`[[3, 7, 5], [4, 11, 7], [6, 6, 1], [65, 80, 4]]`"
                    },
                    {
                        "username": "Sparks0219",
                        "content": "Same issue"
                    }
                ]
            },
            {
                "id": 1829919,
                "content": [
                    {
                        "username": "takru",
                        "content": "[[10,16,3],[10,20,5],[1,12,4],[8,11,2]] why this is 6 not 5?"
                    },
                    {
                        "username": "le-incroyable1-dev",
                        "content": "Line 1034: Char 9: runtime error: reference binding to misaligned address 0xbebebebebebebec2 for type \\'int\\', which requires 4 byte alignment (stl_vector.h)\\n0xbebebebebebebec2: note: pointer points here\\n<memory cannot be printed>\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior /usr/bin/../lib/gcc/x86_64-linux-gnu/9/../../../../include/c++/9/bits/stl_vector.h:1043:9\\n\\nWhy I am I getting this error?\\nHere is my code:\\n\\n\\n#include <bits/stdc++.h>\\nusing namespace std;\\n\\nclass Solution {\\npublic:\\n\\n    static bool compare(vector<int> &v1, vector<int> &v2){\\n        if(v1[1] < v2[1]) return true;\\n        else if(v1[1] == v2[1]) return v1[0] >= v2[0];\\n        else return false;\\n    }\\n\\n    int findMinimumTime(vector<vector<int>>& t) {\\n        int n = t.size();\\n        sort(t.begin(), t.end(), compare);\\n\\n        // for(auto v : t){\\n        //     cout << v[0] << v[1] << v[2] << \"\\\\n\";\\n        // }\\n\\n        vector<int> slots(2002, 0); \\n\\n        for(auto v : t){\\n\\n            int s = v[0];\\n            int e = v[1];\\n            int d = v[2];\\n\\n            for(int i = e; i >= s; i--){\\n                if(slots[i] == 1) d--;\\n            }\\n\\n\\n            while(d > 0){\\n\\n                if(slots[e] == 0){\\n                    slots[e] = 1;\\n                    d--;\\n                }\\n\\n                e--;\\n            }\\n            \\n        }\\n\\n\\n        int ans = 0;\\n        for(auto val : slots){\\n            //cout << val << \" \";\\n            if(val == 1) ++ans;\\n        }\\n\\n        return ans; \\n    }\\n};\\n"
                    },
                    {
                        "username": "rupakk",
                        "content": "There shouldn\\'t be constraints difference on leetcode China and US website."
                    },
                    {
                        "username": "sarthak_045",
                        "content": "can we solve it using binary search?\nstart=1 end=2000"
                    },
                    {
                        "username": "salil53",
                        "content": "For people getting 1035/1059 testcases passed, Any idea why 1036th testcase is failing? Click to view testcase:\\n<details><summary>1036th testcase(spoiler):</summary>\\n<p>\\n[[68,129,2],[58,86,9],[112,142,10],[106,108,1],[48,48,1],[116,143,2],[28,43,5],[1,1,1],[75,83,3],[104,136,10],[11,11,1],[60,63,1],[73,111,8],[57,57,1],[117,119,3],[25,38,2],[20,21,1],[78,80,2],[17,17,1],[28,28,1],[77,117,3],[76,109,4],[61,61,1],[84,92,5],[18,41,4],[47,55,9],[74,132,6],[53,87,3],[102,131,7],[26,26,1],[66,68,3],[59,73,1],[22,30,9],[9,13,2],[31,35,2],[90,91,2],[72,72,1],[62,84,8],[105,106,2],[3,3,1],[32,32,1],[99,103,4],[45,52,4],[108,116,3],[91,123,8],[89,114,4],[94,130,7],[103,104,2],[14,17,4],[63,66,4],[98,112,7],[101,140,9],[58,58,1],[109,145,1],[8,15,8],[4,16,5],[115,141,1],[40,50,4],[118,118,1],[81,120,7]]\\n\\nExpected: 68"
                    },
                    {
                        "username": "brinuke",
                        "content": "Two possible solutions to the 1036th testcase yielding time = 68 :\n\n`[[1, 1], [3, 3], [8, 17], [20, 20], [22, 32], [47, 55], [57, 58], [61, 61], [63, 68], [72, 72], [75, 75], [78, 79], [84, 86], [90, 91], [99, 101], [103, 106], [112, 121]]`\n\nand\n\n`[[1, 1], [3, 3], [8, 17], [21, 30], [32, 32], [35, 35], [47, 55], [57, 58], [61, 61], [63, 68], [72, 72], [79, 80], [83, 83], [88, 92], [100, 106], [114, 119], [136, 136], [140, 142]]`.\n\n\n[@Aayush65](/Aayush65) Two possible answers to your testcase yielding the best time = 12 are :\n\n`[[3, 10], [65, 68]]`\n\nand\n\n`[[3, 7], [9, 11], [77, 80]]`."
                    },
                    {
                        "username": "Dev_Juneja_23",
                        "content": "Keep in mind that at a time you can do only 1 second of work. You probably be decreasing the total duration more than one for a second. "
                    },
                    {
                        "username": "Aayush65",
                        "content": "[@Sparks0219](/Sparks0219) I made a custom testcase like the above mentioned, but here one can see where his program is going nuts... \\n`[[3, 7, 5], [4, 11, 7], [6, 6, 1], [65, 80, 4]]`"
                    },
                    {
                        "username": "Sparks0219",
                        "content": "Same issue"
                    }
                ]
            },
            {
                "id": 1829899,
                "content": [
                    {
                        "username": "takru",
                        "content": "[[10,16,3],[10,20,5],[1,12,4],[8,11,2]] why this is 6 not 5?"
                    },
                    {
                        "username": "le-incroyable1-dev",
                        "content": "Line 1034: Char 9: runtime error: reference binding to misaligned address 0xbebebebebebebec2 for type \\'int\\', which requires 4 byte alignment (stl_vector.h)\\n0xbebebebebebebec2: note: pointer points here\\n<memory cannot be printed>\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior /usr/bin/../lib/gcc/x86_64-linux-gnu/9/../../../../include/c++/9/bits/stl_vector.h:1043:9\\n\\nWhy I am I getting this error?\\nHere is my code:\\n\\n\\n#include <bits/stdc++.h>\\nusing namespace std;\\n\\nclass Solution {\\npublic:\\n\\n    static bool compare(vector<int> &v1, vector<int> &v2){\\n        if(v1[1] < v2[1]) return true;\\n        else if(v1[1] == v2[1]) return v1[0] >= v2[0];\\n        else return false;\\n    }\\n\\n    int findMinimumTime(vector<vector<int>>& t) {\\n        int n = t.size();\\n        sort(t.begin(), t.end(), compare);\\n\\n        // for(auto v : t){\\n        //     cout << v[0] << v[1] << v[2] << \"\\\\n\";\\n        // }\\n\\n        vector<int> slots(2002, 0); \\n\\n        for(auto v : t){\\n\\n            int s = v[0];\\n            int e = v[1];\\n            int d = v[2];\\n\\n            for(int i = e; i >= s; i--){\\n                if(slots[i] == 1) d--;\\n            }\\n\\n\\n            while(d > 0){\\n\\n                if(slots[e] == 0){\\n                    slots[e] = 1;\\n                    d--;\\n                }\\n\\n                e--;\\n            }\\n            \\n        }\\n\\n\\n        int ans = 0;\\n        for(auto val : slots){\\n            //cout << val << \" \";\\n            if(val == 1) ++ans;\\n        }\\n\\n        return ans; \\n    }\\n};\\n"
                    },
                    {
                        "username": "rupakk",
                        "content": "There shouldn\\'t be constraints difference on leetcode China and US website."
                    },
                    {
                        "username": "sarthak_045",
                        "content": "can we solve it using binary search?\nstart=1 end=2000"
                    },
                    {
                        "username": "salil53",
                        "content": "For people getting 1035/1059 testcases passed, Any idea why 1036th testcase is failing? Click to view testcase:\\n<details><summary>1036th testcase(spoiler):</summary>\\n<p>\\n[[68,129,2],[58,86,9],[112,142,10],[106,108,1],[48,48,1],[116,143,2],[28,43,5],[1,1,1],[75,83,3],[104,136,10],[11,11,1],[60,63,1],[73,111,8],[57,57,1],[117,119,3],[25,38,2],[20,21,1],[78,80,2],[17,17,1],[28,28,1],[77,117,3],[76,109,4],[61,61,1],[84,92,5],[18,41,4],[47,55,9],[74,132,6],[53,87,3],[102,131,7],[26,26,1],[66,68,3],[59,73,1],[22,30,9],[9,13,2],[31,35,2],[90,91,2],[72,72,1],[62,84,8],[105,106,2],[3,3,1],[32,32,1],[99,103,4],[45,52,4],[108,116,3],[91,123,8],[89,114,4],[94,130,7],[103,104,2],[14,17,4],[63,66,4],[98,112,7],[101,140,9],[58,58,1],[109,145,1],[8,15,8],[4,16,5],[115,141,1],[40,50,4],[118,118,1],[81,120,7]]\\n\\nExpected: 68"
                    },
                    {
                        "username": "brinuke",
                        "content": "Two possible solutions to the 1036th testcase yielding time = 68 :\n\n`[[1, 1], [3, 3], [8, 17], [20, 20], [22, 32], [47, 55], [57, 58], [61, 61], [63, 68], [72, 72], [75, 75], [78, 79], [84, 86], [90, 91], [99, 101], [103, 106], [112, 121]]`\n\nand\n\n`[[1, 1], [3, 3], [8, 17], [21, 30], [32, 32], [35, 35], [47, 55], [57, 58], [61, 61], [63, 68], [72, 72], [79, 80], [83, 83], [88, 92], [100, 106], [114, 119], [136, 136], [140, 142]]`.\n\n\n[@Aayush65](/Aayush65) Two possible answers to your testcase yielding the best time = 12 are :\n\n`[[3, 10], [65, 68]]`\n\nand\n\n`[[3, 7], [9, 11], [77, 80]]`."
                    },
                    {
                        "username": "Dev_Juneja_23",
                        "content": "Keep in mind that at a time you can do only 1 second of work. You probably be decreasing the total duration more than one for a second. "
                    },
                    {
                        "username": "Aayush65",
                        "content": "[@Sparks0219](/Sparks0219) I made a custom testcase like the above mentioned, but here one can see where his program is going nuts... \\n`[[3, 7, 5], [4, 11, 7], [6, 6, 1], [65, 80, 4]]`"
                    },
                    {
                        "username": "Sparks0219",
                        "content": "Same issue"
                    }
                ]
            }
        ]
    }
]