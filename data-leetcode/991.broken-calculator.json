[
    {
        "title": "Broken Calculator",
        "question_content": "There is a broken calculator that has the integer startValue on its display initially. In one operation, you can:\n\n\tmultiply the number on display by 2, or\n\tsubtract 1 from the number on display.\n\nGiven two integers startValue and target, return the minimum number of operations needed to display target on the calculator.\n&nbsp;\nExample 1:\n\nInput: startValue = 2, target = 3\nOutput: 2\nExplanation: Use double operation and then decrement operation {2 -> 4 -> 3}.\n\nExample 2:\n\nInput: startValue = 5, target = 8\nOutput: 2\nExplanation: Use decrement and then double {5 -> 4 -> 8}.\n\nExample 3:\n\nInput: startValue = 3, target = 10\nOutput: 3\nExplanation: Use double, decrement and double {3 -> 6 -> 5 -> 10}.\n\n&nbsp;\nConstraints:\n\n\t1 <= startValue, target <= 109",
        "solutions": [
            {
                "id": 1874851,
                "title": "c-easy-approach-proper-explanation",
                "content": "### First Approach\\n```\\nAfter reading the problem first approach which would come in my mind is based on the operation which is given.\\nThat is multiplying and subtracting for reaching from \\'startValue\\' to \\'target\\' value.\\nThere would be possibly three cases in this...\\n1. If startValue == target then it will be zero.\\n2. If startValue > target then we only subtract by 1 till we get startValue == target.\\n3. If startValue < target then we only multiply it by till we get startValue equal to target or startValue > target. If startValue get greater than target then we only perform decrementing it.\\n \\n But this approach fails in second case \\'\\uD83D\\uDE05\\'  \\n\\tI/P startValue = 5 target = 8\\n\\tAcc to my approach \\n\\tFirst we go from 5->10 ( X 2 )\\n\\tSecond we subtract 10 -> 9 -> 8 \\n\\tTotal steps is 3.\\n\\tBut the answer is 2;\\n\\tHOW ?? by just decreasing by 1 and then multiplying by 2 i.e 5 -> 4 -> 8.\\n```\\n### Second Approach\\n```\\nInstead of going from startValue to target value we go for opposite i.e target value to startValue.\\nBy reversing the operation i.e instead of multiplying we go for dividing and instead of subtarcting we go for adding.\\nThere would be also possibly three cases in this...\\n1. If target == startValue then it will be zero.\\n2. If  target > startValue then we only divide it by 2 till we get startValue == target or startValue get greater than target. \\n\\tIN STEP SECOND WE HAVE ONE MORE SUB CASES.\\n\\tWe only go for division if target is even else we only increase target by 1.\\n3. If target < startValue then we only increment it by 1.\\n\\nExample \\n\\tI/P  startValue = 5   target = 8\\n\\tStep - 1 target > startValue then divide target by 2 , it becomes 4.\\n\\tStep - 2 target < startValue then we only add by 1 till we get target == startValue. We can only find it by subtracting startValue - target value as startValue is > than target in this case.\\n\\tTherfore total no of steps taken is divide->add i.e \\'2\\' which is the answer.\\n```\\nALGORITHM\\n```\\nStep-1 Declare step counter with initial value 0.\\nStep-2 Start Iterating with condition check whether target value is greater than startValue or not.\\nStep-3 If target > startValue increment step counter by 1. And check whether target value is even or odd.\\nStep-4 If target value is even then divide it by 2 else if it is odd add target value by 1.\\nStep-5 Loop continues till target become small or equal to startValue.\\nStep-6 If target <  startValue then we only add target by 1 till it become equal. So total number of add required can be found by \\'startValue - target\\'. Because currently startValue is > targetValue.\\nStep-7 Return step+startValue - target ;\\n```\\nIF there is some typing mistake then for that i apologize. Thanks for reviewing my idea.\\n\\n### IMPORTANT POINTS\\n```\\nThanks to \\xA0brent7890\\uD83D\\uDE01\\nThe reason why we increment then immediately divide by 2, rather than incrementing more than once and dividing by 2, is simply because, well, better explained in an example:\\n\\nsay our target is 201. Then, say input is 10, or whatever, something smaller.\\n\\nIf, somehow, we think, maybe\\n102*2 = 204 then 204 - 1 - 1 - 1 = 201, in total this is 4 operations.\\n\\ninstead, if we consider\\n102 - 1 = 101 then 101 * 2 = 202 then 202 - 1 = 201, in total is only 3 operations.\\n\\nBut, to put it in reverse, starting from the target, the way to think about this intuitively is, if we start from a target (prior to dividing by 2) and increment to a larger number, how every many times we increment, we\\'re incrementing by a factor of 2 more than if we simply divide by 2 first, then increment on the smaller number.\\n\\nThat\\'s why this process is optimal.\\n```\\n### CODE\\n``` \\nclass Solution {\\npublic:\\n    int brokenCalc(int startValue, int target) {\\n        int result=0;\\n        while(target>startValue)\\n        {\\n            result++;\\n            if(target%2==0)\\n                target=target/2;\\n            else\\n                target+=1;\\n        }\\n        result=result+(startValue-target);\\n        return result;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nAfter reading the problem first approach which would come in my mind is based on the operation which is given.\\nThat is multiplying and subtracting for reaching from \\'startValue\\' to \\'target\\' value.\\nThere would be possibly three cases in this...\\n1. If startValue == target then it will be zero.\\n2. If startValue > target then we only subtract by 1 till we get startValue == target.\\n3. If startValue < target then we only multiply it by till we get startValue equal to target or startValue > target. If startValue get greater than target then we only perform decrementing it.\\n \\n But this approach fails in second case \\'\\uD83D\\uDE05\\'  \\n\\tI/P startValue = 5 target = 8\\n\\tAcc to my approach \\n\\tFirst we go from 5->10 ( X 2 )\\n\\tSecond we subtract 10 -> 9 -> 8 \\n\\tTotal steps is 3.\\n\\tBut the answer is 2;\\n\\tHOW ?? by just decreasing by 1 and then multiplying by 2 i.e 5 -> 4 -> 8.\\n```\n```\\nInstead of going from startValue to target value we go for opposite i.e target value to startValue.\\nBy reversing the operation i.e instead of multiplying we go for dividing and instead of subtarcting we go for adding.\\nThere would be also possibly three cases in this...\\n1. If target == startValue then it will be zero.\\n2. If  target > startValue then we only divide it by 2 till we get startValue == target or startValue get greater than target. \\n\\tIN STEP SECOND WE HAVE ONE MORE SUB CASES.\\n\\tWe only go for division if target is even else we only increase target by 1.\\n3. If target < startValue then we only increment it by 1.\\n\\nExample \\n\\tI/P  startValue = 5   target = 8\\n\\tStep - 1 target > startValue then divide target by 2 , it becomes 4.\\n\\tStep - 2 target < startValue then we only add by 1 till we get target == startValue. We can only find it by subtracting startValue - target value as startValue is > than target in this case.\\n\\tTherfore total no of steps taken is divide->add i.e \\'2\\' which is the answer.\\n```\n```\\nStep-1 Declare step counter with initial value 0.\\nStep-2 Start Iterating with condition check whether target value is greater than startValue or not.\\nStep-3 If target > startValue increment step counter by 1. And check whether target value is even or odd.\\nStep-4 If target value is even then divide it by 2 else if it is odd add target value by 1.\\nStep-5 Loop continues till target become small or equal to startValue.\\nStep-6 If target <  startValue then we only add target by 1 till it become equal. So total number of add required can be found by \\'startValue - target\\'. Because currently startValue is > targetValue.\\nStep-7 Return step+startValue - target ;\\n```\n```\\nThanks to \\xA0brent7890\\uD83D\\uDE01\\nThe reason why we increment then immediately divide by 2, rather than incrementing more than once and dividing by 2, is simply because, well, better explained in an example:\\n\\nsay our target is 201. Then, say input is 10, or whatever, something smaller.\\n\\nIf, somehow, we think, maybe\\n102*2 = 204 then 204 - 1 - 1 - 1 = 201, in total this is 4 operations.\\n\\ninstead, if we consider\\n102 - 1 = 101 then 101 * 2 = 202 then 202 - 1 = 201, in total is only 3 operations.\\n\\nBut, to put it in reverse, starting from the target, the way to think about this intuitively is, if we start from a target (prior to dividing by 2) and increment to a larger number, how every many times we increment, we\\'re incrementing by a factor of 2 more than if we simply divide by 2 first, then increment on the smaller number.\\n\\nThat\\'s why this process is optimal.\\n```\n``` \\nclass Solution {\\npublic:\\n    int brokenCalc(int startValue, int target) {\\n        int result=0;\\n        while(target>startValue)\\n        {\\n            result++;\\n            if(target%2==0)\\n                target=target/2;\\n            else\\n                target+=1;\\n        }\\n        result=result+(startValue-target);\\n        return result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1874813,
                "title": "java-c-recursive-iterative-solution",
                "content": "How\\'s going Ladies - n - Gentlemen, today we are going to solve another coolest problem i.e. **Broken Calculator**\\n\\nSo, what the question is saying is :-\\n```\\n=>Given Two Number\\'s startValue & target\\n=>find Minimum number of operation\\'s to convert startValue to target\\n```\\nNow what operation\\'s question is saying to perform:\\n```\\n=>multiply the number on display by 2, or\\n=>subtract 1 from the number on display.\\n```\\n\\nBut we\\'ll modify the operation\\'s inorder to get our result! We are going to solve our problem in 2 way\\'s **Recursive** &  **Iterative**\\n\\n```\\nRecursive Approach\\n```\\nif `startValue >= target`, then we have to **subtract by 1**\\nOtherwise,\\nif it is `even`, then the only way is to **divide it by 2**\\nIf it is `odd`, then there\\'s no way other than to **add 1 to change to even**\\n\\n**Java**\\n```\\nclass Solution {\\n    public int brokenCalc(int startValue, int target) {\\n        if(startValue >= target) return startValue - target;\\n        if(target % 2 == 0){\\n            return 1 + brokenCalc(startValue, target / 2);\\n        }\\n        return 1 + brokenCalc(startValue, target + 1);\\n    }\\n}\\n```\\n**C++**\\n```\\nclass Solution {\\npublic:\\n    int brokenCalc(int startValue, int target) {\\n        if(startValue >= target) return startValue - target;\\n        if(target % 2 == 0){\\n            return 1 + brokenCalc(startValue, target / 2);\\n        }\\n        return 1 + brokenCalc(startValue, target + 1);\\n    }\\n};\\n```\\nANALYSIS :-\\n* **Time Complexity :-** BigO(logN)\\n\\n* **Space Complexity :-** BigO(1)\\n\\n```\\nIterative Approach\\n```\\nSimilar to recursive,\\nRun the loop until `target` becomes **>** `startValue`\\nWhat you have to perform:-\\nif it is `even`, then the only way is to **divide it by 2**\\nIf it is `odd`, then there\\'s no way other than to **add 1 to change to even**\\n\\n**Let\\'s understand a way more deeper:**\\n\\nWe\\'re only allowed to do \"Double\" and \"Decrement\" operation to startValue,\\nIn the case of change startValue to target, considering target = startValue*(2^n) + 1, where n can be any given number.\\nWe can double startValue for n + 1 times, then, do decrement for startValue*(2^n) - 1 times, which make startValue = target.\\nWhen n get bigger, which means we perform more double operations, the number of required decrement operation would increase exponentially in this case.\\n\\nOn the other hand, if we change target to startValue,\\nwe can do operations to target which are exactly opposite to what we can do to startValue.\\nThat is:\\n\\nDivision: Divide by 2\\nIncrement: Add by 1\\nIn the same case of target = startValue*(2^n) + 1\\nmore division operations we perform, the number of increment operation would decrease exponentially.\\nTherefore, do as many division operations as we can which would lead to minumum number of operation needed to change target to startValue.\\n\\n\\n**Java**\\n```\\nclass Solution {\\n    public int brokenCalc(int startValue, int target) {\\n        int result = 0;\\n        while(target > startValue){\\n            if(target % 2 == 0){\\n                target /= 2;\\n            }\\n            else{\\n                target++;\\n            }\\n            result++;\\n        }\\n        return result + (startValue - target);\\n    }\\n}\\n```\\n**C++**\\n```\\nclass Solution {\\npublic:\\n    int brokenCalc(int startValue, int target) {\\n        int result = 0;\\n        while(target > startValue){\\n            if(target % 2 == 0){\\n                target /= 2;\\n            }\\n            else{\\n                target++;\\n            }\\n            result++;\\n        }\\n        return result + (startValue - target);\\n    }\\n};\\n```\\n\\nANALYSIS :-\\n* **Time Complexity :-** BigO(logN)\\n\\n* **Space Complexity :-** BigO(1)\\n",
                "solutionTags": [
                    "Java",
                    "C"
                ],
                "code": "```\\n=>Given Two Number\\'s startValue & target\\n=>find Minimum number of operation\\'s to convert startValue to target\\n```\n```\\n=>multiply the number on display by 2, or\\n=>subtract 1 from the number on display.\\n```\n```\\nRecursive Approach\\n```\n```\\nclass Solution {\\n    public int brokenCalc(int startValue, int target) {\\n        if(startValue >= target) return startValue - target;\\n        if(target % 2 == 0){\\n            return 1 + brokenCalc(startValue, target / 2);\\n        }\\n        return 1 + brokenCalc(startValue, target + 1);\\n    }\\n}\\n```\n```\\nclass Solution {\\npublic:\\n    int brokenCalc(int startValue, int target) {\\n        if(startValue >= target) return startValue - target;\\n        if(target % 2 == 0){\\n            return 1 + brokenCalc(startValue, target / 2);\\n        }\\n        return 1 + brokenCalc(startValue, target + 1);\\n    }\\n};\\n```\n```\\nIterative Approach\\n```\n```\\nclass Solution {\\n    public int brokenCalc(int startValue, int target) {\\n        int result = 0;\\n        while(target > startValue){\\n            if(target % 2 == 0){\\n                target /= 2;\\n            }\\n            else{\\n                target++;\\n            }\\n            result++;\\n        }\\n        return result + (startValue - target);\\n    }\\n}\\n```\n```\\nclass Solution {\\npublic:\\n    int brokenCalc(int startValue, int target) {\\n        int result = 0;\\n        while(target > startValue){\\n            if(target % 2 == 0){\\n                target /= 2;\\n            }\\n            else{\\n                target++;\\n            }\\n            result++;\\n        }\\n        return result + (startValue - target);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1875138,
                "title": "c-iterative-100-faster-o-1-space",
                "content": "*Upvote if helpful*\\n\\n**Approach**\\n```\\n1. reduce target value as much as possible  because this question can be done by greedy\\n2. if divisible by 2 divide by 2  \\n3. else increase by 1\\n4. if target becomes less than startValue then only option left is to increasse\\n```\\n\\n\\n\\n**CODE**\\n```\\nclass Solution {\\npublic:\\n    int brokenCalc(int startValue, int target) {\\n        long long ans = 0;\\n        long long tar = target;\\n        while(startValue != tar){\\n            if(tar%2 == 0 and startValue < tar){\\n                tar /= 2;\\n            }\\n            else if(tar > startValue){\\n                tar +=1;\\n            }\\n            else{\\n                ans += abs(tar-startValue)-1;\\n                tar = startValue;\\n            }\\n            ans++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n1. reduce target value as much as possible  because this question can be done by greedy\\n2. if divisible by 2 divide by 2  \\n3. else increase by 1\\n4. if target becomes less than startValue then only option left is to increasse\\n```\n```\\nclass Solution {\\npublic:\\n    int brokenCalc(int startValue, int target) {\\n        long long ans = 0;\\n        long long tar = target;\\n        while(startValue != tar){\\n            if(tar%2 == 0 and startValue < tar){\\n                tar /= 2;\\n            }\\n            else if(tar > startValue){\\n                tar +=1;\\n            }\\n            else{\\n                ans += abs(tar-startValue)-1;\\n                tar = startValue;\\n            }\\n            ans++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 234484,
                "title": "java-c-python-change-y-to-x-in-1-line",
                "content": "## **Intuition**:\\n\\nConsidering how to change `Y` to `X`\\nOperation 1: `Y = Y / 2` if `Y` is even\\nOperation 2: `Y = Y + 1`\\n<br>\\n\\n## **Explanation**:\\n\\nObviously,\\nIf `Y <= X`, we won\\'t do `Y / 2` anymore.\\nWe will increase `Y` until it equals to `X`\\n\\nSo before that, while `Y > X`, we\\'ll keep reducing `Y`, until it\\'s smaller than `X`.\\nIf `Y` is odd, we can do only `Y = Y + 1`\\nIf `Y` is even, if we plus 1 to `Y`, then `Y` is odd, we need to plus another 1.\\nAnd because `(Y + 1 + 1) / 2 = (Y / 2) + 1`, 3 operations are more than 2.\\nWe always choose `Y / 2` if `Y` is even. \\n<br>\\n\\n## **Why it\\'s right**\\nActually, what we do is:\\nIf `Y` is even, `Y = Y / 2`\\nIf `Y` is odd, `Y = (Y + 1) / 2`\\n\\nWe reduce `Y` with least possible operations, until it\\'s smaller than `X`.\\n\\nAnd we know that, we won\\'t do `Y + 1` twice in a row.\\nBecasue we will always end with an operation `Y / 2`.\\n\\n2N times `Y + 1` and once `Y / 2` needs 2N + 1 operations.\\nOnce `Y / 2` first and N times `Y + 1` will end up with same result, but needs only N + 1 operations.\\n<br>\\n\\n## **Time complexity**\\nWe do `Y/2` all the way until it\\'s smaller than `X`,\\ntime complexity is `O(log(Y/X))`.\\n<br>\\n\\n**Java/C++**\\n```\\n        int res = 0;\\n        while (Y > X) {\\n            Y = Y % 2 > 0 ? Y + 1 : Y / 2;\\n            res++;\\n        }\\n        return res + X - Y;\\n```\\n\\n**Python:**\\n```\\n    def brokenCalc(self, X, Y):\\n        res = 0\\n        while X < Y:\\n            res += Y % 2 + 1\\n            Y = (Y + 1) / 2\\n        return res + X - Y\\n```\\n\\n<br>\\n\\n## **1 line Recursive Solution**\\n**Java/C++**\\n```\\n        return X >= Y ? X - Y : 1 + Y % 2 + brokenCalc(X, (Y + 1) / 2);\\n```\\n\\n**Python:**\\n```\\n        return X - Y if X >= Y else 1 + Y % 2 + self.brokenCalc(X, (Y + 1) / 2)\\n```\\n\\n<br>\\n\\n## **FAQ, Updated on 2019-02-11**\\n\\n**Q: Can we try to change X to Y?**\\n**A:** Yes we can.\\n\\n**Java**\\n```\\n    public int brokenCalc(int X, int Y) {\\n        int multiple = 1, res = 0;\\n        while (X * multiple < Y) {\\n            multiple <<= 1;\\n            res++;\\n        }\\n        int diff = X * multiple - Y;\\n        while (diff > 0) {  \\n            res += diff / multiple;\\n            diff -= diff / multiple * multiple;\\n            multiple >>= 1;\\n        }\\n        return res;\\n    }\\n```\\n**C++**\\n```\\n    int brokenCalc(int X, int Y) {\\n        int multiple = 1, res = 0;\\n        while (X * multiple < Y)\\n            multiple <<= 1, res++;\\n        int diff = X * multiple - Y;\\n        while (diff > 0) {  \\n            res += diff / multiple;\\n            diff -= diff / multiple * multiple;\\n            multiple >>= 1;\\n        }\\n        return res;\\n    }\\n```\\n\\n**Python:**\\n```\\n    def brokenCalc(self, X, Y):\\n        multiple = 1\\n        res = 0\\n        while X * multiple < Y:\\n            multiple *= 2\\n            res += 1\\n        diff = X * multiple - Y\\n        while diff:\\n            res += diff / multiple\\n            diff -= diff / multiple * multiple\\n            multiple /= 2\\n        return res\\n```",
                "solutionTags": [],
                "code": "```\\n        int res = 0;\\n        while (Y > X) {\\n            Y = Y % 2 > 0 ? Y + 1 : Y / 2;\\n            res++;\\n        }\\n        return res + X - Y;\\n```\n```\\n    def brokenCalc(self, X, Y):\\n        res = 0\\n        while X < Y:\\n            res += Y % 2 + 1\\n            Y = (Y + 1) / 2\\n        return res + X - Y\\n```\n```\\n        return X >= Y ? X - Y : 1 + Y % 2 + brokenCalc(X, (Y + 1) / 2);\\n```\n```\\n        return X - Y if X >= Y else 1 + Y % 2 + self.brokenCalc(X, (Y + 1) / 2)\\n```\n```\\n    public int brokenCalc(int X, int Y) {\\n        int multiple = 1, res = 0;\\n        while (X * multiple < Y) {\\n            multiple <<= 1;\\n            res++;\\n        }\\n        int diff = X * multiple - Y;\\n        while (diff > 0) {  \\n            res += diff / multiple;\\n            diff -= diff / multiple * multiple;\\n            multiple >>= 1;\\n        }\\n        return res;\\n    }\\n```\n```\\n    int brokenCalc(int X, int Y) {\\n        int multiple = 1, res = 0;\\n        while (X * multiple < Y)\\n            multiple <<= 1, res++;\\n        int diff = X * multiple - Y;\\n        while (diff > 0) {  \\n            res += diff / multiple;\\n            diff -= diff / multiple * multiple;\\n            multiple >>= 1;\\n        }\\n        return res;\\n    }\\n```\n```\\n    def brokenCalc(self, X, Y):\\n        multiple = 1\\n        res = 0\\n        while X * multiple < Y:\\n            multiple *= 2\\n            res += 1\\n        diff = X * multiple - Y\\n        while diff:\\n            res += diff / multiple\\n            diff -= diff / multiple * multiple\\n            multiple /= 2\\n        return res\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 236565,
                "title": "detailed-proof-of-correctness-greedy-algorithm",
                "content": "**Credits** -- Motivation to convert `y` to `x` inspired by [lee215\\'s Solution](https://leetcode.com/problems/broken-calculator/discuss/234484/JavaC%2B%2BPython-Change-Y-to-X-in-1-Line)\\n\\n\\nFirst, Let use see if the solution exists or not.\\nClearly, we can keep doubling ` x ` till it goes beyond ` y`. Then we can keep decrementing `x` till it reaches `y`. Since the number of operations  is not limited, so we conclude that a solution exists.\\n\\nSo now, consider an optimal solution (any solution with the minimal number of steps). \\nThe path is nothing but a sequence of numbers that start at `x` and end at `y`. \\n\\n`Assume (x<=y)`. The other case is trivial\\n\\n# Case 1) ***Y is odd***\\n\\nNow, consider the last second element of the sequence (optimal path). Recall that we can only move in the sequence via the allowed moves (in the forward direction, we multiply by 2 or decrement by 1). Let us backtrack and see which move did we actually use to get to `y`. (obviously it has to be one of the two moves).\\n\\nNow, the move could not have been multiplication by 2, or else `y` would have been a multiple of 2, which violates our assumption. So the only possible move is the decrement move. It means that the last second term of the sequence is indeed `y+1` if `y` is odd. (And there is no other possibility).\\n\\nSo now we just need to compute the optimal length to reach `y+1`, and then add 1 to our answer to get the optimal path length for `y`. (Why? It happens because `y+1` lies in an optimal path and any subpath of the optimal path must be optimal or else it would violate our assumptions).\\n\\n\\n# Case 2)***Y is even. Say, y=2m***\\n\\nFirst, let us study the worst case analysis of what is the maximum number that you would touch if you play optimally.\\n\\nClearly it is `2*(y-1)`, since in the worst case, you may end up starting at `y-1` and jumping to `2*(y-1)` and then coming back. In all other cases, the jump will lead you to a number less than `2*(y-1)` and you can easily come back to `y` one step at a time.\\n\\nLet us denote `2*(y-1)` as `jump_max`.\\n\\n\\nNow, If `y` is even, we cannot say anything about the last second term of the sequence. (The move could be either multiplication or decrement).\\n\\nHowever, let us see what happens if the last move was multiplication by 2. \\n\\nClearly , the last second element in this case is `y/2` = `m`\\n\\nSo we need to compute the optimal path length to reach `m` and then we can add 1 to our answer. (But this is valid only if we know that the last move was indeed multiplication.)\\n\\n***What if the last move was decrement?***\\n\\nIn that case, the last second element becomes `2m+1`, (odd number) , and by the 1st lemma, we conclude that the last third number is `2m+2`. \\n\\nNow `2m+2` is an even number so either a jump happens or it\\'s descendant is `2m+4`. So we keep going to the right untill we find a`k` such that `2m+2k` is obtained by jumping from `m+k`. Clearly such a number exists as the largest number we can encounter is `jump_max`.\\n\\nSo, now the path looks like \\n\\n`x` .......  `(m+k)` -> `2(m+k)`  -> `(2m+2k-1)` -> `(2m+2k-2) -> ....... `y`\\n\\nBut, if you observe carefully, after we reach `(m+k)` we can decrement `k` times to reach `m` and then double to get `y`. This would cost us `(k+1)` operations `+` the cost to reach `(m+k)`. However, the current cost is `(1 + 2(m+k) - 2m)` = `(2k+1)` operations `+` the cost to reach `(m+k)`. Since the new cost is lower, this violates our assumption that the original sequence was an optimal path. Therefore we have a contradiction and we conclude that the last move could not have been decrement.\\n\\n# **Conclusion**\\n\\nIf `y` is odd, we know that the last number to be reached before `y` is `(y+1)` (in the optimal path)\\n\\nIf `y` is even, we know that the last number to be reached before `y` is `y/2` (in the optimal path).\\n\\nSo finally we have our recursive relation.\\n\\n`if`(x>=y)\\n`cost`(x,y) = x-y\\n\\n\\n`if`(x< y)\\n`cost` (x,y) = 1 + `cost`(x,y+1) if `y` is odd\\n`cost` (x,y) = 1 + `cost`(x,y/2) if `y` is even \\n\\nHere\\'s the iterative implementation\\n\\n```\\nint brokenCalc(int x, int y)\\n{\\n    int count=0;\\n    while(y!=x)\\n    {\\n        if(x>=y) return ((x-y) + count);\\n        \\n        /* If y is even, the last move was multiplication, else decrement */\\n        if(y%2==0) y=y/2 ;\\n        else y++;\\n        \\n        // One operation used\\n        count ++;\\n    }\\n    \\n    return count;\\n}\\n```\\n\\nSorry, It got too long but I hope you get the gist.\\n\\n.",
                "solutionTags": [],
                "code": "```\\nint brokenCalc(int x, int y)\\n{\\n    int count=0;\\n    while(y!=x)\\n    {\\n        if(x>=y) return ((x-y) + count);\\n        \\n        /* If y is even, the last move was multiplication, else decrement */\\n        if(y%2==0) y=y/2 ;\\n        else y++;\\n        \\n        // One operation used\\n        count ++;\\n    }\\n    \\n    return count;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1076046,
                "title": "python-greedy-solution-explained",
                "content": "Let us consider several cases and understand, what will be the best choise in each of them. Let us go in opposite direction and divide `Y` by `2` or add `1`, to it until we get `X`.\\n\\n1. If `X > Y`, we do not have a lot of choice, we can just decrease `X` by one until it becomes equal to `Y`, so answer will be `X - Y`.\\n2. If `X == Y`, then we already happy and we return `0`.\\n3. If `Y % 2 == 1`, then let us think, what can be the last step? It can not be multilication by `2`, so the only choice is subtraction of `1` and on previous step we have configuration `(X, Y + 1)`, for which we run our function recursively.\\n4. If `Y % 2 == 0`, let us prove that we always need to divide by `2` in this case. \\n\\nImagine, that we have sequence of operations, like: `[+1, +1, /2, /2, /2, +1, /2, ...]`. Then, if we have `+1, +1, /2` sequence inside, we can always replace it with `/2, +1`, so we can make it shorter. So, there will be no `+1, +1` subsequence, except for the very end and in general all sequence looks like: `[+1, /2, .., /2, +1, /2, ..., /2, ..., +1, ..., +1]`. Note, that the last part correspondes to case `1`. Also we will never have two `+1` in the middle and it means, that if we have even number, we **must** divide it by `2`: if we add `1` to it, then we have no choice to add `1` again (case 3) and then we have `+1, +1, /2` pattern.\\n\\n**Complexity**: time complexity is `O(log Y)`, because every two iteration number decreased at least twice. Space complexity here is also `O(log Y)`, because we use recursion. It can be made `O(1)` if we do it iteratively.\\n\\n```\\nclass Solution:\\n    def brokenCalc(self, X, Y):\\n        if X > Y: return X - Y\\n        if X == Y: return 0\\n        if Y % 2 == 0:\\n            return self.brokenCalc(X, Y//2) + 1\\n        else:\\n            return self.brokenCalc(X, Y + 1) + 1\\n```\\n\\nIf you have any question, feel free to ask. If you like the explanations, please **Upvote!**",
                "solutionTags": [
                    "Greedy",
                    "Recursion"
                ],
                "code": "```\\nclass Solution:\\n    def brokenCalc(self, X, Y):\\n        if X > Y: return X - Y\\n        if X == Y: return 0\\n        if Y % 2 == 0:\\n            return self.brokenCalc(X, Y//2) + 1\\n        else:\\n            return self.brokenCalc(X, Y + 1) + 1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1874839,
                "title": "c-2-approaches-easy-simple-short-algorithm",
                "content": "# 991. Broken Calculator\\n**KNOCKCAT**\\n\\n```\\n1. Easy C++\\n2. Line by Line Explanation with Comments.\\n3. Detailed Explanation \\u2705\\n4. Inituton is to convert target value to startvalue by dividing & addition.\\n5. Please Upvote if it helps\\u2B06\\uFE0F\\n6. Link to my Github Profile contains a repository of Leetcode with all my Solutions. \\u2B07\\uFE0F\\n\\t//\\uD83D\\uDE09If you Like the repository don\\'t foget to star & fork the repository\\uD83D\\uDE09\\n```\\n\\n[LeetCode](http://github.com/knockcat/Leetcode) **LINK TO LEETCODE REPOSITORY**\\n\\nPlease upvote my comment so that i get to win the 2022 giveaway and motivate to make such discussion post.\\n**Happy new Year 2023 to all of you**\\n**keep solving keep improving**\\nLink To comment\\n[Leetcode Give away comment](https://leetcode.com/discuss/general-discussion/2946993/2022-Annual-Badge-and-the-Giveaway/1734919)\\n\\n**ALGORITHM**\\n* The **idea is to bring target equal to startvalue** & **counting the number of operations.**\\n* We will do opposite **insitead of turning startvalue to target.**\\n* **we are turning target to startvalue by 2 steps.**\\n\\t* if **target value is odd** , we will **make it even by adding one to it.**\\n\\t* **If target is even** we will **divide by 2;**\\n\\t* and **doing these 2  operations** we will **count min operations** **till targetvalue is greater than startvalue.**\\n\\nANALYSIS:-\\n* **TIME CONPLEXITY** :- O(logn)\\n* **SPACE COMPLEXITY** :- O(1)\\n``` ``` \\n\\n* **ITERATIVE APPROACH**\\n```\\n\\t\\t// \\uD83D\\uDE09\\uD83D\\uDE09\\uD83D\\uDE09\\uD83D\\uDE09Please upvote if it helps \\uD83D\\uDE09\\uD83D\\uDE09\\uD83D\\uDE09\\uD83D\\uDE09\\nclass Solution {\\npublic:\\n    int brokenCalc(int startValue, int target) {\\n        \\n\\t\\t// res for counting number of operation\\n        int res = 0;\\n        \\n        while(target > startValue)\\n        {\\n\\t\\t\\t// if target is odd we will make it even\\n            if(target % 2)\\n                ++target;\\n\\t\\t\\t// if target is even divide by 2\\n            else\\n                target /= 2;\\n            \\n            ++res;\\n        }\\n        return res  + startValue - target;\\n    }\\n\\t// for github repository link go to my profile.\\n};\\n\\n```\\n* **RECURSIVE APPROACH**\\n```\\n\\t\\t\\t\\t// \\uD83D\\uDE09\\uD83D\\uDE09\\uD83D\\uDE09\\uD83D\\uDE09Please upvote if it helps \\uD83D\\uDE09\\uD83D\\uDE09\\uD83D\\uDE09\\uD83D\\uDE09\\nclass Solution {\\npublic:\\n    int brokenCalc(int startValue, int target) {\\n        if(startValue >= target)\\n            return startValue - target;\\n        \\n        if(target & 1)// if odd\\n            return 1 + brokenCalc(startValue, target  + 1);\\n        \\n        // if even\\n        return 1 + brokenCalc(startValue, target / 2);\\n    }\\n\\t// for github repository link go to my profile.\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Math"
                ],
                "code": "```\\n1. Easy C++\\n2. Line by Line Explanation with Comments.\\n3. Detailed Explanation \\u2705\\n4. Inituton is to convert target value to startvalue by dividing & addition.\\n5. Please Upvote if it helps\\u2B06\\uFE0F\\n6. Link to my Github Profile contains a repository of Leetcode with all my Solutions. \\u2B07\\uFE0F\\n\\t//\\uD83D\\uDE09If you Like the repository don\\'t foget to star & fork the repository\\uD83D\\uDE09\\n```\n``` ```\n```\\n\\t\\t// \\uD83D\\uDE09\\uD83D\\uDE09\\uD83D\\uDE09\\uD83D\\uDE09Please upvote if it helps \\uD83D\\uDE09\\uD83D\\uDE09\\uD83D\\uDE09\\uD83D\\uDE09\\nclass Solution {\\npublic:\\n    int brokenCalc(int startValue, int target) {\\n        \\n\\t\\t// res for counting number of operation\\n        int res = 0;\\n        \\n        while(target > startValue)\\n        {\\n\\t\\t\\t// if target is odd we will make it even\\n            if(target % 2)\\n                ++target;\\n\\t\\t\\t// if target is even divide by 2\\n            else\\n                target /= 2;\\n            \\n            ++res;\\n        }\\n        return res  + startValue - target;\\n    }\\n\\t// for github repository link go to my profile.\\n};\\n\\n```\n```\\n\\t\\t\\t\\t// \\uD83D\\uDE09\\uD83D\\uDE09\\uD83D\\uDE09\\uD83D\\uDE09Please upvote if it helps \\uD83D\\uDE09\\uD83D\\uDE09\\uD83D\\uDE09\\uD83D\\uDE09\\nclass Solution {\\npublic:\\n    int brokenCalc(int startValue, int target) {\\n        if(startValue >= target)\\n            return startValue - target;\\n        \\n        if(target & 1)// if odd\\n            return 1 + brokenCalc(startValue, target  + 1);\\n        \\n        // if even\\n        return 1 + brokenCalc(startValue, target / 2);\\n    }\\n\\t// for github repository link go to my profile.\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1076061,
                "title": "broken-calculator-js-python-java-c-simple-solution-w-detailed-explanation",
                "content": "*(Note: This is part of a series of Leetcode solution explanations ([**index**](https://dev.to/seanpgallivan/leetcode-solutions-index-57fl)). If you like this solution or find it useful,* ***please upvote*** *this post.)*\\n\\n---\\n\\n#### ***Idea:***\\n\\nThe first thing we should be able to understand is that one of the operations increases **X** while the other one decreases it. So the natural tendency is to think about the solution in terms of applying these operations in order. That is, multiply as many times as you need to before subtracting as many times as you need to.\\n\\nWe see that that\\'s not a viable solution, however, once we recognize that one of the operations is quite obviously multiplicative rather than additive, meaning that a subtraction done *before* a multiplication has twice the impact, for example.\\n\\nSo the trick here is to think of the problem backwards: moving from **Y** to **X** instead of from **X** to **Y**. If **Y** is odd, we\\'re forced to do the additive operation (reversed from the subtractive operation) as we can\\'t divide an odd number by **2** and be able to reach **X**. If **Y** is even, we can prioritize the division operation instead. At each step we can increment our **ans**.\\n\\nOnce **Y** drops below **X**, the remaining difference must be made via the additive operation, so we can just **return** that difference plus **ans**.\\n\\n**To illustrate why the backwards order leads to the correct solution**, let\\'s take a look at an example: **X = 3, Y = 13**. Under the naive approach discussed at the very beginning of this section, we could apply the multiplication operation **3** times to achieve **24**, then apply the subtraction operation **11** times to bring **Y** back down to **13**.\\n\\nAs we observed before, that **11** is not very efficient, considering that some/all of those subtraction operations could have been done before some/all of the multiplication operations with greater impact.\\n\\nSo what if we had applied as many of those operations as necessary just *before* the last of the three multiplications? Then we would only have needed **5** operations to effect **10** subtraction, plus the leftover **1** to get to **11** at the end.\\n\\nIf we go back one more step before the second of three multiplications, we could have instead done **2** operations then which would have the effect of **8** substraction, plus an extra operation after the second multiplication (adding another **2** subtraction), plus the final operation after all multiplications to reach **11**.\\n\\nThis quickly begins to represent a binary representation of our target difference of **11**:\\n```js\\n     Total multiplications:                                 In binary: (11 = 1011)\\n        3    2    1    0\\n                      11   =   11 in 11 operations                   1011   =   11\\n                  5    1   =   11 in 6 operations                 101 + 1   =   6\\n             2    1    1   =   11 in 4 operations              10 + 1 + 1   =   4\\n        1    0    1    1   =   11 in 3 operations           1 + 0 + 1 + 1   =   3\\n```\\nWe can already see that this is starting to look like our backwards approach. At each additional multiplication operation available, we\\'re forced to perform a subtraction operation if the difference is still odd, otherwise, we can divide the remainder by **2** and push it back one multiplication earlier.\\n\\nBasically, for each multiplication we need to take **X** over **Y**, we take the remaining difference, count the first bit, then shift the difference to the right. And that should sound *exactly* like our backwards approach, because the first bit is a **0** if even and **1** if odd, and shifting to the right is the same as dividing by **2**.\\n\\n**So why can\\'t we go forwards with X instead of backwards with Y?** As mentioned before, the multiplication operation is, quite obviously, multiplicative, and will have an enhancing effect on any subtraction operations performed before it. Therefore, *we cannot possibly know* how much impact any given subtraction operation will have on the difference between **X** and **Y** until we find out how many multiplication operations we will need after it.\\n\\nSo any solution involving moving **X** to **Y** would at least require \"peeking\" ahead at part of the solution before progressing with the subtraction operations.\\n\\n---\\n\\n#### ***Implementation:***\\n\\nThis solution is almost identical in all four languages.\\n\\nPython will convert our integer into a float if we simply divide by 2, so we can use the floor division operator instead to maintain the integer.\\n\\n---\\n\\n#### ***Javascript Code:***\\n\\nThe best result for the code below is **68ms / 38.2MB** (beats 100% / 90%).\\n```javascript\\nvar brokenCalc = function(X, Y) {\\n    let ans = 0\\n    while (X < Y) {\\n        ans++\\n        if (Y % 2) Y++\\n        else Y /= 2\\n    }\\n    return X - Y + ans\\n};\\n```\\n\\n---\\n\\n#### ***Python Code:***\\n\\nThe best result for the code below is **20ms / 14.1MB** (beats 99% / 90%).\\n```python\\nclass Solution:\\n    def brokenCalc(self, X: int, Y: int) -> int:\\n        ans = 0\\n        while X < Y:\\n            ans += 1\\n            if Y % 2: Y += 1\\n            else: Y //= 2\\n        return X - Y + ans\\n```\\n\\n---\\n\\n#### ***Java Code:***\\n\\nThe best result for the code below is **0ms / 35.4MB** (beats 100% / 98%).\\n```java\\nclass Solution {\\n    public int brokenCalc(int X, int Y) {\\n        int ans = 0;\\n        while (X < Y) {\\n            ans++;\\n            if (Y % 2 > 0) Y++;\\n            else Y /= 2;\\n        }\\n        return X - Y + ans;\\n    }\\n}\\n```\\n\\n---\\n\\n#### ***C++ Code:***\\n\\nThe best result for the code below is **0ms / 5.8MB** (beats 100% / 81%).\\n```c++\\nclass Solution {\\npublic:\\n    int brokenCalc(int X, int Y) {\\n        int ans = 0;\\n        while (X < Y) {\\n            ans++;\\n            if (Y % 2) Y++;\\n            else Y /= 2;\\n        }\\n        return X - Y + ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```js\\n     Total multiplications:                                 In binary: (11 = 1011)\\n        3    2    1    0\\n                      11   =   11 in 11 operations                   1011   =   11\\n                  5    1   =   11 in 6 operations                 101 + 1   =   6\\n             2    1    1   =   11 in 4 operations              10 + 1 + 1   =   4\\n        1    0    1    1   =   11 in 3 operations           1 + 0 + 1 + 1   =   3\\n```\n```javascript\\nvar brokenCalc = function(X, Y) {\\n    let ans = 0\\n    while (X < Y) {\\n        ans++\\n        if (Y % 2) Y++\\n        else Y /= 2\\n    }\\n    return X - Y + ans\\n};\\n```\n```python\\nclass Solution:\\n    def brokenCalc(self, X: int, Y: int) -> int:\\n        ans = 0\\n        while X < Y:\\n            ans += 1\\n            if Y % 2: Y += 1\\n            else: Y //= 2\\n        return X - Y + ans\\n```\n```java\\nclass Solution {\\n    public int brokenCalc(int X, int Y) {\\n        int ans = 0;\\n        while (X < Y) {\\n            ans++;\\n            if (Y % 2 > 0) Y++;\\n            else Y /= 2;\\n        }\\n        return X - Y + ans;\\n    }\\n}\\n```\n```c++\\nclass Solution {\\npublic:\\n    int brokenCalc(int X, int Y) {\\n        int ans = 0;\\n        while (X < Y) {\\n            ans++;\\n            if (Y % 2) Y++;\\n            else Y /= 2;\\n        }\\n        return X - Y + ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1076042,
                "title": "python-c-explanation-with-illustration-why-we-should-work-with-y-not-x",
                "content": "Most obvious algorithm would be to count `steps` and do `X *= 2` when `X < Y` and `X -= 1` when `X > Y`, and return `steps` when `X == Y`.\\nEvery time when `X < Y` and we want to double `X`  we need to think, would it be better to subtract one, so when we will get `X > Y`, the difference will be smaller. Here is illustration with `X = 4, Y = 17`:\\nBlue \\u2013 primitive way\\nRed \\u2013 smart way\\n\\n![image](https://assets.leetcode.com/users/images/cf8686ad-3101-4a6c-8309-fac122186e9c_1613898000.5730617.png)\\n\\nHere we see that smart logic for working with `X` not clear, we will need to calculate something ahead to decide should we actually `X -= 1` or `X *= 2` even if `X < Y`, **but** from `Y` perspective everything is quite simple:\\nWe **always** divide `Y` by 2, if `Y > X` **and** `Y % 2 == 0` (can be divided by `2`), \\nand simply add `1` if `Y < X` or if `Y > X` **but** `Y % 2 == 1`. \\n\\nPython Code:\\n```\\nclass Solution:\\n  def brokenCalc(self, x: int, y: int) -> int:\\n    steps = 0\\n    while y > x:\\n      steps += 1 + y % 2 # if y not divisible do 1 extra step (add one to y)\\n      y += y % 2 # if y not divisible add one to y\\n      y //= 2\\n        \\n    return steps + (x - y)\\n```\\n\\nC++ Code:\\n```\\nclass Solution {\\n  public:\\n    int brokenCalc(int x, int y) {\\n      int steps = 0;\\n      while (y > x) {\\n        steps += 1 + y % 2; // if y not divisible do 1 extra step (add one to y)\\n        y += y % 2; // if y not divisible add one to y\\n        y /= 2;\\n      }\\n      return steps + (x - y);\\n    }\\n};\\n```",
                "solutionTags": [
                    "Python",
                    "C"
                ],
                "code": "```\\nclass Solution:\\n  def brokenCalc(self, x: int, y: int) -> int:\\n    steps = 0\\n    while y > x:\\n      steps += 1 + y % 2 # if y not divisible do 1 extra step (add one to y)\\n      y += y % 2 # if y not divisible add one to y\\n      y //= 2\\n        \\n    return steps + (x - y)\\n```\n```\\nclass Solution {\\n  public:\\n    int brokenCalc(int x, int y) {\\n      int steps = 0;\\n      while (y > x) {\\n        steps += 1 + y % 2; // if y not divisible do 1 extra step (add one to y)\\n        y += y % 2; // if y not divisible add one to y\\n        y /= 2;\\n      }\\n      return steps + (x - y);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 234791,
                "title": "c-solution-o-n-time-and-o-1-space-using-greedy-algorithm-with-explanation",
                "content": "```\\nclass Solution {\\npublic:\\n    int brokenCalc(int X, int Y) {\\n        if(X > Y){ return X - Y; }\\n        \\n        int num_ops = 0;\\n        int mult = 1;\\n        while(X < Y){\\n            X *= 2;\\n            mult *= 2;\\n            num_ops++;\\n        }\\n        \\n        int diff = X - Y;\\n        while(diff != 0){\\n            if(diff - mult < 0){\\n                mult /= 2;\\n            }\\n            else{\\n                diff -= mult;\\n                num_ops++;\\n            }\\n        }\\n        return num_ops;\\n    }\\n};\\n```\\n\\n**The underlying concept of this solution is based on the following observations**:\\n\\n1. The only way to increment a X towards Y is to double\\n2. The fastest way to decrement X towards Y is to decrement by 1 before doubling some number of times.\\n\\nFor example, if given `X = 7` and `Y = 19`,\\n\\n```\\n7 * 2 * 2 = 28 >= 19\\n```\\n\\nWe intuitively see that at least 2 doublings are required to get `X > Y`. At this point, a possible solution could be to decrement 9 times, however it would be **faster if we could decrement before doubling**.\\n\\nConsider these two cases:\\n```\\nA. (7 - 1) * 2 * 2 = 24\\nB. (7 * 2 - 1) * 2 = 26\\n```\\n\\nNotice that in case `A`, we **save** 2 decrements, but in case `B` we save 4 decrements. **This can be seen by comparing the differences**. The amount we **save** is equal to `2^(number of doublings that occured since decrementing)`.\\n\\nSince we are required to double until `X > Y`, the **minimum number of operations results from decrementing as much as possible, as early as possible**.\\n\\nThe steps are summarized as follows:\\n\\n1. Double X until it is greater than Y and take the difference (`diff`) between X and Y, while keeping track of how many times you doubled (`mult = 2^(number of doublings until X > Y)`)\\n\\n\\n2. Subtract `mult` from `diff` until it `diff - mult < 0`, then divide `mult` by 2 and repeat this process. This will continue until `diff = 0` (We are calculating the minimum number of decrements needed).\\n\\n\\n3. Return `(number of doublings) + (number of times mult is subtracted from diff)`\\n\\n\\n**Example**: `X = 7, Y = 19`\\n```\\n1. We need to double 2 times\\n7 * 2 * 2 > 19 \\ndiff = 28 - 19 = 9\\nmult = 2 * 2 (2 doublings necessary for X > Y)\\n\\n2. We need to decrement 3 times (mult is subtracted from diff 3 times)\\n9 - 4 - 4 - 1 = 0\\n\\n3. We return 2 + 3 = 5\\n```",
                "solutionTags": [
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int brokenCalc(int X, int Y) {\\n        if(X > Y){ return X - Y; }\\n        \\n        int num_ops = 0;\\n        int mult = 1;\\n        while(X < Y){\\n            X *= 2;\\n            mult *= 2;\\n            num_ops++;\\n        }\\n        \\n        int diff = X - Y;\\n        while(diff != 0){\\n            if(diff - mult < 0){\\n                mult /= 2;\\n            }\\n            else{\\n                diff -= mult;\\n                num_ops++;\\n            }\\n        }\\n        return num_ops;\\n    }\\n};\\n```\n```\\n7 * 2 * 2 = 28 >= 19\\n```\n```\\nA. (7 - 1) * 2 * 2 = 24\\nB. (7 * 2 - 1) * 2 = 26\\n```\n```\\n1. We need to double 2 times\\n7 * 2 * 2 > 19 \\ndiff = 28 - 19 = 9\\nmult = 2 * 2 (2 doublings necessary for X > Y)\\n\\n2. We need to decrement 3 times (mult is subtracted from diff 3 times)\\n9 - 4 - 4 - 1 = 0\\n\\n3. We return 2 + 3 = 5\\n```",
                "codeTag": "Java"
            },
            {
                "id": 234526,
                "title": "simple-recursive-solution-considering-only-last-bit-and-proof-why-it-s-guranteed-shortest-path",
                "content": "```\\npublic int brokenCalc(int X, int Y) {\\n        if (X>=Y) return X-Y;\\n        return (Y&1)==0? 1+brokenCalc(X, Y/2):1+brokenCalc(X, Y+1);\\n        \\n}\\n```\\n\\nSo we check only the last bit of Y, since doubling and -1 can only alter (directly) one bit.\\n\\nif last bit of Y is 0, the last operation must be doubling, we trace back to Y/2\\nif last bit of Y is 1, the last operation must be decrement, we trace back to Y+1\\n\\nTrying to prove that the **if last bit of Y is 0, the last operation must be doubling**:\\n\\n **hypothesis**: there can be one or more decrement from Y+1 to Y in the shortest path, where last bit of Y is 0\\n- since last bit of Y+1 is 1, it must be decrement from Y+2(doubling can never make an 1 on last bit)\\n- two options at Y+2.\\n1. decrement from Y+3, it\\'s the same as the starting point Y+1 and Y;\\n2. doubling from (Y+2)/2, three moves used from (Y+2)/2 to Y: double to Y+2, decrement to Y+1, decrement to Y, while there is a shorter path: decrement to Y/2, double to Y\\n\\n- there we get a contradiction to the hypothesis\\n- so the hypothesis is false\\nhence, **there can be none decrement move(s) from Y+1 to Y in the shortest path if last bit of Y is 0**",
                "solutionTags": [],
                "code": "```\\npublic int brokenCalc(int X, int Y) {\\n        if (X>=Y) return X-Y;\\n        return (Y&1)==0? 1+brokenCalc(X, Y/2):1+brokenCalc(X, Y+1);\\n        \\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1076063,
                "title": "js-python-java-c-simple-solution-w-detailed-explanation-beats-100",
                "content": "*(Note: This is part of a series of Leetcode solution explanations ([**index**](https://dev.to/seanpgallivan/leetcode-solutions-index-57fl)). If you like this solution or find it useful,* ***please upvote*** *this post.)*\\n\\n---\\n\\n#### ***Idea:***\\n\\nThe first thing we should be able to understand is that one of the operations increases **X** while the other one decreases it. So the natural tendency is to think about the solution in terms of applying these operations in order. That is, multiply as many times as you need to before subtracting as many times as you need to.\\n\\nWe see that that\\'s not a viable solution, however, once we recognize that one of the operations is quite obviously multiplicative rather than additive, meaning that a subtraction done *before* a multiplication has twice the impact, for example.\\n\\nSo the trick here is to think of the problem backwards: moving from **Y** to **X** instead of from **X** to **Y**. If **Y** is odd, we\\'re forced to do the additive operation (reversed from the subtractive operation) as we can\\'t divide an odd number by **2** and be able to reach **X**. If **Y** is even, we can prioritize the division operation instead. At each step we can increment our **ans**.\\n\\nOnce **Y** drops below **X**, the remaining difference must be made via the additive operation, so we can just **return** that difference plus **ans**.\\n\\n**To illustrate why the backwards order leads to the correct solution**, let\\'s take a look at an example: **X = 3, Y = 13**. Under the naive approach discussed at the very beginning of this section, we could apply the multiplication operation **3** times to achieve **24**, then apply the subtraction operation **11** times to bring **Y** back down to **13**.\\n\\nAs we observed before, that **11** is not very efficient, considering that some/all of those subtraction operations could have been done before some/all of the multiplication operations with greater impact.\\n\\nSo what if we had applied as many of those operations as necessary just *before* the last of the three multiplications? Then we would only have needed **5** operations to effect **10** subtraction, plus the leftover **1** to get to **11** at the end.\\n\\nIf we go back one more step before the second of three multiplications, we could have instead done **2** operations then which would have the effect of **8** substraction, plus an extra operation after the second multiplication (adding another **2** subtraction), plus the final operation after all multiplications to reach **11**.\\n\\nThis quickly begins to represent a binary representation of our target difference of **11**:\\n```js\\n     Total multiplications:                                 In binary: (11 = 1011)\\n        3    2    1    0\\n                      11   =   11 in 11 operations                   1011   =   11\\n                  5    1   =   11 in 6 operations                 101 + 1   =   6\\n             2    1    1   =   11 in 4 operations              10 + 1 + 1   =   4\\n        1    0    1    1   =   11 in 3 operations           1 + 0 + 1 + 1   =   3\\n```\\nWe can already see that this is starting to look like our backwards approach. At each additional multiplication operation available, we\\'re forced to perform a subtraction operation if the difference is still odd, otherwise, we can divide the remainder by **2** and push it back one multiplication earlier.\\n\\nBasically, for each multiplication we need to take **X** over **Y**, we take the remaining difference, count the first bit, then shift the difference to the right. And that should sound *exactly* like our backwards approach, because the first bit is a **0** if even and **1** if odd, and shifting to the right is the same as dividing by **2**.\\n\\n**So why can\\'t we go forwards with X instead of backwards with Y?** As mentioned before, the multiplication operation is, quite obviously, multiplicative, and will have an enhancing effect on any subtraction operations performed before it. Therefore, *we cannot possibly know* how much impact any given subtraction operation will have on the difference between **X** and **Y** until we find out how many multiplication operations we will need after it.\\n\\nSo any solution involving moving **X** to **Y** would at least require \"peeking\" ahead at part of the solution before progressing with the subtraction operations.\\n\\n---\\n\\n#### ***Implementation:***\\n\\nThis solution is almost identical in all four languages.\\n\\nPython will convert our integer into a float if we simply divide by 2, so we can use the floor division operator instead to maintain the integer.\\n\\n---\\n\\n#### ***Javascript Code:***\\n\\nThe best result for the code below is **68ms / 38.2MB** (beats 100% / 90%).\\n```javascript\\nvar brokenCalc = function(X, Y) {\\n    let ans = 0\\n    while (X < Y) {\\n        ans++\\n        if (Y % 2) Y++\\n        else Y /= 2\\n    }\\n    return X - Y + ans\\n};\\n```\\n\\n---\\n\\n#### ***Python Code:***\\n\\nThe best result for the code below is **20ms / 14.1MB** (beats 99% / 90%).\\n```python\\nclass Solution:\\n    def brokenCalc(self, X: int, Y: int) -> int:\\n        ans = 0\\n        while X < Y:\\n            ans += 1\\n            if Y % 2: Y += 1\\n            else: Y //= 2\\n        return X - Y + ans\\n```\\n\\n---\\n\\n#### ***Java Code:***\\n\\nThe best result for the code below is **0ms / 35.4MB** (beats 100% / 98%).\\n```java\\nclass Solution {\\n    public int brokenCalc(int X, int Y) {\\n        int ans = 0;\\n        while (X < Y) {\\n            ans++;\\n            if (Y % 2 > 0) Y++;\\n            else Y /= 2;\\n        }\\n        return X - Y + ans;\\n    }\\n}\\n```\\n\\n---\\n\\n#### ***C++ Code:***\\n\\nThe best result for the code below is **0ms / 5.8MB** (beats 100% / 81%).\\n```c++\\nclass Solution {\\npublic:\\n    int brokenCalc(int X, int Y) {\\n        int ans = 0;\\n        while (X < Y) {\\n            ans++;\\n            if (Y % 2) Y++;\\n            else Y /= 2;\\n        }\\n        return X - Y + ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Java",
                    "Python",
                    "C",
                    "JavaScript"
                ],
                "code": "```js\\n     Total multiplications:                                 In binary: (11 = 1011)\\n        3    2    1    0\\n                      11   =   11 in 11 operations                   1011   =   11\\n                  5    1   =   11 in 6 operations                 101 + 1   =   6\\n             2    1    1   =   11 in 4 operations              10 + 1 + 1   =   4\\n        1    0    1    1   =   11 in 3 operations           1 + 0 + 1 + 1   =   3\\n```\n```javascript\\nvar brokenCalc = function(X, Y) {\\n    let ans = 0\\n    while (X < Y) {\\n        ans++\\n        if (Y % 2) Y++\\n        else Y /= 2\\n    }\\n    return X - Y + ans\\n};\\n```\n```python\\nclass Solution:\\n    def brokenCalc(self, X: int, Y: int) -> int:\\n        ans = 0\\n        while X < Y:\\n            ans += 1\\n            if Y % 2: Y += 1\\n            else: Y //= 2\\n        return X - Y + ans\\n```\n```java\\nclass Solution {\\n    public int brokenCalc(int X, int Y) {\\n        int ans = 0;\\n        while (X < Y) {\\n            ans++;\\n            if (Y % 2 > 0) Y++;\\n            else Y /= 2;\\n        }\\n        return X - Y + ans;\\n    }\\n}\\n```\n```c++\\nclass Solution {\\npublic:\\n    int brokenCalc(int X, int Y) {\\n        int ans = 0;\\n        while (X < Y) {\\n            ans++;\\n            if (Y % 2) Y++;\\n            else Y /= 2;\\n        }\\n        return X - Y + ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1075986,
                "title": "c-simple-short-solution-o-logn-time-o-1-space-0-ms-faster-than-100",
                "content": "We are doing the opposite - instead of turning X into Y by multiplying/subtracting, we are turning Y into X by doing the opposite operations - adding/dividing.\\n```\\nclass Solution {\\npublic:\\n    int brokenCalc(int X, int Y) {\\n        int res = 0;\\n        while (Y > X) {\\n            \\n            if (Y % 2) \\n                Y++;\\n            \\n            else \\n                Y /= 2;\\n            \\n            res++;\\n        }\\n        return res + X - Y;\\n    }\\n};\\n```\\n**Like it? please upvote...**",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int brokenCalc(int X, int Y) {\\n        int res = 0;\\n        while (Y > X) {\\n            \\n            if (Y % 2) \\n                Y++;\\n            \\n            else \\n                Y /= 2;\\n            \\n            res++;\\n        }\\n        return res + X - Y;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 234476,
                "title": "simple-java-why-to-go-towards-x",
                "content": "To get minimal steps, we can think of covering distance by taking maximum jumps towards Y and then come back. But this doesn\\u2019t give minimum steps to us.\\nAs we keep jumping towards right, our jump size keeps doubling. We can end up jumping very far away from Y in last jump  and we can loose minimal steps.\\n\\nBut if we go back, from Y to X, then \\n(1.) we would have utilised our biggest jump i.e. last jump to reach Y. And \\n(2.) our jump size also keeps decreasing, so even if we land very far way to left of X, then also it would give us minimal steps when we move forward to Y.\\n\\n**Recursive**\\n```\\n    public int brokenCalc(int X, int Y) {\\n        if(Y <= X) return X-Y;\\n        return 1 + (Y % 2 == 0 ? brokenCalc(X, Y/2) : brokenCalc(X, Y + 1));\\n    }\\n```\\n**Iterative**\\n```\\n    public int brokenCalc(int X, int Y) {\\n        int ans = 0;\\n        for(; Y > X ;  Y = Y % 2 > 0 ? Y + 1 : Y / 2, ans++);\\n        return (ans + X - Y);\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    public int brokenCalc(int X, int Y) {\\n        if(Y <= X) return X-Y;\\n        return 1 + (Y % 2 == 0 ? brokenCalc(X, Y/2) : brokenCalc(X, Y + 1));\\n    }\\n```\n```\\n    public int brokenCalc(int X, int Y) {\\n        int ans = 0;\\n        for(; Y > X ;  Y = Y % 2 > 0 ? Y + 1 : Y / 2, ans++);\\n        return (ans + X - Y);\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1874898,
                "title": "rust-o-1-space-and-o-1-time-explained",
                "content": "```rust\\nimpl Solution {\\n    pub fn broken_calc(start_value: i32, target: i32) -> i32 {\\n        // Find the smallest number of doubling needed to get start_value > target.\\n        // * `(target - 1) / start_value` is the largest multiple of target that is less than start_value\\n        // * `31 - (...).leading_zeros()` is the flooring log2 of the value.\\n        // This gives the largest number of doubling possible before start_value > target.\\n        // Plus 1 to get the smallest number of doubling needed.\\n        let m = 32 - ((target - 1) / start_value).leading_zeros() as i32;\\n        // This is the \"overshoot\" by doubling, which we need to subtract away\\n        let diff = (start_value << m) - target;\\n        // Now we look at bits.\\n        // * If bit i is 1, then we can do a subtraction before the i-th doubling (counting from back)\\n        // * E.g. if bit 0 is 1, then we do a subtraction after all doublings\\n        // * If bit 1 is 1, then we do a subtraction before the last doubling\\n        // * If bit 2 is 1, then we do a subtraction before the last two doublings\\n        // * ...\\n        // * If bit m is 1, then we do a subtraction before the first doubling.\\n        // However if bit m+1 or higher is 1, then we can\\'t go back further, so we need to subtract them from the start.\\n        // The `diff >> m` part accounts for this, and this is the doublings we need to do before doublings.\\n        // The `(diff & ((1 << m) - 1)).count_ones()` just counts the number of subtractions that we do in between or after all doublings.\\n        // Finally, add `m` which is the number of doubling operation, we get the final answer\\n        (diff >> m) + (diff & ((1 << m) - 1)).count_ones() as i32 + m\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```rust\\nimpl Solution {\\n    pub fn broken_calc(start_value: i32, target: i32) -> i32 {\\n        // Find the smallest number of doubling needed to get start_value > target.\\n        // * `(target - 1) / start_value` is the largest multiple of target that is less than start_value\\n        // * `31 - (...).leading_zeros()` is the flooring log2 of the value.\\n        // This gives the largest number of doubling possible before start_value > target.\\n        // Plus 1 to get the smallest number of doubling needed.\\n        let m = 32 - ((target - 1) / start_value).leading_zeros() as i32;\\n        // This is the \"overshoot\" by doubling, which we need to subtract away\\n        let diff = (start_value << m) - target;\\n        // Now we look at bits.\\n        // * If bit i is 1, then we can do a subtraction before the i-th doubling (counting from back)\\n        // * E.g. if bit 0 is 1, then we do a subtraction after all doublings\\n        // * If bit 1 is 1, then we do a subtraction before the last doubling\\n        // * If bit 2 is 1, then we do a subtraction before the last two doublings\\n        // * ...\\n        // * If bit m is 1, then we do a subtraction before the first doubling.\\n        // However if bit m+1 or higher is 1, then we can\\'t go back further, so we need to subtract them from the start.\\n        // The `diff >> m` part accounts for this, and this is the doublings we need to do before doublings.\\n        // The `(diff & ((1 << m) - 1)).count_ones()` just counts the number of subtractions that we do in between or after all doublings.\\n        // Finally, add `m` which is the number of doubling operation, we get the final answer\\n        (diff >> m) + (diff & ((1 << m) - 1)).count_ones() as i32 + m\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1076045,
                "title": "c-recursive-iterative-o-min-operations-0ms-beats-100-explanation",
                "content": "**EXPLANATION**\\nFor finding the **minimum operations** needed to change `X` to `Y`, we need to look at the question in an *opposite perspective*. Here, we will be modifying `Y` not `X` so we need to do operations in `Y` exactly opposite to those which we are supposed to do in `X`. Let us consider some *facts*:\\n1. Doing `X*2` is the opposite of doing `Y/2`. Similarly, `X-1` is opposite of `Y+1`.\\n2. If `X>Y`, then the only way to change `X` to `Y` is by **subtraction**, so we need to do exactly `X-Y` subtraction for achieving that.\\n3.  If `X<Y`, then we need to consider two cases:\\n\\t\\t- If `Y` is **odd** then we need to use the **subtraction** operation in X, that is `X-1` whose opposite operation is `Y+1` (Using 1).\\n\\t\\t- If `Y` is **even** then we need to use the **multiplication** operation in X, that is `X*2` whose opposite operation is `Y/2` (Using 1).\\n\\nNow, considering all the above facts we will solve the problem using **recursive** and **iterative** approaches as shown below.\\n\\n\\n**RECURSIVE APPROACH**\\n```\\nclass Solution {\\npublic:\\n    int brokenCalc(int X, int Y) {\\n        if(X==Y) return 0; // no operation required as X and Y are already same\\n        \\n        if(X>Y) return X-Y; // only way to change X to Y is by subtraction\\n        \\n        if(Y % 2){ // Y is odd\\n \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0// do (opposite operation to X-1) or Y+1\\n            return 1 + brokenCalc(X, Y+1); \\n        }\\n        else{ // Y is even\\n \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0// do (opposite operarion of X*2) or Y/2\\n            return 1 + brokenCalc(X, Y>>1); // Y/2 same as Y>>1\\n        }\\n    }\\n};\\n```\\n\\nConsidering, **n=minimum operations needed to change `X` to `Y`**\\n**TIME COMPLEXITY**\\n**O(n)**\\n\\n**SPACE COMPLEXITY**\\n**O(n)**\\n\\n\\n**ITERATIVE APPROACH (No extra space)**\\n```\\nclass Solution {\\npublic:\\n    int brokenCalc(int X, int Y) {\\n        int ans=0;\\n        while(X<Y){\\n            if(Y % 2){ // Y is odd\\n                // do (opposite operation to X-1) or Y+1\\n                ++Y;\\n                ++ans;\\n            }\\n            else{ // Y is even\\n                // do (opposite operarion of X*2) or Y/2\\n                Y=Y>>1; // Y/2 same as Y>>1\\n                ++ans;\\n            }    \\n        }\\n        return ans+X-Y; // if X>Y then the only way to change X to Y is by subtraction\\n    }\\n};\\n```\\n\\nConsidering, **n=minimum operations needed to change `X` to `Y`**\\n**TIME COMPLEXITY**\\n**O(n)**\\n\\n**SPACE COMPLEXITY**\\n**O(1)**",
                "solutionTags": [
                    "C",
                    "Math",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int brokenCalc(int X, int Y) {\\n        if(X==Y) return 0; // no operation required as X and Y are already same\\n        \\n        if(X>Y) return X-Y; // only way to change X to Y is by subtraction\\n        \\n        if(Y % 2){ // Y is odd\\n \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0// do (opposite operation to X-1) or Y+1\\n            return 1 + brokenCalc(X, Y+1); \\n        }\\n        else{ // Y is even\\n \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0// do (opposite operarion of X*2) or Y/2\\n            return 1 + brokenCalc(X, Y>>1); // Y/2 same as Y>>1\\n        }\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int brokenCalc(int X, int Y) {\\n        int ans=0;\\n        while(X<Y){\\n            if(Y % 2){ // Y is odd\\n                // do (opposite operation to X-1) or Y+1\\n                ++Y;\\n                ++ans;\\n            }\\n            else{ // Y is even\\n                // do (opposite operarion of X*2) or Y/2\\n                Y=Y>>1; // Y/2 same as Y>>1\\n                ++ans;\\n            }    \\n        }\\n        return ans+X-Y; // if X>Y then the only way to change X to Y is by subtraction\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1875839,
                "title": "c-6-line-simple-code-easy-to-understand-tc-o-log-n-sc-o-1",
                "content": "#### *Please Upvote if it helps\\u2B06\\uFE0F*\\n```\\nint brokenCalc(int startValue, int target) {\\n        int ans=0;\\n        while(target!=startValue){\\n            if(target<startValue || target%2) target++;\\n            else target/=2;\\n            ans++;\\n        }\\n        return ans;\\n    }",
                "solutionTags": [
                    "C",
                    "Greedy"
                ],
                "code": "#### *Please Upvote if it helps\\u2B06\\uFE0F*\\n```\\nint brokenCalc(int startValue, int target) {\\n        int ans=0;\\n        while(target!=startValue){\\n            if(target<startValue || target%2) target++;\\n            else target/=2;\\n            ans++;\\n        }\\n        return ans;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1875304,
                "title": "java-easy-to-understand-beginner-friendly-with-explanation",
                "content": "try doing this for many inputs, u will find a pattern :-\\nwhen target is even then we can reduce steps by making it target/2;\\nwhen target is odd we have to find the even number which is close to target, in which we can perform our operation ie target-1.\\nwhen target is less than start then we simply return start - target \\nExample:- start= 3, target = 2\\nwe can simply perform start -1 to reach target.\\n```\\nclass Solution {\\n    public int brokenCalc(int start, int target) { \\n        if(target < start)\\n            return start-target;\\n        if(start == target)\\n            return 0;\\n        int ans =0;\\n        if(target > 0 && target%2 == 0)\\n            ans = 1+brokenCalc(start,target/2);\\n        else    ans = 1+ brokenCalc(start,target+1);\\n        return ans;\\n    }\\n}\\n```\\nPlease upvote if u find my code easy to understand",
                "solutionTags": [
                    "Java",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n    public int brokenCalc(int start, int target) { \\n        if(target < start)\\n            return start-target;\\n        if(start == target)\\n            return 0;\\n        int ans =0;\\n        if(target > 0 && target%2 == 0)\\n            ans = 1+brokenCalc(start,target/2);\\n        else    ans = 1+ brokenCalc(start,target+1);\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1874888,
                "title": "notagenius-recursive-3-line-solution-iterative-that-uses-less-memory-multilanguage",
                "content": "Hi everyone! I hope you are enjoying coding every day.\\n\\nQuick post today, the non-genius approach as always!\\n\\n- We can model this as BSF or DSF, at every step the game branches by subtracting 1 or multiplying by 2. Of course this is exponential. We also need to take care of loops. It\\'s a path forward, but given that the problem restriction marks target being as high as 1_000_000_000, we are encouraged to find something faster.\\n- My first realization is that if we work backwards from the result we can cut some branches, as you cannot always divide by 2 and keep the current value an integer. Wrking backwards means dividing the target by 2 or adding 1 to the target, rather than multiplying the start by 2, or subtracting 1 from start.\\n- There are no restrictions on startValue or target being greater or lower than the other one. When startValue is greater than target though, you can only get there by subtracting (working forward, or adding working backward). In that case, the result is just adding/subtracting n times, or put another way, startValue-target.\\n- Since we are trying to make target as close as possible as startValue, when we can, we will always divide, as adding 1 will make them further apart.\\n- Sometimes though we need to add 1 as it\\'s the only way to make progress.\\n- So we get to the algorithm:\\n\\t- If startValue >= target, we just return startValue-target\\n\\t- Else when we can, we divide the target by 2 and try again\\n\\t- If we cannot divide by 2, we can just add 1 to target and try again\\n\\nAnd here is the code:\\n\\n```java\\nclass Solution {\\n    public int brokenCalc(int startValue, int target) {\\n        if (startValue >= target) return startValue-target;\\n        if (target % 2 == 0) return 1 + brokenCalc(startValue, target/2);\\n        else return 1 + brokenCalc(startValue, target + 1);\\n    }\\n}\\n```\\n\\n**Runtime: 0 ms, faster than 100.00% of Java online submissions for Broken Calculator.**\\n\\nThis is O(logn) time and O(logn) memory. From here you can go to iterative if you want to save memory.\\n\\n```java\\nclass Solution {\\n    public int brokenCalc(int startValue, int target) {\\n        int result = 0;\\n        while (true) {\\n            if (startValue >= target) return result+startValue-target;\\n            if (target % 2 == 0) {\\n                result++; \\n                target /= 2;\\n            }\\n            else {\\n                result++;\\n                target++;\\n            }\\n        }\\n    }\\n}\\n```\\n\\nOr the more concise\\n\\n```java\\nclass Solution {\\n    public int brokenCalc(int startValue, int target) {\\n        int result = 0;\\n        while (true) {\\n            if (startValue >= target) return result+startValue-target;\\n            result++;\\n            if (target % 2 == 0) target /= 2;\\n            else target++;\\n        }\\n    }\\n}\\n```\\n\\n\\nOr if you are afraid of `while(true)`\\n\\n```java\\nclass Solution {\\n    public int brokenCalc(int startValue, int target) {\\n        int result = 0;\\n        while (startValue < target) {\\n            result++;\\n            if (target % 2 == 0) target /= 2;\\n            else target++;\\n        }\\n        return result+startValue-target;\\n    }\\n}\\n```\\n\\n**Runtime: 0 ms, faster than 100.00% of Java online submissions for Broken Calculator.**\\n\\nThis is O(logn) time and O(1) memory.\\n\\nBonus track:\\n\\nC++:\\n\\n```cpp\\nclass Solution {\\npublic:\\n    int brokenCalc(int startValue, int target) {\\n        int result = 0;\\n        while (startValue < target) {\\n            result++;\\n            if (target % 2 == 0) target /= 2;\\n            else target++;\\n        }\\n        return result+startValue-target;\\n    }\\n};\\n```\\n\\nPython:\\n\\n```py\\nclass Solution(object):\\n    def brokenCalc(self, startValue, target):\\n        result = 0;\\n        while (startValue < target) :\\n            result+=1;\\n            if target % 2 == 0: target = target/2;\\n            else: target+=1;\\n        return result+startValue-target;\\n```\\n\\nRuby:\\n\\n```ruby\\ndef broken_calc(start_value, target)\\n    result = 0;\\n    while start_value < target\\n        result+=1;\\n        if target % 2 == 0 then target = target/2;\\n        else target+=1;\\n        end\\n    end\\n    return result+start_value-target\\nend\\n```\\n\\nGo:\\n\\n```go\\nfunc brokenCalc(startValue int, target int) int {\\n    var result = 0;\\n    for startValue < target {\\n        result++;\\n        if target % 2 == 0 {\\n            target /= 2\\n        } else {\\n            target++\\n        }\\n    }\\n    return result+startValue-target;\\n}\\n```\\n\\nHave fun!!",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "Ruby",
                    "Go"
                ],
                "code": "```java\\nclass Solution {\\n    public int brokenCalc(int startValue, int target) {\\n        if (startValue >= target) return startValue-target;\\n        if (target % 2 == 0) return 1 + brokenCalc(startValue, target/2);\\n        else return 1 + brokenCalc(startValue, target + 1);\\n    }\\n}\\n```\n```java\\nclass Solution {\\n    public int brokenCalc(int startValue, int target) {\\n        int result = 0;\\n        while (true) {\\n            if (startValue >= target) return result+startValue-target;\\n            if (target % 2 == 0) {\\n                result++; \\n                target /= 2;\\n            }\\n            else {\\n                result++;\\n                target++;\\n            }\\n        }\\n    }\\n}\\n```\n```java\\nclass Solution {\\n    public int brokenCalc(int startValue, int target) {\\n        int result = 0;\\n        while (true) {\\n            if (startValue >= target) return result+startValue-target;\\n            result++;\\n            if (target % 2 == 0) target /= 2;\\n            else target++;\\n        }\\n    }\\n}\\n```\n```java\\nclass Solution {\\n    public int brokenCalc(int startValue, int target) {\\n        int result = 0;\\n        while (startValue < target) {\\n            result++;\\n            if (target % 2 == 0) target /= 2;\\n            else target++;\\n        }\\n        return result+startValue-target;\\n    }\\n}\\n```\n```cpp\\nclass Solution {\\npublic:\\n    int brokenCalc(int startValue, int target) {\\n        int result = 0;\\n        while (startValue < target) {\\n            result++;\\n            if (target % 2 == 0) target /= 2;\\n            else target++;\\n        }\\n        return result+startValue-target;\\n    }\\n};\\n```\n```py\\nclass Solution(object):\\n    def brokenCalc(self, startValue, target):\\n        result = 0;\\n        while (startValue < target) :\\n            result+=1;\\n            if target % 2 == 0: target = target/2;\\n            else: target+=1;\\n        return result+startValue-target;\\n```\n```ruby\\ndef broken_calc(start_value, target)\\n    result = 0;\\n    while start_value < target\\n        result+=1;\\n        if target % 2 == 0 then target = target/2;\\n        else target+=1;\\n        end\\n    end\\n    return result+start_value-target\\nend\\n```\n```go\\nfunc brokenCalc(startValue int, target int) int {\\n    var result = 0;\\n    for startValue < target {\\n        result++;\\n        if target % 2 == 0 {\\n            target /= 2\\n        } else {\\n            target++\\n        }\\n    }\\n    return result+startValue-target;\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1875316,
                "title": "c-recursive-approach-easy-to-understand-with-explanation",
                "content": "**PLEASE UPVOTE IF IT HELPS YOU**\\n``` \\n **APPROACH**\\n \\n1. instead of going towards the target we will make target to move toward start value ie we will do just opposite of what said in question.\\n2. we will check if the target value is even than we will divide it by two\\n3. else we will increment it by 1.\\n4. this process continues untill the target than startvalue \\n5. if startvalue became greater than target than we will just increment target value by 1 untill it became equals to 1.\\n```\\n```\\nclass Solution {\\npublic:\\n    int brokenCalc(int start, int target) {\\n        \\n        \\n        if(start >= target)\\n            return start-target;\\n\\t\\t\\n        return 1 + (target%2 == 0 ? brokenCalc(start, target/2) : brokenCalc(start, target+1));\\n    \\n        \\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C",
                    "Greedy",
                    "Recursion"
                ],
                "code": "``` \\n **APPROACH**\\n \\n1. instead of going towards the target we will make target to move toward start value ie we will do just opposite of what said in question.\\n2. we will check if the target value is even than we will divide it by two\\n3. else we will increment it by 1.\\n4. this process continues untill the target than startvalue \\n5. if startvalue became greater than target than we will just increment target value by 1 untill it became equals to 1.\\n```\n```\\nclass Solution {\\npublic:\\n    int brokenCalc(int start, int target) {\\n        \\n        \\n        if(start >= target)\\n            return start-target;\\n\\t\\t\\n        return 1 + (target%2 == 0 ? brokenCalc(start, target/2) : brokenCalc(start, target+1));\\n    \\n        \\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1875310,
                "title": "c-faster-solution-iterative-and-recursive-way-o-logn",
                "content": "**Iterative Code**\\n\\n```\\nclass Solution {\\npublic:\\n    int brokenCalc(int startValue, int target) {\\n        // In this approach, instead of thinking how\\n        // to approach from start to target, let\\'s think \\n        // how to go from target to start\\n        \\n        /*\\n        ONE CRUX:\\n        \\n            1. If our target is lesser than start then\\n               ans will always be the differece\\n            eg. startValue = 20, target = 5.\\n            In this example multiplying will not do anything\\n            so, ans = (startValue - target) = 20 - 5 = 15;\\n            \\n            2. Otherwise, we\\'ll check if target is odd/even\\n            \\n                -> for even numbers, we can directly divide by 2\\n                -> for odd numbers, we\\'ll increase the target by 1\\n                   just to divide by 2 in the next step\\n        \\n        */\\n        int cnt = 0;\\n        \\n        while(target > startValue)\\n        {\\n            if(target&1)\\n                target++;\\n            else\\n                target/=2;\\n            \\n            cnt++;\\n        }\\n        \\n        return cnt + startValue - target;\\n    }\\n};\\n```\\n\\n**Time - O(logN)\\nSpace - O(1)**\\n\\n**Recursive Code**\\n```\\nclass Solution {\\npublic:\\n    int brokenCalc(int startValue, int target) {\\n        \\n        if(startValue >= target) return startValue - target;\\n        \\n        return (target%2==0) ? 1 + brokenCalc(startValue, target/2) : 1 + brokenCalc(startValue, target+1);\\n    }\\n};\\n```\\n\\n**Time - O(logN)\\nSpace - O(logN)**\\n\\n***NB: If you liked the approached please upvote the solution as well as don\\'t hesitate to ask questions in the comments, I\\'ll be more than happy to help***",
                "solutionTags": [
                    "C++",
                    "C",
                    "Greedy",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int brokenCalc(int startValue, int target) {\\n        // In this approach, instead of thinking how\\n        // to approach from start to target, let\\'s think \\n        // how to go from target to start\\n        \\n        /*\\n        ONE CRUX:\\n        \\n            1. If our target is lesser than start then\\n               ans will always be the differece\\n            eg. startValue = 20, target = 5.\\n            In this example multiplying will not do anything\\n            so, ans = (startValue - target) = 20 - 5 = 15;\\n            \\n            2. Otherwise, we\\'ll check if target is odd/even\\n            \\n                -> for even numbers, we can directly divide by 2\\n                -> for odd numbers, we\\'ll increase the target by 1\\n                   just to divide by 2 in the next step\\n        \\n        */\\n        int cnt = 0;\\n        \\n        while(target > startValue)\\n        {\\n            if(target&1)\\n                target++;\\n            else\\n                target/=2;\\n            \\n            cnt++;\\n        }\\n        \\n        return cnt + startValue - target;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int brokenCalc(int startValue, int target) {\\n        \\n        if(startValue >= target) return startValue - target;\\n        \\n        return (target%2==0) ? 1 + brokenCalc(startValue, target/2) : 1 + brokenCalc(startValue, target+1);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 997373,
                "title": "greedy-method-explanation-visual-python",
                "content": "***TL;DR***  (explantion + visual below). This problem is a ***minimization*** problem; thus a greedy method is appropriate. At every stage we take the operation that results in the minimum cost (operation that brings us closest to our target). if we invert our operations ( ```decrement -> increment, double -> half``` ) and work backwards from ```Y``` to ```X``` we arrive at an more elegant and readable solution. \\n\\n```python\\ndef brokenCalc(self, X: int, Y: int) -> int:\\n\\t\\toperations = 0\\n        while Y > X:\\n            Y = Y + 1 if Y % 2 == 1 else Y//2\\n            operations += 1\\n        return operations + X - Y\\n```\\n * * * \\n### Problem Overview \\n* * * \\nRecall the problem requires us to find the ***minimum number of operations*** needed to transfrom ```X``` to ```Y``` where we are confined to a restricted set of operations ```double(X)``` and ```decrement(X)```. To fully understand this problem it is instructive to see why there are many ways to transfrom ```X``` to ```Y```.\\n\\nThere many ways to transfrom ```X``` into ```Y```. Trying different operations in different orderings can lead to different solutions.  We try some number of operations in some order to transform ```X```  to ```Y```.\\n\\n***To demonstrate a few***\\n\\n![image](https://assets.leetcode.com/users/images/86014117-da98-4ee9-8594-c8da5d440331_1609537797.2625136.png)\\n\\n![image](https://assets.leetcode.com/users/images/0ce50c43-41c6-4c61-920c-8c43691f137a_1609537297.903984.png)\\n\\nThese are all feasible solutions, as they result in ```X``` being transformed into ```Y```.\\n\\nNow suppose we restict the set of operations to ```double(X)``` and ```decrement(X)``` \\n![image](https://assets.leetcode.com/users/images/02cf1351-837a-4756-8057-190000510a79_1609537935.8319757.png)\\n\\n![image](https://assets.leetcode.com/users/images/0e363371-0980-44fc-b470-9f196577af8b_1609538174.062282.png)\\n\\nThere are still many ways with this restricted set of operations to transfrom ```X``` to ```Y```, this list is by no means exhaustive.\\n* * * \\n### Greedy Method \\n * * * \\nRecall the problem statement asks us to find the ***minimum*** number of operations.\\n\\nAs shown above there are many valid ways to transform ```X``` to ```Y``` , even with our restricted set of operations. However we only interested in valid transfromations that produce the ***minimum number of operations***. we will follow one of these transfromations that leads to the minimum number of operations and count its operations. \\n * * * \\nThis is a ***minimization*** problem because out of a set of possible solutions we select the minimum. A ***minimization*** problem is type of ***optimization*** problem. Since this is an ***optimization*** problem a ***Greedy*** approach is applicable.\\n\\n* * * \\nThe ***Greedy Method*** is an approach to solve an optimization problem by breaking the problem down into a ***series of stages*** where at each stage we invoke ***the same procedure*** (some selection procedure we define) always making the ***best*** choice for the given stage. At each stage we  end up with some result that ***always meets the constraint of the problem***.\\n\\n* * * \\n\\n### Selection Procedure \\n\\n* * * \\n\\nThe heart of a ***Greedy*** approach is the selection procedure. We repeatedly select a result at each stage. a ***Greedy*** selection procedure always selects the ***best*** possible result at each stage. \\n\\n***In this problem we are selecting an operation at each stage.***\\n\\n#### How do we select the ***best*** operation? \\n\\nFirst we define what ***best*** means to us in this problem. The best operation is the operation at each stage that will lead us to the ***minimum number*** of overall operations to transfrom ```X``` to ```Y```. if we always choose the ***best*** operation at each stage surely we will reach ```Y``` in the ***minimum number of operations***, because at no point did we ever pick an operation that was ***not the best***, so surely our solution is the ***best*** we can do; that is, our solution must have find the minimum number of operations.\\n\\nRecall for our selection procedure to be valid, at each stage we  must end up with some result that ***always meets the constraint of the problem***.  Thus to define a good and valid selection procedure we must be well aware of our ***problem constraints***. \\n\\n* * * \\n### Problem Constraints\\n* * * \\nour ***constraints*** for this problem is we can only use two operations. ```double(X)``` or ```decrement(X)```, thus our result at each stage should always produce a number can be formed by appyling some number of ```decrement(X)```  and/or ```double(X)``` operations to ```X``` where we are free to chose the order of these operations   \\n * * * \\n![image](https://assets.leetcode.com/users/images/d2505c8f-4df7-4fbe-b32e-dd835d2aab2a_1609540533.6298044.png)\\n\\n* * * \\n### Tying It All Togther \\n * * * \\nWe decided it is best to take a ***Greedy*** approach to solving this problem. To implement a Greedy approach we must.\\n\\n1. Define a ***valid*** selection procedure that always selects the ***best*** choice at each stage\\n2. To define a ***valid*** selection procedure we must design the selection procedure in such a way that it always produces a result that ***falls within the constraints of the problem.***\\n\\n * * * \\n***Defining The Selection Procedure*** \\n* * * \\nWhile this problem can be solved by starting from ```X``` and working our way to ```Y```. It is much easier to define our  ***Greedy*** selection procedure. if we work ***backwards*** from ```Y``` to ```X```.\\n\\nTo work backwards from ```X``` to ```Y``` we must invert our ```decrement(X)``` or ```double(X)```  operations.  (this will not affect our count because if we can make a transformation in ```N``` stages we can also undo that transformation in ```N``` stages) \\n\\n![image](https://assets.leetcode.com/users/images/0e4a2066-83e4-4713-9509-d94e7fee9933_1609545282.8591826.png)\\n\\nOur selection procedure must choose the ***best*** operation for each stage,  ***best*** meaning the operation that will lead us to the ***minimum*** number of operations. \\nHowever this is still rather vague. let us be more formal.\\n\\nThe ***best*** operation to select at a given stage when we go from ```Y``` to ```X``` is the operation that brings us ***closest***  to ```Y```. Surely if we ***always*** chose the operation out of our set of choices (```half(X)``` or ```increment(X)```)  that  brings us closest to ```Y```, we will ***always*** reach ```Y``` in the ***minimum possible number*** of operations. \\n\\nAdditionally our slection procedure will have to handle two cases ```X < Y``` and ```X > Y```. first let us address ```X < Y``` as the other case is trivial. \\n\\n![image](https://assets.leetcode.com/users/images/87483da5-7287-4196-840e-0502ed4c918c_1609547090.541625.png)\\n\\nfrom the example above where ```X < Y``` it may seem like there is ***no choice to  be made at all***, because  ***increasing the number*** always pulls us further away from our target ```X```` so why would we ever choose to ````increment(X)```? \\n\\n* recall that a ***valid*** selection procedure always produces a result that ***falls within the constraints of the problem.*** \\n\\n* recall the ***problem constraint*** states we  are only allowed to use the operations```decrement(X)``` and ```double(X)```.\\n\\n* thus at each of our selection procedure the result should be a number that could be formed by some number of ```decrement(X)``` and/or ```double(X)``` ***These operations always produce some integer value.***\\n\\n* * * \\nRecall we ***inverted*** our operations inorder to work backwards. We are able to ***invert*** because the count will remain unaffected as mentioned previously.\\n\\nHowever does our current selection procedure  always produce  a number that could be formed by some number of ```decrement(X)``` and/or ```double(X)```?  observe\\n\\n![image](https://assets.leetcode.com/users/images/2887f1a7-a6da-4086-aeba-047b1ed07655_1609549498.5807447.png)\\n\\nas you can see the result is a decimal and as stated above the result at each stage must be an integer because integer addition and integer muliplication operations are closed under the set of intergers (always results in an integer), thus the selection procedure at stage 2 failed to produce a result meets the problem constraints. thus this will not lead to correct solution\\n\\nthe correct solution is \\n![image](https://assets.leetcode.com/users/images/336cde3c-3fa1-4f7b-968f-bb6ae6eadf24_1609550050.9692233.png)\\n * * * \\nYou may be wondering to counteract this issue by simply using integer floor division. then no decimals would ever occur. \\n* * * \\n![image](https://assets.leetcode.com/users/images/a1eca010-d612-48b5-93e8-470fec979bd0_1609551576.4902742.png)\\n\\n\\nHere we get the correct result. ***but are we guaranteed a correct result for all inputs?*** the answer is no, this is because we inverted our operations. If we make a transformation ```Y``` to ```X``` in series of stages we should visit the exact same stages going to ```X``` to ```Y```  only in reverse order . \\n\\nif we attempt to verify an example this will become clear. \\n![image](https://assets.leetcode.com/users/images/5ef8adb4-4108-485b-a1a9-f8758f7bdf8f_1609553122.5619931.png)\\n\\ngoing from ```X``` to ```Y``` we get 4, and 4 is the correct answer \\n\\n![image](https://assets.leetcode.com/users/images/d251fb15-1d91-47fb-9ffa-f94a7889cff0_1609553372.8630252.png)\\n\\nnotice the stages for the two correct solutions are exactly the same except they are in reverse.\\n\\nAs seen from the example the real check that should be made is whether or not the number at the current stage is divisble by 2. this is because ```double(X)``` always produces a number that is dvisible by 2 and in this way we avoid decimals or incorrect counting caused by integer floor division. \\n\\nthus we truely meet the ***constraitnts for the problem*** it is as if we used ```double(x)``` and ```decrement(x)``` because all stages are exactly the same as if  we did not invert the operations the only difference is we look at them backwards and this does not affect the count. \\n* * * \\n### The Trivial Case \\n* * * \\nlastly let us address the case where ```X >  Y``` \\n\\n* We can only increment from ```Y``` to get to ```X```. In that case the number of operations to get to from ```Y``` to ```X```\\nis ```X - Y```.\\n\\n* It could also be the case that oru selection procedure ends on a number that is less than ```X``` and there are still some operations to be counted. thus we once have the case ```X > Y``` so the only operation that can be formed is ```increment(X)``` thus we can apply the same stategy of ```X - Y``` and add it to our current count of operations. \\n\\nthus we arrive out our final solution. \\nin the worst case we repeatedly half the input, with a few intermediate increment operations. thus we get a runtime of ```O(Log N)``` and space complexity of ```O(1)```\\n\\n```python \\ndef brokenCalc(self, X: int, Y: int) -> int:\\n     operations = 0\\n        while Y > X:\\n            Y = Y + 1 if Y % 2 == 1 else Y//2\\n            operations += 1\\n        return operations + X - Y\\n```",
                "solutionTags": [
                    "Python",
                    "Greedy"
                ],
                "code": "```decrement -> increment, double -> half```\n```Y```\n```X```\n```python\\ndef brokenCalc(self, X: int, Y: int) -> int:\\n\\t\\toperations = 0\\n        while Y > X:\\n            Y = Y + 1 if Y % 2 == 1 else Y//2\\n            operations += 1\\n        return operations + X - Y\\n```\n```X```\n```Y```\n```double(X)```\n```decrement(X)```\n```X```\n```Y```\n```X```\n```Y```\n```X```\n```Y```\n```X```\n```Y```\n```double(X)```\n```decrement(X)```\n```X```\n```Y```\n```X```\n```Y```\n```X```\n```Y```\n```Y```\n```double(X)```\n```decrement(X)```\n```decrement(X)```\n```double(X)```\n```X```\n```X```\n```Y```\n```Y```\n```X```\n```X```\n```Y```\n```decrement(X)```\n```double(X)```\n```N```\n```N```\n```Y```\n```X```\n```Y```\n```half(X)```\n```increment(X)```\n```Y```\n```Y```\n```X < Y```\n```X > Y```\n```X < Y```\n```X < Y```\n```X```\n````increment(X)```\n```decrement(X)```\n```double(X)```\n```decrement(X)```\n```double(X)```\n```decrement(X)```\n```double(X)```\n```Y```\n```X```\n```X```\n```Y```\n```X```\n```Y```\n```double(X)```\n```double(x)```\n```decrement(x)```\n```X >  Y```\n```Y```\n```X```\n```Y```\n```X```\n```X - Y```\n```X```\n```X > Y```\n```increment(X)```\n```X - Y```\n```O(Log N)```\n```O(1)```\n```python \\ndef brokenCalc(self, X: int, Y: int) -> int:\\n     operations = 0\\n        while Y > X:\\n            Y = Y + 1 if Y % 2 == 1 else Y//2\\n            operations += 1\\n        return operations + X - Y\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 308539,
                "title": "thinking-forward",
                "content": "Instead of thinking backward by incrementing and dividing ```Y```, we can think this problem forwardly. \\n\\nIntuition: We want to **first decrement** ```X``` to some extent, **then start to multiply** it until it gets close to ```Y```. \\nThis process equals to decrementing from a number ```X*(2^N)``` to ```Y```, where ```X*(2^N) >= Y```, and the number we are decrementing is **no longer** 1, instead, it is ```2^N```\\n\\nTherefore, we can be greedy. \\nStep1: **Find the smallest N**, for which ```X*(2^N) >= Y```\\nStep2: Start counting the number of decrements we need to do, where we are using ```2^N``` to decrement, until we cannot get any closer to Y.\\nStep3: Then, use ```2^(N-1)``` to decrement until we cannot get any closer to Y. \\nStep4: Use ```2^(N-2)``` to decrement, and do this recursively until we are using```2^0```, which is ```1``` to decrement. \\nFinally, return the number of decrements we have made, remember to plus ```N```, which is the number of multiplication.\\n\\n```\\nclass Solution(object):\\n    def brokenCalc(self, X, Y):\\n        \"\"\"\\n        :type X: int\\n        :type Y: int\\n        :rtype: int\\n        \"\"\"\\n        if Y <= X:\\n            return X-Y\\n        \\n        count = 0\\n        N = 1\\n        while X*2**N < Y:\\n            N += 1\\n        remain = (X*2**N)-Y\\n        count += N\\n        while N >= 0:\\n            count += remain//(2**N)\\n            remain %= (2**N)\\n            N -= 1\\n        \\n        return count\\n\\t\\t",
                "solutionTags": [
                    "Python"
                ],
                "code": "```Y```\n```X```\n```Y```\n```X*(2^N)```\n```Y```\n```X*(2^N) >= Y```\n```2^N```\n```X*(2^N) >= Y```\n```2^N```\n```2^(N-1)```\n```2^(N-2)```\n```2^0```\n```1```\n```N```",
                "codeTag": "Unknown"
            },
            {
                "id": 1876653,
                "title": "python-go-c-greedy-recursive-and-iterative-solutions",
                "content": "**\\uD83D\\uDC46Please UPVOTE it if you find my soulutions are useful \\uD83D\\uDC46 Feel free to ask any question**\\n# [Python/GO/C++] \\uD83C\\uDF1F Greedy Recursive and Iterative Solutions and Explanations \\uD83D\\uDC95\\n## 1\\uFE0F\\u20E3 Recursive Approach:\\nSimply backtrack target to startValue\\n1. If target is even, divide by 2 (for startValue multiply the number on display by 2)\\n2. If target is odd, add 1 (subtract 1 from the number on display.)\\n\\n**Edge Case**\\nOnce target is less or equal to startValue, means we can obtain the number only by subtract 1 from startValue to target\\n=> Return startValue - target, to find steps\\n## Complexity Analysis\\n* Time: O(logN): Let N be target\\'s number.\\n* Space: O(logN): Recurrsive call stack.\\n\\n## Code\\n\\n**Python**\\n```python\\n# Recursive\\nclass Solution:\\n    def brokenCalc(self, startValue: int, target: int) -> int:\\n        # Once target <= startValue, we only do subtract 1 to fit the target\\n        if target <= startValue:\\n            return startValue - target\\n        # Base Greedy Condition\\n        if target % 2 == 0:\\n            return 1 + self.brokenCalc(startValue, target // 2)\\n        else:\\n            return 1 + self.brokenCalc(startValue, target + 1)\\n```\\n**Go**\\n```go\\n// Recursive\\nfunc brokenCalc(startValue int, target int) int {\\n    // Once target <= startValue, we only do subtract 1 to fit the target\\n    if target <= startValue{\\n        return startValue - target\\n    }\\n    // Base Condition\\n    if target % 2 == 0{\\n        return 1 + brokenCalc(startValue, target / 2)\\n    } else{\\n        return 1 + brokenCalc(startValue, target + 1)\\n    }\\n}\\n```\\n**C++**\\n```cpp\\n// Recursive\\nclass Solution {\\npublic:\\n    int brokenCalc(int startValue, int target) {\\n        // Once target <= startValue, we only do subtract 1 to fit the target\\n        if (target <= startValue){\\n            return startValue - target;\\n        }\\n        // Base Condition\\n        if (target % 2 == 0){\\n            return 1 + brokenCalc(startValue, target / 2);\\n        } else{\\n            return 1 + brokenCalc(startValue, target + 1);\\n        }\\n    }\\n};\\n```\\n\\n## 2\\uFE0F\\u20E3 Iterative Approach:\\nSame apporach to recurrsive but less space memory. Because we don\\'t use recursive stack.\\n\\n## Complexity Analysis\\n* Time: O(logN): Let N be target\\'s number.\\n* Space: O(1)\\n\\n## Code\\n\\n**Python**\\n```python\\n# Iterative\\nclass Solution:\\n    def brokenCalc(self, startValue: int, target: int) -> int:\\n        steps = 0\\n        while target > startValue:\\n            steps += 1\\n            # Base Greedy Condition\\n            if target % 2 == 0:\\n                target //= 2\\n            else:\\n                target += 1\\n        # Once target <= startValue, we only do subtract 1 to fit the target\\n        return steps + startValue - target\\n```\\n**Go**\\n```go\\n// Iterative\\nfunc brokenCalc(startValue int, target int) int {\\n    steps := 0\\n    for target > startValue{\\n        steps++\\n        // Base Condition\\n        if target % 2 == 0{\\n            target /= 2 \\n        } else{\\n            target += 1\\n        }\\n    }\\n    // Once target <= startValue, we only do subtract 1 to fit the target\\n    return steps + startValue - target\\n}\\n```\\n**C++**\\n```cpp\\n// Iterative\\nclass Solution {\\npublic:\\n    int brokenCalc(int startValue, int target) {\\n        int steps = 0;\\n        // Base Condition\\n        while (target > startValue){\\n            steps++;\\n            if (target % 2 == 0){\\n                target /= 2;\\n            } else{\\n                target++;\\n            }\\n        }\\n        // Once target <= startValue, we only do subtract 1 to fit the target\\n        return steps + startValue - target;\\n    }\\n};\\n```\\n* See more 2022 Daily Challenge Solution : [GitHub](https://github.com/gcobs0834/2022-Daily-LeetCoding-Challenge-python3-)",
                "solutionTags": [],
                "code": "```python\\n# Recursive\\nclass Solution:\\n    def brokenCalc(self, startValue: int, target: int) -> int:\\n        # Once target <= startValue, we only do subtract 1 to fit the target\\n        if target <= startValue:\\n            return startValue - target\\n        # Base Greedy Condition\\n        if target % 2 == 0:\\n            return 1 + self.brokenCalc(startValue, target // 2)\\n        else:\\n            return 1 + self.brokenCalc(startValue, target + 1)\\n```\n```go\\n// Recursive\\nfunc brokenCalc(startValue int, target int) int {\\n    // Once target <= startValue, we only do subtract 1 to fit the target\\n    if target <= startValue{\\n        return startValue - target\\n    }\\n    // Base Condition\\n    if target % 2 == 0{\\n        return 1 + brokenCalc(startValue, target / 2)\\n    } else{\\n        return 1 + brokenCalc(startValue, target + 1)\\n    }\\n}\\n```\n```cpp\\n// Recursive\\nclass Solution {\\npublic:\\n    int brokenCalc(int startValue, int target) {\\n        // Once target <= startValue, we only do subtract 1 to fit the target\\n        if (target <= startValue){\\n            return startValue - target;\\n        }\\n        // Base Condition\\n        if (target % 2 == 0){\\n            return 1 + brokenCalc(startValue, target / 2);\\n        } else{\\n            return 1 + brokenCalc(startValue, target + 1);\\n        }\\n    }\\n};\\n```\n```python\\n# Iterative\\nclass Solution:\\n    def brokenCalc(self, startValue: int, target: int) -> int:\\n        steps = 0\\n        while target > startValue:\\n            steps += 1\\n            # Base Greedy Condition\\n            if target % 2 == 0:\\n                target //= 2\\n            else:\\n                target += 1\\n        # Once target <= startValue, we only do subtract 1 to fit the target\\n        return steps + startValue - target\\n```\n```go\\n// Iterative\\nfunc brokenCalc(startValue int, target int) int {\\n    steps := 0\\n    for target > startValue{\\n        steps++\\n        // Base Condition\\n        if target % 2 == 0{\\n            target /= 2 \\n        } else{\\n            target += 1\\n        }\\n    }\\n    // Once target <= startValue, we only do subtract 1 to fit the target\\n    return steps + startValue - target\\n}\\n```\n```cpp\\n// Iterative\\nclass Solution {\\npublic:\\n    int brokenCalc(int startValue, int target) {\\n        int steps = 0;\\n        // Base Condition\\n        while (target > startValue){\\n            steps++;\\n            if (target % 2 == 0){\\n                target /= 2;\\n            } else{\\n                target++;\\n            }\\n        }\\n        // Once target <= startValue, we only do subtract 1 to fit the target\\n        return steps + startValue - target;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1875785,
                "title": "java-python-recursive",
                "content": "While `target > startValue`, we\\'ll keep reducing `target`, until it\\'s smaller or equals `startValue`.\\nIf `target` is even, if we plus 1 to `target`, then `target` is odd, we can do only plus 1 more,\\nbut` (target + 1 + 1) / 2  = (target / 2) + 1` and  it makes no sense to do an extra operation \\n\\n =>\\n \\n **`target = target / 2` if `target` is even\\n `target = target + 1` if` target` is odd**\\n \\n Using recursion, we can do this check until the `target value` becomes the `start value`\\n\\n### Java\\n\\n```\\npublic int brokenCalc(int startValue, int target) {\\n        if (startValue > target)\\n            return startValue - target;\\n        if (startValue == target)\\n            return 0;\\n\\n        if (target % 2 == 0)\\n            return 1 + brokenCalc(startValue, target / 2);\\n        else\\n            return 1 + brokenCalc(startValue, target + 1);\\n    }\\n```\\n\\n### Python\\n\\n```\\ndef brokenCalc(self, startValue: int, target: int) -> int:\\n        if (startValue > target) : \\n            return startValue - target\\n        if (startValue == target) : \\n            return 0\\n        if (target % 2 == 0): \\n            return 1 + self.brokenCalc(startValue, target // 2)\\n        else : \\n            return 1 + self.brokenCalc(startValue, target + 1)\\n```",
                "solutionTags": [
                    "Java",
                    "Python",
                    "Recursion"
                ],
                "code": "```\\npublic int brokenCalc(int startValue, int target) {\\n        if (startValue > target)\\n            return startValue - target;\\n        if (startValue == target)\\n            return 0;\\n\\n        if (target % 2 == 0)\\n            return 1 + brokenCalc(startValue, target / 2);\\n        else\\n            return 1 + brokenCalc(startValue, target + 1);\\n    }\\n```\n```\\ndef brokenCalc(self, startValue: int, target: int) -> int:\\n        if (startValue > target) : \\n            return startValue - target\\n        if (startValue == target) : \\n            return 0\\n        if (target % 2 == 0): \\n            return 1 + self.brokenCalc(startValue, target // 2)\\n        else : \\n            return 1 + self.brokenCalc(startValue, target + 1)\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1874943,
                "title": "python-solution-easy-to-understand",
                "content": "```\\n# if target value is smaller than startValue we can only subtract from the number\\nif startValue>target:\\n    return startValue-target\\n\\n# we will iterate backwards to reach the startValue (greedy approach)\\ntotal_steps=0\\nwhile target!=startValue:\\n\\tif target<startValue:\\n\\t\\ttotal_steps+=startValue-target\\n\\t\\ttarget=startValue\\n\\telif target%2==1:\\n\\t\\ttotal_steps+=1\\n\\t\\ttarget+=1\\n\\telse:\\n\\t\\ttarget//=2\\n\\t\\ttotal_steps+=1\\nreturn total_steps\\n\\n```",
                "solutionTags": [
                    "Python",
                    "Greedy"
                ],
                "code": "```\\n# if target value is smaller than startValue we can only subtract from the number\\nif startValue>target:\\n    return startValue-target\\n\\n# we will iterate backwards to reach the startValue (greedy approach)\\ntotal_steps=0\\nwhile target!=startValue:\\n\\tif target<startValue:\\n\\t\\ttotal_steps+=startValue-target\\n\\t\\ttarget=startValue\\n\\telif target%2==1:\\n\\t\\ttotal_steps+=1\\n\\t\\ttarget+=1\\n\\telse:\\n\\t\\ttarget//=2\\n\\t\\ttotal_steps+=1\\nreturn total_steps\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1076754,
                "title": "java-100-recursion",
                "content": "if you like it pls upvote\\n\\nJava\\n```\\nclass Solution {\\n    public int brokenCalc(int X, int Y) {\\n        if(X==Y)\\n        {\\n            return 0;\\n        }\\n        if(X>Y)\\n        {\\n            return X-Y;\\n        }\\n        else\\n        {\\n            if(Y%2==1)\\n            {\\n                return 1+brokenCalc(X,Y+1);\\n            }\\n            else\\n            {\\n                return 1+brokenCalc(X,Y/2);\\n            }\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int brokenCalc(int X, int Y) {\\n        if(X==Y)\\n        {\\n            return 0;\\n        }\\n        if(X>Y)\\n        {\\n            return X-Y;\\n        }\\n        else\\n        {\\n            if(Y%2==1)\\n            {\\n                return 1+brokenCalc(X,Y+1);\\n            }\\n            else\\n            {\\n                return 1+brokenCalc(X,Y/2);\\n            }\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1876481,
                "title": "calculator-reverse-technique-simple-loop-java-100-faster",
                "content": "Hi,\\n\\nI tried this problem straight forward, that time I was not able to pass more than few test cases, so I thought of trying in reverse.\\n\\nHere is my approach :\\n  1. We have to iterate till the target value becomes start value.\\n  2. If the target value is odd then dividing we can increment the count by 2 else 1, this is because if its odd then we can add a value to the target and then divide it by 2\\n  3. Reduce the target by half till the target is less than start value.\\n  4. Once start value is greater than target then add the difference between target and source.\\n\\nHope this is easy to understand.. Upvote if it helps.\\n\\n```\\n    private int brokenCalc(int startValue, int target) {\\n\\t\\tint i=0;\\n\\t\\twhile(target!=startValue){\\n\\t\\t\\tif(target<startValue){\\n\\t\\t\\t\\treturn i+(startValue-target);\\n\\t\\t\\t}\\n\\t\\t\\tif(target%2==1){\\n\\t\\t\\t\\ttarget++;\\n\\t\\t\\t\\ti++;\\n\\t\\t\\t}\\n\\t\\t\\ttarget = target/2;\\n\\t\\t\\ti++;\\n\\t\\t}\\n\\t\\treturn i;\\n\\t}",
                "solutionTags": [
                    "Java"
                ],
                "code": "Hi,\\n\\nI tried this problem straight forward, that time I was not able to pass more than few test cases, so I thought of trying in reverse.\\n\\nHere is my approach :\\n  1. We have to iterate till the target value becomes start value.\\n  2. If the target value is odd then dividing we can increment the count by 2 else 1, this is because if its odd then we can add a value to the target and then divide it by 2\\n  3. Reduce the target by half till the target is less than start value.\\n  4. Once start value is greater than target then add the difference between target and source.\\n\\nHope this is easy to understand.. Upvote if it helps.\\n\\n```\\n    private int brokenCalc(int startValue, int target) {\\n\\t\\tint i=0;\\n\\t\\twhile(target!=startValue){\\n\\t\\t\\tif(target<startValue){\\n\\t\\t\\t\\treturn i+(startValue-target);\\n\\t\\t\\t}\\n\\t\\t\\tif(target%2==1){\\n\\t\\t\\t\\ttarget++;\\n\\t\\t\\t\\ti++;\\n\\t\\t\\t}\\n\\t\\t\\ttarget = target/2;\\n\\t\\t\\ti++;\\n\\t\\t}\\n\\t\\treturn i;\\n\\t}",
                "codeTag": "Unknown"
            },
            {
                "id": 1875082,
                "title": "faster-than-100-c-simple-greedy-approach-o-log-n-time-o-1-space-complexity",
                "content": "Approach:\\n\\t1. instead of making startValue equal to target by * and - We can use / and - operation to reduce target to startValue and count steps;\\n\\t2. If current target value is odd than add 1 to target else target is even divide it by 2. at each step increase count of count variable.\\n\\t3. at the end if target ==0 then count is answer but if target become less than startValue then in that case to match target to start we have to perform + operation (startValue-target) times.\\n\\t4. In general count+(startValue-target) will give correct answer;\\n```\\nclass Solution {\\npublic:\\n    int brokenCalc(int startValue, int target) {\\n        int answer=0;\\n        while(target>startValue){\\n            if(target&1)\\n                target++;\\n            else\\n                target/=2;\\n            answer++;\\n        }\\n        return answer+(startValue-target);\\n    }\\n};\\n```\\n",
                "solutionTags": [
                    "C",
                    "Math",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int brokenCalc(int startValue, int target) {\\n        int answer=0;\\n        while(target>startValue){\\n            if(target&1)\\n                target++;\\n            else\\n                target/=2;\\n            answer++;\\n        }\\n        return answer+(startValue-target);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1846206,
                "title": "javascript-991-broken-calculator",
                "content": "---\\n\\n- This looks similar to a question from Amazon sponsered contest, a month or so ago\\n  - **Brute force** solution\\n  - **Slightly optimized** solution\\n\\n---\\n\\nHope it is simple to understand.\\n\\n---\\n\\n**Brute force** solution\\n\\n```\\nvar brokenCalc = function (startValue, target) {\\n    let count = 0;\\n\\n    // go down\\n    while (target > startValue) {\\n        if (target % 2 === 0) target /= 2;\\n        else target += 1;\\n        count++;\\n    }\\n\\n    // go up\\n    while (startValue != target) {\\n        target += 1;\\n        count++;\\n    }\\n\\n    return count;\\n};\\n```\\n\\n---\\n\\n**Slightly optimized** solution\\n\\n```\\nvar brokenCalc = function (startValue, target) {\\n    let count = 0;\\n\\n    // go down\\n    while (target > startValue) {\\n        if (target % 2 === 0) target /= 2;\\n        else target += 1;\\n        count++;\\n    }\\n\\n    // go up\\n    count += startValue - target;\\n\\n    return count;\\n};\\n```\\n\\n![image](https://assets.leetcode.com/users/images/03bcf34e-ddc0-4cae-bade-1e2669437665_1647182984.236964.png)\\n\\n---\\n",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar brokenCalc = function (startValue, target) {\\n    let count = 0;\\n\\n    // go down\\n    while (target > startValue) {\\n        if (target % 2 === 0) target /= 2;\\n        else target += 1;\\n        count++;\\n    }\\n\\n    // go up\\n    while (startValue != target) {\\n        target += 1;\\n        count++;\\n    }\\n\\n    return count;\\n};\\n```\n```\\nvar brokenCalc = function (startValue, target) {\\n    let count = 0;\\n\\n    // go down\\n    while (target > startValue) {\\n        if (target % 2 === 0) target /= 2;\\n        else target += 1;\\n        count++;\\n    }\\n\\n    // go up\\n    count += startValue - target;\\n\\n    return count;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 293970,
                "title": "easy-readable-faster-than-100-c-recursive-solution",
                "content": "```\\n public static int BrokenCalc(int X, int Y)\\n        {\\n            if (Y <= X)\\n                return X - Y;\\n\\n            if (Y % 2 == 1)\\n                return BrokenCalc(X, Y + 1) + 1;\\n            else return BrokenCalc(X, Y / 2) + 1;\\n        }\\n```",
                "solutionTags": [
                    "Recursion"
                ],
                "code": "```\\n public static int BrokenCalc(int X, int Y)\\n        {\\n            if (Y <= X)\\n                return X - Y;\\n\\n            if (Y % 2 == 1)\\n                return BrokenCalc(X, Y + 1) + 1;\\n            else return BrokenCalc(X, Y / 2) + 1;\\n        }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2416694,
                "title": "python-95-67-faster-simplest-solution-with-explanation-beg-to-adv-greedy",
                "content": "```python\\nclass Solution:\\n    def brokenCalc(self, startValue: int, target: int) -> int:\\n        res = 0 # taking a counter. \\n        while target > startValue: # checking if target value is greater then startValue. \\n            res += 1 # as if target is greater implies we`ll be having atleast one operation. \\n            if target%2==0:\\n                target //=2 # in case number is even. \\n            else:\\n                target += 1 # in case number odd. \\n        return res + startValue - target# startValue - target is for (target<=staetValue). \\n```\\n***Found helpful, Do upvote!!***\\n![image](https://assets.leetcode.com/users/images/07f07521-5e18-4da7-8506-d198d0eeeb72_1660327775.915633.png)\\n",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Greedy"
                ],
                "code": "```python\\nclass Solution:\\n    def brokenCalc(self, startValue: int, target: int) -> int:\\n        res = 0 # taking a counter. \\n        while target > startValue: # checking if target value is greater then startValue. \\n            res += 1 # as if target is greater implies we`ll be having atleast one operation. \\n            if target%2==0:\\n                target //=2 # in case number is even. \\n            else:\\n                target += 1 # in case number odd. \\n        return res + startValue - target# startValue - target is for (target<=staetValue). \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1876846,
                "title": "c-how-to-prove-the-o-logn-solution-will-always-work",
                "content": "I refer solution and write in C++. \\n```C++\\nclass Solution {\\npublic:\\n    int brokenCalc(int startValue, int target) {\\n        int ans = 0; \\n        while(target >startValue) {\\n            ans++;\\n            if (target %2==1){\\n                target++;\\n            } else {\\n                target/=2;\\n            }\\n        }\\n        return ans + startValue - target;\\n    }\\n};\\n```\\nBut the only question is that how to prove this algorithm \\ncan be correct for this problem. \\n\\nAfter thinking sometimes, I still have no answer. \\n\\nCan anyone help me ? \\n\\nThanks a lot \\n",
                "solutionTags": [
                    "C"
                ],
                "code": "```C++\\nclass Solution {\\npublic:\\n    int brokenCalc(int startValue, int target) {\\n        int ans = 0; \\n        while(target >startValue) {\\n            ans++;\\n            if (target %2==1){\\n                target++;\\n            } else {\\n                target/=2;\\n            }\\n        }\\n        return ans + startValue - target;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1875734,
                "title": "991-c-easy-o-logn-solution-with-explanation",
                "content": "**Please upvote if you find this solution helpful**\\n**Approach:**\\n* Here, we do opposite operations we reduce targetvalue until it is lesser than startvalue\\n* For this we apply just 2 opposite operations....\\ni) If target is odd, add 1 to it\\nii) If target is even, divide it by 2\\n* increment count by 1 for each operation and return it.\\n* **TC-O(LogN), SC- O(1)**\\n\\n**Code:**\\n```\\nclass Solution {\\npublic:\\n    int brokenCalc(int startValue, int target) \\n    {\\n        //variable for counting no. of operations\\n        int cnt=0;\\n        \\n        while(startValue < target)\\n        {\\n            if(target%2) // odd (t%2==1 for odd)\\n            {\\n                target++;\\n            }\\n            \\n            else //even (t%2==0 for even)\\n            {\\n                target /= 2;\\n            }\\n            \\n            //increment count\\n            cnt++;\\n        }\\n        return cnt + (startValue - target);\\n        \\n    }\\n};\\n```\\n\\n**Please upvote if you find this solution helpful**",
                "solutionTags": [
                    "C",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int brokenCalc(int startValue, int target) \\n    {\\n        //variable for counting no. of operations\\n        int cnt=0;\\n        \\n        while(startValue < target)\\n        {\\n            if(target%2) // odd (t%2==1 for odd)\\n            {\\n                target++;\\n            }\\n            \\n            else //even (t%2==0 for even)\\n            {\\n                target /= 2;\\n            }\\n            \\n            //increment count\\n            cnt++;\\n        }\\n        return cnt + (startValue - target);\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1875432,
                "title": "javascript-intutive-solution",
                "content": "```\\n/**\\n * @param {number} startValue\\n * @param {number} target\\n * @return {number}\\n */\\nvar brokenCalc = function(startValue, target) {\\n    let steps = 0;\\n    \\n    while(target !== startValue){\\n\\n        if(startValue > target){\\n            return steps  + startValue - target;\\n        }\\n        if(target %2 === 0){\\n            target /= 2;\\n        }else {\\n            target += 1;\\n            \\n        }\\n        steps++;\\n    }\\n    return steps\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Math"
                ],
                "code": "```\\n/**\\n * @param {number} startValue\\n * @param {number} target\\n * @return {number}\\n */\\nvar brokenCalc = function(startValue, target) {\\n    let steps = 0;\\n    \\n    while(target !== startValue){\\n\\n        if(startValue > target){\\n            return steps  + startValue - target;\\n        }\\n        if(target %2 === 0){\\n            target /= 2;\\n        }else {\\n            target += 1;\\n            \\n        }\\n        steps++;\\n    }\\n    return steps\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1875206,
                "title": "java-100-faster-with-greedy",
                "content": "class Solution {\\n    public int brokenCalc(int startValue, int target) {\\n        \\n        int ans=0;\\n        while(true)\\n        {\\n            if(startValue==target)\\n                return ans;\\n            if(startValue>target)\\n                return ans+startValue-target;\\n            if(target%2==0)\\n            {\\n                target/=2;\\n            }\\n            else\\n            {\\n               target=(target+1)/2;\\n               ans++; \\n            }\\n            ans++;\\n        \\n        }\\n        \\n    }\\n}",
                "solutionTags": [
                    "Java",
                    "Greedy"
                ],
                "code": "class Solution {\\n    public int brokenCalc(int startValue, int target) {\\n        \\n        int ans=0;\\n        while(true)\\n        {\\n            if(startValue==target)\\n                return ans;\\n            if(startValue>target)\\n                return ans+startValue-target;\\n            if(target%2==0)\\n            {\\n                target/=2;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1874880,
                "title": "javascript-greedy-one-liner-recursive-bfs-and-arithmetic-iterative-solutions-100",
                "content": "![image](https://assets.leetcode.com/users/images/a4ae1016-da0f-4e3a-86ae-f0f5840560b8_1647998543.907309.png)\\n\\nHere\\'s the one liner first because I was bored. \\n```\\nconst brokenCalc=(s,e,o=0)=>e<=s?o+s-e:!(e%2)?brokenCalc(s,e/2,o+1):brokenCalc(s,e+1,o+1)\\n```\\n\\nMuch more readable version that works exactly the same:\\n```\\nconst brokenCalc = (start, end, ops = 0) => {\\n  if (end <= start) return ops + start - end;\\n  if (!(end % 2)) return brokenCalc(start, end / 2, ops + 1)\\n  else return brokenCalc(start, end + 1, ops + 1)\\n}\\n```\\n\\nBest / most optimal solution here.  Though if we\\'re being honest, they all have the same complexity / do the same operations, the others just take up a bit more space on the callstack or in the queue.:\\n```\\nconst brokenCalc = (start, end, ops = 0) => {\\n  for (;end > start; ops++) {\\n    !(end % 2) ? end /= 2 : end += 1\\n  }\\n  return ops + start - end\\n}\\n```\\n\\nCompletely unnecessary BFS Version which only ever puts one option in the queue at a time...  Sooo, no branching.  Once again, completely pointless.  But to reiterate - I was bored, and also anytime I see buzzwords like \\'Minimum Operations to\\' or \\'Shortest Distance\\' or \\'Least Time\\' the BFS monster in my brain charges through the wall like Kool-Aid...  So, this is - admittedly - where I started until I wrote it out and realized it was pointless. \\uD83E\\uDD37\\u200D\\u2642\\uFE0F\\n```\\nvar brokenCalc = function(startValue, target, operations = 0) {\\n  const queue = new Queue([target]);\\n  while (!queue.isEmpty()) {\\n    const curend = queue.dequeue();\\n    if (curend <= startValue) return  operations + startValue - curend\\n    if (!(curend % 2)) queue.enqueue(curend / 2)\\n    else queue.enqueue(curend + 1)\\n    operations++\\n  }\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Breadth-First Search",
                    "Recursion"
                ],
                "code": "```\\nconst brokenCalc=(s,e,o=0)=>e<=s?o+s-e:!(e%2)?brokenCalc(s,e/2,o+1):brokenCalc(s,e+1,o+1)\\n```\n```\\nconst brokenCalc = (start, end, ops = 0) => {\\n  if (end <= start) return ops + start - end;\\n  if (!(end % 2)) return brokenCalc(start, end / 2, ops + 1)\\n  else return brokenCalc(start, end + 1, ops + 1)\\n}\\n```\n```\\nconst brokenCalc = (start, end, ops = 0) => {\\n  for (;end > start; ops++) {\\n    !(end % 2) ? end /= 2 : end += 1\\n  }\\n  return ops + start - end\\n}\\n```\n```\\nvar brokenCalc = function(startValue, target, operations = 0) {\\n  const queue = new Queue([target]);\\n  while (!queue.isEmpty()) {\\n    const curend = queue.dequeue();\\n    if (curend <= startValue) return  operations + startValue - curend\\n    if (!(curend % 2)) queue.enqueue(curend / 2)\\n    else queue.enqueue(curend + 1)\\n    operations++\\n  }\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1697185,
                "title": "python-o-logn-solution-starting-from-startvalue-with-detailed-explanation",
                "content": "## 991 Broken Calculator\\n\\n[https://leetcode.com/problems/broken-calculator/](https://leetcode.com/problems/broken-calculator/)\\n\\nInstead of doing the smart thing and thinking about the problem from the target backwards as explained [here](https://leetcode.com/problems/broken-calculator/discuss/1076042/Python-C%2B%2B-Explanation-with-illustration-why-we-should-work-with-Y-not-X), I chose to tackle the problem from the startValue upwards.\\n\\nThe general idea is double the startValue until it is greater than target, and it\\'s important to note that the optimal solution **always** requires this many doublings.\\n\\nNow our task is to figure out when to decrease the value so that it minimizes our number of steps.\\n\\n**Case 1:**\\n\\n![case1](https://i.imgur.com/t1ZwSZF.png)\\n\\nIn this example, the difference from the number we get after only doubling and the target is 12. We can see that using the decrease operation at differnce times affects the results differently. The effect of reduction on the final number doubles after every doubling. Decreasing 14 to 13 decreases the final result by 8, since there are 3 doublings after the decrease. This corresponds to 2^3, and so the effects of decreases can be calculated by 2 to the power of the number of doublings remaining. Similarly, there are 2 doublings after the deduction from 26 to 25, and that decreases the final result by 2^2.\\n\\nTherefore, any difference between the number we get from doubling to the target can be broken down into powers of 2, and those powers of 2 then tells us when and how many times to decrease. In this case, the difference of 12 (112-100) can be broken down into 2^3 + 2^2, telling us that we should decrease once with 3 doublings left and once with 2 doublings left.\\n\\nThe final result would be the number of doubles + the number of decreases.\\n\\n**Case 2:**\\n\\n![case2](https://i.imgur.com/laZO199.png)\\n\\nIn this case we have to decrease before we double. The difference of 12 (28-16) can be made up of 2^3 + 2^2. However we can\\'t decrease 3 doublings before the end, since we don\\'t double 3 times. In this case, the earlier we can decrease only affects the final result by 4 (2^2) every time. Therefore the difference can still be broken down into powers of 2, but any powers greater than 2^(max doubles) must be broken down into powers no greater than 2^(max doubles). Here we break the difference down into 3*2^2, meaning we decrease 3 times at 2 doublings before the end.\\n\\n**Case 3:**\\n\\nThis is the case where the start is greater than the target. In this case the result is simply target - start.\\n\\ne.g. \\nstart = 20, target = 5\\nresult = 15 (20-5)\\n\\n**Implementation:**\\n\\nBreaking down the difference into powers of 2 is simply converting the int to binary.\\n\\n```python\\ndef brokenCalc(self, startValue: int, target: int) -> int:\\n```\\nCase 3\\n```python\\n    if startValue>target:\\n        return startValue - target\\n```\\n\\nCalculate doublings and difference\\nx is the value we get if we only apply doubling\\n\\n```python\\n    doublings = 0\\n    x = startValue\\n    while x < target:\\n        x *= 2\\n        doublings += 1\\n    diff = bin(x-target)[2:] #saves difference as binary representation\\n```\\n\\nFinal result res is the number of doublings and the number of decreases\\n```python\\n    res = doublings\\n    #Adds decreases that happen **before** doubling\\n    if diff[:-doublings]:\\n        res += int(diff[:-doublings],2)\\n    #Adds decreases that happen **after** first doubling\\n    if diff[-doublings:]:\\n        res += sum(int(i) for i in diff[-doublings:])\\n    return res\\n```\\n\\nTime: O(logn)\\n\\nSpace: O(1)\\n",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```python\\ndef brokenCalc(self, startValue: int, target: int) -> int:\\n```\n```python\\n    if startValue>target:\\n        return startValue - target\\n```\n```python\\n    doublings = 0\\n    x = startValue\\n    while x < target:\\n        x *= 2\\n        doublings += 1\\n    diff = bin(x-target)[2:] #saves difference as binary representation\\n```\n```python\\n    res = doublings\\n    #Adds decreases that happen **before** doubling\\n    if diff[:-doublings]:\\n        res += int(diff[:-doublings],2)\\n    #Adds decreases that happen **after** first doubling\\n    if diff[-doublings:]:\\n        res += sum(int(i) for i in diff[-doublings:])\\n    return res\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1077278,
                "title": "c-greedy-solution-linear-time",
                "content": "This problem is best solved when reframing the solution around `Y` -- the number we are trying to reach -- and using it as a starting point to reach `X`, which is our original number. This working backwards approach is best exemplified by breaking down the problem using casework:\\n- Clearly, without reframing the problem, we can see that based on the given operations, if `X >= Y`, then the problem is trivial. Since the only way we have to reduce the number is to decrement the number, it is guaranteed to perform the reduction in the fewest number of operations. Therefore, the answer is just `X - Y`.\\n- Otherwise, we can proceed by starting at `Y` and working backwards to get to `X`. The reason why this approach is optimal is because if we were to go in the opposite direction, we don\\'t know the order to best choose our decrement and multiply operations. However, if we work backwards, the path is clear. First of all, let us make clear that the minimum number of operations to get from `X` to `Y` is the minimum number of operations to get from `Y` to `X`. This is apparent by just reversing the order of the operations and applying their inverses, which will ensure minimality. Now, let\\'s look at getting from `Y` to `X`. Clearly, to invert the operations, we must now either divide by two or increment by one, since we are moving in the opposite direction. \\n\\nBased on the setup of this \"working backwards\" process described before, we are left with two cases: \\n- If `Y` is even and more than `X`, we want to divide by 2. This gets us the most \"bang for our buck\" in terms of getting closest to `X`, since we are decreasing by the furthest amount. Furthermore, as an operation, we want to be dividing as much as possible, since there is each division operation can encapsulate up to `Y / 2` subtraction operations.\\n- Otherwise, if we are an odd number, then we just increment. This puts us back into even territory so we can continue decrementing.\\n\\nWe know for certain that dividing at a given point is the best choice we can take, because if we do not divide at that point and instead increment, we are guaranteed to have to increment twice in order to reach the number that would have only one increment had we divided and then incremented, as opposed to incrementing and then dividing (e.g. `10 -> 5 -> 6` vs `10 -> 11 -> 12 -> 6`).\\n\\nAnalyzing this, we see that the time complexity is linear in the number of operations required, since we are merely counting the operations, and requires constant space, since we are only declaring set variables.\\n\\n```\\nint brokenCalc(int X, int Y) {\\n\\tif (X >= Y) {\\n\\t\\treturn X - Y;\\n\\t} else {\\n\\t\\tint count = 0;\\n\\t\\twhile (Y != X) {\\n\\t\\t\\tif (!(Y % 2) && Y > X) {\\n\\t\\t\\t\\tY /= 2;\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tY++;\\n\\t\\t\\t}\\n\\t\\t\\tcount++;\\n\\t\\t}\\n\\t\\treturn count;\\n\\t}\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nint brokenCalc(int X, int Y) {\\n\\tif (X >= Y) {\\n\\t\\treturn X - Y;\\n\\t} else {\\n\\t\\tint count = 0;\\n\\t\\twhile (Y != X) {\\n\\t\\t\\tif (!(Y % 2) && Y > X) {\\n\\t\\t\\t\\tY /= 2;\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tY++;\\n\\t\\t\\t}\\n\\t\\t\\tcount++;\\n\\t\\t}\\n\\t\\treturn count;\\n\\t}\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1076128,
                "title": "recursive-and-iterative-y-x-1-liner-recursive",
                "content": "\\n\\n\\n**Recursive**\\n\\n```\\nclass Solution {\\n    public int brokenCalc(int X, int Y) {\\n        return (X >= Y) ? X - Y : (Y % 2 == 0) ? 1 + brokenCalc(X, Y / 2) : 1 + brokenCalc(X, Y + 1);\\n\\t\\t// return (X >= Y) ? X - Y : 1 + (Y % 2 == 0 ? brokenCalc(X, Y / 2) : brokenCalc(X, Y + 1));\\n    }\\n}\\n```\\n\\n************\\n**Iterative**\\n\\n```\\nclass Solution {\\n    public int brokenCalc(int X, int Y) {\\n        int operations = 0;\\n        while(Y > X) {\\n            Y = (Y % 2 == 0) ? Y / 2 : Y + 1;\\n            operations++;\\n        }\\n        \\n        return operations + X - Y;\\n    }\\n}\\n```\\n\\n**TC - O(logY)**\\n\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int brokenCalc(int X, int Y) {\\n        return (X >= Y) ? X - Y : (Y % 2 == 0) ? 1 + brokenCalc(X, Y / 2) : 1 + brokenCalc(X, Y + 1);\\n\\t\\t// return (X >= Y) ? X - Y : 1 + (Y % 2 == 0 ? brokenCalc(X, Y / 2) : brokenCalc(X, Y + 1));\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public int brokenCalc(int X, int Y) {\\n        int operations = 0;\\n        while(Y > X) {\\n            Y = (Y % 2 == 0) ? Y / 2 : Y + 1;\\n            operations++;\\n        }\\n        \\n        return operations + X - Y;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 705591,
                "title": "short-proof-of-correctness",
                "content": "```\\n    public int brokenCalc(int X, int Y) {\\n        int step = 0;\\n        while (X < Y) {\\n            if (Y % 2 == 0) {\\n                Y /= 2;\\n            } else {\\n                Y++;\\n            }\\n            step++;\\n        }\\n        return step + X - Y;\\n    }\\n```\\n\\nMany persons uses above implementation.\\nLet me proof its correctness.\\n\\nWhen `X >= Y`, we have one path, it is always decrementing `X` to `Y`\\nWhen `X < Y`, let\\'s find out what\\'s last operation\\n* `Y` is odd, last operation must be decrement.  Because we can\\'t multiply 2 to an odd number.\\n* `Y` is even, last operaton must be multiply.  Let\\'s assume `X < Y` and `2 * X >= Y`, that is `X >= Y / 2`, how `X` can reach `Y`\\n\\t* option 1, multiply 2 first, then decrements, operations is `2 * X - Y + 1`\\n\\t* option 2, decrement 1s first, then multiply 2, operations is `X - Y / 2 + 1`\\n\\t* as `(2 *X - Y + 1) - (X - Y / 2 + 1) = X - Y/ 2 >= 0`, so we should choose option2, so the last operation is multiply.\\n\\nWait, I just consider the situation `X >= Y / 2`, but what if `X < Y/ 2`? For `X < Y/ 2`, it must have a step `X_m` where  `Y/2 <= X_m < Y` before it reaches `Y`.\\n",
                "solutionTags": [],
                "code": "```\\n    public int brokenCalc(int X, int Y) {\\n        int step = 0;\\n        while (X < Y) {\\n            if (Y % 2 == 0) {\\n                Y /= 2;\\n            } else {\\n                Y++;\\n            }\\n            step++;\\n        }\\n        return step + X - Y;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 323276,
                "title": "recursive-method-to-solve-problem",
                "content": "## we should analyze the relation of X and Y\\n## case 1: X == Y \\n- the result is  0,these is no need to make any change.\\n\\n## case 2: X  > Y \\n- we can only decrease one by one step. The result will be ```X - Y ```\\n\\n## case 3 : X < Y\\n- case 3.1: if Y is ```odd```, Y must be formed by ```Y + 1 ```which is ```even```, so we can form Y by forming (Y + 1) \\uFF0Cwhich can be formed by some number using ```double ops```\\n- case 3.2: if Y is ```even```, Y must be formed by some number using ```double ops```\\n\\n## code is here,easily understand\\n\\n```cpp\\nint brokenCalc(int X, int Y) {\\n        if( X  == Y ) // case 1\\n            return 0;\\n        if( X > Y ) //  case 2\\n            return X - Y;\\n        if(Y  & 0x01 ) { //case 3.1\\n            return brokenCalc( X, Y + 1 ) + 1 ;\\n        }else {//case 3.2\\n            return brokenCalc( X, Y  /  2 ) + 1;\\n        }\\n        return 0;//end.\\n    }\\n```\\n- Time complexity is $O(log(n))$,space complexity:$O(log(n))$",
                "solutionTags": [],
                "code": "```X - Y ```\n```odd```\n```Y + 1 ```\n```even```\n```double ops```\n```even```\n```double ops```\n```cpp\\nint brokenCalc(int X, int Y) {\\n        if( X  == Y ) // case 1\\n            return 0;\\n        if( X > Y ) //  case 2\\n            return X - Y;\\n        if(Y  & 0x01 ) { //case 3.1\\n            return brokenCalc( X, Y + 1 ) + 1 ;\\n        }else {//case 3.2\\n            return brokenCalc( X, Y  /  2 ) + 1;\\n        }\\n        return 0;//end.\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 241770,
                "title": "c-super-easy-and-short-3-line-solution-can-be-implemented-in-1min-and-beats-100",
                "content": "```\\n    int brokenCalc(int X, int Y) {\\n        if(Y<=X) return X-Y;\\n        if(Y%2==0) return brokenCalc(X, Y/2)+1;\\n        else return brokenCalc(X, Y+1)+1;\\n    }",
                "solutionTags": [],
                "code": "```\\n    int brokenCalc(int X, int Y) {\\n        if(Y<=X) return X-Y;\\n        if(Y%2==0) return brokenCalc(X, Y/2)+1;\\n        else return brokenCalc(X, Y+1)+1;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 234478,
                "title": "java-o-logn-solution-with-detailed-explanation",
                "content": "```\\n/* Initially, I am thinking about using BFS.. but the solution will easily get TLE...\\n * Later, after analyze the problem in detail, \\n * I found:\\n * (1) when X > Y... multiple by 2 will only bring us far away from target...\\n *     so each step, we can only subtract 1 from X to get the target value...\\n *     thus we just need to return X - Y;\\n * (2) when Y > X... we can think reversely...\\n *     we can achieve Y from the previous number by either of two cases \\n *     (a) pre - 1 = Y;\\n *     (b) pre * 2 = Y...\\n *     which step to take is dependent on if Y is even or odd...\\n *     if (Y is even), pre = Y / 2;\\n *     if (Y is odd), pre = Y + 1...\\n *     then we reset Y as pre...\\n *     do the same thing, until Y <= X... which is the first case...\\n *         \\n */\\n\\nclass Solution {\\n    public int brokenCalc(int X, int Y) {\\n        int cnt = 0;\\n        while (Y > X) {\\n            if ((Y & 1) == 1) {\\n                Y += 1;\\n                cnt++;\\n            } \\n            Y >>= 1;\\n            cnt++;\\n        }\\n        return cnt + (X - Y);\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public int brokenCalc(int X, int Y) {\\n        int cnt = 0;\\n        while (Y > X) {\\n            if ((Y & 1) == 1) {\\n                Y += 1;\\n                cnt++;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 3585777,
                "title": "easy-clear-solution-python-3",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def brokenCalc(self, x: int, y: int) -> int:\\n        if y<=x:\\n            return x-y\\n        else:\\n            res=0\\n            while x<y:\\n                if y%2==1:\\n                    y+=1\\n                else:\\n                    y=y//2\\n                res+=1\\n            res+=(x-y)\\n            return res\\n            \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def brokenCalc(self, x: int, y: int) -> int:\\n        if y<=x:\\n            return x-y\\n        else:\\n            res=0\\n            while x<y:\\n                if y%2==1:\\n                    y+=1\\n                else:\\n                    y=y//2\\n                res+=1\\n            res+=(x-y)\\n            return res\\n            \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3345846,
                "title": "best-easiest-to-understand-in-5-lines",
                "content": "# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nPlsssss Up Vote! -> \\uD83D\\uDE2D\\n# Code\\n```\\nclass Solution {\\n    public int brokenCalc(int s, int t) {\\n        int ans = 0; \\n        while(t>s){\\n            ans++;\\n            if(t%2==1) t++;        \\n            else t/=2;\\n        }\\n        return ans+s-t;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int brokenCalc(int s, int t) {\\n        int ans = 0; \\n        while(t>s){\\n            ans++;\\n            if(t%2==1) t++;        \\n            else t/=2;\\n        }\\n        return ans+s-t;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3308094,
                "title": "solution-in-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int brokenCalc(int startValue, int target)\\n     {\\n        if(startValue >= target)\\n        {\\n            return startValue - target;\\n            }\\n        if(target & 1)\\n        {\\n            return 1 + brokenCalc(startValue, target  + 1);\\n            }\\n        return 1 + brokenCalc(startValue, target / 2);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int brokenCalc(int startValue, int target)\\n     {\\n        if(startValue >= target)\\n        {\\n            return startValue - target;\\n            }\\n        if(target & 1)\\n        {\\n            return 1 + brokenCalc(startValue, target  + 1);\\n            }\\n        return 1 + brokenCalc(startValue, target / 2);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3256622,
                "title": "c-easy-iterative-solution",
                "content": "<!-- # Intuition -->\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n<!-- # Approach -->\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:$$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:$$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```C++ []\\nclass Solution {\\npublic:\\n    int brokenCalc(int startValue, int target) {\\n        int ans = 0 ;\\n\\n        while(target > startValue)\\n        {\\n            if(target % 2 == 0)\\n            {\\n                target /= 2 ;\\n            }\\n            else\\n            {\\n                target += 1 ;\\n            }\\n            ans ++ ; \\n        }\\n\\n        ans = ans + (startValue - target) ;\\n        return ans ;\\n    }\\n};\\n```\\n![815a317f-9cdf-46e2-a397-af8869dafa2e_1673498197.3721023.png](https://assets.leetcode.com/users/images/9cc6c47d-bdd8-40d7-9737-a2158e0af022_1677948352.6102405.png)\\n",
                "solutionTags": [
                    "C++",
                    "Math",
                    "Greedy"
                ],
                "code": "```C++ []\\nclass Solution {\\npublic:\\n    int brokenCalc(int startValue, int target) {\\n        int ans = 0 ;\\n\\n        while(target > startValue)\\n        {\\n            if(target % 2 == 0)\\n            {\\n                target /= 2 ;\\n            }\\n            else\\n            {\\n                target += 1 ;\\n            }\\n            ans ++ ; \\n        }\\n\\n        ans = ans + (startValue - target) ;\\n        return ans ;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2907857,
                "title": "java-0ms-100-iterative-recursive",
                "content": "# Please Upvote :D\\n---\\n##### 1. Iterative approach:\\n![image.png](https://assets.leetcode.com/users/images/674497ab-11e0-4658-9ad9-92d5576bf913_1670943311.2295694.png)\\n \\n``` java []\\nclass Solution {\\n    public int brokenCalc(int startValue, int target) {\\n        int result = 0;\\n\\n        while (target > startValue) {\\n            result++;\\n            if (target % 2 == 0) target /=2;\\n            else target++;\\n        }\\n\\n        return result + (startValue - target);\\n    }\\n}\\n\\n// TC: O(log(target)), SC: O(1)\\n```\\n---\\n##### 2. Recursive approach:\\n![image.png](https://assets.leetcode.com/users/images/e9b351bd-4084-4a34-8a50-65b41eeaecd8_1670943356.5838752.png)\\n\\n``` java []\\nclass Solution {\\n    public int brokenCalc(int startValue, int target) {\\n        if (startValue >= target) {\\n            return startValue - target;\\n        }\\n\\n        if (target % 2 == 0) {\\n            return 1 + brokenCalc(startValue, target / 2);\\n        }\\n\\n        return 1 + brokenCalc(startValue, target + 1);\\n    }\\n}\\n\\n// TC: O(log(target)), SC: O(1)\\n```\\n",
                "solutionTags": [
                    "Java",
                    "Greedy",
                    "Recursion"
                ],
                "code": "``` java []\\nclass Solution {\\n    public int brokenCalc(int startValue, int target) {\\n        int result = 0;\\n\\n        while (target > startValue) {\\n            result++;\\n            if (target % 2 == 0) target /=2;\\n            else target++;\\n        }\\n\\n        return result + (startValue - target);\\n    }\\n}\\n\\n// TC: O(log(target)), SC: O(1)\\n```\n``` java []\\nclass Solution {\\n    public int brokenCalc(int startValue, int target) {\\n        if (startValue >= target) {\\n            return startValue - target;\\n        }\\n\\n        if (target % 2 == 0) {\\n            return 1 + brokenCalc(startValue, target / 2);\\n        }\\n\\n        return 1 + brokenCalc(startValue, target + 1);\\n    }\\n}\\n\\n// TC: O(log(target)), SC: O(1)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1876658,
                "title": "simple-java-solution",
                "content": "class Solution {\\n\\n    public int brokenCalc(int s, int t) {\\n        int c=0;\\n        while(t>s)\\n        {\\n            if(t%2==0)\\n            {\\n                c++;\\n                t/=2;\\n            }\\n            else\\n            {\\n                t++;\\n                c++;\\n            }\\n        }\\n        return c+(s-t);\\n    }\\n}",
                "solutionTags": [
                    "Java",
                    "Iterator"
                ],
                "code": "class Solution {\\n\\n    public int brokenCalc(int s, int t) {\\n        int c=0;\\n        while(t>s)\\n        {\\n            if(t%2==0)\\n            {\\n                c++;\\n                t/=2;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1876625,
                "title": "c-broken-calculator-going-backwards",
                "content": "--> Little Intuition : \\n\\n1. instead of going from P to Q think of going Q to P by doing /2 or +1 operations. \\n\\n1. While going backwards, if we encounter an odd number we must think how we must have reached here while going forward (Obviously by doing -1), so we must do a vice verse operation here. for encountering and even number we must have did x*2 while going forward. so we need to do x/2. \\n2. Once we have our startValue>target that means we can no longer do x/2 operations which would reduce it further. so do the remaining +1 operations which is (startValue-target) ops.\\n\\n```\\n  int brokenCalc(int startValue, int target) { \\n        int steps=0;\\n        while(target>startValue){\\n            steps++;\\n           if(target&1)\\n               target++;\\n           else\\n                target/=2;\\n        }\\n        \\n        return steps+(startValue-target);\\n    }\\n```",
                "solutionTags": [
                    "Math",
                    "Greedy"
                ],
                "code": "```\\n  int brokenCalc(int startValue, int target) { \\n        int steps=0;\\n        while(target>startValue){\\n            steps++;\\n           if(target&1)\\n               target++;\\n           else\\n                target/=2;\\n        }\\n        \\n        return steps+(startValue-target);\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1875892,
                "title": "c-o-logn-solution-daily-leetcoding-challenge-march-day-23",
                "content": "Intuition: We are sure when we are starting from target to startValue that if number is even that means it would be divided by 2 at some point, if number is odd that means 1 would be substracted from it.\\nSo we are reversing the logic:\\n**1) if target == even, divide it by 2\\n2) if taget == odd, add 1 in it**\\n\\nEdge case: if start value is greater than target then we can just substract 1 every time to reach target. Hence (startValue - target) been done in the last.\\n\\nExample:\\nstartValue = 5\\ntarget = 25\\nwhile(target > startValue)\\n25 -> 26 -> 13 -> 14 -> 7 -> 8 -> 4\\no/p: 6 (operations) + (5-4) = 7\\n\\n```\\nclass Solution {\\npublic:\\n    int brokenCalc(int startValue, int target) {\\n        \\n        int count = 0;\\n        while(target> startValue){\\n            if(target%2==0) \\n                target /= 2;\\n            else \\n                target += 1;\\n            \\n            count++;\\n        }\\n        \\n        return count+(startValue-target);\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int brokenCalc(int startValue, int target) {\\n        \\n        int count = 0;\\n        while(target> startValue){\\n            if(target%2==0) \\n                target /= 2;\\n            else \\n                target += 1;\\n            \\n            count++;\\n        }\\n        \\n        return count+(startValue-target);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1875775,
                "title": "easy-100-faster-recursive-o-1-space-o-logn-time-100-faster",
                "content": "**Approach**\\nIn this problem, I can\\'t decide which step should i do from the given two (multiply & subtract). But if i do the opposite thing, i can divide and increment the target to get the start value. \\n* Set ans as 0\\n* Start a loop with condition startValue < target & increase by one for every step\\n\\t* If target is even divide target\\n\\t* else increment target by one.\\n*  return ans + (target - startValue)\\n\\n**Code**\\n***Iterative Approach***\\n```\\nclass Solution {\\n    public int brokenCalc(int startValue, int target) {\\n        int ans = 0;\\n        while(startValue != target && target > startValue){\\n            if(target%2 == 0 )\\n                target /= 2;\\n            else \\n                target++;\\n            ans++;\\n            \\n        }\\n        if(target < startValue)\\n            ans +=  startValue - target;\\n        return ans;\\n    }\\n}\\n```\\n\\n***Recursive Approach***\\n```\\nclass Solution {\\n    private int getStep(int startValue, int target){\\n        if(target <= startValue)\\n            return startValue - target;\\n        if(target%2 == 0){\\n            return 1 + getStep(startValue, target/2);\\n        }else {\\n            return 1 + getStep(startValue, target+1);\\n        }\\n    }\\n    \\n    public int brokenCalc(int startValue, int target) {\\n        return getStep(startValue, target);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Recursion",
                    "Iterator"
                ],
                "code": "```\\nclass Solution {\\n    public int brokenCalc(int startValue, int target) {\\n        int ans = 0;\\n        while(startValue != target && target > startValue){\\n            if(target%2 == 0 )\\n                target /= 2;\\n            else \\n                target++;\\n            ans++;\\n            \\n        }\\n        if(target < startValue)\\n            ans +=  startValue - target;\\n        return ans;\\n    }\\n}\\n```\n```\\nclass Solution {\\n    private int getStep(int startValue, int target){\\n        if(target <= startValue)\\n            return startValue - target;\\n        if(target%2 == 0){\\n            return 1 + getStep(startValue, target/2);\\n        }else {\\n            return 1 + getStep(startValue, target+1);\\n        }\\n    }\\n    \\n    public int brokenCalc(int startValue, int target) {\\n        return getStep(startValue, target);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1875609,
                "title": "java-solution-with-comments-and-explaination",
                "content": "To Make x to y. we dont know at every step which of the operation might lead to min operation. i.e. for every step we can either do -1 or double it. there is no fix pattern.\\nSo what if we try to reverse think it. i.e. make y to x. in such case x-1 will be replaced by y+1 and x * 2 will be replaced by y / 2.\\nWe know to get min operation we must use more divide by 2 operations.\\n1. loop till y>x\\n2. If y is even. divide it by 2 and if y is odd. add 1 to make it y even again.\\n3. increment counter in each iteration to count no of operations done so far.\\n4. when loop finishes either x==y, in such case counter is the answer else we need to add 1 x-y times to y to make it same as x.\\n\\nexample ->\\nx=3, y=14\\niterations->\\ny,counter\\n14/2,1 (divide)\\n7+1,2(add)\\n8/2,3(divide)\\n4/2,4(divide)\\n\\nreturn 4+(3-2) [add 1 1 times here)\\nin forward direction just reverse the operation order. \\nit is 3 - 1 = 2 * 2 = 4 * 2 = 8 -1 = 7 * 2 =14.\\n\\n```\\npublic int brokenCalc(int start, int target) {\\n\\t\\t// hold no of operations\\n\\t\\tint ans = 0;\\n\\t\\t// till target is greater then start\\n\\t\\twhile (start < target) {\\n\\t\\t\\t// if target is odd. make it even as we can then perform divide operation. which\\n\\t\\t\\t// indeed make no of operation min\\n\\t\\t\\tif (target % 2 == 1) {\\n\\t\\t\\t\\ttarget++;\\n\\t\\t\\t} else {\\n\\t\\t\\t\\t// if target is even. divide by 2.\\n\\t\\t\\t\\ttarget = target / 2;\\n\\t\\t\\t}\\n\\t\\t\\t// increment operation\\n\\t\\t\\tans++;\\n\\t\\t}\\n\\t\\t// either start reaches target. in such case return ans. else then add 1 start -\\n\\t\\t// target no of times more to the target to make it equal to start.\\n\\t\\treturn ans + start - target;\\n\\t}\\n\\n```",
                "solutionTags": [
                    "Java",
                    "Math",
                    "Greedy"
                ],
                "code": "```\\npublic int brokenCalc(int start, int target) {\\n\\t\\t// hold no of operations\\n\\t\\tint ans = 0;\\n\\t\\t// till target is greater then start\\n\\t\\twhile (start < target) {\\n\\t\\t\\t// if target is odd. make it even as we can then perform divide operation. which\\n\\t\\t\\t// indeed make no of operation min\\n\\t\\t\\tif (target % 2 == 1) {\\n\\t\\t\\t\\ttarget++;\\n\\t\\t\\t} else {\\n\\t\\t\\t\\t// if target is even. divide by 2.\\n\\t\\t\\t\\ttarget = target / 2;\\n\\t\\t\\t}\\n\\t\\t\\t// increment operation\\n\\t\\t\\tans++;\\n\\t\\t}\\n\\t\\t// either start reaches target. in such case return ans. else then add 1 start -\\n\\t\\t// target no of times more to the target to make it equal to start.\\n\\t\\treturn ans + start - target;\\n\\t}\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1875531,
                "title": "easy-c-solution-using-recursion",
                "content": "\\'\\'\\'\\nclass Solution {\\npublic:\\n    int brokenCalc(int start, int target) {\\n        if(start==target) return 0;\\n        else if(start>target)  return start-target;\\n        else{\\n            if(target%2==1) return 1+brokenCalc(start,target+1);\\n            else return 1+brokenCalc(start,target/2);\\n        }\\n    }\\n};",
                "solutionTags": [
                    "C++",
                    "C",
                    "Recursion"
                ],
                "code": "class Solution {\\npublic:\\n    int brokenCalc(int start, int target) {\\n        if(start==target) return 0;\\n        else if(start>target)  return start-target;\\n        else{\\n            if(target%2==1) return 1+brokenCalc(start,target+1);\\n            else return 1+brokenCalc(start,target/2);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1875305,
                "title": "1-line-solution-c-100-faster",
                "content": "**If our start value is greater than target**,\\nthen we have no choice but to decrement it till we reach the target, that gives us *start - target* operations.\\n**If our target is odd**\\nthen we have to add 1 to make it even so as to make it a number that was possibly obtained by doubling the startValue.\\n**If our target is even**\\nthen we can divide this target by 2 \\n**Start - Target will become 0 after finite steps. Hence we get the answer.**\\n```\\nclass Solution {\\npublic:\\n    int brokenCalc(int S, int T) {\\n        return S >= T ? S - T : (T & 1 ? 1 + brokenCalc(S,T + 1) : 1 + brokenCalc(S,T/2));\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Greedy",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int brokenCalc(int S, int T) {\\n        return S >= T ? S - T : (T & 1 ? 1 + brokenCalc(S,T + 1) : 1 + brokenCalc(S,T/2));\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1875097,
                "title": "c-simple-math",
                "content": "As we are given only two operations multiply by 2 and substract 1.\\nIf number is even then the only way to reach it is by multiplying by 2 otherwise add one.\\n\\n```\\npublic class Solution {\\n    public int BrokenCalc(int startValue, int target) {\\n        int count=0;\\n        while(startValue<target)\\n        {\\n            if(target%2==0)\\n                target /=2;\\n            else\\n                target++;\\n            \\n            count++;\\n        }\\n        return count + (startValue-target);\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    public int BrokenCalc(int startValue, int target) {\\n        int count=0;\\n        while(startValue<target)\\n        {\\n            if(target%2==0)\\n                target /=2;\\n            else\\n                target++;\\n            \\n            count++;\\n        }\\n        return count + (startValue-target);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1875070,
                "title": "python-99-90-faster-o-n",
                "content": "```\\nclass Solution:\\n    def brokenCalc(self, startValue: int, target: int) -> int:\\n        if target <= startValue:\\n            return startValue - target\\n        else:\\n            steps = 0\\n            while target > startValue:\\n                if target % 2 != 0:\\n                    target += 1\\n                else:\\n                    target = target//2\\n                steps += 1\\n            steps += (startValue - target)\\n            return steps\\n                \\n                \\n```\\n\\n*If you think my solution helped you, please upvote :))*\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def brokenCalc(self, startValue: int, target: int) -> int:\\n        if target <= startValue:\\n            return startValue - target\\n        else:\\n            steps = 0\\n            while target > startValue:\\n                if target % 2 != 0:\\n                    target += 1\\n                else:\\n                    target = target//2\\n                steps += 1\\n            steps += (startValue - target)\\n            return steps\\n                \\n                \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1875055,
                "title": "javascript-o-n",
                "content": "```\\nvar brokenCalc = function(startValue, target) {\\n    let count = 0;\\n    while(target > startValue) {\\n        target%2 ? target++ : target /= 2;\\n        count++;\\n    }\\n    return count + (startValue - target)\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nvar brokenCalc = function(startValue, target) {\\n    let count = 0;\\n    while(target > startValue) {\\n        target%2 ? target++ : target /= 2;\\n        count++;\\n    }\\n    return count + (startValue - target)\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1874956,
                "title": "c-recursive-100-faster-easy-to-understand-simple-and-sort-o-log-n",
                "content": "**//Please upvote if you find this code is helplful**\\n\\n*Time Complexity : O(log n)\\nSpace Complexity: O(1)*\\n\\n```\\n\\nclass Solution {\\npublic:\\n    int brokenCalc(int startValue, int target) {\\n\\t\\n        if(startValue >= target){\\n            return startValue-target;\\n        }\\n        if(target%2 ==0){\\n            return 1 + brokenCalc(startValue, target/2);\\n        }\\n        return 1 + brokenCalc(startValue, target+1);\\n\\t\\t\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n\\nclass Solution {\\npublic:\\n    int brokenCalc(int startValue, int target) {\\n\\t\\n        if(startValue >= target){\\n            return startValue-target;\\n        }\\n        if(target%2 ==0){\\n            return 1 + brokenCalc(startValue, target/2);\\n        }\\n        return 1 + brokenCalc(startValue, target+1);\\n\\t\\t\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1874901,
                "title": "c-approach-from-start-to-target-explaination",
                "content": "Here is a approach that works from start to end.\\n**Working:**\\n1. Keep on multiplying start with 2 until start >= target, meanwhile also calculate the steps.\\n2. Now we have to remove the difference we have between start and target, from the examples you already know reducing at the end wont work.\\n**Here is the logic part:**\\nTo reduce the difference , if we had reduced 1 in any previous step, it would have got multiplied with power of 2s till now. SO using the step count , we can reduced the biggest possible 2\\'s power from difference\\nLets see with example \\n**start = 3 , end = 18\\n 3 -> 6 -> 12 -> 24   steps=4;**\\n difference = 24-18 = 6\\n Now we have to reduce this 6 to 0.\\n \\n If we reduced -1 when x=3 , it would have become -8 till which we cant subtract from 6.\\n If we reduced -1 when x=6 , it would have become -4 , which we can include. SO now diff = 6-4=2;\\n Now we need to reduce 2, when x is in 3phase i.e 12 (although it doesnt mean value would be 12 as we have modifed values in previous iterations) -1 will be become -2 in end and diff=0;\\n \\n```\\nclass Solution {\\npublic:\\n int brokenCalc(int startValue, int target) {\\n     if(startValue >= target)\\n         return startValue-target;\\n\\tlong long  x = startValue;\\n\\tint steps = 0;\\n\\twhile (x < target)\\n\\t\\tx *= 2, steps++;\\n\\tlong long diff =  x - target;\\n\\tif (diff==0) return steps;\\n\\tint i = steps;\\n\\twhile ( diff != 0) {\\n\\t\\tif (diff - (1<<i) >= 0) {\\n\\t\\t\\tdiff -= (1<<i);\\n\\t\\t\\tsteps++;\\n\\t\\t}\\n        else\\n\\t\\ti--;\\n\\t}\\n\\treturn steps;\\n}\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n int brokenCalc(int startValue, int target) {\\n     if(startValue >= target)\\n         return startValue-target;\\n\\tlong long  x = startValue;\\n\\tint steps = 0;\\n\\twhile (x < target)\\n\\t\\tx *= 2, steps++;\\n\\tlong long diff =  x - target;\\n\\tif (diff==0) return steps;\\n\\tint i = steps;\\n\\twhile ( diff != 0) {\\n\\t\\tif (diff - (1<<i) >= 0) {\\n\\t\\t\\tdiff -= (1<<i);\\n\\t\\t\\tsteps++;\\n\\t\\t}\\n        else\\n\\t\\ti--;\\n\\t}\\n\\treturn steps;\\n}\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1077265,
                "title": "python-broken-calculator-simple-solution",
                "content": "```\\ndef brokenCalc(self, X: int, Y: int) -> int:\\n        \\n        ops = 0\\n        \\n        while Y>X:      #reducing Y till it becomes less than X, calculating in reverse way\\n            if Y%2==1:  #if Y is odd, eg: 9 i.e 10-1\\n                Y+=1    \\n            else:\\n                Y=Y//2  #if Y is even \\n            ops+=1\\n        \\n        ops+=(X-Y)      #if X is greater than Y, we can only subtract\\n        \\n        return ops\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\ndef brokenCalc(self, X: int, Y: int) -> int:\\n        \\n        ops = 0\\n        \\n        while Y>X:      #reducing Y till it becomes less than X, calculating in reverse way\\n            if Y%2==1:  #if Y is odd, eg: 9 i.e 10-1\\n                Y+=1    \\n            else:\\n                Y=Y//2  #if Y is even \\n            ops+=1\\n        \\n        ops+=(X-Y)      #if X is greater than Y, we can only subtract\\n        \\n        return ops\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1076711,
                "title": "broken-calculator-c-beats-100-submissions-a-novel-solution-explanation-from-x-to-y",
                "content": "## An simple idea about bits operation\\n\\n* As the X = 3, and you add 1 to 3=> (3 + 1)\\\\\\nHowever, once double operator one time on X, the effect of the \"1\" would also double.\\n* Following the above example,\\n    * 3, add one => 4.\\xA0 \\xA0| 1\\n    * 4, double => 8.\\xA0 \\xA0 \\xA0| 0\\n    * 8, add one => 9.\\xA0 \\xA0| 1\\n    * 9, add one => 10\\xA0 | 1\\n    * 10, double => 20\\xA0 | 0\\n* As the times of double operation more, \"1\" would be effective more anywhere.\\\\\\nTherefore, we treat it as the operation of a bit.\\xA0\\xA0\\n\\n---\\n* e.g, `X=2`, `Y=24`\\n   > * And you would operate (2 -> 3 -> 6 -> 12 -> 24).\\nIf you add 1 to the first \"2\" => (2+1) * 2 * 2 * 2 ...\\nthe \"1\" become 1 * 2 * 2 * 2 ... * (n times)\\n   > * I thought that the \"2\" times 2 continuous until the number greater than \"24\" (Y).\\n=> 2 * 2 * 2 * 2 * 2 = 32. (n = 5)\\nand the different between 24 and 32 is eight.\\n\"8\", in other word, => (1000) on 2 based\\n\\nAs X forces four operations to Y, adding 1 to X, it becomes\\xA0subtracts \"4\".\\\\\\nFinally, the answer is n\\xA0+ (1000)_2 (how many 1\\'s in the number base on 2?)\\\\\\n=> 9\\xA0+ 1 = 10\\n\\n---\\n\\nHowever, cautions for a case...\\\\\\nIs your \"different\" over the n bits can represent, and then the n bits be regarded as \"largest\"?\\n\\ne.g. `X=68`, `Y=71`=> 68 * 2 = 136 > 71. (n = 2)\\n\\n* Different: 136-71 = 6565 => (1000001), \\nit takes seven bits to represent it......n = 2, \\nonly to subtract \"(0)1\"\\ntherefore, shifts 1 bit right => 100000 (32)\\xA0\\n\\n* finally, you should do 32\\xA0+ 1 times subtracting and one double operation to get Y.\\n68 -> 36 -> 72 -> 71(32 time + 1 times + 1 times => 34 times)\\n\\n---\\n\\nIt\\'s **C++ code**:\\n\\n```\\nclass Solution {\\npublic:\\n    typedef struct{\\n        int32_t x;\\n        int32_t pow;\\n    }s_pair;\\n    \\n    int32_t pow(int32_t X, int32_t Y, int32_t &ans){\\n        ans = 0;\\n        while (X < Y){\\n            ans += 1;\\n            X *= 2;\\n        }\\n        return X;\\n    }\\n    \\n    int brokenCalc(int X, int Y) {\\n        int32_t ans = 0;\\n        \\n        int32_t temp = pow(X, Y, ans);\\n        int32_t tp = temp - Y;\\n        if (X > Y)\\n            ans = X - Y;\\n        else{\\n            int32_t anst = ans;\\n            int32_t i = 0;\\n            while (tp > 0 && anst > i){\\n                ans += (tp & 1 > 0);\\n                tp >>= 1;\\n                i += 1;\\n            }\\n            ans += tp;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    typedef struct{\\n        int32_t x;\\n        int32_t pow;\\n    }s_pair;\\n    \\n    int32_t pow(int32_t X, int32_t Y, int32_t &ans){\\n        ans = 0;\\n        while (X < Y){\\n            ans += 1;\\n            X *= 2;\\n        }\\n        return X;\\n    }\\n    \\n    int brokenCalc(int X, int Y) {\\n        int32_t ans = 0;\\n        \\n        int32_t temp = pow(X, Y, ans);\\n        int32_t tp = temp - Y;\\n        if (X > Y)\\n            ans = X - Y;\\n        else{\\n            int32_t anst = ans;\\n            int32_t i = 0;\\n            while (tp > 0 && anst > i){\\n                ans += (tp & 1 > 0);\\n                tp >>= 1;\\n                i += 1;\\n            }\\n            ans += tp;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1076471,
                "title": "c-two-approaches-one-bfs-and-the-other-greedy",
                "content": "My first approach was to use DFS . \\n You will get TLE on this .\\n ```\\n class Solution {\\npublic:\\n    struct node{\\n        int val;\\n        int level;\\n    };\\n    int brokenCalc(int X, int Y) {\\n        \\n \\n         set<int> visit;\\n    if(X==Y)\\n        return 0;\\n    if(X>Y)\\n        return X-Y;\\n   \\n    queue<node> q;\\n    node n = {X, 0};\\n    q.push(n);\\n \\n \\n    while (!q.empty())\\n    {\\n        \\n        node t = q.front();\\n        q.pop();\\n \\n        \\n        if (t.val == Y)\\n            return t.level;\\n \\n        \\n        visit.insert(t.val);\\n \\n        \\n        if (t.val*2 == Y || t.val-1 == Y)\\n            return t.level+1;\\n \\n       \\n        if (visit.find(t.val*2) == visit.end())\\n        {\\n            n.val = t.val*2;\\n            n.level = t.level+1;\\n            q.push(n);\\n        }\\n        if (t.val-1>=0 && visit.find(t.val-1) == visit.end())\\n        {\\n            n.val = t.val-1;\\n            n.level = t.level+1;\\n            q.push(n);\\n        }\\n    }\\n        return 0;\\n    }\\n    \\n};\\n```\\n2nd Approach : Greedy Approach from Backward . p.s : Everyone Shared this .\\n``` \\nclass Solution {\\npublic:\\n    int brokenCalc(int X, int Y) {\\n     \\n        if(X==Y)\\n            return 0;\\n        \\n        int ans=0;\\n        while(Y>X){\\n            ans++;\\n            if(Y%2)\\n                Y++;\\n            else\\n                Y=Y/2;\\n        }\\n        return ans+(X-Y);\\n    }\\n}; \\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Greedy",
                    "Breadth-First Search"
                ],
                "code": "```\\n class Solution {\\npublic:\\n    struct node{\\n        int val;\\n        int level;\\n    };\\n    int brokenCalc(int X, int Y) {\\n        \\n \\n         set<int> visit;\\n    if(X==Y)\\n        return 0;\\n    if(X>Y)\\n        return X-Y;\\n   \\n    queue<node> q;\\n    node n = {X, 0};\\n    q.push(n);\\n \\n \\n    while (!q.empty())\\n    {\\n        \\n        node t = q.front();\\n        q.pop();\\n \\n        \\n        if (t.val == Y)\\n            return t.level;\\n \\n        \\n        visit.insert(t.val);\\n \\n        \\n        if (t.val*2 == Y || t.val-1 == Y)\\n            return t.level+1;\\n \\n       \\n        if (visit.find(t.val*2) == visit.end())\\n        {\\n            n.val = t.val*2;\\n            n.level = t.level+1;\\n            q.push(n);\\n        }\\n        if (t.val-1>=0 && visit.find(t.val-1) == visit.end())\\n        {\\n            n.val = t.val-1;\\n            n.level = t.level+1;\\n            q.push(n);\\n        }\\n    }\\n        return 0;\\n    }\\n    \\n};\\n```\n``` \\nclass Solution {\\npublic:\\n    int brokenCalc(int X, int Y) {\\n     \\n        if(X==Y)\\n            return 0;\\n        \\n        int ans=0;\\n        while(Y>X){\\n            ans++;\\n            if(Y%2)\\n                Y++;\\n            else\\n                Y=Y/2;\\n        }\\n        return ans+(X-Y);\\n    }\\n}; \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1076114,
                "title": "0-ms-100-best-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int brokenCalc(int X, int Y) {\\n        if(X==Y)\\n        {\\n            return 0;\\n        }\\n        if(X>Y)\\n        {\\n            return X-Y;\\n        }\\n        else\\n        {\\n            if(Y%2==1)\\n            {\\n                return 1+brokenCalc(X,Y+1);\\n            }\\n            else\\n            {\\n                return 1+brokenCalc(X,Y/2);\\n            }\\n        }\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int brokenCalc(int X, int Y) {\\n        if(X==Y)\\n        {\\n            return 0;\\n        }\\n        if(X>Y)\\n        {\\n            return X-Y;\\n        }\\n        else\\n        {\\n            if(Y%2==1)\\n            {\\n                return 1+brokenCalc(X,Y+1);\\n            }\\n            else\\n            {\\n                return 1+brokenCalc(X,Y/2);\\n            }\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1076110,
                "title": "broken-calculator-c-beats-100-submissions-easy-explanation-simple-maths",
                "content": "According to the question, we can perform two types of operations:\\n1] X=X*2;\\n2]X=X-1;\\n\\nIt can be easily observed that when  X>Y  ito reach Y in minimum number of steps, we should \\nonly use the second operation.But  when Y>X  we don\\'t get any clear idea as such about how to proceed.(And as   1<=X,Y<=1e9  brute force approach would lead to TLE.)\\n\\nIf you observe both the give operations are in terms of X;\\nNow if consider equivalent operations in terms of Y(and try to X from Y), it would as follows:\\n1] Y=Y/2;\\n2]Y=Y+1;\\n\\nWe can say that this set of Operations (i.e the one w.r.t Y)  are more convinient as,\\nthe 1st operation can only be applied if Y is even.Similarly if Y is odd operation 1 cannot be performed hence only allowed operation remain operation 2.\\n\\nSo From this we can say that-->\\nif(Y is odd) Y=Y+1;\\nelse Y=Y/2;\\n\\nAnd we repeat the above until Y becomes X.\\n\\n## CODE-->\\n```\\nclass Solution {\\npublic:\\n   \\n    int getAns(int x, int y) \\n    { \\n        if (x>=y)return x-y; \\n        if (y % 2 == 1)return (1 + getAns(x, y + 1)); \\n        else return (1 + getAns(x, y / 2)); \\n        \\n    } \\n    int brokenCalc(int X, int Y){\\n       \\n      return getAns(X,Y);\\n        \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n   \\n    int getAns(int x, int y) \\n    { \\n        if (x>=y)return x-y; \\n        if (y % 2 == 1)return (1 + getAns(x, y + 1)); \\n        else return (1 + getAns(x, y / 2)); \\n        \\n    } \\n    int brokenCalc(int X, int Y){\\n       \\n      return getAns(X,Y);\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1075990,
                "title": "java-recursive-2-lines-of-code",
                "content": "```\\n\\tpublic int brokenCalc(int X, int Y) {\\n        if(X >= Y) return X - Y;\\n        return 1 + brokenCalc(X, (Y % 2 == 0) ? Y / 2 : Y + 1);\\n    }",
                "solutionTags": [],
                "code": "```\\n\\tpublic int brokenCalc(int X, int Y) {\\n        if(X >= Y) return X - Y;\\n        return 1 + brokenCalc(X, (Y % 2 == 0) ? Y / 2 : Y + 1);\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1033822,
                "title": "easy-clear-solution-python-3",
                "content": "```\\nclass Solution:\\n    def brokenCalc(self, x: int, y: int) -> int:\\n        if y<=x:\\n            return x-y\\n        else:\\n            res=0\\n            while x<y:\\n                if y%2==1:\\n                    y+=1\\n                else:\\n                    y=y//2\\n                res+=1\\n            res+=(x-y)\\n            return res\\n            \\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def brokenCalc(self, x: int, y: int) -> int:\\n        if y<=x:\\n            return x-y\\n        else:\\n            res=0\\n            while x<y:\\n                if y%2==1:\\n                    y+=1\\n                else:\\n                    y=y//2\\n                res+=1\\n            res+=(x-y)\\n            return res\\n            \\n```",
                "codeTag": "Java"
            },
            {
                "id": 788047,
                "title": "simple-java-backward-solution",
                "content": "```\\nclass Solution {\\n    public int brokenCalc(int X, int Y) {\\n        int res = 0;\\n        while (X != Y) {\\n            if (Y % 2 == 1) {\\n                Y++;\\n                res++;\\n            } else {\\n                if (Y < X) {\\n                    res += X - Y;\\n                    Y = X;\\n                } else {\\n                    Y /= 2;\\n                    res++;\\n                }\\n            }        \\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int brokenCalc(int X, int Y) {\\n        int res = 0;\\n        while (X != Y) {\\n            if (Y % 2 == 1) {\\n                Y++;\\n                res++;\\n            } else {\\n                if (Y < X) {\\n                    res += X - Y;\\n                    Y = X;\\n                } else {\\n                    Y /= 2;\\n                    res++;\\n                }\\n            }        \\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 748006,
                "title": "python-explained-high-speed-reversed-approach",
                "content": "**Python Explained | High Speed | Reversed Approach**\\n\\nThe code below presents a Python solution with the notes I used to work out the problem. I hope they are helpful. Cheers,\\n\\n```\\n# Explanation: Let\\'s think the other way around for a second:\\n#           3 -> 10 = 3,6,5,10 (multiply or subtract) ( << 1 , -1)\\n#       This is the same as:\\n#           10 -> 3 = 10,5,6,3 (divide   or sum     ) ( >> 1 , +1) \\n#\\n# Since Bit destruction is somewhat easier:\\n#     - Pop everything, until we reach the required bit length  (adding before reaching len(X) is inefficient (or equal at best))\\n#         - Notice that we can\\'t pop if we don\\'t have a zero at the last bit (we might need to sum one before)\\n#     - Then add the difference between X, and Y:\\n#         - If Y was already higher, divide it by 2 before (but ensure there is a zero at last bit)\\n#\\n# By looking at the algorithm, we need actually to:\\n#     - Pop everything while Y>X\\n#     - Add the difference between [X,Y]\\n#\\nclass Solution:\\n   def brokenCalc(self, X, Y):\\n       # Easy Edge Case, X is higher (or equal since X-Y = 0)\\n       if Y<=X:\\n           return X-Y # We can do nothing but subtract\\n       #\\n       # Y is bigger, now let\\'s think the other way around\\n       n  = 0\\n       while Y>X:\\n           if Y&1:\\n               Y += 1\\n               n += 1\\n           Y >>= 1\\n           n  += 1\\n       n += X-Y # sum to Y until we reach X\\n       return n\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\n# Explanation: Let\\'s think the other way around for a second:\\n#           3 -> 10 = 3,6,5,10 (multiply or subtract) ( << 1 , -1)\\n#       This is the same as:\\n#           10 -> 3 = 10,5,6,3 (divide   or sum     ) ( >> 1 , +1) \\n#\\n# Since Bit destruction is somewhat easier:\\n#     - Pop everything, until we reach the required bit length  (adding before reaching len(X) is inefficient (or equal at best))\\n#         - Notice that we can\\'t pop if we don\\'t have a zero at the last bit (we might need to sum one before)\\n#     - Then add the difference between X, and Y:\\n#         - If Y was already higher, divide it by 2 before (but ensure there is a zero at last bit)\\n#\\n# By looking at the algorithm, we need actually to:\\n#     - Pop everything while Y>X\\n#     - Add the difference between [X,Y]\\n#\\nclass Solution:\\n   def brokenCalc(self, X, Y):\\n       # Easy Edge Case, X is higher (or equal since X-Y = 0)\\n       if Y<=X:\\n           return X-Y # We can do nothing but subtract\\n       #\\n       # Y is bigger, now let\\'s think the other way around\\n       n  = 0\\n       while Y>X:\\n           if Y&1:\\n               Y += 1\\n               n += 1\\n           Y >>= 1\\n           n  += 1\\n       n += X-Y # sum to Y until we reach X\\n       return n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 647400,
                "title": "c-2-lines-intuition",
                "content": "**Intuition:**\\nIf (X > Y) only way possible to keep decrementing till Y.\\nIf Y is even, then Y can be reached by reaching Y/2 and adding then 1 step of multiplying by 2.\\nIf Y is odd, then Y can be reached by reaching Y+1, and then 1 step of subtracting 1.\\n\\n**Solution:**\\n\\n```\\nclass Solution {\\npublic:\\n    int brokenCalc(int X, int Y) {\\n        \\n        if (X >= Y) return X-Y;\\n        return Y%2 == 0 ? 1 + brokenCalc(X, Y/2) : 1 + brokenCalc(X, Y+1);\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int brokenCalc(int X, int Y) {\\n        \\n        if (X >= Y) return X-Y;\\n        return Y%2 == 0 ? 1 + brokenCalc(X, Y/2) : 1 + brokenCalc(X, Y+1);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 496189,
                "title": "100-javascript-solution-thoroughly-explained-algorithm",
                "content": "First I will paste the code then explain.\\n\\n```\\nconst brokenCalc = function(X, Y) {\\n    if (Y <= X) return X - Y;\\n    let count = 0;\\n    let acc = Y;\\n    \\n    while (acc > X) {\\n        if (acc%2 !== 0) {\\n            acc++;\\n            count++;\\n        }\\n        acc /= 2;\\n        count ++;\\n    }\\n    return count + X - acc;\\n};\\n```\\n\\nFirst, we must split the case into two scenarios. The first case is if Y (second parameter) is less than X. The last example given by the problem matches this: Y=1, X=1024. Because multiplying by 2 will not bring X closer to Y, the only way is to substract 1. Hence, the answer is simply however many times you would subtract 1, and the easiest way to do that is to return the difference between Y and X, hence the first line in the function `if (Y <= X) return X - Y`.\\n\\nThe second scenario is more complicated, because it requires you to combine both multiplication and subtraction operation, and you must find the combination which would have the lowest number of total operations.\\n\\nThe way I did this was by working backwards. I started with Y, and the operations I was counting were instead:\\n1. divide by 2\\n2. add 1\\nTo avoid confusion in this explanation, I will call these operations WBO (working backwards operations). The others, the ones provided by the problem statement, we will call them WFO (working forwards operations).\\n\\nAfter we go through the entire solution, you\\'ll see why I did it in reverse.\\n\\nSay we start with example Y=75, and X=14.\\nThinking in terms WFO, the only way for X to get closer to Y (assuming Y is bigger) is using the \"multiply by 2\" operation. \"subtract 1\" is still important to help us reduce the total number of operations.\\n\\na \"multiply by 2\" operation will always return an even number. If we want to somehow arrive at an odd number, we must use subtract to get there.\\n\\nusing our example, Y=75 which is an odd number. This means that we must use subtract at some point. in WBO terms, we must add 1, and that is one operation. Since we are starting with operations, let\\'s define two variables.\\n\\n`acc` short for \"accumulator\", and it is the intermediary number that we will perform operations on to get to our answer.\\n`count` is the number of operations we have so far performed.\\n\\nafter we add 1 to 75, this means acc=76 and count is 1 because we performed one operation. Now that we have an even number, we know we can get to this number through multiplication in WFO terms. in WBO terms, we divide by two.\\n\\n```\\nacc = 76 / 2 = 38\\ncount = 2\\n```\\n\\nnow we have 38. So we repeat the process. First, we check, can we arrive to this number by multiplying by 2 in WFO terms? In other words, is this number even? if it is, we proceed with dividing by 2 in WBO terms. If it is not, we make it so by adding 1 in WBO terms.\\n\\nIt is even, so we can divide by 2 in WBO.\\n\\n```\\nacc  = 38/2 = 19\\ncount = 3\\n```\\n\\nWe do it again. Is 19 even or odd? it is odd. This means we must add in WBO, because otherwise, we cannot get there by multiplying by two.\\n\\n```\\nacc = 19+1 = 20\\ncount = 4\\n```\\n\\nNow we can divide by two in WBO. However, before we do this, we should note a pattern. In every step, we do the following:\\n1. check if even or odd. If even, skip to step 3. Otherwise, proceed to step 2.\\n2. add 1 (only if it is odd)\\n3. divide by 2\\n\\nThis explains this portion of the code:\\n```\\nif (acc%2 !== 0) {\\n\\tacc++;\\n\\tcount++;\\n}\\nacc /= 2;\\ncount ++;\\n```\\n\\nWhat\\'s the check in while loop for? we\\'re about to find out. Let\\'s proceed.\\n\\n```\\nacc = 20 / 2 = 10\\ncount = 5\\n```\\n\\nso, then we proceed with the usual ... or should we? no we should not. The reason why is that `acc` is now less than `X`. If we divide by 2 (WBO), we will move even farther from X, which is 14, because are no longer at a value greater than `X`. This explains the while loop check.\\n\\nSo, what do we do? Well, since `acc` is less than `X`, this is the same as the first scenario we discussed, where `Y` is smaller `X`. This means that the number of steps left is `X - acc` because they are merely a series of additions in WBO. The final answer must equal that number + `count` that we have already been tallying. This explains the last line in the function.\\n\\nThis technically means that we would not have really need the first if statement at the beginning, because it is redundant. But it was valuable to explain the algorithm.\\n\\nThe reason why we worked backwards is that we would not be able to find the point where, after we subtract several times, we start multiplying by 2 (WFO). In other words, starting with `X=14`, you would not know that you must subtract 1 until you reach 10. Why not 9? or 12? or 7?\\n\\nBONUS:\\n\\nHere is an even shorter way of writing this, using recursion, (nested) ternaries, and arrow functions:\\n\\n```\\nconst brokenCalc = (X, Y) => (Y <= X) ? X - Y : (Y % 2 === 0) ? brokenCalc(X, Y / 2) + 1 : brokenCalc(X, Y+1) + 1;\\n```",
                "solutionTags": [],
                "code": "```\\nconst brokenCalc = function(X, Y) {\\n    if (Y <= X) return X - Y;\\n    let count = 0;\\n    let acc = Y;\\n    \\n    while (acc > X) {\\n        if (acc%2 !== 0) {\\n            acc++;\\n            count++;\\n        }\\n        acc /= 2;\\n        count ++;\\n    }\\n    return count + X - acc;\\n};\\n```\n```\\nacc = 76 / 2 = 38\\ncount = 2\\n```\n```\\nacc  = 38/2 = 19\\ncount = 3\\n```\n```\\nacc = 19+1 = 20\\ncount = 4\\n```\n```\\nif (acc%2 !== 0) {\\n\\tacc++;\\n\\tcount++;\\n}\\nacc /= 2;\\ncount ++;\\n```\n```\\nacc = 20 / 2 = 10\\ncount = 5\\n```\n```\\nconst brokenCalc = (X, Y) => (Y <= X) ? X - Y : (Y % 2 === 0) ? brokenCalc(X, Y / 2) + 1 : brokenCalc(X, Y+1) + 1;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 481824,
                "title": "two-lines-c-0ms",
                "content": "Y only can be even or odd. If Y is even, can be arrived through x * 2, i.e, x should arrive Y/2 first. We need {brokenCalc(X, Y/2) + 1} steps;\\nIf Y is odd, only can be achieved this  -1 operation, i.e., x should arrive (Y+1) first. We need {brokenCalc(X, Y + 1) + 1} steps;\\n\\t\\n\\tint brokenCalc(int X, int Y) {\\n        if (Y <= X) return X - Y;\\n        return (Y % 2 == 0)? brokenCalc(X, Y / 2) + 1 : brokenCalc(X, Y + 1) + 1;\\n    }\\n\\t\\n\\t",
                "solutionTags": [],
                "code": "Y only can be even or odd. If Y is even, can be arrived through x * 2, i.e, x should arrive Y/2 first. We need {brokenCalc(X, Y/2) + 1} steps;\\nIf Y is odd, only can be achieved this  -1 operation, i.e., x should arrive (Y+1) first. We need {brokenCalc(X, Y + 1) + 1} steps;\\n\\t\\n\\tint brokenCalc(int X, int Y) {\\n        if (Y <= X) return X - Y;\\n        return (Y % 2 == 0)? brokenCalc(X, Y / 2) + 1 : brokenCalc(X, Y + 1) + 1;\\n    }\\n\\t\\n\\t",
                "codeTag": "Unknown"
            },
            {
                "id": 352258,
                "title": "c-solution",
                "content": "```\\npublic class Solution \\n{\\n    public int BrokenCalc(int x, int y) \\n    {\\n        if(x >= y) return x - y;\\n        if(y % 2 == 0) return 1 + BrokenCalc(x, y / 2);\\n        return 1 + BrokenCalc(x, y + 1);\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution \\n{\\n    public int BrokenCalc(int x, int y) \\n    {\\n        if(x >= y) return x - y;\\n        if(y % 2 == 0) return 1 + BrokenCalc(x, y / 2);\\n        return 1 + BrokenCalc(x, y + 1);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3643922,
                "title": "simple-c-solution-best-for-beginners",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int brokenCalc(int X, int Y) {\\n        int res = 0;\\n        while (Y > X) {\\n            Y = Y % 2 > 0 ? Y + 1 : Y / 2;\\n            res++;\\n        }\\n        return res + X - Y;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int brokenCalc(int X, int Y) {\\n        int res = 0;\\n        while (Y > X) {\\n            Y = Y % 2 > 0 ? Y + 1 : Y / 2;\\n            res++;\\n        }\\n        return res + X - Y;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3536528,
                "title": "solution",
                "content": "```C++ []\\nclass Solution {\\n public:\\n  int brokenCalc(int X, int Y) {\\n    int ops = 0;\\n\\n    while (X < Y) {\\n      if (Y % 2 == 0)\\n        Y /= 2;\\n      else\\n        Y += 1;\\n      ++ops;\\n    }\\n    return ops + X - Y;\\n  }\\n};\\n```\\n\\n```Python3 []\\nclass Solution:\\n    def brokenCalc(self, startValue: int, target: int) -> int:\\n        ans = 0 \\n        while target > startValue:\\n            if not target % 2:\\n                target /= 2\\n            else:\\n                target += 1\\n\\n            ans += 1\\n\\n        return ans + int(startValue - target)\\n```\\n\\n```Java []\\nclass Solution {\\n    public int brokenCalc(int startValue, int target) {\\n        if(startValue >= target) return startValue - target;\\n        if(target % 2 == 0){\\n            return 1 + brokenCalc(startValue, target / 2);\\n        }\\n        return 1 + brokenCalc(startValue, target + 1);\\n    }\\n}\\n```\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3"
                ],
                "code": "```C++ []\\nclass Solution {\\n public:\\n  int brokenCalc(int X, int Y) {\\n    int ops = 0;\\n\\n    while (X < Y) {\\n      if (Y % 2 == 0)\\n        Y /= 2;\\n      else\\n        Y += 1;\\n      ++ops;\\n    }\\n    return ops + X - Y;\\n  }\\n};\\n```\n```Python3 []\\nclass Solution:\\n    def brokenCalc(self, startValue: int, target: int) -> int:\\n        ans = 0 \\n        while target > startValue:\\n            if not target % 2:\\n                target /= 2\\n            else:\\n                target += 1\\n\\n            ans += 1\\n\\n        return ans + int(startValue - target)\\n```\n```Java []\\nclass Solution {\\n    public int brokenCalc(int startValue, int target) {\\n        if(startValue >= target) return startValue - target;\\n        if(target % 2 == 0){\\n            return 1 + brokenCalc(startValue, target / 2);\\n        }\\n        return 1 + brokenCalc(startValue, target + 1);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2809393,
                "title": "c-easy-fast",
                "content": "\\n\\n# Code\\n```\\n\\t\\t\\t\\t\\nclass Solution {\\npublic:\\n    int brokenCalc(int startValue, int target) {\\n        if(startValue >= target)\\n            return startValue - target;\\n        \\n        if(target & 1)\\n            return 1 + brokenCalc(startValue, target  + 1);\\n        \\n        return 1 + brokenCalc(startValue, target / 2);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n\\t\\t\\t\\t\\nclass Solution {\\npublic:\\n    int brokenCalc(int startValue, int target) {\\n        if(startValue >= target)\\n            return startValue - target;\\n        \\n        if(target & 1)\\n            return 1 + brokenCalc(startValue, target  + 1);\\n        \\n        return 1 + brokenCalc(startValue, target / 2);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2645546,
                "title": "100-faster-c-recursion",
                "content": "```\\nclass Solution {\\npublic:\\n    int brokenCalc(int i, int j) {\\n        if(i>=j){\\n            return (i-j);\\n        }\\n        if(j%2){\\n            return 1+brokenCalc(i,j+1);\\n        }\\n        else{\\n            return 1+brokenCalc(i,(j>>1));\\n        }\\n        return 0;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Math",
                    "Greedy",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int brokenCalc(int i, int j) {\\n        if(i>=j){\\n            return (i-j);\\n        }\\n        if(j%2){\\n            return 1+brokenCalc(i,j+1);\\n        }\\n        else{\\n            return 1+brokenCalc(i,(j>>1));\\n        }\\n        return 0;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2501378,
                "title": "o-log-n-time-o-1-space-clear-explanation-change-2-1-to-2-1",
                "content": "![image](https://assets.leetcode.com/users/images/046804c6-93fc-460b-a0ca-26266e4d25cb_1661796524.3940682.png)\\n\\n    def brokenCalc(self, startValue: int, target: int) -> int:\\n        \"\"\" O(log N)TS \"\"\"\\n        if startValue >= target:\\n            return startValue - target\\n        return 1 + self.brokenCalc(startValue, target // 2 if target % 2 == 0 else target + 1)\\n\\n    def brokenCalc(self, startValue: int, target: int, ans=0) -> int:\\n        \"\"\" O(log N)T O(1)S \"\"\"\\n\\n        while startValue < target:\\n            target = target // 2 if target % 2 == 0 else target + 1\\n            ans += 1\\n\\n        return ans + startValue - target",
                "solutionTags": [],
                "code": "![image](https://assets.leetcode.com/users/images/046804c6-93fc-460b-a0ca-26266e4d25cb_1661796524.3940682.png)\\n\\n    def brokenCalc(self, startValue: int, target: int) -> int:\\n        \"\"\" O(log N)TS \"\"\"\\n        if startValue >= target:\\n            return startValue - target\\n        return 1 + self.brokenCalc(startValue, target // 2 if target % 2 == 0 else target + 1)\\n\\n    def brokenCalc(self, startValue: int, target: int, ans=0) -> int:\\n        \"\"\" O(log N)T O(1)S \"\"\"\\n\\n        while startValue < target:\\n            target = target // 2 if target % 2 == 0 else target + 1\\n            ans += 1\\n\\n        return ans + startValue - target",
                "codeTag": "Python3"
            },
            {
                "id": 2465756,
                "title": "c-solution-time-o-log-target-memory-o-1-beats-100-easy-to-understand-greedy",
                "content": "```C#\\npublic class Solution {\\n    public int BrokenCalc(int startValue, int target) {\\n        int ans = 0;\\n        while (startValue < target) {\\n            if (target % 2 == 1) target++;\\n            else target /= 2;\\n            ans++;\\n        }\\n        \\n        if (startValue == target) return ans;\\n        return ans + startValue - target;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Greedy"
                ],
                "code": "```C#\\npublic class Solution {\\n    public int BrokenCalc(int startValue, int target) {\\n        int ans = 0;\\n        while (startValue < target) {\\n            if (target % 2 == 1) target++;\\n            else target /= 2;\\n            ans++;\\n        }\\n        \\n        if (startValue == target) return ans;\\n        return ans + startValue - target;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2460180,
                "title": "c-2-line-solution-iterative-solution-easy-observation",
                "content": "```\\nclass Solution {\\npublic:\\n    int brokenCalc(int start, int target) {\\n        int ct=0;\\n        while(target!=start){\\n            if(target%2==0 and start<=target) target/=2;\\n            else target++;\\n              ct++; }\\n        return ct;\\n    }\\n};\\n**If You Like It Please Upvote.**\\n```",
                "solutionTags": [
                    "C",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int brokenCalc(int start, int target) {\\n        int ct=0;\\n        while(target!=start){\\n            if(target%2==0 and start<=target) target/=2;\\n            else target++;\\n              ct++; }\\n        return ct;\\n    }\\n};\\n**If You Like It Please Upvote.**\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2336431,
                "title": "greedy-with-basic-maths-100-fast-and-100-memory-efficient",
                "content": "```\\nclass Solution {\\npublic:\\n    int brokenCalc(int start, int target) {\\n        int ans = 0;\\n        while(target>start){\\n            if(target%2){\\n                target++;\\n                ans++;\\n            }\\n            target /= 2;\\n            ans++;\\n        }\\n        return ans + start - target;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int brokenCalc(int start, int target) {\\n        int ans = 0;\\n        while(target>start){\\n            if(target%2){\\n                target++;\\n                ans++;\\n            }\\n            target /= 2;\\n            ans++;\\n        }\\n        return ans + start - target;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2111139,
                "title": "c-100-faster-tc-log-n-detailed-logic",
                "content": "```\\n// 1- Here we have been given (either multiply by 2 or decrement 1) to startValue, So we can have three possible condition-\\n// 1a- startValue become equal to target\\n// 1b- startValue become greater than target\\n// 1c - startValue is less than target\\n// 2- You  might think that we will multiply by 2 until startValue<=target and then substract if startValue become greater. But 2nd test case will not pass though this logic.\\n// 3- So instead of making startValue to target ,we will do just opposite. We will devide until target is greater than startValue and finally add if target become less than startValue\\nclass Solution {\\npublic:\\n    int brokenCalc(int startVal, int target) {\\n        if(startVal>=target) return startVal-target;\\n        int cnt=0;\\n        while(target>startVal)\\n        {\\n            if(target%2==0)\\n            target/=2;\\n            else target+=1;\\n            cnt++;\\n        }\\n        if(startVal>target) cnt+=(startVal-target);\\n        return cnt;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Math"
                ],
                "code": "```\\n// 1- Here we have been given (either multiply by 2 or decrement 1) to startValue, So we can have three possible condition-\\n// 1a- startValue become equal to target\\n// 1b- startValue become greater than target\\n// 1c - startValue is less than target\\n// 2- You  might think that we will multiply by 2 until startValue<=target and then substract if startValue become greater. But 2nd test case will not pass though this logic.\\n// 3- So instead of making startValue to target ,we will do just opposite. We will devide until target is greater than startValue and finally add if target become less than startValue\\nclass Solution {\\npublic:\\n    int brokenCalc(int startVal, int target) {\\n        if(startVal>=target) return startVal-target;\\n        int cnt=0;\\n        while(target>startVal)\\n        {\\n            if(target%2==0)\\n            target/=2;\\n            else target+=1;\\n            cnt++;\\n        }\\n        if(startVal>target) cnt+=(startVal-target);\\n        return cnt;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1899262,
                "title": "broken-calculator-o-n-logic",
                "content": "class Solution {\\n    public int brokenCalc(int startValue, int target) {\\n        int count=0;\\n        while(startValue!=target)\\n        { if(target>startValue)\\n            if(target%2==0&&(startValue-target)!=1 )\\n            {\\n                target=target/2;\\n                count++;\\n            }\\n             else{\\n                target = target+1;\\n                count++;\\n            }\\n             else{\\n                startValue=startValue-1;\\n                    count++;\\n}}\\n        return count;\\n        \\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public int brokenCalc(int startValue, int target) {\\n        int count=0;\\n        while(startValue!=target)\\n        { if(target>startValue)\\n            if(target%2==0&&(startValue-target)!=1 )\\n            {\\n                target=target/2;\\n                count++;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1885472,
                "title": "beats-100-o-1-space",
                "content": "```\\nclass Solution {\\npublic:\\n    int brokenCalc(int start, int target) {\\n        int ans=0;\\n        while(start!=target){\\n            if(target > start and target%2==0)\\n                target/=2;\\n            else if(target > start)\\n                ++target;\\n            else{\\n                ans+=abs(target-start)-1;\\n                target=start;\\n            }\\n            ++ans;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Math",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int brokenCalc(int start, int target) {\\n        int ans=0;\\n        while(start!=target){\\n            if(target > start and target%2==0)\\n                target/=2;\\n            else if(target > start)\\n                ++target;\\n            else{\\n                ans+=abs(target-start)-1;\\n                target=start;\\n            }\\n            ++ans;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1882451,
                "title": "python3-simple-solution",
                "content": "```\\ndef brokenCalc(self, start: int, target: int) -> int:\\n        \\n        count = 0\\n        while target > start:\\n            if target%2 != 0:\\n                target += 1\\n            else:\\n                target//=2\\n                \\n            count += 1\\n            \\n        count += start - target\\n            \\n            \\n        return count\\n```",
                "solutionTags": [],
                "code": "```\\ndef brokenCalc(self, start: int, target: int) -> int:\\n        \\n        count = 0\\n        while target > start:\\n            if target%2 != 0:\\n                target += 1\\n            else:\\n                target//=2\\n                \\n            count += 1\\n            \\n        count += start - target\\n            \\n            \\n        return count\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1877523,
                "title": "c-100-faster-solution-0ms-easy-approach",
                "content": "**C++ Solution**\\n```\\nclass Solution {\\npublic:\\n    int brokenCalc(int startValue, int target) {\\n    int count=0; \\n        while (startValue < target) \\n        {   count++;\\n            if (target % 2) target++;\\n            else target /= 2;\\n        }\\n    return startValue-target+count;\\n    }\\n};",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n    int brokenCalc(int startValue, int target) {\\n    int count=0; \\n        while (startValue < target) \\n        {   count++;\\n            if (target % 2) target++;\\n            else target /= 2;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1877499,
                "title": "c-easy-approach-leetcode-challenge",
                "content": "```\\nclass Solution {\\npublic:\\n    int brokenCalc(int startValue, int target) {\\n        int count=0;\\n        while(startValue<target)\\n        {\\n            if(target%2==0)\\n            {\\n              target/=2;\\n              count++;\\n            }\\n            else\\n            {\\n                target+=1;\\n                count++;\\n            }\\n        }\\n        return count+startValue-target;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int brokenCalc(int startValue, int target) {\\n        int count=0;\\n        while(startValue<target)\\n        {\\n            if(target%2==0)\\n            {\\n              target/=2;\\n              count++;\\n            }\\n            else\\n            {\\n                target+=1;\\n                count++;\\n            }\\n        }\\n        return count+startValue-target;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1877421,
                "title": "easy-java-solution",
                "content": "```\\nclass Solution {\\n    public int brokenCalc(int startValue, int target) {\\n        \\n        int ans=0;\\n        //Check if target is even or odd\\n        while(startValue<target)\\n        {\\n\\t\\t   //If even, divide the target by 2 and increment the ans by 1\\n            if(target%2==0)\\n            {\\n                target/=2;\\n                ans++;\\n            }\\n            else{\\n\\t\\t\\t   //If odd, add 1 to target and increment the ans by 1\\n                target++;\\n                ans++;\\n            }\\n        }\\n        \\n        \\n        return ans+startValue-target;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int brokenCalc(int startValue, int target) {\\n        \\n        int ans=0;\\n        //Check if target is even or odd\\n        while(startValue<target)\\n        {\\n\\t\\t   //If even, divide the target by 2 and increment the ans by 1\\n            if(target%2==0)\\n            {\\n                target/=2;\\n                ans++;\\n            }\\n            else{\\n\\t\\t\\t   //If odd, add 1 to target and increment the ans by 1\\n                target++;\\n                ans++;\\n            }\\n        }\\n        \\n        \\n        return ans+startValue-target;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1877249,
                "title": "forward-solution-python",
                "content": "Let\\'s assume that the shortest path consists of k steps where each step consists of one or two actions:\\n1. (optional) decrease by one\\n2. multiply by 2\\n\\nThen\\n\\ntarget = 2 ** k start - a_k 2 ** k - a_(k - 1) 2 ** (k - 1) - ... - a_0\\n\\nLike in the official solution, we can show that a_i is either 0 or 1 for i = 0, 1, ..., k - 1. (Note that a_k may be greater than 1.) Then\\n\\n2 ** k start - target = a_k 2 ** k + a_(k - 1) 2 ** (k - 1) + ... + a_0\\n\\nwhich means that the total cost is k + popcount((k + 1 least significant bits of 2 ** k start - target) - (binary number a_k a_(k-1) ... a_0)). Note that we need to know k to evaluate this expression.\\n\\nFinally, we can show that this number of steps in the shortest path, k, is the minimum number of left shifts that, when applied to startValue, would evaluate greater or equal to target.\\n\\n\\n```\\nclass Solution:\\n    def brokenCalc(self, startValue: int, target: int) -> int:\\n        if target <= startValue:\\n            return startValue - target\\n        cost = 0\\n        val = startValue\\n        mask = 2\\n        sh = 0\\n        while val < target:\\n            cost += 1\\n            val <<= 1\\n            mask <<= 1\\n            sh += 1\\n        mask -= 1\\n        cost += ((val - target) & mask).bit_count()\\n        val -= ((val - target) & mask)\\n        cost += (val - target) >> sh\\n        return cost\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def brokenCalc(self, startValue: int, target: int) -> int:\\n        if target <= startValue:\\n            return startValue - target\\n        cost = 0\\n        val = startValue\\n        mask = 2\\n        sh = 0\\n        while val < target:\\n            cost += 1\\n            val <<= 1\\n            mask <<= 1\\n            sh += 1\\n        mask -= 1\\n        cost += ((val - target) & mask).bit_count()\\n        val -= ((val - target) & mask)\\n        cost += (val - target) >> sh\\n        return cost\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1877088,
                "title": "100-faster-c-easiest-approach",
                "content": "by targeting the target.\\n\\n```\\nint brokenCalc(int startValue, int target) {\\n        int count=0;\\n        while(target>startValue)\\n        {\\n            count++;\\n            if(target&1)\\n                target+=1;\\n                \\n            else\\n                target=target/2;\\n                \\n        }\\n        count=count+(startValue-target);\\n        \\n        return count;\\n        \\n    }",
                "solutionTags": [
                    "C++"
                ],
                "code": "by targeting the target.\\n\\n```\\nint brokenCalc(int startValue, int target) {\\n        int count=0;\\n        while(target>startValue)\\n        {\\n            count++;\\n            if(target&1)\\n                target+=1;\\n                \\n            else\\n                target=target/2;\\n                \\n        }\\n        count=count+(startValue-target);\\n        \\n        return count;\\n        \\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1877070,
                "title": "java-solution-100-faster",
                "content": "\\tclass Solution \\n\\t{   \\n\\t\\tpublic int brokenCalc(int startValue, int target) \\n\\t\\t{\\n\\t\\t\\tint res = 0;\\n\\n\\t\\t\\twhile(target>startValue)\\n\\t\\t\\t{\\n\\t\\t\\t\\tif(target%2 == 1)\\n\\t\\t\\t\\t\\ttarget++;\\n\\t\\t\\t\\telse\\n\\t\\t\\t\\t\\ttarget /= 2;\\n\\t\\t\\t\\tres++;\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn res - target + startValue;\\n\\t\\t}\\n\\t}",
                "solutionTags": [
                    "Java",
                    "Greedy"
                ],
                "code": "class Solution \\n\\t{   \\n\\t\\tpublic int brokenCalc(int startValue, int target) \\n\\t\\t{\\n\\t\\t\\tint res = 0;\\n\\n\\t\\t\\twhile(target>startValue)\\n\\t\\t\\t{\\n\\t\\t\\t\\tif(target%2 == 1)\\n\\t\\t\\t\\t\\ttarget++;\\n\\t\\t\\t\\telse\\n\\t\\t\\t\\t\\ttarget /= 2;\\n\\t\\t\\t\\tres++;\\n\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 1876929,
                "title": "c-0ms-100-faster-target-to-startvalue",
                "content": "\\tclass Solution {\\n\\tpublic:\\n\\t\\tint brokenCalc(int startValue, int target) {\\n\\t\\t\\t int ans=0;\\n\\t\\t\\t while(target>startValue){\\n\\t\\t\\t\\t  if(target%2==0){\\n\\t\\t\\t\\t\\t  target/=2;\\n\\t\\t\\t\\t  }\\n\\t\\t\\t\\t else{\\n\\t\\t\\t\\t\\t target+=1;\\n\\t\\t\\t\\t }\\n\\t\\t\\t\\t ans++;\\n\\t\\t\\t }\\n\\t\\t\\treturn ans+abs(target-startValue);\\n\\t\\t}\\n\\t};",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution {\\n\\tpublic:\\n\\t\\tint brokenCalc(int startValue, int target) {\\n\\t\\t\\t int ans=0;\\n\\t\\t\\t while(target>startValue){\\n\\t\\t\\t\\t  if(target%2==0){\\n\\t\\t\\t\\t\\t  target/=2;\\n\\t\\t\\t\\t  }",
                "codeTag": "Java"
            },
            {
                "id": 1876815,
                "title": "c-best-100",
                "content": "Here is the code for this question.\\n\\n```cpp\\nclass Solution {\\npublic:\\n    int brokenCalc(int startValue, int target) {\\n        int count=0;\\n        while (target>startValue) {\\n            if (target%2 ==0) target/=2;\\n            else target+=1;\\n            count++;\\n        }\\n        return count+abs(startValue-target);\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Greedy"
                ],
                "code": "```cpp\\nclass Solution {\\npublic:\\n    int brokenCalc(int startValue, int target) {\\n        int count=0;\\n        while (target>startValue) {\\n            if (target%2 ==0) target/=2;\\n            else target+=1;\\n            count++;\\n        }\\n        return count+abs(startValue-target);\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1876645,
                "title": "python-simple-solution-with-base-case-explanation",
                "content": "```\\nclass Solution:\\n    def brokenCalc(self, startValue: int, target: int) -> int:\\n        #For this you can simply think for a situation where in start you are at peak and you have to come down from peak and there is only one possibility for that which move down and that\\'s why we do this\\n        if startValue >= target:\\n            return startValue - target\\n        if target % 2== 0:\\n            return 1 + self.brokenCalc(startValue , target // 2)\\n        else:\\n            return 1 + self.brokenCalc(startValue , target + 1)\\n```",
                "solutionTags": [
                    "Python",
                    "Recursion"
                ],
                "code": "```\\nclass Solution:\\n    def brokenCalc(self, startValue: int, target: int) -> int:\\n        #For this you can simply think for a situation where in start you are at peak and you have to come down from peak and there is only one possibility for that which move down and that\\'s why we do this\\n        if startValue >= target:\\n            return startValue - target\\n        if target % 2== 0:\\n            return 1 + self.brokenCalc(startValue , target // 2)\\n        else:\\n            return 1 + self.brokenCalc(startValue , target + 1)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1876465,
                "title": "java-simple-clean-solution-with-easy-explanation-of-thought-process",
                "content": "\\n**Idea**\\nIt is simple to think of the problem in the opposite direction. It just feels more natural that as we can clearly see that dividing by 2 is the fastest way to decrease the src towards our target. So if we think of it like - decreasing target to reach startVal using `+1` and `/2`(reversed the operations) operations, it becomes simpler. The solution is simple to comprehend once you understand the below points -\\n\\n1. if `startValue>target`, there is no option other than keeping on adding 1 till we reach the startVal;\\n2. if possible to `divide by 2`, that is the fastest way to decrease target. Hence we do that if possible. \\n3. if not possible(target is odd), we can `add 1` to target using one operation and then again continue the fastest way available to us i.e. point 2.\\n\\nRefer to the code now.\\n\\n```java\\nclass Solution {\\n    public int brokenCalc(int startValue, int target) {\\n        int ops=0;\\n        while(true){\\n            if(startValue==target)\\n                return ops;\\n            if(startValue>target)  // point 1.\\n                return ops+startValue-target;\\n            \\n            if(target%2==0)target/=2; // point 2.\\n            else{\\n               target=(target+1)/2;   // point 3.\\n               ops++; \\n            }\\n            ops++;\\n        }\\n    }\\n}\\n```\\n\\n**TC is O(logn) and SC is O(1)**\\n",
                "solutionTags": [
                    "Java",
                    "Greedy"
                ],
                "code": "```java\\nclass Solution {\\n    public int brokenCalc(int startValue, int target) {\\n        int ops=0;\\n        while(true){\\n            if(startValue==target)\\n                return ops;\\n            if(startValue>target)  // point 1.\\n                return ops+startValue-target;\\n            \\n            if(target%2==0)target/=2; // point 2.\\n            else{\\n               target=(target+1)/2;   // point 3.\\n               ops++; \\n            }\\n            ops++;\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1876456,
                "title": "c-5-lines-faster-than-100-takes-memory-less-than-73-18",
                "content": "```c++\\nint res = 0;\\nwhile (target > startValue) {\\n\\tres++;\\n\\ttarget = target % 2 == 0 ? target / 2 : target + 1;\\n}\\nreturn res + (startValue - target);\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```c++\\nint res = 0;\\nwhile (target > startValue) {\\n\\tres++;\\n\\ttarget = target % 2 == 0 ? target / 2 : target + 1;\\n}\\nreturn res + (startValue - target);\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1876427,
                "title": "c-easy-iterative-solution-100-faster",
                "content": "Easy iterative solution if target is even then we will divide by 2 and if it is odd then we will add one and divide by 2. If it reaches less than startvalue we will increment till it reaches startvalue\\n```\\nclass Solution {\\npublic:\\n    int brokenCalc(int start, int target) {\\n        int ans=0;\\n        while(target>=start)\\n        {\\n            if(target==start)\\n                return ans;\\n            else if(target%2!=0)\\n                ans+=2;\\n            else\\n                ans+=1;\\n            target=(target+1)/2;\\n        }\\n        if(target<start)\\n            ans+=start-target;\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int brokenCalc(int start, int target) {\\n        int ans=0;\\n        while(target>=start)\\n        {\\n            if(target==start)\\n                return ans;\\n            else if(target%2!=0)\\n                ans+=2;\\n            else\\n                ans+=1;\\n            target=(target+1)/2;\\n        }\\n        if(target<start)\\n            ans+=start-target;\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1876361,
                "title": "c-straight-forward-recursive-solution-beats-100-solutions",
                "content": "```\\nclass Solution {\\nprivate:\\n    int dfs(int startValue,int target){\\n        if(startValue == target) return 0;\\n        \\n        if(target > startValue){\\n            if((target & 1) == 0) return 1 + dfs(startValue, target / 2);\\n            else return 1 + dfs(startValue, target + 1);\\n        }\\n        else{\\n            return (startValue - target);\\n        }\\n    }\\npublic:\\n    int brokenCalc(int startValue, int target) {\\n        return dfs(startValue,target);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Greedy",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\nprivate:\\n    int dfs(int startValue,int target){\\n        if(startValue == target) return 0;\\n        \\n        if(target > startValue){\\n            if((target & 1) == 0) return 1 + dfs(startValue, target / 2);\\n            else return 1 + dfs(startValue, target + 1);\\n        }\\n        else{\\n            return (startValue - target);\\n        }\\n    }\\npublic:\\n    int brokenCalc(int startValue, int target) {\\n        return dfs(startValue,target);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1876358,
                "title": "easy-understanding-solution",
                "content": "```\\n//PLEASE UPVOTE, IF U LIKE MY SOLUTION  :)\\nint brokenCalc(int start, int target) {\\n        if(start == target) return 0;\\n        if(target < start) return start - target;\\n        int ans = 0;\\n        while(start<target){\\n            ans++;\\n            if(target % 2 == 0){ //even\\n                target /= 2;\\n            }else{\\n                target += 1;\\n                if(target < start) break;\\n            }\\n        }\\n        return ans + start-target;\\n    }\\n//PLEASE UPVOTE, IF U LIKE MY SOLUTION  :)\\n```\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "C",
                    "Math",
                    "Greedy",
                    "Recursion"
                ],
                "code": "```\\n//PLEASE UPVOTE, IF U LIKE MY SOLUTION  :)\\nint brokenCalc(int start, int target) {\\n        if(start == target) return 0;\\n        if(target < start) return start - target;\\n        int ans = 0;\\n        while(start<target){\\n            ans++;\\n            if(target % 2 == 0){ //even\\n                target /= 2;\\n            }else{\\n                target += 1;\\n                if(target < start) break;\\n            }\\n        }\\n        return ans + start-target;\\n    }\\n//PLEASE UPVOTE, IF U LIKE MY SOLUTION  :)\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1876340,
                "title": "c-easy-solution-100-faster",
                "content": "\\n\\tint brokenCalc(int startValue, int target) {\\n\\t\\t\\t\\t   int count=0;\\n\\t\\t\\t\\t   while(target > startValue )\\n\\t\\t\\t\\t   {\\n\\t\\t\\t\\t\\t   if(target%2==1) target++;\\n\\t\\t\\t\\t\\t   else target =  target/2;\\n\\t\\t\\t\\t\\t\\tcount++;\\n\\t\\t\\t\\t   }\\n\\t\\t\\t\\treturn count + startValue - target ;",
                "solutionTags": [
                    "C"
                ],
                "code": "\\n\\tint brokenCalc(int startValue, int target) {\\n\\t\\t\\t\\t   int count=0;\\n\\t\\t\\t\\t   while(target > startValue )\\n\\t\\t\\t\\t   {\\n\\t\\t\\t\\t\\t   if(target%2==1) target++;\\n\\t\\t\\t\\t\\t   else target =  target/2;\\n\\t\\t\\t\\t\\t\\tcount++;\\n\\t\\t\\t\\t   }\\n\\t\\t\\t\\treturn count + startValue - target ;",
                "codeTag": "Unknown"
            },
            {
                "id": 1876333,
                "title": "3-lines-code-recursion-based-solution-mathematical-approach",
                "content": "```\\nRecursion Solution\\n public int brokenCalc(int startValue, int target) {\\n        if(startValue>=target) return startValue-target;  // base case\\n        if(target %2 == 1) return 1+brokenCalc(startValue,target+1);\\n        return 1+brokenCalc(startValue,target/2);\\n\\t}\\n\\t\\nMathematical Solution\\npublic int brokenCalc(int startValue, int target) {\\n        int count = 0;\\n        if(startValue>target) return startValue-target;\\n        while(startValue<target){\\n            count++;\\n            if(target%2 == 1) target+=1;\\n            else target/=2;\\n        }\\n        if(startValue== target) return count;\\n        \\n        while(startValue>target){\\n            count+= startValue-target;\\n            break;\\n        }\\n        \\n        return count;\\n\\t\\t}\\n\\t\\t",
                "solutionTags": [
                    "Java",
                    "Math",
                    "Recursion"
                ],
                "code": "```\\nRecursion Solution\\n public int brokenCalc(int startValue, int target) {\\n        if(startValue>=target) return startValue-target;  // base case\\n        if(target %2 == 1) return 1+brokenCalc(startValue,target+1);\\n        return 1+brokenCalc(startValue,target/2);\\n\\t}\\n\\t\\nMathematical Solution\\npublic int brokenCalc(int startValue, int target) {\\n        int count = 0;\\n        if(startValue>target) return startValue-target;\\n        while(startValue<target){\\n            count++;\\n            if(target%2 == 1) target+=1;\\n            else target/=2;\\n        }\\n        if(startValue== target) return count;\\n        \\n        while(startValue>target){\\n            count+= startValue-target;\\n            break;\\n        }\\n        \\n        return count;\\n\\t\\t}\\n\\t\\t",
                "codeTag": "Unknown"
            },
            {
                "id": 1876274,
                "title": "c-o-log-n-o-1-solution-faster-than-100",
                "content": "class Solution {\\npublic:\\n    int brokenCalc(int startValue, int target) {\\n        int cnt=0;\\n        // bringing the target closest to startValue\\n        while(target>startValue){\\n            if(target%2){\\n                target++; //opposite of subtract operation in startValue\\n                cnt++;\\n            }\\n            else{\\n                target/=2;\\n                cnt++;\\n            }}\\n        return cnt+startValue-target; //when target becomes smaller than startValue, we have to perform (startValue-target) subtract operations.        \\n         }};",
                "solutionTags": [
                    "C",
                    "Greedy"
                ],
                "code": "class Solution {\\npublic:\\n    int brokenCalc(int startValue, int target) {\\n        int cnt=0;\\n        // bringing the target closest to startValue\\n        while(target>startValue){\\n            if(target%2){\\n                target++; //opposite of subtract operation in startValue\\n                cnt++;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1876228,
                "title": "100-faster-easy-to-understand-hashmap-dp-c",
                "content": "```\\nclass Solution {\\npublic:\\n    int brokenCalc(int startValue, int target) {\\n        if(target <= startValue ){\\n            return startValue - target;\\n        }\\n        unordered_map<int,int> mp;\\n        int k = startValue;\\n        int steps = 0;\\n        while(startValue < target){\\n            mp[startValue]  = steps;\\n            startValue *=2;\\n            steps++;\\n        }\\n        mp[startValue]  = steps;\\n        int ans = steps + (startValue - target);\\n        steps = 0;\\n        while(target > k ){\\n            if(mp.find(target) != mp.end()){\\n                ans = min(ans , mp[target]  + steps );\\n            }\\n            if(target & 1){\\n                target += 1;\\n            }\\n            else{\\n                target/=2;\\n            }\\n            steps++;\\n        }\\n        \\n        ans = min(ans ,steps + (k - target));\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Two Pointers",
                    "Dynamic Programming",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int brokenCalc(int startValue, int target) {\\n        if(target <= startValue ){\\n            return startValue - target;\\n        }\\n        unordered_map<int,int> mp;\\n        int k = startValue;\\n        int steps = 0;\\n        while(startValue < target){\\n            mp[startValue]  = steps;\\n            startValue *=2;\\n            steps++;\\n        }\\n        mp[startValue]  = steps;\\n        int ans = steps + (startValue - target);\\n        steps = 0;\\n        while(target > k ){\\n            if(mp.find(target) != mp.end()){\\n                ans = min(ans , mp[target]  + steps );\\n            }\\n            if(target & 1){\\n                target += 1;\\n            }\\n            else{\\n                target/=2;\\n            }\\n            steps++;\\n        }\\n        \\n        ans = min(ans ,steps + (k - target));\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1876081,
                "title": "c-easy-to-understand-daily-leetcoding-challenge-march-day-23",
                "content": "**Please upvote if it helps**\\n\\n* we are going to start from **target to start value** instaed of **startvalue to target**\\n\\n* for our final result we will also **oppose the operations** \\n* if **target == even**, divide it by 2 (**instead of multiplication**)\\n* if t**aget  == odd**, add 1 in it     (**instead of subtraction**)\\n* till our **target gets lesser than the startvalue**\\n* and at the last return **(ans + startValue - target)**\\n\\n```\\nclass Solution {\\npublic:\\n    int brokenCalc(int startValue, int target) \\n    {\\n        int ans = 0;\\n        \\n        while(startValue < target)\\n        {\\n            // if target is odd\\n            // make it even\\n            if(target % 2 != 0)\\n                target++;\\n            \\n            // else divide it by 2\\n            else\\n                target /= 2;\\n            \\n            ans++;\\n        }\\n        \\n        return ans + startValue - target;\\n    }\\n};\\n```\\n\\nDry Run \\n\\nst = 6, t = 26\\n    \\n    initially, ans = 0;\\n    6<26\\n        t = 26/2 = 13\\n        ans = 0 + 1 = 1\\n        \\n    6<13\\n        t = 13+1 = 14\\n        ans = 1 + 1 = 2\\n        \\n    6<14\\n        t = 14/2 = 7\\n        ans = 2 + 1 = 3\\n        \\n    6<7\\n        t = 7+1 = 8\\n        ans = 3 + 1 = 4\\n        \\n    6<8\\n        t = 8/2 = 4\\n        ans = 4 + 1 = 5\\n        \\n    6<4\\n        break\\n        \\n\\nreturn (5 + 6 - 4)=(7)",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int brokenCalc(int startValue, int target) \\n    {\\n        int ans = 0;\\n        \\n        while(startValue < target)\\n        {\\n            // if target is odd\\n            // make it even\\n            if(target % 2 != 0)\\n                target++;\\n            \\n            // else divide it by 2\\n            else\\n                target /= 2;\\n            \\n            ans++;\\n        }\\n        \\n        return ans + startValue - target;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1876045,
                "title": "simple-java-solution-greedy",
                "content": "we will start from target and will try to reach the startValue instead of Multiplication and subtraction we will use division and addition.\\nBase case:If startValue > target the ans will be startValue-target because at that time we have only one option that is subtraction.\\n```\\nclass Solution {\\n    public int brokenCalc(int startValue, int target) {\\n        if(startValue>target) return startValue-target;\\n        int count=0;\\n        while(startValue!=target){\\n            if(target%2==0 && target>=startValue) target=target/2;\\n            else target++;\\n            count++;\\n        }\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\n    public int brokenCalc(int startValue, int target) {\\n        if(startValue>target) return startValue-target;\\n        int count=0;\\n        while(startValue!=target){\\n            if(target%2==0 && target>=startValue) target=target/2;\\n            else target++;\\n            count++;\\n        }\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1875968,
                "title": "991-broken-calculator-0ms-41-1mb-java",
                "content": "```\\nclass Solution {\\n    public int brokenCalc(int startValue, int target) {\\n        int operation = 0;\\n        while(startValue < target)\\n        {\\n            if(target % 2 == 0)\\n            {\\n                target = target / 2;\\n            }\\n            else{\\n                target = target + 1;\\n            }\\n            operation++;\\n        }\\n        return operation + (startValue - target);\\n    }\\n}\\n```\\nIf my solution helped you please **UPVOTE**",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int brokenCalc(int startValue, int target) {\\n        int operation = 0;\\n        while(startValue < target)\\n        {\\n            if(target % 2 == 0)\\n            {\\n                target = target / 2;\\n            }\\n            else{\\n                target = target + 1;\\n            }\\n            operation++;\\n        }\\n        return operation + (startValue - target);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1875955,
                "title": "js",
                "content": "```\\n\\nvar brokenCalc = function(startValue, target) {\\n    \\n    let count = 0;\\n    while(target > startValue){\\n        if(target % 2)\\n            target++;\\n        else\\n          target /= 2;\\n        count++\\n    }\\n    return count + startValue - target;\\n};\\n```\\n",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n\\nvar brokenCalc = function(startValue, target) {\\n    \\n    let count = 0;\\n    while(target > startValue){\\n        if(target % 2)\\n            target++;\\n        else\\n          target /= 2;\\n        count++\\n    }\\n    return count + startValue - target;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1875899,
                "title": "easiest-c-solution-beginner-friendly-algorithm-backward-approach",
                "content": "```\\nclass Solution {\\npublic:\\n    int brokenCalc(int startValue, int target) {\\n        int ans=0;\\n        while (startValue < target) {\\n            if (target%2==0)\\n                target /= 2;\\n            else\\n                target += 1;\\n            ans++;\\n        }\\n        return ans + startValue - target;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int brokenCalc(int startValue, int target) {\\n        int ans=0;\\n        while (startValue < target) {\\n            if (target%2==0)\\n                target /= 2;\\n            else\\n                target += 1;\\n            ans++;\\n        }\\n        return ans + startValue - target;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1875826,
                "title": "easy-c-sol-o-log-target-greedy",
                "content": "```\\nclass Solution {   // Time: O(log(target)) :: Aux_Space: O(1);\\npublic:\\n    int brokenCalc(int startValue, int target) {\\n        \\n        int res = 0;\\n        \\n        while(target > startValue){\\n            \\n            if(target%2 == 0){\\n                 target = target/2;\\n                res++;\\n            }else{\\n                target++;\\n                res++;\\n            }\\n        }\\n        \\n        return res+startValue-target;\\n        \\n    }\\n};",
                "solutionTags": [
                    "C++",
                    "C",
                    "Greedy"
                ],
                "code": "class Solution {   // Time: O(log(target)) :: Aux_Space: O(1);\\npublic:\\n    int brokenCalc(int startValue, int target) {\\n        \\n        int res = 0;\\n        \\n        while(target > startValue){\\n            \\n            if(target%2 == 0){\\n                 target = target/2;\\n                res++;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1875812,
                "title": "c-0ms-code-clean-and-simple-solution",
                "content": "TIP : Don\\'t try to change startValue . Instead of that , make target equal to startValue\\nTry solving the problem once again now and then come back and see the code \\n\\n```\\nclass Solution {\\npublic:\\n    int brokenCalc(int startValue, int target) {\\n        int ans=0;\\n        while(startValue!=target)\\n        {\\n            ans++;\\n            if(target>startValue)\\n            {\\n                if(target%2)  target++;    \\n                else target=target/2;\\n            }\\n            else\\n            {\\n                 ans+=(startValue-target-1); // -1 because we already increased ans by 1 in beginning \\n                target=startValue;   \\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int brokenCalc(int startValue, int target) {\\n        int ans=0;\\n        while(startValue!=target)\\n        {\\n            ans++;\\n            if(target>startValue)\\n            {\\n                if(target%2)  target++;    \\n                else target=target/2;\\n            }\\n            else\\n            {\\n                 ans+=(startValue-target-1); // -1 because we already increased ans by 1 in beginning \\n                target=startValue;   \\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1875791,
                "title": "broken-calculator-recursive-and-iterative-approach",
                "content": "Recursive\\n```\\nclass Solution {\\npublic:\\n    int brokenCalc(int startValue, int target) {\\n        if(startValue>=target)\\n            return startValue-target;\\n        if(target%2==0){\\n            return 1+brokenCalc(startValue,target/2);\\n        }\\n        return 1+brokenCalc(startValue,target+1);\\n    }\\n};\\n//Time Complexity: O(log target)\\n//Space Complexity: O(1)\\n```\\nIterative\\n```\\nclass Solution {\\npublic:\\n    int brokenCalc(int startValue, int target) {\\n        int res=0;\\n        while(target>startValue){\\n            res++;\\n            if(target%2==0){\\n                target/=2;\\n            }else{\\n                target++;\\n            }\\n        }\\n        return res+(startValue-target);\\n    }\\n};\\n//Time Complexity: O(log target)\\n//Space Complexity: O(1)\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int brokenCalc(int startValue, int target) {\\n        if(startValue>=target)\\n            return startValue-target;\\n        if(target%2==0){\\n            return 1+brokenCalc(startValue,target/2);\\n        }\\n        return 1+brokenCalc(startValue,target+1);\\n    }\\n};\\n//Time Complexity: O(log target)\\n//Space Complexity: O(1)\\n```\n```\\nclass Solution {\\npublic:\\n    int brokenCalc(int startValue, int target) {\\n        int res=0;\\n        while(target>startValue){\\n            res++;\\n            if(target%2==0){\\n                target/=2;\\n            }else{\\n                target++;\\n            }\\n        }\\n        return res+(startValue-target);\\n    }\\n};\\n//Time Complexity: O(log target)\\n//Space Complexity: O(1)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1875768,
                "title": "c-easy-understand",
                "content": "```\\n int brokenCalc(int startValue, int target) {\\n        if(startValue >= target)\\n            return startValue - target;\\n        if(target%2==0)\\n            return 1+ brokenCalc(startValue,target/2);\\n        else\\n            return 1+ brokenCalc(startValue,target+1);\\n    }\\n```",
                "solutionTags": [
                    "C",
                    "Recursion"
                ],
                "code": "```\\n int brokenCalc(int startValue, int target) {\\n        if(startValue >= target)\\n            return startValue - target;\\n        if(target%2==0)\\n            return 1+ brokenCalc(startValue,target/2);\\n        else\\n            return 1+ brokenCalc(startValue,target+1);\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1875664,
                "title": "c-o-1-time-and-o-1-space-bit-manipulation",
                "content": "```\\nclass Solution {\\npublic:\\n    int brokenCalc(int startValue, int target) {\\n        /*\\n        target = multiplySum - minusSum\\n\\t\\t\\n\\t\\tmultiplySum = 2^n * startValue\\n\\t\\t2^(n - 1) < target/startValue <= 2^n\\n        => the count of multiply = n\\n        \\n        minusSum = 2^n * t0 + 2^(n-1) * t1 + .... + 2^0 * tn\\n        ti is the count of minus after i times of multiply\\n        ti = 1 or 0 (i > 0)\\n        t0 >= 0, because the maximum multiplier is n\\n        => count of minus = t0 + (t1 + ... + tn)\\n                    t0 = minusSum / 2^n\\n         t1 + ... + tn = bit1count(minusSum & bitmask)\\n        */\\n        \\n        // Get multiply count\\n        int multCnt = max(ceil(log2((double)target / startValue)), 0.0);\\n        // Get sum of minus\\n        int minusSum = pow(2, multCnt) * startValue - target;\\n        // Get mask for counting 1-bit\\n        int bitmask = (1 << multCnt) - 1;\\n        return multCnt + (minusSum >> multCnt) + __builtin_popcount(minusSum & bitmask);\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C",
                    "Math",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int brokenCalc(int startValue, int target) {\\n        /*\\n        target = multiplySum - minusSum\\n\\t\\t\\n\\t\\tmultiplySum = 2^n * startValue\\n\\t\\t2^(n - 1) < target/startValue <= 2^n\\n        => the count of multiply = n\\n        \\n        minusSum = 2^n * t0 + 2^(n-1) * t1 + .... + 2^0 * tn\\n        ti is the count of minus after i times of multiply\\n        ti = 1 or 0 (i > 0)\\n        t0 >= 0, because the maximum multiplier is n\\n        => count of minus = t0 + (t1 + ... + tn)\\n                    t0 = minusSum / 2^n\\n         t1 + ... + tn = bit1count(minusSum & bitmask)\\n        */\\n        \\n        // Get multiply count\\n        int multCnt = max(ceil(log2((double)target / startValue)), 0.0);\\n        // Get sum of minus\\n        int minusSum = pow(2, multCnt) * startValue - target;\\n        // Get mask for counting 1-bit\\n        int bitmask = (1 << multCnt) - 1;\\n        return multCnt + (minusSum >> multCnt) + __builtin_popcount(minusSum & bitmask);\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1875619,
                "title": "c-easy-solution-0ms-100-faster",
                "content": "Here\\'s what approach I used -\\n* Let\\'s start to reach from target to startValue since it\\'ll also take same steps to reach startValue from target.\\n* The operations will change here. for **startValue = startValue*2 -> target = target/2** and for **startValue = startValue - 1 -> target = target + 1.**\\n* The first case is when starting value is equal to target, then there is no step involved here to change values, so simply return 0.\\n* Then we started our steps from 0 and Performed these operations until our target is greater than startValue -\\n  1. The first case is when my **target value is even**, then one operation can be performed -> **target = target/2** ( so for startValue, it\\'ll be startValue = startValue*2 that is allowed Operation by the calculator.)\\n  2. If **my target is odd**, then we can only perform **target = (target + 1**) operation since doing target = target/2 operation will give us float value that isn\\'t allowed here. ( For the startValue, This operation will be startValue = startValue - 1 )\\n* Now loop will only break in 2 conditons, either my target is less than startValue or target is equal to startValue.\\n* If target is less than startValue, then doing operations target = target/2 isn\\'t going to help. so the only Beneficial operation here is target = target + 1.\\n* We\\'ll do this target = target+1 operation to fill the difference between target and startValue so for **(startValue - target)** times. \\n* In the case when target is equal to startValue, this difference (startValue - target) will be zero.\\n* so we\\'ll simply add these extra steps required to our steps variable.\\n* Now steps variable contains minimum steps needed to reach from startValue to target.\\n\\n\\n```\\nclass Solution {\\npublic:\\n    int brokenCalc(int startValue, int target) {\\n\\t/* Since startValue = target, no step required to change value */\\n        if(startValue == target) return 0;\\n\\t\\t\\n\\t\\t/* starting value of steps = 0 */\\n        int steps = 0;\\n        while(target>startValue){\\n\\t\\t/* If target value is even, we can only do this operation */\\n            if( target%2==0){\\n                target=target/2;\\n            }\\n\\t\\t\\t/* In case of odd value */\\n            else target+=1;\\n\\t\\t\\t\\n\\t\\t\\t/* steps will increase in both cases */\\n            steps++;\\n        }\\n\\t\\t\\n\\t\\t/* our target might have become less than startValue by target = target/2 operation so add the difference here\\n\\t\\t that shows the number of times we will perform target = target+1 */\\n        steps+=(startValue-target);\\n\\t\\t\\n\\t\\t/* Final minimum steps required */\\n        return steps;\\n    }\\n};\\n```\\n\\nPlease upvote if it helps. Also provide your suggestions to improve the code.",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int brokenCalc(int startValue, int target) {\\n\\t/* Since startValue = target, no step required to change value */\\n        if(startValue == target) return 0;\\n\\t\\t\\n\\t\\t/* starting value of steps = 0 */\\n        int steps = 0;\\n        while(target>startValue){\\n\\t\\t/* If target value is even, we can only do this operation */\\n            if( target%2==0){\\n                target=target/2;\\n            }\\n\\t\\t\\t/* In case of odd value */\\n            else target+=1;\\n\\t\\t\\t\\n\\t\\t\\t/* steps will increase in both cases */\\n            steps++;\\n        }\\n\\t\\t\\n\\t\\t/* our target might have become less than startValue by target = target/2 operation so add the difference here\\n\\t\\t that shows the number of times we will perform target = target+1 */\\n        steps+=(startValue-target);\\n\\t\\t\\n\\t\\t/* Final minimum steps required */\\n        return steps;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1875557,
                "title": "recursive-c-100-fast-greedy",
                "content": "x is initial number, y is target we want to achieve\\n\\n1 step -> x-1 to x\\n         -> 2x to x\\n(x,y) can be (even,odd)  ,(even,even)  ,(odd,odd)  ,(odd,even)\\n\\neg-> x=4  and y=7\\n4->8->7 in 2 step or 7->8->4 in 2 steps\\n\\neg->x=4 and y=8\\n4->8 in 1 steps or 8->4 in 1 steps\\n\\neg-> x=3 to y=11\\n\\n3->6->12->11 or 11->12->6.-> in 3 steps\\neg-> x=3 to y=13\\n\\n3->2->4->8->7->14->13   or 13->14->7->8->4->**2->3**\\n\\nhere 2->3 is the case where we can decrement from 3 to 2 in reality but from backward we are add 1 to gain 3\\nx is bigger than only decrement can happen, x-y is answer\\n\\n\\n```\\nclass Solution {\\npublic:\\n    int brokenCalc(int x, int y) {\\n        \\n        if(x>=y){\\n            return x-y;     \\n        } \\n\\t\\t\\n        if(y%2) return 1+brokenCalc(x,y+1);   // if i am on odd state we add 1 to make even, \\n        \\n        return 1+brokenCalc(x,y/2);              // if y is even just divide by 2 greedily\\n        \\n        \\n    }\\n};\\n```\\n\\nIF YOU DID\\'T GET ASK ANY LINE ASK IN COMMENT\\n\\n\\n\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int brokenCalc(int x, int y) {\\n        \\n        if(x>=y){\\n            return x-y;     \\n        } \\n\\t\\t\\n        if(y%2) return 1+brokenCalc(x,y+1);   // if i am on odd state we add 1 to make even, \\n        \\n        return 1+brokenCalc(x,y/2);              // if y is even just divide by 2 greedily\\n        \\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1875554,
                "title": "c-intuition-from-other-s-answer",
                "content": "```\\npublic class Solution \\n{\\n    public int BrokenCalc(int x, int y) \\n    {\\n        int op = 0;\\n        while (y > x) \\n        {\\n            y = y % 2 == 0 ? y / 2 : y + 1;\\n            op++;\\n        }\\n        \\n        //since we are coming from target to source\\n        return op + x - y;\\n    }\\n}\\n\\n/*\\nExplanation with example\\n\\nLet\\'s say we have X = 2 and Y = 9\\nIf we move from X to Y, our approach would be to multiply X while it\\'s less than Y\\n& then decrement it.\\nIt would be something like\\n(2 * 2 * 2 * 2) - 1 - 1 - 1 - 1 - 1 - 1 - 1 which is 3 multiplication and 7 subtraction (Total 10 operations)\\nbut optimal solution would be somthing like\\n(((((2 * 2) - 1) * 2) - 1) * 2) - 1 which is 3 multiplication and 3 subtraction (Total 6 operations)\\n\\nBut for optimal solution, how do decide when to multiply or subtract?\\nLet\\'s try to see the equation:\\nOur optimal solution gives us Y, so it will be something like\\n(((((2 * 2) - 1) * 2) - 1) * 2) - 1 = Y\\n(((((2 * 2) - 1) * 2) - 1) * 2) - 1 = 9\\n(((((2 * 2) - 1) * 2) - 1) * 2) = 9 + 1 = 10\\n((((2 * 2) - 1) * 2) - 1) = 10 / 2 = 5\\n(((2 * 2) - 1) * 2) = 5 + 1 = 6\\n((2 * 2) - 1) = 6 / 2 = 3\\n2 * 2 = 3 + 1 = 4\\n2 = 4 / 2 = 2 (equals X)\\n\\nWhen we see this, we see that for Y, we are adding one when it\\'s odd\\nand dividing by 2 when it\\'s even.\\nthis takes Y close to Y and hence to our answer\\n*/\\n\\n\\n\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution \\n{\\n    public int BrokenCalc(int x, int y) \\n    {\\n        int op = 0;\\n        while (y > x) \\n        {\\n            y = y % 2 == 0 ? y / 2 : y + 1;\\n            op++;\\n        }\\n        \\n        //since we are coming from target to source\\n        return op + x - y;\\n    }\\n}\\n\\n/*\\nExplanation with example\\n\\nLet\\'s say we have X = 2 and Y = 9\\nIf we move from X to Y, our approach would be to multiply X while it\\'s less than Y\\n& then decrement it.\\nIt would be something like\\n(2 * 2 * 2 * 2) - 1 - 1 - 1 - 1 - 1 - 1 - 1 which is 3 multiplication and 7 subtraction (Total 10 operations)\\nbut optimal solution would be somthing like\\n(((((2 * 2) - 1) * 2) - 1) * 2) - 1 which is 3 multiplication and 3 subtraction (Total 6 operations)\\n\\nBut for optimal solution, how do decide when to multiply or subtract?\\nLet\\'s try to see the equation:\\nOur optimal solution gives us Y, so it will be something like\\n(((((2 * 2) - 1) * 2) - 1) * 2) - 1 = Y\\n(((((2 * 2) - 1) * 2) - 1) * 2) - 1 = 9\\n(((((2 * 2) - 1) * 2) - 1) * 2) = 9 + 1 = 10\\n((((2 * 2) - 1) * 2) - 1) = 10 / 2 = 5\\n(((2 * 2) - 1) * 2) = 5 + 1 = 6\\n((2 * 2) - 1) = 6 / 2 = 3\\n2 * 2 = 3 + 1 = 4\\n2 = 4 / 2 = 2 (equals X)\\n\\nWhen we see this, we see that for Y, we are adding one when it\\'s odd\\nand dividing by 2 when it\\'s even.\\nthis takes Y close to Y and hence to our answer\\n*/\\n\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1875544,
                "title": "c-sort-ans-simply-to-understand",
                "content": "class Solution {\\npublic:\\n    int brokenCalc(int start, int target) {\\n        \\n        /*\\n            our approach is that Rather than updating startval to reach target ,,we update target to reach start\\n            \\n            \\n        */\\n        \\n        if(start==target)return 0;//base case\\n        \\n        if(start>target)\\n        {\\n          return  start-target;\\n        }\\n        else if(target%2==0)\\n        {\\n           return  1+brokenCalc(start,target/2);\\n        }\\n        else\\n        {\\n            return 1+brokenCalc(start,target+1);\\n        }\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    int brokenCalc(int start, int target) {\\n        \\n        /*\\n            our approach is that Rather than updating startval to reach target ,,we update target to reach start\\n            \\n            \\n        */\\n        \\n        if(start==target)return 0;//base case\\n        \\n        if(start>target)\\n        {\\n          return  start-target;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1875517,
                "title": "c-java-greedy-o-logn-time-o-1-space-change-target-to-startvalue",
                "content": "**C++ Code -**\\n```\\nclass Solution {\\npublic:\\n    int brokenCalc(int startValue, int target) {\\n        int ans = 0;\\n        while(startValue < target){\\n            if(target%2!=0) target += 1;\\n            else target = target >> 1;  \\n            ans++;\\n        }\\n        return ans + (startValue - target);\\n    }\\n};\\n```\\n**Java Code -**\\n```\\nclass Solution {\\n    public int brokenCalc(int startValue, int target) {\\n        int ans = 0;\\n        while(startValue < target){\\n            if(target%2!=0) target += 1;\\n            else target = target >> 1;  \\n            ans++;\\n        }\\n        return ans + (startValue - target);\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int brokenCalc(int startValue, int target) {\\n        int ans = 0;\\n        while(startValue < target){\\n            if(target%2!=0) target += 1;\\n            else target = target >> 1;  \\n            ans++;\\n        }\\n        return ans + (startValue - target);\\n    }\\n};\\n```\n```\\nclass Solution {\\n    public int brokenCalc(int startValue, int target) {\\n        int ans = 0;\\n        while(startValue < target){\\n            if(target%2!=0) target += 1;\\n            else target = target >> 1;  \\n            ans++;\\n        }\\n        return ans + (startValue - target);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1875437,
                "title": "0ms-3-line-solution-recursion-c",
                "content": "```\\nclass Solution {\\npublic:\\n    int brokenCalc(int start, int target) \\n    {\\n        if(start>=target) return start-target;\\n        \\n        if(target%2==0) return 1+brokenCalc(start, target/2);\\n\\t\\t\\n        return 1+brokenCalc(start, target+1);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int brokenCalc(int start, int target) \\n    {\\n        if(start>=target) return start-target;\\n        \\n        if(target%2==0) return 1+brokenCalc(start, target/2);\\n\\t\\t\\n        return 1+brokenCalc(start, target+1);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1875420,
                "title": "c-0ms-runtime-easy-solution",
                "content": "class Solution {\\npublic:\\n\\n    int brokenCalc(int startValue, int target) {\\n        int count=0;\\n        while(target>startValue)\\n        {\\n            count++;\\n            if(target%2==0)\\n                target/=2;\\n            else\\n                target++;\\n        }\\n        return count+(startValue-target);\\n        \\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n\\n    int brokenCalc(int startValue, int target) {\\n        int count=0;\\n        while(target>startValue)\\n        {\\n            count++;\\n            if(target%2==0)\\n                target/=2;\\n            else\\n                target++;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1875403,
                "title": "c-short-and-simple-solution-greedy",
                "content": "```\\nclass Solution {\\npublic:\\n    \\n    int brokenCalc(int x, int y) {\\n        \\n        if(x >= y)\\n            return x - y;\\n        \\n        int ans = 0;\\n        \\n        while(y > x){\\n            \\n            if(y % 2 == 0)\\n                y = y / 2;\\n            \\n            else\\n                y++;\\n            \\n            ans++;\\n        }\\n        \\n        ans += x - y;\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    int brokenCalc(int x, int y) {\\n        \\n        if(x >= y)\\n            return x - y;\\n        \\n        int ans = 0;\\n        \\n        while(y > x){\\n            \\n            if(y % 2 == 0)\\n                y = y / 2;\\n            \\n            else\\n                y++;\\n            \\n            ans++;\\n        }\\n        \\n        ans += x - y;\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1875399,
                "title": "java-100-faster-0ms",
                "content": "```\\nclass Solution {\\n    public int brokenCalc(int startValue, int target) {\\n        \\n\\t\\t//edge case\\n        if(startValue >= target){\\n            return startValue - target;\\n        }\\n        \\n        int count = 0;\\n        \\n        while( startValue < target){\\n            if(target % 2 == 0){\\n                target /= 2;\\n            }else{\\n                target += 1;\\n            }\\n            \\n            count++;\\n        }\\n        \\n        if(startValue > target){\\n            count += Math.abs(startValue - target);\\n        }\\n        \\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Math"
                ],
                "code": "```\\nclass Solution {\\n    public int brokenCalc(int startValue, int target) {\\n        \\n\\t\\t//edge case\\n        if(startValue >= target){\\n            return startValue - target;\\n        }\\n        \\n        int count = 0;\\n        \\n        while( startValue < target){\\n            if(target % 2 == 0){\\n                target /= 2;\\n            }else{\\n                target += 1;\\n            }\\n            \\n            count++;\\n        }\\n        \\n        if(startValue > target){\\n            count += Math.abs(startValue - target);\\n        }\\n        \\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1875344,
                "title": "c-0-ms-faster-than-100-00-simple-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int brokenCalc(int startValue, int target) {\\n        int ans=0;\\n        while(target>startValue){\\n            ans++;\\n            if(target%2==0){\\n                target/=2;\\n            }\\n            else\\n                target++;\\n        }\\n        return ans+(startValue-target);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int brokenCalc(int startValue, int target) {\\n        int ans=0;\\n        while(target>startValue){\\n            ans++;\\n            if(target%2==0){\\n                target/=2;\\n            }\\n            else\\n                target++;\\n        }\\n        return ans+(startValue-target);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1875269,
                "title": "broken-calculator-c-100-o-n-greedy-solution-with-explanation-easy-simple-solution",
                "content": "Try to think Greedily in Opposite Direction i.e start from target Value to reach upto Start Value.\\n\\ni) if targetValue is greater than startValue divide target value by 2 ( as we can multiply start value by 2)\\nif it is not completely divisible then add 1 after division.\\n\\nii) if targetValue is less than startValue add 1 in target Value upto which it reaches to start value ( since we can substract 1 each time from start Value).\\n          \\nPlease Upvote if this is helpful\\n```\\nclass Solution {\\npublic:\\n    int brokenCalc(int startValue, int target) {\\n        int temp=target;\\n        int count=0;\\n        while(temp>startValue){\\n           \\n               if(temp%2==0){\\n                   temp/=2;\\n                   count++;\\n               }else{\\n                   temp=temp/2 + 1;\\n                   count+=2;\\n               }\\n          \\n        }\\n        if(temp<startValue){\\n            count+=startValue-temp;\\n        }\\n        return count;\\n    }\\n};\\n```\\n\\nPlease Go through my Other Solutions ans Upvote if it is Helpful  :\\nhttps://leetcode.com/problems/partition-labels/discuss/1868704/partition-labels-on-solution-c-greedy-simple-solution\\nhttps://leetcode.com/problems/power-of-four/discuss/1799832/power-of-four-c100bit-manipualtion-easy-solution\\nhttps://leetcode.com/problems/partition-labels/discuss/1868704/partition-labels-on-solution-c-greedy-simple-solution\\nhttps://leetcode.com/problems/binary-tree-level-order-traversal/discuss/1862025/binary-tree-level-order-traversal-queue-binary-tree-easy-solution\\nhttps://leetcode.com/problems/minimum-remove-to-make-valid-parentheses/discuss/1850726/minimum-remove-to-make-valid-parentheses-c-on-simple-logic-easy-solution\\nhttps://leetcode.com/problems/maximum-number-of-vowels-in-a-substring-of-given-length/discuss/1849453/maximum-number-of-vowels-in-a-substring-of-given-length-csliding-window\\nhttps://leetcode.com/problems/reverse-prefix-of-word/discuss/1840375/reverse-prefix-of-word-100-c\\nhttps://leetcode.com/problems/find-n-unique-integers-sum-up-to-zero/discuss/1826246/find-n-unique-integers-sum-up-to-zero-100-simple-solution\\nhttps://leetcode.com/problems/find-minimum-in-rotated-sorted-array/discuss/1814346/find-minimum-in-rotated-sorted-array-binary-search-100-ceasy-solution\\nhttps://leetcode.com/problems/is-subsequence/discuss/1811098/is-subsequence-100-c-easy-solution\\nhttps://leetcode.com/problems/search-in-rotated-sorted-array/discuss/1808021/search-in-rotated-sorted-array-ologn-solution-simple-solution-binary-search\\nhttps://leetcode.com/problems/check-if-number-is-a-sum-of-powers-of-three/discuss/1799853/check-if-number-is-a-sum-of-powers-of-three-100-easy-solution\\nhttps://leetcode.com/problems/sequential-digits/discuss/1751815/sequential-digits-c-100-easy-solution\\nhttps://leetcode.com/problems/binary-gap/discuss/1749101/binary-gap-100-c-simple-solution\\nhttps://leetcode.com/problems/kth-largest-element-in-an-array/discuss/1730888/kth-largest-element-in-an-array-c-sorting-simple-solution\\nhttps://leetcode.com/problems/queries-on-number-of-points-inside-a-circle/discuss/1726527/queries-on-number-of-points-inside-a-circle-c-simple-mathematics\\nhttps://leetcode.com/problems/integer-to-roman/discuss/1726042/integer-to-roman-c-easy-to-understand\\nhttps://leetcode.com/problems/rings-and-rods/discuss/1724149/rings-and-rods-100-c-using-hashmap\\nhttps://leetcode.com/problems/number-complement/discuss/1722669/number-compliment\\nhttps://leetcode.com/problems/find-the-duplicate-number/discuss/1809351/find-the-duplicate-number-o1-space-binary-search-easy-solution\\nhttps://leetcode.com/problems/smallest-string-with-a-given-numeric-value/discuss/1872424/Smallest-String-With-A-Given-Numeric-Value-oror-C%2B%2B-O(n)-oror-Simple-Solution-with-Explaination",
                "solutionTags": [
                    "C++",
                    "C",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int brokenCalc(int startValue, int target) {\\n        int temp=target;\\n        int count=0;\\n        while(temp>startValue){\\n           \\n               if(temp%2==0){\\n                   temp/=2;\\n                   count++;\\n               }else{\\n                   temp=temp/2 + 1;\\n                   count+=2;\\n               }\\n          \\n        }\\n        if(temp<startValue){\\n            count+=startValue-temp;\\n        }\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1875251,
                "title": "easy-greedy-o-log-target-0ms",
                "content": "Easy greedy \\n```\\n    int brokenCalc(int start, int target) {\\n        int c=0;\\n        while(start!=target){\\n            if(target>start){\\n            if(target%2==0){\\n                target/=2;\\n            }else\\n                target++;\\n            }\\n            else\\n                break;\\n            c++;\\n        }\\n        c+=(start-target);\\n        return c;\\n    }\\n```",
                "solutionTags": [
                    "C++",
                    "Math",
                    "Greedy"
                ],
                "code": "```\\n    int brokenCalc(int start, int target) {\\n        int c=0;\\n        while(start!=target){\\n            if(target>start){\\n            if(target%2==0){\\n                target/=2;\\n            }else\\n                target++;\\n            }\\n            else\\n                break;\\n            c++;\\n        }\\n        c+=(start-target);\\n        return c;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1875239,
                "title": "java-100-faster-code",
                "content": "\\'\\'\\'\\n\\n\\nclass Solution {\\npublic int brokenCalc(int startValue, int target) {\\n    if(target < startValue)\\n    {\\n        return startValue - target;\\n    }\\n    \\n    int ops = 0;\\n    while(target > startValue)\\n    {\\n        if(target%2 == 1)\\n        {\\n            target += 1;\\n            ops++;\\n        }\\n        \\n        target = target/2;\\n        ops++;\\n    }\\n    \\n    ops += (startValue-target);\\n    return ops;\\n}\\n}",
                "solutionTags": [],
                "code": "class Solution {\\npublic int brokenCalc(int startValue, int target) {\\n    if(target < startValue)\\n    {\\n        return startValue - target;\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 1875234,
                "title": "c-100-fast-with-explanation",
                "content": "**Approach :**\\n\\n\\t\\t\\t1.we will go in reverse manner so, think how to go from  target --> start\\n\\t\\t\\t2.  we can do two operation to reach startValue\\n\\t\\t\\t\\t1.   target ++  if target is odd \\n\\t\\t\\t\\t2.   target/=2   if target is even\\n\\t\\t\\t\\t3.   increase the cnt\\n\\t\\t    3. we will do step 2 until target > startValue\\t\\n\\t\\t    4. add startValue- target to cnt and return it\\t\\n\\n```\\nclass Solution {\\npublic:\\n    int brokenCalc(int startValue, int target) {\\n        \\n        int cnt=0;\\n        while(target>startValue){\\n            if(target%2)\\n              target++;\\n            else\\n               target/=2;\\n            cnt++;\\n        }\\n        return cnt+startValue-target;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int brokenCalc(int startValue, int target) {\\n        \\n        int cnt=0;\\n        while(target>startValue){\\n            if(target%2)\\n              target++;\\n            else\\n               target/=2;\\n            cnt++;\\n        }\\n        return cnt+startValue-target;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1875164,
                "title": "simple-c-ggreedy-solution-100-faster",
                "content": "time and space - O(log(y/x)) and O(1)\\n\\nclass Solution {\\npublic:\\n    int brokenCalc(int startValue, int target) {\\n\\t\\n        int x= startValue;\\n        int y = target;\\n        \\n        int cnt =0;\\n        \\n        // instead of going from x to y, we r going from y to x\\n        // so our new operations become:\\n        // 1. divide y by 2 (ofc it has to be even , so add +1 to make it even ist )\\n        // 2. add +1 to y\\n        while( x<y){\\n            \\n            // if y is odd, make it even ist\\n            if( y%2)\\n                y++;\\n            \\n            // if its even, keep on dividing by 2, unless y becomes less than x\\n            else\\n                y/=2;\\n            \\n            cnt++;\\n\\n        }\\n        // y goes below x, so the only option left is to keep on addiing 1 to y\\n        // until we reach x\\n        cnt+= (x-y);\\n        \\n        return cnt;\\n    }\\n};",
                "solutionTags": [
                    "C++",
                    "C",
                    "Greedy"
                ],
                "code": "class Solution {\\npublic:\\n    int brokenCalc(int startValue, int target) {\\n\\t\\n        int x= startValue;\\n        int y = target;\\n        \\n        int cnt =0;\\n        \\n        // instead of going from x to y, we r going from y to x\\n        // so our new operations become:\\n        // 1. divide y by 2 (ofc it has to be even , so add +1 to make it even ist )\\n        // 2. add +1 to y\\n        while( x<y){\\n            \\n            // if y is odd, make it even ist\\n            if( y%2)\\n                y++;\\n            \\n            // if its even, keep on dividing by 2, unless y becomes less than x\\n            else\\n                y/=2;\\n            \\n            cnt++;\\n\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1875147,
                "title": "c-recursion-easy-simple-algorithms-reverse",
                "content": "Approach: If you try to convert target to startValue then this problem is looks very easy recursion solution.\\n\\nStep 1: if target is odd then we have to add substract cost along with division cost.\\nStep 2: Base case when target is less than startValue then simply add the difference in the ans.\\n\\n```\\nclass Solution {\\npublic:\\n    int brokenCalc(int startValue, int target) {        \\n        //Base case\\n        if(startValue>=target)\\n            return startValue - target;        \\n\\t\\t\\t\\n\\t\\t// division cost\\n        int ans = 1;\\n\\t\\t\\n        if(target%2!=0) {\\n            target++;\\n\\t\\t\\t// subtraction cost\\n            ans++;\\n        }                    \\n\\t\\t\\n        ans += brokenCalc(startValue,target/2);        \\n        return ans;\\n    }\\n};\\n```\\n\\nOptimized Code:\\n```\\nclass Solution {\\npublic:\\n    int brokenCalc(int startValue, int target) {        \\n        \\n        if(startValue >= target)\\n            return startValue - target;        \\n\\t\\t\\t\\n        if(target%2 != 0)\\n            return 2 + brokenCalc(startValue, (target+1)/2);        \\n\\t\\t       \\n        return 1 + brokenCalc(startValue, target/2);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Math"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int brokenCalc(int startValue, int target) {        \\n        //Base case\\n        if(startValue>=target)\\n            return startValue - target;        \\n\\t\\t\\t\\n\\t\\t// division cost\\n        int ans = 1;\\n\\t\\t\\n        if(target%2!=0) {\\n            target++;\\n\\t\\t\\t// subtraction cost\\n            ans++;\\n        }                    \\n\\t\\t\\n        ans += brokenCalc(startValue,target/2);        \\n        return ans;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int brokenCalc(int startValue, int target) {        \\n        \\n        if(startValue >= target)\\n            return startValue - target;        \\n\\t\\t\\t\\n        if(target%2 != 0)\\n            return 2 + brokenCalc(startValue, (target+1)/2);        \\n\\t\\t       \\n        return 1 + brokenCalc(startValue, target/2);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1875115,
                "title": "simple-iterative-java-solution",
                "content": "\\n\\nclass Solution {\\n\\n    public int brokenCalc(int startValue, int target) {\\n        int ans = 0;\\n        while(target > startValue){\\n            if(target % 2 == 0) target /= 2;\\n            else  target++; \\n            ans++;\\n        } return ans + (startValue - target);\\n}\\n\\n}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n\\n    public int brokenCalc(int startValue, int target) {\\n        int ans = 0;\\n        while(target > startValue){\\n            if(target % 2 == 0) target /= 2;\\n            else  target++; \\n            ans++;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1875066,
                "title": "clean-and-documented-greedy-solution",
                "content": "```\\nclass Solution:\\n    def brokenCalc(self, X: int, Y: int) -> int:\\n        \"\"\"\\n        We have gotten a \"finite\" path S: X -> X[1] -> X[2] -> ... X[n] -> Y and assume X < Y.\\n\\n        Statement: if Y is even then last operation to reach Y must be of multiplication.\\n        Proof: Suppose that is not the case.\\n               Then X[n] = Y + 1.\\n\\n               Now X[n] is odd, so the last operation to reach X[n] can not be multiplication\\n               by 2, it has to be a subtraction by 1.\\n\\n               Now X[n-1] is even. Also that X[n-1] = Y + 2. Applying the statement that\\n               last operation must be of subtraction if number to reach is even, we find\\n               that we are moving away and away from Y.\\n\\n               Hence the length of path S can not be finite. And this is a contraction.\\n\\n               Hence we conclude that last operation must be of multiplication by 2 if\\n               Y is even.\\n        Done\\n\\n        Also note that if Y is odd then last operation can not be of multiplication by 2,\\n        which mean last operation must be of type subtraction.\\n\\n        In the following implementation, we trace back from Y to X, so operation of multiplication\\n        becomes that of division and operation of subtraction becomes that of addition.\\n\\n        Also @see https://leetcode.com/problems/broken-calculator/discuss/234484/JavaC%2B%2BPython-Change-Y-to-X-in-1-Line\\n        :param X:\\n        :param Y:\\n        :return:\\n        \"\"\"\\n        output = 0\\n\\n        while X < Y:\\n            if Y % 2 == 0:\\n                Y //= 2\\n            else:\\n                Y += 1\\n\\n            output += 1\\n\\n        return output + (X - Y)\\n```",
                "solutionTags": [
                    "Python",
                    "Greedy"
                ],
                "code": "```\\nclass Solution:\\n    def brokenCalc(self, X: int, Y: int) -> int:\\n        \"\"\"\\n        We have gotten a \"finite\" path S: X -> X[1] -> X[2] -> ... X[n] -> Y and assume X < Y.\\n\\n        Statement: if Y is even then last operation to reach Y must be of multiplication.\\n        Proof: Suppose that is not the case.\\n               Then X[n] = Y + 1.\\n\\n               Now X[n] is odd, so the last operation to reach X[n] can not be multiplication\\n               by 2, it has to be a subtraction by 1.\\n\\n               Now X[n-1] is even. Also that X[n-1] = Y + 2. Applying the statement that\\n               last operation must be of subtraction if number to reach is even, we find\\n               that we are moving away and away from Y.\\n\\n               Hence the length of path S can not be finite. And this is a contraction.\\n\\n               Hence we conclude that last operation must be of multiplication by 2 if\\n               Y is even.\\n        Done\\n\\n        Also note that if Y is odd then last operation can not be of multiplication by 2,\\n        which mean last operation must be of type subtraction.\\n\\n        In the following implementation, we trace back from Y to X, so operation of multiplication\\n        becomes that of division and operation of subtraction becomes that of addition.\\n\\n        Also @see https://leetcode.com/problems/broken-calculator/discuss/234484/JavaC%2B%2BPython-Change-Y-to-X-in-1-Line\\n        :param X:\\n        :param Y:\\n        :return:\\n        \"\"\"\\n        output = 0\\n\\n        while X < Y:\\n            if Y % 2 == 0:\\n                Y //= 2\\n            else:\\n                Y += 1\\n\\n            output += 1\\n\\n        return output + (X - Y)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1874974,
                "title": "c-100-faster-iterative-approach-easy-to-understand-o-log-n",
                "content": "**// Please upvote if it is helpful**\\n\\n*Time complexity: O(log n)\\nSpace complexity: O(1)*\\n\\n```\\n\\nclass Solution {\\npublic:\\n    int brokenCalc(int startValue, int target) {\\n        int result =0;\\n        while(target> startValue){\\n            result++;\\n            if(target%2 ==0 ){\\n                target/=2;\\n            }\\n            else{\\n                target++;\\n            }\\n        }\\n        return result+(startValue - target);\\n    }\\n};\\n```\\n",
                "solutionTags": [],
                "code": "```\\n\\nclass Solution {\\npublic:\\n    int brokenCalc(int startValue, int target) {\\n        int result =0;\\n        while(target> startValue){\\n            result++;\\n            if(target%2 ==0 ){\\n                target/=2;\\n            }\\n            else{\\n                target++;\\n            }\\n        }\\n        return result+(startValue - target);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1874944,
                "title": "will-a-heuristic-search-algorithm-solve-the-problem",
                "content": "BFS gives a TLE here. What about some heuristic search algorithms, such as A star?\\n\\nMy python code that implements A star.\\nMemory limit exceeded on the case 5/84\\uFF0C where the input is (1, 1000000000)\\n\\n```python\\nclass Solution:\\n    def heuristic(self, start, end):\\n        if start > end:\\n            return start - end\\n        else:\\n            steps = 0\\n            while start <= end:\\n                start *= 2\\n                steps += 1\\n            steps += (start - end)\\n            return steps\\n        \\n    def neighbor(self, start):\\n        return [start * 2, start - 1]\\n    \\n    def brokenCalc(self, startValue: int, target: int) -> int:\\n        # A* finds a path from start to goal.\\n        # h is the heuristic function. h(n) estimates the cost to reach goal from node n.\\n\\n        # The set of discovered nodes that may need to be (re-)expanded.\\n        # Initially, only the start node is known.\\n        # This is usually implemented as a min-heap or priority queue rather than a hash-set.\\n        start = startValue\\n        openSetNodes = set([start])\\n        openSet = [(0, start)] \\n        heapq.heapify(openSet)\\n            \\n        # For node n, cameFrom[n] is the node immediately preceding it on the cheapest path from start to n currently known.\\n        cameFrom = {}\\n        # For node n, gScore[n] is the cost of the cheapest path from start to n currently known.\\n        gScore  = {start: 0}\\n        # For node n, fScore[n] := gScore[n] + h(n). fScore[n] represents our current best guess as to how short a path from start to finish can be if it goes through n.\\n        fScore = {start: 0}\\n        while openSet:\\n        # This operation can occur in O(Log(N)) time if openSet is a min-heap or a priority queue\\n            # print(openSet)\\n            fscore,  current = heapq.heappop(openSet)\\n            openSetNodes.remove(current)\\n            if current == target:\\n                count = 0\\n                while current != start:\\n                    count += 1\\n                    current = cameFrom[current]\\n                return count\\n\\n            for neighbor in self.neighbor(current):\\n                # d(current,neighbor) is the weight of the edge from current to neighbor\\n                # tentative_gScore is the distance from start to the neighbor through current\\n                if neighbor <= 0:\\n                    continue\\n                tentative_gScore = gScore.get(current, 1000000000) + 1\\n                if tentative_gScore < gScore.get(neighbor, 1000000000):\\n                    # This path to neighbor is better than any previous one. Record it!\\n                    cameFrom[neighbor] = current\\n                    gScore[neighbor] = tentative_gScore\\n                    fScore[neighbor] = tentative_gScore + self.heuristic(neighbor, target)\\n                    if neighbor not in openSetNodes:\\n                        openSetNodes.add(neighbor)\\n                        heapq.heappush(openSet, (fScore[neighbor], neighbor))\\n```\\n\\n",
                "solutionTags": [],
                "code": "```python\\nclass Solution:\\n    def heuristic(self, start, end):\\n        if start > end:\\n            return start - end\\n        else:\\n            steps = 0\\n            while start <= end:\\n                start *= 2\\n                steps += 1\\n            steps += (start - end)\\n            return steps\\n        \\n    def neighbor(self, start):\\n        return [start * 2, start - 1]\\n    \\n    def brokenCalc(self, startValue: int, target: int) -> int:\\n        # A* finds a path from start to goal.\\n        # h is the heuristic function. h(n) estimates the cost to reach goal from node n.\\n\\n        # The set of discovered nodes that may need to be (re-)expanded.\\n        # Initially, only the start node is known.\\n        # This is usually implemented as a min-heap or priority queue rather than a hash-set.\\n        start = startValue\\n        openSetNodes = set([start])\\n        openSet = [(0, start)] \\n        heapq.heapify(openSet)\\n            \\n        # For node n, cameFrom[n] is the node immediately preceding it on the cheapest path from start to n currently known.\\n        cameFrom = {}\\n        # For node n, gScore[n] is the cost of the cheapest path from start to n currently known.\\n        gScore  = {start: 0}\\n        # For node n, fScore[n] := gScore[n] + h(n). fScore[n] represents our current best guess as to how short a path from start to finish can be if it goes through n.\\n        fScore = {start: 0}\\n        while openSet:\\n        # This operation can occur in O(Log(N)) time if openSet is a min-heap or a priority queue\\n            # print(openSet)\\n            fscore,  current = heapq.heappop(openSet)\\n            openSetNodes.remove(current)\\n            if current == target:\\n                count = 0\\n                while current != start:\\n                    count += 1\\n                    current = cameFrom[current]\\n                return count\\n\\n            for neighbor in self.neighbor(current):\\n                # d(current,neighbor) is the weight of the edge from current to neighbor\\n                # tentative_gScore is the distance from start to the neighbor through current\\n                if neighbor <= 0:\\n                    continue\\n                tentative_gScore = gScore.get(current, 1000000000) + 1\\n                if tentative_gScore < gScore.get(neighbor, 1000000000):\\n                    # This path to neighbor is better than any previous one. Record it!\\n                    cameFrom[neighbor] = current\\n                    gScore[neighbor] = tentative_gScore\\n                    fScore[neighbor] = tentative_gScore + self.heuristic(neighbor, target)\\n                    if neighbor not in openSetNodes:\\n                        openSetNodes.add(neighbor)\\n                        heapq.heappush(openSet, (fScore[neighbor], neighbor))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1874924,
                "title": "python-recursion-thinking-backwards",
                "content": "```\\nclass Solution:\\n    def brokenCalc(self, startValue: int, target: int) -> int:\\n        if target<=startValue:\\n            return (startValue-target)\\n        elif target%2==1:\\n            return 1+Solution.brokenCalc(self,startValue,target+1)\\n        else:\\n            return 1+Solution.brokenCalc(self,startValue,target//2)\\n```",
                "solutionTags": [
                    "Python",
                    "Recursion"
                ],
                "code": "```\\nclass Solution:\\n    def brokenCalc(self, startValue: int, target: int) -> int:\\n        if target<=startValue:\\n            return (startValue-target)\\n        elif target%2==1:\\n            return 1+Solution.brokenCalc(self,startValue,target+1)\\n        else:\\n            return 1+Solution.brokenCalc(self,startValue,target//2)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1874899,
                "title": "java-simple-and-efficient",
                "content": "The idea is  to reach from \"target\" to \"startValue\" instead of the opposite (Which is most of us try on the first think)\\n```\\n\\t\\tint counter = 0;\\n        while (startValue<target){\\n            if (target%2 == 0){\\n                target = target /2;\\n            }else {\\n                target = target + 1;\\n            }\\n            counter++;\\n        }\\n\\n        counter += startValue - target;\\n        return counter;\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n\\t\\tint counter = 0;\\n        while (startValue<target){\\n            if (target%2 == 0){\\n                target = target /2;\\n            }else {\\n                target = target + 1;\\n            }\\n            counter++;\\n        }\\n\\n        counter += startValue - target;\\n        return counter;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1874823,
                "title": "easy-java-solution-target-to-startvalue",
                "content": "class Solution {\\n    public int brokenCalc(int startValue, int target) {\\n     \\n       int result = 0;\\n\\n        while(startValue != target) {\\n            if (startValue > target) {\\n                result += startValue - target;\\n                break;\\n            }\\n            if(target % 2 == 1) {\\n                target++;\\n            }else{\\n                target = target / 2;\\n            }\\n            result++;\\n        }\\n\\n        return result;\\n    }\\n}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    public int brokenCalc(int startValue, int target) {\\n     \\n       int result = 0;\\n\\n        while(startValue != target) {\\n            if (startValue > target) {\\n                result += startValue - target;\\n                break;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1874789,
                "title": "c-java-solution-o-n-time-and-o-1-space",
                "content": "The intuition is to make the target equal to the startValue.\\n1. If target is even we divide it by 2\\n2. If target is odd we add 1 to it\\n\\nTry to dry run with some cases it will become clear.\\n\\n**C++:**\\n```\\nclass Solution {\\npublic:\\n    int brokenCalc(int startValue, int target) {\\n        int ans = 0;\\n        while (startValue < target) {\\n            ++ans;\\n            if (target & 1) ++target;\\n            else target /= 2;\\n        }\\n        return ans + startValue - target;\\n    }\\n};\\n```\\n\\n**Java:**\\n```\\nclass Solution {\\n    public int brokenCalc(int startValue, int target) {\\n        int ans = 0;\\n        while (startValue < target) {\\n            ++ans;\\n            if ((target & 1) == 1) ++target;\\n            else target /= 2;\\n        }\\n        return ans + startValue - target;\\n    }\\n}\\n```\\n\\n**Time complexity:** O(N)\\n**Space complexity:** O(1)",
                "solutionTags": [
                    "Java",
                    "C",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int brokenCalc(int startValue, int target) {\\n        int ans = 0;\\n        while (startValue < target) {\\n            ++ans;\\n            if (target & 1) ++target;\\n            else target /= 2;\\n        }\\n        return ans + startValue - target;\\n    }\\n};\\n```\n```\\nclass Solution {\\n    public int brokenCalc(int startValue, int target) {\\n        int ans = 0;\\n        while (startValue < target) {\\n            ++ans;\\n            if ((target & 1) == 1) ++target;\\n            else target /= 2;\\n        }\\n        return ans + startValue - target;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1399699,
                "title": "simple-java-solution",
                "content": "class Solution {\\n\\n    public int brokenCalc(int s, int t) {\\n        int c=0;\\n        while(t>s)\\n        {\\n            c++;\\n            if(t%2==0)\\n                t/=2;\\n            else\\n                t++;\\n        }\\n        return c+(s-t);\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n\\n    public int brokenCalc(int s, int t) {\\n        int c=0;\\n        while(t>s)\\n        {\\n            c++;\\n            if(t%2==0)\\n                t/=2;\\n            else\\n                t++;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1355780,
                "title": "kotlin",
                "content": "Keep dividing y until you get to an odd number or a value less than or equal to x. Since if after doubling you\\'d be off by more than 2, it\\'s always better to decrement before doubling (i.e. `4->8->7->6` is worse than `4->3->6`) we\\'ll continue halving until we\\'re at or below the starting value, then we\\'d decrement to get there.\\n\\nWalking through, let\\'s say your starting x is 6 and y is 100, here are the loop steps.\\n\\n0) 100 -> too big, divisible by 2\\n1) 50 -> too big, divisible by 2\\n2) 25 -> too big, but not divisible by 2. We can only be off by 1 since otherwise you\\'d decrement before doubling.\\n3) 26 -> too big, divisible by 2\\n4) 13 -> too big, not divisible, add 1\\n5) 14 -> too big, divisible\\n6) 7 -> too big, not divisible, add 1\\n7) 8 -> too big, divisible\\n8) 4 -> too small\\n\\nSince we start with 6 and need to get to 4 to get into the sequence, we return those 8 steps plus the difference 6 - 4 = 2. So 10 total steps.\\n\\n```\\nclass Solution {\\n    fun brokenCalc(x: Int, y: Int): Int {\\n        var steps = 0\\n        var target = y\\n        while (target > x) {\\n            if (target % 2 == 0)\\n                target /= 2\\n            else\\n                target++\\n            steps++\\n        }\\n\\n        return steps + (x - target)\\n    }\\n}\\n```",
                "solutionTags": [
                    "Kotlin"
                ],
                "code": "```\\nclass Solution {\\n    fun brokenCalc(x: Int, y: Int): Int {\\n        var steps = 0\\n        var target = y\\n        while (target > x) {\\n            if (target % 2 == 0)\\n                target /= 2\\n            else\\n                target++\\n            steps++\\n        }\\n\\n        return steps + (x - target)\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1206172,
                "title": "java-easy-solution-with-explanation",
                "content": "# Basic Idea\\n\\n1. I am Y, and I want to become X.\\n    - Question arises why not start from X and go to Y? Well,  if you start from X, you can\\'t say for sure that is X*2 more optimal or X-1 will give a better solution. Why so? Because there is no criteria for you to judge.  This will become more clear, when you read below.\\n\\n2. If I am divisible by 2, I can simply reduce myself to half my number in one step.\\n    - Question arises why did I not increment myself by 1, how is dividing by 2  an optimal step? Well, listen. I want to reach X in the least possible steps,\\n\\n        My Goal : Y \\u2192 X \\n\\n        Case 1 : Y \\u2192 Y/2 \\u2014\\u2014\\u2014\\u2014\\u2192 X . Say steps taken are C_1\\n        Case 2 : Y \\u2192 Y+1 \\u2192 Y+1 \\u2192 Y/2 \\u2014\\u2014\\u2192 X. Steps taken will be C_1 + 2\\n        { If a number is  not divisible by  2 you can\\'t divide it by 2, that is against the rules of the question | \\n\\n        *To sum up every time you increment by 1, you will take 2 more steps to reach X. So Y/2 is surely the optimal solution.*\\n\\n3. If I am not divisible by 2, the only option I have is to increment myself by 1.\\n\\n\\n![image](https://assets.leetcode.com/users/images/ba17bfa7-3e89-4fbe-8609-de837464eea1_1620905451.088948.png)\\n\\n# Code\\n\\n\\tpublic int brokenCalc(int X, int Y) {\\n        int res = 0;\\n        while (Y > X) {\\n            Y = Y % 2 == 0 ? Y/2 : Y+1;\\n            res++;\\n        }\\n        return res + X - Y;\\n    }\\n",
                "solutionTags": [],
                "code": "# Basic Idea\\n\\n1. I am Y, and I want to become X.\\n    - Question arises why not start from X and go to Y? Well,  if you start from X, you can\\'t say for sure that is X*2 more optimal or X-1 will give a better solution. Why so? Because there is no criteria for you to judge.  This will become more clear, when you read below.\\n\\n2. If I am divisible by 2, I can simply reduce myself to half my number in one step.\\n    - Question arises why did I not increment myself by 1, how is dividing by 2  an optimal step? Well, listen. I want to reach X in the least possible steps,\\n\\n        My Goal : Y \\u2192 X \\n\\n        Case 1 : Y \\u2192 Y/2 \\u2014\\u2014\\u2014\\u2014\\u2192 X . Say steps taken are C_1\\n        Case 2 : Y \\u2192 Y+1 \\u2192 Y+1 \\u2192 Y/2 \\u2014\\u2014\\u2192 X. Steps taken will be C_1 + 2\\n        { If a number is  not divisible by  2 you can\\'t divide it by 2, that is against the rules of the question | \\n\\n        *To sum up every time you increment by 1, you will take 2 more steps to reach X. So Y/2 is surely the optimal solution.*\\n\\n3. If I am not divisible by 2, the only option I have is to increment myself by 1.\\n\\n\\n![image](https://assets.leetcode.com/users/images/ba17bfa7-3e89-4fbe-8609-de837464eea1_1620905451.088948.png)\\n\\n# Code\\n\\n\\tpublic int brokenCalc(int X, int Y) {\\n        int res = 0;\\n        while (Y > X) {\\n            Y = Y % 2 == 0 ? Y/2 : Y+1;\\n            res++;\\n        }\\n        return res + X - Y;\\n    }\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 1122770,
                "title": "c-short-recursion-with-explanation",
                "content": "```\\nclass Solution {\\npublic:\\n    int brokenCalc(int X, int Y) {\\n        // There are 3 scenarios:\\n        // 1) if X >= Y, we can only subtract 1 from X to get Y, so the result == X - Y.\\n        // 2) if X < Y && Y is odd, we need to reach Y + 1 first and then subtract 1 to get Y,\\n        //    so the result will be brokenCalc(X, Y + 1) + 1 (recursion).\\n        // 3) if X < Y && Y is even, we need to reach Y / 2 first and then multiply 2 to get Y,\\n        //    so the result is brokenCalc(X, Y / 2) + 1. \\n        // To prove our conclusion in 3), assume X >= Y / 2, to get Y we either multiple and then subtract, \\n        // aka 1 + 2 * X - Y #, or reach Y / 2 and then Y, aka 1 + X - Y / 2 <= 1 + 2 * X - Y.\\n        // Therefore to reach Y (even) we always need to get Y / 2 first.\\n        if (X >= Y)\\n        {\\n            return X - Y;\\n        }\\n        \\n        if (Y % 2 == 1)\\n        {\\n            return 1 + brokenCalc(X, Y + 1);\\n        }\\n        \\n        return 1 + brokenCalc(X, Y / 2);\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int brokenCalc(int X, int Y) {\\n        // There are 3 scenarios:\\n        // 1) if X >= Y, we can only subtract 1 from X to get Y, so the result == X - Y.\\n        // 2) if X < Y && Y is odd, we need to reach Y + 1 first and then subtract 1 to get Y,\\n        //    so the result will be brokenCalc(X, Y + 1) + 1 (recursion).\\n        // 3) if X < Y && Y is even, we need to reach Y / 2 first and then multiply 2 to get Y,\\n        //    so the result is brokenCalc(X, Y / 2) + 1. \\n        // To prove our conclusion in 3), assume X >= Y / 2, to get Y we either multiple and then subtract, \\n        // aka 1 + 2 * X - Y #, or reach Y / 2 and then Y, aka 1 + X - Y / 2 <= 1 + 2 * X - Y.\\n        // Therefore to reach Y (even) we always need to get Y / 2 first.\\n        if (X >= Y)\\n        {\\n            return X - Y;\\n        }\\n        \\n        if (Y % 2 == 1)\\n        {\\n            return 1 + brokenCalc(X, Y + 1);\\n        }\\n        \\n        return 1 + brokenCalc(X, Y / 2);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1077501,
                "title": "cpp-fast-easy-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int brokenCalc(int X, int Y) {\\n        int c=0;\\n        while(X!=Y)\\n        {\\n            if(Y>X&&Y%2!=0)\\n            {\\n                Y+=1;\\n                c++;\\n            }\\n          else if(Y>X)\\n            {\\n                Y/=2;\\n                c++;\\n            }\\n            else\\n            {\\n                c+=(X-Y);\\n                break;\\n            }\\n        }\\n        return c;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int brokenCalc(int X, int Y) {\\n        int c=0;\\n        while(X!=Y)\\n        {\\n            if(Y>X&&Y%2!=0)\\n            {\\n                Y+=1;\\n                c++;\\n            }\\n          else if(Y>X)\\n            {\\n                Y/=2;\\n                c++;\\n            }\\n            else\\n            {\\n                c+=(X-Y);\\n                break;\\n            }\\n        }\\n        return c;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1076951,
                "title": "python-3-bit-manipulation-o-log-log-n",
                "content": "# Greedy approach\\n- if Y <= X then we can only decrement X `X-Y` times.\\n- Else we should double X `mul = ceil(log2(Y/X))` times in any case. To get Y we should decrement doublings by `difference = X*2**mul - Y`.  And our goal is to optimize it.\\n- Every two decrements after doubling can be replaced by one decrement before doubling. So every doubling can be with zero or one decrement, but for big differences we need several decrements before doublings. It is easy to implement this parity checking in reverse order: half and increment Y.\\n- Time complexity is `O(log Y/X)`. Space complexity is `O(1)`.\\n```\\nclass Solution:\\n    def brokenCalc(self, X: int, Y: int) -> int:\\n        count = 0\\n        while Y > X:\\n            if Y&1:\\n                Y += 1\\n                count += 1\\n            Y >>= 1\\n            count += 1\\n            \\n        return count + X-Y\\n```\\n\\n# Bit manipulation approach\\n- As you can see in the Greedy approach result consists of three terms.\\n- First term is `mul = ceil(log2(Y/X))`.\\n- Second term is a number of decrements with doublings, or set bit count of `mul` least significant bits of `difference = X*2**mul - Y`.\\n- Third term is a number of decrements before doublings `difference / 2**mul`\\n- Time complexity is `O(log log n)`. For 32-bit integers `log log n = 5`. Space complexity is `O(1)`.\\n\\n```\\nclass Solution:\\n    def brokenCalc(self, X: int, Y: int) -> int:\\n        d = (Y-1)//X; mul = bool(d)\\n        if d & 0xffff0000: d >>=16; mul +=16\\n        if d &     0xff00: d >>= 8; mul += 8\\n        if d &       0xf0: d >>= 4; mul += 4\\n        if d &        0xc: d >>= 2; mul += 2\\n        if d &          2: d >>= 1; mul += 1\\n        \\n        dec = (X << mul)-Y & (1 << mul)-1\\n        dec = (dec >> 1 & 0x55555555) + (dec & 0x55555555)\\n        dec = (dec >> 2 & 0x33333333) + (dec & 0x33333333)\\n        dec = (dec >> 4 & 0x0f0f0f0f) + (dec & 0x0f0f0f0f)\\n        dec = (dec >> 8 & 0x00ff00ff) + (dec & 0x00ff00ff)\\n        dec = (dec >>16 & 0x0000ffff) + (dec & 0x0000ffff)\\n        \\n        return mul + dec + ((X << mul)-Y >> mul)\\n```",
                "solutionTags": [
                    "Python",
                    "Greedy",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution:\\n    def brokenCalc(self, X: int, Y: int) -> int:\\n        count = 0\\n        while Y > X:\\n            if Y&1:\\n                Y += 1\\n                count += 1\\n            Y >>= 1\\n            count += 1\\n            \\n        return count + X-Y\\n```\n```\\nclass Solution:\\n    def brokenCalc(self, X: int, Y: int) -> int:\\n        d = (Y-1)//X; mul = bool(d)\\n        if d & 0xffff0000: d >>=16; mul +=16\\n        if d &     0xff00: d >>= 8; mul += 8\\n        if d &       0xf0: d >>= 4; mul += 4\\n        if d &        0xc: d >>= 2; mul += 2\\n        if d &          2: d >>= 1; mul += 1\\n        \\n        dec = (X << mul)-Y & (1 << mul)-1\\n        dec = (dec >> 1 & 0x55555555) + (dec & 0x55555555)\\n        dec = (dec >> 2 & 0x33333333) + (dec & 0x33333333)\\n        dec = (dec >> 4 & 0x0f0f0f0f) + (dec & 0x0f0f0f0f)\\n        dec = (dec >> 8 & 0x00ff00ff) + (dec & 0x00ff00ff)\\n        dec = (dec >>16 & 0x0000ffff) + (dec & 0x0000ffff)\\n        \\n        return mul + dec + ((X << mul)-Y >> mul)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1076585,
                "title": "java-one-liner-with-recursion-faster-than-100",
                "content": "Clearly, if X >= Y, subtraction is fastest.  Doubling will not improve the answer.\\nOtherwise, we want to end with multiplication by 2 (and if Y is odd, subtract 1).\\nTo solve recursively, we set an initial target value of Y, and successively calculate new targets equal to the previous target divided by 2 and rounded up (i.e. target = (target + 1) / 2, with integer division).\\nRepeat until X >= target, and then add the difference X - target, to cover the necessary subtractions.\\nFor example, suppose X = 3 and Y = 10.\\nStep 1: (X = 3, Y = 10)\\n     Y is even, so we want to end with multiplication by 2 (one operation).\\nStep 2: (X = 3, Y = (10+1) / 2 = 5)\\n     Y is odd, so we want to end with multiplication by 2 and then subtraction (two operations).\\nStep 3: (X = 3, Y = (5+1) / 2 = 3)\\n     X = Y, so we do not need any more operations.\\nSolution is 1 + 2 + 0 = 3 operations.\\n```\\nclass Solution {\\n    public int brokenCalc(int X, int Y) {\\n        if (X >= Y) return X - Y; else return 1 + (Y % 2) + brokenCalc(X, (Y + 1) / 2);\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public int brokenCalc(int X, int Y) {\\n        if (X >= Y) return X - Y; else return 1 + (Y % 2) + brokenCalc(X, (Y + 1) / 2);\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 1076371,
                "title": "python-backwards",
                "content": "There\\'s another problem on leetcode where you have to do the reverse (go back from Y to X) and it is actually the way to go, because deciding whether to subtract one from X or double its value is much harder. I couldn\\'t come up with a proper solution it in reasonable time, but check Lee\\'s answer he has provided one.\\n```\\ndef brokenCalc(self, X: int, Y: int) -> int:\\n\\tops = 0\\n\\twhile Y > X:\\n\\t\\tif Y & 1: Y += 1\\n\\t\\telse: Y //= 2\\n\\t\\tops += 1\\n\\treturn ops + X - Y\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\ndef brokenCalc(self, X: int, Y: int) -> int:\\n\\tops = 0\\n\\twhile Y > X:\\n\\t\\tif Y & 1: Y += 1\\n\\t\\telse: Y //= 2\\n\\t\\tops += 1\\n\\treturn ops + X - Y\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1076232,
                "title": "python-24ms-beats-96-68",
                "content": "```\\nclass Solution:\\n    def brokenCalc(self, X: int, Y: int) -> int:\\n        if Y<X:\\n            return X-Y\\n        elif Y==X:\\n            return 0\\n        elif Y%2==0:\\n            Y//=2\\n        else:\\n            Y+=1\\n        return 1 + self.brokenCalc(X, Y)\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def brokenCalc(self, X: int, Y: int) -> int:\\n        if Y<X:\\n            return X-Y\\n        elif Y==X:\\n            return 0\\n        elif Y%2==0:\\n            Y//=2\\n        else:\\n            Y+=1\\n        return 1 + self.brokenCalc(X, Y)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1076194,
                "title": "broken-calculator-c-0ms",
                "content": "```\\nclass Solution {\\npublic:\\n    int brokenCalc(int X, int Y) {\\n        int steps = 0;\\n        while (Y > X) {\\n            Y = Y%2 ? Y+1 : Y/2;\\n            steps++;\\n        }\\n        steps += X - Y;\\n        return steps;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int brokenCalc(int X, int Y) {\\n        int steps = 0;\\n        while (Y > X) {\\n            Y = Y%2 ? Y+1 : Y/2;\\n            steps++;\\n        }\\n        steps += X - Y;\\n        return steps;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1076180,
                "title": "python-forward-solution-toss-and-divide",
                "content": "Thanks to https://leetcode.com/problems/broken-calculator/discuss/308539/Thinking-Forward\\n\\n```\\n    def brokenCalc(self, X, Y):\\n        \"\"\"\\n        :type X: int\\n        :type Y: int\\n        :rtype: int\\n        \"\"\"\\n        if X >= Y:\\n            return X - Y\\n\\n        count = 0\\n        # multiply 2 until X is greater than Y\\n        while X < Y:\\n            X *= 2\\n            count += 1\\n        # Currently, the result is count+left, which might not be optimal\\n        # Calculate when should we decrement 1 to save cost using toss and divide\\n        left = X - Y\\n        power = count\\n        while left > 0:\\n            # if left // 2 ** power > 0, this means we should minus left//2**power before multiply 2 at that level\\n            count += left // 2 ** power\\n            left %= 2 ** power\\n            power -= 1\\n        return count\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\n    def brokenCalc(self, X, Y):\\n        \"\"\"\\n        :type X: int\\n        :type Y: int\\n        :rtype: int\\n        \"\"\"\\n        if X >= Y:\\n            return X - Y\\n\\n        count = 0\\n        # multiply 2 until X is greater than Y\\n        while X < Y:\\n            X *= 2\\n            count += 1\\n        # Currently, the result is count+left, which might not be optimal\\n        # Calculate when should we decrement 1 to save cost using toss and divide\\n        left = X - Y\\n        power = count\\n        while left > 0:\\n            # if left // 2 ** power > 0, this means we should minus left//2**power before multiply 2 at that level\\n            count += left // 2 ** power\\n            left %= 2 ** power\\n            power -= 1\\n        return count\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1076101,
                "title": "broken-calculator-greedy-python3",
                "content": "\\n```\\n\\t\\tif X == Y: return 0\\n        if X > Y: return X - Y\\n        ans = 0\\n        # Divide Y by 2 until it smaller than double of X\\n        while Y > X * 2:\\n            ans += Y % 2 + 1\\n            Y = Y / 2 if Y % 2 == 0 else (Y + 1) / 2 \\n        \\n        # Subtract 1 from X until X * 2 - Y == 0 or X * 2 - Y == 1\\n        if X * 2 - Y > 1:\\n            ans += (X * 2 - Y) // 2\\n            X -= (X * 2 - Y) // 2\\n            \\n        # Until now there are only 2 cases:\\n        # X * 2 - Y == 0: ==> Only 1 steps left: X *= 2\\n        # X * 2 - Y == 1: ==> Only 2 steps left: X *= 2 then X -= 1\\n        ans += int((X * 2) % Y + 1)\\n        return ans\\n```",
                "solutionTags": [
                    "Python",
                    "Greedy"
                ],
                "code": "```\\n\\t\\tif X == Y: return 0\\n        if X > Y: return X - Y\\n        ans = 0\\n        # Divide Y by 2 until it smaller than double of X\\n        while Y > X * 2:\\n            ans += Y % 2 + 1\\n            Y = Y / 2 if Y % 2 == 0 else (Y + 1) / 2 \\n        \\n        # Subtract 1 from X until X * 2 - Y == 0 or X * 2 - Y == 1\\n        if X * 2 - Y > 1:\\n            ans += (X * 2 - Y) // 2\\n            X -= (X * 2 - Y) // 2\\n            \\n        # Until now there are only 2 cases:\\n        # X * 2 - Y == 0: ==> Only 1 steps left: X *= 2\\n        # X * 2 - Y == 1: ==> Only 2 steps left: X *= 2 then X -= 1\\n        ans += int((X * 2) % Y + 1)\\n        return ans\\n```",
                "codeTag": "Unknown"
            }
        ],
        "discussions": [
            {
                "id": 1565214,
                "content": [
                    {
                        "username": "fabregas2messi",
                        "content": "Hi guys,\\n\\nMy first intution for solving this problem was converting from X to Y, I ended up getting TLE or wrong answers. Most of the answers here I see have converting from Y to X. I dont understand how everyone got same intuition but me. Is there a chance that everyone is supermans here or you guys read top voted answers before designing your solution?"
                    },
                    {
                        "username": "RomaFed",
                        "content": "same question.. and if am not wrong, task says we should mutate start value, not target"
                    },
                    {
                        "username": "betaminc",
                        "content": "HAHAHHAHA"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for March, Day 23.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/broken-calculator/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Work Backwards\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "arghya",
                        "content": "My initial intitution was to update value of X to bring it closer to Y. \\n\\nI don\\'t understand what made you guys think of the \"work backward\" solution. What was the intituion behind modifying Y?\\nI am not asking for the solution here. Thanks"
                    },
                    {
                        "username": "krishnachanduakula",
                        "content": "I thought this is a DP question  and  i spanned two trees one with X-1 and other with X*2 \\nand return the minimum of both ,which reached Y fast. When  But i failed to understand its \\na greedy. How to decide if it is a greedy or DP?"
                    },
                    {
                        "username": "Charlemagne5t",
                        "content": "1 <= startValue, target <= 10^9 constraint screams it is not DP. But I\\'ve seen a problem that had such a constraint and had to be solved using DP with some trick."
                    },
                    {
                        "username": "Khwaja_Abdul_Samad",
                        "content": "in the DP approach when it will go with case -1 , it will create endless loop of only substracting one from itself as it will be moving away from target so DP is not a good option"
                    },
                    {
                        "username": "Gangeswaran",
                        "content": "I tried BFS approach starting from root, picked element from queue, performed multiply and subtract, push new value to queue.\\nRepeated the process till we reach target value, While pushing new element to queue keep updating steps count.\\n\\nBut ended up with TLE for worst case startValue=1, target=10000000\\n\\nSo BFS won\\'t work here.. Though its actually to find out shortest route from source to target."
                    },
                    {
                        "username": "glock17",
                        "content": "A lot of people are having trouble getting their heads around why are we moving from target to startValue.\nSo here I try to tell you the way I got to the solution.\n\n1. Multiplication is an independent operation irrespective of whether a number is even or odd, so it is a possibility that multiplication by 2 would overshoot our target by a large value and then to tone it down we would have to apply a large number of subtraction operations(as for this case only subtraction would be possible) to reach the target, which is an overkill.\n2. So the greedy approach aims at dividing the number by 2 only when it is possible, which was not the case with multiplication as we could have multiplied at any instance of time. As the target becomes less than the startValue then we simply do addition operations to reach the target value.\n\nHope it makes things clearer.\n\nMy python3 Solution:\nhttps://leetcode.com/problems/broken-calculator/solutions/3096648/python3-intuition-best-explanation-on-leetcode/"
                    },
                    {
                        "username": "crabbyD",
                        "content": "everyone in the discussion is having the same code in which they are changing the value of target and not the value of start.\\ncan anyone explain why everyone is doing so..."
                    },
                    {
                        "username": "Mars_Congressional_Republic",
                        "content": "I started off in that way and got stuck for a while. I guess the realization that made me switch is that you can only divide by 2 for even numbers, but multiplying by 2, you can do that for even or odd numbers so going backward seems more restricted than going forward."
                    },
                    {
                        "username": "livelearn",
                        "content": "Did other languages face the same time restrictions, felt like this was really tight."
                    },
                    {
                        "username": "bupt_wc",
                        "content": "https://buptwc.com/2019/02/10/Leetcode-991-Broken-Calculator/\\nHope helpful!"
                    },
                    {
                        "username": "phalkey89",
                        "content": "Question no \"991\"  is itself a series of calc being sold world wide.\\nlol !!"
                    }
                ]
            },
            {
                "id": 1567112,
                "content": [
                    {
                        "username": "fabregas2messi",
                        "content": "Hi guys,\\n\\nMy first intution for solving this problem was converting from X to Y, I ended up getting TLE or wrong answers. Most of the answers here I see have converting from Y to X. I dont understand how everyone got same intuition but me. Is there a chance that everyone is supermans here or you guys read top voted answers before designing your solution?"
                    },
                    {
                        "username": "RomaFed",
                        "content": "same question.. and if am not wrong, task says we should mutate start value, not target"
                    },
                    {
                        "username": "betaminc",
                        "content": "HAHAHHAHA"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for March, Day 23.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/broken-calculator/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Work Backwards\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "arghya",
                        "content": "My initial intitution was to update value of X to bring it closer to Y. \\n\\nI don\\'t understand what made you guys think of the \"work backward\" solution. What was the intituion behind modifying Y?\\nI am not asking for the solution here. Thanks"
                    },
                    {
                        "username": "krishnachanduakula",
                        "content": "I thought this is a DP question  and  i spanned two trees one with X-1 and other with X*2 \\nand return the minimum of both ,which reached Y fast. When  But i failed to understand its \\na greedy. How to decide if it is a greedy or DP?"
                    },
                    {
                        "username": "Charlemagne5t",
                        "content": "1 <= startValue, target <= 10^9 constraint screams it is not DP. But I\\'ve seen a problem that had such a constraint and had to be solved using DP with some trick."
                    },
                    {
                        "username": "Khwaja_Abdul_Samad",
                        "content": "in the DP approach when it will go with case -1 , it will create endless loop of only substracting one from itself as it will be moving away from target so DP is not a good option"
                    },
                    {
                        "username": "Gangeswaran",
                        "content": "I tried BFS approach starting from root, picked element from queue, performed multiply and subtract, push new value to queue.\\nRepeated the process till we reach target value, While pushing new element to queue keep updating steps count.\\n\\nBut ended up with TLE for worst case startValue=1, target=10000000\\n\\nSo BFS won\\'t work here.. Though its actually to find out shortest route from source to target."
                    },
                    {
                        "username": "glock17",
                        "content": "A lot of people are having trouble getting their heads around why are we moving from target to startValue.\nSo here I try to tell you the way I got to the solution.\n\n1. Multiplication is an independent operation irrespective of whether a number is even or odd, so it is a possibility that multiplication by 2 would overshoot our target by a large value and then to tone it down we would have to apply a large number of subtraction operations(as for this case only subtraction would be possible) to reach the target, which is an overkill.\n2. So the greedy approach aims at dividing the number by 2 only when it is possible, which was not the case with multiplication as we could have multiplied at any instance of time. As the target becomes less than the startValue then we simply do addition operations to reach the target value.\n\nHope it makes things clearer.\n\nMy python3 Solution:\nhttps://leetcode.com/problems/broken-calculator/solutions/3096648/python3-intuition-best-explanation-on-leetcode/"
                    },
                    {
                        "username": "crabbyD",
                        "content": "everyone in the discussion is having the same code in which they are changing the value of target and not the value of start.\\ncan anyone explain why everyone is doing so..."
                    },
                    {
                        "username": "Mars_Congressional_Republic",
                        "content": "I started off in that way and got stuck for a while. I guess the realization that made me switch is that you can only divide by 2 for even numbers, but multiplying by 2, you can do that for even or odd numbers so going backward seems more restricted than going forward."
                    },
                    {
                        "username": "livelearn",
                        "content": "Did other languages face the same time restrictions, felt like this was really tight."
                    },
                    {
                        "username": "bupt_wc",
                        "content": "https://buptwc.com/2019/02/10/Leetcode-991-Broken-Calculator/\\nHope helpful!"
                    },
                    {
                        "username": "phalkey89",
                        "content": "Question no \"991\"  is itself a series of calc being sold world wide.\\nlol !!"
                    }
                ]
            },
            {
                "id": 1565985,
                "content": [
                    {
                        "username": "fabregas2messi",
                        "content": "Hi guys,\\n\\nMy first intution for solving this problem was converting from X to Y, I ended up getting TLE or wrong answers. Most of the answers here I see have converting from Y to X. I dont understand how everyone got same intuition but me. Is there a chance that everyone is supermans here or you guys read top voted answers before designing your solution?"
                    },
                    {
                        "username": "RomaFed",
                        "content": "same question.. and if am not wrong, task says we should mutate start value, not target"
                    },
                    {
                        "username": "betaminc",
                        "content": "HAHAHHAHA"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for March, Day 23.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/broken-calculator/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Work Backwards\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "arghya",
                        "content": "My initial intitution was to update value of X to bring it closer to Y. \\n\\nI don\\'t understand what made you guys think of the \"work backward\" solution. What was the intituion behind modifying Y?\\nI am not asking for the solution here. Thanks"
                    },
                    {
                        "username": "krishnachanduakula",
                        "content": "I thought this is a DP question  and  i spanned two trees one with X-1 and other with X*2 \\nand return the minimum of both ,which reached Y fast. When  But i failed to understand its \\na greedy. How to decide if it is a greedy or DP?"
                    },
                    {
                        "username": "Charlemagne5t",
                        "content": "1 <= startValue, target <= 10^9 constraint screams it is not DP. But I\\'ve seen a problem that had such a constraint and had to be solved using DP with some trick."
                    },
                    {
                        "username": "Khwaja_Abdul_Samad",
                        "content": "in the DP approach when it will go with case -1 , it will create endless loop of only substracting one from itself as it will be moving away from target so DP is not a good option"
                    },
                    {
                        "username": "Gangeswaran",
                        "content": "I tried BFS approach starting from root, picked element from queue, performed multiply and subtract, push new value to queue.\\nRepeated the process till we reach target value, While pushing new element to queue keep updating steps count.\\n\\nBut ended up with TLE for worst case startValue=1, target=10000000\\n\\nSo BFS won\\'t work here.. Though its actually to find out shortest route from source to target."
                    },
                    {
                        "username": "glock17",
                        "content": "A lot of people are having trouble getting their heads around why are we moving from target to startValue.\nSo here I try to tell you the way I got to the solution.\n\n1. Multiplication is an independent operation irrespective of whether a number is even or odd, so it is a possibility that multiplication by 2 would overshoot our target by a large value and then to tone it down we would have to apply a large number of subtraction operations(as for this case only subtraction would be possible) to reach the target, which is an overkill.\n2. So the greedy approach aims at dividing the number by 2 only when it is possible, which was not the case with multiplication as we could have multiplied at any instance of time. As the target becomes less than the startValue then we simply do addition operations to reach the target value.\n\nHope it makes things clearer.\n\nMy python3 Solution:\nhttps://leetcode.com/problems/broken-calculator/solutions/3096648/python3-intuition-best-explanation-on-leetcode/"
                    },
                    {
                        "username": "crabbyD",
                        "content": "everyone in the discussion is having the same code in which they are changing the value of target and not the value of start.\\ncan anyone explain why everyone is doing so..."
                    },
                    {
                        "username": "Mars_Congressional_Republic",
                        "content": "I started off in that way and got stuck for a while. I guess the realization that made me switch is that you can only divide by 2 for even numbers, but multiplying by 2, you can do that for even or odd numbers so going backward seems more restricted than going forward."
                    },
                    {
                        "username": "livelearn",
                        "content": "Did other languages face the same time restrictions, felt like this was really tight."
                    },
                    {
                        "username": "bupt_wc",
                        "content": "https://buptwc.com/2019/02/10/Leetcode-991-Broken-Calculator/\\nHope helpful!"
                    },
                    {
                        "username": "phalkey89",
                        "content": "Question no \"991\"  is itself a series of calc being sold world wide.\\nlol !!"
                    }
                ]
            },
            {
                "id": 1567438,
                "content": [
                    {
                        "username": "fabregas2messi",
                        "content": "Hi guys,\\n\\nMy first intution for solving this problem was converting from X to Y, I ended up getting TLE or wrong answers. Most of the answers here I see have converting from Y to X. I dont understand how everyone got same intuition but me. Is there a chance that everyone is supermans here or you guys read top voted answers before designing your solution?"
                    },
                    {
                        "username": "RomaFed",
                        "content": "same question.. and if am not wrong, task says we should mutate start value, not target"
                    },
                    {
                        "username": "betaminc",
                        "content": "HAHAHHAHA"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for March, Day 23.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/broken-calculator/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Work Backwards\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "arghya",
                        "content": "My initial intitution was to update value of X to bring it closer to Y. \\n\\nI don\\'t understand what made you guys think of the \"work backward\" solution. What was the intituion behind modifying Y?\\nI am not asking for the solution here. Thanks"
                    },
                    {
                        "username": "krishnachanduakula",
                        "content": "I thought this is a DP question  and  i spanned two trees one with X-1 and other with X*2 \\nand return the minimum of both ,which reached Y fast. When  But i failed to understand its \\na greedy. How to decide if it is a greedy or DP?"
                    },
                    {
                        "username": "Charlemagne5t",
                        "content": "1 <= startValue, target <= 10^9 constraint screams it is not DP. But I\\'ve seen a problem that had such a constraint and had to be solved using DP with some trick."
                    },
                    {
                        "username": "Khwaja_Abdul_Samad",
                        "content": "in the DP approach when it will go with case -1 , it will create endless loop of only substracting one from itself as it will be moving away from target so DP is not a good option"
                    },
                    {
                        "username": "Gangeswaran",
                        "content": "I tried BFS approach starting from root, picked element from queue, performed multiply and subtract, push new value to queue.\\nRepeated the process till we reach target value, While pushing new element to queue keep updating steps count.\\n\\nBut ended up with TLE for worst case startValue=1, target=10000000\\n\\nSo BFS won\\'t work here.. Though its actually to find out shortest route from source to target."
                    },
                    {
                        "username": "glock17",
                        "content": "A lot of people are having trouble getting their heads around why are we moving from target to startValue.\nSo here I try to tell you the way I got to the solution.\n\n1. Multiplication is an independent operation irrespective of whether a number is even or odd, so it is a possibility that multiplication by 2 would overshoot our target by a large value and then to tone it down we would have to apply a large number of subtraction operations(as for this case only subtraction would be possible) to reach the target, which is an overkill.\n2. So the greedy approach aims at dividing the number by 2 only when it is possible, which was not the case with multiplication as we could have multiplied at any instance of time. As the target becomes less than the startValue then we simply do addition operations to reach the target value.\n\nHope it makes things clearer.\n\nMy python3 Solution:\nhttps://leetcode.com/problems/broken-calculator/solutions/3096648/python3-intuition-best-explanation-on-leetcode/"
                    },
                    {
                        "username": "crabbyD",
                        "content": "everyone in the discussion is having the same code in which they are changing the value of target and not the value of start.\\ncan anyone explain why everyone is doing so..."
                    },
                    {
                        "username": "Mars_Congressional_Republic",
                        "content": "I started off in that way and got stuck for a while. I guess the realization that made me switch is that you can only divide by 2 for even numbers, but multiplying by 2, you can do that for even or odd numbers so going backward seems more restricted than going forward."
                    },
                    {
                        "username": "livelearn",
                        "content": "Did other languages face the same time restrictions, felt like this was really tight."
                    },
                    {
                        "username": "bupt_wc",
                        "content": "https://buptwc.com/2019/02/10/Leetcode-991-Broken-Calculator/\\nHope helpful!"
                    },
                    {
                        "username": "phalkey89",
                        "content": "Question no \"991\"  is itself a series of calc being sold world wide.\\nlol !!"
                    }
                ]
            },
            {
                "id": 1828165,
                "content": [
                    {
                        "username": "fabregas2messi",
                        "content": "Hi guys,\\n\\nMy first intution for solving this problem was converting from X to Y, I ended up getting TLE or wrong answers. Most of the answers here I see have converting from Y to X. I dont understand how everyone got same intuition but me. Is there a chance that everyone is supermans here or you guys read top voted answers before designing your solution?"
                    },
                    {
                        "username": "RomaFed",
                        "content": "same question.. and if am not wrong, task says we should mutate start value, not target"
                    },
                    {
                        "username": "betaminc",
                        "content": "HAHAHHAHA"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for March, Day 23.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/broken-calculator/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Work Backwards\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "arghya",
                        "content": "My initial intitution was to update value of X to bring it closer to Y. \\n\\nI don\\'t understand what made you guys think of the \"work backward\" solution. What was the intituion behind modifying Y?\\nI am not asking for the solution here. Thanks"
                    },
                    {
                        "username": "krishnachanduakula",
                        "content": "I thought this is a DP question  and  i spanned two trees one with X-1 and other with X*2 \\nand return the minimum of both ,which reached Y fast. When  But i failed to understand its \\na greedy. How to decide if it is a greedy or DP?"
                    },
                    {
                        "username": "Charlemagne5t",
                        "content": "1 <= startValue, target <= 10^9 constraint screams it is not DP. But I\\'ve seen a problem that had such a constraint and had to be solved using DP with some trick."
                    },
                    {
                        "username": "Khwaja_Abdul_Samad",
                        "content": "in the DP approach when it will go with case -1 , it will create endless loop of only substracting one from itself as it will be moving away from target so DP is not a good option"
                    },
                    {
                        "username": "Gangeswaran",
                        "content": "I tried BFS approach starting from root, picked element from queue, performed multiply and subtract, push new value to queue.\\nRepeated the process till we reach target value, While pushing new element to queue keep updating steps count.\\n\\nBut ended up with TLE for worst case startValue=1, target=10000000\\n\\nSo BFS won\\'t work here.. Though its actually to find out shortest route from source to target."
                    },
                    {
                        "username": "glock17",
                        "content": "A lot of people are having trouble getting their heads around why are we moving from target to startValue.\nSo here I try to tell you the way I got to the solution.\n\n1. Multiplication is an independent operation irrespective of whether a number is even or odd, so it is a possibility that multiplication by 2 would overshoot our target by a large value and then to tone it down we would have to apply a large number of subtraction operations(as for this case only subtraction would be possible) to reach the target, which is an overkill.\n2. So the greedy approach aims at dividing the number by 2 only when it is possible, which was not the case with multiplication as we could have multiplied at any instance of time. As the target becomes less than the startValue then we simply do addition operations to reach the target value.\n\nHope it makes things clearer.\n\nMy python3 Solution:\nhttps://leetcode.com/problems/broken-calculator/solutions/3096648/python3-intuition-best-explanation-on-leetcode/"
                    },
                    {
                        "username": "crabbyD",
                        "content": "everyone in the discussion is having the same code in which they are changing the value of target and not the value of start.\\ncan anyone explain why everyone is doing so..."
                    },
                    {
                        "username": "Mars_Congressional_Republic",
                        "content": "I started off in that way and got stuck for a while. I guess the realization that made me switch is that you can only divide by 2 for even numbers, but multiplying by 2, you can do that for even or odd numbers so going backward seems more restricted than going forward."
                    },
                    {
                        "username": "livelearn",
                        "content": "Did other languages face the same time restrictions, felt like this was really tight."
                    },
                    {
                        "username": "bupt_wc",
                        "content": "https://buptwc.com/2019/02/10/Leetcode-991-Broken-Calculator/\\nHope helpful!"
                    },
                    {
                        "username": "phalkey89",
                        "content": "Question no \"991\"  is itself a series of calc being sold world wide.\\nlol !!"
                    }
                ]
            },
            {
                "id": 1773654,
                "content": [
                    {
                        "username": "fabregas2messi",
                        "content": "Hi guys,\\n\\nMy first intution for solving this problem was converting from X to Y, I ended up getting TLE or wrong answers. Most of the answers here I see have converting from Y to X. I dont understand how everyone got same intuition but me. Is there a chance that everyone is supermans here or you guys read top voted answers before designing your solution?"
                    },
                    {
                        "username": "RomaFed",
                        "content": "same question.. and if am not wrong, task says we should mutate start value, not target"
                    },
                    {
                        "username": "betaminc",
                        "content": "HAHAHHAHA"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for March, Day 23.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/broken-calculator/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Work Backwards\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "arghya",
                        "content": "My initial intitution was to update value of X to bring it closer to Y. \\n\\nI don\\'t understand what made you guys think of the \"work backward\" solution. What was the intituion behind modifying Y?\\nI am not asking for the solution here. Thanks"
                    },
                    {
                        "username": "krishnachanduakula",
                        "content": "I thought this is a DP question  and  i spanned two trees one with X-1 and other with X*2 \\nand return the minimum of both ,which reached Y fast. When  But i failed to understand its \\na greedy. How to decide if it is a greedy or DP?"
                    },
                    {
                        "username": "Charlemagne5t",
                        "content": "1 <= startValue, target <= 10^9 constraint screams it is not DP. But I\\'ve seen a problem that had such a constraint and had to be solved using DP with some trick."
                    },
                    {
                        "username": "Khwaja_Abdul_Samad",
                        "content": "in the DP approach when it will go with case -1 , it will create endless loop of only substracting one from itself as it will be moving away from target so DP is not a good option"
                    },
                    {
                        "username": "Gangeswaran",
                        "content": "I tried BFS approach starting from root, picked element from queue, performed multiply and subtract, push new value to queue.\\nRepeated the process till we reach target value, While pushing new element to queue keep updating steps count.\\n\\nBut ended up with TLE for worst case startValue=1, target=10000000\\n\\nSo BFS won\\'t work here.. Though its actually to find out shortest route from source to target."
                    },
                    {
                        "username": "glock17",
                        "content": "A lot of people are having trouble getting their heads around why are we moving from target to startValue.\nSo here I try to tell you the way I got to the solution.\n\n1. Multiplication is an independent operation irrespective of whether a number is even or odd, so it is a possibility that multiplication by 2 would overshoot our target by a large value and then to tone it down we would have to apply a large number of subtraction operations(as for this case only subtraction would be possible) to reach the target, which is an overkill.\n2. So the greedy approach aims at dividing the number by 2 only when it is possible, which was not the case with multiplication as we could have multiplied at any instance of time. As the target becomes less than the startValue then we simply do addition operations to reach the target value.\n\nHope it makes things clearer.\n\nMy python3 Solution:\nhttps://leetcode.com/problems/broken-calculator/solutions/3096648/python3-intuition-best-explanation-on-leetcode/"
                    },
                    {
                        "username": "crabbyD",
                        "content": "everyone in the discussion is having the same code in which they are changing the value of target and not the value of start.\\ncan anyone explain why everyone is doing so..."
                    },
                    {
                        "username": "Mars_Congressional_Republic",
                        "content": "I started off in that way and got stuck for a while. I guess the realization that made me switch is that you can only divide by 2 for even numbers, but multiplying by 2, you can do that for even or odd numbers so going backward seems more restricted than going forward."
                    },
                    {
                        "username": "livelearn",
                        "content": "Did other languages face the same time restrictions, felt like this was really tight."
                    },
                    {
                        "username": "bupt_wc",
                        "content": "https://buptwc.com/2019/02/10/Leetcode-991-Broken-Calculator/\\nHope helpful!"
                    },
                    {
                        "username": "phalkey89",
                        "content": "Question no \"991\"  is itself a series of calc being sold world wide.\\nlol !!"
                    }
                ]
            },
            {
                "id": 1570826,
                "content": [
                    {
                        "username": "fabregas2messi",
                        "content": "Hi guys,\\n\\nMy first intution for solving this problem was converting from X to Y, I ended up getting TLE or wrong answers. Most of the answers here I see have converting from Y to X. I dont understand how everyone got same intuition but me. Is there a chance that everyone is supermans here or you guys read top voted answers before designing your solution?"
                    },
                    {
                        "username": "RomaFed",
                        "content": "same question.. and if am not wrong, task says we should mutate start value, not target"
                    },
                    {
                        "username": "betaminc",
                        "content": "HAHAHHAHA"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for March, Day 23.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/broken-calculator/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Work Backwards\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "arghya",
                        "content": "My initial intitution was to update value of X to bring it closer to Y. \\n\\nI don\\'t understand what made you guys think of the \"work backward\" solution. What was the intituion behind modifying Y?\\nI am not asking for the solution here. Thanks"
                    },
                    {
                        "username": "krishnachanduakula",
                        "content": "I thought this is a DP question  and  i spanned two trees one with X-1 and other with X*2 \\nand return the minimum of both ,which reached Y fast. When  But i failed to understand its \\na greedy. How to decide if it is a greedy or DP?"
                    },
                    {
                        "username": "Charlemagne5t",
                        "content": "1 <= startValue, target <= 10^9 constraint screams it is not DP. But I\\'ve seen a problem that had such a constraint and had to be solved using DP with some trick."
                    },
                    {
                        "username": "Khwaja_Abdul_Samad",
                        "content": "in the DP approach when it will go with case -1 , it will create endless loop of only substracting one from itself as it will be moving away from target so DP is not a good option"
                    },
                    {
                        "username": "Gangeswaran",
                        "content": "I tried BFS approach starting from root, picked element from queue, performed multiply and subtract, push new value to queue.\\nRepeated the process till we reach target value, While pushing new element to queue keep updating steps count.\\n\\nBut ended up with TLE for worst case startValue=1, target=10000000\\n\\nSo BFS won\\'t work here.. Though its actually to find out shortest route from source to target."
                    },
                    {
                        "username": "glock17",
                        "content": "A lot of people are having trouble getting their heads around why are we moving from target to startValue.\nSo here I try to tell you the way I got to the solution.\n\n1. Multiplication is an independent operation irrespective of whether a number is even or odd, so it is a possibility that multiplication by 2 would overshoot our target by a large value and then to tone it down we would have to apply a large number of subtraction operations(as for this case only subtraction would be possible) to reach the target, which is an overkill.\n2. So the greedy approach aims at dividing the number by 2 only when it is possible, which was not the case with multiplication as we could have multiplied at any instance of time. As the target becomes less than the startValue then we simply do addition operations to reach the target value.\n\nHope it makes things clearer.\n\nMy python3 Solution:\nhttps://leetcode.com/problems/broken-calculator/solutions/3096648/python3-intuition-best-explanation-on-leetcode/"
                    },
                    {
                        "username": "crabbyD",
                        "content": "everyone in the discussion is having the same code in which they are changing the value of target and not the value of start.\\ncan anyone explain why everyone is doing so..."
                    },
                    {
                        "username": "Mars_Congressional_Republic",
                        "content": "I started off in that way and got stuck for a while. I guess the realization that made me switch is that you can only divide by 2 for even numbers, but multiplying by 2, you can do that for even or odd numbers so going backward seems more restricted than going forward."
                    },
                    {
                        "username": "livelearn",
                        "content": "Did other languages face the same time restrictions, felt like this was really tight."
                    },
                    {
                        "username": "bupt_wc",
                        "content": "https://buptwc.com/2019/02/10/Leetcode-991-Broken-Calculator/\\nHope helpful!"
                    },
                    {
                        "username": "phalkey89",
                        "content": "Question no \"991\"  is itself a series of calc being sold world wide.\\nlol !!"
                    }
                ]
            },
            {
                "id": 1567364,
                "content": [
                    {
                        "username": "fabregas2messi",
                        "content": "Hi guys,\\n\\nMy first intution for solving this problem was converting from X to Y, I ended up getting TLE or wrong answers. Most of the answers here I see have converting from Y to X. I dont understand how everyone got same intuition but me. Is there a chance that everyone is supermans here or you guys read top voted answers before designing your solution?"
                    },
                    {
                        "username": "RomaFed",
                        "content": "same question.. and if am not wrong, task says we should mutate start value, not target"
                    },
                    {
                        "username": "betaminc",
                        "content": "HAHAHHAHA"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for March, Day 23.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/broken-calculator/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Work Backwards\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "arghya",
                        "content": "My initial intitution was to update value of X to bring it closer to Y. \\n\\nI don\\'t understand what made you guys think of the \"work backward\" solution. What was the intituion behind modifying Y?\\nI am not asking for the solution here. Thanks"
                    },
                    {
                        "username": "krishnachanduakula",
                        "content": "I thought this is a DP question  and  i spanned two trees one with X-1 and other with X*2 \\nand return the minimum of both ,which reached Y fast. When  But i failed to understand its \\na greedy. How to decide if it is a greedy or DP?"
                    },
                    {
                        "username": "Charlemagne5t",
                        "content": "1 <= startValue, target <= 10^9 constraint screams it is not DP. But I\\'ve seen a problem that had such a constraint and had to be solved using DP with some trick."
                    },
                    {
                        "username": "Khwaja_Abdul_Samad",
                        "content": "in the DP approach when it will go with case -1 , it will create endless loop of only substracting one from itself as it will be moving away from target so DP is not a good option"
                    },
                    {
                        "username": "Gangeswaran",
                        "content": "I tried BFS approach starting from root, picked element from queue, performed multiply and subtract, push new value to queue.\\nRepeated the process till we reach target value, While pushing new element to queue keep updating steps count.\\n\\nBut ended up with TLE for worst case startValue=1, target=10000000\\n\\nSo BFS won\\'t work here.. Though its actually to find out shortest route from source to target."
                    },
                    {
                        "username": "glock17",
                        "content": "A lot of people are having trouble getting their heads around why are we moving from target to startValue.\nSo here I try to tell you the way I got to the solution.\n\n1. Multiplication is an independent operation irrespective of whether a number is even or odd, so it is a possibility that multiplication by 2 would overshoot our target by a large value and then to tone it down we would have to apply a large number of subtraction operations(as for this case only subtraction would be possible) to reach the target, which is an overkill.\n2. So the greedy approach aims at dividing the number by 2 only when it is possible, which was not the case with multiplication as we could have multiplied at any instance of time. As the target becomes less than the startValue then we simply do addition operations to reach the target value.\n\nHope it makes things clearer.\n\nMy python3 Solution:\nhttps://leetcode.com/problems/broken-calculator/solutions/3096648/python3-intuition-best-explanation-on-leetcode/"
                    },
                    {
                        "username": "crabbyD",
                        "content": "everyone in the discussion is having the same code in which they are changing the value of target and not the value of start.\\ncan anyone explain why everyone is doing so..."
                    },
                    {
                        "username": "Mars_Congressional_Republic",
                        "content": "I started off in that way and got stuck for a while. I guess the realization that made me switch is that you can only divide by 2 for even numbers, but multiplying by 2, you can do that for even or odd numbers so going backward seems more restricted than going forward."
                    },
                    {
                        "username": "livelearn",
                        "content": "Did other languages face the same time restrictions, felt like this was really tight."
                    },
                    {
                        "username": "bupt_wc",
                        "content": "https://buptwc.com/2019/02/10/Leetcode-991-Broken-Calculator/\\nHope helpful!"
                    },
                    {
                        "username": "phalkey89",
                        "content": "Question no \"991\"  is itself a series of calc being sold world wide.\\nlol !!"
                    }
                ]
            },
            {
                "id": 1566853,
                "content": [
                    {
                        "username": "fabregas2messi",
                        "content": "Hi guys,\\n\\nMy first intution for solving this problem was converting from X to Y, I ended up getting TLE or wrong answers. Most of the answers here I see have converting from Y to X. I dont understand how everyone got same intuition but me. Is there a chance that everyone is supermans here or you guys read top voted answers before designing your solution?"
                    },
                    {
                        "username": "RomaFed",
                        "content": "same question.. and if am not wrong, task says we should mutate start value, not target"
                    },
                    {
                        "username": "betaminc",
                        "content": "HAHAHHAHA"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for March, Day 23.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/broken-calculator/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Work Backwards\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "arghya",
                        "content": "My initial intitution was to update value of X to bring it closer to Y. \\n\\nI don\\'t understand what made you guys think of the \"work backward\" solution. What was the intituion behind modifying Y?\\nI am not asking for the solution here. Thanks"
                    },
                    {
                        "username": "krishnachanduakula",
                        "content": "I thought this is a DP question  and  i spanned two trees one with X-1 and other with X*2 \\nand return the minimum of both ,which reached Y fast. When  But i failed to understand its \\na greedy. How to decide if it is a greedy or DP?"
                    },
                    {
                        "username": "Charlemagne5t",
                        "content": "1 <= startValue, target <= 10^9 constraint screams it is not DP. But I\\'ve seen a problem that had such a constraint and had to be solved using DP with some trick."
                    },
                    {
                        "username": "Khwaja_Abdul_Samad",
                        "content": "in the DP approach when it will go with case -1 , it will create endless loop of only substracting one from itself as it will be moving away from target so DP is not a good option"
                    },
                    {
                        "username": "Gangeswaran",
                        "content": "I tried BFS approach starting from root, picked element from queue, performed multiply and subtract, push new value to queue.\\nRepeated the process till we reach target value, While pushing new element to queue keep updating steps count.\\n\\nBut ended up with TLE for worst case startValue=1, target=10000000\\n\\nSo BFS won\\'t work here.. Though its actually to find out shortest route from source to target."
                    },
                    {
                        "username": "glock17",
                        "content": "A lot of people are having trouble getting their heads around why are we moving from target to startValue.\nSo here I try to tell you the way I got to the solution.\n\n1. Multiplication is an independent operation irrespective of whether a number is even or odd, so it is a possibility that multiplication by 2 would overshoot our target by a large value and then to tone it down we would have to apply a large number of subtraction operations(as for this case only subtraction would be possible) to reach the target, which is an overkill.\n2. So the greedy approach aims at dividing the number by 2 only when it is possible, which was not the case with multiplication as we could have multiplied at any instance of time. As the target becomes less than the startValue then we simply do addition operations to reach the target value.\n\nHope it makes things clearer.\n\nMy python3 Solution:\nhttps://leetcode.com/problems/broken-calculator/solutions/3096648/python3-intuition-best-explanation-on-leetcode/"
                    },
                    {
                        "username": "crabbyD",
                        "content": "everyone in the discussion is having the same code in which they are changing the value of target and not the value of start.\\ncan anyone explain why everyone is doing so..."
                    },
                    {
                        "username": "Mars_Congressional_Republic",
                        "content": "I started off in that way and got stuck for a while. I guess the realization that made me switch is that you can only divide by 2 for even numbers, but multiplying by 2, you can do that for even or odd numbers so going backward seems more restricted than going forward."
                    },
                    {
                        "username": "livelearn",
                        "content": "Did other languages face the same time restrictions, felt like this was really tight."
                    },
                    {
                        "username": "bupt_wc",
                        "content": "https://buptwc.com/2019/02/10/Leetcode-991-Broken-Calculator/\\nHope helpful!"
                    },
                    {
                        "username": "phalkey89",
                        "content": "Question no \"991\"  is itself a series of calc being sold world wide.\\nlol !!"
                    }
                ]
            },
            {
                "id": 1983290,
                "content": [
                    {
                        "username": "fabregas2messi",
                        "content": "Hi guys,\\n\\nMy first intution for solving this problem was converting from X to Y, I ended up getting TLE or wrong answers. Most of the answers here I see have converting from Y to X. I dont understand how everyone got same intuition but me. Is there a chance that everyone is supermans here or you guys read top voted answers before designing your solution?"
                    },
                    {
                        "username": "RomaFed",
                        "content": "same question.. and if am not wrong, task says we should mutate start value, not target"
                    },
                    {
                        "username": "betaminc",
                        "content": "HAHAHHAHA"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for March, Day 23.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/broken-calculator/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Work Backwards\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "arghya",
                        "content": "My initial intitution was to update value of X to bring it closer to Y. \\n\\nI don\\'t understand what made you guys think of the \"work backward\" solution. What was the intituion behind modifying Y?\\nI am not asking for the solution here. Thanks"
                    },
                    {
                        "username": "krishnachanduakula",
                        "content": "I thought this is a DP question  and  i spanned two trees one with X-1 and other with X*2 \\nand return the minimum of both ,which reached Y fast. When  But i failed to understand its \\na greedy. How to decide if it is a greedy or DP?"
                    },
                    {
                        "username": "Charlemagne5t",
                        "content": "1 <= startValue, target <= 10^9 constraint screams it is not DP. But I\\'ve seen a problem that had such a constraint and had to be solved using DP with some trick."
                    },
                    {
                        "username": "Khwaja_Abdul_Samad",
                        "content": "in the DP approach when it will go with case -1 , it will create endless loop of only substracting one from itself as it will be moving away from target so DP is not a good option"
                    },
                    {
                        "username": "Gangeswaran",
                        "content": "I tried BFS approach starting from root, picked element from queue, performed multiply and subtract, push new value to queue.\\nRepeated the process till we reach target value, While pushing new element to queue keep updating steps count.\\n\\nBut ended up with TLE for worst case startValue=1, target=10000000\\n\\nSo BFS won\\'t work here.. Though its actually to find out shortest route from source to target."
                    },
                    {
                        "username": "glock17",
                        "content": "A lot of people are having trouble getting their heads around why are we moving from target to startValue.\nSo here I try to tell you the way I got to the solution.\n\n1. Multiplication is an independent operation irrespective of whether a number is even or odd, so it is a possibility that multiplication by 2 would overshoot our target by a large value and then to tone it down we would have to apply a large number of subtraction operations(as for this case only subtraction would be possible) to reach the target, which is an overkill.\n2. So the greedy approach aims at dividing the number by 2 only when it is possible, which was not the case with multiplication as we could have multiplied at any instance of time. As the target becomes less than the startValue then we simply do addition operations to reach the target value.\n\nHope it makes things clearer.\n\nMy python3 Solution:\nhttps://leetcode.com/problems/broken-calculator/solutions/3096648/python3-intuition-best-explanation-on-leetcode/"
                    },
                    {
                        "username": "crabbyD",
                        "content": "everyone in the discussion is having the same code in which they are changing the value of target and not the value of start.\\ncan anyone explain why everyone is doing so..."
                    },
                    {
                        "username": "Mars_Congressional_Republic",
                        "content": "I started off in that way and got stuck for a while. I guess the realization that made me switch is that you can only divide by 2 for even numbers, but multiplying by 2, you can do that for even or odd numbers so going backward seems more restricted than going forward."
                    },
                    {
                        "username": "livelearn",
                        "content": "Did other languages face the same time restrictions, felt like this was really tight."
                    },
                    {
                        "username": "bupt_wc",
                        "content": "https://buptwc.com/2019/02/10/Leetcode-991-Broken-Calculator/\\nHope helpful!"
                    },
                    {
                        "username": "phalkey89",
                        "content": "Question no \"991\"  is itself a series of calc being sold world wide.\\nlol !!"
                    }
                ]
            },
            {
                "id": 1565214,
                "content": [
                    {
                        "username": "fabregas2messi",
                        "content": "Hi guys,\\n\\nMy first intution for solving this problem was converting from X to Y, I ended up getting TLE or wrong answers. Most of the answers here I see have converting from Y to X. I dont understand how everyone got same intuition but me. Is there a chance that everyone is supermans here or you guys read top voted answers before designing your solution?"
                    },
                    {
                        "username": "RomaFed",
                        "content": "same question.. and if am not wrong, task says we should mutate start value, not target"
                    },
                    {
                        "username": "betaminc",
                        "content": "HAHAHHAHA"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for March, Day 23.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/broken-calculator/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Work Backwards\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "arghya",
                        "content": "My initial intitution was to update value of X to bring it closer to Y. \\n\\nI don\\'t understand what made you guys think of the \"work backward\" solution. What was the intituion behind modifying Y?\\nI am not asking for the solution here. Thanks"
                    },
                    {
                        "username": "krishnachanduakula",
                        "content": "I thought this is a DP question  and  i spanned two trees one with X-1 and other with X*2 \\nand return the minimum of both ,which reached Y fast. When  But i failed to understand its \\na greedy. How to decide if it is a greedy or DP?"
                    },
                    {
                        "username": "Charlemagne5t",
                        "content": "1 <= startValue, target <= 10^9 constraint screams it is not DP. But I\\'ve seen a problem that had such a constraint and had to be solved using DP with some trick."
                    },
                    {
                        "username": "Khwaja_Abdul_Samad",
                        "content": "in the DP approach when it will go with case -1 , it will create endless loop of only substracting one from itself as it will be moving away from target so DP is not a good option"
                    },
                    {
                        "username": "Gangeswaran",
                        "content": "I tried BFS approach starting from root, picked element from queue, performed multiply and subtract, push new value to queue.\\nRepeated the process till we reach target value, While pushing new element to queue keep updating steps count.\\n\\nBut ended up with TLE for worst case startValue=1, target=10000000\\n\\nSo BFS won\\'t work here.. Though its actually to find out shortest route from source to target."
                    },
                    {
                        "username": "glock17",
                        "content": "A lot of people are having trouble getting their heads around why are we moving from target to startValue.\nSo here I try to tell you the way I got to the solution.\n\n1. Multiplication is an independent operation irrespective of whether a number is even or odd, so it is a possibility that multiplication by 2 would overshoot our target by a large value and then to tone it down we would have to apply a large number of subtraction operations(as for this case only subtraction would be possible) to reach the target, which is an overkill.\n2. So the greedy approach aims at dividing the number by 2 only when it is possible, which was not the case with multiplication as we could have multiplied at any instance of time. As the target becomes less than the startValue then we simply do addition operations to reach the target value.\n\nHope it makes things clearer.\n\nMy python3 Solution:\nhttps://leetcode.com/problems/broken-calculator/solutions/3096648/python3-intuition-best-explanation-on-leetcode/"
                    },
                    {
                        "username": "crabbyD",
                        "content": "everyone in the discussion is having the same code in which they are changing the value of target and not the value of start.\\ncan anyone explain why everyone is doing so..."
                    },
                    {
                        "username": "Mars_Congressional_Republic",
                        "content": "I started off in that way and got stuck for a while. I guess the realization that made me switch is that you can only divide by 2 for even numbers, but multiplying by 2, you can do that for even or odd numbers so going backward seems more restricted than going forward."
                    },
                    {
                        "username": "livelearn",
                        "content": "Did other languages face the same time restrictions, felt like this was really tight."
                    },
                    {
                        "username": "bupt_wc",
                        "content": "https://buptwc.com/2019/02/10/Leetcode-991-Broken-Calculator/\\nHope helpful!"
                    },
                    {
                        "username": "phalkey89",
                        "content": "Question no \"991\"  is itself a series of calc being sold world wide.\\nlol !!"
                    }
                ]
            },
            {
                "id": 1567112,
                "content": [
                    {
                        "username": "fabregas2messi",
                        "content": "Hi guys,\\n\\nMy first intution for solving this problem was converting from X to Y, I ended up getting TLE or wrong answers. Most of the answers here I see have converting from Y to X. I dont understand how everyone got same intuition but me. Is there a chance that everyone is supermans here or you guys read top voted answers before designing your solution?"
                    },
                    {
                        "username": "RomaFed",
                        "content": "same question.. and if am not wrong, task says we should mutate start value, not target"
                    },
                    {
                        "username": "betaminc",
                        "content": "HAHAHHAHA"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for March, Day 23.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/broken-calculator/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Work Backwards\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "arghya",
                        "content": "My initial intitution was to update value of X to bring it closer to Y. \\n\\nI don\\'t understand what made you guys think of the \"work backward\" solution. What was the intituion behind modifying Y?\\nI am not asking for the solution here. Thanks"
                    },
                    {
                        "username": "krishnachanduakula",
                        "content": "I thought this is a DP question  and  i spanned two trees one with X-1 and other with X*2 \\nand return the minimum of both ,which reached Y fast. When  But i failed to understand its \\na greedy. How to decide if it is a greedy or DP?"
                    },
                    {
                        "username": "Charlemagne5t",
                        "content": "1 <= startValue, target <= 10^9 constraint screams it is not DP. But I\\'ve seen a problem that had such a constraint and had to be solved using DP with some trick."
                    },
                    {
                        "username": "Khwaja_Abdul_Samad",
                        "content": "in the DP approach when it will go with case -1 , it will create endless loop of only substracting one from itself as it will be moving away from target so DP is not a good option"
                    },
                    {
                        "username": "Gangeswaran",
                        "content": "I tried BFS approach starting from root, picked element from queue, performed multiply and subtract, push new value to queue.\\nRepeated the process till we reach target value, While pushing new element to queue keep updating steps count.\\n\\nBut ended up with TLE for worst case startValue=1, target=10000000\\n\\nSo BFS won\\'t work here.. Though its actually to find out shortest route from source to target."
                    },
                    {
                        "username": "glock17",
                        "content": "A lot of people are having trouble getting their heads around why are we moving from target to startValue.\nSo here I try to tell you the way I got to the solution.\n\n1. Multiplication is an independent operation irrespective of whether a number is even or odd, so it is a possibility that multiplication by 2 would overshoot our target by a large value and then to tone it down we would have to apply a large number of subtraction operations(as for this case only subtraction would be possible) to reach the target, which is an overkill.\n2. So the greedy approach aims at dividing the number by 2 only when it is possible, which was not the case with multiplication as we could have multiplied at any instance of time. As the target becomes less than the startValue then we simply do addition operations to reach the target value.\n\nHope it makes things clearer.\n\nMy python3 Solution:\nhttps://leetcode.com/problems/broken-calculator/solutions/3096648/python3-intuition-best-explanation-on-leetcode/"
                    },
                    {
                        "username": "crabbyD",
                        "content": "everyone in the discussion is having the same code in which they are changing the value of target and not the value of start.\\ncan anyone explain why everyone is doing so..."
                    },
                    {
                        "username": "Mars_Congressional_Republic",
                        "content": "I started off in that way and got stuck for a while. I guess the realization that made me switch is that you can only divide by 2 for even numbers, but multiplying by 2, you can do that for even or odd numbers so going backward seems more restricted than going forward."
                    },
                    {
                        "username": "livelearn",
                        "content": "Did other languages face the same time restrictions, felt like this was really tight."
                    },
                    {
                        "username": "bupt_wc",
                        "content": "https://buptwc.com/2019/02/10/Leetcode-991-Broken-Calculator/\\nHope helpful!"
                    },
                    {
                        "username": "phalkey89",
                        "content": "Question no \"991\"  is itself a series of calc being sold world wide.\\nlol !!"
                    }
                ]
            },
            {
                "id": 1565985,
                "content": [
                    {
                        "username": "fabregas2messi",
                        "content": "Hi guys,\\n\\nMy first intution for solving this problem was converting from X to Y, I ended up getting TLE or wrong answers. Most of the answers here I see have converting from Y to X. I dont understand how everyone got same intuition but me. Is there a chance that everyone is supermans here or you guys read top voted answers before designing your solution?"
                    },
                    {
                        "username": "RomaFed",
                        "content": "same question.. and if am not wrong, task says we should mutate start value, not target"
                    },
                    {
                        "username": "betaminc",
                        "content": "HAHAHHAHA"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for March, Day 23.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/broken-calculator/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Work Backwards\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "arghya",
                        "content": "My initial intitution was to update value of X to bring it closer to Y. \\n\\nI don\\'t understand what made you guys think of the \"work backward\" solution. What was the intituion behind modifying Y?\\nI am not asking for the solution here. Thanks"
                    },
                    {
                        "username": "krishnachanduakula",
                        "content": "I thought this is a DP question  and  i spanned two trees one with X-1 and other with X*2 \\nand return the minimum of both ,which reached Y fast. When  But i failed to understand its \\na greedy. How to decide if it is a greedy or DP?"
                    },
                    {
                        "username": "Charlemagne5t",
                        "content": "1 <= startValue, target <= 10^9 constraint screams it is not DP. But I\\'ve seen a problem that had such a constraint and had to be solved using DP with some trick."
                    },
                    {
                        "username": "Khwaja_Abdul_Samad",
                        "content": "in the DP approach when it will go with case -1 , it will create endless loop of only substracting one from itself as it will be moving away from target so DP is not a good option"
                    },
                    {
                        "username": "Gangeswaran",
                        "content": "I tried BFS approach starting from root, picked element from queue, performed multiply and subtract, push new value to queue.\\nRepeated the process till we reach target value, While pushing new element to queue keep updating steps count.\\n\\nBut ended up with TLE for worst case startValue=1, target=10000000\\n\\nSo BFS won\\'t work here.. Though its actually to find out shortest route from source to target."
                    },
                    {
                        "username": "glock17",
                        "content": "A lot of people are having trouble getting their heads around why are we moving from target to startValue.\nSo here I try to tell you the way I got to the solution.\n\n1. Multiplication is an independent operation irrespective of whether a number is even or odd, so it is a possibility that multiplication by 2 would overshoot our target by a large value and then to tone it down we would have to apply a large number of subtraction operations(as for this case only subtraction would be possible) to reach the target, which is an overkill.\n2. So the greedy approach aims at dividing the number by 2 only when it is possible, which was not the case with multiplication as we could have multiplied at any instance of time. As the target becomes less than the startValue then we simply do addition operations to reach the target value.\n\nHope it makes things clearer.\n\nMy python3 Solution:\nhttps://leetcode.com/problems/broken-calculator/solutions/3096648/python3-intuition-best-explanation-on-leetcode/"
                    },
                    {
                        "username": "crabbyD",
                        "content": "everyone in the discussion is having the same code in which they are changing the value of target and not the value of start.\\ncan anyone explain why everyone is doing so..."
                    },
                    {
                        "username": "Mars_Congressional_Republic",
                        "content": "I started off in that way and got stuck for a while. I guess the realization that made me switch is that you can only divide by 2 for even numbers, but multiplying by 2, you can do that for even or odd numbers so going backward seems more restricted than going forward."
                    },
                    {
                        "username": "livelearn",
                        "content": "Did other languages face the same time restrictions, felt like this was really tight."
                    },
                    {
                        "username": "bupt_wc",
                        "content": "https://buptwc.com/2019/02/10/Leetcode-991-Broken-Calculator/\\nHope helpful!"
                    },
                    {
                        "username": "phalkey89",
                        "content": "Question no \"991\"  is itself a series of calc being sold world wide.\\nlol !!"
                    }
                ]
            },
            {
                "id": 1567438,
                "content": [
                    {
                        "username": "fabregas2messi",
                        "content": "Hi guys,\\n\\nMy first intution for solving this problem was converting from X to Y, I ended up getting TLE or wrong answers. Most of the answers here I see have converting from Y to X. I dont understand how everyone got same intuition but me. Is there a chance that everyone is supermans here or you guys read top voted answers before designing your solution?"
                    },
                    {
                        "username": "RomaFed",
                        "content": "same question.. and if am not wrong, task says we should mutate start value, not target"
                    },
                    {
                        "username": "betaminc",
                        "content": "HAHAHHAHA"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for March, Day 23.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/broken-calculator/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Work Backwards\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "arghya",
                        "content": "My initial intitution was to update value of X to bring it closer to Y. \\n\\nI don\\'t understand what made you guys think of the \"work backward\" solution. What was the intituion behind modifying Y?\\nI am not asking for the solution here. Thanks"
                    },
                    {
                        "username": "krishnachanduakula",
                        "content": "I thought this is a DP question  and  i spanned two trees one with X-1 and other with X*2 \\nand return the minimum of both ,which reached Y fast. When  But i failed to understand its \\na greedy. How to decide if it is a greedy or DP?"
                    },
                    {
                        "username": "Charlemagne5t",
                        "content": "1 <= startValue, target <= 10^9 constraint screams it is not DP. But I\\'ve seen a problem that had such a constraint and had to be solved using DP with some trick."
                    },
                    {
                        "username": "Khwaja_Abdul_Samad",
                        "content": "in the DP approach when it will go with case -1 , it will create endless loop of only substracting one from itself as it will be moving away from target so DP is not a good option"
                    },
                    {
                        "username": "Gangeswaran",
                        "content": "I tried BFS approach starting from root, picked element from queue, performed multiply and subtract, push new value to queue.\\nRepeated the process till we reach target value, While pushing new element to queue keep updating steps count.\\n\\nBut ended up with TLE for worst case startValue=1, target=10000000\\n\\nSo BFS won\\'t work here.. Though its actually to find out shortest route from source to target."
                    },
                    {
                        "username": "glock17",
                        "content": "A lot of people are having trouble getting their heads around why are we moving from target to startValue.\nSo here I try to tell you the way I got to the solution.\n\n1. Multiplication is an independent operation irrespective of whether a number is even or odd, so it is a possibility that multiplication by 2 would overshoot our target by a large value and then to tone it down we would have to apply a large number of subtraction operations(as for this case only subtraction would be possible) to reach the target, which is an overkill.\n2. So the greedy approach aims at dividing the number by 2 only when it is possible, which was not the case with multiplication as we could have multiplied at any instance of time. As the target becomes less than the startValue then we simply do addition operations to reach the target value.\n\nHope it makes things clearer.\n\nMy python3 Solution:\nhttps://leetcode.com/problems/broken-calculator/solutions/3096648/python3-intuition-best-explanation-on-leetcode/"
                    },
                    {
                        "username": "crabbyD",
                        "content": "everyone in the discussion is having the same code in which they are changing the value of target and not the value of start.\\ncan anyone explain why everyone is doing so..."
                    },
                    {
                        "username": "Mars_Congressional_Republic",
                        "content": "I started off in that way and got stuck for a while. I guess the realization that made me switch is that you can only divide by 2 for even numbers, but multiplying by 2, you can do that for even or odd numbers so going backward seems more restricted than going forward."
                    },
                    {
                        "username": "livelearn",
                        "content": "Did other languages face the same time restrictions, felt like this was really tight."
                    },
                    {
                        "username": "bupt_wc",
                        "content": "https://buptwc.com/2019/02/10/Leetcode-991-Broken-Calculator/\\nHope helpful!"
                    },
                    {
                        "username": "phalkey89",
                        "content": "Question no \"991\"  is itself a series of calc being sold world wide.\\nlol !!"
                    }
                ]
            },
            {
                "id": 1828165,
                "content": [
                    {
                        "username": "fabregas2messi",
                        "content": "Hi guys,\\n\\nMy first intution for solving this problem was converting from X to Y, I ended up getting TLE or wrong answers. Most of the answers here I see have converting from Y to X. I dont understand how everyone got same intuition but me. Is there a chance that everyone is supermans here or you guys read top voted answers before designing your solution?"
                    },
                    {
                        "username": "RomaFed",
                        "content": "same question.. and if am not wrong, task says we should mutate start value, not target"
                    },
                    {
                        "username": "betaminc",
                        "content": "HAHAHHAHA"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for March, Day 23.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/broken-calculator/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Work Backwards\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "arghya",
                        "content": "My initial intitution was to update value of X to bring it closer to Y. \\n\\nI don\\'t understand what made you guys think of the \"work backward\" solution. What was the intituion behind modifying Y?\\nI am not asking for the solution here. Thanks"
                    },
                    {
                        "username": "krishnachanduakula",
                        "content": "I thought this is a DP question  and  i spanned two trees one with X-1 and other with X*2 \\nand return the minimum of both ,which reached Y fast. When  But i failed to understand its \\na greedy. How to decide if it is a greedy or DP?"
                    },
                    {
                        "username": "Charlemagne5t",
                        "content": "1 <= startValue, target <= 10^9 constraint screams it is not DP. But I\\'ve seen a problem that had such a constraint and had to be solved using DP with some trick."
                    },
                    {
                        "username": "Khwaja_Abdul_Samad",
                        "content": "in the DP approach when it will go with case -1 , it will create endless loop of only substracting one from itself as it will be moving away from target so DP is not a good option"
                    },
                    {
                        "username": "Gangeswaran",
                        "content": "I tried BFS approach starting from root, picked element from queue, performed multiply and subtract, push new value to queue.\\nRepeated the process till we reach target value, While pushing new element to queue keep updating steps count.\\n\\nBut ended up with TLE for worst case startValue=1, target=10000000\\n\\nSo BFS won\\'t work here.. Though its actually to find out shortest route from source to target."
                    },
                    {
                        "username": "glock17",
                        "content": "A lot of people are having trouble getting their heads around why are we moving from target to startValue.\nSo here I try to tell you the way I got to the solution.\n\n1. Multiplication is an independent operation irrespective of whether a number is even or odd, so it is a possibility that multiplication by 2 would overshoot our target by a large value and then to tone it down we would have to apply a large number of subtraction operations(as for this case only subtraction would be possible) to reach the target, which is an overkill.\n2. So the greedy approach aims at dividing the number by 2 only when it is possible, which was not the case with multiplication as we could have multiplied at any instance of time. As the target becomes less than the startValue then we simply do addition operations to reach the target value.\n\nHope it makes things clearer.\n\nMy python3 Solution:\nhttps://leetcode.com/problems/broken-calculator/solutions/3096648/python3-intuition-best-explanation-on-leetcode/"
                    },
                    {
                        "username": "crabbyD",
                        "content": "everyone in the discussion is having the same code in which they are changing the value of target and not the value of start.\\ncan anyone explain why everyone is doing so..."
                    },
                    {
                        "username": "Mars_Congressional_Republic",
                        "content": "I started off in that way and got stuck for a while. I guess the realization that made me switch is that you can only divide by 2 for even numbers, but multiplying by 2, you can do that for even or odd numbers so going backward seems more restricted than going forward."
                    },
                    {
                        "username": "livelearn",
                        "content": "Did other languages face the same time restrictions, felt like this was really tight."
                    },
                    {
                        "username": "bupt_wc",
                        "content": "https://buptwc.com/2019/02/10/Leetcode-991-Broken-Calculator/\\nHope helpful!"
                    },
                    {
                        "username": "phalkey89",
                        "content": "Question no \"991\"  is itself a series of calc being sold world wide.\\nlol !!"
                    }
                ]
            },
            {
                "id": 1773654,
                "content": [
                    {
                        "username": "fabregas2messi",
                        "content": "Hi guys,\\n\\nMy first intution for solving this problem was converting from X to Y, I ended up getting TLE or wrong answers. Most of the answers here I see have converting from Y to X. I dont understand how everyone got same intuition but me. Is there a chance that everyone is supermans here or you guys read top voted answers before designing your solution?"
                    },
                    {
                        "username": "RomaFed",
                        "content": "same question.. and if am not wrong, task says we should mutate start value, not target"
                    },
                    {
                        "username": "betaminc",
                        "content": "HAHAHHAHA"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for March, Day 23.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/broken-calculator/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Work Backwards\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "arghya",
                        "content": "My initial intitution was to update value of X to bring it closer to Y. \\n\\nI don\\'t understand what made you guys think of the \"work backward\" solution. What was the intituion behind modifying Y?\\nI am not asking for the solution here. Thanks"
                    },
                    {
                        "username": "krishnachanduakula",
                        "content": "I thought this is a DP question  and  i spanned two trees one with X-1 and other with X*2 \\nand return the minimum of both ,which reached Y fast. When  But i failed to understand its \\na greedy. How to decide if it is a greedy or DP?"
                    },
                    {
                        "username": "Charlemagne5t",
                        "content": "1 <= startValue, target <= 10^9 constraint screams it is not DP. But I\\'ve seen a problem that had such a constraint and had to be solved using DP with some trick."
                    },
                    {
                        "username": "Khwaja_Abdul_Samad",
                        "content": "in the DP approach when it will go with case -1 , it will create endless loop of only substracting one from itself as it will be moving away from target so DP is not a good option"
                    },
                    {
                        "username": "Gangeswaran",
                        "content": "I tried BFS approach starting from root, picked element from queue, performed multiply and subtract, push new value to queue.\\nRepeated the process till we reach target value, While pushing new element to queue keep updating steps count.\\n\\nBut ended up with TLE for worst case startValue=1, target=10000000\\n\\nSo BFS won\\'t work here.. Though its actually to find out shortest route from source to target."
                    },
                    {
                        "username": "glock17",
                        "content": "A lot of people are having trouble getting their heads around why are we moving from target to startValue.\nSo here I try to tell you the way I got to the solution.\n\n1. Multiplication is an independent operation irrespective of whether a number is even or odd, so it is a possibility that multiplication by 2 would overshoot our target by a large value and then to tone it down we would have to apply a large number of subtraction operations(as for this case only subtraction would be possible) to reach the target, which is an overkill.\n2. So the greedy approach aims at dividing the number by 2 only when it is possible, which was not the case with multiplication as we could have multiplied at any instance of time. As the target becomes less than the startValue then we simply do addition operations to reach the target value.\n\nHope it makes things clearer.\n\nMy python3 Solution:\nhttps://leetcode.com/problems/broken-calculator/solutions/3096648/python3-intuition-best-explanation-on-leetcode/"
                    },
                    {
                        "username": "crabbyD",
                        "content": "everyone in the discussion is having the same code in which they are changing the value of target and not the value of start.\\ncan anyone explain why everyone is doing so..."
                    },
                    {
                        "username": "Mars_Congressional_Republic",
                        "content": "I started off in that way and got stuck for a while. I guess the realization that made me switch is that you can only divide by 2 for even numbers, but multiplying by 2, you can do that for even or odd numbers so going backward seems more restricted than going forward."
                    },
                    {
                        "username": "livelearn",
                        "content": "Did other languages face the same time restrictions, felt like this was really tight."
                    },
                    {
                        "username": "bupt_wc",
                        "content": "https://buptwc.com/2019/02/10/Leetcode-991-Broken-Calculator/\\nHope helpful!"
                    },
                    {
                        "username": "phalkey89",
                        "content": "Question no \"991\"  is itself a series of calc being sold world wide.\\nlol !!"
                    }
                ]
            },
            {
                "id": 1570826,
                "content": [
                    {
                        "username": "fabregas2messi",
                        "content": "Hi guys,\\n\\nMy first intution for solving this problem was converting from X to Y, I ended up getting TLE or wrong answers. Most of the answers here I see have converting from Y to X. I dont understand how everyone got same intuition but me. Is there a chance that everyone is supermans here or you guys read top voted answers before designing your solution?"
                    },
                    {
                        "username": "RomaFed",
                        "content": "same question.. and if am not wrong, task says we should mutate start value, not target"
                    },
                    {
                        "username": "betaminc",
                        "content": "HAHAHHAHA"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for March, Day 23.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/broken-calculator/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Work Backwards\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "arghya",
                        "content": "My initial intitution was to update value of X to bring it closer to Y. \\n\\nI don\\'t understand what made you guys think of the \"work backward\" solution. What was the intituion behind modifying Y?\\nI am not asking for the solution here. Thanks"
                    },
                    {
                        "username": "krishnachanduakula",
                        "content": "I thought this is a DP question  and  i spanned two trees one with X-1 and other with X*2 \\nand return the minimum of both ,which reached Y fast. When  But i failed to understand its \\na greedy. How to decide if it is a greedy or DP?"
                    },
                    {
                        "username": "Charlemagne5t",
                        "content": "1 <= startValue, target <= 10^9 constraint screams it is not DP. But I\\'ve seen a problem that had such a constraint and had to be solved using DP with some trick."
                    },
                    {
                        "username": "Khwaja_Abdul_Samad",
                        "content": "in the DP approach when it will go with case -1 , it will create endless loop of only substracting one from itself as it will be moving away from target so DP is not a good option"
                    },
                    {
                        "username": "Gangeswaran",
                        "content": "I tried BFS approach starting from root, picked element from queue, performed multiply and subtract, push new value to queue.\\nRepeated the process till we reach target value, While pushing new element to queue keep updating steps count.\\n\\nBut ended up with TLE for worst case startValue=1, target=10000000\\n\\nSo BFS won\\'t work here.. Though its actually to find out shortest route from source to target."
                    },
                    {
                        "username": "glock17",
                        "content": "A lot of people are having trouble getting their heads around why are we moving from target to startValue.\nSo here I try to tell you the way I got to the solution.\n\n1. Multiplication is an independent operation irrespective of whether a number is even or odd, so it is a possibility that multiplication by 2 would overshoot our target by a large value and then to tone it down we would have to apply a large number of subtraction operations(as for this case only subtraction would be possible) to reach the target, which is an overkill.\n2. So the greedy approach aims at dividing the number by 2 only when it is possible, which was not the case with multiplication as we could have multiplied at any instance of time. As the target becomes less than the startValue then we simply do addition operations to reach the target value.\n\nHope it makes things clearer.\n\nMy python3 Solution:\nhttps://leetcode.com/problems/broken-calculator/solutions/3096648/python3-intuition-best-explanation-on-leetcode/"
                    },
                    {
                        "username": "crabbyD",
                        "content": "everyone in the discussion is having the same code in which they are changing the value of target and not the value of start.\\ncan anyone explain why everyone is doing so..."
                    },
                    {
                        "username": "Mars_Congressional_Republic",
                        "content": "I started off in that way and got stuck for a while. I guess the realization that made me switch is that you can only divide by 2 for even numbers, but multiplying by 2, you can do that for even or odd numbers so going backward seems more restricted than going forward."
                    },
                    {
                        "username": "livelearn",
                        "content": "Did other languages face the same time restrictions, felt like this was really tight."
                    },
                    {
                        "username": "bupt_wc",
                        "content": "https://buptwc.com/2019/02/10/Leetcode-991-Broken-Calculator/\\nHope helpful!"
                    },
                    {
                        "username": "phalkey89",
                        "content": "Question no \"991\"  is itself a series of calc being sold world wide.\\nlol !!"
                    }
                ]
            },
            {
                "id": 1567364,
                "content": [
                    {
                        "username": "fabregas2messi",
                        "content": "Hi guys,\\n\\nMy first intution for solving this problem was converting from X to Y, I ended up getting TLE or wrong answers. Most of the answers here I see have converting from Y to X. I dont understand how everyone got same intuition but me. Is there a chance that everyone is supermans here or you guys read top voted answers before designing your solution?"
                    },
                    {
                        "username": "RomaFed",
                        "content": "same question.. and if am not wrong, task says we should mutate start value, not target"
                    },
                    {
                        "username": "betaminc",
                        "content": "HAHAHHAHA"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for March, Day 23.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/broken-calculator/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Work Backwards\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "arghya",
                        "content": "My initial intitution was to update value of X to bring it closer to Y. \\n\\nI don\\'t understand what made you guys think of the \"work backward\" solution. What was the intituion behind modifying Y?\\nI am not asking for the solution here. Thanks"
                    },
                    {
                        "username": "krishnachanduakula",
                        "content": "I thought this is a DP question  and  i spanned two trees one with X-1 and other with X*2 \\nand return the minimum of both ,which reached Y fast. When  But i failed to understand its \\na greedy. How to decide if it is a greedy or DP?"
                    },
                    {
                        "username": "Charlemagne5t",
                        "content": "1 <= startValue, target <= 10^9 constraint screams it is not DP. But I\\'ve seen a problem that had such a constraint and had to be solved using DP with some trick."
                    },
                    {
                        "username": "Khwaja_Abdul_Samad",
                        "content": "in the DP approach when it will go with case -1 , it will create endless loop of only substracting one from itself as it will be moving away from target so DP is not a good option"
                    },
                    {
                        "username": "Gangeswaran",
                        "content": "I tried BFS approach starting from root, picked element from queue, performed multiply and subtract, push new value to queue.\\nRepeated the process till we reach target value, While pushing new element to queue keep updating steps count.\\n\\nBut ended up with TLE for worst case startValue=1, target=10000000\\n\\nSo BFS won\\'t work here.. Though its actually to find out shortest route from source to target."
                    },
                    {
                        "username": "glock17",
                        "content": "A lot of people are having trouble getting their heads around why are we moving from target to startValue.\nSo here I try to tell you the way I got to the solution.\n\n1. Multiplication is an independent operation irrespective of whether a number is even or odd, so it is a possibility that multiplication by 2 would overshoot our target by a large value and then to tone it down we would have to apply a large number of subtraction operations(as for this case only subtraction would be possible) to reach the target, which is an overkill.\n2. So the greedy approach aims at dividing the number by 2 only when it is possible, which was not the case with multiplication as we could have multiplied at any instance of time. As the target becomes less than the startValue then we simply do addition operations to reach the target value.\n\nHope it makes things clearer.\n\nMy python3 Solution:\nhttps://leetcode.com/problems/broken-calculator/solutions/3096648/python3-intuition-best-explanation-on-leetcode/"
                    },
                    {
                        "username": "crabbyD",
                        "content": "everyone in the discussion is having the same code in which they are changing the value of target and not the value of start.\\ncan anyone explain why everyone is doing so..."
                    },
                    {
                        "username": "Mars_Congressional_Republic",
                        "content": "I started off in that way and got stuck for a while. I guess the realization that made me switch is that you can only divide by 2 for even numbers, but multiplying by 2, you can do that for even or odd numbers so going backward seems more restricted than going forward."
                    },
                    {
                        "username": "livelearn",
                        "content": "Did other languages face the same time restrictions, felt like this was really tight."
                    },
                    {
                        "username": "bupt_wc",
                        "content": "https://buptwc.com/2019/02/10/Leetcode-991-Broken-Calculator/\\nHope helpful!"
                    },
                    {
                        "username": "phalkey89",
                        "content": "Question no \"991\"  is itself a series of calc being sold world wide.\\nlol !!"
                    }
                ]
            },
            {
                "id": 1566853,
                "content": [
                    {
                        "username": "fabregas2messi",
                        "content": "Hi guys,\\n\\nMy first intution for solving this problem was converting from X to Y, I ended up getting TLE or wrong answers. Most of the answers here I see have converting from Y to X. I dont understand how everyone got same intuition but me. Is there a chance that everyone is supermans here or you guys read top voted answers before designing your solution?"
                    },
                    {
                        "username": "RomaFed",
                        "content": "same question.. and if am not wrong, task says we should mutate start value, not target"
                    },
                    {
                        "username": "betaminc",
                        "content": "HAHAHHAHA"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for March, Day 23.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/broken-calculator/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Work Backwards\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "arghya",
                        "content": "My initial intitution was to update value of X to bring it closer to Y. \\n\\nI don\\'t understand what made you guys think of the \"work backward\" solution. What was the intituion behind modifying Y?\\nI am not asking for the solution here. Thanks"
                    },
                    {
                        "username": "krishnachanduakula",
                        "content": "I thought this is a DP question  and  i spanned two trees one with X-1 and other with X*2 \\nand return the minimum of both ,which reached Y fast. When  But i failed to understand its \\na greedy. How to decide if it is a greedy or DP?"
                    },
                    {
                        "username": "Charlemagne5t",
                        "content": "1 <= startValue, target <= 10^9 constraint screams it is not DP. But I\\'ve seen a problem that had such a constraint and had to be solved using DP with some trick."
                    },
                    {
                        "username": "Khwaja_Abdul_Samad",
                        "content": "in the DP approach when it will go with case -1 , it will create endless loop of only substracting one from itself as it will be moving away from target so DP is not a good option"
                    },
                    {
                        "username": "Gangeswaran",
                        "content": "I tried BFS approach starting from root, picked element from queue, performed multiply and subtract, push new value to queue.\\nRepeated the process till we reach target value, While pushing new element to queue keep updating steps count.\\n\\nBut ended up with TLE for worst case startValue=1, target=10000000\\n\\nSo BFS won\\'t work here.. Though its actually to find out shortest route from source to target."
                    },
                    {
                        "username": "glock17",
                        "content": "A lot of people are having trouble getting their heads around why are we moving from target to startValue.\nSo here I try to tell you the way I got to the solution.\n\n1. Multiplication is an independent operation irrespective of whether a number is even or odd, so it is a possibility that multiplication by 2 would overshoot our target by a large value and then to tone it down we would have to apply a large number of subtraction operations(as for this case only subtraction would be possible) to reach the target, which is an overkill.\n2. So the greedy approach aims at dividing the number by 2 only when it is possible, which was not the case with multiplication as we could have multiplied at any instance of time. As the target becomes less than the startValue then we simply do addition operations to reach the target value.\n\nHope it makes things clearer.\n\nMy python3 Solution:\nhttps://leetcode.com/problems/broken-calculator/solutions/3096648/python3-intuition-best-explanation-on-leetcode/"
                    },
                    {
                        "username": "crabbyD",
                        "content": "everyone in the discussion is having the same code in which they are changing the value of target and not the value of start.\\ncan anyone explain why everyone is doing so..."
                    },
                    {
                        "username": "Mars_Congressional_Republic",
                        "content": "I started off in that way and got stuck for a while. I guess the realization that made me switch is that you can only divide by 2 for even numbers, but multiplying by 2, you can do that for even or odd numbers so going backward seems more restricted than going forward."
                    },
                    {
                        "username": "livelearn",
                        "content": "Did other languages face the same time restrictions, felt like this was really tight."
                    },
                    {
                        "username": "bupt_wc",
                        "content": "https://buptwc.com/2019/02/10/Leetcode-991-Broken-Calculator/\\nHope helpful!"
                    },
                    {
                        "username": "phalkey89",
                        "content": "Question no \"991\"  is itself a series of calc being sold world wide.\\nlol !!"
                    }
                ]
            },
            {
                "id": 1983290,
                "content": [
                    {
                        "username": "fabregas2messi",
                        "content": "Hi guys,\\n\\nMy first intution for solving this problem was converting from X to Y, I ended up getting TLE or wrong answers. Most of the answers here I see have converting from Y to X. I dont understand how everyone got same intuition but me. Is there a chance that everyone is supermans here or you guys read top voted answers before designing your solution?"
                    },
                    {
                        "username": "RomaFed",
                        "content": "same question.. and if am not wrong, task says we should mutate start value, not target"
                    },
                    {
                        "username": "betaminc",
                        "content": "HAHAHHAHA"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for March, Day 23.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/broken-calculator/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Work Backwards\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "arghya",
                        "content": "My initial intitution was to update value of X to bring it closer to Y. \\n\\nI don\\'t understand what made you guys think of the \"work backward\" solution. What was the intituion behind modifying Y?\\nI am not asking for the solution here. Thanks"
                    },
                    {
                        "username": "krishnachanduakula",
                        "content": "I thought this is a DP question  and  i spanned two trees one with X-1 and other with X*2 \\nand return the minimum of both ,which reached Y fast. When  But i failed to understand its \\na greedy. How to decide if it is a greedy or DP?"
                    },
                    {
                        "username": "Charlemagne5t",
                        "content": "1 <= startValue, target <= 10^9 constraint screams it is not DP. But I\\'ve seen a problem that had such a constraint and had to be solved using DP with some trick."
                    },
                    {
                        "username": "Khwaja_Abdul_Samad",
                        "content": "in the DP approach when it will go with case -1 , it will create endless loop of only substracting one from itself as it will be moving away from target so DP is not a good option"
                    },
                    {
                        "username": "Gangeswaran",
                        "content": "I tried BFS approach starting from root, picked element from queue, performed multiply and subtract, push new value to queue.\\nRepeated the process till we reach target value, While pushing new element to queue keep updating steps count.\\n\\nBut ended up with TLE for worst case startValue=1, target=10000000\\n\\nSo BFS won\\'t work here.. Though its actually to find out shortest route from source to target."
                    },
                    {
                        "username": "glock17",
                        "content": "A lot of people are having trouble getting their heads around why are we moving from target to startValue.\nSo here I try to tell you the way I got to the solution.\n\n1. Multiplication is an independent operation irrespective of whether a number is even or odd, so it is a possibility that multiplication by 2 would overshoot our target by a large value and then to tone it down we would have to apply a large number of subtraction operations(as for this case only subtraction would be possible) to reach the target, which is an overkill.\n2. So the greedy approach aims at dividing the number by 2 only when it is possible, which was not the case with multiplication as we could have multiplied at any instance of time. As the target becomes less than the startValue then we simply do addition operations to reach the target value.\n\nHope it makes things clearer.\n\nMy python3 Solution:\nhttps://leetcode.com/problems/broken-calculator/solutions/3096648/python3-intuition-best-explanation-on-leetcode/"
                    },
                    {
                        "username": "crabbyD",
                        "content": "everyone in the discussion is having the same code in which they are changing the value of target and not the value of start.\\ncan anyone explain why everyone is doing so..."
                    },
                    {
                        "username": "Mars_Congressional_Republic",
                        "content": "I started off in that way and got stuck for a while. I guess the realization that made me switch is that you can only divide by 2 for even numbers, but multiplying by 2, you can do that for even or odd numbers so going backward seems more restricted than going forward."
                    },
                    {
                        "username": "livelearn",
                        "content": "Did other languages face the same time restrictions, felt like this was really tight."
                    },
                    {
                        "username": "bupt_wc",
                        "content": "https://buptwc.com/2019/02/10/Leetcode-991-Broken-Calculator/\\nHope helpful!"
                    },
                    {
                        "username": "phalkey89",
                        "content": "Question no \"991\"  is itself a series of calc being sold world wide.\\nlol !!"
                    }
                ]
            }
        ]
    }
]