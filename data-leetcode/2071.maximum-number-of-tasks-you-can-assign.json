[
    {
        "title": "Maximum Number of Tasks You Can Assign",
        "question_content": "You have n tasks and m workers. Each task has a strength requirement stored in a 0-indexed integer array tasks, with the ith task requiring tasks[i] strength to complete. The strength of each worker is stored in a 0-indexed integer array workers, with the jth worker having workers[j] strength. Each worker can only be assigned to a single task and must have a strength greater than or equal to the task's strength requirement (i.e., workers[j] >= tasks[i]).\nAdditionally, you have pills magical pills that will increase a worker's strength by strength. You can decide which workers receive the magical pills, however, you may only give each worker at most one magical pill.\nGiven the 0-indexed integer arrays tasks and workers and the integers pills and strength, return the maximum number of tasks that can be completed.\n&nbsp;\nExample 1:\n\nInput: tasks = [3,2,1], workers = [0,3,3], pills = 1, strength = 1\nOutput: 3\nExplanation:\nWe can assign the magical pill and tasks as follows:\n- Give the magical pill to worker 0.\n- Assign worker 0 to task 2 (0 + 1 >= 1)\n- Assign worker 1 to task 1 (3 >= 2)\n- Assign worker 2 to task 0 (3 >= 3)\n\nExample 2:\n\nInput: tasks = [5,4], workers = [0,0,0], pills = 1, strength = 5\nOutput: 1\nExplanation:\nWe can assign the magical pill and tasks as follows:\n- Give the magical pill to worker 0.\n- Assign worker 0 to task 0 (0 + 5 >= 5)\n\nExample 3:\n\nInput: tasks = [10,15,30], workers = [0,10,10,10,10], pills = 3, strength = 10\nOutput: 2\nExplanation:\nWe can assign the magical pills and tasks as follows:\n- Give the magical pill to worker 0 and worker 1.\n- Assign worker 0 to task 0 (0 + 10 >= 10)\n- Assign worker 1 to task 1 (10 + 10 >= 15)\nThe last pill is not given because it will not make any worker strong enough for the last task.\n\n&nbsp;\nConstraints:\n\n\tn == tasks.length\n\tm == workers.length\n\t1 <= n, m <= 5 * 104\n\t0 <= pills <= m\n\t0 <= tasks[i], workers[j], strength <= 109",
        "solutions": [
            {
                "id": 1576033,
                "title": "python-greedy-binary-search-explained",
                "content": "The idea of this problem is the following: let us ask question: `check(k)`: can we finish `k` tasks or not. Here is a couple of insights.\\n\\n1. If we want to finish `k` tasks, we better choose the smallest `k` of them.\\n2. If we want to finish `k` tasks, we need `k` workers, and we want to choost the `k` strongest of them.\\n3. So, we choose tasks and workers and now the question is can we allocate them. We start from the biggest task and start to allocate it to worker. First we try to give it to worker without pill and if we are OK, we allocate it to the weakest worker. If we can not allocate it to worker without pill, we allocate it to weakest worker with pill. If we can not do both of these steps, we return `False`: it means, that we were not able to allocate all tasks.\\n\\nGood question though, why this greedy strategy will work? At the moment I do not have strict proof, I will add it a bit later.\\n\\n#### Complexity\\nIt is `O(n * log^2 n)` for time and `O(n)` for space.\\n\\n#### Code\\n```python\\nfrom sortedcontainers import SortedList\\n\\nclass Solution:\\n    def maxTaskAssign(self, tasks, workers, pills, strength):\\n        tasks = sorted(tasks)\\n        workers = sorted(workers)\\n\\n        def check(k):\\n            W = SortedList(workers[-k:])\\n            tries = pills\\n\\n            for elem in tasks[:k][::-1]:\\n                place = W.bisect_left(elem)\\n                if place < len(W):\\n                    W.pop(place)\\n                elif tries > 0:\\n                    place2 = W.bisect_left(elem - strength)\\n                    if place2 < len(W):\\n                        W.pop(place2)\\n                        tries -= 1\\n                else:\\n                    return False\\n\\n            return len(W) == 0\\n\\n        beg, end = 0, min(len(workers), len(tasks)) + 1\\n        while beg + 1 < end:\\n            mid = (beg + end)//2\\n            if check(mid):\\n                beg = mid\\n            else:\\n                end = mid\\n\\n        return beg\\n```\\n\\nIf you have any questoins, feel free to ask. If you like the solution and explanation, please **upvote!**",
                "solutionTags": [
                    "Binary Search",
                    "Greedy"
                ],
                "code": "```python\\nfrom sortedcontainers import SortedList\\n\\nclass Solution:\\n    def maxTaskAssign(self, tasks, workers, pills, strength):\\n        tasks = sorted(tasks)\\n        workers = sorted(workers)\\n\\n        def check(k):\\n            W = SortedList(workers[-k:])\\n            tries = pills\\n\\n            for elem in tasks[:k][::-1]:\\n                place = W.bisect_left(elem)\\n                if place < len(W):\\n                    W.pop(place)\\n                elif tries > 0:\\n                    place2 = W.bisect_left(elem - strength)\\n                    if place2 < len(W):\\n                        W.pop(place2)\\n                        tries -= 1\\n                else:\\n                    return False\\n\\n            return len(W) == 0\\n\\n        beg, end = 0, min(len(workers), len(tasks)) + 1\\n        while beg + 1 < end:\\n            mid = (beg + end)//2\\n            if check(mid):\\n                beg = mid\\n            else:\\n                end = mid\\n\\n        return beg\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1575887,
                "title": "c-binary-search-intuitive-greedy-idea-detailed-explanation-comments",
                "content": "**Idea**\\nThis is a good problem which requires concepts of binary search as well as greedy. I am going to try to explain the solution in points for better understanding. \\n\\n* We binary seach over the number of tasks to be completed. Hence the search space would be [0, min(workers.size(), tasks.size()]. \\n* Let us say that for a particular iteration of binary search, we need to check if *mid* number of tasks can be assigned. It makes sense to greedily choose the *mid* tasks with the smallest strength requirements. \\n* For each task, there can be three cases:\\n\\t* A worker *without* the pill can complete it.\\n\\t* A worker *with* the pill can complete it.\\n\\t* No available worker, *with or without* the pill can complete it.\\n* Since there is a constraint on the number of pills, it makes sense to give priority to the first case. If it is not possible, then we shift to the second case. However, if even that is not possible and we have third case, then we can say for sure that *mid* number of tasks cannot be assigned at all.\\n* Keep in mind that for the first case, we can simply choose the strongest worker available. But for the second case (where we use the pill), it is always better to greedily look for the worker with the smallest strength that is capable of completing the current task. Assigning a task to a stronger worker when a weaker worker is capable can result in a situation later where there is a task which the weaker worker can\\'t complete but the stronger worker could have completed. \\n* We need to search for smaller values if the third case is reached or the number of pills required for *mid* tasks exceeds the given number of pills. Otherwise, we can check for higher values of *mid*.\\n\\n**Implementation**\\nI use multiset to store the workers in each iteration of binary search. This is so that I can use the useful STL functions to make the implementation clear and concise. Also, multisets keep elements in increasing order by default. I have added comments to explain the code. \\n\\n**C++**\\n```\\nclass Solution {\\npublic:\\n    int maxTaskAssign(vector<int>& tasks, vector<int>& workers, int p, int strength) {\\n        int n = tasks.size(), m = workers.size();\\n        \\n        // Sorting the tasks and workers in increasing order\\n        sort(tasks.begin(), tasks.end());\\n        sort(workers.begin(), workers.end());\\n        int lo = 0, hi = min(m, n);\\n        int ans;\\n        \\n        while(lo <= hi) {\\n            int mid = lo + (hi - lo) / 2;\\n            int count = 0;\\n            bool flag = true;\\n            \\n            // Inserting all workers in a multiset\\n            multiset<int> st(workers.begin(), workers.end());\\n            \\n            // Checking if the mid smallest tasks can be assigned\\n            for(int i = mid - 1; i >= 0; i--) {\\n                \\n                // Case 1: Trying to assing to a worker without the pill\\n                auto it = prev(st.end());\\n                if(tasks[i] <= *it) {\\n                    \\n                    // Case 1 satisfied!\\n                    st.erase(it);\\n                } else {\\n                    \\n                    // Case 2: Trying to assign to a worker with the pill\\n                    auto it = st.lower_bound(tasks[i] - strength);\\n                    if(it != st.end()) {\\n                        \\n                        // Case 2 satisfied!\\n                        count++;\\n                        st.erase(it);\\n                    } else {\\n                        \\n                        // Case 3: Impossible to assign mid tasks\\n                        flag = false;\\n                        break;\\n                    }\\n                }\\n                \\n                // If at any moment, the number of pills require for mid tasks exceeds \\n                // the allotted number of pills, we stop the loop\\n                if(count > p) {\\n                    flag = false;\\n                    break;\\n                }\\n            }\\n            \\n            if(flag) {\\n                ans = mid;\\n                lo = mid + 1;\\n            } else {\\n                hi = mid - 1;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```\\n\\n*Space Complexity: O(m)*\\n*Time Complexity: O(log(min(n, m)) * m * log(m))*\\n\\n**Complexity Analysis**\\n*Space*: Auxiliary space is only required when creating a multiset for workers in each iteration of binary search. Hence, at any point of the program execution, there is O(m) auxiliary space used.\\n\\n*Time*: The search space of binary search is min(n, m), hence the factor of *log(min(n, m))*. In each iteration a multiset is created, hence the factor of *mlog(m)*. Further, the set is also binary searched for *mid* times, but this factor is ignored in the presence of *mlog(m)* when considering the amortized complexity.",
                "solutionTags": [
                    "Binary Search",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxTaskAssign(vector<int>& tasks, vector<int>& workers, int p, int strength) {\\n        int n = tasks.size(), m = workers.size();\\n        \\n        // Sorting the tasks and workers in increasing order\\n        sort(tasks.begin(), tasks.end());\\n        sort(workers.begin(), workers.end());\\n        int lo = 0, hi = min(m, n);\\n        int ans;\\n        \\n        while(lo <= hi) {\\n            int mid = lo + (hi - lo) / 2;\\n            int count = 0;\\n            bool flag = true;\\n            \\n            // Inserting all workers in a multiset\\n            multiset<int> st(workers.begin(), workers.end());\\n            \\n            // Checking if the mid smallest tasks can be assigned\\n            for(int i = mid - 1; i >= 0; i--) {\\n                \\n                // Case 1: Trying to assing to a worker without the pill\\n                auto it = prev(st.end());\\n                if(tasks[i] <= *it) {\\n                    \\n                    // Case 1 satisfied!\\n                    st.erase(it);\\n                } else {\\n                    \\n                    // Case 2: Trying to assign to a worker with the pill\\n                    auto it = st.lower_bound(tasks[i] - strength);\\n                    if(it != st.end()) {\\n                        \\n                        // Case 2 satisfied!\\n                        count++;\\n                        st.erase(it);\\n                    } else {\\n                        \\n                        // Case 3: Impossible to assign mid tasks\\n                        flag = false;\\n                        break;\\n                    }\\n                }\\n                \\n                // If at any moment, the number of pills require for mid tasks exceeds \\n                // the allotted number of pills, we stop the loop\\n                if(count > p) {\\n                    flag = false;\\n                    break;\\n                }\\n            }\\n            \\n            if(flag) {\\n                ans = mid;\\n                lo = mid + 1;\\n            } else {\\n                hi = mid - 1;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1578590,
                "title": "assign-m-easiest-tasks",
                "content": "Liked this one. The binary search approach is not very obvious here.\\n\\nThe idea is to pick `m` easiest tasks, and `m` strongest workers, and see if we can assign those tasks.\\n\\nWith this set of `m` workers and tasks, we:\\n1. Process tasks from hardest to easiest\\n2. Check if the strongest worker can do the hardest of the remaining tasks.\\n\\t- If not, find the weakest worker that can do the hardest task if given a pill.\\n\\t- If there are no more pills, we cannot assign `m` tasks.\\n3. If we find the worker who can do the task, remove it from the list of workers.\\n\\t- If not, we cannot assign `m` tasks.\\n\\nFinally, we do a binary search for the maximum number of tasks that we can accomplish.\\n\\n**C++**\\n```cpp\\nint maxTaskAssign(vector<int>& tasks, vector<int>& ws, int pills, int strength) {\\n    int l = 0, r = min(tasks.size(), ws.size());\\n    sort(begin(tasks), end(tasks));\\n    sort(begin(ws), end(ws));\\n    while (l < r) {\\n        int m = (l + r + 1) / 2, need = 0;\\n        multiset<int> ms(end(ws) - m, end(ws));\\n        for (int i = m - 1; i >= 0; --i) {\\n            auto it = prev(end(ms));\\n            if (*it < tasks[i]) {\\n                it = ms.lower_bound(tasks[i] - strength);\\n                if (it == end(ms) || ++need > pills)\\n                    break;\\n            }\\n            ms.erase(it);\\n        }\\n        if (ms.empty())\\n            l = m;\\n        else\\n            r = m - 1;\\n    }\\n    return l;\\n}\\n```",
                "solutionTags": [],
                "code": "```cpp\\nint maxTaskAssign(vector<int>& tasks, vector<int>& ws, int pills, int strength) {\\n    int l = 0, r = min(tasks.size(), ws.size());\\n    sort(begin(tasks), end(tasks));\\n    sort(begin(ws), end(ws));\\n    while (l < r) {\\n        int m = (l + r + 1) / 2, need = 0;\\n        multiset<int> ms(end(ws) - m, end(ws));\\n        for (int i = m - 1; i >= 0; --i) {\\n            auto it = prev(end(ms));\\n            if (*it < tasks[i]) {\\n                it = ms.lower_bound(tasks[i] - strength);\\n                if (it == end(ms) || ++need > pills)\\n                    break;\\n            }\\n            ms.erase(it);\\n        }\\n        if (ms.empty())\\n            l = m;\\n        else\\n            r = m - 1;\\n    }\\n    return l;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1575980,
                "title": "python-binary-search-check-answer-greedily",
                "content": "* Observation 1:\\nIf we know how many tasks can be assigned (i.e. we know the `ans = k` in advanced), the best way to choose tasks and workers is:\\n    * Choose the `k` smallest tasks.\\n    * Choose the `k` strongest workers.\\n    * For example, if we need to finish `3` tasks among `tasks = [5,5,8,9,9]` with `workers = [1,2,4,6,6]`, we should choose `workers = [4, 6, 6]` to finish `tasks = [5, 5, 8]`\\n    \\n* Observation 2:\\nSuppose the tasks should be done is a multi-set `T`, and the workers is a sorted list `W`. For example, `T = [5, 5, 8]` and `W = [4, 6, 6]`, and `pills = 1, strength = 5`\\n    * Start from the weakest worker with strength of `4`. At this time, `T = [5, 5, 8]` and the minimum task of `T` is `5`. The worker should have a pill to finish a task. However, the worker after having a pill will have a strength of `9`. We can choose to assign the maximum task that the strengthened worker can do instead of the original task, to reduce the following strength requirements. In this case, we remove `8` from `T`.\\n    * The next worker has the strength of `6`. At this time, `T = [5, 5]` and the minimum task of `T` is `5`. The worker can finish the task without pill. Just remove the task from `T`.\\n    * The last worker has the strength of `6`. At this time, `T = [5]` and the minimum task of `T` is `5`. The worker can finish the task without pill. Just remove the task from `T`.\\n    \\n* Combine the two observations, the solution of this question consists of two parts:\\n    * Binary search the answer `k`.\\n    * For every guess `k`, we check if `k` is valid or not.\\n    The two observations above is used in the process of checking.\\n    \\n    \\n* How to find the maximum task that a strengthened worker can do? And how to remove the task efficiently?\\n    * This requires an efficient data structure. In Python you can use `SortedList` with `bisect_right` and `remove` in `O(lg n)`. In C++ you can use a `multiset`.\\n\\n* Time complexity:\\n    * Checking if the answer is valid needs `O(N log N)`.\\n    * Binary search will check the answer `O(log N)` times.\\n    * The total time complexity is `O(N log^2 N)`\\n\\n* My code:\\n```python\\nclass Solution:\\n    def maxTaskAssign(self, tasks: List[int], workers: List[int], pills: int, strength: int) -> int:\\n        \\n        from sortedcontainers import SortedList\\n        \\n        tasks.sort()\\n        workers.sort()\\n        \\n        def check_valid(ans):\\n            \\n            _tasks = SortedList(tasks[:ans])\\n            _workers = workers[-ans:]\\n            remain_pills = pills\\n            \\n            for worker in _workers:\\n                task = _tasks[0]\\n                if worker >= task:\\n                    # the worker can finish the min task without pill, just move on\\n                    _tasks.pop(0)\\n                elif worker + strength >= task and remain_pills:\\n                    # the worker cannot finish the min task without pill, but can solve it with pill\\n                    # remove the max task that the strengthened worker can finish instead\\n                    remove_task_idx = _tasks.bisect_right(worker + strength)\\n                    _tasks.pop(remove_task_idx - 1)\\n                    remain_pills -= 1\\n                else:\\n                    return False\\n            return True\\n        \\n        lo, hi = 0, min(len(workers), len(tasks))\\n        while lo < hi:\\n            mid = (lo + hi + 1) // 2\\n            if check_valid(mid):\\n                lo = mid\\n            else:\\n                hi = mid - 1\\n        return lo\\n```",
                "solutionTags": [],
                "code": "```python\\nclass Solution:\\n    def maxTaskAssign(self, tasks: List[int], workers: List[int], pills: int, strength: int) -> int:\\n        \\n        from sortedcontainers import SortedList\\n        \\n        tasks.sort()\\n        workers.sort()\\n        \\n        def check_valid(ans):\\n            \\n            _tasks = SortedList(tasks[:ans])\\n            _workers = workers[-ans:]\\n            remain_pills = pills\\n            \\n            for worker in _workers:\\n                task = _tasks[0]\\n                if worker >= task:\\n                    # the worker can finish the min task without pill, just move on\\n                    _tasks.pop(0)\\n                elif worker + strength >= task and remain_pills:\\n                    # the worker cannot finish the min task without pill, but can solve it with pill\\n                    # remove the max task that the strengthened worker can finish instead\\n                    remove_task_idx = _tasks.bisect_right(worker + strength)\\n                    _tasks.pop(remove_task_idx - 1)\\n                    remain_pills -= 1\\n                else:\\n                    return False\\n            return True\\n        \\n        lo, hi = 0, min(len(workers), len(tasks))\\n        while lo < hi:\\n            mid = (lo + hi + 1) // 2\\n            if check_valid(mid):\\n                lo = mid\\n            else:\\n                hi = mid - 1\\n        return lo\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1617609,
                "title": "java-solution-with-monotonic-queue",
                "content": "```\\nclass Solution {\\n    public int maxTaskAssign(int[] tasks, int[] workers, int pills, int strength) {\\n        int left = 0, right = Math.min(tasks.length, workers.length);\\n        Arrays.sort(tasks);\\n        Arrays.sort(workers);\\n        while(left+1<right)\\n        {\\n            int mid = left + (right - left)/2;\\n            if(canAssign(mid, tasks, workers, pills, strength))\\n            {\\n                left = mid;\\n            }\\n            else\\n            {\\n                right = mid;\\n            }\\n        }\\n        \\n        if(canAssign(right, tasks, workers, pills, strength))\\n        {\\n            return right;\\n        }\\n        else return left;\\n    }\\n    \\n      public boolean canAssign(int count, int[] tasks, int[] workers, int pills, int strength){\\n        Deque<Integer> dq = new ArrayDeque<>();\\n        int ind = workers.length - 1;\\n        for (int i = count - 1; i >= 0; i--) {\\n            while(ind>=workers.length-count && workers[ind]+strength>=tasks[i])\\n            {\\n              dq.offerLast(workers[ind]);\\n              ind--;\\n            }\\n            \\n            if(dq.isEmpty())return false;\\n            if(dq.peekFirst()>=tasks[i])\\n            {\\n                dq.pollFirst();\\n            }\\n            else\\n            {\\n                dq.pollLast();\\n                pills--;\\n                if(pills<0)return false;\\n            }\\n        }\\n          \\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int maxTaskAssign(int[] tasks, int[] workers, int pills, int strength) {\\n        int left = 0, right = Math.min(tasks.length, workers.length);\\n        Arrays.sort(tasks);\\n        Arrays.sort(workers);\\n        while(left+1<right)\\n        {\\n            int mid = left + (right - left)/2;\\n            if(canAssign(mid, tasks, workers, pills, strength))\\n            {\\n                left = mid;\\n            }\\n            else\\n            {\\n                right = mid;\\n            }\\n        }\\n        \\n        if(canAssign(right, tasks, workers, pills, strength))\\n        {\\n            return right;\\n        }\\n        else return left;\\n    }\\n    \\n      public boolean canAssign(int count, int[] tasks, int[] workers, int pills, int strength){\\n        Deque<Integer> dq = new ArrayDeque<>();\\n        int ind = workers.length - 1;\\n        for (int i = count - 1; i >= 0; i--) {\\n            while(ind>=workers.length-count && workers[ind]+strength>=tasks[i])\\n            {\\n              dq.offerLast(workers[ind]);\\n              ind--;\\n            }\\n            \\n            if(dq.isEmpty())return false;\\n            if(dq.peekFirst()>=tasks[i])\\n            {\\n                dq.pollFirst();\\n            }\\n            else\\n            {\\n                dq.pollLast();\\n                pills--;\\n                if(pills<0)return false;\\n            }\\n        }\\n          \\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1576141,
                "title": "c-why-binary-search",
                "content": "**Why Binary Search?**\\nWhenever the set of all possible values that can satisfy the requirements form a continuous range, we apply the binary search to find the optimal value out of those.\\n\\nLet\\'s understand this with the current example.\\n\\n- Suppose someone says that you can complete K tasks with this particular input. Then, it is evident that we can complete K-1 tasks, K-2 tasks ... so on.\\n\\n- But we can\\'t say that we can complete K+1 tasks (or K+j, for any j>0 && j<=n-K).\\n\\t- If someone also says that K is not the max possible number of tasks that can be completed, then we can say we can surely do K+1 tasks.\\n\\t\\n\\t - That means there is a tipping point X, such that for a particular input, we can complete K<=X tasks, but we can complete K>X tasks.\\n\\t \\nNow, this is similar to finding peak elements in the array using binary search.\\n\\n**Algorithm**\\n- X can take values l = 0, r = n\\n\\n- We check if \"mid\" number of tasks can be taken with the help of Check() function. [Explained in the subsequent paragraph.]\\n\\t- Yes: Then, we search for X in [mid+1, r] range\\n\\t- No:  Then, we search for X in [l, mid] range\\n\\t\\n- Check() function\\n\\t- Given a number K, we have to check whether we can complete K tasks.\\n\\t- Now, we will greedily take K tasks, which require lowest strength. That is, tasks[0] ... tasks[k-1], after we sort tasks array.\\n\\t- We will process these K tasks in the decreasing order of their strengths, i.e. from K-1 to 0.\\n\\t\\t- Say, for particular i, we need not to use a pill.\\n\\t\\t\\t- Then, we will allocate it to the largest available worker.\\n\\t\\t- Say, for a particular task i, we need to use pill.\\n\\t\\t\\t- Suppose there are two workers, w1 with strength 4 and w2 with strength 5. Now, after taking pill both of them can complete the task i.\\n\\t\\t\\t- Then, which one is optimal to take?\\n\\t\\t\\t\\t- Obviously taking worker w1. Because, if we can do some work at a cheap amount then why we should spend extras.\\n\\t\\t\\t- The lower_bound()  does the part mentioned above.\\n\\t- The greedy strategy for Check() works well. And, it easy to write a proof of its correctness. Do let me know, if you need the proof.\\n\\n**Time Complexity**\\n- O(n*log(n)*log(m))\\n\\n**Code(Multiset)**\\n```\\nclass Solution {\\npublic:\\n    \\n    int check(vector<int> &tasks, int take, vector<int> &worker, int pills, int power){\\n        //optimal to take first \"take\" tasks\\n        //satisfy the largest one first\\n        multiset<int> st(worker.begin(), worker.end());\\n        while(take>=1 && st.size()){\\n            auto it = st.end(); --it; \\n            \\n            //last element can satisfy\\n            if(tasks[take-1] <= *st.rbegin()) {}\\n            //last worker cant satisfy, use pills\\n            else if(pills) {            \\n                //find worker with least strength which after eating pill, can do the current task\\n                it = st.lower_bound(tasks[take-1]-power); \\n                if(it==st.end()) return 0;\\n                --pills;\\n            }\\n            else return 0;\\n            st.erase(it);\\n            --take;\\n        }\\n        return take==0;\\n    }\\n    int maxTaskAssign(vector<int>& t, vector<int>& w, int p, int s) {\\n        int n = t.size();\\n        int m = w.size();\\n        sort(t.begin(), t.end());\\n  \\n        int l = 0, r = n, ans = 0;\\n        \\n        while(l<=r){\\n            int mid  = l + (r-l)/2;\\n            int chk  = check(t,mid,w,p,s); //check if we can take \"mid\" number of tasks. \\n                                            //Return 1 if we can take, 0 otherwise         \\n            if(chk) {\\n                ans = mid;\\n                l   = mid+1;\\n            }\\n            else {\\n                r = mid-1;\\n            }\\n        }\\n        return ans;\\n        \\n    }\\n};\\n```\\n**Code(Map)**\\n```\\nclass Solution {\\npublic:\\n    \\n    int check(vector<int> &tasks, int take, map<int,int> count, int pills, int power){\\n        //optimal to take first \"take\" tasks\\n        //satisfy the largest one first\\n        \\n        while(take>=1 && count.size()){\\n            auto it = count.end(); --it; \\n            \\n            //last element can satisfy\\n            if(tasks[take-1] <= it->first) {}    \\n            //last worker cant satisfy, use pills\\n            else if(pills) {            \\n                //find worker with least strength which after eating pill, can do the current task\\n                it = count.lower_bound(tasks[take-1]-power); \\n                if(it==count.end()) return 0;\\n                --pills;\\n            }\\n            else return 0;\\n            \\n            --take;\\n            (it->second)--;\\n            if(it->second == 0) \\n                count.erase(it);\\n        }\\n        return take==0;\\n    }\\n    int maxTaskAssign(vector<int>& t, vector<int>& w, int p, int s) {\\n        int n = t.size();\\n        int m = w.size();\\n        sort(t.begin(), t.end());\\n        map<int,int> Count;\\n        for(auto &strength : w) Count[strength]++;\\n  \\n        int l = 0, r = n, ans = 0;\\n        \\n        while(l<=r){\\n            int mid  = l + (r-l)/2;\\n            int chk  = check(t,mid,Count,p,s); //check if we can take \"mid\" number of tasks. \\n                                            //Return 1 if we can take, 0 otherwise         \\n            if(chk) {\\n                ans = mid;\\n                l   = mid+1;\\n            }\\n            else {\\n                r = mid-1;\\n            }\\n        }\\n        return ans;\\n        \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    int check(vector<int> &tasks, int take, vector<int> &worker, int pills, int power){\\n        //optimal to take first \"take\" tasks\\n        //satisfy the largest one first\\n        multiset<int> st(worker.begin(), worker.end());\\n        while(take>=1 && st.size()){\\n            auto it = st.end(); --it; \\n            \\n            //last element can satisfy\\n            if(tasks[take-1] <= *st.rbegin()) {}\\n            //last worker cant satisfy, use pills\\n            else if(pills) {            \\n                //find worker with least strength which after eating pill, can do the current task\\n                it = st.lower_bound(tasks[take-1]-power); \\n                if(it==st.end()) return 0;\\n                --pills;\\n            }\\n            else return 0;\\n            st.erase(it);\\n            --take;\\n        }\\n        return take==0;\\n    }\\n    int maxTaskAssign(vector<int>& t, vector<int>& w, int p, int s) {\\n        int n = t.size();\\n        int m = w.size();\\n        sort(t.begin(), t.end());\\n  \\n        int l = 0, r = n, ans = 0;\\n        \\n        while(l<=r){\\n            int mid  = l + (r-l)/2;\\n            int chk  = check(t,mid,w,p,s); //check if we can take \"mid\" number of tasks. \\n                                            //Return 1 if we can take, 0 otherwise         \\n            if(chk) {\\n                ans = mid;\\n                l   = mid+1;\\n            }\\n            else {\\n                r = mid-1;\\n            }\\n        }\\n        return ans;\\n        \\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    \\n    int check(vector<int> &tasks, int take, map<int,int> count, int pills, int power){\\n        //optimal to take first \"take\" tasks\\n        //satisfy the largest one first\\n        \\n        while(take>=1 && count.size()){\\n            auto it = count.end(); --it; \\n            \\n            //last element can satisfy\\n            if(tasks[take-1] <= it->first) {}    \\n            //last worker cant satisfy, use pills\\n            else if(pills) {            \\n                //find worker with least strength which after eating pill, can do the current task\\n                it = count.lower_bound(tasks[take-1]-power); \\n                if(it==count.end()) return 0;\\n                --pills;\\n            }\\n            else return 0;\\n            \\n            --take;\\n            (it->second)--;\\n            if(it->second == 0) \\n                count.erase(it);\\n        }\\n        return take==0;\\n    }\\n    int maxTaskAssign(vector<int>& t, vector<int>& w, int p, int s) {\\n        int n = t.size();\\n        int m = w.size();\\n        sort(t.begin(), t.end());\\n        map<int,int> Count;\\n        for(auto &strength : w) Count[strength]++;\\n  \\n        int l = 0, r = n, ans = 0;\\n        \\n        while(l<=r){\\n            int mid  = l + (r-l)/2;\\n            int chk  = check(t,mid,Count,p,s); //check if we can take \"mid\" number of tasks. \\n                                            //Return 1 if we can take, 0 otherwise         \\n            if(chk) {\\n                ans = mid;\\n                l   = mid+1;\\n            }\\n            else {\\n                r = mid-1;\\n            }\\n        }\\n        return ans;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1596318,
                "title": "c-binary-search-the-answer",
                "content": "## \\u2714\\uFE0F **Solution 1 (Binary search the answer)**\\nThis is a nice problem which can be solved with binary search.\\n\\n**Main ideas**\\n* Observation 1\\n\\t* Let\\'s say that we have a method `isValid(k)` which returns true if the workers can complete k tasks\\n(such that all conditions of the problem are satisfied) and false otherwise.\\n\\t* The answer of the problem is the `maximum value k` such that `isValid(k)` is `true`.\\nWe can **check all possible values** of k and return the maximum valid k.\\nUnfortunately this is **too slow**.\\n\\n* Observation 2\\n\\t* If we know that workers can complete k tasks then for sure they can complete k - 1, k - 2, ..., 1 tasks.\\nIf we know that workers cannot complete k tasks then for sure they cannot complete k + 1, k + 2, ... T tasks.\\n\\t* If we call `isValid(k)` for all k in range [0, T] then we will have a **sorted sequence** with prefix values `true` and\\nwith suffix (possibly empty) values `false`: [true, true, true, ..., true, true, false, false, ..., false].\\n\\t* This means that we can **binary search** the `maximum value k` such that `isValid(k)` is `true`.\\nThis should be **fast enough** to pass all test cases.\\n\\n**Algorithm**\\n1. Sort `tasks` (we need this for `isValid(..)` method);\\n2. Sort `workers` (we need this for `isValid(..)` method);\\n3. Set the search space of the binary search: `[0, min(T, W)]`;\\n\\t* the maximum number of completed tasks is the minimum between number of tasks and number of workers;\\n\\t* remember that a worker can complete at most one task;\\n4. For each range `[l, r]` during the binary search:\\n\\t* set `mid =(l + r + 1) / 2`;\\n\\t* if `isValid(mid) == true` then we shrink the range to `[mid, r]`;\\n\\telse we shrink the range to `[l, mid - 1]`;\\n\\t* when we shrink the range `[l, r]` we maintain the following invariant:\\n\\t\\t * the left border `l` of the next range satisfies the condition/invariant `isValid(l) == true`;\\n5. The binary search stops when the search range has a size equal to 1.\\n   * We can be sure that it represents the maximum number of tasks that can be completed by the workers.\\n   * Remember that we updated the ranges by moving to the right and maintaining the invariant `isValid(l) == true`.\\n\\nThe most interesting and difficult part of the problem is to implement the method `isValid(k)`. \\nWe can use the following greedy approach:\\n* Fix the `easiest k tasks` and `strongest k workers`;\\n\\t* this is why we sorted `tasks` and `workers` in the beginning;\\n\\t* we use a multiset with the strongest k workers (multiset allows fast search and erase operations);\\n* `For each task` from the easiest k tasks (starting `from the hardest` and moving `to the easiest`):\\n\\t* search the `weakest available worker` that can complete the task `without taking a pill`;\\n\\t* if we find such worker\\n\\t\\t* complete the task and erase him from the multiset (he is not available anymore);\\n\\t* if we do not find such worker:\\n\\t\\t* if we do not have any pills then `return false` (we cannot complete the current task);\\n\\t\\t* search the `weakest available worker` that can complete the task when he `takes a pill`;\\n\\t\\t* if such worker exists then he takes a pill and completes the task (he is erased from the multiset, he is not available anymore)\\n\\t\\totherwise `return false` (we cannot complete the current task);\\n* If we completed all k tasks then `return true`;\\n\\n**Complexity analysis**\\n- Notation: T = tasks.size(), W = workers.size()\\n- **Time complexity:** `O(Tlog(T) + Wlog(W) + min(T, W) * (log(min(T, W))) ^ 2)`\\n\\t* `O(Tlog(T))` for `sort(tasks ..)`;\\n\\t* `O(Wlog(W))` for `sort(workers ..)`;\\n\\t* `O(min(T, W) * (log(min(T, W))) ^ 2)` for binary search;\\n\\t\\t* `log(min(T, W))` calls of `isValid(..)` method;\\n\\t\\t* each `isValid(..)` call is `O(min(T, W) * log(min(T, W)))`;\\n- **Extra-Space complexity:** `O(min(T, W)+log(T)+log(W))`\\n\\t* `O(min(T, W))` for `workersMultiset`;\\n\\t* `O(log(T))` for recursion stack of `sort(tasks ..)`;\\n\\t* `O(log(W))` for recursion stack of `sort(workers ..)`;\\n\\t* We modify the input vectors (`tasks` and `workers`) and do not include `O(T + W)` to the extra-space of the solution/algorithm.\\n\\n\\n**Submission details**\\n\\t- 48 / 48 test cases passed.\\n\\t- Runtime: 1638 ms\\n\\t- Memory Usage: 282.1 MB\\n\\n**Code**\\n```\\nclass Solution {\\nprivate:\\n    bool isValid(vector<int>& tasks, vector<int>& workers, const int& MAX_TASKS, int pills, int strength){\\n        multiset<int> workersMultiset(workers.end() - MAX_TASKS, workers.end());\\n        for(int i = MAX_TASKS - 1; i >= 0; --i){\\n            auto it = workersMultiset.lower_bound(tasks[i]);\\n            if(it == workersMultiset.end()){\\n                pills -= 1;\\n                it = workersMultiset.lower_bound(tasks[i] - strength);\\n            }\\n            if(it == workersMultiset.end() || pills < 0){\\n                return false;\\n            }\\n            workersMultiset.erase(it);\\n        }\\n        return true;\\n    }\\n    \\npublic:\\n    int maxTaskAssign(vector<int>& tasks, vector<int>& workers, int pills, int strength) {\\n        const int T = tasks.size();\\n        const int W = workers.size();\\n        \\n        sort(tasks.begin(), tasks.end());\\n        sort(workers.begin(), workers.end());\\n        \\n        int l = 0;\\n        int r = min(T, W);\\n        while(l != r){\\n            int mid = (l + r + 1) / 2;\\n            if(isValid(tasks, workers, mid, pills, strength)){\\n                l = mid;\\n            }else{\\n                r = mid - 1;\\n            }\\n        }\\n        \\n        return r;\\n    }\\n};\\n```\\n",
                "solutionTags": [
                    "C",
                    "Greedy",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\nprivate:\\n    bool isValid(vector<int>& tasks, vector<int>& workers, const int& MAX_TASKS, int pills, int strength){\\n        multiset<int> workersMultiset(workers.end() - MAX_TASKS, workers.end());\\n        for(int i = MAX_TASKS - 1; i >= 0; --i){\\n            auto it = workersMultiset.lower_bound(tasks[i]);\\n            if(it == workersMultiset.end()){\\n                pills -= 1;\\n                it = workersMultiset.lower_bound(tasks[i] - strength);\\n            }\\n            if(it == workersMultiset.end() || pills < 0){\\n                return false;\\n            }\\n            workersMultiset.erase(it);\\n        }\\n        return true;\\n    }\\n    \\npublic:\\n    int maxTaskAssign(vector<int>& tasks, vector<int>& workers, int pills, int strength) {\\n        const int T = tasks.size();\\n        const int W = workers.size();\\n        \\n        sort(tasks.begin(), tasks.end());\\n        sort(workers.begin(), workers.end());\\n        \\n        int l = 0;\\n        int r = min(T, W);\\n        while(l != r){\\n            int mid = (l + r + 1) / 2;\\n            if(isValid(tasks, workers, mid, pills, strength)){\\n                l = mid;\\n            }else{\\n                r = mid - 1;\\n            }\\n        }\\n        \\n        return r;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1588356,
                "title": "python-binary-search-greedy-with-deque-o-nlogn",
                "content": "Use binary search with greedy check. Each check can be done in O(n) using a deque. Within a check, we iterate through the workers from the weakiest to the strongest. Each worker needs to take a task. \\nThere are two cases:\\n1. The worker can take the easiest task available: we assign it to the worker.\\n2. The worker cannot even take the easiest task: we give a pill to him and let him take the hardest doable task.\\n\\nThe deque will hold from the easiest unassigned task to the toughest that can be done by the current worker with a pill. If the easiest task can be handled by the weakiest worker, we assign it to the worker and do a popleft, other wise, we use one pill and pop from the right.\\n```\\nclass Solution:\\n    def maxTaskAssign(self, tasks: List[int], workers: List[int], pills: int, strength: int) -> int:\\n        # workers sorted in reverse order, tasks sorted in normal order\\n        def can_assign(n):\\n            task_i = 0\\n            task_temp = deque()\\n            n_pills = pills\\n            for i in range(n-1,-1,-1):\\n                while task_i < n and tasks[task_i] <= workers[i]+strength:\\n                    task_temp.append(tasks[task_i])\\n                    task_i += 1\\n                \\n                if len(task_temp) == 0:\\n                    return False\\n                if workers[i] >= task_temp[0]:\\n                    task_temp.popleft()\\n                elif n_pills > 0:\\n                    task_temp.pop()\\n                    n_pills -= 1\\n                else:\\n                    return False\\n            return True\\n        \\n        tasks.sort()\\n        workers.sort(reverse = True)\\n        \\n        l = 0\\n        r = min(len(tasks), len(workers))\\n        res = -1\\n        while l <= r:\\n            m = (l+r)//2\\n            if can_assign(m):\\n                res = m\\n                l = m+1\\n            else:\\n                r = m-1\\n        return res\\n```",
                "solutionTags": [
                    "Python3",
                    "Greedy",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution:\\n    def maxTaskAssign(self, tasks: List[int], workers: List[int], pills: int, strength: int) -> int:\\n        # workers sorted in reverse order, tasks sorted in normal order\\n        def can_assign(n):\\n            task_i = 0\\n            task_temp = deque()\\n            n_pills = pills\\n            for i in range(n-1,-1,-1):\\n                while task_i < n and tasks[task_i] <= workers[i]+strength:\\n                    task_temp.append(tasks[task_i])\\n                    task_i += 1\\n                \\n                if len(task_temp) == 0:\\n                    return False\\n                if workers[i] >= task_temp[0]:\\n                    task_temp.popleft()\\n                elif n_pills > 0:\\n                    task_temp.pop()\\n                    n_pills -= 1\\n                else:\\n                    return False\\n            return True\\n        \\n        tasks.sort()\\n        workers.sort(reverse = True)\\n        \\n        l = 0\\n        r = min(len(tasks), len(workers))\\n        res = -1\\n        while l <= r:\\n            m = (l+r)//2\\n            if can_assign(m):\\n                res = m\\n                l = m+1\\n            else:\\n                r = m-1\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1576586,
                "title": "python3-binary-search",
                "content": "I thought a greedy algo would be enough but have spent hours and couldn\\'t get a solution. It turns out that the direction was wrong in the first place. Below implementation is based on other posts in the discuss. \\n\\nPlease check out this [commit](https://github.com/gaosanyong/leetcode/commit/e61879b77928a08bb15cc182a69259d6e2bce59a) for solutions of biweekly 65. \\n```\\nclass Solution:\\n    def maxTaskAssign(self, tasks: List[int], workers: List[int], pills: int, strength: int) -> int:\\n        tasks.sort()\\n        workers.sort()\\n        \\n        def fn(k, p=pills): \\n            \"\"\"Return True if k tasks can be completed.\"\"\"\\n            ww = workers[-k:]\\n            for t in reversed(tasks[:k]): \\n                if t <= ww[-1]: ww.pop()\\n                elif t <= ww[-1] + strength and p: \\n                    p -= 1\\n                    i = bisect_left(ww, t - strength)\\n                    ww.pop(i)\\n                else: return False \\n            return True \\n          \\n        lo, hi = 0, min(len(tasks), len(workers))\\n        while lo < hi: \\n            mid = lo + hi + 1 >> 1\\n            if fn(mid): lo = mid\\n            else: hi = mid - 1\\n        return lo \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maxTaskAssign(self, tasks: List[int], workers: List[int], pills: int, strength: int) -> int:\\n        tasks.sort()\\n        workers.sort()\\n        \\n        def fn(k, p=pills): \\n            \"\"\"Return True if k tasks can be completed.\"\"\"\\n            ww = workers[-k:]\\n            for t in reversed(tasks[:k]): \\n                if t <= ww[-1]: ww.pop()\\n                elif t <= ww[-1] + strength and p: \\n                    p -= 1\\n                    i = bisect_left(ww, t - strength)\\n                    ww.pop(i)\\n                else: return False \\n            return True \\n          \\n        lo, hi = 0, min(len(tasks), len(workers))\\n        while lo < hi: \\n            mid = lo + hi + 1 >> 1\\n            if fn(mid): lo = mid\\n            else: hi = mid - 1\\n        return lo \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2389960,
                "title": "faster-than-100-00-python-easiest-solution",
                "content": "![image](https://assets.leetcode.com/users/images/2a3ad34c-3d5e-4380-8226-4f0e26ed8aac_1659827542.6038299.png)\\n**for me it was an easy solution .. might be it is not as easy for you..!**\\n***consider me in comment section about your doubt if you have any...  if you don\\'t have any glad to know* :)**\\n\\n**solution code:- \\n_________________**\\n\\n```\\nclass Solution:\\n    def maxTaskAssign(self, tasks: List[int], workers: List[int], pills: int, strength: int) -> int:\\n        \\n        from sortedcontainers import SortedList\\n        \\n        tasks.sort()\\n        workers.sort()\\n        \\n        def check_valid(ans):\\n            \\n            # _tasks = SortedList(tasks[:ans])\\n            _tasks = deque(tasks[:ans])\\n            _workers = workers[-ans:]\\n            remain_pills = pills\\n            \\n            for worker in _workers:\\n                task = _tasks[0]\\n                if worker >= task:\\n                    # the worker can finish the min task without pill, just move on\\n                    # _tasks.pop(0)\\n                    _tasks.popleft()\\n                elif worker + strength >= task and remain_pills:\\n                    # the worker cannot finish the min task without pill, but can solve it with pill\\n                    # remove the max task that the strengthened worker can finish instead\\n                    # remove_task_idx = _tasks.bisect_right(worker + strength)\\n                    remove_task_idx = bisect.bisect_right(_tasks, worker + strength)\\n                    # _tasks.pop(remove_task_idx - 1)\\n                    del _tasks[remove_task_idx - 1]\\n                    remain_pills -= 1\\n                else:\\n                    return False\\n            return True\\n        \\n        lo, hi = 0, min(len(workers), len(tasks))\\n        while lo < hi:\\n            mid = (lo + hi + 1) // 2\\n            if check_valid(mid):\\n                lo = mid\\n            else:\\n                hi = mid - 1\\n        return lo\\n```\\n**i will answer whenever i get time... don\\'t be panic**\\n***i have also a busy schedule as you have . hope you understand***",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maxTaskAssign(self, tasks: List[int], workers: List[int], pills: int, strength: int) -> int:\\n        \\n        from sortedcontainers import SortedList\\n        \\n        tasks.sort()\\n        workers.sort()\\n        \\n        def check_valid(ans):\\n            \\n            # _tasks = SortedList(tasks[:ans])\\n            _tasks = deque(tasks[:ans])\\n            _workers = workers[-ans:]\\n            remain_pills = pills\\n            \\n            for worker in _workers:\\n                task = _tasks[0]\\n                if worker >= task:\\n                    # the worker can finish the min task without pill, just move on\\n                    # _tasks.pop(0)\\n                    _tasks.popleft()\\n                elif worker + strength >= task and remain_pills:\\n                    # the worker cannot finish the min task without pill, but can solve it with pill\\n                    # remove the max task that the strengthened worker can finish instead\\n                    # remove_task_idx = _tasks.bisect_right(worker + strength)\\n                    remove_task_idx = bisect.bisect_right(_tasks, worker + strength)\\n                    # _tasks.pop(remove_task_idx - 1)\\n                    del _tasks[remove_task_idx - 1]\\n                    remain_pills -= 1\\n                else:\\n                    return False\\n            return True\\n        \\n        lo, hi = 0, min(len(workers), len(tasks))\\n        while lo < hi:\\n            mid = (lo + hi + 1) // 2\\n            if check_valid(mid):\\n                lo = mid\\n            else:\\n                hi = mid - 1\\n        return lo\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1886392,
                "title": "python-binary-search-monotonic-queue-template",
                "content": "```\\nfrom collections import deque\\nclass Solution:\\n    def maxTaskAssign(self, tasks: List[int], workers: List[int], pills: int, strength: int) -> int:\\n        \\n        tasks.sort()\\n        workers.sort()\\n        \\n        def can_finish(mid, pills):\\n            \\n            n = len(workers)\\n            \\n            i = 0\\n            \\n            # record the mid valid tasks\\n            queue = deque()\\n            \\n            for j in range(n - mid, n):\\n                \\n                w = workers[j]\\n                \\n                # put m tasks into the queue\\n                while i < mid and tasks[i] <= w + strength:\\n                    queue.append(tasks[i])\\n                    i += 1\\n                \\n                # Now we have found the eligible at most m tasks that workers[j] can finish\\n                # and have put these tasks into the queue\\n                \\n                \\n                # below are to find the most smallest strength task that workers[j] can finish\\n                \\n                # First check, if no tasks were added, this means workers[j] can finish nothing\\n                if not queue:\\n                    return False\\n                \\n                # Case 1: if workers[j] can finish task queue[0] without eating pills,\\n                # then this is what we want, that is, the powerful worker finish the smallest task.\\n                if queue[0] <= w:\\n                    queue.popleft()\\n                \\n                # Case 2: if workers[j] needs to eat pills to finish\\n                # Once he needs to eat pill, we choose the hardest task for him\\n                # since the left tasks for the others workers will be easy to finish.\\n                else:\\n                    # need to eat pills\\n                    if pills == 0:\\n                        return False\\n                    \\n                    pills -= 1\\n                    queue.pop()\\n                \\n                # after this loop, it means for the workers[j], \\n                # he can finish the one task that is <= his strength + strength of pills\\n            \\n            return True\\n        \\n        \\n        # standard Binary Search\\n        left = 0\\n        right = min(len(tasks), len(workers))\\n        \\n        while left + 1 < right:\\n            \\n            mid = left + (right - left) // 2\\n            \\n            # this guessing mid number is eligible, \\n            # we can guess larger since we need maximum tasks number\\n            if can_finish(mid, pills):\\n                left = mid\\n                \\n            else:\\n                right = mid - 1\\n        \\n        if can_finish(right, pills):\\n            return right\\n        else:\\n            return left\\n```",
                "solutionTags": [
                    "Python",
                    "Binary Search"
                ],
                "code": "```\\nfrom collections import deque\\nclass Solution:\\n    def maxTaskAssign(self, tasks: List[int], workers: List[int], pills: int, strength: int) -> int:\\n        \\n        tasks.sort()\\n        workers.sort()\\n        \\n        def can_finish(mid, pills):\\n            \\n            n = len(workers)\\n            \\n            i = 0\\n            \\n            # record the mid valid tasks\\n            queue = deque()\\n            \\n            for j in range(n - mid, n):\\n                \\n                w = workers[j]\\n                \\n                # put m tasks into the queue\\n                while i < mid and tasks[i] <= w + strength:\\n                    queue.append(tasks[i])\\n                    i += 1\\n                \\n                # Now we have found the eligible at most m tasks that workers[j] can finish\\n                # and have put these tasks into the queue\\n                \\n                \\n                # below are to find the most smallest strength task that workers[j] can finish\\n                \\n                # First check, if no tasks were added, this means workers[j] can finish nothing\\n                if not queue:\\n                    return False\\n                \\n                # Case 1: if workers[j] can finish task queue[0] without eating pills,\\n                # then this is what we want, that is, the powerful worker finish the smallest task.\\n                if queue[0] <= w:\\n                    queue.popleft()\\n                \\n                # Case 2: if workers[j] needs to eat pills to finish\\n                # Once he needs to eat pill, we choose the hardest task for him\\n                # since the left tasks for the others workers will be easy to finish.\\n                else:\\n                    # need to eat pills\\n                    if pills == 0:\\n                        return False\\n                    \\n                    pills -= 1\\n                    queue.pop()\\n                \\n                # after this loop, it means for the workers[j], \\n                # he can finish the one task that is <= his strength + strength of pills\\n            \\n            return True\\n        \\n        \\n        # standard Binary Search\\n        left = 0\\n        right = min(len(tasks), len(workers))\\n        \\n        while left + 1 < right:\\n            \\n            mid = left + (right - left) // 2\\n            \\n            # this guessing mid number is eligible, \\n            # we can guess larger since we need maximum tasks number\\n            if can_finish(mid, pills):\\n                left = mid\\n                \\n            else:\\n                right = mid - 1\\n        \\n        if can_finish(right, pills):\\n            return right\\n        else:\\n            return left\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1734428,
                "title": "why-binary-search-and-why-not-direct-greedy-approach-explained",
                "content": "greedy approach will not work here why? read below\\n\\ne.x if we prioritize on the basis of workers array , the worker[i] will try to do the work just smaller then its strenght \\nbut the problem occur when a worker can do a task  with and  without a pill :\\n\\nfor e g \\n\\ntask [ 8 5 5 ]\\nworker [ 6 6 4 ]\\npill =1\\nstre = 4\\n\\nans = 3  ( since worker [ 0 ]  can do both task task[ 0 ] with pill and task [1] without pill \\n               but we get optimal answere when we give pill to worker [ 2 ] instead of \\n\\t\\t\\t\\t\\t\\t\\t worker [0] )\\n\\t\\t\\t\\t\\t\\t\\t \\n\\t\\t\\t\\t\\t\\t\\t \\n\\t\\t\\t\\t\\t\\t\\t other eaxmple;\\n\\t\\ntask [  10 5 4 ]\\nworker [ 7 6 4 ]\\npill =1\\nstre = 3\\n\\nans= 3  ( since worker [ 0 ]  can do both task task[ 0 ] with pill and task [1] without pill \\n               but we get optimal answere when we we give pill to worker [ 0 ])\\n\\t\\t\\t\\t\\t\\t\\t \\n these 2 example are contradiction to each other in one we get optimal answere by giving pill to worker 0 and in other by giving pill to  worker 2\\n\\t\\t\\t\\t\\t\\t\\t \\nso this proves prioritizing approach will not work here\\n\\t\\t\\t\\t\\t\\t\\t \\n\\nhow do binary search work \\n\\n   if we sort the array and if kth worker cant do a task with and without a pill its confirm that all worker with strenght less then kth worker will also not we able to do that task;\\n\\t \\n\\t and if we say that k task can be done so we can chosse k strongest workers and k weakest tasks and now we each work have to do its corresponding task so either it will do it on its own or with a help of a pill  workers dont have options now\\n\\t \\n\\tworker [    a    b     c   d    e   ]\\n\\ttask  [   v     x    y    z  ]\\n\\t\\n\\tcan we do 3 tasks so we chosse  worker [ a   b   c]     task    [   x   y   z ]\\n\\t\\n\\tnow each task is to be done else we return false;\\n\\t\\n\\tso if a task can we assigned to a worker we assign it else we subtract pill strength from task and assign it to a optimal worker ( that is the weakest worker capable of doing the task)\\n\\t\\n\\t\\n\\t\\n`class Solution {\\n   public:\\n     bool solver(vector<int>& t, vector<int>& w,int m,int p,int s)\\n    {\\n       int k=w.size();\\n        \\n        multiset<int>st(w.begin()+k-m,w.end());\\n        \\n        for(int i=m-1;i>=0;i--)\\n        {\\n           auto it=st.end();\\n            it--;\\n            if(*it<t[i])\\n            {\\n               auto temp=st.lower_bound(t[i]-s);\\n                if(!p || temp==st.end())\\n                  return false;\\n                else\\n                {\\n                   p--;\\n                    st.erase(temp);\\n                }\\n            }\\n            else\\n               st.erase(it);\\n            \\n        }\\n        return true;\\n    }\\n    int maxTaskAssign(vector<int>& tasks, vector<int>& work, int pill, int s) {\\n        \\n        int l=0;\\n        \\n        int r=min(tasks.size(),work.size());\\n        \\n        int n=work.size();\\n        sort(tasks.begin(),tasks.end());\\n        sort(work.begin(),work.end());\\n        \\n        int ans=0;\\n        \\n        while(l<=r)\\n        {\\n            int m=(l+r)/2;\\n            bool flag=true;\\n            \\n             multiset<int>st(work.begin()+n-m,work.end());\\n        int p=pill;\\n        for(int i=m-1;i>=0;i--)\\n        {\\n            auto it=st.end();\\n            it--;\\n            \\n            \\n            if(*it<tasks[i])\\n            {\\n                auto temp=st.lower_bound(tasks[i]-s);\\n                if(!p || temp==st.end())\\n                {\\n                    flag=false;\\n                    break;\\n                }\\n                else\\n                {\\n                    p--;\\n                    st.erase(temp);\\n                }\\n            }\\n            else\\n               st.erase(it);\\n            \\n        }\\n        \\n            \\n            if(flag)\\n            {\\n                l=m+1;\\n                ans=max(m,ans);\\n            }\\n            else\\n                r=m-1;\\n        }\\n        \\n        return ans;\\n    }\\n};`\\n\\t\\t\\t\\t\\t\\t\\t \\t\\n\\t\\t\\t\\t\\t\\t\\t",
                "solutionTags": [],
                "code": "class Solution {\\n   public:\\n     bool solver(vector<int>& t, vector<int>& w,int m,int p,int s)\\n    {\\n       int k=w.size();\\n        \\n        multiset<int>st(w.begin()+k-m,w.end());\\n        \\n        for(int i=m-1;i>=0;i--)\\n        {\\n           auto it=st.end();\\n            it--;\\n            if(*it<t[i])\\n            {\\n               auto temp=st.lower_bound(t[i]-s);\\n                if(!p || temp==st.end())\\n                  return false;\\n                else\\n                {\\n                   p--;\\n                    st.erase(temp);\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 1626078,
                "title": "python-binary-search-with-double-deque-to-trace-available-workers",
                "content": "Explained in the comments:\\n```\\nclass Solution:\\n    def maxTaskAssign(self, tasks: List[int], workers: List[int], pills: int, strength: int) -> int:\\n        tasks = list(sorted(tasks))\\n        workers = list(sorted(workers))\\n        WN = len(workers)\\n        \\n        # to evaluate if k tasks can be done, we just need to check if the strongest k workers \\n        # can finish the k smallest tasks\\n        def canDo(k: int) -> bool:\\n            ps = pills\\n            # wq stores the k strongest workers in desc order\\n            wq = deque(workers[WN - k:][::-1])\\n            # available stores workers which can do the current task with pill help\\n            available = deque()\\n            for t in tasks[:k][::-1]:\\n                while wq and wq[0] + strength >= t:\\n                    available.append(wq.popleft())\\n                if not available:\\n                    return False\\n                if available[0] >= t:   # no need to use pill\\n                    available.popleft()\\n                elif ps > 0:\\n                    # when pill is needed, use the weakest available worker\\n                    ps -= 1\\n                    available.pop() \\n                else:\\n                    return False\\n            return True\\n        \\n        N = len(tasks)\\n        l, r = 0, N\\n        while l <= r:\\n            mid = l + r >> 1\\n            if canDo(mid):\\n                l = mid + 1\\n            else:\\n                r = mid - 1\\n        return r\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def maxTaskAssign(self, tasks: List[int], workers: List[int], pills: int, strength: int) -> int:\\n        tasks = list(sorted(tasks))\\n        workers = list(sorted(workers))\\n        WN = len(workers)\\n        \\n        # to evaluate if k tasks can be done, we just need to check if the strongest k workers \\n        # can finish the k smallest tasks\\n        def canDo(k: int) -> bool:\\n            ps = pills\\n            # wq stores the k strongest workers in desc order\\n            wq = deque(workers[WN - k:][::-1])\\n            # available stores workers which can do the current task with pill help\\n            available = deque()\\n            for t in tasks[:k][::-1]:\\n                while wq and wq[0] + strength >= t:\\n                    available.append(wq.popleft())\\n                if not available:\\n                    return False\\n                if available[0] >= t:   # no need to use pill\\n                    available.popleft()\\n                elif ps > 0:\\n                    # when pill is needed, use the weakest available worker\\n                    ps -= 1\\n                    available.pop() \\n                else:\\n                    return False\\n            return True\\n        \\n        N = len(tasks)\\n        l, r = 0, N\\n        while l <= r:\\n            mid = l + r >> 1\\n            if canDo(mid):\\n                l = mid + 1\\n            else:\\n                r = mid - 1\\n        return r\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1585683,
                "title": "python-binary-search-faster-than-100-easy-to-understand-with-explanation",
                "content": "```\\nclass Solution(object):\\n    def maxTaskAssign(self, tasks, workers, pills, strength):\\n        def canAssignAll(tasks, workers, pills):\\n            #  notice that len(tasks) = len(workers)\\n            #  given pills and strength, can all tasks be assigned, so that every worker has a task.\\n            while len(tasks) and len(workers):\\n                if workers[-1] >= tasks[-1]:\\n                    #  from the max task to the min, if current max worker can do the current max task, \\n                    #  assign the max task to the max worker.\\n                    workers.pop()\\n                    tasks.pop()\\n                elif pills > 0:\\n                    #  if current max worker cannot do the current max task, someone should eat a pill to try, but it is\\n                    #  no need that the current max worker goes to eat the pill, it\\'s not greedy. we need to find the \\n                    #  greedy worker who is the min one can do the current max task after eat a pill, and assign it to \\n                    #  him.\\n                    pills -= 1\\n                    j = bisect.bisect_left(workers, tasks[-1] - strength)\\n                    if j >= len(workers):\\n                        # it means even the current max worker cannot do the current max task after eat a pill.\\n                        return False\\n                    workers.pop(j)\\n                    tasks.pop()\\n                else:  # it means the current max worker cannot do the current max task, and no pill left.\\n                    return False\\n            return True\\n\\n        tasks.sort()\\n        workers.sort()\\n        # standard binary search\\n        low, high = 0, min(len(tasks), len(workers))\\n        while low <= high:\\n            mid = (low + high) // 2\\n            if canAssignAll(tasks[:mid], workers[-mid:], pills):\\n\\t\\t\\t    #  try assign mid easiest tasks to mid strongest workers, it\\'s a naive greedy strategy.\\n                low = mid + 1\\n            else:\\n                high = mid - 1\\n        return high\\n```\\n**If you have any questoins, feel free to ask. If you like the solution and explanation, please upvote!**",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def maxTaskAssign(self, tasks, workers, pills, strength):\\n        def canAssignAll(tasks, workers, pills):\\n            #  notice that len(tasks) = len(workers)\\n            #  given pills and strength, can all tasks be assigned, so that every worker has a task.\\n            while len(tasks) and len(workers):\\n                if workers[-1] >= tasks[-1]:\\n                    #  from the max task to the min, if current max worker can do the current max task, \\n                    #  assign the max task to the max worker.\\n                    workers.pop()\\n                    tasks.pop()\\n                elif pills > 0:\\n                    #  if current max worker cannot do the current max task, someone should eat a pill to try, but it is\\n                    #  no need that the current max worker goes to eat the pill, it\\'s not greedy. we need to find the \\n                    #  greedy worker who is the min one can do the current max task after eat a pill, and assign it to \\n                    #  him.\\n                    pills -= 1\\n                    j = bisect.bisect_left(workers, tasks[-1] - strength)\\n                    if j >= len(workers):\\n                        # it means even the current max worker cannot do the current max task after eat a pill.\\n                        return False\\n                    workers.pop(j)\\n                    tasks.pop()\\n                else:  # it means the current max worker cannot do the current max task, and no pill left.\\n                    return False\\n            return True\\n\\n        tasks.sort()\\n        workers.sort()\\n        # standard binary search\\n        low, high = 0, min(len(tasks), len(workers))\\n        while low <= high:\\n            mid = (low + high) // 2\\n            if canAssignAll(tasks[:mid], workers[-mid:], pills):\\n\\t\\t\\t    #  try assign mid easiest tasks to mid strongest workers, it\\'s a naive greedy strategy.\\n                low = mid + 1\\n            else:\\n                high = mid - 1\\n        return high\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1575983,
                "title": "java-binarysearch-treemap-greedy",
                "content": "Time : O(logn * max(nlogn, mlogm))\\nConstant Constraint is too high. Need to submit multiple times to get AC\\n\\n\\n```\\nclass Solution {\\n    public int maxTaskAssign(int[] A, int[] B, int cnt, int add) {\\n        Arrays.sort(A);\\n        Arrays.sort(B);\\n        int l = 0, r = A.length-1;\\n        int res = -1;\\n        while(l<=r){\\n            int mid = l +(r-l)/2;\\n            if(check(A,B,cnt,add,mid)){\\n                res=mid;\\n                l=mid+1;\\n            }else{\\n                r=mid-1;\\n            }\\n        }\\n        \\n        return res+1;\\n    }\\n    \\n    public boolean check(int A[],int B[],int cnt,int add,int mid){\\n        TreeMap<Integer,Integer>tree=new TreeMap<>();\\n        int j = B.length-1;\\n        \\n        for(int i = mid; i >=0; i--){\\n            while(j>=0&&B[j]>=A[i]){\\n                add(tree,B[j]);\\n                j--;\\n            }\\n            \\n            Integer ceil = tree.ceilingKey(A[i]);\\n            if(ceil!=null){\\n                del(tree,ceil);\\n            }\\n            else{\\n                if(cnt>0){\\n                    while(j>=0&&B[j]+add>=A[i]){\\n                        add(tree,B[j]);\\n                        j--;\\n                    }\\n                    \\n                    ceil = tree.ceilingKey(A[i]-add);\\n                    if(ceil!=null){\\n                        cnt--;\\n                        del(tree,ceil);\\n                    }\\n                    else{\\n                        return false;\\n                    }\\n                }\\n                else{\\n                    return false;\\n                }\\n                \\n            }\\n        }\\n        return true;\\n    }\\n    \\n    public void add(TreeMap<Integer,Integer>tree,int k){\\n        if(!tree.containsKey(k))tree.put(k,0);\\n        tree.put(k,tree.get(k)+1);\\n    }\\n    \\n    public void del(TreeMap<Integer,Integer>tree,int k){\\n        tree.put(k,tree.get(k)-1);\\n        if(tree.get(k)==0)tree.remove(k);\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int maxTaskAssign(int[] A, int[] B, int cnt, int add) {\\n        Arrays.sort(A);\\n        Arrays.sort(B);\\n        int l = 0, r = A.length-1;\\n        int res = -1;\\n        while(l<=r){\\n            int mid = l +(r-l)/2;\\n            if(check(A,B,cnt,add,mid)){\\n                res=mid;\\n                l=mid+1;\\n            }else{\\n                r=mid-1;\\n            }\\n        }\\n        \\n        return res+1;\\n    }\\n    \\n    public boolean check(int A[],int B[],int cnt,int add,int mid){\\n        TreeMap<Integer,Integer>tree=new TreeMap<>();\\n        int j = B.length-1;\\n        \\n        for(int i = mid; i >=0; i--){\\n            while(j>=0&&B[j]>=A[i]){\\n                add(tree,B[j]);\\n                j--;\\n            }\\n            \\n            Integer ceil = tree.ceilingKey(A[i]);\\n            if(ceil!=null){\\n                del(tree,ceil);\\n            }\\n            else{\\n                if(cnt>0){\\n                    while(j>=0&&B[j]+add>=A[i]){\\n                        add(tree,B[j]);\\n                        j--;\\n                    }\\n                    \\n                    ceil = tree.ceilingKey(A[i]-add);\\n                    if(ceil!=null){\\n                        cnt--;\\n                        del(tree,ceil);\\n                    }\\n                    else{\\n                        return false;\\n                    }\\n                }\\n                else{\\n                    return false;\\n                }\\n                \\n            }\\n        }\\n        return true;\\n    }\\n    \\n    public void add(TreeMap<Integer,Integer>tree,int k){\\n        if(!tree.containsKey(k))tree.put(k,0);\\n        tree.put(k,tree.get(k)+1);\\n    }\\n    \\n    public void del(TreeMap<Integer,Integer>tree,int k){\\n        tree.put(k,tree.get(k)-1);\\n        if(tree.get(k)==0)tree.remove(k);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2759471,
                "title": "javascript-binary-search-deque",
                "content": "**Solution: Binary Search & Deque**\\n\\nBinary search for the largest number of tasks that can be completed.\\nHow to check whether we can complete k tasks:\\n*   Try to assign the k weakest tasks to the k strongest workers.\\n*   Sort tasks in asc order and workers in desc order.\\n*   Go through the workers from weakest to strongest,\\n\\t*   Try to assign the easiest task to the worker (without using a pill).\\n\\t\\t*    If it can be assigned, assign it. (If the easiest task can be done by the worker, that means all following workers will be able to do it without a pill. Therefore, it is optimal for the current task to complete the easiest task)\\n\\t\\t*   Otherwise, try to do the hardest possible task after using a pill.\\n*    Keep track of the tasks that are assignable after using a pill in a deque so that we can remove tasks both on the left and right.\\n    If we can\\'t assign any task to the worker, return false (we can\\'t complete k tasks).\\n\\n`n = number of tasks`, `m = number of workers`\\nTime Complexity: `O(n log(n) + m log(m))` 479ms\\nSpace Complexity: `O(m)` 65.7MB\\n```\\nvar maxTaskAssign = function(tasks, workers, pills, strength) {\\n  let m = workers.length;\\n  tasks.sort((a, b) => a - b);\\n  workers.sort((a, b) => b - a);\\n  let low = 0, high = m;\\n  while (low < high) {\\n    let mid = Math.ceil((low + high) / 2);\\n    if (canAssign(mid)) low = mid;\\n    else high = mid - 1;\\n  }\\n  return low;\\n  \\n  function canAssign(k) {\\n    let queue = new Deque(), pillsUsed = 0;\\n    for (let j = k - 1, i = 0; j >= 0; j--) {\\n      while (i < k && workers[j] + strength >= tasks[i]) {\\n        queue.push(tasks[i++]);\\n      }\\n      if (queue.isEmpty()) return false; // no do-able tasks\\n      if (queue.front() <= workers[j]) { // do the easiest task without using pill\\n        queue.shift();\\n      } else if (pillsUsed === pills) { \\n        return false;\\n      } else { // do the hardest task after using a pill\\n        pillsUsed++;\\n        queue.pop();\\n      }\\n    }\\n    return true;\\n  }\\n};\\n\\nclass Deque {\\n  constructor() {\\n    this.head = new Node(null);\\n    this.tail = new Node(null);\\n    this.head.next = this.tail;\\n    this.tail.prev = this.head;\\n    this.size = 0;\\n  }\\n  unshift(val) {\\n    let node = new Node(val);\\n    node.next = this.head.next;\\n    node.prev = this.head;\\n    this.head.next.prev = node;\\n    this.head.next = node;\\n    this.size++;\\n  }\\n  push(val) {\\n    let node = new Node(val);\\n    node.prev = this.tail.prev;\\n    node.next = this.tail;\\n    this.tail.prev.next = node;\\n    this.tail.prev = node;\\n    this.size++;\\n  }\\n  shift() {\\n    let head = this.head.next;\\n    this.removeNode(head);\\n    this.size--;\\n    return head.val;\\n  }\\n  pop() {\\n    let tail = this.tail.prev;\\n    this.removeNode(tail);\\n    this.size--;\\n    return tail.val;\\n  }\\n  removeNode(node) {\\n    if (!node.prev && !node.next) return;\\n    node.prev.next = node.next;\\n    node.next.prev = node.prev;\\n    node.prev = null;\\n    node.next = null;\\n  }\\n  front() {\\n    return this.head.next.val;\\n  }\\n  back() {\\n    return this.tail.prev.val;\\n  }\\n  isEmpty() {\\n    return this.size === 0;\\n  }\\n}\\nclass Node {\\n  constructor(val) {\\n    this.val = val;\\n    this.next = null;\\n    this.prev = null;\\n  }\\n}\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar maxTaskAssign = function(tasks, workers, pills, strength) {\\n  let m = workers.length;\\n  tasks.sort((a, b) => a - b);\\n  workers.sort((a, b) => b - a);\\n  let low = 0, high = m;\\n  while (low < high) {\\n    let mid = Math.ceil((low + high) / 2);\\n    if (canAssign(mid)) low = mid;\\n    else high = mid - 1;\\n  }\\n  return low;\\n  \\n  function canAssign(k) {\\n    let queue = new Deque(), pillsUsed = 0;\\n    for (let j = k - 1, i = 0; j >= 0; j--) {\\n      while (i < k && workers[j] + strength >= tasks[i]) {\\n        queue.push(tasks[i++]);\\n      }\\n      if (queue.isEmpty()) return false; // no do-able tasks\\n      if (queue.front() <= workers[j]) { // do the easiest task without using pill\\n        queue.shift();\\n      } else if (pillsUsed === pills) { \\n        return false;\\n      } else { // do the hardest task after using a pill\\n        pillsUsed++;\\n        queue.pop();\\n      }\\n    }\\n    return true;\\n  }\\n};\\n\\nclass Deque {\\n  constructor() {\\n    this.head = new Node(null);\\n    this.tail = new Node(null);\\n    this.head.next = this.tail;\\n    this.tail.prev = this.head;\\n    this.size = 0;\\n  }\\n  unshift(val) {\\n    let node = new Node(val);\\n    node.next = this.head.next;\\n    node.prev = this.head;\\n    this.head.next.prev = node;\\n    this.head.next = node;\\n    this.size++;\\n  }\\n  push(val) {\\n    let node = new Node(val);\\n    node.prev = this.tail.prev;\\n    node.next = this.tail;\\n    this.tail.prev.next = node;\\n    this.tail.prev = node;\\n    this.size++;\\n  }\\n  shift() {\\n    let head = this.head.next;\\n    this.removeNode(head);\\n    this.size--;\\n    return head.val;\\n  }\\n  pop() {\\n    let tail = this.tail.prev;\\n    this.removeNode(tail);\\n    this.size--;\\n    return tail.val;\\n  }\\n  removeNode(node) {\\n    if (!node.prev && !node.next) return;\\n    node.prev.next = node.next;\\n    node.next.prev = node.prev;\\n    node.prev = null;\\n    node.next = null;\\n  }\\n  front() {\\n    return this.head.next.val;\\n  }\\n  back() {\\n    return this.tail.prev.val;\\n  }\\n  isEmpty() {\\n    return this.size === 0;\\n  }\\n}\\nclass Node {\\n  constructor(val) {\\n    this.val = val;\\n    this.next = null;\\n    this.prev = null;\\n  }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2152736,
                "title": "c-binary-search-noob-friendly",
                "content": "```\\nclass Solution {\\npublic:\\n    bool isPossible(int noOfTasks,vector<int>& tasks, vector<int>& workers, int pills, int strength){\\n        multiset <int> ms(workers.end()-noOfTasks,workers.end());\\n        for(int i=noOfTasks-1;i>=0;i--){\\n            //get the strongest worker\\n            auto it = ms.end();\\n            it--;\\n            \\n            //if the strongest worker cannot do the task\\n            if(*it<tasks[i]){\\n                if(pills<=0)\\n                    return false;\\n                //find the weakest worker who is just able to do the task with pill\\n                it=ms.lower_bound(tasks[i]-strength);\\n                if(it==ms.end())\\n                    return false;\\n                \\n                //task done decrese the pill\\n                pills--;\\n            }\\n            //remove the worker from the multiset\\n            ms.erase(it);\\n        }\\n        return true;\\n        \\n    }  \\n    int maxTaskAssign(vector<int>& tasks, vector<int>& workers, int pills, int strength) {\\n        int l=0,r= min(tasks.size(),workers.size());\\n        int res=0;\\n        sort(tasks.begin(),tasks.end());\\n        sort(workers.begin(),workers.end());\\n        while(l<=r){\\n            int mid= (l+r)/2;\\n            if(isPossible(mid,tasks,workers,pills,strength)){\\n                res=mid;\\n                l=mid+1;\\n            }else{\\n                r=mid-1;\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Greedy",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isPossible(int noOfTasks,vector<int>& tasks, vector<int>& workers, int pills, int strength){\\n        multiset <int> ms(workers.end()-noOfTasks,workers.end());\\n        for(int i=noOfTasks-1;i>=0;i--){\\n            //get the strongest worker\\n            auto it = ms.end();\\n            it--;\\n            \\n            //if the strongest worker cannot do the task\\n            if(*it<tasks[i]){\\n                if(pills<=0)\\n                    return false;\\n                //find the weakest worker who is just able to do the task with pill\\n                it=ms.lower_bound(tasks[i]-strength);\\n                if(it==ms.end())\\n                    return false;\\n                \\n                //task done decrese the pill\\n                pills--;\\n            }\\n            //remove the worker from the multiset\\n            ms.erase(it);\\n        }\\n        return true;\\n        \\n    }  \\n    int maxTaskAssign(vector<int>& tasks, vector<int>& workers, int pills, int strength) {\\n        int l=0,r= min(tasks.size(),workers.size());\\n        int res=0;\\n        sort(tasks.begin(),tasks.end());\\n        sort(workers.begin(),workers.end());\\n        while(l<=r){\\n            int mid= (l+r)/2;\\n            if(isPossible(mid,tasks,workers,pills,strength)){\\n                res=mid;\\n                l=mid+1;\\n            }else{\\n                r=mid-1;\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1600510,
                "title": "java-easy-solution-explanation",
                "content": "**Approach:**\\n**1. So we know that the min task that can be done is 0 and the max task that can be done is min size between worker or tasks. \\n2. Sort both arrays now using binary search  we need to find that a whether he is able to complete task(low+high)/2 or not if he is able to complete that task then try for some other task that comes in range (low+1,high)\\n3. If the person with max strength  is not able to complete the task(mid) then try to complete task using pill and for that just feed the pill to the worker with the least strength so that he can complete the task (mid) .**\\n```\\nclass Solution {\\n    static int firstPowerguy(int w[],int s,int reqstrength){\\n        for(int i=0;i<w.length;i++){\\n            if(w[i]==-1)\\n                continue;\\n            else if(w[i]+s>=reqstrength){\\n                return i;\\n            }\\n        }\\n        return -1;\\n    }\\n    static boolean canThisMuchTaskBeDone(int mid,int workers[],int tasks[],int pills,int strength){\\n       //lets find can i do mid task or not\\n        int end=workers.length-1;\\n       // System.out.println(mid);\\n        while(mid>0){\\n            if(workers[end]==-1){\\n                end--;\\n                continue;\\n            }\\n           if(tasks[mid-1]<=workers[end]){\\n                end--;\\n                mid--;\\n           }\\n            else{\\n               if(pills<=0)\\n                   return false;\\n                else{\\n                   \\n                    int ind=firstPowerguy(workers,strength,tasks[mid-1]);\\n                   // System.out.println(\"pow\"+ind);\\n                    if(ind!=-1){\\n                        pills--;\\n                        tasks[mid-1]=-1;\\n                        mid--;\\n                        workers[ind]=-1;\\n                        \\n                    }\\n                    else{\\n                        return false;\\n                    }\\n                }\\n            }        \\n       }\\n        return true;\\n    }\\n    public int maxTaskAssign(int[] tasks, int[] workers, int pills, int strength) {\\n        int low=0;\\n        int high=Math.min(tasks.length,workers.length);\\n        Arrays.sort(tasks);\\n        Arrays.sort(workers);\\n        int ans=0;\\n        while(low<=high){\\n            int mid=(low+high)/2;\\n\\t\\t\\t//mid represent the task and we are finding if he can complete mid task or not\\n           // System.out.println(\"midd \"+mid);\\n             int wc[]=Arrays.copyOf(workers,workers.length);\\n             int tc[]=Arrays.copyOf(tasks,tasks.length);\\n           if(canThisMuchTaskBeDone(mid,wc,tc,pills,strength)){\\n                low=mid+1;      \\n                ans=mid;\\n           }    \\n         else{\\n                high=mid-1;\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Greedy",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\n    static int firstPowerguy(int w[],int s,int reqstrength){\\n        for(int i=0;i<w.length;i++){\\n            if(w[i]==-1)\\n                continue;\\n            else if(w[i]+s>=reqstrength){\\n                return i;\\n            }\\n        }\\n        return -1;\\n    }\\n    static boolean canThisMuchTaskBeDone(int mid,int workers[],int tasks[],int pills,int strength){\\n       //lets find can i do mid task or not\\n        int end=workers.length-1;\\n       // System.out.println(mid);\\n        while(mid>0){\\n            if(workers[end]==-1){\\n                end--;\\n                continue;\\n            }\\n           if(tasks[mid-1]<=workers[end]){\\n                end--;\\n                mid--;\\n           }\\n            else{\\n               if(pills<=0)\\n                   return false;\\n                else{\\n                   \\n                    int ind=firstPowerguy(workers,strength,tasks[mid-1]);\\n                   // System.out.println(\"pow\"+ind);\\n                    if(ind!=-1){\\n                        pills--;\\n                        tasks[mid-1]=-1;\\n                        mid--;\\n                        workers[ind]=-1;\\n                        \\n                    }\\n                    else{\\n                        return false;\\n                    }\\n                }\\n            }        \\n       }\\n        return true;\\n    }\\n    public int maxTaskAssign(int[] tasks, int[] workers, int pills, int strength) {\\n        int low=0;\\n        int high=Math.min(tasks.length,workers.length);\\n        Arrays.sort(tasks);\\n        Arrays.sort(workers);\\n        int ans=0;\\n        while(low<=high){\\n            int mid=(low+high)/2;\\n\\t\\t\\t//mid represent the task and we are finding if he can complete mid task or not\\n           // System.out.println(\"midd \"+mid);\\n             int wc[]=Arrays.copyOf(workers,workers.length);\\n             int tc[]=Arrays.copyOf(tasks,tasks.length);\\n           if(canThisMuchTaskBeDone(mid,wc,tc,pills,strength)){\\n                low=mid+1;      \\n                ans=mid;\\n           }    \\n         else{\\n                high=mid-1;\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1590756,
                "title": "c-greedy-without-binary-search",
                "content": "I would say binary search is a much better solution... but still it\\'s possible to use greedy only.\\n\\n1. Sort `tasks` in increasing order. Put `workers` in a set `st` as a pool of candidate workers.\\n2. Keep a set `taken` of workers which have taken a pill to match a task.\\n3. Loop through `tasks` from biggest to smallest. Find a matching worker by:\\n\\ta. Use the biggest one in `st` if it can do it without a pill.\\n\\tb. Find the smallest one in `st` that can do it with a pill.\\n\\tc. If there is no such one from #b, and the biggest in `taken` can do current task without a pill, it should be changed to do current task and yield the pill it has taken.\\n\\td. If there is one from #b, and there are pills left, feed it a pill.\\n\\te. If there is one from #b, but there is no pill left. Compare the largest in `taken`, the one from #b, and current task to decide which one should take the pill and which one should be put into `st`.\\n\\n```cpp\\nclass Solution {\\npublic:\\n    int maxTaskAssign(vector<int>& tasks, vector<int>& workers, int pills, int strength) {\\n        sort(tasks.begin(), tasks.end());\\n        multiset<int> st(workers.begin(), workers.end());\\n        multiset<int> taken;\\n        int n = tasks.size(), m = workers.size();\\n        int res = 0;\\n        for (int i = n - 1; i >= 0 && !st.empty(); --i) {\\n            if (*st.rbegin() >= tasks[i]) {\\n                ++res;\\n                st.erase(prev(st.end()));\\n                continue;\\n            }\\n            auto it = st.lower_bound(tasks[i] - strength);\\n            if (it == st.end()) {\\n                if (!taken.empty() && *taken.rbegin() >= tasks[i]) {\\n                    taken.erase(prev(taken.end()));\\n                    ++pills;\\n                }\\n                continue;\\n            }\\n            if (pills == 0) {\\n                if (taken.empty()) {\\n                    continue;\\n                }\\n                if (*taken.rbegin() >= tasks[i]) {\\n                    ++pills;\\n                    taken.erase(prev(taken.end()));\\n                } else {\\n                    int ma = max(*it, *taken.rbegin());\\n                    int mi = min(*it, *taken.rbegin());\\n                    taken.erase(prev(taken.end()));\\n                    taken.insert(mi);\\n                    st.erase(it);\\n                    st.insert(ma);\\n                }\\n                continue;\\n            }\\n            taken.insert(*it);\\n            st.erase(it);\\n            ++res;\\n            --pills;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```cpp\\nclass Solution {\\npublic:\\n    int maxTaskAssign(vector<int>& tasks, vector<int>& workers, int pills, int strength) {\\n        sort(tasks.begin(), tasks.end());\\n        multiset<int> st(workers.begin(), workers.end());\\n        multiset<int> taken;\\n        int n = tasks.size(), m = workers.size();\\n        int res = 0;\\n        for (int i = n - 1; i >= 0 && !st.empty(); --i) {\\n            if (*st.rbegin() >= tasks[i]) {\\n                ++res;\\n                st.erase(prev(st.end()));\\n                continue;\\n            }\\n            auto it = st.lower_bound(tasks[i] - strength);\\n            if (it == st.end()) {\\n                if (!taken.empty() && *taken.rbegin() >= tasks[i]) {\\n                    taken.erase(prev(taken.end()));\\n                    ++pills;\\n                }\\n                continue;\\n            }\\n            if (pills == 0) {\\n                if (taken.empty()) {\\n                    continue;\\n                }\\n                if (*taken.rbegin() >= tasks[i]) {\\n                    ++pills;\\n                    taken.erase(prev(taken.end()));\\n                } else {\\n                    int ma = max(*it, *taken.rbegin());\\n                    int mi = min(*it, *taken.rbegin());\\n                    taken.erase(prev(taken.end()));\\n                    taken.insert(mi);\\n                    st.erase(it);\\n                    st.insert(ma);\\n                }\\n                continue;\\n            }\\n            taken.insert(*it);\\n            st.erase(it);\\n            ++res;\\n            --pills;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1581896,
                "title": "golang-binary-search-greedy-check",
                "content": "```\\nfunc maxTaskAssign(tasks []int, workers []int, pills int, strength int) int {\\n    sort.Ints(tasks)\\n    sort.Ints(workers)\\n\\n    l, h := 0, min(len(tasks), len(workers))\\n    for l <= h {\\n        m := (l + h) / 2\\n        if check(tasks[0:m], workers[len(workers)-m:], pills, strength) {\\n            l = m + 1\\n        } else {\\n            h = m - 1\\n        }\\n    }\\n    return l-1\\n}\\n\\nfunc check(tasks, workers []int, pills, strength int) bool {\\n    n := len(tasks)\\n    used := make([]bool, n)\\n    availableTasks := newDeque(n) // tasks that can be done by current worker (some may require using pill)\\n\\n    for workerIdx, taskIdx, maxTaskIdx := 0, 0, 0; workerIdx < n; workerIdx++ {\\n        // skip done tasks\\n        for ; used[taskIdx]; taskIdx++ {\\n        }\\n\\n        // update queue of available tasks\\n        for ; maxTaskIdx < n && workers[workerIdx] + strength >= tasks[maxTaskIdx]; maxTaskIdx++ {\\n            availableTasks.pushBack(maxTaskIdx)\\n        }\\n        for !availableTasks.empty() && availableTasks.front() < taskIdx {\\n            availableTasks.popFront()\\n        }\\n\\n        // do the easiest available task or use pill and do the hardest available one\\n        if workers[workerIdx] >= tasks[taskIdx] {\\n            used[taskIdx] = true\\n        } else {\\n            if pills == 0 || availableTasks.empty() {\\n                return false\\n            }\\n            pills--\\n            used[availableTasks.back()] = true\\n            availableTasks.popBack()\\n        }\\n    }\\n    return true\\n}\\n\\nfunc min(i, j int) int {\\n    if i < j {\\n        return i\\n    }\\n    return j\\n}\\n```\\n\\nAnd finally my rather ugly deque implementation:\\n```\\ntype deque struct {\\n    values   []int\\n    frontCur int\\n    backCur  int\\n}\\n\\nfunc newDeque(maxSize int) *deque {\\n    return &deque{\\n        values:   make([]int, maxSize),\\n        frontCur: 0,\\n        backCur:  -1,\\n    }\\n}\\n\\nfunc (d *deque) front() int {\\n    return d.values[d.frontCur]\\n}\\n\\nfunc (d *deque) popFront() {\\n    d.frontCur++\\n}\\n\\nfunc (d *deque) back() int {\\n    return d.values[d.backCur]\\n}\\n\\nfunc (d *deque) pushBack(x int) {\\n    d.backCur++\\n    d.values[d.backCur] = x\\n}\\n\\nfunc (d *deque) popBack() {\\n    d.backCur--\\n}\\n\\nfunc (d deque) empty() bool {\\n    return d.frontCur > d.backCur\\n}\\n```",
                "solutionTags": [
                    "Go",
                    "Binary Search"
                ],
                "code": "```\\nfunc maxTaskAssign(tasks []int, workers []int, pills int, strength int) int {\\n    sort.Ints(tasks)\\n    sort.Ints(workers)\\n\\n    l, h := 0, min(len(tasks), len(workers))\\n    for l <= h {\\n        m := (l + h) / 2\\n        if check(tasks[0:m], workers[len(workers)-m:], pills, strength) {\\n            l = m + 1\\n        } else {\\n            h = m - 1\\n        }\\n    }\\n    return l-1\\n}\\n\\nfunc check(tasks, workers []int, pills, strength int) bool {\\n    n := len(tasks)\\n    used := make([]bool, n)\\n    availableTasks := newDeque(n) // tasks that can be done by current worker (some may require using pill)\\n\\n    for workerIdx, taskIdx, maxTaskIdx := 0, 0, 0; workerIdx < n; workerIdx++ {\\n        // skip done tasks\\n        for ; used[taskIdx]; taskIdx++ {\\n        }\\n\\n        // update queue of available tasks\\n        for ; maxTaskIdx < n && workers[workerIdx] + strength >= tasks[maxTaskIdx]; maxTaskIdx++ {\\n            availableTasks.pushBack(maxTaskIdx)\\n        }\\n        for !availableTasks.empty() && availableTasks.front() < taskIdx {\\n            availableTasks.popFront()\\n        }\\n\\n        // do the easiest available task or use pill and do the hardest available one\\n        if workers[workerIdx] >= tasks[taskIdx] {\\n            used[taskIdx] = true\\n        } else {\\n            if pills == 0 || availableTasks.empty() {\\n                return false\\n            }\\n            pills--\\n            used[availableTasks.back()] = true\\n            availableTasks.popBack()\\n        }\\n    }\\n    return true\\n}\\n\\nfunc min(i, j int) int {\\n    if i < j {\\n        return i\\n    }\\n    return j\\n}\\n```\n```\\ntype deque struct {\\n    values   []int\\n    frontCur int\\n    backCur  int\\n}\\n\\nfunc newDeque(maxSize int) *deque {\\n    return &deque{\\n        values:   make([]int, maxSize),\\n        frontCur: 0,\\n        backCur:  -1,\\n    }\\n}\\n\\nfunc (d *deque) front() int {\\n    return d.values[d.frontCur]\\n}\\n\\nfunc (d *deque) popFront() {\\n    d.frontCur++\\n}\\n\\nfunc (d *deque) back() int {\\n    return d.values[d.backCur]\\n}\\n\\nfunc (d *deque) pushBack(x int) {\\n    d.backCur++\\n    d.values[d.backCur] = x\\n}\\n\\nfunc (d *deque) popBack() {\\n    d.backCur--\\n}\\n\\nfunc (d deque) empty() bool {\\n    return d.frontCur > d.backCur\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1577582,
                "title": "nlgn-greedy-solution-can-pass-all-tests-but-i-m-not-sure-it-s-correct",
                "content": "```\\n    public int maxTaskAssign(int[] tasks, int[] workers, int pills, int strength) {\\n        Arrays.sort(tasks);\\n        Arrays.sort(workers);\\n        boolean[]usedWorkerInFirstRound=new boolean[workers.length];\\n        int maxPossibleUsedTaskLen=Math.min(tasks.length,workers.length);\\n        int curToJudgeWorkIndex=0;\\n        for(int i=0;i<maxPossibleUsedTaskLen;i++){\\n            while (curToJudgeWorkIndex<workers.length&&workers[curToJudgeWorkIndex]<tasks[i]){\\n                curToJudgeWorkIndex++;\\n            }\\n            if(curToJudgeWorkIndex==workers.length){\\n                break;\\n            }\\n            usedWorkerInFirstRound[curToJudgeWorkIndex]=true;\\n            curToJudgeWorkIndex++;\\n        }\\n        for (int i=workers.length-1;i>=0;i--){\\n            if(pills==0){\\n                break;\\n            }\\n            if(!usedWorkerInFirstRound[i]){\\n                workers[i]+=strength;\\n                pills--;\\n            }\\n        }\\n        for (int i=workers.length-1;i>=0;i--){\\n            if(pills==0){\\n                break;\\n            }\\n            if(usedWorkerInFirstRound[i]){\\n                workers[i]+=strength;\\n                pills--;\\n            }\\n        }\\n        Arrays.sort(workers);\\n        int res=0;\\n        curToJudgeWorkIndex=0;\\n        for(int i=0;i<maxPossibleUsedTaskLen;i++){\\n            while (curToJudgeWorkIndex<workers.length&&workers[curToJudgeWorkIndex]<tasks[i]){\\n                curToJudgeWorkIndex++;\\n            }\\n            if(curToJudgeWorkIndex==workers.length){\\n                break;\\n            }\\n            res++;\\n            curToJudgeWorkIndex++;\\n        }\\n        return res;\\n    }\\n```",
                "solutionTags": [
                    "Java",
                    "Greedy"
                ],
                "code": "```\\n    public int maxTaskAssign(int[] tasks, int[] workers, int pills, int strength) {\\n        Arrays.sort(tasks);\\n        Arrays.sort(workers);\\n        boolean[]usedWorkerInFirstRound=new boolean[workers.length];\\n        int maxPossibleUsedTaskLen=Math.min(tasks.length,workers.length);\\n        int curToJudgeWorkIndex=0;\\n        for(int i=0;i<maxPossibleUsedTaskLen;i++){\\n            while (curToJudgeWorkIndex<workers.length&&workers[curToJudgeWorkIndex]<tasks[i]){\\n                curToJudgeWorkIndex++;\\n            }\\n            if(curToJudgeWorkIndex==workers.length){\\n                break;\\n            }\\n            usedWorkerInFirstRound[curToJudgeWorkIndex]=true;\\n            curToJudgeWorkIndex++;\\n        }\\n        for (int i=workers.length-1;i>=0;i--){\\n            if(pills==0){\\n                break;\\n            }\\n            if(!usedWorkerInFirstRound[i]){\\n                workers[i]+=strength;\\n                pills--;\\n            }\\n        }\\n        for (int i=workers.length-1;i>=0;i--){\\n            if(pills==0){\\n                break;\\n            }\\n            if(usedWorkerInFirstRound[i]){\\n                workers[i]+=strength;\\n                pills--;\\n            }\\n        }\\n        Arrays.sort(workers);\\n        int res=0;\\n        curToJudgeWorkIndex=0;\\n        for(int i=0;i<maxPossibleUsedTaskLen;i++){\\n            while (curToJudgeWorkIndex<workers.length&&workers[curToJudgeWorkIndex]<tasks[i]){\\n                curToJudgeWorkIndex++;\\n            }\\n            if(curToJudgeWorkIndex==workers.length){\\n                break;\\n            }\\n            res++;\\n            curToJudgeWorkIndex++;\\n        }\\n        return res;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1576648,
                "title": "c-2071-maximum-number-of-tasks-you-can-assign",
                "content": "\\n```\\nclass Solution {\\npublic:\\n    int maxTaskAssign(vector<int>& tasks, vector<int>& workers, int pills, int strength) {\\n        sort(tasks.begin(), tasks.end()); \\n        sort(workers.begin(), workers.end()); \\n        \\n        auto fn = [&](int k) {\\n            int p = pills; \\n            multiset<int> st(workers.end()-k, workers.end()); \\n            for (int i = k-1; i >= 0; --i) {\\n                int task = tasks[i]; \\n                if (task <= *(st.rbegin())) st.erase(prev(st.end())); \\n                else if (task <= *st.rbegin() + strength && p) {\\n                    --p; \\n                    auto it = st.lower_bound(task - strength); \\n                    st.erase(it); \\n                } \\n                else return false; \\n            }\\n            return true; \\n        }; \\n        \\n        int lo = 0, hi = min((int)tasks.size(), (int)workers.size()); \\n        while (lo < hi) {\\n            int mid = lo + (hi - lo + 1)/2; \\n            if (fn(mid)) lo = mid; \\n            else hi = mid - 1; \\n        }\\n        return lo; \\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxTaskAssign(vector<int>& tasks, vector<int>& workers, int pills, int strength) {\\n        sort(tasks.begin(), tasks.end()); \\n        sort(workers.begin(), workers.end()); \\n        \\n        auto fn = [&](int k) {\\n            int p = pills; \\n            multiset<int> st(workers.end()-k, workers.end()); \\n            for (int i = k-1; i >= 0; --i) {\\n                int task = tasks[i]; \\n                if (task <= *(st.rbegin())) st.erase(prev(st.end())); \\n                else if (task <= *st.rbegin() + strength && p) {\\n                    --p; \\n                    auto it = st.lower_bound(task - strength); \\n                    st.erase(it); \\n                } \\n                else return false; \\n            }\\n            return true; \\n        }; \\n        \\n        int lo = 0, hi = min((int)tasks.size(), (int)workers.size()); \\n        while (lo < hi) {\\n            int mid = lo + (hi - lo + 1)/2; \\n            if (fn(mid)) lo = mid; \\n            else hi = mid - 1; \\n        }\\n        return lo; \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3904962,
                "title": "c-super-easy-clean-code-multi-set-easy-to-grasp",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\nprivate:\\n    bool isPossible(int numTask, vector<int>& tasks, vector<int>& workers, int pills, int strength){\\n        multiset<int> ms(workers.end()-numTask,workers.end());\\n\\n        for(int i=numTask-1; i>=0; i--){\\n            auto it = ms.end();\\n            it--;\\n            if(*it < tasks[i]){\\n                if(!pills) return false;\\n                it = ms.lower_bound(tasks[i]-strength);\\n                if(it == ms.end()) return false;\\n                pills--;\\n            }\\n            ms.erase(it);\\n        }\\n\\n        return true;\\n    }\\npublic:\\n    int maxTaskAssign(vector<int>& tasks, vector<int>& workers, int pills, int strength) {\\n        \\n        sort(tasks.begin(), tasks.end());\\n        sort(workers.begin(),workers.end());\\n\\n        int n = tasks.size();\\n        int m = workers.size();\\n\\n        int low = 0;\\n        int high = min(n,m);\\n        int ans = 0;\\n\\n        while(low <= high){\\n            int mid = (low + high) >> 1;\\n            if(isPossible(mid,tasks,workers,pills,strength)){\\n                ans = mid;\\n                low = mid + 1;\\n            }\\n            else high = mid - 1;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\nprivate:\\n    bool isPossible(int numTask, vector<int>& tasks, vector<int>& workers, int pills, int strength){\\n        multiset<int> ms(workers.end()-numTask,workers.end());\\n\\n        for(int i=numTask-1; i>=0; i--){\\n            auto it = ms.end();\\n            it--;\\n            if(*it < tasks[i]){\\n                if(!pills) return false;\\n                it = ms.lower_bound(tasks[i]-strength);\\n                if(it == ms.end()) return false;\\n                pills--;\\n            }\\n            ms.erase(it);\\n        }\\n\\n        return true;\\n    }\\npublic:\\n    int maxTaskAssign(vector<int>& tasks, vector<int>& workers, int pills, int strength) {\\n        \\n        sort(tasks.begin(), tasks.end());\\n        sort(workers.begin(),workers.end());\\n\\n        int n = tasks.size();\\n        int m = workers.size();\\n\\n        int low = 0;\\n        int high = min(n,m);\\n        int ans = 0;\\n\\n        while(low <= high){\\n            int mid = (low + high) >> 1;\\n            if(isPossible(mid,tasks,workers,pills,strength)){\\n                ans = mid;\\n                low = mid + 1;\\n            }\\n            else high = mid - 1;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1800470,
                "title": "java-simple-treemap-and-binaryserch-solution",
                "content": "```\\nclass Solution {\\n    \\n    public int maxTaskAssign(int[] tasks, int[] workers, int pills, int strength) {   \\n        Arrays.sort(tasks);\\n        Arrays.sort(workers);\\n        \\n        int st = 0;\\n        int end = Math.min(tasks.length, workers.length)-1;\\n        int ans =0;\\n        while(st<=end){\\n            int mid = (st+end)/2;\\n            if(isPossible(tasks, workers, pills, strength, mid)){\\n                st = mid+1;\\n                ans = Math.max(ans, mid+1);\\n            }else{\\n                end = mid-1;\\n            }\\n        }\\n        return ans;\\n    }\\n    \\nboolean isPossibleToComplete(int[] tasks, int[] workers, int pills, int strength, int mid) {\\n        int n = workers.length;\\n        TreeMap<Integer, Integer> map = new TreeMap<>();\\n        \\n        for (int i = n - 1, count = 0; count <= mid && i >= 0; i--, count++) {\\n            map.merge(workers[i], 1, (a, b) -> a + b);\\n        }\\n        int done = n - 1;\\n        int count = mid;\\n        for (int i = mid; i >= 0; i--) {\\n            int val = tasks[i];\\n                Integer kv = map.ceilingKey(val);\\n                if (kv != null) {\\n                    updateMap(map, kv);\\n                } else {\\n                    if(pills>0){\\n                        int newStrg = val-strength;\\n                        Integer newKv = map.ceilingKey(newStrg);\\n                        if(newKv!=null){\\n                           updateMap(map, newKv);\\n                            pills--;\\n                        }else {\\n                            return false;\\n                        }\\n                    } else {\\n                        return false;\\n                    }\\n                }\\n        }\\n         return true;\\n    }\\n    void updateMap(TreeMap<Integer, Integer> map, int key){\\n        int vl = map.get(key);\\n        map.put(key, vl - 1);\\n        if (vl - 1 == 0) {\\n            map.remove(key);\\n        }\\n    }\\n}\\n",
                "solutionTags": [
                    "Java",
                    "Tree"
                ],
                "code": "class Solution {\\n    \\n    public int maxTaskAssign(int[] tasks, int[] workers, int pills, int strength) {   \\n        Arrays.sort(tasks);\\n        Arrays.sort(workers);\\n        \\n        int st = 0;\\n        int end = Math.min(tasks.length, workers.length)-1;\\n        int ans =0;\\n        while(st<=end){\\n            int mid = (st+end)/2;\\n            if(isPossible(tasks, workers, pills, strength, mid)){\\n                st = mid+1;\\n                ans = Math.max(ans, mid+1);\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1674742,
                "title": "greedy-binary-search-java-solution",
                "content": "\\n```\\nclass Solution {\\n    public int maxTaskAssign(int[] tasks, int[] workers, int pills, int strength) {\\n        Arrays.sort(tasks);\\n        Arrays.sort(workers);\\n        int m = tasks.length, n = workers.length;\\n        int start = 0, end = Math.min(m, n);\\n        while(start < end) {\\n            int mid = (end - start) / 2 + start;\\n            boolean isDone = true;  \\n            TreeMap<Integer, Integer> map = new TreeMap<>();\\n            for(int w : workers) {\\n                map.put(w, map.getOrDefault(w, 0) + 1);\\n            }\\n            int tries = pills;\\n            for(int i = mid; i >= 0; i--) {\\n                int w = map.lastKey();\\n                if(tasks[i] <= w) {// use the strongest workers for \"easy tasks\"\\n                    map.put(w, map.get(w) - 1);\\n                    if(map.get(w) == 0) map.remove(w);\\n                } else {   // use pill for qualify workers if the worker exists. If not, we exit the for-loop and try smaller size of tasks \\n                    Integer w1 = map.ceilingKey(tasks[i] - strength);\\n                    if(w1 != null) {\\n                        tries --;\\n                        map.put(w1, map.get(w1) - 1);\\n                        if(map.get(w1) == 0) map.remove(w1);\\n                    } else {\\n                        isDone = false;\\n                        break;\\n                    }\\n                }\\n                if(tries < 0) {\\n                    isDone = false;\\n                    break;\\n                }\\n            }\\n            if(isDone) {\\n                start = mid + 1;\\n            } else {\\n                end = mid;\\n            }\\n        }\\n        return start;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int maxTaskAssign(int[] tasks, int[] workers, int pills, int strength) {\\n        Arrays.sort(tasks);\\n        Arrays.sort(workers);\\n        int m = tasks.length, n = workers.length;\\n        int start = 0, end = Math.min(m, n);\\n        while(start < end) {\\n            int mid = (end - start) / 2 + start;\\n            boolean isDone = true;  \\n            TreeMap<Integer, Integer> map = new TreeMap<>();\\n            for(int w : workers) {\\n                map.put(w, map.getOrDefault(w, 0) + 1);\\n            }\\n            int tries = pills;\\n            for(int i = mid; i >= 0; i--) {\\n                int w = map.lastKey();\\n                if(tasks[i] <= w) {// use the strongest workers for \"easy tasks\"\\n                    map.put(w, map.get(w) - 1);\\n                    if(map.get(w) == 0) map.remove(w);\\n                } else {   // use pill for qualify workers if the worker exists. If not, we exit the for-loop and try smaller size of tasks \\n                    Integer w1 = map.ceilingKey(tasks[i] - strength);\\n                    if(w1 != null) {\\n                        tries --;\\n                        map.put(w1, map.get(w1) - 1);\\n                        if(map.get(w1) == 0) map.remove(w1);\\n                    } else {\\n                        isDone = false;\\n                        break;\\n                    }\\n                }\\n                if(tries < 0) {\\n                    isDone = false;\\n                    break;\\n                }\\n            }\\n            if(isDone) {\\n                start = mid + 1;\\n            } else {\\n                end = mid;\\n            }\\n        }\\n        return start;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1603511,
                "title": "javascript-js-binarysearch",
                "content": "\\n\\n```js\\n/**\\n * @param {number[]} tasks\\n * @param {number[]} workers\\n * @param {number} pills\\n * @param {number} strength\\n * @return {number}\\n */\\nconst maxTaskAssign = function(tasks, workers, pills, strength) {\\n  tasks.sort((a, b) => a - b)\\n  workers.sort((a, b) => b - a)\\n  const m = tasks.length, n = workers.length\\n  const { min, floor } = Math\\n  let l = 0, r = min(n, m)\\n  while (l < r) {\\n    const mid = r - floor((r - l) / 2)\\n    if (check(mid)) l = mid\\n    else r = mid - 1\\n  }\\n\\n  return l\\n\\n  function check(k){\\n    const wArr = workers.slice(0, k), tArr = tasks.slice(0, k)\\n    let tries = pills, bs = new Bisect()\\n    wArr.reverse()\\n    tArr.reverse()\\n  \\n    for (let elem of tArr) {\\n      const place = bs.bisect_left(wArr, elem)\\n      if (place < wArr.length) {\\n        wArr.pop()\\n      } else if (tries > 0) {\\n        const place2 = bs.bisect_left(wArr, elem - strength)\\n        if (place2 < wArr.length) {\\n          wArr.splice(place2, 1)\\n          tries -= 1\\n        }\\n      } else return false\\n    }\\n  \\n    return wArr.length === 0\\n  }\\n};\\n\\n////////////////Template////////////////\\nfunction Bisect() {\\n  return { insort_right, insort_left, bisect_left, bisect_right }\\n  function insort_right(a, x, lo = 0, hi = null) {\\n    lo = bisect_right(a, x, lo, hi)\\n    a.splice(lo, 0, x)\\n  }\\n  function bisect_right(a, x, lo = 0, hi = null) {\\n    // > upper_bound\\n    if (lo < 0) throw new Error(\\'lo must be non-negative\\')\\n    if (hi == null) hi = a.length\\n    while (lo < hi) {\\n      let mid = parseInt((lo + hi) / 2)\\n      x < a[mid] ? (hi = mid) : (lo = mid + 1)\\n    }\\n    return lo\\n  }\\n  function insort_left(a, x, lo = 0, hi = null) {\\n    lo = bisect_left(a, x, lo, hi)\\n    a.splice(lo, 0, x)\\n  }\\n  function bisect_left(a, x, lo = 0, hi = null) {\\n    // >= lower_bound\\n    if (lo < 0) throw new Error(\\'lo must be non-negative\\')\\n    if (hi == null) hi = a.length\\n    while (lo < hi) {\\n      let mid = parseInt((lo + hi) / 2)\\n      a[mid] < x ? (lo = mid + 1) : (hi = mid)\\n    }\\n    return lo\\n  }\\n}\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Binary Tree"
                ],
                "code": "```js\\n/**\\n * @param {number[]} tasks\\n * @param {number[]} workers\\n * @param {number} pills\\n * @param {number} strength\\n * @return {number}\\n */\\nconst maxTaskAssign = function(tasks, workers, pills, strength) {\\n  tasks.sort((a, b) => a - b)\\n  workers.sort((a, b) => b - a)\\n  const m = tasks.length, n = workers.length\\n  const { min, floor } = Math\\n  let l = 0, r = min(n, m)\\n  while (l < r) {\\n    const mid = r - floor((r - l) / 2)\\n    if (check(mid)) l = mid\\n    else r = mid - 1\\n  }\\n\\n  return l\\n\\n  function check(k){\\n    const wArr = workers.slice(0, k), tArr = tasks.slice(0, k)\\n    let tries = pills, bs = new Bisect()\\n    wArr.reverse()\\n    tArr.reverse()\\n  \\n    for (let elem of tArr) {\\n      const place = bs.bisect_left(wArr, elem)\\n      if (place < wArr.length) {\\n        wArr.pop()\\n      } else if (tries > 0) {\\n        const place2 = bs.bisect_left(wArr, elem - strength)\\n        if (place2 < wArr.length) {\\n          wArr.splice(place2, 1)\\n          tries -= 1\\n        }\\n      } else return false\\n    }\\n  \\n    return wArr.length === 0\\n  }\\n};\\n\\n////////////////Template////////////////\\nfunction Bisect() {\\n  return { insort_right, insort_left, bisect_left, bisect_right }\\n  function insort_right(a, x, lo = 0, hi = null) {\\n    lo = bisect_right(a, x, lo, hi)\\n    a.splice(lo, 0, x)\\n  }\\n  function bisect_right(a, x, lo = 0, hi = null) {\\n    // > upper_bound\\n    if (lo < 0) throw new Error(\\'lo must be non-negative\\')\\n    if (hi == null) hi = a.length\\n    while (lo < hi) {\\n      let mid = parseInt((lo + hi) / 2)\\n      x < a[mid] ? (hi = mid) : (lo = mid + 1)\\n    }\\n    return lo\\n  }\\n  function insort_left(a, x, lo = 0, hi = null) {\\n    lo = bisect_left(a, x, lo, hi)\\n    a.splice(lo, 0, x)\\n  }\\n  function bisect_left(a, x, lo = 0, hi = null) {\\n    // >= lower_bound\\n    if (lo < 0) throw new Error(\\'lo must be non-negative\\')\\n    if (hi == null) hi = a.length\\n    while (lo < hi) {\\n      let mid = parseInt((lo + hi) / 2)\\n      a[mid] < x ? (lo = mid + 1) : (hi = mid)\\n    }\\n    return lo\\n  }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1601378,
                "title": "java-greedy-o-n-logn-logn",
                "content": "\\n```\\nclass Solution {\\n    public int maxTaskAssign(int[] t, int[] w, int p, int s) {\\n        int n = w.length;\\n        int m = t.length;\\n        Arrays.sort(t);\\n        \\n        int lo = 1, hi = Math.min(n, m);  // hi = Math.min(n, m),  since max tasks you can assign is the minimum of tasks and workers\\n        int ans = 0;\\n\\t\\t// binary search to find the max tasks we can assign\\n        while(lo <= hi){\\n            int mid = (lo+hi)>>1;\\n            if(check(t, w, p, s, mid)){ \\n                ans = mid;\\n                lo = mid+1;\\n            }else{\\n                hi = mid-1;\\n            }\\n        }\\n        return ans;\\n    }\\n    \\n    boolean check(int []t, int w[], int p, int s, int n){\\n        int idx = n-1;\\n        TreeMap<Integer, Integer> map = new TreeMap<>();\\n        addAll(w, map);\\n        \\n        while(idx >= 0){\\n            Integer strongest = map.ceilingKey(t[idx]);  // try assigning the task to the strongest worker\\n            if(strongest == null){\\n                if(p == 0) return false;\\n                Integer weekest = map.ceilingKey(t[idx]-s);  // try assigning the task to the weekest worker with pill\\n                if(weekest == null) return false; // if cannot assign the task  return false\\n                remove(map, weekest);\\n                p--;\\n            }else{\\n                remove(map, strongest);\\n            }\\n            idx--;\\n        }\\n        return true;  // if all k tasks are assigned then return true\\n    }\\n    \\n    void addAll(int[] w, TreeMap<Integer, Integer> map){\\n        for(int i: w) map.put(i, map.getOrDefault(i, 0) + 1);\\n    }\\n    \\n    void remove(TreeMap<Integer, Integer> map, int val){\\n        if(map.get(val) == 1) map.remove(val);\\n        else map.put(val, map.get(val)-1);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Greedy",
                    "Tree"
                ],
                "code": "```\\nclass Solution {\\n    public int maxTaskAssign(int[] t, int[] w, int p, int s) {\\n        int n = w.length;\\n        int m = t.length;\\n        Arrays.sort(t);\\n        \\n        int lo = 1, hi = Math.min(n, m);  // hi = Math.min(n, m),  since max tasks you can assign is the minimum of tasks and workers\\n        int ans = 0;\\n\\t\\t// binary search to find the max tasks we can assign\\n        while(lo <= hi){\\n            int mid = (lo+hi)>>1;\\n            if(check(t, w, p, s, mid)){ \\n                ans = mid;\\n                lo = mid+1;\\n            }else{\\n                hi = mid-1;\\n            }\\n        }\\n        return ans;\\n    }\\n    \\n    boolean check(int []t, int w[], int p, int s, int n){\\n        int idx = n-1;\\n        TreeMap<Integer, Integer> map = new TreeMap<>();\\n        addAll(w, map);\\n        \\n        while(idx >= 0){\\n            Integer strongest = map.ceilingKey(t[idx]);  // try assigning the task to the strongest worker\\n            if(strongest == null){\\n                if(p == 0) return false;\\n                Integer weekest = map.ceilingKey(t[idx]-s);  // try assigning the task to the weekest worker with pill\\n                if(weekest == null) return false; // if cannot assign the task  return false\\n                remove(map, weekest);\\n                p--;\\n            }else{\\n                remove(map, strongest);\\n            }\\n            idx--;\\n        }\\n        return true;  // if all k tasks are assigned then return true\\n    }\\n    \\n    void addAll(int[] w, TreeMap<Integer, Integer> map){\\n        for(int i: w) map.put(i, map.getOrDefault(i, 0) + 1);\\n    }\\n    \\n    void remove(TreeMap<Integer, Integer> map, int val){\\n        if(map.get(val) == 1) map.remove(val);\\n        else map.put(val, map.get(val)-1);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1577613,
                "title": "c-binary-search-o-nlgn-using-std-list",
                "content": "# O(NlgN) using std::list\\n\\n```c++\\nclass Solution {\\npublic:\\n    int maxTaskAssign(vector<int>& tasks, vector<int>& workers, int pills, int strength) {\\n        sort(begin(tasks), end(tasks));\\n        sort(begin(workers), end(workers));\\n        auto check = [&](int n) {\\n            list<int> S(end(workers) - n, end(workers));\\n            auto j = S.end(), i = j;\\n            int p = 0;\\n            while (n--) {\\n                if (p < pills) {\\n                    while (i != S.begin() && *prev(i) + strength >= tasks[n]) --i;\\n                    if (i != S.end() && *i + strength < tasks[n]) ++i;\\n                } else {\\n                    i = S.end();\\n                }\\n                \\n                while (j != S.begin() && *prev(j) >= tasks[n]) --j;\\n                if (j != S.end() && *j < tasks[n]) ++j;\\n                \\n                if (i == S.end() && j == S.end()) return false;\\n                if (j != S.end()) {\\n                    if (i == j) ++i;\\n                    S.erase(j++);\\n                } else {\\n                    ++p;\\n                    if (j == i) ++j;\\n                    S.erase(i++);\\n                }\\n            }\\n            return true;\\n        };\\n        int L = 0, R = min(workers.size(), tasks.size()) + 1;\\n        while (L + 1 < R) {\\n            int MID = (L + R) >> 1;\\n            if (check(MID)) L = MID;\\n            else R = MID;\\n        }\\n        return L;\\n    }\\n};\\n```\\n\\n# O(NlgNlgN) using std::multiset\\n```c++\\nclass Solution {\\npublic:\\n    int maxTaskAssign(vector<int>& tasks, vector<int>& workers, int pills, int strength) {\\n        sort(begin(tasks), end(tasks));\\n        sort(begin(workers), end(workers));\\n        auto check = [&](int n) {\\n            multiset<int> S(end(workers) - n, end(workers));\\n            int p = 0;\\n            while (n--) {\\n                auto i = p < pills ? S.lower_bound(tasks[n] - strength) : S.end();\\n                auto j = S.lower_bound(tasks[n]);\\n                if (i == S.end() && j == S.end()) return false;\\n                if (j != S.end()) {\\n                    S.erase(j);\\n                } else {\\n                    ++p;\\n                    S.erase(i);\\n                }\\n            }\\n            return true;\\n        };\\n        int L = 0, R = min(workers.size(), tasks.size()) + 1;\\n        while (L + 1 < R) {\\n            int MID = (L + R) >> 1;\\n            if (check(MID)) L = MID;\\n            else R = MID;\\n        }\\n        return L;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```c++\\nclass Solution {\\npublic:\\n    int maxTaskAssign(vector<int>& tasks, vector<int>& workers, int pills, int strength) {\\n        sort(begin(tasks), end(tasks));\\n        sort(begin(workers), end(workers));\\n        auto check = [&](int n) {\\n            list<int> S(end(workers) - n, end(workers));\\n            auto j = S.end(), i = j;\\n            int p = 0;\\n            while (n--) {\\n                if (p < pills) {\\n                    while (i != S.begin() && *prev(i) + strength >= tasks[n]) --i;\\n                    if (i != S.end() && *i + strength < tasks[n]) ++i;\\n                } else {\\n                    i = S.end();\\n                }\\n                \\n                while (j != S.begin() && *prev(j) >= tasks[n]) --j;\\n                if (j != S.end() && *j < tasks[n]) ++j;\\n                \\n                if (i == S.end() && j == S.end()) return false;\\n                if (j != S.end()) {\\n                    if (i == j) ++i;\\n                    S.erase(j++);\\n                } else {\\n                    ++p;\\n                    if (j == i) ++j;\\n                    S.erase(i++);\\n                }\\n            }\\n            return true;\\n        };\\n        int L = 0, R = min(workers.size(), tasks.size()) + 1;\\n        while (L + 1 < R) {\\n            int MID = (L + R) >> 1;\\n            if (check(MID)) L = MID;\\n            else R = MID;\\n        }\\n        return L;\\n    }\\n};\\n```\n```c++\\nclass Solution {\\npublic:\\n    int maxTaskAssign(vector<int>& tasks, vector<int>& workers, int pills, int strength) {\\n        sort(begin(tasks), end(tasks));\\n        sort(begin(workers), end(workers));\\n        auto check = [&](int n) {\\n            multiset<int> S(end(workers) - n, end(workers));\\n            int p = 0;\\n            while (n--) {\\n                auto i = p < pills ? S.lower_bound(tasks[n] - strength) : S.end();\\n                auto j = S.lower_bound(tasks[n]);\\n                if (i == S.end() && j == S.end()) return false;\\n                if (j != S.end()) {\\n                    S.erase(j);\\n                } else {\\n                    ++p;\\n                    S.erase(i);\\n                }\\n            }\\n            return true;\\n        };\\n        int L = 0, R = min(workers.size(), tasks.size()) + 1;\\n        while (L + 1 < R) {\\n            int MID = (L + R) >> 1;\\n            if (check(MID)) L = MID;\\n            else R = MID;\\n        }\\n        return L;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1576030,
                "title": "c-why-is-this-tle-thanks",
                "content": "Came up with this binary search solution and greedy approach but kept hitting time limit during contest. Complexity is O(N (log N)^2). What is wrong with it? Thanks.\\n\\n```\\nclass Solution {\\npublic:\\n    bool possible(const int M, vector<int>& tasks, vector<int>& workers, int pills, int strength) {\\n        \\n        if (M + 1 > workers.size())\\n            return false;\\n        \\n        multiset<int> S;\\n\\n        for (auto& w : workers)\\n            S.insert(w);\\n        \\n        for (int i = M; i >= 0; i--) {\\n            if (S.empty())\\n                return false;\\n            \\n            auto worker = lower_bound(S.begin(), S.end(), tasks[i]);\\n            if (worker == S.end()) {\\n                worker = lower_bound(S.begin(), S.end(), tasks[i] - strength);\\n                if (worker == S.end())\\n                    return false;\\n                pills--;\\n                if (pills < 0)\\n                    return false;                \\n            }\\n            S.erase(worker);\\n        }\\n        return true;        \\n    }\\n    \\n    \\n    \\n    int maxTaskAssign(vector<int>& tasks, vector<int>& workers, int pills, int strength) {\\n        int L = 0;\\n        int R = int(tasks.size()) - 1;\\n        int ans = -1;\\n        \\n        sort(tasks.begin(), tasks.end());\\n        \\n        while (L <= R) {\\n            int M = (R + L) / 2;\\n            if (possible(M, tasks, workers, pills, strength)) {\\n                ans = M;\\n                L = M + 1;\\n            }\\n            else {\\n                R = M - 1;\\n            }\\n        }\\n        \\n        return ans + 1;\\n    }\\n};\\n```\\n\\nFound the cause......\\n\\nlower_bound(S.begin(), S.end(), tasks[i]) is actually O(N) and S.lower_bound(tasks[i]) is O(log N). Man oh man! This cost me a good ranking position. It just got accepted after this tiny change ;)",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    bool possible(const int M, vector<int>& tasks, vector<int>& workers, int pills, int strength) {\\n        \\n        if (M + 1 > workers.size())\\n            return false;\\n        \\n        multiset<int> S;\\n\\n        for (auto& w : workers)\\n            S.insert(w);\\n        \\n        for (int i = M; i >= 0; i--) {\\n            if (S.empty())\\n                return false;\\n            \\n            auto worker = lower_bound(S.begin(), S.end(), tasks[i]);\\n            if (worker == S.end()) {\\n                worker = lower_bound(S.begin(), S.end(), tasks[i] - strength);\\n                if (worker == S.end())\\n                    return false;\\n                pills--;\\n                if (pills < 0)\\n                    return false;                \\n            }\\n            S.erase(worker);\\n        }\\n        return true;        \\n    }\\n    \\n    \\n    \\n    int maxTaskAssign(vector<int>& tasks, vector<int>& workers, int pills, int strength) {\\n        int L = 0;\\n        int R = int(tasks.size()) - 1;\\n        int ans = -1;\\n        \\n        sort(tasks.begin(), tasks.end());\\n        \\n        while (L <= R) {\\n            int M = (R + L) / 2;\\n            if (possible(M, tasks, workers, pills, strength)) {\\n                ans = M;\\n                L = M + 1;\\n            }\\n            else {\\n                R = M - 1;\\n            }\\n        }\\n        \\n        return ans + 1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4018950,
                "title": "binary-search-greedy",
                "content": "# Intuition\\nTo check how to solve the easiest m tasks using the strongest m workers.\\n\\n# Approach\\nSort the task and worker strenght vectors in increasing order. Then, binary search over the number of tasks that can be completed using the provided workers and the pills. \\n\\nFor each of the chosen m easiest tasks, make a multiset of the m strongest workers. For every task in the decreasing order of the m tasks, check if the current strongest worker can complete the task. If so remove the worker and continue. \\n\\nIf not, chose the weakest possible worker that can complete the given task with the usage of the pills. If the pills are finished or there does not exist any worker that can solve the given task with the pill, that means that the current task would remain undone. Thus, the chosen m tasks would not get completed with the m strongest workers.\\n\\n# Complexity\\n- Time complexity: \\n\\n\\n- Space complexity:\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maxTaskAssign(vector<int>& tasks, vector<int>& work, int pills, int strength) {\\n        int l = 0, r = min(tasks.size(),work.size());\\n        int ans = l;\\n        sort(tasks.begin(),tasks.end());\\n        sort(work.begin(),work.end());\\n        while(l <= r){\\n            int m = (l+r)/2, curr = pills;\\n            multiset<int>mst(end(work)-m,end(work));\\n            for(int i=m-1;i>=0;i--){\\n                auto end_ptr = prev(end(mst));\\n                if(*(end_ptr) < tasks[i]){\\n                    end_ptr = mst.lower_bound(tasks[i] - strength);\\n                    if(end_ptr == mst.end() || curr <= 0){\\n                        break;\\n                    }\\n                    curr--;\\n                }\\n                mst.erase(end_ptr);\\n            }\\n            if(mst.size() == 0){\\n                ans = m;\\n                l = m + 1;\\n            }\\n            else r = m - 1;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxTaskAssign(vector<int>& tasks, vector<int>& work, int pills, int strength) {\\n        int l = 0, r = min(tasks.size(),work.size());\\n        int ans = l;\\n        sort(tasks.begin(),tasks.end());\\n        sort(work.begin(),work.end());\\n        while(l <= r){\\n            int m = (l+r)/2, curr = pills;\\n            multiset<int>mst(end(work)-m,end(work));\\n            for(int i=m-1;i>=0;i--){\\n                auto end_ptr = prev(end(mst));\\n                if(*(end_ptr) < tasks[i]){\\n                    end_ptr = mst.lower_bound(tasks[i] - strength);\\n                    if(end_ptr == mst.end() || curr <= 0){\\n                        break;\\n                    }\\n                    curr--;\\n                }\\n                mst.erase(end_ptr);\\n            }\\n            if(mst.size() == 0){\\n                ans = m;\\n                l = m + 1;\\n            }\\n            else r = m - 1;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3829476,
                "title": "sorting-and-searching-solution-based-on-given-hint",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    int maxTaskAssign(vector<int>& task, vector<int>& workers, int pills, int strength) {\\n        int t=task.size(),w=workers.size();\\n        sort(task.begin(),task.end());\\n        int ans=0;\\n        sort(workers.begin(),workers.end());\\n        int start=0,end=min(t,w)-1;\\n\\n        while(start<=end)\\n        {\\n            int mid=start+(end-start)/2;\\n            if(isPossible(mid,task,workers,pills,strength)){\\n                ans=max(ans,mid+1);\\n                start=mid+1;\\n            }\\n            else{\\n                end=mid-1;\\n            }\\n        }\\n        return ans;\\n    }\\n    bool isPossible(int ele,vector<int>& task,vector<int>& worker,int pills,int strength)\\n    {\\n        multiset<int> ms;\\n        int t=task.size(),w=worker.size();\\n        for(int i=0;i<w;i++)\\n        ms.insert(worker[i]);\\n\\n        for(int i=ele;i>=0;i--)\\n        {\\n            auto it=ms.end();\\n            it--;\\n            if(*it<task[i])\\n            {\\n                if(pills<=0)\\n                return false;\\n                \\n                auto ite=ms.lower_bound(task[i]-strength);\\n                // Find the iterator to the first element not less than 30\\n                \\n                if(ite==ms.end())\\n                return false;\\n                pills--;\\n                ms.erase(ite);\\n            }\\n            else{\\n                ms.erase(it);\\n            }\\n        }\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Binary Search",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxTaskAssign(vector<int>& task, vector<int>& workers, int pills, int strength) {\\n        int t=task.size(),w=workers.size();\\n        sort(task.begin(),task.end());\\n        int ans=0;\\n        sort(workers.begin(),workers.end());\\n        int start=0,end=min(t,w)-1;\\n\\n        while(start<=end)\\n        {\\n            int mid=start+(end-start)/2;\\n            if(isPossible(mid,task,workers,pills,strength)){\\n                ans=max(ans,mid+1);\\n                start=mid+1;\\n            }\\n            else{\\n                end=mid-1;\\n            }\\n        }\\n        return ans;\\n    }\\n    bool isPossible(int ele,vector<int>& task,vector<int>& worker,int pills,int strength)\\n    {\\n        multiset<int> ms;\\n        int t=task.size(),w=worker.size();\\n        for(int i=0;i<w;i++)\\n        ms.insert(worker[i]);\\n\\n        for(int i=ele;i>=0;i--)\\n        {\\n            auto it=ms.end();\\n            it--;\\n            if(*it<task[i])\\n            {\\n                if(pills<=0)\\n                return false;\\n                \\n                auto ite=ms.lower_bound(task[i]-strength);\\n                // Find the iterator to the first element not less than 30\\n                \\n                if(ite==ms.end())\\n                return false;\\n                pills--;\\n                ms.erase(ite);\\n            }\\n            else{\\n                ms.erase(it);\\n            }\\n        }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3825884,
                "title": "python-3-no-binary-search-faster-than-100",
                "content": "![Screenshot 2023-07-27 at 1.28.48 PM.png](https://assets.leetcode.com/users/images/502027f1-967d-4dc5-86f9-5023ae6a8bde_1690491263.5724463.png)\\n# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe inituition: Starts with realizing that you can complete at most k tasks. \\nWhere `k = min(len(tasks), len(workers))`\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nWe split up the workers and task by the k strongest workers and the k weakest tasks. Assign the worker with the minimum required strength the task, remove the worker from the stack.\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n- n = len(tasks)\\n- m = len(workers)\\n- k = min(n, m)\\n\\n- sorting: $$O(nlogn) + O(mlogm)$$\\n- loop: $$O(k*k*logk)$$ - I think the reality is closer to $$O(k*1*logk) = O(klogk)$$\\n\\nOverall Time Complexity: $$O(nlogn + mlogm + klogk)$$\\n- Space complexity: $$O(n + m)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n\\n    def maxTaskAssign(self, tasks: List[int], workers: List[int], pills: int, strength: int) -> int:\\n\\n        # sort the arrays\\n        tasks.sort() # O(nlogn)\\n        workers.sort() # O(mlogm)\\n        \\n      \\n        # you can complete at most k tasks\\n        k = min(len(tasks), len(workers))\\n\\n        # strongest workers\\n        workers = workers[-k:]\\n\\n        # easiest tasks\\n        tasks = tasks[:k]\\n\\n        res = 0\\n\\n        # hardest task first\\n        for t in reversed(tasks): # O(k)\\n            # We dont need to use our pills as there\\n            # exists a worker that can solve the current task\\n            if workers[-1] >= t:\\n                res += 1\\n                # Find the worker with the minimum required strength\\n                # to complete the ask\\n                deleteIdx = bisect.bisect_left(workers, t - strength) # O(log k) \\n                # Remove the worker from the stack\\n                workers.pop(deleteIdx) # O(k) - my guess is this is closer to O(1) as the worker is going to be closer to the end of the stack\\n            # we know there exists a worker\\n            # that can solve the task with a pill\\n            elif pills and workers[-1] + strength >= t:\\n                deleteIdx = bisect.bisect_left(workers, t - strength)\\n                workers.pop(deleteIdx)\\n                pills -= 1\\n                res += 1\\n            # else:\\n            # The task couldn\\'t be solved.\\n            # Either because we are out of pills\\n            # or there is no workers that with\\n            # or without the pill can solve it\\n        \\n        return res\\n```",
                "solutionTags": [
                    "Python3",
                    "Stack",
                    "Monotonic Stack"
                ],
                "code": "```\\nclass Solution:\\n\\n    def maxTaskAssign(self, tasks: List[int], workers: List[int], pills: int, strength: int) -> int:\\n\\n        # sort the arrays\\n        tasks.sort() # O(nlogn)\\n        workers.sort() # O(mlogm)\\n        \\n      \\n        # you can complete at most k tasks\\n        k = min(len(tasks), len(workers))\\n\\n        # strongest workers\\n        workers = workers[-k:]\\n\\n        # easiest tasks\\n        tasks = tasks[:k]\\n\\n        res = 0\\n\\n        # hardest task first\\n        for t in reversed(tasks): # O(k)\\n            # We dont need to use our pills as there\\n            # exists a worker that can solve the current task\\n            if workers[-1] >= t:\\n                res += 1\\n                # Find the worker with the minimum required strength\\n                # to complete the ask\\n                deleteIdx = bisect.bisect_left(workers, t - strength) # O(log k) \\n                # Remove the worker from the stack\\n                workers.pop(deleteIdx) # O(k) - my guess is this is closer to O(1) as the worker is going to be closer to the end of the stack\\n            # we know there exists a worker\\n            # that can solve the task with a pill\\n            elif pills and workers[-1] + strength >= t:\\n                deleteIdx = bisect.bisect_left(workers, t - strength)\\n                workers.pop(deleteIdx)\\n                pills -= 1\\n                res += 1\\n            # else:\\n            # The task couldn\\'t be solved.\\n            # Either because we are out of pills\\n            # or there is no workers that with\\n            # or without the pill can solve it\\n        \\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3815961,
                "title": "binary-search-multi-set-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool solve(vector<int>& tasks, vector<int>& workers, int pills, int strength, int n){\\n        multiset<int>mw(workers.end()-n,workers.end());\\n        for(int i=n-1;i>=0;i--){\\n            auto it=mw.lower_bound(tasks[i]);\\n            if(it==mw.end()){\\n                pills-=1;\\n                it=mw.lower_bound(tasks[i]-strength);\\n            }\\n            if(it==mw.end() or pills<0) return false;\\n            mw.erase(it);\\n        }\\n        return true;\\n    }\\n    int maxTaskAssign(vector<int>& tasks, vector<int>& workers, int pills, int strength) {\\n        sort(tasks.begin(), tasks.end());\\n        sort(workers.begin(), workers.end());\\n        int l=0;\\n        int h=min(tasks.size(),workers.size());\\n        int ans=0;\\n        while(l<=h){\\n            int mid=(l+h)/2;\\n            if(solve(tasks,workers,pills,strength,mid)){\\n                ans=max(mid,ans);\\n                l=mid+1;\\n            }\\n            else h=mid-1;\\n        }\\n        return ans;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool solve(vector<int>& tasks, vector<int>& workers, int pills, int strength, int n){\\n        multiset<int>mw(workers.end()-n,workers.end());\\n        for(int i=n-1;i>=0;i--){\\n            auto it=mw.lower_bound(tasks[i]);\\n            if(it==mw.end()){\\n                pills-=1;\\n                it=mw.lower_bound(tasks[i]-strength);\\n            }\\n            if(it==mw.end() or pills<0) return false;\\n            mw.erase(it);\\n        }\\n        return true;\\n    }\\n    int maxTaskAssign(vector<int>& tasks, vector<int>& workers, int pills, int strength) {\\n        sort(tasks.begin(), tasks.end());\\n        sort(workers.begin(), workers.end());\\n        int l=0;\\n        int h=min(tasks.size(),workers.size());\\n        int ans=0;\\n        while(l<=h){\\n            int mid=(l+h)/2;\\n            if(solve(tasks,workers,pills,strength,mid)){\\n                ans=max(mid,ans);\\n                l=mid+1;\\n            }\\n            else h=mid-1;\\n        }\\n        return ans;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3704903,
                "title": "easy-simple-and-fastest-way-in-c",
                "content": "# Complexity\\n- Time complexity:\\nO(wLen*tLen)\\n\\n- Space complexity:\\nO(wLen)\\n\\n# Code\\n```\\nclass Solution {\\n    bool checkTask(vector<int>& tasks, vector<int>& workers, int pills, int strength, int mid) {\\n        multiset<int> mSet(workers.begin(), workers.end());\\n\\n        for(int i = mid-1; i>=0; i--) {\\n            auto lb = mSet.lower_bound(tasks[i]);\\n            if(lb != mSet.end()) {\\n                mSet.erase(lb);\\n            }\\n            else {\\n                if(pills<=0) return false;\\n\\n                auto lb = mSet.lower_bound(tasks[i]-strength);\\n                if(lb != mSet.end()) {\\n                    mSet.erase(lb);\\n                    pills--;\\n                }\\n                else {\\n                    return false;\\n                }\\n            }\\n        }\\n\\n        return true;\\n    }\\npublic:\\n    int maxTaskAssign(vector<int>& tasks, vector<int>& workers, int pills, int strength) {\\n        sort(tasks.begin(), tasks.end());\\n        sort(workers.begin(), workers.end());\\n        int t_Len = tasks.size();\\n        int w_Len = workers.size();\\n\\n        int low=0, high=min(t_Len, w_Len), mid=0;\\n        int res=0;\\n\\n        while(low <= high) {\\n            mid = low + (high-low)/2;\\n\\n            if(checkTask(tasks, workers, pills, strength, mid)) {\\n                low = mid+1;\\n                res = mid;\\n            }\\n            else {\\n                high = mid-1;\\n            }\\n        }\\n\\n\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\n    bool checkTask(vector<int>& tasks, vector<int>& workers, int pills, int strength, int mid) {\\n        multiset<int> mSet(workers.begin(), workers.end());\\n\\n        for(int i = mid-1; i>=0; i--) {\\n            auto lb = mSet.lower_bound(tasks[i]);\\n            if(lb != mSet.end()) {\\n                mSet.erase(lb);\\n            }\\n            else {\\n                if(pills<=0) return false;\\n\\n                auto lb = mSet.lower_bound(tasks[i]-strength);\\n                if(lb != mSet.end()) {\\n                    mSet.erase(lb);\\n                    pills--;\\n                }\\n                else {\\n                    return false;\\n                }\\n            }\\n        }\\n\\n        return true;\\n    }\\npublic:\\n    int maxTaskAssign(vector<int>& tasks, vector<int>& workers, int pills, int strength) {\\n        sort(tasks.begin(), tasks.end());\\n        sort(workers.begin(), workers.end());\\n        int t_Len = tasks.size();\\n        int w_Len = workers.size();\\n\\n        int low=0, high=min(t_Len, w_Len), mid=0;\\n        int res=0;\\n\\n        while(low <= high) {\\n            mid = low + (high-low)/2;\\n\\n            if(checkTask(tasks, workers, pills, strength, mid)) {\\n                low = mid+1;\\n                res = mid;\\n            }\\n            else {\\n                high = mid-1;\\n            }\\n        }\\n\\n\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3665769,
                "title": "binary-search-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool isValid(vector<int>& tasks, vector<int>& workers,int ind, int pills, int strength){\\n        multiset<int>st;\\n        for(auto it: workers){\\n            st.insert(it);\\n        }\\n        for(int i=ind-1; i>=0; i--){\\n            auto it=st.lower_bound(tasks[i]);\\n            if(it!=st.end()){\\n                st.erase(it);\\n            }\\n            else{\\n                if(pills<=0){\\n                    return false;\\n                }\\n                else{\\n                    it=st.lower_bound(tasks[i]-strength);\\n                    if(it!=st.end()){\\n                        st.erase(it);\\n                        pills--;\\n                    }\\n                    else{\\n                        return false;\\n                    }\\n\\n                }\\n            }\\n        }\\n        return true;\\n    }\\n    int maxTaskAssign(vector<int>& tasks, vector<int>& workers, int pills, int strength) {\\n       //we will use binary search\\n       // sort task and workers\\n       // at low=1 high=min(T, W);\\n       // will find mid \\n       // will check wthether we can complete mid number of task \\n       // if yes then set low=mid;\\n       // else high=mid-1;\\n       //is valid(mid)\\n       // in this function we will puts workes in multiset \\n       // we will iterate from tasks which require large amoiu\\n       // we will check in multiset task just close to workers strength\\n       // if we found then increment the count remove it from set\\n       // if we are not able to find the workers of required strength then we will use pills and try to again find the workers with strength atleast(task-strength  if we have available pills)\\n       int T=tasks.size();\\n       int W=workers.size();\\n       sort(tasks.begin(), tasks.end());\\n       sort(workers.begin(), workers.end());\\n       int low=0;\\n       int high=min(T, W);\\n       while(low<high){\\n           int mid=(low+high+1)/2;\\n           \\n           if(isValid(tasks, workers, mid, pills, strength)){\\n               low=mid;\\n\\n           }\\n           else{\\n               high=mid-1;\\n           }\\n\\n       }\\n\\n         \\n    return high;\\n\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isValid(vector<int>& tasks, vector<int>& workers,int ind, int pills, int strength){\\n        multiset<int>st;\\n        for(auto it: workers){\\n            st.insert(it);\\n        }\\n        for(int i=ind-1; i>=0; i--){\\n            auto it=st.lower_bound(tasks[i]);\\n            if(it!=st.end()){\\n                st.erase(it);\\n            }\\n            else{\\n                if(pills<=0){\\n                    return false;\\n                }\\n                else{\\n                    it=st.lower_bound(tasks[i]-strength);\\n                    if(it!=st.end()){\\n                        st.erase(it);\\n                        pills--;\\n                    }\\n                    else{\\n                        return false;\\n                    }\\n\\n                }\\n            }\\n        }\\n        return true;\\n    }\\n    int maxTaskAssign(vector<int>& tasks, vector<int>& workers, int pills, int strength) {\\n       //we will use binary search\\n       // sort task and workers\\n       // at low=1 high=min(T, W);\\n       // will find mid \\n       // will check wthether we can complete mid number of task \\n       // if yes then set low=mid;\\n       // else high=mid-1;\\n       //is valid(mid)\\n       // in this function we will puts workes in multiset \\n       // we will iterate from tasks which require large amoiu\\n       // we will check in multiset task just close to workers strength\\n       // if we found then increment the count remove it from set\\n       // if we are not able to find the workers of required strength then we will use pills and try to again find the workers with strength atleast(task-strength  if we have available pills)\\n       int T=tasks.size();\\n       int W=workers.size();\\n       sort(tasks.begin(), tasks.end());\\n       sort(workers.begin(), workers.end());\\n       int low=0;\\n       int high=min(T, W);\\n       while(low<high){\\n           int mid=(low+high+1)/2;\\n           \\n           if(isValid(tasks, workers, mid, pills, strength)){\\n               low=mid;\\n\\n           }\\n           else{\\n               high=mid-1;\\n           }\\n\\n       }\\n\\n         \\n    return high;\\n\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3586143,
                "title": "apply-binary-search-on-answer",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n   bool f(int mid,vector<int>& tasks, vector<int>& workers,int pills,int strength){\\n       multiset<int>ms;\\n       for(int i=workers.size()-1;i>=0;i--){\\n           ms.insert(workers[i]);\\n       }\\n       for(int i=mid-1;i>=0;i--){\\n           auto it=ms.end();\\n           it--;\\n           if(*it<tasks[i]){\\n               if(pills<=0)return false;\\n               auto ite=ms.lower_bound(tasks[i]-strength);\\n               if(ite==ms.end()){\\n                   return false;\\n               }\\n               pills--;\\n               ms.erase(ite);\\n           }\\n           else{\\n               ms.erase(it);\\n           }\\n        }\\n       return true;\\n   }\\n    int maxTaskAssign(vector<int>& tasks, vector<int>& workers, int pills, int strength) {\\n        int s=0;\\n        int e=min(tasks.size(),workers.size());\\n        int ans=0;\\n        sort(tasks.begin(),tasks.end());\\n        sort(workers.begin(),workers.end());\\n        while(s<=e){\\n            int mid=s+(e-s)/2;\\n            if(f(mid,tasks,workers,pills,strength)){\\n                ans=mid;\\n                s=mid+1;\\n            }\\n            else{\\n                e=mid-1;\\n            }\\n        }\\n        return ans;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Binary Search",
                    "Greedy",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n   bool f(int mid,vector<int>& tasks, vector<int>& workers,int pills,int strength){\\n       multiset<int>ms;\\n       for(int i=workers.size()-1;i>=0;i--){\\n           ms.insert(workers[i]);\\n       }\\n       for(int i=mid-1;i>=0;i--){\\n           auto it=ms.end();\\n           it--;\\n           if(*it<tasks[i]){\\n               if(pills<=0)return false;\\n               auto ite=ms.lower_bound(tasks[i]-strength);\\n               if(ite==ms.end()){\\n                   return false;\\n               }\\n               pills--;\\n               ms.erase(ite);\\n           }\\n           else{\\n               ms.erase(it);\\n           }\\n        }\\n       return true;\\n   }\\n    int maxTaskAssign(vector<int>& tasks, vector<int>& workers, int pills, int strength) {\\n        int s=0;\\n        int e=min(tasks.size(),workers.size());\\n        int ans=0;\\n        sort(tasks.begin(),tasks.end());\\n        sort(workers.begin(),workers.end());\\n        while(s<=e){\\n            int mid=s+(e-s)/2;\\n            if(f(mid,tasks,workers,pills,strength)){\\n                ans=mid;\\n                s=mid+1;\\n            }\\n            else{\\n                e=mid-1;\\n            }\\n        }\\n        return ans;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3563982,
                "title": "easy-c-code",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maxTaskAssign(vector<int>& tasks, vector<int>& workers, int pills, int strength) \\n    {\\n        sort(tasks.begin(), tasks.end());\\n        sort(workers.begin(), workers.end());\\n        int left = 0, right = tasks.size();\\n        while (left < right)\\n        {\\n            int mid = right - (right - left)/2;\\n            if (checkOK(tasks, workers, pills, strength, mid))\\n                left = mid;\\n            else\\n                right = mid-1;\\n        }\\n        return left;        \\n    }\\n    \\n    bool checkOK(vector<int>& tasks, vector<int>& workers, int pills, int strength, int num)\\n    {\\n        if (num > tasks.size()) return false;\\n        if (num > workers.size()) return false;\\n        \\n        multiset<int>Set(workers.begin(), workers.end());        \\n                \\n        for (int i=num-1; i>=0; i--)\\n        {            \\n            if (*Set.rbegin() >= tasks[i])            \\n            {\\n                Set.erase(prev(Set.end()));\\n            }\\n            else \\n            {\\n                if (pills == 0) return false;\\n                auto iter = Set.lower_bound(tasks[i]-strength);\\n                if (iter == Set.end()) return false;\\n                Set.erase(iter);                \\n                pills--;\\n            }\\n        }\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxTaskAssign(vector<int>& tasks, vector<int>& workers, int pills, int strength) \\n    {\\n        sort(tasks.begin(), tasks.end());\\n        sort(workers.begin(), workers.end());\\n        int left = 0, right = tasks.size();\\n        while (left < right)\\n        {\\n            int mid = right - (right - left)/2;\\n            if (checkOK(tasks, workers, pills, strength, mid))\\n                left = mid;\\n            else\\n                right = mid-1;\\n        }\\n        return left;        \\n    }\\n    \\n    bool checkOK(vector<int>& tasks, vector<int>& workers, int pills, int strength, int num)\\n    {\\n        if (num > tasks.size()) return false;\\n        if (num > workers.size()) return false;\\n        \\n        multiset<int>Set(workers.begin(), workers.end());        \\n                \\n        for (int i=num-1; i>=0; i--)\\n        {            \\n            if (*Set.rbegin() >= tasks[i])            \\n            {\\n                Set.erase(prev(Set.end()));\\n            }\\n            else \\n            {\\n                if (pills == 0) return false;\\n                auto iter = Set.lower_bound(tasks[i]-strength);\\n                if (iter == Set.end()) return false;\\n                Set.erase(iter);                \\n                pills--;\\n            }\\n        }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3432787,
                "title": "python-simple-binary-search",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def maxTaskAssign(self, tasks, workers, pills, strength):\\n        tasks.sort()\\n        workers.sort()\\n\\n        def fn(k,pills):\\n            ww = workers[-k:]\\n            \\n            for t in reversed(tasks[:k]):\\n                if t <= ww[-1]: ww.pop()\\n                elif pills and t <= ww[-1] + strength:\\n                    pills -= 1\\n                    i = bisect_left(ww,t-strength)\\n                    ww.pop(i)\\n                else:\\n                    return False\\n\\n            return True\\n        \\n        low, high = 0, min(len(tasks),len(workers))\\n\\n        while low <= high:\\n            mid = (low + high)//2\\n            if fn(mid,pills): low = mid + 1\\n            else: high = mid - 1\\n\\n        return high\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maxTaskAssign(self, tasks, workers, pills, strength):\\n        tasks.sort()\\n        workers.sort()\\n\\n        def fn(k,pills):\\n            ww = workers[-k:]\\n            \\n            for t in reversed(tasks[:k]):\\n                if t <= ww[-1]: ww.pop()\\n                elif pills and t <= ww[-1] + strength:\\n                    pills -= 1\\n                    i = bisect_left(ww,t-strength)\\n                    ww.pop(i)\\n                else:\\n                    return False\\n\\n            return True\\n        \\n        low, high = 0, min(len(tasks),len(workers))\\n\\n        while low <= high:\\n            mid = (low + high)//2\\n            if fn(mid,pills): low = mid + 1\\n            else: high = mid - 1\\n\\n        return high\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3395556,
                "title": "c",
                "content": "```\\nclass Solution {\\n    bool check(int k, const vector<int>& tasks, const vector<int>& workers, int pills, int strength){\\n        int idxW = 0 ;\\n        int finish = 0 ;\\n        multiset<int>Set(workers.end() - k, workers.end()) ;\\n\\n        for(int i = k-1; i >= 0; i--){ \\n            if(*Set.rbegin() >= tasks[i])\\n                Set.erase(prev(Set.end()) );\\n            else{\\n                if(pills == 0)\\n                    return false ;\\n                auto iter = Set.lower_bound(tasks[i] - strength) ;\\n                if(iter == Set.end())\\n                    return false ;\\n                Set.erase(iter) ;\\n                pills-- ;\\n            }\\n        }\\n        return true ;\\n    }\\npublic:\\n    int maxTaskAssign(vector<int>& tasks, vector<int>& workers, int pills, int strength) {\\n        sort(tasks.begin(), tasks.end()) ;\\n        sort(workers.begin(), workers.end()) ;\\n        int left = 0, right = min(tasks.size(), workers.size() ) ;\\n        while(left < right){\\n            int mid = right - (right -left)/2 ;\\n            if(check(mid, tasks, workers, pills, strength))\\n                left = mid ;\\n            else\\n                right = mid - 1 ;\\n        }\\n        return left ;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Sorting",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\n    bool check(int k, const vector<int>& tasks, const vector<int>& workers, int pills, int strength){\\n        int idxW = 0 ;\\n        int finish = 0 ;\\n        multiset<int>Set(workers.end() - k, workers.end()) ;\\n\\n        for(int i = k-1; i >= 0; i--){ \\n            if(*Set.rbegin() >= tasks[i])\\n                Set.erase(prev(Set.end()) );\\n            else{\\n                if(pills == 0)\\n                    return false ;\\n                auto iter = Set.lower_bound(tasks[i] - strength) ;\\n                if(iter == Set.end())\\n                    return false ;\\n                Set.erase(iter) ;\\n                pills-- ;\\n            }\\n        }\\n        return true ;\\n    }\\npublic:\\n    int maxTaskAssign(vector<int>& tasks, vector<int>& workers, int pills, int strength) {\\n        sort(tasks.begin(), tasks.end()) ;\\n        sort(workers.begin(), workers.end()) ;\\n        int left = 0, right = min(tasks.size(), workers.size() ) ;\\n        while(left < right){\\n            int mid = right - (right -left)/2 ;\\n            if(check(mid, tasks, workers, pills, strength))\\n                left = mid ;\\n            else\\n                right = mid - 1 ;\\n        }\\n        return left ;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3271975,
                "title": "just-a-runnable-solution",
                "content": "# Code\\n```\\nimpl Solution {\\n    pub fn max_task_assign(tasks: Vec<i32>, workers: Vec<i32>, pills: i32, strength: i32) -> i32 {\\n        use std::collections::VecDeque;\\n\\n        fn check(tasks: &[i32], workers: &[i32], pills: i32, strength: i32, k: usize) -> bool {\\n            let mut pills = pills;\\n            if k > workers.len() {\\n                return false;\\n            }\\n            let mut t = 0;\\n            let mut q = VecDeque::new();\\n            for i in (0..k).rev() {\\n                if q.is_empty() && t < k {\\n                    q.push_front(tasks[t]);\\n                    t += 1;\\n                }\\n                if *q.back().unwrap() <= workers[i] {\\n                    q.pop_back();\\n                } else {\\n                    if pills == 0 {\\n                        return false;\\n                    }\\n                    if *q.back().unwrap() > workers[i] + strength {\\n                        return false;\\n                    }\\n                    while t < k && tasks[t] <= workers[i] + strength {\\n                        q.push_front(tasks[t]);\\n                        t += 1;\\n                    }\\n                    q.pop_front();\\n                    pills -= 1;\\n                }\\n            }\\n            true\\n        }\\n\\n        let (mut l, mut r) = (0, tasks.len());\\n        let mut tasks = tasks;\\n        let mut workers = workers;\\n        tasks.sort();\\n        workers.sort_by(|a, b| b.cmp(a));\\n        while l < r {\\n            let mid = (l + r + 1) / 2;\\n            if check(&tasks, &workers, pills, strength, mid) {\\n                l = mid;\\n            } else {\\n                r = mid - 1;\\n            }\\n        }\\n        l as i32\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nimpl Solution {\\n    pub fn max_task_assign(tasks: Vec<i32>, workers: Vec<i32>, pills: i32, strength: i32) -> i32 {\\n        use std::collections::VecDeque;\\n\\n        fn check(tasks: &[i32], workers: &[i32], pills: i32, strength: i32, k: usize) -> bool {\\n            let mut pills = pills;\\n            if k > workers.len() {\\n                return false;\\n            }\\n            let mut t = 0;\\n            let mut q = VecDeque::new();\\n            for i in (0..k).rev() {\\n                if q.is_empty() && t < k {\\n                    q.push_front(tasks[t]);\\n                    t += 1;\\n                }\\n                if *q.back().unwrap() <= workers[i] {\\n                    q.pop_back();\\n                } else {\\n                    if pills == 0 {\\n                        return false;\\n                    }\\n                    if *q.back().unwrap() > workers[i] + strength {\\n                        return false;\\n                    }\\n                    while t < k && tasks[t] <= workers[i] + strength {\\n                        q.push_front(tasks[t]);\\n                        t += 1;\\n                    }\\n                    q.pop_front();\\n                    pills -= 1;\\n                }\\n            }\\n            true\\n        }\\n\\n        let (mut l, mut r) = (0, tasks.len());\\n        let mut tasks = tasks;\\n        let mut workers = workers;\\n        tasks.sort();\\n        workers.sort_by(|a, b| b.cmp(a));\\n        while l < r {\\n            let mid = (l + r + 1) / 2;\\n            if check(&tasks, &workers, pills, strength, mid) {\\n                l = mid;\\n            } else {\\n                r = mid - 1;\\n            }\\n        }\\n        l as i32\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3120772,
                "title": "binary-search-and-deque",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nnlogn\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\no(n)\\n# Code\\n```\\nclass Solution {\\n    public int maxTaskAssign(int[] tasks, int[] workers, int pills, int strength) {\\n        Arrays.sort(tasks);\\n        Arrays.sort(workers);\\n\\n        int lo=0,hi=Math.min(tasks.length, workers.length);\\n\\n        while(lo<hi) {\\n            int mid = (lo+hi+1)/2;\\n            if(check(mid,tasks,workers,pills,strength)) {\\n                lo = mid;\\n            } else {\\n                hi = mid-1;\\n            }\\n        }\\n        return lo;\\n    }\\n\\n    boolean check(int k, int[] tasks, int[] workers, int pills, int strength) {\\n        Deque<Integer> q = new LinkedList<>();\\n        int j = workers.length-1;\\n        for(int i=k-1; i>=0; i--) {\\n            while(j>=workers.length-k && (workers[j]>=tasks[i] || workers[j] + strength>= tasks[i])) {\\n                q.addFirst(workers[j]);\\n                j--;\\n            }\\n            if(q.isEmpty())\\n                return false;\\n            if(q.getLast()>=tasks[i]){\\n                q.pollLast();\\n            } else {\\n                if(pills<=0)\\n                    return false;\\n                q.pollFirst();\\n                pills--;\\n            }\\n        }\\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int maxTaskAssign(int[] tasks, int[] workers, int pills, int strength) {\\n        Arrays.sort(tasks);\\n        Arrays.sort(workers);\\n\\n        int lo=0,hi=Math.min(tasks.length, workers.length);\\n\\n        while(lo<hi) {\\n            int mid = (lo+hi+1)/2;\\n            if(check(mid,tasks,workers,pills,strength)) {\\n                lo = mid;\\n            } else {\\n                hi = mid-1;\\n            }\\n        }\\n        return lo;\\n    }\\n\\n    boolean check(int k, int[] tasks, int[] workers, int pills, int strength) {\\n        Deque<Integer> q = new LinkedList<>();\\n        int j = workers.length-1;\\n        for(int i=k-1; i>=0; i--) {\\n            while(j>=workers.length-k && (workers[j]>=tasks[i] || workers[j] + strength>= tasks[i])) {\\n                q.addFirst(workers[j]);\\n                j--;\\n            }\\n            if(q.isEmpty())\\n                return false;\\n            if(q.getLast()>=tasks[i]){\\n                q.pollLast();\\n            } else {\\n                if(pills<=0)\\n                    return false;\\n                q.pollFirst();\\n                pills--;\\n            }\\n        }\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3028750,
                "title": "javascript-c-binarysearch-queue",
                "content": "# Greedy Approach\\n- Pills are precious, so avoid using them as much as possible\\n- In case we are forced to use pills, give pill to lower potential worker who can complete the task, i.e., **workerEngergy < task --whereas-- workerEnergy + strengthFromOnePill >= task**\\n- deque store the workers in decreasing order of their potential\\n\\n# Complexity\\n- Time complexity: $$O(n^2)$$\\n- Space complexity: $$O(n)$$\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maxTaskAssign(vector<int>& tasks, vector<int>& workers, int pills, int strength) {\\n        sort(begin(workers), end(workers));\\n        sort(begin(tasks), end(tasks));\\n\\n        int lTasks = -1, rTasks = min(tasks.size(), workers.size()) - 1;\\n\\n        while (lTasks < rTasks) {\\n            int midTasks = (lTasks + rTasks + 1) >> 1, t = midTasks;\\n            deque<int> dq;\\n\\n            for (int w = workers.size() - 1, freePills = pills; t >= 0; t--) {\\n                if (dq.size() > 0 && dq.front() >= tasks.at(t)) {\\n                    dq.pop_front();\\n                } else if (w >= 0 && workers.at(w) >= tasks.at(t)) {\\n                    w--;\\n                } else if (freePills > 0) {\\n                    while (w >= 0 && workers.at(w) + strength >= tasks.at(t))\\n                        dq.push_back(workers.at(w--));\\n\\n                    if (dq.size() == 0) break;\\n                    dq.pop_back(), freePills--;\\n                } else break;\\n            }\\n\\n            t == -1 ? lTasks = midTasks : rTasks = midTasks - 1;\\n        }\\n\\n        return lTasks + 1;\\n    }\\n};\\n```\\n```\\nvar maxTaskAssign = function(tasks, workers, pills, strength) {\\n    workers.sort((b, a) => b - a);\\n    tasks.sort((b, a) => b - a);\\n\\n    let lTasks = -1, rTasks = Math.min(tasks.length, workers.length) - 1;\\n\\n    while (lTasks < rTasks) {\\n        const midTasks = (lTasks + rTasks + 1) >> 1;\\n        let t = midTasks;\\n\\n        for (let w = workers.length - 1, freePills = pills, queue = []; t >= 0; t--) {\\n            if (queue[0] >= tasks[t]) {\\n                queue.shift();\\n            } else if (workers[w] >= tasks[t]) {\\n                w--;\\n            } else if (freePills > 0) {\\n                while (w >= 0 && workers[w] + strength >= tasks[t])\\n                    queue.push(workers[w--]);\\n\\n                if (queue.length == 0) break;\\n                queue.pop(), freePills--;\\n            } else break;\\n        }\\n        t == -1 ? lTasks = midTasks : rTasks = midTasks - 1;\\n    }\\n    return lTasks + 1;\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "JavaScript",
                    "Binary Search",
                    "Queue",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxTaskAssign(vector<int>& tasks, vector<int>& workers, int pills, int strength) {\\n        sort(begin(workers), end(workers));\\n        sort(begin(tasks), end(tasks));\\n\\n        int lTasks = -1, rTasks = min(tasks.size(), workers.size()) - 1;\\n\\n        while (lTasks < rTasks) {\\n            int midTasks = (lTasks + rTasks + 1) >> 1, t = midTasks;\\n            deque<int> dq;\\n\\n            for (int w = workers.size() - 1, freePills = pills; t >= 0; t--) {\\n                if (dq.size() > 0 && dq.front() >= tasks.at(t)) {\\n                    dq.pop_front();\\n                } else if (w >= 0 && workers.at(w) >= tasks.at(t)) {\\n                    w--;\\n                } else if (freePills > 0) {\\n                    while (w >= 0 && workers.at(w) + strength >= tasks.at(t))\\n                        dq.push_back(workers.at(w--));\\n\\n                    if (dq.size() == 0) break;\\n                    dq.pop_back(), freePills--;\\n                } else break;\\n            }\\n\\n            t == -1 ? lTasks = midTasks : rTasks = midTasks - 1;\\n        }\\n\\n        return lTasks + 1;\\n    }\\n};\\n```\n```\\nvar maxTaskAssign = function(tasks, workers, pills, strength) {\\n    workers.sort((b, a) => b - a);\\n    tasks.sort((b, a) => b - a);\\n\\n    let lTasks = -1, rTasks = Math.min(tasks.length, workers.length) - 1;\\n\\n    while (lTasks < rTasks) {\\n        const midTasks = (lTasks + rTasks + 1) >> 1;\\n        let t = midTasks;\\n\\n        for (let w = workers.length - 1, freePills = pills, queue = []; t >= 0; t--) {\\n            if (queue[0] >= tasks[t]) {\\n                queue.shift();\\n            } else if (workers[w] >= tasks[t]) {\\n                w--;\\n            } else if (freePills > 0) {\\n                while (w >= 0 && workers[w] + strength >= tasks[t])\\n                    queue.push(workers[w--]);\\n\\n                if (queue.length == 0) break;\\n                queue.pop(), freePills--;\\n            } else break;\\n        }\\n        t == -1 ? lTasks = midTasks : rTasks = midTasks - 1;\\n    }\\n    return lTasks + 1;\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2865602,
                "title": "python-sortedlist-or-bisect",
                "content": "There are 2 ways of doing binary search for this problem using Python\\nLet N, M be the legth of tasks and worker respectively.\\n1. SortedList - TC: `logN * N * logM * logM`\\n2. bisect &nbsp; &nbsp; &nbsp; &nbsp;- TC: `logN * N * logM * M`\\n\\nHere\\n` logN` is from the outest binary search\\n`N` is from the for loop in check() function for `bottom_task`\\n`logM` is from `top_workers.bisect_left()`\\n\\nThe difference between the 2 method is on the `top_workers.pop`.\\n`pop` from a SortedList should be taking `logM`\\n`pop` from a List in Python with argument should be taking a worst `M`\\n\\n\\nBut when using SortedList it gives TLE. I\\'m confused, shouldn\\'t SortedList be faster then List in Python when doing a `.pop()` operation?\\n\\nSortedList solution\\n```python\\nfrom sortedcontainers import SortedList\\n\\n\\nclass Solution:\\n    def maxTaskAssign(self, tasks: List[int], workers: List[int], pills: int, strength: int) -> int:\\n        n, m = len(tasks), len(workers)\\n        tasks.sort()\\n        workers.sort()\\n        \\n        \\n        def check(k):\\n            top_workers = SortedList(workers[-k:])\\n            bottom_tasks = tasks[:k][::-1]\\n            pill_needed = 0\\n\\n            for task in bottom_tasks:\\n                idx = top_workers.bisect_left(task)\\n                if idx < len(top_workers):\\n                    top_workers.pop(idx)\\n                    continue\\n                \\n                idx = top_workers.bisect_left(task - strength)\\n                if idx < len(top_workers):\\n                    top_workers.pop(idx)\\n                    pill_needed += 1\\n                else:\\n                    return float(\\'inf\\')\\n\\n            return pill_needed\\n        \\n        left, right = 0, min(n, m)\\n        while left <= right:\\n            should_complete = (left + right) // 2\\n            pill_needed = check(should_complete)\\n            # print(left, right, should_complete, pill_needed)\\n            \\n            if pill_needed <= pills:\\n                left = should_complete + 1\\n            else:\\n                right = should_complete - 1\\n                \\n        return right\\n```\\n\\n\\nbisect solution:\\n```python\\nimport bisect\\n\\n\\nclass Solution:\\n    def maxTaskAssign(self, tasks: List[int], workers: List[int], pills: int, strength: int) -> int:\\n        n, m = len(tasks), len(workers)\\n        tasks.sort()\\n        workers.sort()\\n                \\n\\n        def check(k):\\n            top_workers = workers[-k:]\\n            bottom_tasks = tasks[:k][::-1]\\n            pill_needed = 0\\n\\n            for task in bottom_tasks:\\n                idx = bisect.bisect_left(top_workers, task)\\n                if idx < len(top_workers):\\n                    top_workers.pop(idx)\\n                    continue\\n                    \\n                idx = bisect.bisect_left(top_workers, task - strength)\\n                if idx < len(top_workers):\\n                    top_workers.pop(idx)\\n                    pill_needed += 1\\n                else:\\n                    return float(\\'inf\\')\\n                \\n            return pill_needed\\n\\n        left, right = 0, min(n, m)\\n        while left <= right:\\n            should_complete = (left + right) // 2\\n            pill_needed = check(should_complete)\\n            # print(left, right, should_complete, pill_needed)\\n\\n            if pill_needed <= pills:\\n                left = should_complete + 1\\n            else:\\n                right = should_complete - 1\\n        \\n        return right\\n```",
                "solutionTags": [
                    "Binary Tree"
                ],
                "code": "```python\\nfrom sortedcontainers import SortedList\\n\\n\\nclass Solution:\\n    def maxTaskAssign(self, tasks: List[int], workers: List[int], pills: int, strength: int) -> int:\\n        n, m = len(tasks), len(workers)\\n        tasks.sort()\\n        workers.sort()\\n        \\n        \\n        def check(k):\\n            top_workers = SortedList(workers[-k:])\\n            bottom_tasks = tasks[:k][::-1]\\n            pill_needed = 0\\n\\n            for task in bottom_tasks:\\n                idx = top_workers.bisect_left(task)\\n                if idx < len(top_workers):\\n                    top_workers.pop(idx)\\n                    continue\\n                \\n                idx = top_workers.bisect_left(task - strength)\\n                if idx < len(top_workers):\\n                    top_workers.pop(idx)\\n                    pill_needed += 1\\n                else:\\n                    return float(\\'inf\\')\\n\\n            return pill_needed\\n        \\n        left, right = 0, min(n, m)\\n        while left <= right:\\n            should_complete = (left + right) // 2\\n            pill_needed = check(should_complete)\\n            # print(left, right, should_complete, pill_needed)\\n            \\n            if pill_needed <= pills:\\n                left = should_complete + 1\\n            else:\\n                right = should_complete - 1\\n                \\n        return right\\n```\n```python\\nimport bisect\\n\\n\\nclass Solution:\\n    def maxTaskAssign(self, tasks: List[int], workers: List[int], pills: int, strength: int) -> int:\\n        n, m = len(tasks), len(workers)\\n        tasks.sort()\\n        workers.sort()\\n                \\n\\n        def check(k):\\n            top_workers = workers[-k:]\\n            bottom_tasks = tasks[:k][::-1]\\n            pill_needed = 0\\n\\n            for task in bottom_tasks:\\n                idx = bisect.bisect_left(top_workers, task)\\n                if idx < len(top_workers):\\n                    top_workers.pop(idx)\\n                    continue\\n                    \\n                idx = bisect.bisect_left(top_workers, task - strength)\\n                if idx < len(top_workers):\\n                    top_workers.pop(idx)\\n                    pill_needed += 1\\n                else:\\n                    return float(\\'inf\\')\\n                \\n            return pill_needed\\n\\n        left, right = 0, min(n, m)\\n        while left <= right:\\n            should_complete = (left + right) // 2\\n            pill_needed = check(should_complete)\\n            # print(left, right, should_complete, pill_needed)\\n\\n            if pill_needed <= pills:\\n                left = should_complete + 1\\n            else:\\n                right = should_complete - 1\\n        \\n        return right\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2696511,
                "title": "python-binary-search-and-greedy-check",
                "content": "```\\nfrom bisect import bisect_left\\n\\nclass Solution:\\n    def maxTaskAssign(self, tasks: List[int], workers: List[int], pills: int, strength: int) -> int:\\n        tasks.sort()\\n        workers.sort()\\n        ans, lo, hi = 0, 1, min(len(workers), len(tasks))\\n        while lo <= hi:\\n            mid = (lo + hi) // 2\\n            cp, cw = pills, workers[-mid:]\\n            for i, t in enumerate(reversed(tasks[:mid])):\\n                if cw[-1] >= t: cw.pop(-1)\\n                elif cw[-1] + strength >= t and cp:\\n                    pos = bisect_left(cw, t - strength)\\n                    cw[pos : pos + 1] = []\\n                    cp -= 1\\n                if len(cw) + i + 1 != mid: break\\n            if cw: hi = mid - 1\\n            else:\\n                ans = max(ans, mid)\\n                lo = mid + 1\\n        return ans\\n```",
                "solutionTags": [],
                "code": "```\\nfrom bisect import bisect_left\\n\\nclass Solution:\\n    def maxTaskAssign(self, tasks: List[int], workers: List[int], pills: int, strength: int) -> int:\\n        tasks.sort()\\n        workers.sort()\\n        ans, lo, hi = 0, 1, min(len(workers), len(tasks))\\n        while lo <= hi:\\n            mid = (lo + hi) // 2\\n            cp, cw = pills, workers[-mid:]\\n            for i, t in enumerate(reversed(tasks[:mid])):\\n                if cw[-1] >= t: cw.pop(-1)\\n                elif cw[-1] + strength >= t and cp:\\n                    pos = bisect_left(cw, t - strength)\\n                    cw[pos : pos + 1] = []\\n                    cp -= 1\\n                if len(cw) + i + 1 != mid: break\\n            if cw: hi = mid - 1\\n            else:\\n                ans = max(ans, mid)\\n                lo = mid + 1\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2581233,
                "title": "exlplanation-why-binearysearch-works-greedy-does-not",
                "content": "```\\n    def maxTaskAssign(self, tasks: List[int], workers: List[int], pills: int, strength: int) -> int:\\n        \\n        maxTasks = min(len(tasks), len(workers))\\n        workers.sort()\\n        tasks.sort()\\n        #u can try a greedy approach, I spent days and it got better but it didnt work 100% time\\n        #but binarySearch approach guarantees the correct solution\\n        #because u can develop a checking algorithm to check if answer is correct\\n        \\n        def isValid(maxTask):\\n            #find all the workers who can do the c_strongestTask with/without the pill, put them in a que\\n            #if the first item in que doesnt require pill, use it, otherwise\\n            #use the last item in que to do the c_task -> this frees up stronger guys to do weaker tasks without pill\\n            #the next_strongestTask can be handelled by all items in the que, but add some new ones aswell\\n            #repeat the same process\\n            #this whole process can be done in Time->O(N), Space->O(N)\\n            \\n            #u can also use binarySearch here,Time->O(NlogN), &, \\n            #pretty sure Space->O(N) because u have to find some way to keep track of workers on which pill was used\\n            canHandle = deque([])\\n            t_i = maxTask-1; w_i = len(workers)-1\\n            pill = pills\\n            while t_i >= 0:\\n                c_task = tasks[t_i]\\n                \\n                while w_i >= 0 and workers[w_i] + strength >= c_task:\\n                    canHandle.append(workers[w_i])\\n                    w_i -= 1\\n                if not canHandle: #no worker available to do this task\\n                    return False\\n                \\n                if canHandle[0] >= c_task: #strongest available worker can do this task withoutpill\\n                    canHandle.popleft()\\n                #need to use a pill\\n                elif pill:\\n                    canHandle.pop()\\n                    pill -= 1\\n                #no pills left :(\\n                else:\\n                    return False\\n                t_i -= 1\\n            return True\\n        \\n        L = 0; R = maxTasks\\n        while L < R:\\n            M = (L+R+1)//2\\n            if isValid(M):\\n                L = M\\n            else:\\n                R = M-1\\n        \\n        return L\\n```",
                "solutionTags": [
                    "Python",
                    "Greedy",
                    "Binary Tree"
                ],
                "code": "```\\n    def maxTaskAssign(self, tasks: List[int], workers: List[int], pills: int, strength: int) -> int:\\n        \\n        maxTasks = min(len(tasks), len(workers))\\n        workers.sort()\\n        tasks.sort()\\n        #u can try a greedy approach, I spent days and it got better but it didnt work 100% time\\n        #but binarySearch approach guarantees the correct solution\\n        #because u can develop a checking algorithm to check if answer is correct\\n        \\n        def isValid(maxTask):\\n            #find all the workers who can do the c_strongestTask with/without the pill, put them in a que\\n            #if the first item in que doesnt require pill, use it, otherwise\\n            #use the last item in que to do the c_task -> this frees up stronger guys to do weaker tasks without pill\\n            #the next_strongestTask can be handelled by all items in the que, but add some new ones aswell\\n            #repeat the same process\\n            #this whole process can be done in Time->O(N), Space->O(N)\\n            \\n            #u can also use binarySearch here,Time->O(NlogN), &, \\n            #pretty sure Space->O(N) because u have to find some way to keep track of workers on which pill was used\\n            canHandle = deque([])\\n            t_i = maxTask-1; w_i = len(workers)-1\\n            pill = pills\\n            while t_i >= 0:\\n                c_task = tasks[t_i]\\n                \\n                while w_i >= 0 and workers[w_i] + strength >= c_task:\\n                    canHandle.append(workers[w_i])\\n                    w_i -= 1\\n                if not canHandle: #no worker available to do this task\\n                    return False\\n                \\n                if canHandle[0] >= c_task: #strongest available worker can do this task withoutpill\\n                    canHandle.popleft()\\n                #need to use a pill\\n                elif pill:\\n                    canHandle.pop()\\n                    pill -= 1\\n                #no pills left :(\\n                else:\\n                    return False\\n                t_i -= 1\\n            return True\\n        \\n        L = 0; R = maxTasks\\n        while L < R:\\n            M = (L+R+1)//2\\n            if isValid(M):\\n                L = M\\n            else:\\n                R = M-1\\n        \\n        return L\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2568513,
                "title": "c-with-komments",
                "content": "```\\nint maxTaskAssign(vector<int>& tasks, vector<int>& ws, int pills, int strength) {\\n        sort(tasks.begin(), tasks.end());\\n        sort(ws.begin(), ws.end());\\n        \\n        \\n        int l = 0, r = min(tasks.size(), ws.size());\\n        while(l<r){\\n            int m = (l+r+1)/2, need = 0;\\n            \\n            // using multiset bcz it\\'s optimal for removing elements\\n            // creating set of the strongest \\'m\\' workers in multiset\\n            multiset<int> ms(ws.end() - m, end(ws)); \\n            \\n            for(int i=m-1; i>=0; --i){\\n                // iterating over \\'m\\' smallests tasks\\n                \\n                auto it = ms.end();\\n                it--;   // itr of last element of multiset; \\n                \\n                if(*it >= tasks[i]){\\n                    // without pill, worker strong enough to do task\\n                    ms.erase(it);\\n                }\\n                else{\\n                    // checking if possible with using magic-pill\\n                    it = ms.lower_bound(tasks[i]-strength);\\n                    if(it == end(ms) || ++need > pills)\\n                        break;\\n                    ms.erase(it);\\n                }\\n                \\n            }\\n\\n            if(ms.empty())\\n                // All \\'m\\' tasks got a worker assigned to them\\n                l = m;\\n            else\\n                r = m-1;\\n        }\\n        return l;       \\n    }\\n```",
                "solutionTags": [],
                "code": "```\\nint maxTaskAssign(vector<int>& tasks, vector<int>& ws, int pills, int strength) {\\n        sort(tasks.begin(), tasks.end());\\n        sort(ws.begin(), ws.end());\\n        \\n        \\n        int l = 0, r = min(tasks.size(), ws.size());\\n        while(l<r){\\n            int m = (l+r+1)/2, need = 0;\\n            \\n            // using multiset bcz it\\'s optimal for removing elements\\n            // creating set of the strongest \\'m\\' workers in multiset\\n            multiset<int> ms(ws.end() - m, end(ws)); \\n            \\n            for(int i=m-1; i>=0; --i){\\n                // iterating over \\'m\\' smallests tasks\\n                \\n                auto it = ms.end();\\n                it--;   // itr of last element of multiset; \\n                \\n                if(*it >= tasks[i]){\\n                    // without pill, worker strong enough to do task\\n                    ms.erase(it);\\n                }\\n                else{\\n                    // checking if possible with using magic-pill\\n                    it = ms.lower_bound(tasks[i]-strength);\\n                    if(it == end(ms) || ++need > pills)\\n                        break;\\n                    ms.erase(it);\\n                }\\n                \\n            }\\n\\n            if(ms.empty())\\n                // All \\'m\\' tasks got a worker assigned to them\\n                l = m;\\n            else\\n                r = m-1;\\n        }\\n        return l;       \\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2468971,
                "title": "greedy-binary-search",
                "content": "```\\nclass Solution {\\npublic:\\n    int maxTaskAssign(vector<int>& tasks, vector<int>& workers, int pills, int strength) {\\n        // is it optimal to give all pills to the \\n        // people with highest stength ??? \\n        \\n        // No \\n        \\n        // Observation : If I give a pill to ith person, then \\n        // it must be taking some task, otherwise I won\\'t \\n        // be giving him any pill \\n        \\n        \\n        // what if there are no pills ?\\n        \\n        // If I can complete any x tasks, I can also complete \\n        // x smallest tasks \\n        \\n        // x1 < x2 < x3 < x4 < ............\\n        // So, it can\\'t  be that I assign xi but not xj with j<i \\n        // So, always start assigning task from 1 \\n        \\n        // Binary search on the answer \\n        int n = tasks.size();\\n        int m =workers.size();\\n        \\n        sort(tasks.begin(),tasks.end());\\n        \\n        int low=0;\\n        int high=n;\\n        int ans=0;\\n        while(low<=high){\\n            int mid=(low+high)/2;\\n            bool f=true;\\n            multiset<int>ms;\\n            \\n            for(auto e:workers)\\n              ms.insert(e);\\n            \\n            int count=0;\\n            \\n            for(int i=mid-1;i>=0;i--){\\n              auto it=ms.lower_bound(tasks[i]);\\n                if(it!=ms.end()){\\n                    ms.erase(it);\\n                    continue;\\n                }\\n                \\n                // val + strength >= tasks[i]\\n                // val>=tasks[i]-strength \\n               it=ms.lower_bound(tasks[i]-strength);\\n                \\n                if(it==ms.end())\\n                {\\n                    f=false;\\n                    break;\\n                }\\n                \\n                ++count;\\n                if(count>pills){\\n                    f=false;\\n                    break;\\n                }\\n\\n                ms.erase(it);\\n            }\\n            if(f){\\n                ans=mid;\\n                low=mid+1;\\n            }\\n            else \\n                high=mid-1;\\n        }\\n        return ans;\\n        \\n        \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxTaskAssign(vector<int>& tasks, vector<int>& workers, int pills, int strength) {\\n        // is it optimal to give all pills to the \\n        // people with highest stength ??? \\n        \\n        // No \\n        \\n        // Observation : If I give a pill to ith person, then \\n        // it must be taking some task, otherwise I won\\'t \\n        // be giving him any pill \\n        \\n        \\n        // what if there are no pills ?\\n        \\n        // If I can complete any x tasks, I can also complete \\n        // x smallest tasks \\n        \\n        // x1 < x2 < x3 < x4 < ............\\n        // So, it can\\'t  be that I assign xi but not xj with j<i \\n        // So, always start assigning task from 1 \\n        \\n        // Binary search on the answer \\n        int n = tasks.size();\\n        int m =workers.size();\\n        \\n        sort(tasks.begin(),tasks.end());\\n        \\n        int low=0;\\n        int high=n;\\n        int ans=0;\\n        while(low<=high){\\n            int mid=(low+high)/2;\\n            bool f=true;\\n            multiset<int>ms;\\n            \\n            for(auto e:workers)\\n              ms.insert(e);\\n            \\n            int count=0;\\n            \\n            for(int i=mid-1;i>=0;i--){\\n              auto it=ms.lower_bound(tasks[i]);\\n                if(it!=ms.end()){\\n                    ms.erase(it);\\n                    continue;\\n                }\\n                \\n                // val + strength >= tasks[i]\\n                // val>=tasks[i]-strength \\n               it=ms.lower_bound(tasks[i]-strength);\\n                \\n                if(it==ms.end())\\n                {\\n                    f=false;\\n                    break;\\n                }\\n                \\n                ++count;\\n                if(count>pills){\\n                    f=false;\\n                    break;\\n                }\\n\\n                ms.erase(it);\\n            }\\n            if(f){\\n                ans=mid;\\n                low=mid+1;\\n            }\\n            else \\n                high=mid-1;\\n        }\\n        return ans;\\n        \\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2415285,
                "title": "c-multiset-greedy-binary-search",
                "content": "My idea is simple. We have 3 observations:\\n1. If we can do n tasks then we can do n-1 tasks => We use binary search to find result.\\n2. If we do n tasks we will chooses n smallest tasks and n highest workers (greedy)\\n3. For one worker we will assign it to nearest task. If no nearest task smaller than worker, we will use pill on this worker and find nearest task with new strength => We use binary search to find nearest task.\\n\\nHere is my code implement this idea. If you find this helpful, please upvote.\\n```\\nclass Solution {\\npublic:\\n    int maxTaskAssign(vector<int>& tasks, vector<int>& workers, int pills, int strength) {\\n        sort(tasks.begin(), tasks.end());\\n        sort(workers.begin(), workers.end());\\n        int low = 1;\\n        int high = min(tasks.size(), workers.size());\\n        while(low<=high){\\n            int mid = (low+high)/2;\\n            int can = 1;\\n            int temp = pills;\\n            multiset<int> solved_tasks;\\n            for(int i = 0; i<mid; i++){\\n                solved_tasks.insert(tasks[i]);\\n            }\\n            \\n            for(int i=workers.size()-mid; i<workers.size(); i++){\\n                auto it = solved_tasks.upper_bound(workers[i]);\\n                if(it != solved_tasks.begin()){\\n                    it--;\\n                    solved_tasks.erase(it);\\n                    continue;\\n                }\\n                if(temp==0){\\n                    can = 0;\\n                    break;\\n                }\\n                it = solved_tasks.upper_bound(workers[i]+strength);\\n                if(it != solved_tasks.begin()){\\n                    temp--;\\n                    it --;\\n                    solved_tasks.erase(it);\\n                }\\n                else{\\n                    can = 0;\\n                    break;\\n                }\\n            }\\n            if(can){\\n                low = mid+1;\\n            }\\n            else{\\n                high = mid-1;\\n            }\\n        }\\n        return low-1;\\n    }\\n};",
                "solutionTags": [
                    "Greedy",
                    "Binary Tree"
                ],
                "code": "class Solution {\\npublic:\\n    int maxTaskAssign(vector<int>& tasks, vector<int>& workers, int pills, int strength) {\\n        sort(tasks.begin(), tasks.end());\\n        sort(workers.begin(), workers.end());\\n        int low = 1;\\n        int high = min(tasks.size(), workers.size());\\n        while(low<=high){\\n            int mid = (low+high)/2;\\n            int can = 1;\\n            int temp = pills;\\n            multiset<int> solved_tasks;\\n            for(int i = 0; i<mid; i++){\\n                solved_tasks.insert(tasks[i]);\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2385113,
                "title": "python3-o-nlogn-bs-queue",
                "content": "Note the `check` takes O(n), starting from the hardest task, if the strongest worker can take it, then let the worker do it, otherwise find the weakest worker who can do it with the pill. So we can maintain a queue which contains all workers who can do it with the pill. If the strongest one (`queue[0]`) can do it without pill, good. Otherwise the  `queue[-1]` is the weakest one who can do it with pill. For the next task, all remaining in the queue can still do it with the pill, since all of them can do the harder one earlier. So we just need to extend the queue to add these who can do the easier task with the pill now, but was able to do the harder one in last round. At the end, each worker can enter the queue at most once. so total time complexity is O(N)\\n\\t\\n```\\nclass Solution:\\n    def maxTaskAssign(self, tasks: List[int], workers: List[int], pills: int, strength: int) -> int:\\n        def check(x, tasks, workers, pills, strength):\\n            queue = collections.deque()\\n            start = 0\\n            for i in range(x-1, -1, -1):\\n                task = tasks[i]\\n                while start <= min(x-1, len(workers)-1) and workers[start] + strength >= task:\\n                    queue.append(start)\\n                    start += 1\\n                if not queue:\\n                    return False\\n                if workers[queue[0]] >= task:\\n                    queue.popleft()\\n                else:\\n                    pills -= 1\\n                    if pills < 0:\\n                        return False\\n                    queue.pop()\\n            return True\\n                    \\n                \\n            \\n        tasks = sorted(tasks)\\n        workers = sorted(workers, reverse=True)\\n        low, high = 0, len(tasks)\\n        ans = 0\\n        while low <= high:\\n            mid = low + (high - low) // 2\\n            if check(mid, tasks, workers, pills, strength):\\n                ans = max(ans, mid)\\n                low = mid + 1\\n            else:\\n                high = mid - 1\\n        return ans\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def maxTaskAssign(self, tasks: List[int], workers: List[int], pills: int, strength: int) -> int:\\n        def check(x, tasks, workers, pills, strength):\\n            queue = collections.deque()\\n            start = 0\\n            for i in range(x-1, -1, -1):\\n                task = tasks[i]\\n                while start <= min(x-1, len(workers)-1) and workers[start] + strength >= task:\\n                    queue.append(start)\\n                    start += 1\\n                if not queue:\\n                    return False\\n                if workers[queue[0]] >= task:\\n                    queue.popleft()\\n                else:\\n                    pills -= 1\\n                    if pills < 0:\\n                        return False\\n                    queue.pop()\\n            return True\\n                    \\n                \\n            \\n        tasks = sorted(tasks)\\n        workers = sorted(workers, reverse=True)\\n        low, high = 0, len(tasks)\\n        ans = 0\\n        while low <= high:\\n            mid = low + (high - low) // 2\\n            if check(mid, tasks, workers, pills, strength):\\n                ans = max(ans, mid)\\n                low = mid + 1\\n            else:\\n                high = mid - 1\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2347386,
                "title": "optimal-solution-no-binary-seach-o-nlogn",
                "content": "Sort both tasks and workers in decreasing order.\\\\\\nLet `used` denotes a set of workers using pills.\\n* If the hardest task is smaller than the strongest worker, add `1` to the answer, remove both of the task and the worker \\n* Otherwise, a worker must takes the pills to be able to do the task. As one must be chosen, we would choose the weakest worker than can do the task after taking the pill since there\\'s higher chance more tasks can be completed  thanks to the stronger strength of other\\'s \\n* If we could not find a worker can do the task even after taking the pill, or simply there\\'s just no pill left, we would force the strongest worker who had taken the pill to quit his taskes and give up his pill and do the task .There are two case. If the worker is stronger than the task, this case we would gain back 1 pill, otherwise the worker would still have to use the pill to complete the task (he took the pill and do a harder task previously so it\\'s guaranteed he could do the task if he took one). Either case, the number of completed tasks is unchanged and more pills could possibly be gained, hence we achieve the optimal solution. If there is not such a worker, then simply this task could not done, leave it and proceed to the next one.\\n\\n```python\\ndef maxTaskAssign(self, tasks: List[int], workers: List[int], pills: int, strength: int) -> int:\\n        tasks.sort(reverse=True)\\n        from sortedcontainers import SortedList\\n        pool = SortedList(workers)\\n        i = res = c = 0\\n        used = SortedList()\\n        while i < len(tasks) and pool:\\n            if tasks[i] <= pool[-1]:\\n                c += 1\\n                pool.pop()\\n            else:\\n                j = pool.bisect_left(tasks[i] - strength)\\n                if (j == len(pool) or len(used) == pills) and used:\\n                    pool.add(used.pop())\\n                    continue\\n                if j < len(pool) and pills:\\n                    used.add(pool.pop(j))\\n            i += 1\\n            res = max(res, c + len(used))\\n        return res\\n```",
                "solutionTags": [],
                "code": "```python\\ndef maxTaskAssign(self, tasks: List[int], workers: List[int], pills: int, strength: int) -> int:\\n        tasks.sort(reverse=True)\\n        from sortedcontainers import SortedList\\n        pool = SortedList(workers)\\n        i = res = c = 0\\n        used = SortedList()\\n        while i < len(tasks) and pool:\\n            if tasks[i] <= pool[-1]:\\n                c += 1\\n                pool.pop()\\n            else:\\n                j = pool.bisect_left(tasks[i] - strength)\\n                if (j == len(pool) or len(used) == pills) and used:\\n                    pool.add(used.pop())\\n                    continue\\n                if j < len(pool) and pills:\\n                    used.add(pool.pop(j))\\n            i += 1\\n            res = max(res, c + len(used))\\n        return res\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2157584,
                "title": "how-can-this-be-wrong",
                "content": "```\\nclass Solution:\\n    def maxTaskAssign(self, t: List[int], workers: List[int], pills: int, s: int) -> int:\\n        \\n        t.sort()\\n        workers.sort()\\n        \\n        A=t.copy()\\n        B=workers.copy()\\n        p=pills\\n        ans=0\\n        a=False\\n        b=False\\n        while(len(A)>0 and len(B)>0):\\n            #print(A,B,p)\\n            if B[-1]>=A[-1]:\\n                a=True\\n                ans+=1\\n                B.pop()\\n                A.pop()\\n            else:\\n                if p>0 and  math.ceil((A[0]-B[0])/s) <=p:\\n                    b=True\\n                    ans+=1\\n                    p=p-math.ceil((A[0]-B[0])/s)\\n                    B.pop()\\n                    A.pop()\\n                else:\\n                    A.pop()\\n            \\n        \\n        ans1=0\\n        A=t.copy()\\n        B=workers.copy()\\n        a=False\\n        b=False\\n        while(len(A)>0 and len(B)>0):\\n            print(A,B)\\n            if B[0]>=A[0]:\\n                a=True\\n                ans1+=1\\n                B.pop(0)\\n                A.pop(0)\\n            else:\\n                if pills>0 and math.ceil((A[0]-B[0])/s) <=pills:\\n                    b=True\\n                    ans1+=1\\n                    pills=pills-math.ceil((A[0]-B[0])/s)\\n                    B.pop(0)\\n                    A.pop(0)\\n                else:\\n                    A.pop(0)\\n            \\n        print(ans,ans1)\\n        return max(ans,ans1)\\n        \\n```\\n\\nfor the test case\\ntasks = [10,15,30], workers = [0,10,10,10,10], pills = 3, strength = 10\\ngetting max 3 \\nwhich is true\\n\\nplease someone help",
                "solutionTags": [
                    "Python",
                    "Greedy"
                ],
                "code": "```\\nclass Solution:\\n    def maxTaskAssign(self, t: List[int], workers: List[int], pills: int, s: int) -> int:\\n        \\n        t.sort()\\n        workers.sort()\\n        \\n        A=t.copy()\\n        B=workers.copy()\\n        p=pills\\n        ans=0\\n        a=False\\n        b=False\\n        while(len(A)>0 and len(B)>0):\\n            #print(A,B,p)\\n            if B[-1]>=A[-1]:\\n                a=True\\n                ans+=1\\n                B.pop()\\n                A.pop()\\n            else:\\n                if p>0 and  math.ceil((A[0]-B[0])/s) <=p:\\n                    b=True\\n                    ans+=1\\n                    p=p-math.ceil((A[0]-B[0])/s)\\n                    B.pop()\\n                    A.pop()\\n                else:\\n                    A.pop()\\n            \\n        \\n        ans1=0\\n        A=t.copy()\\n        B=workers.copy()\\n        a=False\\n        b=False\\n        while(len(A)>0 and len(B)>0):\\n            print(A,B)\\n            if B[0]>=A[0]:\\n                a=True\\n                ans1+=1\\n                B.pop(0)\\n                A.pop(0)\\n            else:\\n                if pills>0 and math.ceil((A[0]-B[0])/s) <=pills:\\n                    b=True\\n                    ans1+=1\\n                    pills=pills-math.ceil((A[0]-B[0])/s)\\n                    B.pop(0)\\n                    A.pop(0)\\n                else:\\n                    A.pop(0)\\n            \\n        print(ans,ans1)\\n        return max(ans,ans1)\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1928240,
                "title": "java-binary-search-and-greedy-linkedhashset",
                "content": "```\\n/*\\nThe binary search approach is not very obvious here.\\n\\nThe idea is to pick k easiest tasks, and k strongest workers, and see if we can assign those tasks.\\n\\nWith this set of k strongest workers and k easiest tasks, we:\\n\\nProcess tasks from hardest to easiest\\nCheck if the strongest worker can do the hardest of the remaining tasks.\\nIf not, find the weakest worker that can do the hardest task if given a pill.\\nIf there are no more pills, we cannot assign m tasks.\\nIf we find the worker who can do the task, remove it from the list of workers.\\nIf not, we cannot assign m tasks.\\n\\nFinally, we do a binary search for the maximum number of tasks that we can accomplish (i.e the max k).\\n\\nI used linked hashset for searching and removing workers during each process of the binary\\nsearch\\n*/\\nclass Solution {\\n    //can k strongest workers do k easiest tasks? Use the algorithm above\\n   \\n    public int maxTaskAssign(int[] tasks, int[] workers, int pills, int strength) {\\n        Arrays.sort(tasks);\\n        Arrays.sort(workers);\\n        int n = tasks.length, m = workers.length;\\n        int left = 0, right = Math.min(n,m);\\n        int index = 0;\\n        while(left < right){\\n            int mid = left + (right - left)/2;\\n            boolean finished = canFinish(index++,tasks, workers, pills, strength, mid+1);\\n            if(finished){\\n                left = mid + 1;\\n            }else {\\n                right = mid;\\n            }\\n        }\\n        return left;\\n    }\\n    //can k strongest workers do k easiest tasks? Use the algorithm above\\n    public boolean canFinish(int index, int[] tasks, int[] workers, int pills, int strength, int k){\\n        //take easiest k jobs and strongest k men\\n        int lastTask = k-1, firstWorker = workers.length-k;\\n        int lastWorker = workers.length-1;\\n        int count = 0;\\n        \\n        LinkedHashSet<Integer> set = new LinkedHashSet<>();\\n        for(int i=firstWorker; i<= lastWorker; i++)\\n            set.add(i);\\n        \\n        top:\\n        while(lastWorker >= firstWorker && lastTask >= 0){\\n            //check if the worker has been used before without being removed\\n            if(!set.contains(lastWorker)){\\n                lastWorker--;\\n                continue;\\n            }\\n            //check if current strongest worker can do the current hardest job\\n            //without pills\\n            if(workers[lastWorker] >= tasks[lastTask]){\\n                set.remove(lastWorker);\\n                lastWorker--;\\n                lastTask--;\\n                count++;\\n                continue;\\n            }\\n            //find the weakest worker that can do current hardest job with pill\\n            //ensure there is pills left and the worker has not been used before\\n            boolean workerSeen = false;\\n            Iterator<Integer> setIt = set.iterator();\\n            while(setIt.hasNext() && pills > 0){\\n                int nextWorker = setIt.next();\\n                \\n                if(workers[nextWorker] + strength >= tasks[lastTask]){\\n                    pills--;\\n                    lastTask--;\\n                    setIt.remove();\\n                    count++;\\n                    workerSeen = true;\\n                    break;\\n                }\\n            }\\n            if(!workerSeen) return false;\\n            \\n        }\\n        return count == k;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\n/*\\nThe binary search approach is not very obvious here.\\n\\nThe idea is to pick k easiest tasks, and k strongest workers, and see if we can assign those tasks.\\n\\nWith this set of k strongest workers and k easiest tasks, we:\\n\\nProcess tasks from hardest to easiest\\nCheck if the strongest worker can do the hardest of the remaining tasks.\\nIf not, find the weakest worker that can do the hardest task if given a pill.\\nIf there are no more pills, we cannot assign m tasks.\\nIf we find the worker who can do the task, remove it from the list of workers.\\nIf not, we cannot assign m tasks.\\n\\nFinally, we do a binary search for the maximum number of tasks that we can accomplish (i.e the max k).\\n\\nI used linked hashset for searching and removing workers during each process of the binary\\nsearch\\n*/\\nclass Solution {\\n    //can k strongest workers do k easiest tasks? Use the algorithm above\\n   \\n    public int maxTaskAssign(int[] tasks, int[] workers, int pills, int strength) {\\n        Arrays.sort(tasks);\\n        Arrays.sort(workers);\\n        int n = tasks.length, m = workers.length;\\n        int left = 0, right = Math.min(n,m);\\n        int index = 0;\\n        while(left < right){\\n            int mid = left + (right - left)/2;\\n            boolean finished = canFinish(index++,tasks, workers, pills, strength, mid+1);\\n            if(finished){\\n                left = mid + 1;\\n            }else {\\n                right = mid;\\n            }\\n        }\\n        return left;\\n    }\\n    //can k strongest workers do k easiest tasks? Use the algorithm above\\n    public boolean canFinish(int index, int[] tasks, int[] workers, int pills, int strength, int k){\\n        //take easiest k jobs and strongest k men\\n        int lastTask = k-1, firstWorker = workers.length-k;\\n        int lastWorker = workers.length-1;\\n        int count = 0;\\n        \\n        LinkedHashSet<Integer> set = new LinkedHashSet<>();\\n        for(int i=firstWorker; i<= lastWorker; i++)\\n            set.add(i);\\n        \\n        top:\\n        while(lastWorker >= firstWorker && lastTask >= 0){\\n            //check if the worker has been used before without being removed\\n            if(!set.contains(lastWorker)){\\n                lastWorker--;\\n                continue;\\n            }\\n            //check if current strongest worker can do the current hardest job\\n            //without pills\\n            if(workers[lastWorker] >= tasks[lastTask]){\\n                set.remove(lastWorker);\\n                lastWorker--;\\n                lastTask--;\\n                count++;\\n                continue;\\n            }\\n            //find the weakest worker that can do current hardest job with pill\\n            //ensure there is pills left and the worker has not been used before\\n            boolean workerSeen = false;\\n            Iterator<Integer> setIt = set.iterator();\\n            while(setIt.hasNext() && pills > 0){\\n                int nextWorker = setIt.next();\\n                \\n                if(workers[nextWorker] + strength >= tasks[lastTask]){\\n                    pills--;\\n                    lastTask--;\\n                    setIt.remove();\\n                    count++;\\n                    workerSeen = true;\\n                    break;\\n                }\\n            }\\n            if(!workerSeen) return false;\\n            \\n        }\\n        return count == k;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1849718,
                "title": "c-96-time-and-mem-iterative-approach-with-priority-queue-commented",
                "content": "int maxTaskAssign(vector<int>& tasks, vector<int>& workers, int pills, int strength) {\\n        \\n        // Sort in descending order, could sort in ascending. Would just need to change loop iteration direction\\n        sort(tasks.begin(),tasks.end(),[](int lhs, int rhs) {return lhs > rhs;});\\n        sort(workers.begin(),workers.end(),[](int lhs, int rhs) {return lhs > rhs;});\\n        \\n        int t = 0; // Current task we are assessing\\n        int w = 0; // Current worker we are checking\\n        int wp = 0; // Weakest worker than can complete task with a pill\\n        \\n        int completedTasks = 0; // Final output\\n        bool bSearchDown = true; // When false, we\\'ve  hit the point that all workers can complete remaining tasks with a pill?\\n        \\n        priority_queue<int> workersQ; // Workers than have a task assigned to them, but can only complete with a pill. Needs to be in descending order\\n                   \\n        while(t < tasks.size())\\n        {\\n            while(w < workers.size() && workers[w] == -1) w++; // Find next worker that has not already been processed\\n            \\n            if(w >= workers.size()) // If we\\'ve run out of workers, look to see if any in the queue can solve the task.\\n            {\\n                if(!workersQ.empty() && workersQ.top() > tasks[t])\\n                {\\n                    workersQ.pop();\\n                    completedTasks++;\\n                }\\n            }\\n            else if(workers[w] >= tasks[t]) // If the current worker can solve the task without a pill, use her.\\n            {\\n                workers[w] = -1;\\n                w++;\\n                completedTasks++;\\n            }\\n            else\\n            {\\n                if(bSearchDown) // Find the lowest strength worker that can solve the task with a pill\\n                {\\n                    //Find first worker that can\\'t do task with pill\\n                    while(wp < workers.size() && (workers[wp] == -1 || workers[wp] + strength >= tasks[t]))\\n                    {\\n                        wp++;\\n                    }\\n                    \\n                    // All tasks can now be completed by all workers with pill\\n                    if(wp == workers.size())\\n                    {\\n                        bSearchDown = false;\\n                        wp = workers.size() - 1;\\n                    }\\n                }\\n                \\n                // Iterate up till we find a worker that has not been processed and can complete the task. Should be the next valid worker.\\n                while(wp >= workers.size() || wp > w && (workers[wp] == -1 || workers[wp] + strength < tasks[t]))\\n                {\\n                    wp--;\\n                }\\n                \\n                // If we have equal or more workers assigned to the queue than pills, see if we can pull one out to finish this task\\n                if(workersQ.size() >= pills && !workersQ.empty() && workersQ.top() >= tasks[t])\\n                {\\n                    completedTasks++;\\n                    workersQ.pop();\\n                }\\n                // Can wp worker finish the task?\\n                else if(workers[wp] + strength >= tasks[t])\\n                {\\n                    workersQ.push(workers[wp]);                    \\n                    workers[wp] = -1;\\n                    wp += bSearchDown ? -1 : 1;\\n                }\\n                // Even if we haven\\'t filled queue, check to see if a worker can finish a task without a pill (task would be wasted otherwise)\\n                else if(!workersQ.empty() && workersQ.top() >= tasks[t])\\n                {\\n                    completedTasks++;\\n                    workersQ.pop();\\n                }\\n            }\\n            \\n            t++; // Processed one task\\n            wp = max(wp,w); // If ever WP becomes greater than w, clamp it to w\\n        }\\n        \\n        return completedTasks + min((int)workersQ.size(), pills); // Return number of completed tasks + number of workers in queue (i.e. number of workers than can complete a task with a pill.)\\n    }",
                "solutionTags": [
                    "C",
                    "Heap (Priority Queue)"
                ],
                "code": "int maxTaskAssign(vector<int>& tasks, vector<int>& workers, int pills, int strength) {\\n        \\n        // Sort in descending order, could sort in ascending. Would just need to change loop iteration direction\\n        sort(tasks.begin(),tasks.end(),[](int lhs, int rhs) {return lhs > rhs;});\\n        sort(workers.begin(),workers.end(),[](int lhs, int rhs) {return lhs > rhs;});\\n        \\n        int t = 0; // Current task we are assessing\\n        int w = 0; // Current worker we are checking\\n        int wp = 0; // Weakest worker than can complete task with a pill\\n        \\n        int completedTasks = 0; // Final output\\n        bool bSearchDown = true; // When false, we\\'ve  hit the point that all workers can complete remaining tasks with a pill?\\n        \\n        priority_queue<int> workersQ; // Workers than have a task assigned to them, but can only complete with a pill. Needs to be in descending order\\n                   \\n        while(t < tasks.size())\\n        {\\n            while(w < workers.size() && workers[w] == -1) w++; // Find next worker that has not already been processed\\n            \\n            if(w >= workers.size()) // If we\\'ve run out of workers, look to see if any in the queue can solve the task.\\n            {\\n                if(!workersQ.empty() && workersQ.top() > tasks[t])\\n                {\\n                    workersQ.pop();\\n                    completedTasks++;\\n                }\\n            }\\n            else if(workers[w] >= tasks[t]) // If the current worker can solve the task without a pill, use her.\\n            {\\n                workers[w] = -1;\\n                w++;\\n                completedTasks++;\\n            }\\n            else\\n            {\\n                if(bSearchDown) // Find the lowest strength worker that can solve the task with a pill\\n                {\\n                    //Find first worker that can\\'t do task with pill\\n                    while(wp < workers.size() && (workers[wp] == -1 || workers[wp] + strength >= tasks[t]))\\n                    {\\n                        wp++;\\n                    }\\n                    \\n                    // All tasks can now be completed by all workers with pill\\n                    if(wp == workers.size())\\n                    {\\n                        bSearchDown = false;\\n                        wp = workers.size() - 1;\\n                    }\\n                }\\n                \\n                // Iterate up till we find a worker that has not been processed and can complete the task. Should be the next valid worker.\\n                while(wp >= workers.size() || wp > w && (workers[wp] == -1 || workers[wp] + strength < tasks[t]))\\n                {\\n                    wp--;\\n                }\\n                \\n                // If we have equal or more workers assigned to the queue than pills, see if we can pull one out to finish this task\\n                if(workersQ.size() >= pills && !workersQ.empty() && workersQ.top() >= tasks[t])\\n                {\\n                    completedTasks++;\\n                    workersQ.pop();\\n                }\\n                // Can wp worker finish the task?\\n                else if(workers[wp] + strength >= tasks[t])\\n                {\\n                    workersQ.push(workers[wp]);                    \\n                    workers[wp] = -1;\\n                    wp += bSearchDown ? -1 : 1;\\n                }\\n                // Even if we haven\\'t filled queue, check to see if a worker can finish a task without a pill (task would be wasted otherwise)\\n                else if(!workersQ.empty() && workersQ.top() >= tasks[t])\\n                {\\n                    completedTasks++;\\n                    workersQ.pop();\\n                }\\n            }\\n            \\n            t++; // Processed one task\\n            wp = max(wp,w); // If ever WP becomes greater than w, clamp it to w\\n        }\\n        \\n        return completedTasks + min((int)workersQ.size(), pills); // Return number of completed tasks + number of workers in queue (i.e. number of workers than can complete a task with a pill.)\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1800879,
                "title": "python-greedy-binary-search-using-monotonic-que-o-nlogn",
                "content": "```\\nfrom collections import deque\\nclass Solution:\\n    def maxTaskAssign(self, tasks: List[int], workers: List[int], pills: int, strength: int) -> int:\\n        tasks = sorted(tasks)\\n        workers = sorted(workers)\\n        n = len(workers)\\n        def check(k, pills):\\n            que = deque()\\n            idx = n-1\\n            for i in range(k-1,-1,-1):\\n                while idx >= n-k and workers[idx]+strength>=tasks[i]:\\n                    que.append(workers[idx])\\n                    idx -= 1\\n                if not que:\\n                    return False\\n                if que[0]>=tasks[i]:\\n                    que.popleft()\\n                else:\\n                    que.pop()\\n                    pills -= 1\\n                    if pills < 0:\\n                        return False\\n            return True\\n        left, right = 0, min(len(tasks),len(workers))+1\\n        while left+1 < right:\\n            mid = (left + right)//2\\n            if check(mid, pills):\\n                left = mid\\n            else:\\n                right = mid\\n        return left\\n```",
                "solutionTags": [],
                "code": "```\\nfrom collections import deque\\nclass Solution:\\n    def maxTaskAssign(self, tasks: List[int], workers: List[int], pills: int, strength: int) -> int:\\n        tasks = sorted(tasks)\\n        workers = sorted(workers)\\n        n = len(workers)\\n        def check(k, pills):\\n            que = deque()\\n            idx = n-1\\n            for i in range(k-1,-1,-1):\\n                while idx >= n-k and workers[idx]+strength>=tasks[i]:\\n                    que.append(workers[idx])\\n                    idx -= 1\\n                if not que:\\n                    return False\\n                if que[0]>=tasks[i]:\\n                    que.popleft()\\n                else:\\n                    que.pop()\\n                    pills -= 1\\n                    if pills < 0:\\n                        return False\\n            return True\\n        left, right = 0, min(len(tasks),len(workers))+1\\n        while left+1 < right:\\n            mid = (left + right)//2\\n            if check(mid, pills):\\n                left = mid\\n            else:\\n                right = mid\\n        return left\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1786356,
                "title": "c-greedy-binary-search",
                "content": "```\\nclass Solution {\\npublic:\\n    bool pos(const int M, vector<int>& tasks, vector<int>& workers, int pills, int strength) {        \\n        multiset<int> W;\\n        for (int i = int(workers.size()) - 1; i >= int(workers.size()) - M; i--)\\n            W.insert(workers[i]);\\n        \\n        for (int i = M - 1; i >= 0; i--) {\\n            auto it = W.lower_bound(tasks[i]);\\n            if (it == W.end()) {\\n                if (pills == 0)\\n                    return false;\\n                it = W.lower_bound(tasks[i] - strength);\\n                if (it == W.end())\\n                    return false;\\n                pills--;\\n            }\\n            W.erase(it);\\n        }\\n        return true;        \\n    }\\n    \\n    int maxTaskAssign(vector<int>& tasks, vector<int>& workers, int pills, int strength) {\\n        sort(tasks.begin(), tasks.end());\\n        sort(workers.begin(), workers.end());\\n        int L = 0;\\n        int R = min(int(tasks.size()), int(workers.size()));\\n        int ans;\\n        while (L <= R) {\\n            int M = (L + R) / 2;\\n            if (pos(M, tasks, workers, pills, strength)) {\\n                ans = M;\\n                L = M + 1;                \\n            }\\n            else\\n                R = M - 1;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    bool pos(const int M, vector<int>& tasks, vector<int>& workers, int pills, int strength) {        \\n        multiset<int> W;\\n        for (int i = int(workers.size()) - 1; i >= int(workers.size()) - M; i--)\\n            W.insert(workers[i]);\\n        \\n        for (int i = M - 1; i >= 0; i--) {\\n            auto it = W.lower_bound(tasks[i]);\\n            if (it == W.end()) {\\n                if (pills == 0)\\n                    return false;\\n                it = W.lower_bound(tasks[i] - strength);\\n                if (it == W.end())\\n                    return false;\\n                pills--;\\n            }\\n            W.erase(it);\\n        }\\n        return true;        \\n    }\\n    \\n    int maxTaskAssign(vector<int>& tasks, vector<int>& workers, int pills, int strength) {\\n        sort(tasks.begin(), tasks.end());\\n        sort(workers.begin(), workers.end());\\n        int L = 0;\\n        int R = min(int(tasks.size()), int(workers.size()));\\n        int ans;\\n        while (L <= R) {\\n            int M = (L + R) / 2;\\n            if (pos(M, tasks, workers, pills, strength)) {\\n                ans = M;\\n                L = M + 1;                \\n            }\\n            else\\n                R = M - 1;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1727882,
                "title": "java-treemap-binary-search",
                "content": "```\\n    public int maxTaskAssign(int[] tasks, int[] workers, int pills, int strength) {\\n        Arrays.sort(tasks);\\n        TreeMap<Integer, Integer> map = new TreeMap<>();\\n        for (int i : workers)\\n        \\tmap.put(i, map.getOrDefault(i, 0) + 1);\\n        int res = 0, left = 0, right = Math.min(tasks.length, workers.length) - 1; \\n        while (left <= right) {\\n        \\tint mid = (left + right) / 2;\\n        \\tif (validate(tasks, (TreeMap<Integer, Integer>)map.clone(), pills, strength, mid))\\n        \\t\\tres = left = mid + 1;\\n        \\telse\\n        \\t\\tright = mid - 1;\\n        }\\n        return res;\\n    }\\n    boolean validate(int[] tasks, TreeMap<Integer, Integer> map, int pills, int strength, int pos) {\\n    \\tfor (; pos >= 0; pos--) {\\n\\t    \\tint maxStrength = map.lastKey(), t = tasks[pos];\\n\\t    \\tif (pills > 0 && strength + maxStrength < t || pills == 0 && maxStrength < t)\\n\\t    \\t\\treturn false;\\n\\t    \\tif (maxStrength < t) {\\n\\t    \\t\\tt -= strength;\\n\\t    \\t\\tpills--;\\n\\t    \\t}\\n    \\t\\tint matchStrength = map.ceilingKey(t);\\n    \\t\\tif (map.get(matchStrength) > 1)\\n    \\t\\t\\tmap.put(matchStrength, map.get(matchStrength) - 1);\\n    \\t\\telse\\n    \\t\\t\\tmap.remove(matchStrength);\\n    \\t}\\n    \\treturn true;\\n    }\\n",
                "solutionTags": [
                    "Java",
                    "Binary Search",
                    "Tree"
                ],
                "code": "```\\n    public int maxTaskAssign(int[] tasks, int[] workers, int pills, int strength) {\\n        Arrays.sort(tasks);\\n        TreeMap<Integer, Integer> map = new TreeMap<>();\\n        for (int i : workers)\\n        \\tmap.put(i, map.getOrDefault(i, 0) + 1);\\n        int res = 0, left = 0, right = Math.min(tasks.length, workers.length) - 1; \\n        while (left <= right) {\\n        \\tint mid = (left + right) / 2;\\n        \\tif (validate(tasks, (TreeMap<Integer, Integer>)map.clone(), pills, strength, mid))\\n        \\t\\tres = left = mid + 1;\\n        \\telse\\n        \\t\\tright = mid - 1;\\n        }\\n        return res;\\n    }\\n    boolean validate(int[] tasks, TreeMap<Integer, Integer> map, int pills, int strength, int pos) {\\n    \\tfor (; pos >= 0; pos--) {\\n\\t    \\tint maxStrength = map.lastKey(), t = tasks[pos];\\n\\t    \\tif (pills > 0 && strength + maxStrength < t || pills == 0 && maxStrength < t)\\n\\t    \\t\\treturn false;\\n\\t    \\tif (maxStrength < t) {\\n\\t    \\t\\tt -= strength;\\n\\t    \\t\\tpills--;\\n\\t    \\t}\\n    \\t\\tint matchStrength = map.ceilingKey(t);\\n    \\t\\tif (map.get(matchStrength) > 1)\\n    \\t\\t\\tmap.put(matchStrength, map.get(matchStrength) - 1);\\n    \\t\\telse\\n    \\t\\t\\tmap.remove(matchStrength);\\n    \\t}\\n    \\treturn true;\\n    }\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 1726586,
                "title": "c-solution-using-binary-search",
                "content": "```\\nclass Solution {\\npublic:\\n    bool find(vector<int>&t,vector<int>&w,int mid,int pill,int s)\\n    {\\n        multiset<int>st(w.begin(),w.end());\\n        for(int i=mid-1;i>=0;i--)\\n        {\\n            auto it=st.lower_bound(t[i]);\\n            if(it==st.end())\\n            {\\n                it=st.lower_bound(t[i]-s);\\n                pill--;\\n                if(it==st.end()||pill<0)\\n                {\\n                  return false;\\n                }\\n            }\\n            st.erase(it);\\n        }\\n        return true;\\n    }\\n    int maxTaskAssign(vector<int>& t, vector<int>& w, int pill,int s) \\n    {\\n        sort(t.begin(),t.end());\\n        sort(w.begin(),w.end());\\n        int n=t.size();\\n        int m=w.size();\\n        int l=0;\\n        int ans=l;\\n        int r=min(n,m);\\n        while(l<=r)\\n        {\\n            int mid=(l+r)/2;\\n            if(find(t,w,mid,pill,s))\\n            {\\n                ans=mid;\\n                l=mid+1;\\n            }\\n            else\\n            {\\n                r=mid-1;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool find(vector<int>&t,vector<int>&w,int mid,int pill,int s)\\n    {\\n        multiset<int>st(w.begin(),w.end());\\n        for(int i=mid-1;i>=0;i--)\\n        {\\n            auto it=st.lower_bound(t[i]);\\n            if(it==st.end())\\n            {\\n                it=st.lower_bound(t[i]-s);\\n                pill--;\\n                if(it==st.end()||pill<0)\\n                {\\n                  return false;\\n                }\\n            }\\n            st.erase(it);\\n        }\\n        return true;\\n    }\\n    int maxTaskAssign(vector<int>& t, vector<int>& w, int pill,int s) \\n    {\\n        sort(t.begin(),t.end());\\n        sort(w.begin(),w.end());\\n        int n=t.size();\\n        int m=w.size();\\n        int l=0;\\n        int ans=l;\\n        int r=min(n,m);\\n        while(l<=r)\\n        {\\n            int mid=(l+r)/2;\\n            if(find(t,w,mid,pill,s))\\n            {\\n                ans=mid;\\n                l=mid+1;\\n            }\\n            else\\n            {\\n                r=mid-1;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1650764,
                "title": "c-multiset-binary-search",
                "content": "```\\nclass Solution {\\npublic:\\n    int maxTaskAssign(vector<int>& tasks, vector<int>& workers, int pills, int strength) {\\n    \\n        sort(begin(tasks),end(tasks));\\n        sort(begin(workers),end(workers),greater<int>());\\n        \\n        \\n        int n=tasks.size();\\n        int m=workers.size();\\n        \\n        int low=0;\\n        int high=n;\\n        int ans=0;\\n        \\n        while(low<=high){\\n            int mid= low+(high-low)/2;\\n            int c=0;\\n            int j=0;\\n            int k=m-1;\\n            int p=pills;\\n            multiset<int,greater<int>>st(begin(workers),begin(workers)+min(mid,m));\\n            for(int i=mid-1;i>=0;i--){\\n                if(st.empty())break;\\n                auto it=st.begin();\\n                if(*it>=tasks[i]){\\n                    c++;\\n                    st.erase(it);\\n                }else{\\n                    auto it =st.end();\\n                    it--;\\n                    bool flag=false;\\n                    while(p>0){\\n                       if(*it+strength>=tasks[i]){\\n                           p--;\\n                           flag=true;\\n                           st.erase(it);\\n                           c++;\\n                           break;\\n                       }else{\\n                           if(it==st.begin())break;\\n                           it--;\\n                       }\\n                    }\\n                    \\n                    if(!flag)break;\\n                }\\n            }\\n\\t\\tif(c==mid){\\n\\t\\t\\tans=mid;\\n\\t\\t\\tlow=mid+1;\\n\\t\\t}else{\\n\\t\\t\\thigh=mid-1;\\n\\t\\t}   \\n        \\n}\\n      \\nreturn ans;\\n         \\n    }\\n    \\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxTaskAssign(vector<int>& tasks, vector<int>& workers, int pills, int strength) {\\n    \\n        sort(begin(tasks),end(tasks));\\n        sort(begin(workers),end(workers),greater<int>());\\n        \\n        \\n        int n=tasks.size();\\n        int m=workers.size();\\n        \\n        int low=0;\\n        int high=n;\\n        int ans=0;\\n        \\n        while(low<=high){\\n            int mid= low+(high-low)/2;\\n            int c=0;\\n            int j=0;\\n            int k=m-1;\\n            int p=pills;\\n            multiset<int,greater<int>>st(begin(workers),begin(workers)+min(mid,m));\\n            for(int i=mid-1;i>=0;i--){\\n                if(st.empty())break;\\n                auto it=st.begin();\\n                if(*it>=tasks[i]){\\n                    c++;\\n                    st.erase(it);\\n                }else{\\n                    auto it =st.end();\\n                    it--;\\n                    bool flag=false;\\n                    while(p>0){\\n                       if(*it+strength>=tasks[i]){\\n                           p--;\\n                           flag=true;\\n                           st.erase(it);\\n                           c++;\\n                           break;\\n                       }else{\\n                           if(it==st.begin())break;\\n                           it--;\\n                       }\\n                    }\\n                    \\n                    if(!flag)break;\\n                }\\n            }\\n\\t\\tif(c==mid){\\n\\t\\t\\tans=mid;\\n\\t\\t\\tlow=mid+1;\\n\\t\\t}else{\\n\\t\\t\\thigh=mid-1;\\n\\t\\t}   \\n        \\n}\\n      \\nreturn ans;\\n         \\n    }\\n    \\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1630965,
                "title": "why-does-example-3-return-2-instead-of-3",
                "content": "For the 3rd example in the problem description, why does the output expect 2 instead of 3? (0-indexed) Worker 1 can be assigned to task 0, worker 2 can be assigned to task 1 with 1 pill boost, and worker 3 can be assigned to task 2 with 2 pill boosts.\\n```\\nInput: tasks = [10,15,30], workers = [0,10,10,10,10], pills = 3, strength = 10\\nOutput: 2\\n```\\n\\nHere is my wrong answer code that I believe should give me AC without using Binary Search\\n```\\npublic class Solution {\\n    public int MaxTaskAssign(int[] t, int[] w, int p, int s) {\\n        // Sort both arrays so strongest worker and hardest task are at array.len - 1 position\\n        Array.Sort(t);\\n        Array.Sort(w);\\n        \\n        int r = 0;\\n        \\n        // Find the 1st task that the last worker is able to handle, else iterate down to -1 in the tasks array\\n        int checkTask = t.Length - 1, checkWorker = w.Length - 1;\\n        while (checkTask >= 0) {\\n            if (w[checkWorker] >= t[checkTask]) {  // found first task that can be handled without pills\\n                break;\\n            }\\n            checkTask--;\\n        }\\n        \\n        // handle all tasks by workers that don\\'t require any pills\\n        int handleTask = checkTask, handleWorker = checkWorker;\\n        while (handleTask >= 0 && handleWorker >= 0 && w[handleWorker] >= t[handleTask]) {\\n            r++;\\n            handleTask--;\\n            handleWorker--;\\n        }\\n        \\n        // Starting from the first worker unable to handle any tasks without pills\\n        int startTask = 0, startWorker = handleWorker; \\n        while (startTask < t.Length && startWorker >= 0) { \\n            // Skip the tasks already handled by previous workers\\n            if (startTask > handleTask && startTask <= checkTask) {\\n                startTask++;\\n                continue;\\n            }\\n\\n            // Apply magic pills until either the worker is strong enough to handle task, \\n            // or the number of available pills reaches 0\\n            if (w[startWorker] < t[startTask] && p > 0) { \\n                while (p > 0 && w[startWorker] < t[startTask]) { \\n                    w[startWorker] += s;\\n                    p--;\\n                } \\n            }\\n            \\n            // Check to see if the worker is capable of handling the task after any consumption of magic pills\\n            if (w[startWorker] >= t[startTask]) {\\n                startTask++;\\n                r++;\\n            } \\n            \\n            startWorker--;\\n        }\\n        \\n        return r;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nInput: tasks = [10,15,30], workers = [0,10,10,10,10], pills = 3, strength = 10\\nOutput: 2\\n```\n```\\npublic class Solution {\\n    public int MaxTaskAssign(int[] t, int[] w, int p, int s) {\\n        // Sort both arrays so strongest worker and hardest task are at array.len - 1 position\\n        Array.Sort(t);\\n        Array.Sort(w);\\n        \\n        int r = 0;\\n        \\n        // Find the 1st task that the last worker is able to handle, else iterate down to -1 in the tasks array\\n        int checkTask = t.Length - 1, checkWorker = w.Length - 1;\\n        while (checkTask >= 0) {\\n            if (w[checkWorker] >= t[checkTask]) {  // found first task that can be handled without pills\\n                break;\\n            }\\n            checkTask--;\\n        }\\n        \\n        // handle all tasks by workers that don\\'t require any pills\\n        int handleTask = checkTask, handleWorker = checkWorker;\\n        while (handleTask >= 0 && handleWorker >= 0 && w[handleWorker] >= t[handleTask]) {\\n            r++;\\n            handleTask--;\\n            handleWorker--;\\n        }\\n        \\n        // Starting from the first worker unable to handle any tasks without pills\\n        int startTask = 0, startWorker = handleWorker; \\n        while (startTask < t.Length && startWorker >= 0) { \\n            // Skip the tasks already handled by previous workers\\n            if (startTask > handleTask && startTask <= checkTask) {\\n                startTask++;\\n                continue;\\n            }\\n\\n            // Apply magic pills until either the worker is strong enough to handle task, \\n            // or the number of available pills reaches 0\\n            if (w[startWorker] < t[startTask] && p > 0) { \\n                while (p > 0 && w[startWorker] < t[startTask]) { \\n                    w[startWorker] += s;\\n                    p--;\\n                } \\n            }\\n            \\n            // Check to see if the worker is capable of handling the task after any consumption of magic pills\\n            if (w[startWorker] >= t[startTask]) {\\n                startTask++;\\n                r++;\\n            } \\n            \\n            startWorker--;\\n        }\\n        \\n        return r;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1630961,
                "title": "c-solution",
                "content": "Binary Search\\n```\\npublic class Solution {\\n    public int MaxTaskAssign(int[] t, int[] w, int p, int s) {\\n        Array.Sort(t);\\n        Array.Sort(w);\\n        \\n        int l = 0, r = Math.Min(t.Length, w.Length);\\n        while (l + 1 < r) {\\n            int m = l + (r - l) / 2;\\n            if (CanAssign(t, w, p, s, m)) {\\n                l = m;\\n            } else {\\n                r = m;\\n            }\\n        }\\n        \\n        if (CanAssign(t, w, p, s, r)) return r;\\n        else return l;\\n    }\\n    \\n    public bool CanAssign(int[] t, int[] w, int p, int s, int cnt) {\\n        List<int> dq = new List<int>();\\n        int end = w.Length - 1;\\n        for (int i = cnt - 1; i >= 0; --i) {\\n            while (end >= w.Length - cnt && w[end] + s >= t[i]) {\\n                dq.Add(w[end]);\\n                end--;\\n            }\\n            \\n            if (dq.Count == 0) return false;\\n        \\n            if (dq[0] >= t[i]) {\\n                dq.RemoveAt(0);\\n            } else {\\n                dq.RemoveAt(dq.Count - 1);\\n                p--;\\n                if (p < 0) return false;\\n            }\\n        }\\n        \\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    public int MaxTaskAssign(int[] t, int[] w, int p, int s) {\\n        Array.Sort(t);\\n        Array.Sort(w);\\n        \\n        int l = 0, r = Math.Min(t.Length, w.Length);\\n        while (l + 1 < r) {\\n            int m = l + (r - l) / 2;\\n            if (CanAssign(t, w, p, s, m)) {\\n                l = m;\\n            } else {\\n                r = m;\\n            }\\n        }\\n        \\n        if (CanAssign(t, w, p, s, r)) return r;\\n        else return l;\\n    }\\n    \\n    public bool CanAssign(int[] t, int[] w, int p, int s, int cnt) {\\n        List<int> dq = new List<int>();\\n        int end = w.Length - 1;\\n        for (int i = cnt - 1; i >= 0; --i) {\\n            while (end >= w.Length - cnt && w[end] + s >= t[i]) {\\n                dq.Add(w[end]);\\n                end--;\\n            }\\n            \\n            if (dq.Count == 0) return false;\\n        \\n            if (dq[0] >= t[i]) {\\n                dq.RemoveAt(0);\\n            } else {\\n                dq.RemoveAt(dq.Count - 1);\\n                p--;\\n                if (p < 0) return false;\\n            }\\n        }\\n        \\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1566201,
                "content": [
                    {
                        "username": "lilydenris",
                        "content": "Below is what I come up during the contest, a WRONG greedy solution.\\n\\n1 (Correct) we should take from smallest task, if current task cannot be taken, we cannot take more tasks.\\n2 (Correct) For current task, if we have no pill left, we should find the smallest worker that can take it.\\n3 (Wrong) If we have pills, try to find two workers: A smallest can take w/o pill, B smallest can take  w/ pill. If B + strength >= A, this means we waste some power from pill, we should choose A. Otherwise choose B. This is wrong because we could have saved the pill later for someone else and we cannot make a decision here without knowing more tasks and workers.\\n\\ntasks=[2,5],workers=[1,3,4],pills=1,strength=1\\nThis case breaks 3. We give pill to worker 1 for task 2. Then no one can complete task 5. Instead we should let worker 3 to complete task 2 and give pill to worker 4 to complete task 5.\\n\\nSo the correct way is to use binary search.\\nstart = 0, end = min(tasks.size(), worker.size())\\n\\nTo verify, we choose smallest mid number of tasks, and choose strongest mid number of workers, so that we hope all these tasks can be finished.\\nStart with biggest task, if our strongest worker can take it, just let him take it, no need to save it for later because no task is bigger.\\nIf strongest worker take pill cannot take or strongest worker cannot take with 0 pill left, we cannot complete all tasks then. Choose a better mid.\\nNow we know someone have to take pill to complete the biggest task, we need to find the weakest worker that can take the task with pill. \\n\\nHope it helps."
                    },
                    {
                        "username": "sk0822",
                        "content": "Why this is giving TLE inspite of TC nlog(m)*log(m)?\\n\\n\\n\\nclass Solution {\\npublic:\\n    int maxTaskAssign(vector<int>& tasks, vector<int>& workers, int pills, int strength) {\\n        sort(tasks.begin(),tasks.end());\\n        int l=0,r= min(workers.size(),tasks.size())-1;\\n        while(l<=r){\\n            int m=(l+r)/2;\\n            if(possible(m,tasks,workers,pills,strength)){\\n                l=m+1;\\n            }\\n            else{\\n                r=m-1;\\n            }\\n        }\\n        return l;\\n    \\n    }\\n    bool possible(int m,vector<int>&t,vector<int>&w,int p,int s){\\n          multiset<int>mt(w.begin(),w.end());\\n          while(m>=0){\\n               auto it = prev(mt.end());   \\n               if(*it>=t[m]){\\n                   m--,\\n                   mt.erase(it);\\n               }\\n               else if(p){\\n                  auto it= lower_bound(mt.begin(),mt.end(),t[m]-s);\\n                  if(it==mt.end()){\\n                      return false;\\n                  }\\n                  mt.erase(it);\\n                  p--,m--;\\n               }\\n               else{\\n                   return false;\\n               }\\n          }\\n          return true;\\n    }\\n};"
                    }
                ]
            }
        ]
    }
]