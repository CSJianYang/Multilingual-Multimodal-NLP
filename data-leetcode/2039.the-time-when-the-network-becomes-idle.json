[
    {
        "title": "The Time When the Network Becomes Idle",
        "question_content": "There is a network of n servers, labeled from 0 to n - 1. You are given a 2D integer array edges, where edges[i] = [ui, vi] indicates there is a message channel between servers ui and vi, and they can pass any number of messages to each other directly in one second. You are also given a 0-indexed integer array patience of length n.\nAll servers are connected, i.e., a message can be passed from one server to any other server(s) directly or indirectly through the message channels.\nThe server labeled 0 is the master server. The rest are data servers. Each data server needs to send its message to the master server for processing and wait for a reply. Messages move between servers optimally, so every message takes the least amount of time to arrive at the master server. The master server will process all newly arrived messages instantly and send a reply to the originating server via the reversed path the message had gone through.\nAt the beginning of second 0, each data server sends its message to be processed. Starting from second 1, at the beginning of every second, each data server will check if it has received a reply to the message it sent (including any newly arrived replies) from the master server:\n\n\tIf it has not, it will resend the message periodically. The data server i will resend the message every patience[i] second(s), i.e., the data server i will resend the message if patience[i] second(s) have elapsed since the last time the message was sent from this server.\n\tOtherwise, no more resending will occur from this server.\n\nThe network becomes idle when there are no messages passing between servers or arriving at servers.\nReturn the earliest second starting from which the network becomes idle.\n&nbsp;\nExample 1:\n\nInput: edges = [[0,1],[1,2]], patience = [0,2,1]\nOutput: 8\nExplanation:\nAt (the beginning of) second 0,\n- Data server 1 sends its message (denoted 1A) to the master server.\n- Data server 2 sends its message (denoted 2A) to the master server.\nAt second 1,\n- Message 1A arrives at the master server. Master server processes message 1A instantly and sends a reply 1A back.\n- Server 1 has not received any reply. 1 second (1 < patience[1] = 2) elapsed since this server has sent the message, therefore it does not resend the message.\n- Server 2 has not received any reply. 1 second (1 == patience[2] = 1) elapsed since this server has sent the message, therefore it resends the message (denoted 2B).\nAt second 2,\n- The reply 1A arrives at server 1. No more resending will occur from server 1.\n- Message 2A arrives at the master server. Master server processes message 2A instantly and sends a reply 2A back.\n- Server 2 resends the message (denoted 2C).\n...\nAt second 4,\n- The reply 2A arrives at server 2. No more resending will occur from server 2.\n...\nAt second 7, reply 2D arrives at server 2.\nStarting from the beginning of the second 8, there are no messages passing between servers or arriving at servers.\nThis is the time when the network becomes idle.\n\nExample 2:\n\nInput: edges = [[0,1],[0,2],[1,2]], patience = [0,10,10]\nOutput: 3\nExplanation: Data servers 1 and 2 receive a reply back at the beginning of second 2.\nFrom the beginning of the second 3, the network becomes idle.\n\n&nbsp;\nConstraints:\n\n\tn == patience.length\n\t2 <= n <= 105\n\tpatience[0] == 0\n\t1 <= patience[i] <= 105 for 1 <= i < n\n\t1 <= edges.length <= min(105, n * (n - 1) / 2)\n\tedges[i].length == 2\n\t0 <= ui, vi < n\n\tui != vi\n\tThere are no duplicate edges.\n\tEach server can directly or indirectly reach another server.",
        "solutions": [
            {
                "id": 1524181,
                "title": "bfs-maths-c-explanation",
                "content": "* we will find single source shortest path using bfs for every data server.\\n* now we have a time array which states min. time to travel from data server to master server.\\n*  total time travel for a message will be time[node]*2.\\n*  now we find the number of messages a data server will send before first message arrives back.\\n*  we will find last time(lastOutTime) a message was sent.\\n*  idle time for current data server will be lastOutTime + time[currentDataServer] + 1 for a message.\\n\\n```\\nclass Solution {\\npublic:\\n    int networkBecomesIdle(vector<vector<int>>& edges, vector<int>& patience) {\\n        int n = patience.size();\\n        vector <vector <int>> graph(n);\\n        vector <int> time(n, -1);\\n        \\n        for(auto x: edges) { // create adjacency list\\n            graph[x[0]].push_back(x[1]);\\n            graph[x[1]].push_back(x[0]);\\n        }\\n        \\n        queue <int> q;\\n        q.push(0);\\n        time[0] = 0;\\n        while(q.size()) {\\n            int node = q.front();\\n            q.pop();\\n            \\n            for(auto child: graph[node]) {\\n                if(time[child] == -1) { // if not visited.\\n                    time[child] = time[node] + 1; // calc time for child node\\n                    q.push(child);\\n                }\\n            }\\n        }\\n        \\n        int res = 0;\\n        for(int i = 1; i<n; i++) {\\n            int extraPayload = (time[i]*2 - 1)/patience[i]; \\n\\t\\t\\t// extra number of payload before the first message arrive back to data server.\\n\\t\\t\\t// since a data server can only send a message before first message arrives back.\"\\n\\t\\t\\t// and first message arrives at time[i]*2. so \"(time[i]*2-1)\"\\n\\t\\t\\t\\n            int lastOut = extraPayload * patience[i]; // find the last time when a data server sends a message\\n            int lastIn = lastOut + time[i]*2; // this is the result for current data server\\n\\t\\t\\t\\n            res = max(res, lastIn);\\n        }\\n\\t\\t\\n\\t\\t// at \"res\" time the last message has arrived at one of the data servers.\\n\\t\\t// so at res+1 no message will be passing between servers.\\n\\t\\t\\n        return res+1;\\n    }\\n};\\n```\\nT.C: O(E+n)\\nS.C: O(E+n)\\nwhere E is number of edges and\\nn is number of nodes.",
                "solutionTags": [
                    "C",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int networkBecomesIdle(vector<vector<int>>& edges, vector<int>& patience) {\\n        int n = patience.size();\\n        vector <vector <int>> graph(n);\\n        vector <int> time(n, -1);\\n        \\n        for(auto x: edges) { // create adjacency list\\n            graph[x[0]].push_back(x[1]);\\n            graph[x[1]].push_back(x[0]);\\n        }\\n        \\n        queue <int> q;\\n        q.push(0);\\n        time[0] = 0;\\n        while(q.size()) {\\n            int node = q.front();\\n            q.pop();\\n            \\n            for(auto child: graph[node]) {\\n                if(time[child] == -1) { // if not visited.\\n                    time[child] = time[node] + 1; // calc time for child node\\n                    q.push(child);\\n                }\\n            }\\n        }\\n        \\n        int res = 0;\\n        for(int i = 1; i<n; i++) {\\n            int extraPayload = (time[i]*2 - 1)/patience[i]; \\n\\t\\t\\t// extra number of payload before the first message arrive back to data server.\\n\\t\\t\\t// since a data server can only send a message before first message arrives back.\"\\n\\t\\t\\t// and first message arrives at time[i]*2. so \"(time[i]*2-1)\"\\n\\t\\t\\t\\n            int lastOut = extraPayload * patience[i]; // find the last time when a data server sends a message\\n            int lastIn = lastOut + time[i]*2; // this is the result for current data server\\n\\t\\t\\t\\n            res = max(res, lastIn);\\n        }\\n\\t\\t\\n\\t\\t// at \"res\" time the last message has arrived at one of the data servers.\\n\\t\\t// so at res+1 no message will be passing between servers.\\n\\t\\t\\n        return res+1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1524780,
                "title": "bfs-formula-formation-hindi-explaination-c",
                "content": "**we have**\\n1. Graph hai\\n2. patience[i] time ka array hai\\n\\nHum pure problem ko 2 parts m kr dete hai \\n1. Pehla ye ki hume hrr ek node se master server ( mean 0 ) tk pohachne m minimum time kitna lagega\\n2. Dusra ye ki hrr ek node ke liye round trip khtm hone m kitna time lagega\\n\\n2nd step ke baad hum hrr ek node ke time ko compare karenge aur unme se jo maximum hoga usse return karenge\\n\\nAab hum ek ek kr dono steps pr discuss krte hai\\n\\n\\n**master server ( mean 0 ) tk pohachne m minimum time kitna lagega**\\n\\nIsse krne ke liye hum 0 se bfs laga denge jisase hume hrr node shortest distance pr milega jisse hum store kr lenge taki hum isse dusre step m use kr sake\\n\\n\\n**hrr ek node ke liye round trip khtm hone m kitna time lagega**\\n\\nAab main game yaha shuru hota h....yaha aapko kuch cases banakr dekhne parenge ki kya kya possibilities hai lekin chinta ki koi zarurat nh niche ache se apke liye smjha rakha h but ye recommended h\\n\\nFor each Node\\nLet,\\nd=minimum distance from master server (mean 0)\\np=patience time for this node\\n\\n**case 1**\\n**2*d<=p**\\n\\niss case m ye dusra message jaane ke pahle hi server idle ho jayega so iss case ka timing simple 2*d ho jayega ( jo 1st packet ke liye time lagega)\\n\\n**case 2**\\n\\n**2*d>p**\\n\\naab yaha bhi 2 case bante hai\\n1. ek to ye ho skta h jb humara pehla message dobara node pr pohache tb ye release krna chah raha ho kintu ye kr nh payega bcz humara reply aa gaya h iss samay (in simple 2*d is divisible by p)\\n2. Dusra ye ki jb humara pehla message ka reply aaye tb ye send krne ke state m na ho (in simple 2*d is not divisible by p)\\n \\n \\n First case :\\n \\n pahle case ke liye total time = time taken for first message + time taken for last message\\ntotal time = 2*d + (2*d-p)  (ye message tb nikla hoga jb first message current node se p distance durr hoga so jb first message pohacha hoga to ye last message source se p aage badh chuka hoga)\\nHence,\\ntotal time = 4*d-p\\n\\nsecond case:\\n\\nIss case ke liye total time = time taken for first message + time taken for last message\\ntotal time = 2*d + (2*d-2*d%p)  (ye message tb nikla hoga jb first message current node se 2*d%p distance durr hoga so jb first message pohacha hoga to ye source se 2*d%p aage badh chuka hoga)\\nHence,\\ntotal time = 4*d-2*d%p\\n\\nIske baad humne sare case ko dekh liya h aab hum coding start kr skte hai\\n\\n```\\nclass Solution {\\npublic:\\n    int networkBecomesIdle(vector<vector<int>>& edges, vector<int>& patience) {\\n        int n = patience.size();\\n        vector <vector <int>> graph(n);\\n        vector <int> time(n, -1);\\n        \\n        for(auto x: edges) { // create adjacency list\\n            graph[x[0]].push_back(x[1]);\\n            graph[x[1]].push_back(x[0]);\\n        }\\n        \\n        queue <int> q;\\n        q.push(0);\\n        time[0] = 0;\\n        while(q.size()) {\\n            int node = q.front();\\n            q.pop();\\n            \\n            for(auto child: graph[node]) {\\n                if(time[child] == -1) { // if not visited.\\n                    time[child] = time[node] + 1; // calc time for child node\\n                    q.push(child);\\n                }\\n            }\\n        }\\n        \\n        int res = 0;\\n        for(int i = 1; i<n; i++) \\n\\t\\t{\\n             int d = dis[i];\\n             int temp = 2*d;\\n             if(2*d > patience[i])\\n\\t\\t\\t {\\n                if((2*d)%patience[i]==0)\\n                temp=4*d-patience[i];\\n                else\\n                    temp=4*d-(2*d)%patience[i];   \\n            }\\n            \\n            res = max(res,temp);\\n\\t\\t\\t\\n        }\\n        return res+1; // since till res time all messages has beed arrived so +1\\n    }\\n};\\n```\\n\\nAur agar isike 2nd traversal ko avoid krna h to 2nd step ko bfs ke sath hi kr skte hai\\n\\n```\\nclass Solution {\\npublic:\\n    int networkBecomesIdle(vector<vector<int>>& edges, vector<int>& patience) {\\n        int n = patience.size();\\n        vector <vector <int>> graph(n);\\n        vector <int> time(n, -1);\\n        \\n        for(auto x: edges) { // create adjacency list\\n            graph[x[0]].push_back(x[1]);\\n            graph[x[1]].push_back(x[0]);\\n        }\\n        int res = 0;\\n        queue <int> q;\\n        q.push(0);\\n        time[0] = 0;\\n        while(q.size()) {\\n            int node = q.front();\\n            q.pop();\\n            \\n            for(auto child: graph[node]) {\\n                if(time[child] == -1) { // if not visited.\\n                    time[child] = time[node] + 1; // calc time for child node\\n                    q.push(child);\\n\\t\\t\\t\\t\\tint d=time[child];\\n\\t\\t\\t\\t\\tint temp = 2*d;\\n             if(2*d > patience[child])\\n\\t\\t\\t {\\n                if((2*d)%patience[child]==0)\\n                temp=4*d-patience[child];\\n                else\\n                    temp=4*d-(2*d)%patience[child];   \\n            }\\n            \\n            res = max(res,temp);\\n                }\\n            }\\n        }\\n        \\n        return res+1; // since till res time all messages has beed arrived so +1\\n    }\\n};\\n```\\n\\nYehh maine hindi m aise pryas kiya h umeed h aplog ache se smjhe honge.\\nAgar koi paresani ho to aap comment kr sakte hai.\\nDhanyvad\\uD83D\\uDE4F\\n\\n\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int networkBecomesIdle(vector<vector<int>>& edges, vector<int>& patience) {\\n        int n = patience.size();\\n        vector <vector <int>> graph(n);\\n        vector <int> time(n, -1);\\n        \\n        for(auto x: edges) { // create adjacency list\\n            graph[x[0]].push_back(x[1]);\\n            graph[x[1]].push_back(x[0]);\\n        }\\n        \\n        queue <int> q;\\n        q.push(0);\\n        time[0] = 0;\\n        while(q.size()) {\\n            int node = q.front();\\n            q.pop();\\n            \\n            for(auto child: graph[node]) {\\n                if(time[child] == -1) { // if not visited.\\n                    time[child] = time[node] + 1; // calc time for child node\\n                    q.push(child);\\n                }\\n            }\\n        }\\n        \\n        int res = 0;\\n        for(int i = 1; i<n; i++) \\n\\t\\t{\\n             int d = dis[i];\\n             int temp = 2*d;\\n             if(2*d > patience[i])\\n\\t\\t\\t {\\n                if((2*d)%patience[i]==0)\\n                temp=4*d-patience[i];\\n                else\\n                    temp=4*d-(2*d)%patience[i];   \\n            }\\n            \\n            res = max(res,temp);\\n\\t\\t\\t\\n        }\\n        return res+1; // since till res time all messages has beed arrived so +1\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int networkBecomesIdle(vector<vector<int>>& edges, vector<int>& patience) {\\n        int n = patience.size();\\n        vector <vector <int>> graph(n);\\n        vector <int> time(n, -1);\\n        \\n        for(auto x: edges) { // create adjacency list\\n            graph[x[0]].push_back(x[1]);\\n            graph[x[1]].push_back(x[0]);\\n        }\\n        int res = 0;\\n        queue <int> q;\\n        q.push(0);\\n        time[0] = 0;\\n        while(q.size()) {\\n            int node = q.front();\\n            q.pop();\\n            \\n            for(auto child: graph[node]) {\\n                if(time[child] == -1) { // if not visited.\\n                    time[child] = time[node] + 1; // calc time for child node\\n                    q.push(child);\\n\\t\\t\\t\\t\\tint d=time[child];\\n\\t\\t\\t\\t\\tint temp = 2*d;\\n             if(2*d > patience[child])\\n\\t\\t\\t {\\n                if((2*d)%patience[child]==0)\\n                temp=4*d-patience[child];\\n                else\\n                    temp=4*d-(2*d)%patience[child];   \\n            }\\n            \\n            res = max(res,temp);\\n                }\\n            }\\n        }\\n        \\n        return res+1; // since till res time all messages has beed arrived so +1\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1524169,
                "title": "python-clean-bfs-lots-of-comments-easy-to-follow",
                "content": "Approach:\\n1) Build an adjency list.\\n2) BFS from the master node to get the shortest path from node to master.\\n3) Calculate when the last resent time is, and how long it will take to reach the server after that.\\n\\n```\\nclass Solution:\\n    def networkBecomesIdle(self, edges: List[List[int]], patience: List[int]) -> int:\\n        \\n        #Build Adjency List\\n        adjList = defaultdict(list)\\n        \\n        for source, target in edges:\\n            adjList[source].append(target)\\n            adjList[target].append(source)\\n            \\n        \\n        #BFS to get the shortest route from node to master.\\n        shortest = {}\\n        queue = deque([(0,0)])\\n        seen = set()\\n        while queue:\\n            currPos, currDist = queue.popleft()\\n            \\n            if currPos in seen:\\n                continue\\n            seen.add(currPos)\\n            shortest[currPos] = currDist\\n            \\n            for nei in adjList[currPos]:\\n                queue.append((nei, currDist+1))\\n\\n                \\n        #Calculate answer using shortest paths.\\n        ans = 0\\n        for index in range(1,len(patience)):\\n            resendInterval = patience[index]\\n                \\n            #The server will stop sending requests after it\\'s been sent to the master node and back.\\n            shutOffTime = (shortest[index] * 2)\\n            \\n            # shutOffTime-1 == Last second the server can send a re-request.\\n            lastSecond = shutOffTime-1\\n            \\n            #Calculate the last time a packet is actually resent.\\n            lastResentTime = (lastSecond//resendInterval)*resendInterval\\n            \\n            # At the last resent time, the packet still must go through 2 more cycles to the master node and back.\\n            lastPacketTime = lastResentTime + shutOffTime\\n            \\n            ans = max(lastPacketTime, ans)\\n            \\n        #Add +1, the current answer is the last time the packet is recieved by the target server (still active).\\n        #We must return the first second the network is idle, therefore + 1\\n        return ans + 1\\n  ```",
                "solutionTags": [
                    "Python",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution:\\n    def networkBecomesIdle(self, edges: List[List[int]], patience: List[int]) -> int:\\n        \\n        #Build Adjency List\\n        adjList = defaultdict(list)\\n        \\n        for source, target in edges:\\n            adjList[source].append(target)\\n            adjList[target].append(source)\\n            \\n        \\n        #BFS to get the shortest route from node to master.\\n        shortest = {}\\n        queue = deque([(0,0)])\\n        seen = set()\\n        while queue:\\n            currPos, currDist = queue.popleft()\\n            \\n            if currPos in seen:\\n                continue\\n            seen.add(currPos)\\n            shortest[currPos] = currDist\\n            \\n            for nei in adjList[currPos]:\\n                queue.append((nei, currDist+1))\\n\\n                \\n        #Calculate answer using shortest paths.\\n        ans = 0\\n        for index in range(1,len(patience)):\\n            resendInterval = patience[index]\\n                \\n            #The server will stop sending requests after it\\'s been sent to the master node and back.\\n            shutOffTime = (shortest[index] * 2)\\n            \\n            # shutOffTime-1 == Last second the server can send a re-request.\\n            lastSecond = shutOffTime-1\\n            \\n            #Calculate the last time a packet is actually resent.\\n            lastResentTime = (lastSecond//resendInterval)*resendInterval\\n            \\n            # At the last resent time, the packet still must go through 2 more cycles to the master node and back.\\n            lastPacketTime = lastResentTime + shutOffTime\\n            \\n            ans = max(lastPacketTime, ans)\\n            \\n        #Add +1, the current answer is the last time the packet is recieved by the target server (still active).\\n        #We must return the first second the network is idle, therefore + 1\\n        return ans + 1\\n  ```",
                "codeTag": "Java"
            },
            {
                "id": 1524241,
                "title": "c-bfs-solution",
                "content": "First, we need to find the shortest path from the master server to the data servers, here I use BFS. Call `dist[i]` is the shortest distance from master server to data server  `i`\\n\\n`firstTimeReceive = dist[i] * 2` : *send to the master server*, and get the *response from the master server*\\n`waitingTime = firstTimeReceive - 1` : After the first message was sent\\n`numResend = waitingTime / patience[i]`: Number of messages to be resend after `waitingTime`\\n\\nWhen a data server receives a response for the first message, it stops resending other messages. So the completion time of a data server is `firstTimeReceive + numResend * patience[i]`\\n\\n```C++\\nclass Solution {\\npublic:\\n    int networkBecomesIdle(vector<vector<int>> &edges, vector<int> &patience) {\\n        auto n = patience.size();\\n        vector<int> dist(n, INT_MAX);\\n        vector<vector<int>> graph(n);\\n        //Build graph\\n        for (auto &edge:edges) {\\n            int u = edge[0], v = edge[1];\\n            graph[u].push_back(v);\\n            graph[v].push_back(u);\\n        }\\n\\n        //Bfs to find the shortest path from master server to all server\\n        queue<int> queue;\\n        vector<bool> visited(n, false);\\n        queue.push(0);\\n        visited[0] = true;\\n        int d = 0;\\n        while (!queue.empty()) {\\n            for (auto i = queue.size(); i > 0; i--) {\\n                int u = queue.front();\\n                queue.pop();\\n                dist[u] = d;\\n                for (auto v:graph[u]) {\\n                    if (!visited[v]) {\\n                        queue.push(v);\\n                        visited[v] = true;\\n                    }\\n                }\\n            }\\n            d++;\\n        }\\n\\n        //Find the slowest completion time\\n        int slowest = 0;\\n        for (int i = 1; i < n; i++) {\\n            int firstTimeReceive = dist[i] * 2; // Send to master server, and receive from master server\\n            int waitingTime = firstTimeReceive - 1;\\n            int numResend = waitingTime / patience[i];\\n            int timeDone = firstTimeReceive + numResend * patience[i];\\n            slowest = max(slowest, timeDone);\\n        }\\n        return slowest + 1;\\n    }\\n};\\n\\n```\\nComplexity:\\nTime: `O(V + E)` Where E is the number of edges, V is the number of servers",
                "solutionTags": [
                    "C",
                    "Breadth-First Search"
                ],
                "code": "```C++\\nclass Solution {\\npublic:\\n    int networkBecomesIdle(vector<vector<int>> &edges, vector<int> &patience) {\\n        auto n = patience.size();\\n        vector<int> dist(n, INT_MAX);\\n        vector<vector<int>> graph(n);\\n        //Build graph\\n        for (auto &edge:edges) {\\n            int u = edge[0], v = edge[1];\\n            graph[u].push_back(v);\\n            graph[v].push_back(u);\\n        }\\n\\n        //Bfs to find the shortest path from master server to all server\\n        queue<int> queue;\\n        vector<bool> visited(n, false);\\n        queue.push(0);\\n        visited[0] = true;\\n        int d = 0;\\n        while (!queue.empty()) {\\n            for (auto i = queue.size(); i > 0; i--) {\\n                int u = queue.front();\\n                queue.pop();\\n                dist[u] = d;\\n                for (auto v:graph[u]) {\\n                    if (!visited[v]) {\\n                        queue.push(v);\\n                        visited[v] = true;\\n                    }\\n                }\\n            }\\n            d++;\\n        }\\n\\n        //Find the slowest completion time\\n        int slowest = 0;\\n        for (int i = 1; i < n; i++) {\\n            int firstTimeReceive = dist[i] * 2; // Send to master server, and receive from master server\\n            int waitingTime = firstTimeReceive - 1;\\n            int numResend = waitingTime / patience[i];\\n            int timeDone = firstTimeReceive + numResend * patience[i];\\n            slowest = max(slowest, timeDone);\\n        }\\n        return slowest + 1;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1524189,
                "title": "java-bfs-and-maths",
                "content": "```\\nclass Solution {\\n    public int networkBecomesIdle(int[][] edges, int[] patience) {\\n        int n = patience.length;\\n        ArrayList<ArrayList<Integer>> adj = new ArrayList<>();\\n        \\n        for(int i = 0; i < n ; i++){\\n            adj.add(new ArrayList<>());\\n        }\\n        \\n        for(int[] edge: edges){\\n            adj.get(edge[0]).add(edge[1]);\\n            adj.get(edge[1]).add(edge[0]);\\n        }\\n        \\n        Queue<Integer> queue = new LinkedList<>();\\n        queue.add(0);\\n        int[] visited = new int[n];\\n        Arrays.fill(visited, -1);\\n        visited[0] = 0;\\n        \\n        int level = 0;\\n        while(!queue.isEmpty()){\\n            level++;\\n            int size = queue.size();\\n            while(size-->0){\\n                int node = queue.remove();\\n                for(int next: adj.get(node)){\\n                    if(visited[next] == -1){\\n                        queue.offer(next);\\n                        visited[next] = 2 * level;\\n                    }\\n                }\\n            }\\n        }\\n        \\n        int res = 0;\\n        \\n        for(int i = 1; i < visited.length; i++){\\n            int dist = visited[i];\\n            int val = dist + dist - (dist % patience[i]);\\n            if(dist % patience[i] == 0) val -= patience[i];\\n            res = Integer.max(res, val);\\n        }\\n        \\n        return res + 1;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int networkBecomesIdle(int[][] edges, int[] patience) {\\n        int n = patience.length;\\n        ArrayList<ArrayList<Integer>> adj = new ArrayList<>();\\n        \\n        for(int i = 0; i < n ; i++){\\n            adj.add(new ArrayList<>());\\n        }\\n        \\n        for(int[] edge: edges){\\n            adj.get(edge[0]).add(edge[1]);\\n            adj.get(edge[1]).add(edge[0]);\\n        }\\n        \\n        Queue<Integer> queue = new LinkedList<>();\\n        queue.add(0);\\n        int[] visited = new int[n];\\n        Arrays.fill(visited, -1);\\n        visited[0] = 0;\\n        \\n        int level = 0;\\n        while(!queue.isEmpty()){\\n            level++;\\n            int size = queue.size();\\n            while(size-->0){\\n                int node = queue.remove();\\n                for(int next: adj.get(node)){\\n                    if(visited[next] == -1){\\n                        queue.offer(next);\\n                        visited[next] = 2 * level;\\n                    }\\n                }\\n            }\\n        }\\n        \\n        int res = 0;\\n        \\n        for(int i = 1; i < visited.length; i++){\\n            int dist = visited[i];\\n            int val = dist + dist - (dist % patience[i]);\\n            if(dist % patience[i] == 0) val -= patience[i];\\n            res = Integer.max(res, val);\\n        }\\n        \\n        return res + 1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1527797,
                "title": "bfs",
                "content": "We do BFS to find the shortest number of steps from `0` to each node.\\n\\nThen, for each node, we can compute when it sent the last message - using steps to reach this node - `cnt` - and the node patience. \\n\\nThat last message will take `cnt * 2` to reach back home. We track and return the largest value.\\n\\n**C++**\\n```cpp\\nint networkBecomesIdle(vector<vector<int>>& edges, vector<int>& pat) {\\n    bool visited[100001] = {true};\\n    vector<vector<int>> al(pat.size());\\n    for (auto &e : edges) {\\n        al[e[0]].push_back(e[1]);\\n        al[e[1]].push_back(e[0]);\\n    }\\n    int res = 0;\\n    vector<int> q{0};\\n    for (int cnt = 1; !q.empty(); ++cnt) {\\n        vector<int> q1;\\n        for (int i : q) {\\n            for (int j : al[i])\\n                if (!visited[j]) {\\n                    visited[j] = true;\\n                    res = max(res, cnt * 2 + (cnt * 2 - 1) / pat[j] * pat[j]);                    \\n                    q1.push_back(j);\\n                }\\n        }\\n        swap(q, q1);\\n    }\\n    return res + 1;\\n}\\n```",
                "solutionTags": [],
                "code": "```cpp\\nint networkBecomesIdle(vector<vector<int>>& edges, vector<int>& pat) {\\n    bool visited[100001] = {true};\\n    vector<vector<int>> al(pat.size());\\n    for (auto &e : edges) {\\n        al[e[0]].push_back(e[1]);\\n        al[e[1]].push_back(e[0]);\\n    }\\n    int res = 0;\\n    vector<int> q{0};\\n    for (int cnt = 1; !q.empty(); ++cnt) {\\n        vector<int> q1;\\n        for (int i : q) {\\n            for (int j : al[i])\\n                if (!visited[j]) {\\n                    visited[j] = true;\\n                    res = max(res, cnt * 2 + (cnt * 2 - 1) / pat[j] * pat[j]);                    \\n                    q1.push_back(j);\\n                }\\n        }\\n        swap(q, q1);\\n    }\\n    return res + 1;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1524271,
                "title": "c-bfs",
                "content": "See my latest update in repo [LeetCode](https://github.com/lzl124631x/LeetCode)\\n## Solution 1. BFS\\n\\n1. BFS to get the distance from each server to server `0`.\\n2. For the `i`-th server with round-trip distance `d`, the earliest second starting from which the network doesn\\'t have any message from this server is `1 + (d - 1) / patience[i] * patience[i] + d)`. The maximum among them is the answer.\\n\\n```cpp\\n// OJ: https://leetcode.com/problems/the-time-when-the-network-becomes-idle/\\n// Author: github.com/lzl124631x\\n// Time: O(N + E)\\n// Space: O(N + E)\\nclass Solution {\\npublic:\\n    int networkBecomesIdle(vector<vector<int>>& E, vector<int>& P) {\\n        int N = P.size(), step = 0, ans = 0;\\n        vector<vector<int>> G(N);\\n        for (auto &e : E) {\\n            int u = e[0], v = e[1];\\n            G[u].push_back(v);\\n            G[v].push_back(u);\\n        }\\n        vector<bool> seen(N);\\n        seen[0] = true;\\n        queue<int> q{{0}};\\n        while (q.size()) {\\n            int cnt = q.size();\\n            while (cnt--) {\\n                int u = q.front();\\n                q.pop();\\n                for (int v : G[u]) {\\n                    if (seen[v]) continue;\\n                    seen[v] = true;\\n                    q.push(v);\\n                    int d = (step + 1) * 2; // the round-trip distance\\n                    ans = max(ans, 1 + (d - 1) / P[v] * P[v] + d); // `1 + (d - 1) / P[v] * P[v] + d` is the earliest second starting from which there is no messages from this server left in the network\\n                }\\n            }\\n            step++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```cpp\\n// OJ: https://leetcode.com/problems/the-time-when-the-network-becomes-idle/\\n// Author: github.com/lzl124631x\\n// Time: O(N + E)\\n// Space: O(N + E)\\nclass Solution {\\npublic:\\n    int networkBecomesIdle(vector<vector<int>>& E, vector<int>& P) {\\n        int N = P.size(), step = 0, ans = 0;\\n        vector<vector<int>> G(N);\\n        for (auto &e : E) {\\n            int u = e[0], v = e[1];\\n            G[u].push_back(v);\\n            G[v].push_back(u);\\n        }\\n        vector<bool> seen(N);\\n        seen[0] = true;\\n        queue<int> q{{0}};\\n        while (q.size()) {\\n            int cnt = q.size();\\n            while (cnt--) {\\n                int u = q.front();\\n                q.pop();\\n                for (int v : G[u]) {\\n                    if (seen[v]) continue;\\n                    seen[v] = true;\\n                    q.push(v);\\n                    int d = (step + 1) * 2; // the round-trip distance\\n                    ans = max(ans, 1 + (d - 1) / P[v] * P[v] + d); // `1 + (d - 1) / P[v] * P[v] + d` is the earliest second starting from which there is no messages from this server left in the network\\n                }\\n            }\\n            step++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1524197,
                "title": "c-bfs-maths-formula",
                "content": "```\\nclass Solution {\\npublic:\\n    int networkBecomesIdle(vector<vector<int>>& edges, vector<int>& patience) {\\n        // First calulate shortest distance from master to all the data servers \\n        int n = patience.size();\\n        vector<vector<int>> g(n);\\n        for(auto e:edges){\\n            g[e[0]].push_back(e[1]);\\n            g[e[1]].push_back(e[0]);\\n        }\\n        queue<pair<int,int>> q;\\n        q.push({0,0});\\n        vector<int> dist(n,INT_MAX);\\n        dist[0] = 0;\\n        while(!q.empty()){\\n            auto [d,node] = q.front();\\n            q.pop();\\n            for(auto nbr:g[node]){\\n                if(d+1<dist[nbr]){\\n                    dist[nbr] = d+1;\\n                    q.push({d+1,nbr});\\n                }\\n            }\\n        }\\n        int ans = 0;\\n        for(int i=1;i<n;i++){\\n            // Calculate no of messages that were already sent and are in progress when first message is received \\n            int left = ceil((dist[i]*2.0)/patience[i]) - 1;\\n            \\n            // Calculate the position of last message that was sent\\n            int remainStart = dist[i]*2 - left*patience[i]; \\n            \\n            // dist[i]*2 --> This is the time required by first message \\n            // dist[i]*2 - remainStart --> This is the time required by last message to reach back\\n            ans = max(ans,dist[i]*2 - remainStart + dist[i]*2);\\n        }\\n        return ans + 1;\\n    }\\n};\\n```\\n**Hit upvote if you like it :)**",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int networkBecomesIdle(vector<vector<int>>& edges, vector<int>& patience) {\\n        // First calulate shortest distance from master to all the data servers \\n        int n = patience.size();\\n        vector<vector<int>> g(n);\\n        for(auto e:edges){\\n            g[e[0]].push_back(e[1]);\\n            g[e[1]].push_back(e[0]);\\n        }\\n        queue<pair<int,int>> q;\\n        q.push({0,0});\\n        vector<int> dist(n,INT_MAX);\\n        dist[0] = 0;\\n        while(!q.empty()){\\n            auto [d,node] = q.front();\\n            q.pop();\\n            for(auto nbr:g[node]){\\n                if(d+1<dist[nbr]){\\n                    dist[nbr] = d+1;\\n                    q.push({d+1,nbr});\\n                }\\n            }\\n        }\\n        int ans = 0;\\n        for(int i=1;i<n;i++){\\n            // Calculate no of messages that were already sent and are in progress when first message is received \\n            int left = ceil((dist[i]*2.0)/patience[i]) - 1;\\n            \\n            // Calculate the position of last message that was sent\\n            int remainStart = dist[i]*2 - left*patience[i]; \\n            \\n            // dist[i]*2 --> This is the time required by first message \\n            // dist[i]*2 - remainStart --> This is the time required by last message to reach back\\n            ans = max(ans,dist[i]*2 - remainStart + dist[i]*2);\\n        }\\n        return ans + 1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1975030,
                "title": "shortest-path-in-network-undirected-graph-maths-easy-c",
                "content": "```\\nclass Solution {\\npublic:\\n    int networkBecomesIdle(vector<vector<int>>& edges, vector<int>& patience) \\n    {\\n        int n = patience.size();\\n        vector<int>dist(n,INT_MAX);\\n        \\n        vector<int>adj[n];\\n        for(auto x:edges)\\n        {\\n            adj[x[0]].push_back(x[1]);\\n            adj[x[1]].push_back(x[0]);\\n        }\\n        \\n        queue<int>q;\\n        dist[0] = 0;\\n        \\n        q.push(0);\\n        while(!q.empty())\\n        {\\n            auto temp = q.front();\\n            q.pop();\\n            for(auto x:adj[temp])\\n            {\\n                if(1+dist[temp]<dist[x])\\n                {\\n                    dist[x] = 1+ dist[temp];\\n                    q.push(x);\\n                }\\n            }\\n        }\\n        int ans = INT_MIN;\\n        for(int i=1;i<n;i++)\\n        {\\n            ans = max(ans,(int)(dist[i]*2) + (int)(ceil((2*dist[i]*1.0)/patience[i])-1)*patience[i]);\\n            // cout<<ans<<\" \";\\n            // double total = 2*dist[i]*1.0;\\n            // int temp = ceil(total/patience[i])-1;\\n            // ans = max(ans,2*dist[i]+(temp*patience[i]));\\n            \\n        }\\n            \\n        return ans+1;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Math",
                    "Graph",
                    "Shortest Path"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int networkBecomesIdle(vector<vector<int>>& edges, vector<int>& patience) \\n    {\\n        int n = patience.size();\\n        vector<int>dist(n,INT_MAX);\\n        \\n        vector<int>adj[n];\\n        for(auto x:edges)\\n        {\\n            adj[x[0]].push_back(x[1]);\\n            adj[x[1]].push_back(x[0]);\\n        }\\n        \\n        queue<int>q;\\n        dist[0] = 0;\\n        \\n        q.push(0);\\n        while(!q.empty())\\n        {\\n            auto temp = q.front();\\n            q.pop();\\n            for(auto x:adj[temp])\\n            {\\n                if(1+dist[temp]<dist[x])\\n                {\\n                    dist[x] = 1+ dist[temp];\\n                    q.push(x);\\n                }\\n            }\\n        }\\n        int ans = INT_MIN;\\n        for(int i=1;i<n;i++)\\n        {\\n            ans = max(ans,(int)(dist[i]*2) + (int)(ceil((2*dist[i]*1.0)/patience[i])-1)*patience[i]);\\n            // cout<<ans<<\" \";\\n            // double total = 2*dist[i]*1.0;\\n            // int temp = ceil(total/patience[i])-1;\\n            // ans = max(ans,2*dist[i]+(temp*patience[i]));\\n            \\n        }\\n            \\n        return ans+1;\\n        \\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2228264,
                "title": "simple-solution-using-dijkstras-algorithm",
                "content": "First we will create a distance array using simple dijkstras algorithm which stores the shortest distance of each node from 0.\\n`i.e. dist[i] = shortest distance of i from 0 `( here we consider weight of each edge as 1)\\n\\nNow, Suppose a station i is at distance of dist[i] from 0.\\n(For example let\\'s say i is 2 and dist[i] is 12.\\nthat is distance of station 2 from 0 is 12)\\n\\nThis station will send the message to station-0 at time t=0\\nThe time taken by the response to come back to this station would be `2*dist[i]` (i.e. 2x12 = 24 for our example)\\n\\nlet this station has patience[i] = 5\\n\\ntherefore during the time interval of 24 the station would send a total of` numberOfMessages = (2xdist[i] / patience[i])` messages  (for our example 24/5 = 4 messages) with last message being sent at time `numberOfMessages*patience[i] `i.e. 4 * 5 = 20\\n\\nafter which the station will receive the response and will send no more messages.\\n\\nafter all of this the station will receive the response of it\\'s last sent message after the time  `lastMessageTime + roundTripTime `( for our example 20 + 2*12 = 44) \\ntherefore this particular station would be idle at 44 +1 = 45 time units.\\n\\nWe will perform simmilar calculations for all the stations and the max of the result would be our ans:\\n\\nSee code for more clarity:\\n\\n```\\nclass Solution {\\n    public int networkBecomesIdle(int[][] edges, int[] patience) {\\n        int n = patience.length;\\n        \\n\\t\\t// creating adjacency list\\n        ArrayList<ArrayList<Integer>> adj = new ArrayList<>();\\n        for(int i = 0 ; i < n ; i++ ) {\\n            adj.add(new ArrayList<>());\\n        }\\n        \\n        for(int[] edge : edges) {\\n            adj.get(edge[0]).add(edge[1]);\\n            adj.get(edge[1]).add(edge[0]);\\n        }        \\n         \\n\\t\\t // getting the distance array using dijkstra algorithm\\n        int[] dist = dijkstra(adj);        \\n     \\n\\t // variable to store the result\\n        int ans = 0;\\n        \\n\\t\\t\\n\\t\\t// performing the calculations discussed above for each index\\n        for(int x = 1; x < n ; x++) {\\n            \\n\\t\\t\\t// round trip time\\n            int time = 2*dist[x];\\n\\t\\t\\t\\n            int p = patience[x];\\n\\t\\t\\t\\n\\t\\t\\t//total number of messages the station will send until it receives the reply of first message\\n            int numberOfMessagesSent = (time)/p;\\n            \\n\\t\\t\\t//handling an edge case if round trip time is a multiple of patience example time =24 patience = 4  \\n\\t\\t\\t//then the reply would be received at 24 therefore station will not send any message at t = 24 \\n            if(time%p == 0) {\\n                numberOfMessagesSent--;\\n            }\\n        \\n\\t\\t// time of last message\\n            int lastMessage = numberOfMessagesSent*p;\\n\\t\\t\\t\\n\\t\\t\\t// updating the ans to store max of time at which the station becomes idle\\n            ans = Math.max(ans,lastMessage+ 2*dist[x]+1);\\n            \\n        }\\n\\n        return ans;\\n    }\\n    \\n\\t// simple dijkstra algorithm implementation\\n    private int[] dijkstra(ArrayList<ArrayList<Integer>> adj) {\\n        \\n        int n = adj.size();\\n        \\n        int[] dist = new int[n];\\n        boolean[] visited = new boolean[n];\\n        \\n        Arrays.fill(dist,Integer.MAX_VALUE);\\n        dist[0] = 0;\\n        \\n        PriorityQueue<int[]> pq = new PriorityQueue<>((o1,o2)->o1[1]-o2[1]);\\n        \\n        pq.add(new int[]{0,0});\\n        \\n        while(!pq.isEmpty()) {\\n            int[] node = pq.remove();\\n            if(!visited[node[0]]) {\\n                visited[node[0]] = true;   \\n                for(int nbr : adj.get(node[0])) {\\n                    if(dist[nbr] > dist[node[0]]+1) {\\n                        dist[nbr] = dist[node[0]]+1;\\n                        pq.add(new int[]{nbr,dist[nbr]});\\n                    }\\n                }\\n            }           \\n            \\n        }\\n        \\n        return dist;\\n    }\\n    \\n}\\n\\n```\\n",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int networkBecomesIdle(int[][] edges, int[] patience) {\\n        int n = patience.length;\\n        \\n\\t\\t// creating adjacency list\\n        ArrayList<ArrayList<Integer>> adj = new ArrayList<>();\\n        for(int i = 0 ; i < n ; i++ ) {\\n            adj.add(new ArrayList<>());\\n        }\\n        \\n        for(int[] edge : edges) {\\n            adj.get(edge[0]).add(edge[1]);\\n            adj.get(edge[1]).add(edge[0]);\\n        }        \\n         \\n\\t\\t // getting the distance array using dijkstra algorithm\\n        int[] dist = dijkstra(adj);        \\n     \\n\\t // variable to store the result\\n        int ans = 0;\\n        \\n\\t\\t\\n\\t\\t// performing the calculations discussed above for each index\\n        for(int x = 1; x < n ; x++) {\\n            \\n\\t\\t\\t// round trip time\\n            int time = 2*dist[x];\\n\\t\\t\\t\\n            int p = patience[x];\\n\\t\\t\\t\\n\\t\\t\\t//total number of messages the station will send until it receives the reply of first message\\n            int numberOfMessagesSent = (time)/p;\\n            \\n\\t\\t\\t//handling an edge case if round trip time is a multiple of patience example time =24 patience = 4  \\n\\t\\t\\t//then the reply would be received at 24 therefore station will not send any message at t = 24 \\n            if(time%p == 0) {\\n                numberOfMessagesSent--;\\n            }\\n        \\n\\t\\t// time of last message\\n            int lastMessage = numberOfMessagesSent*p;\\n\\t\\t\\t\\n\\t\\t\\t// updating the ans to store max of time at which the station becomes idle\\n            ans = Math.max(ans,lastMessage+ 2*dist[x]+1);\\n            \\n        }\\n\\n        return ans;\\n    }\\n    \\n\\t// simple dijkstra algorithm implementation\\n    private int[] dijkstra(ArrayList<ArrayList<Integer>> adj) {\\n        \\n        int n = adj.size();\\n        \\n        int[] dist = new int[n];\\n        boolean[] visited = new boolean[n];\\n        \\n        Arrays.fill(dist,Integer.MAX_VALUE);\\n        dist[0] = 0;\\n        \\n        PriorityQueue<int[]> pq = new PriorityQueue<>((o1,o2)->o1[1]-o2[1]);\\n        \\n        pq.add(new int[]{0,0});\\n        \\n        while(!pq.isEmpty()) {\\n            int[] node = pq.remove();\\n            if(!visited[node[0]]) {\\n                visited[node[0]] = true;   \\n                for(int nbr : adj.get(node[0])) {\\n                    if(dist[nbr] > dist[node[0]]+1) {\\n                        dist[nbr] = dist[node[0]]+1;\\n                        pq.add(new int[]{nbr,dist[nbr]});\\n                    }\\n                }\\n            }           \\n            \\n        }\\n        \\n        return dist;\\n    }\\n    \\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1524183,
                "title": "python3-graph",
                "content": "\\n```\\nclass Solution:\\n    def networkBecomesIdle(self, edges: List[List[int]], patience: List[int]) -> int:\\n        graph = {}\\n        for u, v in edges: \\n            graph.setdefault(u, []).append(v)\\n            graph.setdefault(v, []).append(u)\\n        \\n        dist = [-1]*len(graph)\\n        dist[0] = 0 \\n        val = 0\\n        queue = [0]\\n        while queue: \\n            val += 2\\n            newq = []\\n            for u in queue: \\n                for v in graph[u]: \\n                    if dist[v] == -1: \\n                        dist[v] = val\\n                        newq.append(v)\\n            queue = newq\\n        \\n        ans = 0\\n        for d, p in zip(dist, patience): \\n            if p: \\n                k = d//p - int(d%p == 0)\\n                ans = max(ans, d + k*p)\\n        return ans + 1\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def networkBecomesIdle(self, edges: List[List[int]], patience: List[int]) -> int:\\n        graph = {}\\n        for u, v in edges: \\n            graph.setdefault(u, []).append(v)\\n            graph.setdefault(v, []).append(u)\\n        \\n        dist = [-1]*len(graph)\\n        dist[0] = 0 \\n        val = 0\\n        queue = [0]\\n        while queue: \\n            val += 2\\n            newq = []\\n            for u in queue: \\n                for v in graph[u]: \\n                    if dist[v] == -1: \\n                        dist[v] = val\\n                        newq.append(v)\\n            queue = newq\\n        \\n        ans = 0\\n        for d, p in zip(dist, patience): \\n            if p: \\n                k = d//p - int(d%p == 0)\\n                ans = max(ans, d + k*p)\\n        return ans + 1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3392913,
                "title": "c-bfs-maths-dry-run-easy-to-understand",
                "content": "\\nThis was fun to solve! Let\\'s understand the problem and approach with an example.\\n<p align=\"center\">\\n  <img src=\"https://assets.leetcode.com/users/images/4e5c2ddc-34d0-4f65-9e63-40344a91f4e6_1680938121.9421952.png\" width=\"190px\" />\\n</p>\\n\\n```\\nedges: [0,1],[0,2],[1,3],[2,3]\\npatience: [0, 4, 1, 1], \\nwhere patience[i] is the time that node i can spend idle without sending a message.\\n```\\nNow let\\'s first find the minimum distance of each node from master server i.e. node 0.\\n``` \\ndistance=[0, 1, 1, 2], \\nwhere distance[i] is the minimum distance of node i from node 0\\n```\\n- Now, the first message from each node will take `firstMsgReceive = 2*distance[i]` time to send & receive the signal back. \\n- The number of extra messages that can be sent during that time is calculated as `numberofExtra = (firstMsgReceive-1)/patience[i]`, because no more resending will occur once the first reply is received.\\n- The last message is sent at `lastMsgSent = numberofExtra*patience[i]` time, because every message is sent after patience[i] time.\\n- The time when we receive the last message would be the sum of the time it took for the first message to come back and the time when last message was sent, i.e. `lastMsgReceive = lastMsgSent + firstMsgReceive`.\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n```\\nFor node 1, firstMsgReceive = distance[1]*2 = 1*2 = 2, \\n            numberOfExtra = (2-1)/4 = 0, \\n            lastMsgSent = 0*4 = 0, \\n            lastMsgReceive = 0 + 2 = 2.\\n\\nFor node 2, firstMsgReceive = 1*2 = 2, \\n            numberOfExtra = (2-1)/1 = 1, \\n            lastMsgSent = 1*1 = 1, \\n            lastMsgReceive = 1 + 2 = 3.\\n\\nFor node 3, firstMsgReceive = 2*2 = 4, \\n            numberOfExtra = (4-1)/1 = 3, \\n            lastMsgSent = 3*1 = 3, \\n            lastMsgReceive = 3 + 4 = 7.\\n```\\nThe maximum of these values is 7, so the idle time for this network is 8 time units.\\n# Complexity\\n- Time complexity: O(E+N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n- Space complexity: O(E+N)\\n\\nwhere E is the number of edges and N is the number of nodes.\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int networkBecomesIdle(vector<vector<int>>& edges, vector<int>& patience) {\\n        int n=patience.size();\\n        vector<vector<int>>adj(n); // adjacency matrix to store the graph\\n        vector<int>distance(n,-1);\\n        for(auto& edge:edges){\\n            adj[edge[0]].push_back(edge[1]);\\n            adj[edge[1]].push_back(edge[0]);\\n        }\\n\\n        queue<int>q; // queue to perfrom bfs to calculate distance\\n        q.push(0);\\n        distance[0]=0;\\n        while(!q.empty()){\\n            int node=q.front();\\n            q.pop();\\n            for(auto& neighbor:adj[node]){\\n                if(distance[neighbor]==-1){\\n                    distance[neighbor]=distance[node]+1;\\n                    q.push(neighbor);\\n                }\\n            }\\n        }\\n        int idleTime=0;\\n        for(int i=1;i<n;++i){\\n            int firstMsgReceive=distance[i]*2; // time it takes for the first message to get back\\n            int numberOfExtra=(firstMsgReceive-1)/patience[i]; // number of extra messages that\\'ll be sent\\n            int lastMsgSent=numberOfExtra*patience[i]; // time at which last message will be sent\\n            int lastMsgReceive=lastMsgSent+firstMsgReceive; // time at which we will receive reply for last message\\n            idleTime=max(idleTime,lastMsgReceive);\\n        }\\n        return idleTime+1; // idle time would be 1 second afterb we receive last message\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Math",
                    "Breadth-First Search"
                ],
                "code": "```\\nedges: [0,1],[0,2],[1,3],[2,3]\\npatience: [0, 4, 1, 1], \\nwhere patience[i] is the time that node i can spend idle without sending a message.\\n```\n``` \\ndistance=[0, 1, 1, 2], \\nwhere distance[i] is the minimum distance of node i from node 0\\n```\n```\\nFor node 1, firstMsgReceive = distance[1]*2 = 1*2 = 2, \\n            numberOfExtra = (2-1)/4 = 0, \\n            lastMsgSent = 0*4 = 0, \\n            lastMsgReceive = 0 + 2 = 2.\\n\\nFor node 2, firstMsgReceive = 1*2 = 2, \\n            numberOfExtra = (2-1)/1 = 1, \\n            lastMsgSent = 1*1 = 1, \\n            lastMsgReceive = 1 + 2 = 3.\\n\\nFor node 3, firstMsgReceive = 2*2 = 4, \\n            numberOfExtra = (4-1)/1 = 3, \\n            lastMsgSent = 3*1 = 3, \\n            lastMsgReceive = 3 + 4 = 7.\\n```\n```\\nclass Solution {\\npublic:\\n    int networkBecomesIdle(vector<vector<int>>& edges, vector<int>& patience) {\\n        int n=patience.size();\\n        vector<vector<int>>adj(n); // adjacency matrix to store the graph\\n        vector<int>distance(n,-1);\\n        for(auto& edge:edges){\\n            adj[edge[0]].push_back(edge[1]);\\n            adj[edge[1]].push_back(edge[0]);\\n        }\\n\\n        queue<int>q; // queue to perfrom bfs to calculate distance\\n        q.push(0);\\n        distance[0]=0;\\n        while(!q.empty()){\\n            int node=q.front();\\n            q.pop();\\n            for(auto& neighbor:adj[node]){\\n                if(distance[neighbor]==-1){\\n                    distance[neighbor]=distance[node]+1;\\n                    q.push(neighbor);\\n                }\\n            }\\n        }\\n        int idleTime=0;\\n        for(int i=1;i<n;++i){\\n            int firstMsgReceive=distance[i]*2; // time it takes for the first message to get back\\n            int numberOfExtra=(firstMsgReceive-1)/patience[i]; // number of extra messages that\\'ll be sent\\n            int lastMsgSent=numberOfExtra*patience[i]; // time at which last message will be sent\\n            int lastMsgReceive=lastMsgSent+firstMsgReceive; // time at which we will receive reply for last message\\n            idleTime=max(idleTime,lastMsgReceive);\\n        }\\n        return idleTime+1; // idle time would be 1 second afterb we receive last message\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1524334,
                "title": "simple-using-bfs",
                "content": "step1: find the smallest distance from the root to each and every node\\nstep 2: find the last packet which was dispatched \\nstep 3: if patience is less than time 2*(time from node to root)\\n\\t then simply add the total time + time of the last dispatched packet\\nstep 4: find the maximum of it.\\n\\'\\'\\'\\nclass Solution {\\npublic:\\n    \\n    void bfs(vector<int> &visited, unordered_map<int,vector<int>> um)\\n    {\\n        queue<pair<int,int>> q;\\n        q.push({0,0});\\n        visited[0] =1;\\n        while(!q.empty())\\n        {\\n            auto cur = q.front();\\n            q.pop();\\n            for(auto i:um[cur.first])\\n            {\\n                if(visited[i] == 0)\\n                {\\n                    visited[i] = cur.second+1;\\n                    q.push({i,cur.second+1});\\n                }\\n            }\\n        }\\n    }\\n    \\n    int networkBecomesIdle(vector<vector<int>>& edges, vector<int>& patience) {\\n        \\n        unordered_map<int,vector<int>> um;\\n        int n = patience.size();\\n        \\n        int ans;\\n        vector<int> visited(n,0);\\n        for(auto i:edges)\\n        {\\n            um[i[0]].push_back(i[1]);\\n            um[i[1]].push_back(i[0]);\\n        }\\n        \\n        bfs(visited,um);\\n        \\n        visited[0] = 0;\\n        \\n        vector<int> launch(n,0);\\n        \\n        for(int i = 0; i<n;i++)\\n        {\\n            visited[i] = visited[i]*2;\\n            if(patience[i]<visited[i])\\n            {\\n                int temp = (visited[i]-1)/patience[i];\\n                temp = temp*patience[i];\\n                visited[i] +=temp; \\n            }\\n        }\\n        \\n        int res = 0;\\n        for(auto i:visited)\\n            res = max(res,i);\\n        res++;\\n        \\n        return res;\\n        \\n    }\\n};\\n\\'\\'\\'",
                "solutionTags": [
                    "C",
                    "Breadth-First Search"
                ],
                "code": "class Solution {\\npublic:\\n    \\n    void bfs(vector<int> &visited, unordered_map<int,vector<int>> um)\\n    {\\n        queue<pair<int,int>> q;\\n        q.push({0,0}",
                "codeTag": "Java"
            },
            {
                "id": 1524192,
                "title": "python-bfs-o-vertices-edges",
                "content": "Calculate the round trip time from each node to 0 with BFS. \\nThen iterate nodes 1 to n-1 to find the longest time until last sent message returns.\\n\\n```\\ndef networkBecomesIdle(self, edges: List[List[int]], patience: List[int]) -> int:\\n\\tn = len(patience)\\n\\t\\n\\t# create adjacency list from edges\\n\\tadj = collections.defaultdict(list)\\n\\tfor u, v in edges:\\n\\t\\tadj[u].append(v)\\n\\t\\tadj[v].append(u)\\n\\n\\t# BFS to get distances\\n\\tround_trip = [0]*n\\n\\tq = collections.deque([0])\\n\\tvisited = set([0])\\n\\tdist = 0\\n\\twhile q:\\n\\t\\tfor _ in range(len(q)):\\n\\t\\t\\tcur = q.popleft()\\n\\t\\t\\tround_trip[cur] = dist\\n\\t\\t\\tfor nei in adj[cur]:\\n\\t\\t\\t\\tif nei not in visited:    # no re-visits to the same node\\n\\t\\t\\t\\t\\tq.append(nei)\\n\\t\\t\\t\\t\\tvisited.add(nei)       \\n\\t\\tdist += 2    # round-trip distance of each edge\\n\\n\\n\\tlongest_time = 0    # find the max time of all messages returning to senders\\n\\tfor i in range(1, n):\\n\\t\\tlast_sent = ((round_trip[i] - 1) // patience[i]) * patience[i]     # timestamp of the final message\\n\\t\\tlongest_time = max(longest_time, last_sent + round_trip[i])\\n\\n\\treturn longest_time + 1\\n```\\n- Time: O(N + E), where N = number of vertices, E = number of edges. Because creating adjacency list costs O(E), and BFS and finding longest_time cost O(N).\\n- Space: O(N + E).\\n",
                "solutionTags": [
                    "Python",
                    "Breadth-First Search"
                ],
                "code": "```\\ndef networkBecomesIdle(self, edges: List[List[int]], patience: List[int]) -> int:\\n\\tn = len(patience)\\n\\t\\n\\t# create adjacency list from edges\\n\\tadj = collections.defaultdict(list)\\n\\tfor u, v in edges:\\n\\t\\tadj[u].append(v)\\n\\t\\tadj[v].append(u)\\n\\n\\t# BFS to get distances\\n\\tround_trip = [0]*n\\n\\tq = collections.deque([0])\\n\\tvisited = set([0])\\n\\tdist = 0\\n\\twhile q:\\n\\t\\tfor _ in range(len(q)):\\n\\t\\t\\tcur = q.popleft()\\n\\t\\t\\tround_trip[cur] = dist\\n\\t\\t\\tfor nei in adj[cur]:\\n\\t\\t\\t\\tif nei not in visited:    # no re-visits to the same node\\n\\t\\t\\t\\t\\tq.append(nei)\\n\\t\\t\\t\\t\\tvisited.add(nei)       \\n\\t\\tdist += 2    # round-trip distance of each edge\\n\\n\\n\\tlongest_time = 0    # find the max time of all messages returning to senders\\n\\tfor i in range(1, n):\\n\\t\\tlast_sent = ((round_trip[i] - 1) // patience[i]) * patience[i]     # timestamp of the final message\\n\\t\\tlongest_time = max(longest_time, last_sent + round_trip[i])\\n\\n\\treturn longest_time + 1\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1524422,
                "title": "java-dfs-solution-for-those-who-failed-to-do-with-dfs-in-contest",
                "content": "````\\nclass Solution {\\n\\t\\n    List<Integer> adj[];\\n\\tint min[];\\n\\tboolean vis[];\\n\\tvoid dfs(int i,int level)\\n\\t{\\n\\t\\tfor(Integer ele : adj[i])\\n\\t\\t{\\n\\t\\t\\tif(vis[ele])\\n\\t\\t\\t{\\n                if(min[ele]>level*2) {\\n\\t\\t\\t\\t\\n                    min[ele]=level*2;\\n                    dfs(ele,level+1);\\n                }\\n\\t\\t\\t\\tcontinue;\\n\\t\\t\\t}\\n\\t\\t\\tvis[ele]=true;\\n\\t\\t\\tmin[ele]=level*2;\\n\\t\\t\\tdfs(ele,level+1);\\n\\t\\t}\\n\\t}\\n    public int networkBecomesIdle(int[][] arr, int[] pat) {\\n\\n    \\tint i,n=pat.length;\\n    \\t\\n        adj=new ArrayList[n];\\n    \\tmin=new int[n];\\n    \\tvis=new boolean[n];\\n    \\tvis[0]=true;\\n    \\t\\n        for(i=0;i<n;i++)\\n    \\t\\tadj[i]=new ArrayList<>();\\n    \\tfor(i=0;i<arr.length;i++)\\n    \\t{\\n    \\t\\tadj[arr[i][0]].add(arr[i][1]);\\n    \\t\\tadj[arr[i][1]].add(arr[i][0]);\\n    \\t}\\n    \\t\\n        dfs(0,1);\\n        \\n        int max=0;\\n    \\tfor(i=1;i<n;i++)\\n    \\t{\\n    \\t\\tif(adj[i].size()==0)\\n    \\t\\t\\tcontinue;\\n    \\t\\tif(pat[i]>=min[i])\\n    \\t\\t\\tmax=Math.max(max,min[i]);\\n    \\t\\telse \\n    \\t\\t\\tmax=Math.max(max, min[i]+pat[i]*((int)Math.ceil(min[i]/(double)pat[i])-1));\\n    \\t}\\n    \\treturn max+1;\\n    }\\n}\\n````\\nIf you guys get it then please **upvote** my solution!",
                "solutionTags": [
                    "Java",
                    "Depth-First Search"
                ],
                "code": "````\\nclass Solution {\\n\\t\\n    List<Integer> adj[];\\n\\tint min[];\\n\\tboolean vis[];\\n\\tvoid dfs(int i,int level)\\n\\t{\\n\\t\\tfor(Integer ele : adj[i])\\n\\t\\t{\\n\\t\\t\\tif(vis[ele])\\n\\t\\t\\t{\\n                if(min[ele]>level*2) {\\n\\t\\t\\t\\t\\n                    min[ele]=level*2;\\n                    dfs(ele,level+1);\\n                }\\n\\t\\t\\t\\tcontinue;\\n\\t\\t\\t}\\n\\t\\t\\tvis[ele]=true;\\n\\t\\t\\tmin[ele]=level*2;\\n\\t\\t\\tdfs(ele,level+1);\\n\\t\\t}\\n\\t}\\n    public int networkBecomesIdle(int[][] arr, int[] pat) {\\n\\n    \\tint i,n=pat.length;\\n    \\t\\n        adj=new ArrayList[n];\\n    \\tmin=new int[n];\\n    \\tvis=new boolean[n];\\n    \\tvis[0]=true;\\n    \\t\\n        for(i=0;i<n;i++)\\n    \\t\\tadj[i]=new ArrayList<>();\\n    \\tfor(i=0;i<arr.length;i++)\\n    \\t{\\n    \\t\\tadj[arr[i][0]].add(arr[i][1]);\\n    \\t\\tadj[arr[i][1]].add(arr[i][0]);\\n    \\t}\\n    \\t\\n        dfs(0,1);\\n        \\n        int max=0;\\n    \\tfor(i=1;i<n;i++)\\n    \\t{\\n    \\t\\tif(adj[i].size()==0)\\n    \\t\\t\\tcontinue;\\n    \\t\\tif(pat[i]>=min[i])\\n    \\t\\t\\tmax=Math.max(max,min[i]);\\n    \\t\\telse \\n    \\t\\t\\tmax=Math.max(max, min[i]+pat[i]*((int)Math.ceil(min[i]/(double)pat[i])-1));\\n    \\t}\\n    \\treturn max+1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3835324,
                "title": "clear-bfs-solution-beats-100-python-96-5-java",
                "content": "# Intuition\\nAfter using BFS to determine the distance between the start node and every other node, we can calculate when the last messages will be sent and received.\\n\\n# Approach\\n1. Convert the edge list into an adjacency list.\\n2. Use BFS to compute the distance from the start node to every other node.\\n3. Use a helper method `getLastSend()` to determine when the last message will be sent by a node `n`.\\n    1. If `patience[n]` is greater than the round trip message latency (`2 * distance[n]`), only the original message will be sent at time 0.\\n    2. If the round trip time is a multiple of `patience[n]`, the last message will be sent at `patience[n]` ticks before the arrival of the response to the original message.\\n    3. Otherwise, the last message will be sent at time `2 * distance[n] - (2 * distance[n] % patience[n])\\n4. Compute the maximum time for a node to receive a response to its last message. For each node, this is the sum of:\\n    - the last send time (computed by the helper method)\\n    - the round trip latency (`2 * distance[n]`)\\n3. Add 1 to find when the network will become idle.\\n\\n# Complexity\\n- Time complexity: $$O(E+V)$$\\n    - Building the adjacency list: $$O(E)$$\\n    - Calculating the distances: $$O(E)$$\\n    - Calculating the max time: $$O(V)$$\\n\\n- Space complexity: $$O(E+V)$$\\n    - The adjacency list: $$O(E+V)$$\\n    - The distance array: $$O(V)$$\\n    - The BFS queue: $$O(V)$$\\n\\nAny of the $O(E+V)$ terms above can be replaced with $O(E)$ because the graph is connected, implying that $V < E + 1$.\\n\\n# Python Code\\n```\\nclass Solution:\\n    def networkBecomesIdle(self, edges: List[List[int]], patience: List[int]) -> int:\\n        # Build adjacency list.\\n        graph = defaultdict(list)\\n        for u, v in edges:\\n            graph[u].append(v)\\n            graph[v].append(u)\\n\\n        # Perform BFS to find distances.\\n        distance = [None] * len(patience)\\n        distance[0] = 0\\n        queue = deque()\\n        queue.append(0)\\n        # Instance of explicitly keeping track of which nodes are\\n        # visited, use None as the distance to unvisited nodes.\\n        while queue:\\n            node = queue.popleft()\\n            for neighbor in graph[node]:\\n                if not distance[neighbor]:\\n                    distance[neighbor] = 1 + distance[node]\\n                    queue.append(neighbor)\\n\\n        def getLastSend(n: int) -> int:\\n            \"\"\"Compute when the last message is sent by node n.\"\"\"\\n            if patience[n] >= 2 * distance[n]:\\n                return 0\\n            if (2 * distance[n]) % patience[n] == 0:\\n                return 2 * distance[n] - patience[n]\\n            return 2 * distance[n] - (2 * distance[n] % patience[n])\\n\\n        # Calculate the max time for a node to receive its last response.\\n        maxTime = 0\\n        for n in range(1, len(patience)):\\n            lastSend = getLastSend(n)\\n            lastReceive = lastSend + 2 * distance[n]\\n            maxTime = max(maxTime, lastReceive)\\n        # The above loop can be replaced by a single line with a list comprehension:\\n        maxTime = max(getLastSend(n) + 2 * distance[n] for n in range(1, len(patience)))\\n\\n        return maxTime + 1\\n```\\n\\n# Java Code\\n```\\nclass Solution {\\n    private int getLastSend(int d, int p) {\\n        if (p >= 2 * d) {\\n            return 0;\\n        }\\n        if ((2 * d) % p == 0) {\\n            return 2 * d - p;\\n        }\\n        return 2 * d - (2 * d) % p;\\n    }\\n\\n    public int networkBecomesIdle(int[][] edges, int[] patience) {\\n        // Build adjacency list.\\n        List<List<Integer>> graph = new ArrayList<>();\\n        for (int i = 0; i < patience.length; i++) {\\n            graph.add(new ArrayList<>());\\n        }\\n        for (int[] edge : edges) {\\n            int u = edge[0];\\n            int v = edge[1];\\n            graph.get(u).add(v);\\n            graph.get(v).add(u);\\n        }\\n\\n        // Perform BFS to find the min distance of each node from the root.\\n        int[] distance = new int[patience.length];\\n        boolean[] visited = new boolean[patience.length];\\n        visited[0] = true;\\n        Queue<Integer> queue = new LinkedList<>();\\n        queue.add(0);\\n        while (!queue.isEmpty()) {\\n            int node = queue.remove();\\n            for (int neighbor : graph.get(node)) {\\n                if (!visited[neighbor]) {\\n                    distance[neighbor] = 1 + distance[node];\\n                    queue.add(neighbor);\\n                    visited[neighbor] = true;\\n                }\\n            }\\n        }\\n\\n        int maxTime = 0;\\n        for (int n = 1; n < patience.length; n++) {\\n            int lastSend = getLastSend(distance[n], patience[n]);\\n            int lastReceive = lastSend + 2 * distance[n];\\n            maxTime = Math.max(maxTime, lastReceive);\\n        }\\n        return maxTime + 1;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def networkBecomesIdle(self, edges: List[List[int]], patience: List[int]) -> int:\\n        # Build adjacency list.\\n        graph = defaultdict(list)\\n        for u, v in edges:\\n            graph[u].append(v)\\n            graph[v].append(u)\\n\\n        # Perform BFS to find distances.\\n        distance = [None] * len(patience)\\n        distance[0] = 0\\n        queue = deque()\\n        queue.append(0)\\n        # Instance of explicitly keeping track of which nodes are\\n        # visited, use None as the distance to unvisited nodes.\\n        while queue:\\n            node = queue.popleft()\\n            for neighbor in graph[node]:\\n                if not distance[neighbor]:\\n                    distance[neighbor] = 1 + distance[node]\\n                    queue.append(neighbor)\\n\\n        def getLastSend(n: int) -> int:\\n            \"\"\"Compute when the last message is sent by node n.\"\"\"\\n            if patience[n] >= 2 * distance[n]:\\n                return 0\\n            if (2 * distance[n]) % patience[n] == 0:\\n                return 2 * distance[n] - patience[n]\\n            return 2 * distance[n] - (2 * distance[n] % patience[n])\\n\\n        # Calculate the max time for a node to receive its last response.\\n        maxTime = 0\\n        for n in range(1, len(patience)):\\n            lastSend = getLastSend(n)\\n            lastReceive = lastSend + 2 * distance[n]\\n            maxTime = max(maxTime, lastReceive)\\n        # The above loop can be replaced by a single line with a list comprehension:\\n        maxTime = max(getLastSend(n) + 2 * distance[n] for n in range(1, len(patience)))\\n\\n        return maxTime + 1\\n```\n```\\nclass Solution {\\n    private int getLastSend(int d, int p) {\\n        if (p >= 2 * d) {\\n            return 0;\\n        }\\n        if ((2 * d) % p == 0) {\\n            return 2 * d - p;\\n        }\\n        return 2 * d - (2 * d) % p;\\n    }\\n\\n    public int networkBecomesIdle(int[][] edges, int[] patience) {\\n        // Build adjacency list.\\n        List<List<Integer>> graph = new ArrayList<>();\\n        for (int i = 0; i < patience.length; i++) {\\n            graph.add(new ArrayList<>());\\n        }\\n        for (int[] edge : edges) {\\n            int u = edge[0];\\n            int v = edge[1];\\n            graph.get(u).add(v);\\n            graph.get(v).add(u);\\n        }\\n\\n        // Perform BFS to find the min distance of each node from the root.\\n        int[] distance = new int[patience.length];\\n        boolean[] visited = new boolean[patience.length];\\n        visited[0] = true;\\n        Queue<Integer> queue = new LinkedList<>();\\n        queue.add(0);\\n        while (!queue.isEmpty()) {\\n            int node = queue.remove();\\n            for (int neighbor : graph.get(node)) {\\n                if (!visited[neighbor]) {\\n                    distance[neighbor] = 1 + distance[node];\\n                    queue.add(neighbor);\\n                    visited[neighbor] = true;\\n                }\\n            }\\n        }\\n\\n        int maxTime = 0;\\n        for (int n = 1; n < patience.length; n++) {\\n            int lastSend = getLastSend(distance[n], patience[n]);\\n            int lastReceive = lastSend + 2 * distance[n];\\n            maxTime = Math.max(maxTime, lastReceive);\\n        }\\n        return maxTime + 1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2056613,
                "title": "python-bfs-traversal-queue",
                "content": "```\\nfrom queue import Queue\\n\\nclass Solution:\\n    \\'\\'\\'\\n    we can try to solve this problem by applying BFS traversal \\n    \\'\\'\\'\\n    def networkBecomesIdle(self, edges: List[List[int]], patience: List[int]) -> int:\\n        # create a graph map\\n        graph_map = {i: [] for i in range(len(patience))}\\n        for edge in edges:\\n            graph_map[edge[0]].append(edge[1])\\n            graph_map[edge[1]].append(edge[0])\\n            \\n        visited = set()\\n        \\n        queue = Queue()\\n        queue.put(0)\\n        visited.add(0)\\n        distance = -1\\n        \\n        max_time_so_far = 0\\n        while not queue.empty():\\n            distance+=1\\n            for _ in range(queue.qsize()):\\n                node = queue.get()\\n                if node != 0:\\n                    round_trip_time_for_single_packet = 2 * distance\\n                    # compute the total time required by data server node to get idle\\n                    extra_msg_sent = math.ceil(round_trip_time_for_single_packet / patience[node]) - 1\\n                    time = extra_msg_sent * patience[node] + round_trip_time_for_single_packet\\n                    max_time_so_far = max(max_time_so_far, time)\\n                for data_node in graph_map[node]:\\n                    if data_node not in visited:\\n                        queue.put(data_node)\\n                        visited.add(data_node)\\n        return int(max_time_so_far)+1\\n```",
                "solutionTags": [
                    "Python",
                    "Breadth-First Search"
                ],
                "code": "```\\nfrom queue import Queue\\n\\nclass Solution:\\n    \\'\\'\\'\\n    we can try to solve this problem by applying BFS traversal \\n    \\'\\'\\'\\n    def networkBecomesIdle(self, edges: List[List[int]], patience: List[int]) -> int:\\n        # create a graph map\\n        graph_map = {i: [] for i in range(len(patience))}\\n        for edge in edges:\\n            graph_map[edge[0]].append(edge[1])\\n            graph_map[edge[1]].append(edge[0])\\n            \\n        visited = set()\\n        \\n        queue = Queue()\\n        queue.put(0)\\n        visited.add(0)\\n        distance = -1\\n        \\n        max_time_so_far = 0\\n        while not queue.empty():\\n            distance+=1\\n            for _ in range(queue.qsize()):\\n                node = queue.get()\\n                if node != 0:\\n                    round_trip_time_for_single_packet = 2 * distance\\n                    # compute the total time required by data server node to get idle\\n                    extra_msg_sent = math.ceil(round_trip_time_for_single_packet / patience[node]) - 1\\n                    time = extra_msg_sent * patience[node] + round_trip_time_for_single_packet\\n                    max_time_so_far = max(max_time_so_far, time)\\n                for data_node in graph_map[node]:\\n                    if data_node not in visited:\\n                        queue.put(data_node)\\n                        visited.add(data_node)\\n        return int(max_time_so_far)+1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1767266,
                "title": "python-dfs-with-explanation",
                "content": "The first thing to notice is that each of the data server communicates independently with the master via certain paths. That means, we can find the idle time of all of the data servers and the largest value of the idle time among all servers will be our answer.\\n\\nNow, lets focus on a some generic data server S. Also assume that the shortest path from the server to to the master takes d seconds (i.e it is d-nodes distance away). How can we find it\\'s idle time? Well, there can basically be two cases:\\n1. The patience p of this server is larger than the round-trip time 2d. In this case, the server will receive the message back before sending the second message. So, in this case, the idle time = 2d + 1\\n2. The patience p is less than the round-trip time 2d. In this case, the server will have already sent a repeat message by the time it recieves back the first message. What time is the last repeat message sent, and how long will this server have to wait until it receives the return message of the last repeat message? This is a bit tricky and you should take your time to figure this out. The answer will be like this, where p is the patience and rnd_trip is the round trip time.\\n\\n```\\n                gap = rnd_trip % p\\n                gap = p if gap == 0 else gap\\n                idle_time = 2*rnd_trip - gap + 1\\n```\\n\\nNow, we are in a position where if we knew the distance of all the nodes, we can calculate the idle time for them all.\\n\\nNow all that is left is to use a bfs search to find the shortest distance from the root to all of the nodes. \\n\\n```\\nclass Solution(object):\\n    def networkBecomesIdle(self, edges, patience):\\n        \"\"\"\\n        :type edges: List[List[int]]\\n        :type patience: List[int]\\n        :rtype: int\\n        \"\"\"\\n        n = len(patience)\\n        neighbors = defaultdict(list)\\n        for edge in edges:\\n            neighbors[edge[0]].append(edge[1])\\n            neighbors[edge[1]].append(edge[0])\\n        \\n        distances = [float(\\'inf\\')]*n\\n        \\n        def bfs(root):\\n            to_visit = deque()\\n            distances[root] = 0\\n            to_visit.append((root,0))\\n            while to_visit:\\n                node, dist = to_visit.popleft()\\n                for nn in neighbors[node]:\\n                    if dist+1 < distances[nn]:\\n                        distances[nn] = dist + 1\\n                        to_visit.append((nn, dist+1))\\n        \\n        def get_idle_time(node):\\n            rnd_trip = distances[node]*2\\n            p = patience[node]\\n            if p < rnd_trip:\\n                gap = rnd_trip % p\\n                gap = p if gap == 0 else gap\\n                idle_time = 2*rnd_trip - gap + 1\\n            else:\\n                idle_time = rnd_trip + 1\\n            return idle_time\\n        \\n        bfs(0)\\n        idle_times = [get_idle_time(nd) for nd in range(n)]\\n        return max(idle_times)\\n```\\n",
                "solutionTags": [
                    "Python",
                    "Depth-First Search"
                ],
                "code": "```\\n                gap = rnd_trip % p\\n                gap = p if gap == 0 else gap\\n                idle_time = 2*rnd_trip - gap + 1\\n```\n```\\nclass Solution(object):\\n    def networkBecomesIdle(self, edges, patience):\\n        \"\"\"\\n        :type edges: List[List[int]]\\n        :type patience: List[int]\\n        :rtype: int\\n        \"\"\"\\n        n = len(patience)\\n        neighbors = defaultdict(list)\\n        for edge in edges:\\n            neighbors[edge[0]].append(edge[1])\\n            neighbors[edge[1]].append(edge[0])\\n        \\n        distances = [float(\\'inf\\')]*n\\n        \\n        def bfs(root):\\n            to_visit = deque()\\n            distances[root] = 0\\n            to_visit.append((root,0))\\n            while to_visit:\\n                node, dist = to_visit.popleft()\\n                for nn in neighbors[node]:\\n                    if dist+1 < distances[nn]:\\n                        distances[nn] = dist + 1\\n                        to_visit.append((nn, dist+1))\\n        \\n        def get_idle_time(node):\\n            rnd_trip = distances[node]*2\\n            p = patience[node]\\n            if p < rnd_trip:\\n                gap = rnd_trip % p\\n                gap = p if gap == 0 else gap\\n                idle_time = 2*rnd_trip - gap + 1\\n            else:\\n                idle_time = rnd_trip + 1\\n            return idle_time\\n        \\n        bfs(0)\\n        idle_times = [get_idle_time(nd) for nd in range(n)]\\n        return max(idle_times)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1524322,
                "title": "java-bfs-easy-understanding",
                "content": "import java.util.ArrayList;\\nimport java.util.LinkedList;\\nimport java.util.Queue;\\n\\nclass Solution {\\n    public int networkBecomesIdle(int[][] edges, int[] patience) {\\n\\n        int n = patience.length;\\n        ArrayList<ArrayList<Integer>> adj = new ArrayList<>();\\n        boolean[] visited = new boolean[n + 1];\\n        int[] minDis = new int[n + 1];\\n        for (int i = 0; i <= n; i++) {\\n            adj.add(new ArrayList<>());\\n        }\\n\\n        int m = edges.length;\\n        for (int i = 0; i < m; i++) {\\n            adj.get(edges[i][0]).add(edges[i][1]);\\n            adj.get(edges[i][1]).add(edges[i][0]);\\n        }\\n        Queue<int[]> q = new LinkedList<>();\\n        q.add(new int[]{0, 0});\\n        visited[0] = true;\\n        while (!q.isEmpty()) {\\n            int[] temp = q.poll();\\n            for (int i = 0; i < adj.get(temp[0]).size(); i++) {\\n                int u = adj.get(temp[0]).get(i);\\n                if (!visited[u]) {\\n                    visited[u] = true;\\n                    minDis[u] = temp[1] + 1;\\n                    q.add(new int[]{u, minDis[u]});\\n                }\\n            }\\n        }\\n\\n        int ans = 0;\\n        for (int i = 1; i < n; i++) {\\n\\n            int time = 2 * minDis[i];\\n            ans = Math.max(time, ans);\\n            int num = time / patience[i];\\n            if (time % patience[i] == 0) {\\n                num--;\\n            }\\n            int lastMessage = num * patience[i] + 2 * minDis[i];\\n            ans = Math.max(lastMessage, ans);\\n\\n        }\\n        return ans+1;\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public int networkBecomesIdle(int[][] edges, int[] patience) {\\n\\n        int n = patience.length;\\n        ArrayList<ArrayList<Integer>> adj = new ArrayList<>();\\n        boolean[] visited = new boolean[n + 1];\\n        int[] minDis = new int[n + 1];\\n        for (int i = 0; i <= n; i++) {\\n            adj.add(new ArrayList<>());\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1524265,
                "title": "c-dijkstra",
                "content": "Max time will time taken by the farthest server.\\nTime taken by a server is total distance need to be covered + (additional time taken by the last message of the server)\\nadditional time taken by the last message of the server = time at which last message was sent by the server\\n\\nRest of the problem is textbook dijkstra algo\\n```\\n#define pr pair<int,int>\\nclass Solution {\\npublic:\\n    int networkBecomesIdle(vector<vector<int>>& edges, vector<int>& patience) {\\n    int n=patience.size();\\n    vector<vector<pr>> graph(n);\\n    for(auto &it:edges) \\n    {\\n        graph[it[0]].push_back({it[1],1});\\n        graph[it[1]].push_back({it[0],1});\\n    }\\n    priority_queue<pr,vector<pr>,greater<pr>> pq;   \\n    vector<int> dist(n,INT_MAX);\\n    dist[0]=0;\\n    pq.push({0,0});\\n    while(!pq.empty())\\n    {\\n        int d=pq.top().first,v=pq.top().second;\\n        pq.pop();\\n        for(auto &it:graph[v])\\n        {\\n            int dis=it.second,cur=it.first;\\n            if(dis+d < dist[cur])\\n            {\\n                dist[cur]=d+dis;\\n                pq.push({dist[cur],cur});\\n            }\\n        }\\n    }\\n    int ans=0;\\n    for(int i=1;i<n;i++)\\n    {\\n        int time=2*dist[i],cur;\\n        if(patience[i]>=time) cur=time;\\n        else\\n        {\\n            cur=((time-1)/patience[i]) * patience[i];\\n            cur+=time;\\n        }\\n        ans=max(ans,cur+1);\\n    }\\n    return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\n#define pr pair<int,int>\\nclass Solution {\\npublic:\\n    int networkBecomesIdle(vector<vector<int>>& edges, vector<int>& patience) {\\n    int n=patience.size();\\n    vector<vector<pr>> graph(n);\\n    for(auto &it:edges) \\n    {\\n        graph[it[0]].push_back({it[1],1});\\n        graph[it[1]].push_back({it[0],1});\\n    }\\n    priority_queue<pr,vector<pr>,greater<pr>> pq;   \\n    vector<int> dist(n,INT_MAX);\\n    dist[0]=0;\\n    pq.push({0,0});\\n    while(!pq.empty())\\n    {\\n        int d=pq.top().first,v=pq.top().second;\\n        pq.pop();\\n        for(auto &it:graph[v])\\n        {\\n            int dis=it.second,cur=it.first;\\n            if(dis+d < dist[cur])\\n            {\\n                dist[cur]=d+dis;\\n                pq.push({dist[cur],cur});\\n            }\\n        }\\n    }\\n    int ans=0;\\n    for(int i=1;i<n;i++)\\n    {\\n        int time=2*dist[i],cur;\\n        if(patience[i]>=time) cur=time;\\n        else\\n        {\\n            cur=((time-1)/patience[i]) * patience[i];\\n            cur+=time;\\n        }\\n        ans=max(ans,cur+1);\\n    }\\n    return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1524207,
                "title": "easy-o-nlogn-approach-with-comments-and-explanation-c",
                "content": "EASY  O(NLOGN) Approach with comments and explanation C++\\n\\nIn this question we will first calculate the shortest distance of all the nodes from 0 as this will tell us the time taken by message for coming from nth node to 0 and going back \\nThis can be calculated by djikstra algorithm this will give us the shorted Distance from node 0 to all the other nodes\\n\\nAfter getting the minimum distance of all node from 0 we will calculate the last message time  that will be sent from a node to 0 before receiving the message back\\nIe as in sample test case the last message that was sent by 2 node to 0 node was at time 3\\nWe will calc this for every node and the ans for each node will be : last message time+ (time taken for last msg to deliver at 0 and come back) \\n  Ie   last message time+ 2*(Distance between nth node and 0) \\n\\nThe toughest part atleast for me in this ques \\n\\nLast message sent time :          patience[I] * (( 2*distance between nth node and 0)/p)- (1 (if 2*dist[I] %p[I]==0) \\n \\nWhy this   let Dist be 17 and patience for that node be 2\\n So the last msg time will be 32   => ( 2 * (2*17/2  -1 )==2*(17-1)=2*16=32 \\n How is this formula working \\n \\u2014     No of messages sent will be  (2*dist ) /patience  [2*dist is the total distance and patience is the time\\n  \\u2014    We have to remove the last message if  2*dist%patience ==0  why at this time the response will be received and we will not send message \\n          [for eg in dist =17 and patience = 2 we will not count the message sent at 34 second because at 34 second message will be received ]\\n  \\u2014 patience * no of msg sent \\n \\n\\n```\\nclass Solution {\\npublic:\\n    int networkBecomesIdle(vector<vector<int>>& edges, vector<int>& p) {\\n        vector<vector<int>>graph(p.size(),vector<int>());\\n        for(int i=0;i<edges.size();i++){\\n            graph[edges[i][0]].push_back(edges[i][1]);\\n            graph[edges[i][1]].push_back(edges[i][0]);                                          // making graph\\n            \\n        }\\n        vector<int>dis(p.size(),INT_MAX);\\n       priority_queue<pair<int,int>,vector<pair<int,int>>,greater<pair<int,int>>>q;\\n        q.push({0,0});\\n        while(q.size()){\\n            int a=q.size();\\n            while(a--){                            \\n                pair<int,int> b=q.top();                                                                     //djisktra algorithm and storing the distance in dis array\\n                q.pop();\\n                if(dis[b.second]!=INT_MAX)\\n                    continue;\\n                dis[b.second]=b.first;\\n                for(int c:graph[b.second]){\\n                    if(dis[c]==INT_MAX){\\n                        q.push({b.first+1,c});\\n                    }\\n                }\\n            }\\n        }\\n        int ans=0;\\n        for(int i=1;i<p.size();i++){\\n           int t=( (2*dis[i])/p[i]);\\n            if( ((2*dis[i])%p[i])==0)                                                      \\n                 t-=1;\\n                                 \\n            ans=max(ans,((t*p[i])+(2*dis[i])));                                     // t*p[I] is the last message that is sent form the ith node\\n            }\\n            return ans+1;\\n    }\\n};\\n```\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int networkBecomesIdle(vector<vector<int>>& edges, vector<int>& p) {\\n        vector<vector<int>>graph(p.size(),vector<int>());\\n        for(int i=0;i<edges.size();i++){\\n            graph[edges[i][0]].push_back(edges[i][1]);\\n            graph[edges[i][1]].push_back(edges[i][0]);                                          // making graph\\n            \\n        }\\n        vector<int>dis(p.size(),INT_MAX);\\n       priority_queue<pair<int,int>,vector<pair<int,int>>,greater<pair<int,int>>>q;\\n        q.push({0,0});\\n        while(q.size()){\\n            int a=q.size();\\n            while(a--){                            \\n                pair<int,int> b=q.top();                                                                     //djisktra algorithm and storing the distance in dis array\\n                q.pop();\\n                if(dis[b.second]!=INT_MAX)\\n                    continue;\\n                dis[b.second]=b.first;\\n                for(int c:graph[b.second]){\\n                    if(dis[c]==INT_MAX){\\n                        q.push({b.first+1,c});\\n                    }\\n                }\\n            }\\n        }\\n        int ans=0;\\n        for(int i=1;i<p.size();i++){\\n           int t=( (2*dis[i])/p[i]);\\n            if( ((2*dis[i])%p[i])==0)                                                      \\n                 t-=1;\\n                                 \\n            ans=max(ans,((t*p[i])+(2*dis[i])));                                     // t*p[I] is the last message that is sent form the ith node\\n            }\\n            return ans+1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3339279,
                "title": "simple-solution-using-bfs-in-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nWe are just finding the distance of each node from source i.e \\'0\\'\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1) As it takes only 1 second to travel from one node to another it becomes a problem of finding distance of node with unit distance Unconnected Graph.\\n\\n2) Once you find the distance of each node then you can just need a litte mathematics to calculate that when the last packet will be released from all the node and add 2*(Distance of node)  and find maxumum of all possiblies.\\n\\n3) Add +1 to it and return the answer .\\n\\n4)Way to find the last message to be relased :-\\n\\nNumber of message relased(mess_count) = 2*(Distance of Node) / patience[i]\\nif patience[i] divides completely 2*(Distance of Node ) then one less message will be released as at that time the node will get the message back from source \\n\\nMaxm Time = 2*D+ mess_count*patience[i];\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(V+E) ---> Simple BFS followed by traversal of V-1 nodes;\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(V+E)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n//Time :-  2*D  + (2*D-1)\\n    int networkBecomesIdle(vector<vector<int>>& edges, vector<int>& p) {\\n        int n= p.size();\\n        int ans = 0;\\n        \\n        vector<vector<int>> adj(n);\\n        vector<int> dis(n ,-1);\\n        vector<bool> vis(n,false);\\n        queue<int> q;\\n        q.push(0);\\n        vis[0] =true;\\n        dis[0] = 0;\\n        \\n        for(int i =  0 ; i< edges.size() ;i++){\\n            adj[edges[i][0]].push_back(edges[i][1]);\\n            adj[edges[i][1]].push_back(edges[i][0]);\\n        }\\n        \\n        while(q.empty()!=true){\\n            int curr = q.front();\\n            \\n            for(auto v : adj[curr]){\\n                if(vis[v] == false){\\n                    dis[v] =dis[curr]+1;\\n                    vis[v]=true;\\n                    q.push(v);\\n                }\\n            }\\n            q.pop();\\n            \\n        }\\n        // for(int i = 0 ; )\\n\\n        //Time for 1st pack = 2*D\\n        //No pack left in that moment  = (2*D/p[i]+1)*2*D\\n        for(int  i = 1 ; i< n ;i++){\\n            //Time = 2*D + (2*D-1)\\n            int D= dis[i];\\n            int curr = 0;\\n            if(p[i] == 0) curr=(4*D-1);\\n            else{\\n                int num = (2*D)/p[i];\\n                // num--;\\n                 if((2*D) %p[i] == 0) num--;\\n                \\n                curr = p[i]*num + 2*D;\\n               \\n            }\\n            \\n            cout<<curr<<\" \"<<p[i]<<\" \"<<dis[i]<<endl;\\n         \\n            ans = max (ans ,curr);\\n        }\\n      \\n        \\n        return ans+1;\\n\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n//Time :-  2*D  + (2*D-1)\\n    int networkBecomesIdle(vector<vector<int>>& edges, vector<int>& p) {\\n        int n= p.size();\\n        int ans = 0;\\n        \\n        vector<vector<int>> adj(n);\\n        vector<int> dis(n ,-1);\\n        vector<bool> vis(n,false);\\n        queue<int> q;\\n        q.push(0);\\n        vis[0] =true;\\n        dis[0] = 0;\\n        \\n        for(int i =  0 ; i< edges.size() ;i++){\\n            adj[edges[i][0]].push_back(edges[i][1]);\\n            adj[edges[i][1]].push_back(edges[i][0]);\\n        }\\n        \\n        while(q.empty()!=true){\\n            int curr = q.front();\\n            \\n            for(auto v : adj[curr]){\\n                if(vis[v] == false){\\n                    dis[v] =dis[curr]+1;\\n                    vis[v]=true;\\n                    q.push(v);\\n                }\\n            }\\n            q.pop();\\n            \\n        }\\n        // for(int i = 0 ; )\\n\\n        //Time for 1st pack = 2*D\\n        //No pack left in that moment  = (2*D/p[i]+1)*2*D\\n        for(int  i = 1 ; i< n ;i++){\\n            //Time = 2*D + (2*D-1)\\n            int D= dis[i];\\n            int curr = 0;\\n            if(p[i] == 0) curr=(4*D-1);\\n            else{\\n                int num = (2*D)/p[i];\\n                // num--;\\n                 if((2*D) %p[i] == 0) num--;\\n                \\n                curr = p[i]*num + 2*D;\\n               \\n            }\\n            \\n            cout<<curr<<\" \"<<p[i]<<\" \"<<dis[i]<<endl;\\n         \\n            ans = max (ans ,curr);\\n        }\\n      \\n        \\n        return ans+1;\\n\\n\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2825278,
                "title": "c-constructive-approach-bfs-easyyyyyy",
                "content": "```\\n###################################### DON\\'T FORGET TO UPVOTE #######################################\\n\\nclass Solution {\\npublic:;\\n    typedef pair<int,int> p;\\n    \\n    int networkBecomesIdle(vector<vector<int>>& edges, vector<int>& patience) {\\n        \\n        //prepare adj list\\n        unordered_map<int,list<int>> adj;\\n        for(int i=0; i<edges.size(); i++)   {\\n            int u = edges[i][0];\\n            int v = edges[i][1];\\n            adj[u].push_back(v);\\n            adj[v].push_back(u);\\n        }\\n        \\n        \\n        //calculating the minimum distance vector for all node from source node\\n        int n = patience.size();\\n        vector<int> dist(n,1e9);\\n        priority_queue<p,vector<p>,greater<p>> pq;\\n        \\n        dist[0]=0;\\n        pq.push({0,0});\\n        \\n        while(!pq.empty())  {\\n            auto it = pq.top();\\n            pq.pop();\\n            int wt = it.first;\\n            int node = it.second;\\n            for(auto i:adj[node])   {\\n                int ch = 1+wt;\\n                if(ch<dist[i])  {\\n                    dist[i] = ch;\\n                    pq.push({ch,i});\\n                }\\n            }\\n        }\\n        \\n        \\n        //multiplying the dist vector by 2, cause its a two way trip\\n        for(int i=0; i<n; i++)  {\\n            dist[i] = dist[i]*2;\\n        }\\n        \\n        \\n        //calculating the largest time interval\\n        int var = 0;\\n        int mx = 0;\\n        for(int i=0; i<n; i++)  {\\n            mx = max(mx,dist[i]);\\n            if(dist[i]>patience[i]) {\\n                int p = patience[i];\\n                int d = dist[i];\\n                //find last occurence of multiple of p less than d\\n                //add d to it and +1.\\n                int last = d-1;\\n                while(last>=1)   {\\n                    if(last%p==0)\\n                        break;\\n                    last--;\\n                }\\n                int curr = last + d + 1;\\n                var = max(var,curr);\\n            }\\n        }\\n       \\n        return max(var,mx+1);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Math",
                    "Breadth-First Search",
                    "Graph",
                    "Shortest Path"
                ],
                "code": "```\\n###################################### DON\\'T FORGET TO UPVOTE #######################################\\n\\nclass Solution {\\npublic:;\\n    typedef pair<int,int> p;\\n    \\n    int networkBecomesIdle(vector<vector<int>>& edges, vector<int>& patience) {\\n        \\n        //prepare adj list\\n        unordered_map<int,list<int>> adj;\\n        for(int i=0; i<edges.size(); i++)   {\\n            int u = edges[i][0];\\n            int v = edges[i][1];\\n            adj[u].push_back(v);\\n            adj[v].push_back(u);\\n        }\\n        \\n        \\n        //calculating the minimum distance vector for all node from source node\\n        int n = patience.size();\\n        vector<int> dist(n,1e9);\\n        priority_queue<p,vector<p>,greater<p>> pq;\\n        \\n        dist[0]=0;\\n        pq.push({0,0});\\n        \\n        while(!pq.empty())  {\\n            auto it = pq.top();\\n            pq.pop();\\n            int wt = it.first;\\n            int node = it.second;\\n            for(auto i:adj[node])   {\\n                int ch = 1+wt;\\n                if(ch<dist[i])  {\\n                    dist[i] = ch;\\n                    pq.push({ch,i});\\n                }\\n            }\\n        }\\n        \\n        \\n        //multiplying the dist vector by 2, cause its a two way trip\\n        for(int i=0; i<n; i++)  {\\n            dist[i] = dist[i]*2;\\n        }\\n        \\n        \\n        //calculating the largest time interval\\n        int var = 0;\\n        int mx = 0;\\n        for(int i=0; i<n; i++)  {\\n            mx = max(mx,dist[i]);\\n            if(dist[i]>patience[i]) {\\n                int p = patience[i];\\n                int d = dist[i];\\n                //find last occurence of multiple of p less than d\\n                //add d to it and +1.\\n                int last = d-1;\\n                while(last>=1)   {\\n                    if(last%p==0)\\n                        break;\\n                    last--;\\n                }\\n                int curr = last + d + 1;\\n                var = max(var,curr);\\n            }\\n        }\\n       \\n        return max(var,mx+1);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2642342,
                "title": "c-runtime-81-93-faster-than-all-easy",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int networkBecomesIdle(vector<vector<int>>& edges, vector<int>& patience) {\\n        int n = patience.size();\\n        vector <vector <int>> graph(n);\\n        vector <int> time(n, -1);\\n        \\n        for(auto x: edges) {\\n            graph[x[0]].push_back(x[1]);\\n            graph[x[1]].push_back(x[0]);\\n        }\\n        \\n        queue <int> q;\\n        q.push(0);\\n        time[0] = 0;\\n        while(q.size()) {\\n            int node = q.front();\\n            q.pop();\\n            \\n            for(auto child: graph[node]) {\\n                if(time[child] == -1) { \\n                    time[child] = time[node] + 1; \\n                    q.push(child);\\n                }\\n            }\\n        }\\n        \\n        int res = 0;\\n        for(int i = 1; i<n; i++) {\\n            int extraPayload = (time[i]*2 - 1)/patience[i]; \\n\\t\\t\\t\\n            int lastOut = extraPayload * patience[i]; \\n            int lastIn = lastOut + time[i]*2; \\n\\t\\t\\t\\n            res = max(res, lastIn);\\n        }\\n                return res+1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int networkBecomesIdle(vector<vector<int>>& edges, vector<int>& patience) {\\n        int n = patience.size();\\n        vector <vector <int>> graph(n);\\n        vector <int> time(n, -1);\\n        \\n        for(auto x: edges) {\\n            graph[x[0]].push_back(x[1]);\\n            graph[x[1]].push_back(x[0]);\\n        }\\n        \\n        queue <int> q;\\n        q.push(0);\\n        time[0] = 0;\\n        while(q.size()) {\\n            int node = q.front();\\n            q.pop();\\n            \\n            for(auto child: graph[node]) {\\n                if(time[child] == -1) { \\n                    time[child] = time[node] + 1; \\n                    q.push(child);\\n                }\\n            }\\n        }\\n        \\n        int res = 0;\\n        for(int i = 1; i<n; i++) {\\n            int extraPayload = (time[i]*2 - 1)/patience[i]; \\n\\t\\t\\t\\n            int lastOut = extraPayload * patience[i]; \\n            int lastIn = lastOut + time[i]*2; \\n\\t\\t\\t\\n            res = max(res, lastIn);\\n        }\\n                return res+1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2549706,
                "title": "very-intuitive-and-basic-explained",
                "content": "this is a basic graph level order traversal question .... we get this intution by seeing that we need the smallest distance of the node from server , and all the nodes reachable from server in one move or who are at level 1 would have distance 1 and their message will take a total of 2 mins to reach back to them similarly for other level ..... so first thing that we can do is to populate a dist vector to keep nodes distance which is actually the level at which the node is present .... then we need to check in the time period when the first message of a node goes out and come back how many more messages would be sent , that is simple maths \\nno. of packets=(2*dist[i]-1)/(patience[i]);\\nnow we need to see the max time it will take for this node to get in idle state which is the time its last message takes to reach back to it....\\nstart time of last message = (no.of packets)*(patience[i]);\\nend time=start time+2*dist[i];\\njust do it for all and you get the ans;\\n//code\\n\\nclass Solution {\\npublic:\\n    void bfs(vector<int> adj[],int n,vector<int>& dist){\\n        vector<bool> vis(n,false);\\n       vis[0]=true;\\n        queue<int> q;\\n        q.push(0);\\n        int level=1;\\n        while(!q.empty()){\\n            int n=q.size();\\n            for(int i=0;i<n;i++){\\n                int a=q.front();\\n                q.pop();\\n                for(int j=0;j<adj[a].size();j++){\\n                    if(!vis[adj[a][j]]){\\n                        vis[adj[a][j]]=true;\\n                        dist[adj[a][j]]=level;\\n                        q.push(adj[a][j]);\\n                    }\\n                }\\n            }\\n            level++;\\n        }\\n        \\n    }\\n    int networkBecomesIdle(vector<vector<int>>& edges, vector<int>& pat) {\\n        int n=pat.size();\\n        vector<int> adj[n];\\n        for(int i=0;i<edges.size();i++){\\n            adj[edges[i][0]].push_back(edges[i][1]);\\n            adj[edges[i][1]].push_back(edges[i][0]);\\n        }\\n        vector<int> dist(n,0);\\n        bfs(adj,n,dist);\\n        int ans=INT_MIN;\\n        for(int i=1;i<n;i++){\\n            int pos=(2*dist[i]-1)/pat[i];\\n            int val=pos*(pat[i]);\\n            int final_val=val+2*dist[i];\\n            ans=max(ans,final_val);\\n        }\\n        return ans+1;\\n    }\\n};",
                "solutionTags": [
                    "C",
                    "Breadth-First Search"
                ],
                "code": "class Solution {\\npublic:\\n    void bfs(vector<int> adj[],int n,vector<int>& dist){\\n        vector<bool> vis(n,false);\\n       vis[0]=true;\\n        queue<int> q;\\n        q.push(0);\\n        int level=1;\\n        while(!q.empty()){\\n            int n=q.size();\\n            for(int i=0;i<n;i++){\\n                int a=q.front();\\n                q.pop();\\n                for(int j=0;j<adj[a].size();j++){\\n                    if(!vis[adj[a][j]]){\\n                        vis[adj[a][j]]=true;\\n                        dist[adj[a][j]]=level;\\n                        q.push(adj[a][j]);\\n                    }",
                "codeTag": "Java"
            },
            {
                "id": 2536225,
                "title": "c-dijkstras",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> dij(vector<int> adj[], int n){\\n        vector<int> dist_to(n, INT_MAX);\\n        dist_to[0] = 0;\\n        \\n        priority_queue<pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>>> pq;\\n        pq.push({0, 0});\\n        while(!pq.empty()){\\n            int v = pq.top().second;\\n            int d = pq.top().first;\\n            \\n            pq.pop();\\n            \\n            if(d != dist_to[v]) continue;\\n            \\n            for(auto child: adj[v]){\\n                if(dist_to[child] > dist_to[v] + 1){\\n                    dist_to[child] = dist_to[v] + 1;\\n                    pq.push({dist_to[child], child});\\n                }\\n            }\\n        }\\n        return dist_to;\\n    }\\n    int networkBecomesIdle(vector<vector<int>>& ed, vector<int>& pat) {\\n        int n = pat.size();\\n        vector<int> adj[n];\\n        for(auto it: ed){\\n            adj[it[0]].push_back(it[1]);\\n            adj[it[1]].push_back(it[0]);\\n        }\\n        \\n        vector<int> short_path = dij(adj, n);\\n        long maxi = INT_MIN;\\n        for(int i = 1; i < n; i++){\\n            long num = 2*(short_path[i]);\\n            long last_send_msg = num / pat[i];\\n            if(num % pat[i] == 0) last_send_msg--;\\n            long last_send_msg_time = last_send_msg * pat[i];\\n            \\n            long ans = last_send_msg_time + num + 1;\\n            \\n            maxi = max(maxi, ans);\\n        }\\n        return maxi;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> dij(vector<int> adj[], int n){\\n        vector<int> dist_to(n, INT_MAX);\\n        dist_to[0] = 0;\\n        \\n        priority_queue<pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>>> pq;\\n        pq.push({0, 0});\\n        while(!pq.empty()){\\n            int v = pq.top().second;\\n            int d = pq.top().first;\\n            \\n            pq.pop();\\n            \\n            if(d != dist_to[v]) continue;\\n            \\n            for(auto child: adj[v]){\\n                if(dist_to[child] > dist_to[v] + 1){\\n                    dist_to[child] = dist_to[v] + 1;\\n                    pq.push({dist_to[child], child});\\n                }\\n            }\\n        }\\n        return dist_to;\\n    }\\n    int networkBecomesIdle(vector<vector<int>>& ed, vector<int>& pat) {\\n        int n = pat.size();\\n        vector<int> adj[n];\\n        for(auto it: ed){\\n            adj[it[0]].push_back(it[1]);\\n            adj[it[1]].push_back(it[0]);\\n        }\\n        \\n        vector<int> short_path = dij(adj, n);\\n        long maxi = INT_MIN;\\n        for(int i = 1; i < n; i++){\\n            long num = 2*(short_path[i]);\\n            long last_send_msg = num / pat[i];\\n            if(num % pat[i] == 0) last_send_msg--;\\n            long last_send_msg_time = last_send_msg * pat[i];\\n            \\n            long ans = last_send_msg_time + num + 1;\\n            \\n            maxi = max(maxi, ans);\\n        }\\n        return maxi;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2526493,
                "title": "python-bfs-with-maths",
                "content": "Calculating shortest path for each node form 0.  from the time it takes to reach and return we can calculate the last time send the request before recieving a response. The network  will be idle when the last request return to the server.\\n```\\ndef networkBecomesIdle(self, edges: List[List[int]], patience: List[int]) -> int:\\n\\tgraph = defaultdict(list)\\n\\tlgth = len(patience)\\n\\tfor edge in edges:\\n\\t\\tgraph[edge[0]].append(edge[1])\\n\\t\\tgraph[edge[1]].append(edge[0])\\n\\n\\tmin_cost = [-1 for _ in range(lgth)]\\n\\tvisited = {0}\\n\\tqueue = deque([(0,0)])\\n\\n\\twhile queue:\\n\\t\\tcur,cst = queue.popleft()\\n\\t\\tmin_cost[cur] = 2*cst\\n\\n\\t\\tfor ngh in graph[cur]:\\n\\t\\t\\tif ngh not in visited:\\n\\t\\t\\t\\tvisited.add(ngh)\\n\\t\\t\\t\\tqueue.append((ngh,cst+1))\\n\\n\\tans = 0\\n\\tfor i in range(1,lgth): \\n\\t\\ttime = min_cost[i] - (min_cost[i] % patience[i]) if min_cost[i] % patience[i] > 0 else min_cost[i] - patience[i] \\n\\t\\tans = max(ans,time + min_cost[i])\\n\\treturn ans + 1\\n```\\n",
                "solutionTags": [
                    "Python",
                    "Math",
                    "Breadth-First Search"
                ],
                "code": "```\\ndef networkBecomesIdle(self, edges: List[List[int]], patience: List[int]) -> int:\\n\\tgraph = defaultdict(list)\\n\\tlgth = len(patience)\\n\\tfor edge in edges:\\n\\t\\tgraph[edge[0]].append(edge[1])\\n\\t\\tgraph[edge[1]].append(edge[0])\\n\\n\\tmin_cost = [-1 for _ in range(lgth)]\\n\\tvisited = {0}\\n\\tqueue = deque([(0,0)])\\n\\n\\twhile queue:\\n\\t\\tcur,cst = queue.popleft()\\n\\t\\tmin_cost[cur] = 2*cst\\n\\n\\t\\tfor ngh in graph[cur]:\\n\\t\\t\\tif ngh not in visited:\\n\\t\\t\\t\\tvisited.add(ngh)\\n\\t\\t\\t\\tqueue.append((ngh,cst+1))\\n\\n\\tans = 0\\n\\tfor i in range(1,lgth): \\n\\t\\ttime = min_cost[i] - (min_cost[i] % patience[i]) if min_cost[i] % patience[i] > 0 else min_cost[i] - patience[i] \\n\\t\\tans = max(ans,time + min_cost[i])\\n\\treturn ans + 1\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2526479,
                "title": "python-bfs-fast-and-very-easy-to-understand",
                "content": "The idea is very simple:\\n1. First we calculate the shortest latency ( amount of time it takes for a message to reach the master server plus the time it takes for a reply to reach back the server ) for every node.\\n2. Then from their patience time, we calculate for each node,  the last time it sends a message before it recieves a reply.\\n3. Finally our answer is the maximum of the time for each node from the time they send the first message to the time they recieve a reply for their last message\\n\\n```\\nclass Solution:\\n    def networkBecomesIdle(self, edges: List[List[int]], patience: List[int]) -> int:\\n        graph = defaultdict(set)\\n        for a, b in edges:\\n            graph[a].add(b)\\n            graph[b].add(a)\\n            \\n        dis = {}\\n        queue = deque([(0, 0)])\\n        visited = set([0])\\n        while queue:\\n            cur, length = queue.popleft()\\n            dis[cur] = length * 2\\n            for nxt in graph[cur]:\\n                if nxt not in visited:\\n                    queue.append((nxt, length + 1))\\n                    visited.add(nxt)\\n        \\n        ans = -float(\"inf\")\\n        for i in range(1, len(patience)):\\n            if patience[i] < dis[i]:\\n                rem = dis[i] % patience[i]\\n                lastCall = dis[i] - (rem) if rem > 0 else dis[i] - patience[i]\\n                ans = max(ans, lastCall + dis[i]) \\n            else:\\n                ans = max(ans, dis[i])\\n        return ans + 1\\n\\n# time and space complexity\\n# time: O(n + m)\\n# space: O(n)\\n# n = number of nodes\\n# m = len(edges)\\n            \\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Math",
                    "Breadth-First Search",
                    "Graph",
                    "Shortest Path"
                ],
                "code": "```\\nclass Solution:\\n    def networkBecomesIdle(self, edges: List[List[int]], patience: List[int]) -> int:\\n        graph = defaultdict(set)\\n        for a, b in edges:\\n            graph[a].add(b)\\n            graph[b].add(a)\\n            \\n        dis = {}\\n        queue = deque([(0, 0)])\\n        visited = set([0])\\n        while queue:\\n            cur, length = queue.popleft()\\n            dis[cur] = length * 2\\n            for nxt in graph[cur]:\\n                if nxt not in visited:\\n                    queue.append((nxt, length + 1))\\n                    visited.add(nxt)\\n        \\n        ans = -float(\"inf\")\\n        for i in range(1, len(patience)):\\n            if patience[i] < dis[i]:\\n                rem = dis[i] % patience[i]\\n                lastCall = dis[i] - (rem) if rem > 0 else dis[i] - patience[i]\\n                ans = max(ans, lastCall + dis[i]) \\n            else:\\n                ans = max(ans, dis[i])\\n        return ans + 1\\n\\n# time and space complexity\\n# time: O(n + m)\\n# space: O(n)\\n# n = number of nodes\\n# m = len(edges)\\n            \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2385585,
                "title": "c-bfs-shortest-time-from-server-node",
                "content": "**PLEASE UPVOTE IF U FIND MY SOLUTION HELPFUL :)**\\n\\n```\\nclass Solution {\\npublic:\\n    int networkBecomesIdle(vector<vector<int>>& edges, vector<int>& patience) \\n    {\\n        int n=patience.size();\\n        \\n        vector<int>max_time(n,1e9);\\n        max_time[0]=0;\\n        \\n        queue<int>q;\\n        q.push(0);\\n        \\n        vector<vector<int>>network(n);\\n        \\n        for(auto &e:edges)\\n        {\\n            network[e[0]].push_back(e[1]);\\n            network[e[1]].push_back(e[0]);\\n        }\\n        \\n        while(!q.empty())\\n        {\\n            int node=q.front();q.pop();\\n            \\n            for(auto &nbr:network[node])\\n            {\\n                if(max_time[nbr]>max_time[node]+1)\\n                {\\n                    max_time[nbr]=max_time[node]+1;\\n                    q.push(nbr);\\n                }\\n            }\\n        }\\n        \\n        int max_active_time=0;\\n        for(int i=1;i<n;i++)\\n        {\\n            if(patience[i]>=2*max_time[i])\\n            {\\n                max_active_time=max(max_active_time,2*max_time[i]);\\n            }\\n            else\\n            {\\n                int packets=(2*max_time[i]-1)/patience[i]+1;\\n              \\n                int last_packet_dept=(packets-1)*patience[i];\\n                \\n                int position_of_last_packet=2*max_time[i]-last_packet_dept;\\n                \\n                int total_time=2*max_time[i]+(2*max_time[i]-position_of_last_packet);\\n                \\n                max_active_time=max(max_active_time,total_time);\\n            }\\n        }\\n        \\n        return max_active_time+1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int networkBecomesIdle(vector<vector<int>>& edges, vector<int>& patience) \\n    {\\n        int n=patience.size();\\n        \\n        vector<int>max_time(n,1e9);\\n        max_time[0]=0;\\n        \\n        queue<int>q;\\n        q.push(0);\\n        \\n        vector<vector<int>>network(n);\\n        \\n        for(auto &e:edges)\\n        {\\n            network[e[0]].push_back(e[1]);\\n            network[e[1]].push_back(e[0]);\\n        }\\n        \\n        while(!q.empty())\\n        {\\n            int node=q.front();q.pop();\\n            \\n            for(auto &nbr:network[node])\\n            {\\n                if(max_time[nbr]>max_time[node]+1)\\n                {\\n                    max_time[nbr]=max_time[node]+1;\\n                    q.push(nbr);\\n                }\\n            }\\n        }\\n        \\n        int max_active_time=0;\\n        for(int i=1;i<n;i++)\\n        {\\n            if(patience[i]>=2*max_time[i])\\n            {\\n                max_active_time=max(max_active_time,2*max_time[i]);\\n            }\\n            else\\n            {\\n                int packets=(2*max_time[i]-1)/patience[i]+1;\\n              \\n                int last_packet_dept=(packets-1)*patience[i];\\n                \\n                int position_of_last_packet=2*max_time[i]-last_packet_dept;\\n                \\n                int total_time=2*max_time[i]+(2*max_time[i]-position_of_last_packet);\\n                \\n                max_active_time=max(max_active_time,total_time);\\n            }\\n        }\\n        \\n        return max_active_time+1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2296660,
                "title": "bfs-solution-with-comments-c",
                "content": "\\n\\n    int networkBecomesIdle(vector<vector<int>>& edges, vector<int>& patience) {\\n        int n = patience.size();\\n        if(n == 0) return 0;\\n\\t\\t\\n        // create adjacency matrix for graph:\\n        vector<vector<int>> adj(n);\\n        for(auto it : edges){\\n            int u = it[0];\\n            int v = it[1];\\n            adj[u].push_back(v);\\n            adj[v].push_back(u);\\n        }\\n        \\n        // time[i] represents how much time it will take to get the response for single request:\\n        vector<int> time(n, 0); \\n        \\n        // using BFS to get the time when every sever will get their first response:\\n        queue<int> q;\\n        vector<int> visited(n, 0);\\n        q.push(0);\\n        time[0] = 0;\\n        visited[0] = 1;\\n        \\n        while(!q.empty()){\\n            int u = q.front();\\n            q.pop();\\n            \\n            for(auto it : adj[u]){\\n                if(!visited[it]){\\n                    visited[it] = 1;\\n                    time[it] = time[u] + 1;\\n                    q.push(it);\\n                }\\n            }\\n        }\\n        \\n        // multiply by 2 as there will time is total of send time and recieve time:\\n        // also find the max_time incase if the response time of all servers is higher than the time in which they recieve their first respose, we \\n\\t\\t// take that time as our answer.\\n        int max_time = 0;\\n        for(int i = 0; i < n; i++){\\n            time[i] = 2 * time[i];\\n            max_time = max(time[i], max_time);\\n        } \\n        \\n        // get the server which will recieve the last response:\\n        for(int i = 0; i < n; i++){\\n            if(time[i] > patience[i]){\\n                // calculate the time when the server will send its last message -> there can be two cases.\\n                int last_msg_send_time;\\n                if(time[i] % patience[i] == 0) last_msg_send_time = time[i] - patience[i];\\n                else{\\n                    int x = time[i] / patience[i];\\n                    last_msg_send_time = x * patience[i];\\n                }\\n                \\n                // find time when that server will recieve its last message:\\n                int last_msg_recieve_time = last_msg_send_time + time[i];\\n                max_time = max(last_msg_recieve_time, max_time);\\n            }\\n        }\\n    \\n        return max_time + 1;\\n    }",
                "solutionTags": [
                    "C",
                    "Breadth-First Search"
                ],
                "code": "\\n\\n    int networkBecomesIdle(vector<vector<int>>& edges, vector<int>& patience) {\\n        int n = patience.size();\\n        if(n == 0) return 0;\\n\\t\\t\\n        // create adjacency matrix for graph:\\n        vector<vector<int>> adj(n);\\n        for(auto it : edges){\\n            int u = it[0];\\n            int v = it[1];\\n            adj[u].push_back(v);\\n            adj[v].push_back(u);\\n        }\\n        \\n        // time[i] represents how much time it will take to get the response for single request:\\n        vector<int> time(n, 0); \\n        \\n        // using BFS to get the time when every sever will get their first response:\\n        queue<int> q;\\n        vector<int> visited(n, 0);\\n        q.push(0);\\n        time[0] = 0;\\n        visited[0] = 1;\\n        \\n        while(!q.empty()){\\n            int u = q.front();\\n            q.pop();\\n            \\n            for(auto it : adj[u]){\\n                if(!visited[it]){\\n                    visited[it] = 1;\\n                    time[it] = time[u] + 1;\\n                    q.push(it);\\n                }\\n            }\\n        }\\n        \\n        // multiply by 2 as there will time is total of send time and recieve time:\\n        // also find the max_time incase if the response time of all servers is higher than the time in which they recieve their first respose, we \\n\\t\\t// take that time as our answer.\\n        int max_time = 0;\\n        for(int i = 0; i < n; i++){\\n            time[i] = 2 * time[i];\\n            max_time = max(time[i], max_time);\\n        } \\n        \\n        // get the server which will recieve the last response:\\n        for(int i = 0; i < n; i++){\\n            if(time[i] > patience[i]){\\n                // calculate the time when the server will send its last message -> there can be two cases.\\n                int last_msg_send_time;\\n                if(time[i] % patience[i] == 0) last_msg_send_time = time[i] - patience[i];\\n                else{\\n                    int x = time[i] / patience[i];\\n                    last_msg_send_time = x * patience[i];\\n                }\\n                \\n                // find time when that server will recieve its last message:\\n                int last_msg_recieve_time = last_msg_send_time + time[i];\\n                max_time = max(last_msg_recieve_time, max_time);\\n            }\\n        }\\n    \\n        return max_time + 1;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 2150364,
                "title": "c-bfs-easy",
                "content": "{{{\\n\\nclass Solution {\\npublic:\\n    void dfs(int i,vector<vector<int>>&graph,vector<int>&tmp)\\n    {\\n        queue<pair<int,int>>qmt;\\n        qmt.push({0,0});\\n        tmp[0]=0;\\n        while(qmt.size()>0)\\n        {\\n            pair<int,int>p=qmt.front();\\n            qmt.pop();\\n            int nd=p.first;\\n            int cnt=p.second;\\n            for(auto&p:graph[nd])\\n            {\\n                if(tmp[p]==-1)\\n                {\\n                    tmp[p]=1+cnt;\\n                    qmt.push({p,tmp[p]});\\n                }\\n            }\\n        }\\n    }\\n    int networkBecomesIdle(vector<vector<int>>& edges, vector<int>& patience) {\\n        int n=patience.size();\\n        vector<vector<int>>graph(n,vector<int>());\\n        for(auto&p:edges)\\n        {\\n            graph[p[0]].push_back(p[1]);\\n            graph[p[1]].push_back(p[0]);\\n        }\\n        vector<int>tmp(n,-1);\\n        dfs(0,graph,tmp);\\n        int ans=0;\\n        for(int i=1;i<n;i++)\\n        {\\n            int tme=2*tmp[i];\\n            if(tme<=patience[i])ans=max(ans,tme+1);\\n            else\\n            {\\n                int lst=(tme/patience[i])*patience[i];\\n                if(lst==tme)lst-=patience[i];\\n                ans=max(ans,(lst)+tme+1);\\n               // cout<<lst+tme+1<<\"\\\\n\";\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n}}}",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    void dfs(int i,vector<vector<int>>&graph,vector<int>&tmp)\\n    {\\n        queue<pair<int,int>>qmt;\\n        qmt.push({0,0}",
                "codeTag": "Java"
            },
            {
                "id": 2116004,
                "title": "bfs-simple-logic-c-time-o-n-m-space-o-n-m",
                "content": "```\\nclass Solution {\\npublic:\\n    int networkBecomesIdle(vector<vector<int>>& edges, vector<int>& patience) {\\n        int n = patience.size();\\n        vector<vector<int>> adjList(n);\\n        vector<int> visited(n,0);\\n        for(auto x: edges){\\n            adjList[x[0]].push_back(x[1]);\\n            adjList[x[1]].push_back(x[0]);\\n        }\\n        \\n        vector<int> minDistance(n,INT_MAX);\\n        queue<int> q;\\n        q.push(0);\\n        int level = 0;\\n        while(!q.empty()){\\n            \\n            for(int i = q.size()-1;i>=0;i--){\\n                int x = q.front();\\n                q.pop();\\n                visited[x] = 1;\\n                minDistance[x] = level;\\n                \\n                for(int j=0;j<adjList[x].size();j++){\\n                    if(visited[adjList[x][j]] == 0 ){\\n                        q.push(adjList[x][j]);\\n                        visited[adjList[x][j]] = 1;\\n                    }\\n                }\\n            }\\n            level++;\\n        }\\n    \\n        int max = INT_MIN;\\n        for(int i = 1;i<n;i++){\\n            int totalDistance = minDistance[i]*2;\\n            int noOfMessages = 1 + (totalDistance-1)/patience[i];\\n            int LastMessageSentTime = (noOfMessages-1)*patience[i];\\n            int timeForThisNode = LastMessageSentTime+totalDistance;\\n            if(timeForThisNode > max) max = timeForThisNode;\\n        }\\n        \\n        return max+1;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int networkBecomesIdle(vector<vector<int>>& edges, vector<int>& patience) {\\n        int n = patience.size();\\n        vector<vector<int>> adjList(n);\\n        vector<int> visited(n,0);\\n        for(auto x: edges){\\n            adjList[x[0]].push_back(x[1]);\\n            adjList[x[1]].push_back(x[0]);\\n        }\\n        \\n        vector<int> minDistance(n,INT_MAX);\\n        queue<int> q;\\n        q.push(0);\\n        int level = 0;\\n        while(!q.empty()){\\n            \\n            for(int i = q.size()-1;i>=0;i--){\\n                int x = q.front();\\n                q.pop();\\n                visited[x] = 1;\\n                minDistance[x] = level;\\n                \\n                for(int j=0;j<adjList[x].size();j++){\\n                    if(visited[adjList[x][j]] == 0 ){\\n                        q.push(adjList[x][j]);\\n                        visited[adjList[x][j]] = 1;\\n                    }\\n                }\\n            }\\n            level++;\\n        }\\n    \\n        int max = INT_MIN;\\n        for(int i = 1;i<n;i++){\\n            int totalDistance = minDistance[i]*2;\\n            int noOfMessages = 1 + (totalDistance-1)/patience[i];\\n            int LastMessageSentTime = (noOfMessages-1)*patience[i];\\n            int timeForThisNode = LastMessageSentTime+totalDistance;\\n            if(timeForThisNode > max) max = timeForThisNode;\\n        }\\n        \\n        return max+1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2046147,
                "title": "python-easy-optimal-time-and-space-bfs-dijkstras",
                "content": "Time - O(N + ElogN)\\nSpace - O(N + E)\\n\\nwhere:\\nN - number of servers in network\\nE - number of edges\\n\\nThis solution finds the shortest path between server 0 and all servers. Then with the patience[server], it calculates the last time the server would have sent a new message to server zero, whilst keeping track of the max_time taken for all servers.\\n```\\nclass Solution:\\n    def networkBecomesIdle(self, edges: List[List[int]], patience: List[int]) -> int:\\n        visited = {0}\\n        graph = defaultdict(list)\\n\\t\\t# build graph\\n        for u, v in edges:\\n            graph[u].append(v)\\n            graph[v].append(u)\\n            \\n        min_heap = [(1, 0)]\\n        max_wait = 0\\n        while min_heap and len(visited) < len(patience):\\n            signal_time, node = heapq.heappop(min_heap)\\n            for neighbour in graph[node]:\\n                if neighbour not in visited:\\n                    visited.add(neighbour)\\n                    heapq.heappush(min_heap, (signal_time + 1, neighbour))\\n                    \\n\\t\\t\\t\\t\\t# round trip duration\\n                    latency = signal_time * 2\\n                    p = patience[neighbour]\\n                    \\n\\t\\t\\t\\t\\t# at least one addtional message has been sent by server\\n                    if latency > p:\\n                        last_message_sent = p * ((latency - 1) // p)\\n                        latency += last_message_sent\\n                    max_wait = max(max_wait, latency + 1)\\n                    \\n        return max_wait\\n```\\n",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def networkBecomesIdle(self, edges: List[List[int]], patience: List[int]) -> int:\\n        visited = {0}\\n        graph = defaultdict(list)\\n\\t\\t# build graph\\n        for u, v in edges:\\n            graph[u].append(v)\\n            graph[v].append(u)\\n            \\n        min_heap = [(1, 0)]\\n        max_wait = 0\\n        while min_heap and len(visited) < len(patience):\\n            signal_time, node = heapq.heappop(min_heap)\\n            for neighbour in graph[node]:\\n                if neighbour not in visited:\\n                    visited.add(neighbour)\\n                    heapq.heappush(min_heap, (signal_time + 1, neighbour))\\n                    \\n\\t\\t\\t\\t\\t# round trip duration\\n                    latency = signal_time * 2\\n                    p = patience[neighbour]\\n                    \\n\\t\\t\\t\\t\\t# at least one addtional message has been sent by server\\n                    if latency > p:\\n                        last_message_sent = p * ((latency - 1) // p)\\n                        latency += last_message_sent\\n                    max_wait = max(max_wait, latency + 1)\\n                    \\n        return max_wait\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2005758,
                "title": "c-bfs",
                "content": "```\\npublic:\\n    int networkBecomesIdle(vector<vector<int>>& edges, vector<int>& patience) {\\n        int n = patience.size();\\n        vector<int> dist(n, 0);\\n        vector<int> edgeList[n];\\n        vector<int> visited(n, false);\\n        for (auto edge: edges) {\\n            edgeList[edge[0]].push_back(edge[1]);\\n            edgeList[edge[1]].push_back(edge[0]);\\n        }\\n        queue<int> q;\\n        q.push(0);\\n        q.push(-1);\\n        int curDist = 0;\\n        while (!q.empty()) {\\n            int cur = q.front();\\n            q.pop();\\n            if (cur == -1) {\\n                if (!q.empty()) {\\n                    curDist++;\\n                    q.push(-1);\\n                    continue;\\n                }\\n                break;\\n            }\\n            if (visited[cur]) continue;\\n            visited[cur] = true;\\n            dist[cur] = curDist;\\n            for (int neighbour : edgeList[cur]) {\\n                    q.push(neighbour);\\n            }\\n        }\\n        int max = INT_MIN;\\n        for (int i = 1; i < n; i++) {\\n            int tat = 2 * dist[i];\\n            int pat = patience[i];\\n            int totalTime =0;\\n            if (tat < pat) totalTime = tat;\\n            else {\\n                totalTime = (tat % pat == 0) ? (tat/pat - 1)*pat + tat : (tat/pat)*pat + tat;\\n            }\\n            max = (totalTime > max ) ? totalTime : max;\\n        }\\n        return max + 1;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\npublic:\\n    int networkBecomesIdle(vector<vector<int>>& edges, vector<int>& patience) {\\n        int n = patience.size();\\n        vector<int> dist(n, 0);\\n        vector<int> edgeList[n];\\n        vector<int> visited(n, false);\\n        for (auto edge: edges) {\\n            edgeList[edge[0]].push_back(edge[1]);\\n            edgeList[edge[1]].push_back(edge[0]);\\n        }\\n        queue<int> q;\\n        q.push(0);\\n        q.push(-1);\\n        int curDist = 0;\\n        while (!q.empty()) {\\n            int cur = q.front();\\n            q.pop();\\n            if (cur == -1) {\\n                if (!q.empty()) {\\n                    curDist++;\\n                    q.push(-1);\\n                    continue;\\n                }\\n                break;\\n            }\\n            if (visited[cur]) continue;\\n            visited[cur] = true;\\n            dist[cur] = curDist;\\n            for (int neighbour : edgeList[cur]) {\\n                    q.push(neighbour);\\n            }\\n        }\\n        int max = INT_MIN;\\n        for (int i = 1; i < n; i++) {\\n            int tat = 2 * dist[i];\\n            int pat = patience[i];\\n            int totalTime =0;\\n            if (tat < pat) totalTime = tat;\\n            else {\\n                totalTime = (tat % pat == 0) ? (tat/pat - 1)*pat + tat : (tat/pat)*pat + tat;\\n            }\\n            max = (totalTime > max ) ? totalTime : max;\\n        }\\n        return max + 1;\\n    }\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1884599,
                "title": "c-clean-code-bfs",
                "content": "```\\nclass Solution {\\npublic:\\n    int networkBecomesIdle(vector<vector<int>>& edges, vector<int>& patience) {\\n        \\n        int n = patience.size();\\n        vector<vector<int>> adj(n);\\n        \\n        for(vector<int> &v : edges){\\n            \\n            adj[v[0]].push_back(v[1]);\\n            adj[v[1]].push_back(v[0]);\\n        }\\n        \\n        vector<int> distFromMasterServer(n);\\n        \\n        vector<bool> visited(n,false);\\n        \\n        queue<int> q;\\n        q.push(0);\\n        q.push(-1);\\n        \\n        visited[0] = true;\\n        int dist = 0;\\n        while(!q.empty()){\\n            \\n            int curr = q.front(); q.pop();\\n            \\n            if(curr == -1){\\n                \\n                if(!q.empty())\\n                    q.push(-1);\\n                \\n                dist++;\\n             \\n                continue;\\n            }\\n            \\n            \\n            distFromMasterServer[curr] = dist;\\n            \\n            for(int u : adj[curr]){\\n                if(!visited[u]){\\n                    visited[u] = true;\\n                     q.push(u);\\n                }\\n                   \\n            }\\n        }\\n        \\n        int ans = 0;\\n        \\n        for(int i = 1; i < patience.size(); i++){\\n            \\n            int timeOfFirstResponse = distFromMasterServer[i]*2;\\n            \\n            if(timeOfFirstResponse <= patience[i]){\\n                ans = max(ans, timeOfFirstResponse);\\n                \\n            }\\n            \\n            else{\\n                \\n                int countOfExtraRequest = timeOfFirstResponse/ patience[i];\\n                \\n                if(timeOfFirstResponse % patience[i] == 0)\\n                    countOfExtraRequest--;\\n                \\n                int timeOfLastRequest = countOfExtraRequest * patience[i];\\n                \\n                int timeOfLastResponse = timeOfLastRequest + distFromMasterServer[i]*2;\\n                \\n                ans = max(ans, timeOfLastResponse);\\n            }\\n        }\\n        \\n        //answer would be the beginning of the second at which network becomes idle\\n        //so add 1 to the ans\\n        \\n        return ans + 1;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int networkBecomesIdle(vector<vector<int>>& edges, vector<int>& patience) {\\n        \\n        int n = patience.size();\\n        vector<vector<int>> adj(n);\\n        \\n        for(vector<int> &v : edges){\\n            \\n            adj[v[0]].push_back(v[1]);\\n            adj[v[1]].push_back(v[0]);\\n        }\\n        \\n        vector<int> distFromMasterServer(n);\\n        \\n        vector<bool> visited(n,false);\\n        \\n        queue<int> q;\\n        q.push(0);\\n        q.push(-1);\\n        \\n        visited[0] = true;\\n        int dist = 0;\\n        while(!q.empty()){\\n            \\n            int curr = q.front(); q.pop();\\n            \\n            if(curr == -1){\\n                \\n                if(!q.empty())\\n                    q.push(-1);\\n                \\n                dist++;\\n             \\n                continue;\\n            }\\n            \\n            \\n            distFromMasterServer[curr] = dist;\\n            \\n            for(int u : adj[curr]){\\n                if(!visited[u]){\\n                    visited[u] = true;\\n                     q.push(u);\\n                }\\n                   \\n            }\\n        }\\n        \\n        int ans = 0;\\n        \\n        for(int i = 1; i < patience.size(); i++){\\n            \\n            int timeOfFirstResponse = distFromMasterServer[i]*2;\\n            \\n            if(timeOfFirstResponse <= patience[i]){\\n                ans = max(ans, timeOfFirstResponse);\\n                \\n            }\\n            \\n            else{\\n                \\n                int countOfExtraRequest = timeOfFirstResponse/ patience[i];\\n                \\n                if(timeOfFirstResponse % patience[i] == 0)\\n                    countOfExtraRequest--;\\n                \\n                int timeOfLastRequest = countOfExtraRequest * patience[i];\\n                \\n                int timeOfLastResponse = timeOfLastRequest + distFromMasterServer[i]*2;\\n                \\n                ans = max(ans, timeOfLastResponse);\\n            }\\n        }\\n        \\n        //answer would be the beginning of the second at which network becomes idle\\n        //so add 1 to the ans\\n        \\n        return ans + 1;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1793820,
                "title": "bfs-formulation",
                "content": "```\\n\\nclass Solution {\\npublic:\\n    int networkBecomesIdle(vector<vector<int>>& edges, vector<int>& patience) {\\n        int n = patience.size();\\n        vector<vector<int>> adj(n);\\n        for (auto it:edges){\\n            adj[it[0]].push_back(it[1]);\\n            adj[it[1]].push_back(it[0]);\\n            \\n        }\\n       //har server ko 0 tak reach k lie kitna time lgega fr a particular message;\\n        vector<int> time(n,-1);\\n        queue<int> q;\\n        q.push(0);\\n        time[0] = 0;\\n        while(!q.empty()){\\n            int size = q.size();\\n                int node = q.front();\\n                q.pop();\\n                for (auto it:adj[node]){\\n                    if (time[it]==-1){\\n                        time[it] = time[node]+1;\\n                        q.push(it);\\n                    }\\n            }\\n        }\\n        \\n        int ans = 0;\\n        for(int i=1; i<n;i++) {\\n            int traveltime = 2 * time[i];\\n            int extratime = (traveltime-1) / patience[i];\\n            int rem = traveltime - (extratime*patience[i] +1);\\n            traveltime = 2*traveltime - rem;\\n            ans = max(ans, traveltime);\\n        }\\n        \\n        return ans;\\n        \\n        \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n\\nclass Solution {\\npublic:\\n    int networkBecomesIdle(vector<vector<int>>& edges, vector<int>& patience) {\\n        int n = patience.size();\\n        vector<vector<int>> adj(n);\\n        for (auto it:edges){\\n            adj[it[0]].push_back(it[1]);\\n            adj[it[1]].push_back(it[0]);\\n            \\n        }\\n       //har server ko 0 tak reach k lie kitna time lgega fr a particular message;\\n        vector<int> time(n,-1);\\n        queue<int> q;\\n        q.push(0);\\n        time[0] = 0;\\n        while(!q.empty()){\\n            int size = q.size();\\n                int node = q.front();\\n                q.pop();\\n                for (auto it:adj[node]){\\n                    if (time[it]==-1){\\n                        time[it] = time[node]+1;\\n                        q.push(it);\\n                    }\\n            }\\n        }\\n        \\n        int ans = 0;\\n        for(int i=1; i<n;i++) {\\n            int traveltime = 2 * time[i];\\n            int extratime = (traveltime-1) / patience[i];\\n            int rem = traveltime - (extratime*patience[i] +1);\\n            traveltime = 2*traveltime - rem;\\n            ans = max(ans, traveltime);\\n        }\\n        \\n        return ans;\\n        \\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1748127,
                "title": "c-simple-bfs",
                "content": "Calculate idleTime for each node, and get maximum of these.\\n```\\nclass Solution\\n{\\n    public:\\n    int bfs(unordered_map<int,vector<int>>& graph, int n, vector<int>& patience)\\n    {\\n        queue<int>Q;\\n        Q.push(0);\\n        \\n        vector<int>time(n,INT_MAX);\\n        time[0]=0;\\n        \\n        int idle=INT_MIN,idleTime;\\n        while(!Q.empty())\\n        {\\n            int u=Q.front();\\n            Q.pop();\\n            \\n            for(auto v:graph[u])\\n            {\\n                if(1+time[u]<time[v])\\n                {\\n                    time[v]=time[u]+1;\\n                    idleTime=(2*time[v])+patience[v]*((2*time[v]-1)/patience[v]);\\n                    idle=max(idle,idleTime);\\n                    Q.push(v);\\n                }\\n            }\\n        }\\n        \\n        return idle;\\n    }\\n    int networkBecomesIdle(vector<vector<int>>& edges, vector<int>& patience)\\n    {\\n        int n=patience.size();\\n        \\n        unordered_map<int,vector<int>>graph;\\n        for(auto edge:edges)\\n        {\\n            graph[edge[0]].push_back(edge[1]);\\n            graph[edge[1]].push_back(edge[0]);\\n        }\\n        \\n        int idle=bfs(graph,n,patience);\\n        return idle+1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution\\n{\\n    public:\\n    int bfs(unordered_map<int,vector<int>>& graph, int n, vector<int>& patience)\\n    {\\n        queue<int>Q;\\n        Q.push(0);\\n        \\n        vector<int>time(n,INT_MAX);\\n        time[0]=0;\\n        \\n        int idle=INT_MIN,idleTime;\\n        while(!Q.empty())\\n        {\\n            int u=Q.front();\\n            Q.pop();\\n            \\n            for(auto v:graph[u])\\n            {\\n                if(1+time[u]<time[v])\\n                {\\n                    time[v]=time[u]+1;\\n                    idleTime=(2*time[v])+patience[v]*((2*time[v]-1)/patience[v]);\\n                    idle=max(idle,idleTime);\\n                    Q.push(v);\\n                }\\n            }\\n        }\\n        \\n        return idle;\\n    }\\n    int networkBecomesIdle(vector<vector<int>>& edges, vector<int>& patience)\\n    {\\n        int n=patience.size();\\n        \\n        unordered_map<int,vector<int>>graph;\\n        for(auto edge:edges)\\n        {\\n            graph[edge[0]].push_back(edge[1]);\\n            graph[edge[1]].push_back(edge[0]);\\n        }\\n        \\n        int idle=bfs(graph,n,patience);\\n        return idle+1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1686676,
                "title": "the-time-when-the-network-becomes-idle-c-sssp-maths",
                "content": "```\\nclass Solution {\\npublic:\\n    int networkBecomesIdle(vector<vector<int>>& edges, vector<int>& p) {\\n        int n = p.size();\\n        vector<int> G[n], dist(n, INT_MAX);\\n        for(auto& edge : edges){\\n            G[edge[0]].push_back(edge[1]);\\n            G[edge[1]].push_back(edge[0]);\\n        }\\n        dist[0] = 0;\\n        queue<int> q{{0}};\\n        while(!q.empty()){\\n            int node = q.front(); q.pop();\\n            \\n            for(auto& nei : G[node]){\\n                if(dist[nei] > dist[node] + 1){\\n                    dist[nei] = dist[node] + 1;\\n                    q.push(nei);\\n                }\\n            }\\n        }\\n        \\n        int ans = 0;\\n        for(int i = 1; i < n; i++){\\n            int extra = (2 * dist[i] - 1) / p[i]; // extra messages\\n            ans = max(ans, extra * p[i] + 2 * dist[i] + 1); // last message time + travel time + 1\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Math",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int networkBecomesIdle(vector<vector<int>>& edges, vector<int>& p) {\\n        int n = p.size();\\n        vector<int> G[n], dist(n, INT_MAX);\\n        for(auto& edge : edges){\\n            G[edge[0]].push_back(edge[1]);\\n            G[edge[1]].push_back(edge[0]);\\n        }\\n        dist[0] = 0;\\n        queue<int> q{{0}};\\n        while(!q.empty()){\\n            int node = q.front(); q.pop();\\n            \\n            for(auto& nei : G[node]){\\n                if(dist[nei] > dist[node] + 1){\\n                    dist[nei] = dist[node] + 1;\\n                    q.push(nei);\\n                }\\n            }\\n        }\\n        \\n        int ans = 0;\\n        for(int i = 1; i < n; i++){\\n            int extra = (2 * dist[i] - 1) / p[i]; // extra messages\\n            ans = max(ans, extra * p[i] + 2 * dist[i] + 1); // last message time + travel time + 1\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1668391,
                "title": "python-bfs-20-line-code-20-line-explanation",
                "content": "```python\\nfrom collections import defaultdict, deque\\nimport math\\n\\nclass Solution:\\n    def networkBecomesIdle(self, edges: List[List[int]], patience: List[int]) -> int:\\n        # any node will receive reply in 2*D where D is the shortest path\\n        # from 0 to that node\\n        # so if the patience of a node < 2*D, it will send new messages\\n        # at every patience interval until 2*D - 1\\n        #\\n        # e.g. if D=2, P=1 then:\\n        # reply time = 4\\n        # message is sent at 0, 1, 2, 3\\n        # m0 is received at 4\\n        # m1 is received at 5\\n        # m2 is received at 6\\n        # m3 is received at 7\\n        #\\n        # the network idle time is the maximum idle time of all servers\\n        # the idle time of a data server is the time it take to receive\\n        # its last message, which is dependent only on Di and Pi\\n        #\\n        # the idle time of a node = time at which it sent the last message + 2D\\n        # time of last message = floor(2D-1/P)*P\\n        # so idle time of node = floor(2D-1/P)*P + 2D\\n        #\\n        # simply find D for all nodes\\n        # i.e. single source shortest path in an unweighted graph (simple BFS)\\n           \\n        adjList = defaultdict(set)\\n        for edge in edges:\\n            a, b = edge\\n            adjList[a].add(b)\\n            adjList[b].add(a)\\n            \\n        q = deque()\\n        q.append((0, 0))\\n        distances = {0: 0}\\n        max_idle_time = -math.inf\\n        \\n        while q:\\n            a, d = q.popleft()\\n            for b in adjList[a]:\\n                if b not in distances:\\n                    D = d+1\\n                    P = patience[b]\\n                    q.append((b, D))\\n                    distances[b] = D\\n                    idle_time =  math.floor(((2*D)-1)/P)*P + 2*D\\n                    max_idle_time = max(max_idle_time, idle_time)\\n                    \\n        return max_idle_time+1\\n```",
                "solutionTags": [],
                "code": "```python\\nfrom collections import defaultdict, deque\\nimport math\\n\\nclass Solution:\\n    def networkBecomesIdle(self, edges: List[List[int]], patience: List[int]) -> int:\\n        # any node will receive reply in 2*D where D is the shortest path\\n        # from 0 to that node\\n        # so if the patience of a node < 2*D, it will send new messages\\n        # at every patience interval until 2*D - 1\\n        #\\n        # e.g. if D=2, P=1 then:\\n        # reply time = 4\\n        # message is sent at 0, 1, 2, 3\\n        # m0 is received at 4\\n        # m1 is received at 5\\n        # m2 is received at 6\\n        # m3 is received at 7\\n        #\\n        # the network idle time is the maximum idle time of all servers\\n        # the idle time of a data server is the time it take to receive\\n        # its last message, which is dependent only on Di and Pi\\n        #\\n        # the idle time of a node = time at which it sent the last message + 2D\\n        # time of last message = floor(2D-1/P)*P\\n        # so idle time of node = floor(2D-1/P)*P + 2D\\n        #\\n        # simply find D for all nodes\\n        # i.e. single source shortest path in an unweighted graph (simple BFS)\\n           \\n        adjList = defaultdict(set)\\n        for edge in edges:\\n            a, b = edge\\n            adjList[a].add(b)\\n            adjList[b].add(a)\\n            \\n        q = deque()\\n        q.append((0, 0))\\n        distances = {0: 0}\\n        max_idle_time = -math.inf\\n        \\n        while q:\\n            a, d = q.popleft()\\n            for b in adjList[a]:\\n                if b not in distances:\\n                    D = d+1\\n                    P = patience[b]\\n                    q.append((b, D))\\n                    distances[b] = D\\n                    idle_time =  math.floor(((2*D)-1)/P)*P + 2*D\\n                    max_idle_time = max(max_idle_time, idle_time)\\n                    \\n        return max_idle_time+1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1600671,
                "title": "java-o-n",
                "content": "```java\\nclass Solution {\\n    public int networkBecomesIdle(int[][] edges, int[] patience) {\\n        int len = patience.length;\\n        int[] dist = new int [len];\\n        ArrayList<Integer>[] conn = new ArrayList[len];\\n        for (int[]edge: edges) {\\n            int from = edge[0], to = edge[1];\\n            if (conn[from] == null) conn[from] = new ArrayList<>();\\n            if (conn[to] == null) conn[to] = new ArrayList<>();\\n            conn[from].add(to);\\n            conn[to].add(from);\\n        }\\n        Queue<Integer> queue = new LinkedList<>();\\n        queue.offer(0);\\n        int currLen = 1;\\n        int idle = Integer.MIN_VALUE;\\n        while(!queue.isEmpty()) {\\n            for (int size = queue.size(); size > 0; --size) {\\n                int vertex = queue.poll();\\n                for (int edge: conn[vertex]) {\\n                    if (dist[edge] != 0 || edge == 0) continue;\\n                    dist[edge] = currLen;\\n                    queue.offer(edge);\\n                    \\n                    //compute idle time\\n                    int tripTime = dist[edge] * 2;\\n                    int val = tripTime * 2 - (tripTime % patience[edge]);\\n                    if (tripTime % patience[edge] == 0) val -= patience[edge];\\n                    idle = Math.max(idle, val);\\n                }\\n            }\\n            ++currLen;\\n        }\\n        return idle + 1;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Breadth-First Search"
                ],
                "code": "```java\\nclass Solution {\\n    public int networkBecomesIdle(int[][] edges, int[] patience) {\\n        int len = patience.length;\\n        int[] dist = new int [len];\\n        ArrayList<Integer>[] conn = new ArrayList[len];\\n        for (int[]edge: edges) {\\n            int from = edge[0], to = edge[1];\\n            if (conn[from] == null) conn[from] = new ArrayList<>();\\n            if (conn[to] == null) conn[to] = new ArrayList<>();\\n            conn[from].add(to);\\n            conn[to].add(from);\\n        }\\n        Queue<Integer> queue = new LinkedList<>();\\n        queue.offer(0);\\n        int currLen = 1;\\n        int idle = Integer.MIN_VALUE;\\n        while(!queue.isEmpty()) {\\n            for (int size = queue.size(); size > 0; --size) {\\n                int vertex = queue.poll();\\n                for (int edge: conn[vertex]) {\\n                    if (dist[edge] != 0 || edge == 0) continue;\\n                    dist[edge] = currLen;\\n                    queue.offer(edge);\\n                    \\n                    //compute idle time\\n                    int tripTime = dist[edge] * 2;\\n                    int val = tripTime * 2 - (tripTime % patience[edge]);\\n                    if (tripTime % patience[edge] == 0) val -= patience[edge];\\n                    idle = Math.max(idle, val);\\n                }\\n            }\\n            ++currLen;\\n        }\\n        return idle + 1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1562937,
                "title": "cpp-commented-explanation",
                "content": "```\\nclass Solution {\\npublic:\\n    int networkBecomesIdle(vector<vector<int>>& e, vector<int>& pat) {\\n        vector<vector<int>> graph(pat.size());\\n        for(const auto &v:e){       // constructing undirected graph from given edges\\n            graph[v[0]].push_back(v[1]);            \\n            graph[v[1]].push_back(v[0]);\\n        }\\n        queue<pair<int,int>> q; // declaring queue to perform bfs (for shortest path ) (do remeber. this works because of unit edge weight otherwise we would\\'ve used dijkastra algorithm)\\n        q.push({0,0});  //pushin master server into queue as source\\n        int ans=0;\\n        vector<int> visit(pat.size(),0);    //visited array to avoid un-neccesary computing of already found nodes\\n        while(!q.empty()){ \\n            pair<int,int> p=q.front();\\n            q.pop();\\n            int node=p.first,dist=p.second;\\n            if(visit[node]==1)continue;\\n            visit[node]=1;\\n            int fact=0;     //this <fact> here is the count of the total messages we sent before last message was about to be sent (for each server)\\n            if(pat[node]!=0 and pat[node]<(2*dist))fact=((2*dist-1)/pat[node]); //so if patience of a node is less than the turnaround time of message then we caculate number of messages before last was about to be sent\\n            int tt=2*dist +fact*pat[node];//(2*dist ) is the turnaround time (time taken by last message to come back) (fact*pat[node]) is the time taken by previous all messages to come back\\n            ans=max(ans,tt);//checking if this node is leading to max time on network\\n            for(int x:graph[node])\\n                q.push({x,dist+1});//pushing neighbouring nodes on queue with incremented distance\\n        }\\n        return ans+1; // +1 is done because after last message is recieved by server then from the next second will the network become idle so...\\n    }\\n};****\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int networkBecomesIdle(vector<vector<int>>& e, vector<int>& pat) {\\n        vector<vector<int>> graph(pat.size());\\n        for(const auto &v:e){       // constructing undirected graph from given edges\\n            graph[v[0]].push_back(v[1]);            \\n            graph[v[1]].push_back(v[0]);\\n        }\\n        queue<pair<int,int>> q; // declaring queue to perform bfs (for shortest path ) (do remeber. this works because of unit edge weight otherwise we would\\'ve used dijkastra algorithm)\\n        q.push({0,0});  //pushin master server into queue as source\\n        int ans=0;\\n        vector<int> visit(pat.size(),0);    //visited array to avoid un-neccesary computing of already found nodes\\n        while(!q.empty()){ \\n            pair<int,int> p=q.front();\\n            q.pop();\\n            int node=p.first,dist=p.second;\\n            if(visit[node]==1)continue;\\n            visit[node]=1;\\n            int fact=0;     //this <fact> here is the count of the total messages we sent before last message was about to be sent (for each server)\\n            if(pat[node]!=0 and pat[node]<(2*dist))fact=((2*dist-1)/pat[node]); //so if patience of a node is less than the turnaround time of message then we caculate number of messages before last was about to be sent\\n            int tt=2*dist +fact*pat[node];//(2*dist ) is the turnaround time (time taken by last message to come back) (fact*pat[node]) is the time taken by previous all messages to come back\\n            ans=max(ans,tt);//checking if this node is leading to max time on network\\n            for(int x:graph[node])\\n                q.push({x,dist+1});//pushing neighbouring nodes on queue with incremented distance\\n        }\\n        return ans+1; // +1 is done because after last message is recieved by server then from the next second will the network become idle so...\\n    }\\n};****\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1549651,
                "title": "swift-just-for-you-steve",
                "content": "Basicly we want to calculate the round trip time after the last message was sent for each node. It would be great if we know the round trip time for each node, right? Intuition, is to traverse the whole grid and calculate the distance from the source to each node. Ah, sounds like [Dijkstra](https://en.wikipedia.org/wiki/Dijkstra%27s_algorithm) algorithm, but because there is no build in priority queue in swift we can use BFS instead.\\n\\nSteps:\\n1. Create adjacency matrix for easier traversal\\n2. Traverse the grid and calculate the distance\\n3.  Find max time for each distance\\n\\nNotes:\\n**A**\\nWe use `dist[v] == n` instead creating visited/seen set, since we initialize with `n` and we have not started from this node yet. However, I got TLE so we need a trick here. There are many tricks, I think it is the easiest I can think of.\\n**B**\\nThis line is a one line `res = max(res, (2*dist[i]-1)/patience[i]*patience[i] + 2*dist[i]) ` for\\n```\\nlet roundTrip = 2 * dist[i]\\nlet numberOfMsgs = (roundTrip - 1) / patience[i]\\nlet lastMsgTime = numberOfMsgs * patience[i]\\nres = max(res, lastMsgTime + roundTrip)\\n```\\n\\n**Solution**\\n```\\nclass Solution {\\n    func networkBecomesIdle(_ edges: [[Int]], _ patience: [Int]) -> Int {\\n        let n = patience.count\\n        var adj = [Int: [Int]]()\\n        var dist = Array(repeating: n, count: n)\\n        var q: [Int] = [0]\\n        var res = 0\\n        dist[0] = 0\\n        \\n        for edge in edges {\\n            let u = edge[0]\\n            let v = edge[1]\\n            if adj[u] != nil { adj[u]?.append(v) }\\n            else { adj[u] = [v] }\\n            if adj[v] != nil { adj[v]?.append(u) }\\n            else { adj[v] = [u] }\\n        }\\n        while !q.isEmpty {\\n            let u = q.removeFirst()\\n            for v in adj[u]! {\\n                if dist[v] == n {\\n                    dist[v] = dist[u] + 1\\n                    q.append(v)\\n                }\\n            }\\n        }\\n        for i in 1..<n { \\n\\t\\t\\tres = max(res, (2*dist[i]-1)/patience[i]*patience[i] + 2*dist[i]) \\n\\t\\t}\\n        return res + 1\\n    }\\n}\\n```",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nlet roundTrip = 2 * dist[i]\\nlet numberOfMsgs = (roundTrip - 1) / patience[i]\\nlet lastMsgTime = numberOfMsgs * patience[i]\\nres = max(res, lastMsgTime + roundTrip)\\n```\n```\\nclass Solution {\\n    func networkBecomesIdle(_ edges: [[Int]], _ patience: [Int]) -> Int {\\n        let n = patience.count\\n        var adj = [Int: [Int]]()\\n        var dist = Array(repeating: n, count: n)\\n        var q: [Int] = [0]\\n        var res = 0\\n        dist[0] = 0\\n        \\n        for edge in edges {\\n            let u = edge[0]\\n            let v = edge[1]\\n            if adj[u] != nil { adj[u]?.append(v) }\\n            else { adj[u] = [v] }\\n            if adj[v] != nil { adj[v]?.append(u) }\\n            else { adj[v] = [u] }\\n        }\\n        while !q.isEmpty {\\n            let u = q.removeFirst()\\n            for v in adj[u]! {\\n                if dist[v] == n {\\n                    dist[v] = dist[u] + 1\\n                    q.append(v)\\n                }\\n            }\\n        }\\n        for i in 1..<n { \\n\\t\\t\\tres = max(res, (2*dist[i]-1)/patience[i]*patience[i] + 2*dist[i]) \\n\\t\\t}\\n        return res + 1\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1543220,
                "title": "easy-bfs-full-explaination-c",
                "content": "// simply use bfs to know the time to reach each server from master server \\n// then calculate when the first first arrives how many extra msg has been sent by doing time[i]*2-1/patience[i] (multiply 2 coz msg will go and come back )(-1 because time[i]*2 will give time to reach the first msg but we need to calcute msg sent before it arrives )\\n// now we get a certain number x of extra msg \\n// check when was the last msg sent by x*patience[i];\\n// multiplying with patience of i because patience[i] gives the interval between each msg so if its value is 2 and extra msgs are 5 then last msg send was at =5*2 sec;\\n// now we got last out time \\n//we need to find when will no server send msg \\n//that will happen when last msg send by a server is recieved \\n//so we need to calculate the last msg send \\n//that can be done by last out * time[i]*2 \\n//now we know the last in time so for every server we check the last in value and we return the lasgest value\\n\\n\\nclass Solution {\\npublic:\\n    int networkBecomesIdle(vector<vector<int>>& edges, vector<int>& patience) {\\n        int n = patience.size();\\n        vector <vector <int>> graph(n);\\n        vector <int> time(n, -1);\\n        \\n        for(auto x: edges) { // create adjacency list\\n            graph[x[0]].push_back(x[1]);\\n            graph[x[1]].push_back(x[0]);\\n        }\\n        \\n        queue <int> q;\\n        q.push(0);\\n        time[0] = 0;\\n        while(q.size()) {\\n            int node = q.front();\\n            q.pop();\\n            \\n            for(auto child: graph[node]) {\\n                if(time[child] == -1) { // if not visited.\\n                    time[child] = time[node] + 1; // calc time for child node\\n                    q.push(child);\\n                }\\n            }\\n        }\\n        int res = 0;\\n        for(int i = 1; i<n; i++) {\\n            // since at time[i]*2 first msg arrives but we can only send message untill first msg arrives so if it takes 4 sec to recieve first msg then we will check no of msg send till 3 sec \\n            int extraPayload = (time[i]*2 - 1)/patience[i];\\n             int lastOut = extraPayload * patience[i]; // find the last time when a data server sends a message\\n            int lastIn = lastOut + time[i]*2; // this is the result for current data server\\n\\t\\t\\t\\n            res = max(res, lastIn);\\n        }\\n\\t\\t\\n\\t\\t// at \"res\" time the last message has arrived at one of the data servers.\\n\\t\\t// so at res+1 no message will be passing between servers.\\n\\t\\t\\n        return res+1;\\n    \\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    int networkBecomesIdle(vector<vector<int>>& edges, vector<int>& patience) {\\n        int n = patience.size();\\n        vector <vector <int>> graph(n);\\n        vector <int> time(n, -1);\\n        \\n        for(auto x: edges) { // create adjacency list\\n            graph[x[0]].push_back(x[1]);\\n            graph[x[1]].push_back(x[0]);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1531400,
                "title": "bfs-easy-maths-clean-code",
                "content": "class Solution {\\npublic:\\n    int networkBecomesIdle(vector<vector<int>>& edges, vector<int>& patience) {\\n        \\n        int n=patience.size(),ans=0;\\n        \\n        vector<int> adj[n];\\n        \\n        // create the graph from given edges\\n        \\n        for(int i=0;i<edges.size();++i)\\n        {\\n            adj[edges[i][0]].push_back(edges[i][1]);\\n            adj[edges[i][1]].push_back(edges[i][0]);\\n        }\\n        \\n        vector<int> vis(n,0),dis(n,1e6);\\n        queue<int> q1;\\n        \\n        q1.push(0);\\n        vis[0]=1;\\n        dis[0]=0;\\n        \\n       // do a simple bfs to get minimum distance from master server(0) to each node\\n        \\n        while(q1.size()!=0)\\n        {\\n            int node=q1.front();\\n            q1.pop();\\n            \\n           \\n            for(auto it:adj[node])\\n            {\\n                if(vis[it]==0)\\n                {\\n                    vis[it]=1;\\n                    dis[it]=dis[node]+1;\\n                    q1.push(it);\\n                }\\n            }\\n        }\\n        \\n        \\n        /// find the last packet for every node and calculate time taken by this packet.\\n        /// then simply take maximum of all these\\n        \\n        \\n        for(int i=1;i<=n-1;++i)\\n        {\\n            int p=2*dis[i]-1;\\n            int x=p/patience[i]*patience[i];\\n            \\n            x+=2*dis[i];\\n            ans=max(ans,x+1);\\n            \\n        }\\n        return ans;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    int networkBecomesIdle(vector<vector<int>>& edges, vector<int>& patience) {\\n        \\n        int n=patience.size(),ans=0;\\n        \\n        vector<int> adj[n];\\n        \\n        // create the graph from given edges\\n        \\n        for(int i=0;i<edges.size();++i)\\n        {\\n            adj[edges[i][0]].push_back(edges[i][1]);\\n            adj[edges[i][1]].push_back(edges[i][0]);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1529646,
                "title": "c-bfs-math",
                "content": "```\\nclass Solution {\\npublic:\\n    int networkBecomesIdle(vector<vector<int>>& edges, vector<int>& patience) {\\n        int n = patience.size();\\n        vector<int> dist(n, 0);\\n        vector<bool> used(n, false);\\n        vector<vector<int>> g(n);\\n        for(int i = 0; i < edges.size(); i++) {\\n            int u = edges[i][0];\\n            int v = edges[i][1];\\n            g[u].push_back(v);\\n            g[v].push_back(u);\\n        }\\n        \\n        \\n        queue<int> q;\\n        q.push(0);\\n        used[0] = true;\\n        while(!q.empty()) {\\n            int u = q.front();\\n            q.pop();\\n            for(int v: g[u]) {\\n                if(!used[v]) {\\n                    q.push(v);\\n                    used[v] = true;\\n                    dist[v] = 1 + dist[u];\\n                }\\n            }\\n        }\\n        \\n        int ans = 0;\\n        for(int i = 1; i < n; i++) {\\n            int travel = 2 * dist[i];\\n            int extra = (travel-1) / patience[i];\\n            int rem = travel - (extra*patience[i]);\\n            travel = 2*travel - rem;\\n            ans = max(ans, travel);\\n        }\\n        \\n        return ans+1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int networkBecomesIdle(vector<vector<int>>& edges, vector<int>& patience) {\\n        int n = patience.size();\\n        vector<int> dist(n, 0);\\n        vector<bool> used(n, false);\\n        vector<vector<int>> g(n);\\n        for(int i = 0; i < edges.size(); i++) {\\n            int u = edges[i][0];\\n            int v = edges[i][1];\\n            g[u].push_back(v);\\n            g[v].push_back(u);\\n        }\\n        \\n        \\n        queue<int> q;\\n        q.push(0);\\n        used[0] = true;\\n        while(!q.empty()) {\\n            int u = q.front();\\n            q.pop();\\n            for(int v: g[u]) {\\n                if(!used[v]) {\\n                    q.push(v);\\n                    used[v] = true;\\n                    dist[v] = 1 + dist[u];\\n                }\\n            }\\n        }\\n        \\n        int ans = 0;\\n        for(int i = 1; i < n; i++) {\\n            int travel = 2 * dist[i];\\n            int extra = (travel-1) / patience[i];\\n            int rem = travel - (extra*patience[i]);\\n            travel = 2*travel - rem;\\n            ans = max(ans, travel);\\n        }\\n        \\n        return ans+1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1527898,
                "title": "java-bfs-easy-to-understand",
                "content": "class Solution {\\n    public int networkBecomesIdle(int[][] edges, int[] patience) {\\n\\t\\n        TreeMap<Integer,List<Integer>> graph = new TreeMap<>(); // can use HashMap as well\\n        int n = patience.length;\\n        int[] distance = new int[n];\\n        Arrays.fill(distance,Integer.MAX_VALUE); // setting distance as infinite\\n        distance[0]=0; \\n        \\n\\t\\t// creating our graph\\n        for(int[] e : edges){\\n            graph.computeIfAbsent(e[0],x->new ArrayList<>()).add(e[1]);\\n            graph.computeIfAbsent(e[1],x->new ArrayList<>()).add(e[0]);\\n        }\\n\\t\\t\\n        Queue<Integer> q = new LinkedList<>();\\n        q.add(0);\\n        Set<Integer> visited = new HashSet<>();\\n        while(!q.isEmpty()){\\n            int key = q.poll();\\n            for(int x : graph.get(key)){\\n                if(!visited.contains(x)){\\n                    visited.add(x);\\n                    distance[x] = Math.min(distance[x],distance[key]+1); // fastest route\\n                    q.add(x);\\n                }\\n            }\\n        }                \\n        \\n        int max=0;\\n        for(int i=1;i<n;i++){\\n            int x = distance[i]*2;\\n            if(x<=patience[i]){\\n                max = Math.max(max,x);\\n            }else{\\n                int div = x/patience[i];\\n                if(x%patience[i]==0)\\n                    div--;\\n                x += (div*patience[i]);\\n                max = Math.max(max,x);\\n            }\\n        }\\n        return max+1; // +1 because we need to return the starting time of idle network\\n    }\\n}",
                "solutionTags": [
                    "Java",
                    "Math",
                    "Breadth-First Search"
                ],
                "code": "class Solution {\\n    public int networkBecomesIdle(int[][] edges, int[] patience) {\\n\\t\\n        TreeMap<Integer,List<Integer>> graph = new TreeMap<>(); // can use HashMap as well\\n        int n = patience.length;\\n        int[] distance = new int[n];\\n        Arrays.fill(distance,Integer.MAX_VALUE); // setting distance as infinite\\n        distance[0]=0; \\n        \\n\\t\\t// creating our graph\\n        for(int[] e : edges){\\n            graph.computeIfAbsent(e[0],x->new ArrayList<>()).add(e[1]);\\n            graph.computeIfAbsent(e[1],x->new ArrayList<>()).add(e[0]);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1525036,
                "title": "python-bfs-explanation",
                "content": "Ideas:\\n1. Create a dictionary-like adjecency list so it we can access each node in O(1)\\n2. Use BFS and the adjacency list so we can construct shortest_path dictionary. It will indicate how far away from current node to the source node.\\n3. Calculate when does a data server receive his first reply from the master server, how many impatient checking messages have been sent and when would a data server receive the reply of last sent checking message. \\n4. Use Step 3 to loop through all data servers. Then we can find the time the network system to be idle. \\n```\\nclass Solution:\\n    def networkBecomesIdle(self, edges: List[List[int]], patience: List[int]) -> int:\\n        self.n_nodes = len(patience)\\n        shortest_path = self.bfs(0, edges) # bfs to find minimum steps to the source\\n        return self.get_min_idle(shortest_path, patience)\\n\\n    def bfs(self, source, edges):\\n        # Create an adjecency list using dictionary\\n        edge_d = dict()\\n        for i, j in edges:\\n            if i not in edge_d:\\n                edge_d[i] = []\\n            if j not in edge_d:\\n                edge_d[j] = []\\n            edge_d[i].append(j)\\n            edge_d[j].append(i)\\n\\n        # bfs to construct a shortest_path dictionary \\n        # shortest_path : {Key : current node ,  Value : distance between current node and source}\\n        shortest_path = {source : 0}\\n        visited = set()\\n        visited.add(source)\\n        queue = [source]\\n        while queue:\\n            n = len(queue)\\n            for i in range(n):\\n                cur_node = queue.pop(0)\\n                for neighbor_node in edge_d[cur_node]:\\n                    if neighbor_node not in visited:\\n                        shortest_path[neighbor_node] = shortest_path[cur_node] + 1\\n                        visited.add(neighbor_node)\\n                        queue.append(neighbor_node)\\n        return shortest_path\\n            \\n    \\n    def get_min_idle(self, shortest_path, patience):\\n        maxi = 0\\n        for i in sorted(shortest_path.keys()):\\n\\t\\t    # Ignore source\\n            if i == 0: continue\\n            dist_to_source = shortest_path[i]\\n            \\n            # a round trip time to receive the response from the master server\\n            first_message_receive_time = 2 * dist_to_source\\n            \\n            # the number of messages would be sent by data server due to impatience\\n            n_message_sent = int(first_message_receive_time / patience[i]) + 1\\n            \\n            # if a data server receives the reply of the first message but it\\'s out of patience at the same time (about to send a checking message)\\n            # The data server should stop sending current checking message\\n            if first_message_receive_time % patience[i] == 0:\\n                n_message_sent -= 1\\n\\n            # need to wait for all the replies of all the checking messages due to data server\\'s impatience  \\n            last_sent_need_time = (n_message_sent - 1) * patience[i]\\n            \\n            # find the maximum time one of the data servers needs to receive the last reply from the master server\\n            maxi = max(maxi, last_sent_need_time + first_message_receive_time)\\n\\t\\t\\n\\t\\t# The system will be considered as idle after one second when last reply be received\\n        return maxi+1\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def networkBecomesIdle(self, edges: List[List[int]], patience: List[int]) -> int:\\n        self.n_nodes = len(patience)\\n        shortest_path = self.bfs(0, edges) # bfs to find minimum steps to the source\\n        return self.get_min_idle(shortest_path, patience)\\n\\n    def bfs(self, source, edges):\\n        # Create an adjecency list using dictionary\\n        edge_d = dict()\\n        for i, j in edges:\\n            if i not in edge_d:\\n                edge_d[i] = []\\n            if j not in edge_d:\\n                edge_d[j] = []\\n            edge_d[i].append(j)\\n            edge_d[j].append(i)\\n\\n        # bfs to construct a shortest_path dictionary \\n        # shortest_path : {Key : current node ,  Value : distance between current node and source}\\n        shortest_path = {source : 0}\\n        visited = set()\\n        visited.add(source)\\n        queue = [source]\\n        while queue:\\n            n = len(queue)\\n            for i in range(n):\\n                cur_node = queue.pop(0)\\n                for neighbor_node in edge_d[cur_node]:\\n                    if neighbor_node not in visited:\\n                        shortest_path[neighbor_node] = shortest_path[cur_node] + 1\\n                        visited.add(neighbor_node)\\n                        queue.append(neighbor_node)\\n        return shortest_path\\n            \\n    \\n    def get_min_idle(self, shortest_path, patience):\\n        maxi = 0\\n        for i in sorted(shortest_path.keys()):\\n\\t\\t    # Ignore source\\n            if i == 0: continue\\n            dist_to_source = shortest_path[i]\\n            \\n            # a round trip time to receive the response from the master server\\n            first_message_receive_time = 2 * dist_to_source\\n            \\n            # the number of messages would be sent by data server due to impatience\\n            n_message_sent = int(first_message_receive_time / patience[i]) + 1\\n            \\n            # if a data server receives the reply of the first message but it\\'s out of patience at the same time (about to send a checking message)\\n            # The data server should stop sending current checking message\\n            if first_message_receive_time % patience[i] == 0:\\n                n_message_sent -= 1\\n\\n            # need to wait for all the replies of all the checking messages due to data server\\'s impatience  \\n            last_sent_need_time = (n_message_sent - 1) * patience[i]\\n            \\n            # find the maximum time one of the data servers needs to receive the last reply from the master server\\n            maxi = max(maxi, last_sent_need_time + first_message_receive_time)\\n\\t\\t\\n\\t\\t# The system will be considered as idle after one second when last reply be received\\n        return maxi+1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1525008,
                "title": "short-java-bfs-21-lines",
                "content": "1. Run BFS from 0 to find time to reach each server\\n2. Calculate idle time for this server using its patience data. The result is the max of such values\\n```java\\npublic int networkBecomesIdle(int[][] edges, int[] patience) {\\n        List<List<Integer>> g = IntStream.range(0, patience.length).mapToObj(l -> new ArrayList<Integer>()).collect(Collectors.toList());\\n        for (int[] e : edges) {\\n            g.get(e[0]).add(e[1]);\\n            g.get(e[1]).add(e[0]);\\n        }\\n        Queue<Integer> q = new LinkedList<>();\\n        boolean[] seen = new boolean[patience.length];\\n        int r = 0, time = 0;\\n        for (seen[0] = true, q.add(0); !q.isEmpty(); time++)\\n            for (int size = q.size(); size > 0; size--) {\\n                int u = q.poll(), roundTripTime = 2 * time, idle = roundTripTime + 1;\\n                if (patience[u] < roundTripTime)\\n                    idle += roundTripTime - (roundTripTime % patience[u] == 0 ? patience[u] : roundTripTime % patience[u]);\\n                r = Math.max(r, idle);\\n                for (Integer v : g.get(u))\\n                    if (!seen[v]) {\\n                        q.offer(v);\\n                        seen[v] = true;\\n                    }\\n            }\\n        return r;\\n    }",
                "solutionTags": [],
                "code": "1. Run BFS from 0 to find time to reach each server\\n2. Calculate idle time for this server using its patience data. The result is the max of such values\\n```java\\npublic int networkBecomesIdle(int[][] edges, int[] patience) {\\n        List<List<Integer>> g = IntStream.range(0, patience.length).mapToObj(l -> new ArrayList<Integer>()).collect(Collectors.toList());\\n        for (int[] e : edges) {\\n            g.get(e[0]).add(e[1]);\\n            g.get(e[1]).add(e[0]);\\n        }\\n        Queue<Integer> q = new LinkedList<>();\\n        boolean[] seen = new boolean[patience.length];\\n        int r = 0, time = 0;\\n        for (seen[0] = true, q.add(0); !q.isEmpty(); time++)\\n            for (int size = q.size(); size > 0; size--) {\\n                int u = q.poll(), roundTripTime = 2 * time, idle = roundTripTime + 1;\\n                if (patience[u] < roundTripTime)\\n                    idle += roundTripTime - (roundTripTime % patience[u] == 0 ? patience[u] : roundTripTime % patience[u]);\\n                r = Math.max(r, idle);\\n                for (Integer v : g.get(u))\\n                    if (!seen[v]) {\\n                        q.offer(v);\\n                        seen[v] = true;\\n                    }\\n            }\\n        return r;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1524532,
                "title": "python",
                "content": "First try to find the shortest distance to reach every individual node from master node that can be easily done with dijkstra\\'s algorithm and then find which node take maximum time because after that it will be ideal.\\n```\\nimport heapq\\nclass Solution:\\n    def networkBecomesIdle(self, edges: List[List[int]], pat: List[int]) -> int:\\n        dist = [float(\"inf\")]*len(pat)\\n        d = defaultdict(list)\\n        for a,b in edges:\\n            d[a].append(b)\\n            d[b].append(a)\\n        q=[]\\n        q.append([0,0])\\n        dist[0]=0\\n        while(q):\\n            s,dis = heapq.heappop(q)\\n            for i in d[s]:\\n                if dis+1<dist[i]:\\n                    dist[i] = dis+1\\n                    heapq.heappush(q,[i,dist[i]])\\n        ans=0\\n        #print(dist)\\n        for i in range(1,len(dist)):\\n            p = dist[i]*2\\n            c = p+(p-(p-1)%pat[i])\\n            ans = max(ans,c)\\n        #ans+=1\\n        return ans",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Greedy",
                    "Breadth-First Search",
                    "Graph"
                ],
                "code": "First try to find the shortest distance to reach every individual node from master node that can be easily done with dijkstra\\'s algorithm and then find which node take maximum time because after that it will be ideal.\\n```\\nimport heapq\\nclass Solution:\\n    def networkBecomesIdle(self, edges: List[List[int]], pat: List[int]) -> int:\\n        dist = [float(\"inf\")]*len(pat)\\n        d = defaultdict(list)\\n        for a,b in edges:\\n            d[a].append(b)\\n            d[b].append(a)\\n        q=[]\\n        q.append([0,0])\\n        dist[0]=0\\n        while(q):\\n            s,dis = heapq.heappop(q)\\n            for i in d[s]:\\n                if dis+1<dist[i]:\\n                    dist[i] = dis+1\\n                    heapq.heappush(q,[i,dist[i]])\\n        ans=0\\n        #print(dist)\\n        for i in range(1,len(dist)):\\n            p = dist[i]*2\\n            c = p+(p-(p-1)%pat[i])\\n            ans = max(ans,c)\\n        #ans+=1\\n        return ans",
                "codeTag": "Java"
            },
            {
                "id": 1524359,
                "title": "javascript-bfs-simple-explained",
                "content": "```\\n/**\\n * @param {number[][]} edges\\n * @param {number[]} patience\\n * @return {number}\\n */\\nvar networkBecomesIdle = function(edges, patience) {\\n  /*\\n  Approach:\\n  Lets call D is the distance from node to master\\n  And last message sent from node is at T\\n  Then last message will travel till D+T and network will be idal at D+T+1\\n  */  \\n    let edgesMap={},minDistanceFromMasterArr=[],ans=0,visited={};\\n    for(let i=0;i<edges.length;i++){\\n        if(edgesMap[edges[i][0]]===undefined){\\n            edgesMap[edges[i][0]] = [];\\n        }\\n        edgesMap[edges[i][0]].push(edges[i][1]);\\n        if(edgesMap[edges[i][1]]===undefined){\\n            edgesMap[edges[i][1]] = [];\\n        }\\n        edgesMap[edges[i][1]].push(edges[i][0]);\\n    }\\n    \\n    let queue=[],node,neighbour;\\n    minDistanceFromMasterArr[0]=0;//Distance of source to source is 0 \\n    queue.push(0);\\n    while(queue[0]!==undefined){\\n        node = queue.shift();\\n        for(let i=0;i<edgesMap[node].length;i++){\\n            neighbour = edgesMap[node][i];   \\n            if(minDistanceFromMasterArr[neighbour]===undefined){\\n                minDistanceFromMasterArr[neighbour] = minDistanceFromMasterArr[node] + 1;\\n                queue.push(neighbour);\\n            }\\n        }\\n    }\\n    for(let i=1;i<patience.length;i++){\\n        let responseWillBeReceivedAt = minDistanceFromMasterArr[i]*2;\\n        let lastMessageSentAt;\\n        if(patience[i]<responseWillBeReceivedAt){\\n            lastMessageSentAt = Math.floor((responseWillBeReceivedAt-1)/patience[i])*patience[i];\\n        }else{\\n            lastMessageSentAt=0;\\n        }\\n        let lastMessageWillTravelTill = lastMessageSentAt + responseWillBeReceivedAt;\\n        let firstIdleSecond = lastMessageWillTravelTill+1;\\n        ans = Math.max(ans,firstIdleSecond);\\n    }\\n    \\n    return ans;\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Breadth-First Search"
                ],
                "code": "```\\n/**\\n * @param {number[][]} edges\\n * @param {number[]} patience\\n * @return {number}\\n */\\nvar networkBecomesIdle = function(edges, patience) {\\n  /*\\n  Approach:\\n  Lets call D is the distance from node to master\\n  And last message sent from node is at T\\n  Then last message will travel till D+T and network will be idal at D+T+1\\n  */  \\n    let edgesMap={},minDistanceFromMasterArr=[],ans=0,visited={};\\n    for(let i=0;i<edges.length;i++){\\n        if(edgesMap[edges[i][0]]===undefined){\\n            edgesMap[edges[i][0]] = [];\\n        }\\n        edgesMap[edges[i][0]].push(edges[i][1]);\\n        if(edgesMap[edges[i][1]]===undefined){\\n            edgesMap[edges[i][1]] = [];\\n        }\\n        edgesMap[edges[i][1]].push(edges[i][0]);\\n    }\\n    \\n    let queue=[],node,neighbour;\\n    minDistanceFromMasterArr[0]=0;//Distance of source to source is 0 \\n    queue.push(0);\\n    while(queue[0]!==undefined){\\n        node = queue.shift();\\n        for(let i=0;i<edgesMap[node].length;i++){\\n            neighbour = edgesMap[node][i];   \\n            if(minDistanceFromMasterArr[neighbour]===undefined){\\n                minDistanceFromMasterArr[neighbour] = minDistanceFromMasterArr[node] + 1;\\n                queue.push(neighbour);\\n            }\\n        }\\n    }\\n    for(let i=1;i<patience.length;i++){\\n        let responseWillBeReceivedAt = minDistanceFromMasterArr[i]*2;\\n        let lastMessageSentAt;\\n        if(patience[i]<responseWillBeReceivedAt){\\n            lastMessageSentAt = Math.floor((responseWillBeReceivedAt-1)/patience[i])*patience[i];\\n        }else{\\n            lastMessageSentAt=0;\\n        }\\n        let lastMessageWillTravelTill = lastMessageSentAt + responseWillBeReceivedAt;\\n        let firstIdleSecond = lastMessageWillTravelTill+1;\\n        ans = Math.max(ans,firstIdleSecond);\\n    }\\n    \\n    return ans;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1524332,
                "title": "use-bfs-to-calculate-shortest-distance-of-each-data-server-from-master-server",
                "content": "```\\nclass Solution {\\npublic:\\n    int networkBecomesIdle(vector<vector<int>>& edges, vector<int>& patience) {\\n        int n=patience.size();\\n        \\n        vector<vector<int>>  graph(n);\\n        \\n        for(int i=0;i<edges.size();i++){\\n             graph[edges[i][0]].push_back(edges[i][1]);\\n             graph[edges[i][1]].push_back(edges[i][0]);\\n        }\\n        \\n        vector<int> dist(n);\\n        dist[0]=0;\\n        vector<bool> visited(n,0);\\n        \\n        int curr;  int d=0;\\n       \\n        queue<int> q;\\n        q.push(0);\\n        visited[0]=1;\\n       \\n        while(!q.empty()){\\n            int size=q.size();\\n            while(size--){\\n                \\n                curr=q.front(); q.pop();\\n                dist[curr]=d;\\n                \\n                for(int j=0;j<graph[curr].size();j++){\\n                    if(!visited[graph[curr][j]]){\\n                        visited[graph[curr][j]]=1;\\n                        q.push(graph[curr][j]);\\n                    }\\n                }\\n                \\n            }\\n            d++;\\n        }\\n        int ans=0;\\n        for(int i=1;i<n;i++){\\n            int time=2*dist[i];\\n            int a=time/patience[i];\\n            int b=a*patience[i];\\n            if(b==time){\\n                b=(a-1)*patience[i];\\n            }\\n            ans=max(ans,b+time);\\n            \\n        }\\n        return ans+1;\\n        \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int networkBecomesIdle(vector<vector<int>>& edges, vector<int>& patience) {\\n        int n=patience.size();\\n        \\n        vector<vector<int>>  graph(n);\\n        \\n        for(int i=0;i<edges.size();i++){\\n             graph[edges[i][0]].push_back(edges[i][1]);\\n             graph[edges[i][1]].push_back(edges[i][0]);\\n        }\\n        \\n        vector<int> dist(n);\\n        dist[0]=0;\\n        vector<bool> visited(n,0);\\n        \\n        int curr;  int d=0;\\n       \\n        queue<int> q;\\n        q.push(0);\\n        visited[0]=1;\\n       \\n        while(!q.empty()){\\n            int size=q.size();\\n            while(size--){\\n                \\n                curr=q.front(); q.pop();\\n                dist[curr]=d;\\n                \\n                for(int j=0;j<graph[curr].size();j++){\\n                    if(!visited[graph[curr][j]]){\\n                        visited[graph[curr][j]]=1;\\n                        q.push(graph[curr][j]);\\n                    }\\n                }\\n                \\n            }\\n            d++;\\n        }\\n        int ans=0;\\n        for(int i=1;i<n;i++){\\n            int time=2*dist[i];\\n            int a=time/patience[i];\\n            int b=a*patience[i];\\n            if(b==time){\\n                b=(a-1)*patience[i];\\n            }\\n            ans=max(ans,b+time);\\n            \\n        }\\n        return ans+1;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1524311,
                "title": "java-solution-bfs-easy-to-understand",
                "content": "```\\n\\nclass Solution {\\n    ArrayList<ArrayList<Integer>> adj;\\n    public int networkBecomesIdle(int[][] edges, int[] pat) {\\n        adj=new ArrayList<>();\\n        int n=pat.length;\\n        for(int i=0;i<=n;i++){\\n            adj.add(new ArrayList<Integer>());\\n        }\\n        for(int a[]:edges){\\n            adj.get(a[0]).add(a[1]);\\n            adj.get(a[1]).add(a[0]);\\n        }\\n        int level[]=new int[n];\\n        Arrays.fill(level,-1);\\n        bfs(level);\\n        int res=0;\\n        for(int i=1;i<n;i++){\\n            int dist = level[i];\\n            int val = dist + dist - (dist % pat[i]);\\n            if(dist % pat[i] == 0) val -= pat[i];\\n            res = Integer.max(res, val);\\n        }\\n        \\n        return res + 1;\\n        \\n    }\\n    void bfs(int level[]){\\n        Queue<Integer> q=new LinkedList<>();\\n        q.add(0);\\n        int lev=1;\\n        while(q.size()!=0){\\n            int size=q.size();\\n            while(size-->0){\\n                int mtp=q.remove();\\n                for(int i:adj.get(mtp)){\\n                    if(level[i]==-1){\\n                        level[i]=2*lev;\\n                        q.add(i);\\n                    }\\n                }\\n            }\\n            lev++;\\n        }\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    ArrayList<ArrayList<Integer>> adj;\\n    public int networkBecomesIdle(int[][] edges, int[] pat) {\\n        adj=new ArrayList<>();\\n        int n=pat.length;\\n        for(int i=0;i<=n;i++){\\n            adj.add(new ArrayList<Integer>());\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1524299,
                "title": "c-easy-clean-solution-fastest-dijkstra-math-detailed-comments",
                "content": "```\\nclass Solution {\\n    typedef vector<int> vi;\\n    typedef vector<vi> vvi;\\n    typedef pair<int, int> pii;\\npublic:\\n    int networkBecomesIdle(vvi &edges, vi &patience) {\\n        int n = patience.size();\\n        // build graph\\n        vvi adj(n);\\n        for (auto &e: edges) {\\n            adj[e[0]].push_back(e[1]);\\n            adj[e[1]].push_back(e[0]);\\n        }\\n        // apply dijkstra to build time array for each server\\n        vi time(n, INT_MAX);\\n        dijkstra(adj, time);\\n        // find idle time for each server and reture max of them (+ 1)\\n        int idleTime = 0, currIdleTime, extraMsg;\\n        for (int src = 0; src < n; src++) {\\n            // if time taken to receive first reply is <= patience\\n            if (time[src] <= patience[src])\\n                currIdleTime = time[src];\\n            else {\\n                // no. of extra messages (other than 1st msg) sent by server \\n                extraMsg = (time[src] - 1) / patience[src];\\n                // below is time taken to recieve reply for last extra msg\\n                currIdleTime = extraMsg * patience[src] + time[src];\\n            }\\n            idleTime = max(idleTime, currIdleTime);\\n        }\\n        return idleTime + 1;    // as per ques. we need to add 1\\n    }\\n    // utility for dijkstra\\n    void dijkstra(vvi &adj, vi &time) {\\n        priority_queue<pii, vector<pii>, greater<pii>> pq;\\n        time[0] = 0;\\n        pq.push({0, 0});\\n        while (!pq.empty()) {\\n            auto [src, t] = pq.top();\\n            pq.pop();\\n            for (auto &nd: adj[src])\\n\\t\\t\\t\\t// if (t + 1 < time[nd]) { -> this check is also fine\\n                if (t + 2 < time[nd]) {\\n                    // + 2 to make twice of actual time\\n                    time[nd] = t + 2; \\n                    pq.push({nd, time[nd]});\\n                }\\n        }\\n    }\\n};\\n```\\n\\n**NOTE:**\\n*If you find this post helpful then please **upvote**. It keeps me **motivated** to post such helpful solutions. Thanks!*\\n\\n**PS:**\\nI have also written posts on:\\n1. All C++ (15+) sorting algorithms in a cleaner way [here](https://leetcode.com/problems/sort-an-array/discuss/1401412/C%2B%2B-Clean-Code-Solution-or-Fastest-or-All-(15%2B)-Sorting-Methods-or-Detailed) on leetcode.\\n2. Kadane\\'s Algorithm and Follow up Questions [C++] in a cleaner way [here](https://leetcode.com/problems/maximum-subarray/discuss/1470547/C++-Easy-and-Clean-Solution-or-Fastest:-0ms-or-All-Methods-or-Follow-Ups-or-Detailed-Explanation) on leetcode.\\n\\n*Do check it out/ bookmark (and upvote :)) to revise those concepts for the interview. Thanks!*",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    typedef vector<int> vi;\\n    typedef vector<vi> vvi;\\n    typedef pair<int, int> pii;\\npublic:\\n    int networkBecomesIdle(vvi &edges, vi &patience) {\\n        int n = patience.size();\\n        // build graph\\n        vvi adj(n);\\n        for (auto &e: edges) {\\n            adj[e[0]].push_back(e[1]);\\n            adj[e[1]].push_back(e[0]);\\n        }\\n        // apply dijkstra to build time array for each server\\n        vi time(n, INT_MAX);\\n        dijkstra(adj, time);\\n        // find idle time for each server and reture max of them (+ 1)\\n        int idleTime = 0, currIdleTime, extraMsg;\\n        for (int src = 0; src < n; src++) {\\n            // if time taken to receive first reply is <= patience\\n            if (time[src] <= patience[src])\\n                currIdleTime = time[src];\\n            else {\\n                // no. of extra messages (other than 1st msg) sent by server \\n                extraMsg = (time[src] - 1) / patience[src];\\n                // below is time taken to recieve reply for last extra msg\\n                currIdleTime = extraMsg * patience[src] + time[src];\\n            }\\n            idleTime = max(idleTime, currIdleTime);\\n        }\\n        return idleTime + 1;    // as per ques. we need to add 1\\n    }\\n    // utility for dijkstra\\n    void dijkstra(vvi &adj, vi &time) {\\n        priority_queue<pii, vector<pii>, greater<pii>> pq;\\n        time[0] = 0;\\n        pq.push({0, 0});\\n        while (!pq.empty()) {\\n            auto [src, t] = pq.top();\\n            pq.pop();\\n            for (auto &nd: adj[src])\\n\\t\\t\\t\\t// if (t + 1 < time[nd]) { -> this check is also fine\\n                if (t + 2 < time[nd]) {\\n                    // + 2 to make twice of actual time\\n                    time[nd] = t + 2; \\n                    pq.push({nd, time[nd]});\\n                }\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1524290,
                "title": "python-bfs-with-explanation",
                "content": "Basically the algorithm is following:\\n1. Create adjacency list\\n2. Find a length of path from node 0 to every other node. Basically, we need to run BFS. And we should run it only once, because we only interested in paths from node 0 to every other node, and we are not interested in path between other nodes, e.g. from 1 to 2 etc.\\n3. We need to find max time to travel from all paths (but with some modifications that are related to repeated messages and the fact that message needs to have a round trip, below in comments, I explained more precisely)\\n```\\nclass Solution:\\n    def networkBecomesIdle(self, edges: List[List[int]], patience: List[int]) -> int:\\n        n = len(patience)\\n\\t\\t\\n\\t\\t# Create adjacency list\\n        adj_list = defaultdict(list)\\n        for a,b in edges:\\n            adj_list[a].append(b)\\n            adj_list[b].append(a)\\n\\t\\t\\t\\n\\t\\t# Initialize hash map for storing time to get from every node to node 0 \\n        seen = {}\\n        seen[0] = 0\\n        \\n\\t\\t# Simple BFS to find the shortest path from node 0 to every other node\\n\\t\\t# Note that since we need only find paths from node 0 to every other node,\\n\\t\\t# we can terminate the function when we find all such paths, \\n\\t\\t# the line code: if len(seen) == n: return\\n        def bfs():\\n            queue = deque([0])\\n            dist = 1\\n            while queue:\\n                for _ in range(len(queue)):\\n                    curr = queue.pop()\\n                    for nei in adj_list[curr]:\\n                        if nei not in seen:\\n                            queue.appendleft(nei)\\n                            seen[nei] = dist\\n                            if len(seen) == n:\\n                                return\\n                dist += 1\\n\\t\\t# call the function once\\n        bfs()\\n\\t\\t\\n\\t\\t# here we basically need to find the longest travel time from node 0 to all nodes\\n\\t\\t# First of all, we need to multiply path from each node by 2, because message have a round trip\\n\\t\\t# Second, we need to substruct 1 from this value, because message arrives back at that time\\n\\t\\t# Third, we need to know how many messages were already sent by the time first message gets back, so: val // patience[i]\\n\\t\\t# Fourth, we need to convert this to seconds by multiplying it with time they were sent, i.e by patience[i]\\n        travel = 0\\n        for i in range(1,n):\\n            val = seen[i]*2\\n            travel = max(travel, val + (patience[i] * ((val-1) // patience[i])))\\n        \\n\\t\\t# according to statement we need to add 1 for servers to be in idle state\\n        return travel+1\\n```\\n\\nHope this was helpful, please ask your questions in comment section, will happy to help.",
                "solutionTags": [
                    "Python",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution:\\n    def networkBecomesIdle(self, edges: List[List[int]], patience: List[int]) -> int:\\n        n = len(patience)\\n\\t\\t\\n\\t\\t# Create adjacency list\\n        adj_list = defaultdict(list)\\n        for a,b in edges:\\n            adj_list[a].append(b)\\n            adj_list[b].append(a)\\n\\t\\t\\t\\n\\t\\t# Initialize hash map for storing time to get from every node to node 0 \\n        seen = {}\\n        seen[0] = 0\\n        \\n\\t\\t# Simple BFS to find the shortest path from node 0 to every other node\\n\\t\\t# Note that since we need only find paths from node 0 to every other node,\\n\\t\\t# we can terminate the function when we find all such paths, \\n\\t\\t# the line code: if len(seen) == n: return\\n        def bfs():\\n            queue = deque([0])\\n            dist = 1\\n            while queue:\\n                for _ in range(len(queue)):\\n                    curr = queue.pop()\\n                    for nei in adj_list[curr]:\\n                        if nei not in seen:\\n                            queue.appendleft(nei)\\n                            seen[nei] = dist\\n                            if len(seen) == n:\\n                                return\\n                dist += 1\\n\\t\\t# call the function once\\n        bfs()\\n\\t\\t\\n\\t\\t# here we basically need to find the longest travel time from node 0 to all nodes\\n\\t\\t# First of all, we need to multiply path from each node by 2, because message have a round trip\\n\\t\\t# Second, we need to substruct 1 from this value, because message arrives back at that time\\n\\t\\t# Third, we need to know how many messages were already sent by the time first message gets back, so: val // patience[i]\\n\\t\\t# Fourth, we need to convert this to seconds by multiplying it with time they were sent, i.e by patience[i]\\n        travel = 0\\n        for i in range(1,n):\\n            val = seen[i]*2\\n            travel = max(travel, val + (patience[i] * ((val-1) // patience[i])))\\n        \\n\\t\\t# according to statement we need to add 1 for servers to be in idle state\\n        return travel+1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1524269,
                "title": "clean-and-easy-c-code-using-bfs-with-comments",
                "content": "```\\nclass Solution {\\npublic:\\n    int networkBecomesIdle(vector<vector<int>>& e, vector<int>& p) {\\n        // Creat an adjacent list\\n        int n = p.size();\\n        vector<vector<int>> adj(n);\\n        for(auto x: e) {\\n            adj[x[0]].push_back(x[1]);\\n            adj[x[1]].push_back(x[0]);\\n        }\\n        \\n        vector<int> dist(n); // Distance of all nodes from 0\\n        vector<bool> vis(n); // Visited array\\n        for(int i = 0; i < n; i++) {\\n            dist[i] = 0;\\n            vis[i] = false;\\n        }\\n        \\n        // Distance of all from 0\\n        queue<int> q;\\n        q.push(0);\\n        vis[0] = true;\\n        while(!q.empty()) {\\n            int u = q.front();\\n            q.pop();\\n            for(auto x: adj[u]) {\\n                if(vis[x] == false) {\\n                    dist[x] = dist[u]+1;\\n                    vis[x] = true;\\n                    q.push(x);\\n                }\\n            }\\n        }\\n        \\n        int ans = 0;\\n        for(int i = 1; i < n; i++) {\\n            int firstMessage = 2*dist[i]+1; // Time taken by first message\\n            ans = max(ans, firstMessage+(2*dist[i]-1)/p[i]*p[i]);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int networkBecomesIdle(vector<vector<int>>& e, vector<int>& p) {\\n        // Creat an adjacent list\\n        int n = p.size();\\n        vector<vector<int>> adj(n);\\n        for(auto x: e) {\\n            adj[x[0]].push_back(x[1]);\\n            adj[x[1]].push_back(x[0]);\\n        }\\n        \\n        vector<int> dist(n); // Distance of all nodes from 0\\n        vector<bool> vis(n); // Visited array\\n        for(int i = 0; i < n; i++) {\\n            dist[i] = 0;\\n            vis[i] = false;\\n        }\\n        \\n        // Distance of all from 0\\n        queue<int> q;\\n        q.push(0);\\n        vis[0] = true;\\n        while(!q.empty()) {\\n            int u = q.front();\\n            q.pop();\\n            for(auto x: adj[u]) {\\n                if(vis[x] == false) {\\n                    dist[x] = dist[u]+1;\\n                    vis[x] = true;\\n                    q.push(x);\\n                }\\n            }\\n        }\\n        \\n        int ans = 0;\\n        for(int i = 1; i < n; i++) {\\n            int firstMessage = 2*dist[i]+1; // Time taken by first message\\n            ans = max(ans, firstMessage+(2*dist[i]-1)/p[i]*p[i]);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1524256,
                "title": "for-beginners-greedy-approach-well-explained",
                "content": "## IDEA:\\n\\n\\t* Build an adjency list.\\n\\t* BFS from the master node to get the shortest path from node to master.\\n\\t* Calculate when the last resent time is, and how long it will take to reach the server after that.\\n\\t\\n**Implementation :**\\n\\'\\'\\'\\n\\n\\tclass Solution:\\n    def networkBecomesIdle(self, edges: List[List[int]], patience: List[int]) -> int:\\n        \\n        graph = defaultdict(list)\\n        for e1,e2 in edges:\\n            graph[e1].append(e2)\\n            graph[e2].append(e1)\\n        \\n        dist = [-1]*len(graph)\\n        dist[0] = 0\\n        queue = [0]\\n        d = 0\\n        while queue:\\n            d+=2\\n            newq = []\\n            for u in queue:\\n                for v in graph[u]:\\n                    if dist[v]==-1:\\n                        dist[v]=d\\n                        newq.append(v)\\n            queue = newq\\n\\n        res = 0\\n        for d,p in zip(dist[1:],patience[1:]):\\n            k = d//p\\n            if(d%p==0):\\n                k-=1\\n                \\n            res = max(res,d+k*p)\\n            \\n        return res+1\\n\\t\\n### Thanks & Upvote if you got any help!!\\uD83E\\uDD1E",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "## IDEA:\\n\\n\\t* Build an adjency list.\\n\\t* BFS from the master node to get the shortest path from node to master.\\n\\t* Calculate when the last resent time is, and how long it will take to reach the server after that.\\n\\t\\n**Implementation :**\\n\\'\\'\\'\\n\\n\\tclass Solution:\\n    def networkBecomesIdle(self, edges: List[List[int]], patience: List[int]) -> int:\\n        \\n        graph = defaultdict(list)\\n        for e1,e2 in edges:\\n            graph[e1].append(e2)\\n            graph[e2].append(e1)\\n        \\n        dist = [-1]*len(graph)\\n        dist[0] = 0\\n        queue = [0]\\n        d = 0\\n        while queue:\\n            d+=2\\n            newq = []\\n            for u in queue:\\n                for v in graph[u]:\\n                    if dist[v]==-1:\\n                        dist[v]=d\\n                        newq.append(v)\\n            queue = newq\\n\\n        res = 0\\n        for d,p in zip(dist[1:],patience[1:]):\\n            k = d//p\\n            if(d%p==0):\\n                k-=1\\n                \\n            res = max(res,d+k*p)\\n            \\n        return res+1\\n\\t\\n### Thanks & Upvote if you got any help!!\\uD83E\\uDD1E",
                "codeTag": "Java"
            },
            {
                "id": 1524173,
                "title": "c-solution-with-detailed-explanation",
                "content": "**Idea:**\\nEach data server sends the first message and then keeps sending messages until the first message has come back to the server. So we can try to find the time at which the last message sent by the server comes back to it. \\nTo do this we define the distance of a node `i` from node `0` to be `D` which we find using breath first search and `P` is its patience. We can observe that after the first message has left the server would send `(2D - 1) / P` extra messages which we define as `Q`. Now that last message would have been sent at time `PQ` and would take time `2D` to come back. The next second no more message sent by that server would be there in the network. \\nHence, we can take the max of `PQ + 2D + 1` for all the nodes to get our answer.\\n\\n**Code:**\\n```cpp\\ntypedef pair<int, int> iPair;\\n\\nclass Solution {\\npublic:\\n    int networkBecomesIdle(vector<vector<int>>& edges, vector<int>& patience) {\\n        int n = patience.size();\\n        vector<vector<int>> G(n);\\n        for(vector<int>& e : edges) {\\n            G[e[0]].push_back(e[1]);\\n            G[e[1]].push_back(e[0]);\\n        }\\n        \\n        queue<iPair> q;\\n        vector<bool> vis(n, false);\\n        vis[0] = true;\\n        for(int v : G[0]) {\\n            q.push(make_pair(v, 1));\\n            vis[v] = true;\\n        }\\n        \\n        int res = 0;\\n        while(!q.empty()) {\\n            auto [u, D] = q.front();\\n            q.pop();\\n            int P = patience[u];\\n            int Q = (2 * D - 1) / P;\\n            res = max(res, P * Q + 2 * D + 1);\\n            for(int v : G[u]) {\\n                if(!vis[v]) {\\n                    q.push(make_pair(v, D + 1));\\n                    vis[v] = true;\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```cpp\\ntypedef pair<int, int> iPair;\\n\\nclass Solution {\\npublic:\\n    int networkBecomesIdle(vector<vector<int>>& edges, vector<int>& patience) {\\n        int n = patience.size();\\n        vector<vector<int>> G(n);\\n        for(vector<int>& e : edges) {\\n            G[e[0]].push_back(e[1]);\\n            G[e[1]].push_back(e[0]);\\n        }\\n        \\n        queue<iPair> q;\\n        vector<bool> vis(n, false);\\n        vis[0] = true;\\n        for(int v : G[0]) {\\n            q.push(make_pair(v, 1));\\n            vis[v] = true;\\n        }\\n        \\n        int res = 0;\\n        while(!q.empty()) {\\n            auto [u, D] = q.front();\\n            q.pop();\\n            int P = patience[u];\\n            int Q = (2 * D - 1) / P;\\n            res = max(res, P * Q + 2 * D + 1);\\n            for(int v : G[u]) {\\n                if(!vis[v]) {\\n                    q.push(make_pair(v, D + 1));\\n                    vis[v] = true;\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1524163,
                "title": "c-simple-bfs-maths-comments-o-n",
                "content": "```\\n\\n\\n/*\\nWhy BFS and on what BFS is applied?\\n\\n- BFS is applied on nodes / data servers and master server\\n\\n- We need nearest distance of each data servers with master server which can be done by BFS easily in O(n+e) where n=no of nodes, e=no of edges  \\n- For each data server we just need to find the when the last generated message will come back\\n\\n    - In order to find when last  generated message will come back ?\\n       1 Find instant at which  when first  generated message will come back\\n       2 Then we can find instant at which when last message was generated\\n\\t   3. Then  find instant at which when last message was received back  \\n\\n*/\\n\\nclass Solution {\\npublic:\\n    \\n    int networkBecomesIdle(vector<vector<int>>& edges, vector<int>& patience) {\\n        \\n        int ans=0, n=edges.size();\\n        \\n        map<int,vector<int>>adj;\\n        \\n        for(auto e:edges){\\n            adj[e[0]].push_back(e[1]);\\n            adj[e[1]].push_back(e[0]);\\n        }\\n        \\n        vector<int>tim(n+1,0);\\n        vector<int>dis(n+1,-1);\\n        \\n        dis[0]=0;\\n        \\n        queue<int>q;\\n        q.push(0);\\n        while(!q.empty()){\\n            int node = q.front();\\n            q.pop();\\n            \\n            for(auto nbr:adj[node]){\\n                \\n                if(dis[nbr]==-1){\\n                    dis[nbr]=dis[node]+1;\\n                    q.push(nbr);\\n                    \\n                    \\n                    \\n                    int first_reply_back  = dis[nbr]*2;  //time instant at which we get our first reply back ie from now on no new mails generated \\n                    \\n                    int last_msg_generate = first_reply_back - (first_reply_back % patience[nbr]);//so this is the time instant at which last message is generated \\n                        \\n                    \\n                    if(first_reply_back % patience[nbr] ==0) //this step is just a  mathematical adjustment \\n                    last_msg_generate -= patience[nbr];\\n                    \\n                    int last_msg_back = last_msg_generate + dis[nbr]*2; // this is the instant at which last message generated by this node will come back \\n                    \\n                    ans = max(ans, last_msg_back+1); //so according to this server from \"last_msg_back+1\" instant network should be idle \\n                }\\n            }\\n        }\\n        \\n        return ans;\\n        \\n        \\n        \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n\\n\\n/*\\nWhy BFS and on what BFS is applied?\\n\\n- BFS is applied on nodes / data servers and master server\\n\\n- We need nearest distance of each data servers with master server which can be done by BFS easily in O(n+e) where n=no of nodes, e=no of edges  \\n- For each data server we just need to find the when the last generated message will come back\\n\\n    - In order to find when last  generated message will come back ?\\n       1 Find instant at which  when first  generated message will come back\\n       2 Then we can find instant at which when last message was generated\\n\\t   3. Then  find instant at which when last message was received back  \\n\\n*/\\n\\nclass Solution {\\npublic:\\n    \\n    int networkBecomesIdle(vector<vector<int>>& edges, vector<int>& patience) {\\n        \\n        int ans=0, n=edges.size();\\n        \\n        map<int,vector<int>>adj;\\n        \\n        for(auto e:edges){\\n            adj[e[0]].push_back(e[1]);\\n            adj[e[1]].push_back(e[0]);\\n        }\\n        \\n        vector<int>tim(n+1,0);\\n        vector<int>dis(n+1,-1);\\n        \\n        dis[0]=0;\\n        \\n        queue<int>q;\\n        q.push(0);\\n        while(!q.empty()){\\n            int node = q.front();\\n            q.pop();\\n            \\n            for(auto nbr:adj[node]){\\n                \\n                if(dis[nbr]==-1){\\n                    dis[nbr]=dis[node]+1;\\n                    q.push(nbr);\\n                    \\n                    \\n                    \\n                    int first_reply_back  = dis[nbr]*2;  //time instant at which we get our first reply back ie from now on no new mails generated \\n                    \\n                    int last_msg_generate = first_reply_back - (first_reply_back % patience[nbr]);//so this is the time instant at which last message is generated \\n                        \\n                    \\n                    if(first_reply_back % patience[nbr] ==0) //this step is just a  mathematical adjustment \\n                    last_msg_generate -= patience[nbr];\\n                    \\n                    int last_msg_back = last_msg_generate + dis[nbr]*2; // this is the instant at which last message generated by this node will come back \\n                    \\n                    ans = max(ans, last_msg_back+1); //so according to this server from \"last_msg_back+1\" instant network should be idle \\n                }\\n            }\\n        }\\n        \\n        return ans;\\n        \\n        \\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1524155,
                "title": "java-concise-bfs",
                "content": "1. Find the distance from 0 to other points\\n2. Caculate time\\n```\\nclass Solution {\\n    public int networkBecomesIdle(int[][] edges, int[] patience) {\\n        Map<Integer, List<Integer>> g = new HashMap<>();\\n        int n = patience.length;\\n        for (int i = 0; i < n; i++) {\\n            g.put(i, new ArrayList<>());\\n        }\\n        for (int[] e : edges) {\\n            g.get(e[0]).add(e[1]);\\n            g.get(e[1]).add(e[0]);\\n        }\\n        int[] visited = new int[n]; // record seconds\\n        Arrays.fill(visited, -1);\\n        Queue<Integer> q = new LinkedList<>();\\n        visited[0] = 0;\\n        q.add(0);\\n        int seconds = 0;\\n        while (!q.isEmpty()) {\\n            int size = q.size();\\n            seconds++;\\n            for (int i = 0; i < size; i++) {\\n                int t = q.poll();\\n                List<Integer> nei = g.get(t);\\n                for (int k : nei) {\\n                    if (visited[k] == -1) {\\n                        q.add(k);\\n                        visited[k] = seconds;\\n                    }\\n                }\\n            }\\n        }\\n        int max = 0;\\n        for (int i = 1; i < n; i++) {\\n            int travelTime = visited[i] * 2; \\n            int k = travelTime / patience[i]; // how many messages send after first message\\n            if (k * patience[i] == travelTime) { // at 1st reply received time we don\\'t send\\n                k--;\\n            }\\n            int totalTime = k * patience[i] + travelTime;\\n            max = Math.max(totalTime, max);\\n            \\n        }\\n        return max + 1;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int networkBecomesIdle(int[][] edges, int[] patience) {\\n        Map<Integer, List<Integer>> g = new HashMap<>();\\n        int n = patience.length;\\n        for (int i = 0; i < n; i++) {\\n            g.put(i, new ArrayList<>());\\n        }\\n        for (int[] e : edges) {\\n            g.get(e[0]).add(e[1]);\\n            g.get(e[1]).add(e[0]);\\n        }\\n        int[] visited = new int[n]; // record seconds\\n        Arrays.fill(visited, -1);\\n        Queue<Integer> q = new LinkedList<>();\\n        visited[0] = 0;\\n        q.add(0);\\n        int seconds = 0;\\n        while (!q.isEmpty()) {\\n            int size = q.size();\\n            seconds++;\\n            for (int i = 0; i < size; i++) {\\n                int t = q.poll();\\n                List<Integer> nei = g.get(t);\\n                for (int k : nei) {\\n                    if (visited[k] == -1) {\\n                        q.add(k);\\n                        visited[k] = seconds;\\n                    }\\n                }\\n            }\\n        }\\n        int max = 0;\\n        for (int i = 1; i < n; i++) {\\n            int travelTime = visited[i] * 2; \\n            int k = travelTime / patience[i]; // how many messages send after first message\\n            if (k * patience[i] == travelTime) { // at 1st reply received time we don\\'t send\\n                k--;\\n            }\\n            int totalTime = k * patience[i] + travelTime;\\n            max = Math.max(totalTime, max);\\n            \\n        }\\n        return max + 1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3998818,
                "title": "c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n public:\\n  int networkBecomesIdle(vector<vector<int>>& edges, vector<int>& patience) {\\n    const int n = patience.size();\\n    int ans = 0;\\n    vector<vector<int>> graph(n);\\n    queue<int> q{{0}};\\n    vector<int> dist(n, INT_MAX);  // dist[i] := dist(i, 0)\\n    dist[0] = 0;\\n\\n    for (const vector<int>& edge : edges) {\\n      const int u = edge[0];\\n      const int v = edge[1];\\n      graph[u].push_back(v);\\n      graph[v].push_back(u);\\n    }\\n\\n    while (!q.empty()) {\\n      for (int sz = q.size(); sz > 0; --sz) {\\n        const int u = q.front();\\n        q.pop();\\n        for (const int v : graph[u])\\n          if (dist[v] == INT_MAX) {\\n            dist[v] = dist[u] + 1;\\n            q.push(v);\\n          }\\n      }\\n    }\\n\\n    for (int i = 1; i < n; ++i) {\\n      const int numResending = (dist[i] * 2 - 1) / patience[i];\\n      const int lastResendingTime = patience[i] * numResending;\\n      const int lastArrivingTime = lastResendingTime + dist[i] * 2;\\n      ans = max(ans, lastArrivingTime);\\n    }\\n\\n    return ans + 1;\\n  }\\n};\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\n public:\\n  int networkBecomesIdle(vector<vector<int>>& edges, vector<int>& patience) {\\n    const int n = patience.size();\\n    int ans = 0;\\n    vector<vector<int>> graph(n);\\n    queue<int> q{{0}};\\n    vector<int> dist(n, INT_MAX);  // dist[i] := dist(i, 0)\\n    dist[0] = 0;\\n\\n    for (const vector<int>& edge : edges) {\\n      const int u = edge[0];\\n      const int v = edge[1];\\n      graph[u].push_back(v);\\n      graph[v].push_back(u);\\n    }\\n\\n    while (!q.empty()) {\\n      for (int sz = q.size(); sz > 0; --sz) {\\n        const int u = q.front();\\n        q.pop();\\n        for (const int v : graph[u])\\n          if (dist[v] == INT_MAX) {\\n            dist[v] = dist[u] + 1;\\n            q.push(v);\\n          }\\n      }\\n    }\\n\\n    for (int i = 1; i < n; ++i) {\\n      const int numResending = (dist[i] * 2 - 1) / patience[i];\\n      const int lastResendingTime = patience[i] * numResending;\\n      const int lastArrivingTime = lastResendingTime + dist[i] * 2;\\n      ans = max(ans, lastArrivingTime);\\n    }\\n\\n    return ans + 1;\\n  }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3985906,
                "title": "java-hashmap",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\n    public int networkBecomesIdle(int[][] edges, int[] patience) {\\n\\n        Queue<Integer> queue = new LinkedList<>();\\n        HashMap<Integer, List<Integer>> pre = new HashMap<>();\\n        Map<Integer, Integer> map = new HashMap<>();\\n        for(int i = 0; i < edges.length; i++){\\n            if(pre.containsKey(edges[i][0])){\\n                pre.get(edges[i][0]).add(edges[i][1]);\\n            }\\n            else{\\n                pre.put(edges[i][0], new ArrayList<>());\\n                pre.get(edges[i][0]).add(edges[i][1]);\\n            }\\n            if(pre.containsKey(edges[i][1])){\\n                pre.get(edges[i][1]).add(edges[i][0]);\\n            }\\n            else{\\n                pre.put(edges[i][1], new ArrayList<>());\\n                pre.get(edges[i][1]).add(edges[i][0]);\\n            }\\n        }\\n        queue.offer(0);\\n        map.put(0 ,0);\\n        boolean[] visit = new boolean[patience.length];\\n        visit[0] = true;\\n        while(!queue.isEmpty()){\\n            int key = queue.poll();\\n            List<Integer> candidate = pre.get(key);\\n            for(int i : candidate){\\n                if(visit[i] == true){\\n                    continue;\\n                }\\n                queue.offer(i);\\n                visit[i] = true;\\n                map.put(i, map.get(key) + 1);\\n            }\\n\\n        }\\n\\n        return helper(map, patience);\\n    }\\n\\n    private int helper(Map<Integer, Integer> map, int[] patience){\\n        int ans = Integer.MIN_VALUE;\\n        for(int key : map.keySet()){\\n            if(key == 0){\\n                continue;\\n            }\\n            int round = map.get(key) * 2;\\n            int pat = patience[key];\\n            int times;\\n            if(round % pat == 0){\\n                times = round / pat;\\n            }\\n            else{\\n                times = (round / pat) + 1;\\n            }\\n            int pre = (round * times) - ((round - pat) * (times - 1));\\n            ans = Math.max(ans, pre);\\n        }\\n        return ans+1;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Queue"
                ],
                "code": "```\\nclass Solution {\\n    public int networkBecomesIdle(int[][] edges, int[] patience) {\\n\\n        Queue<Integer> queue = new LinkedList<>();\\n        HashMap<Integer, List<Integer>> pre = new HashMap<>();\\n        Map<Integer, Integer> map = new HashMap<>();\\n        for(int i = 0; i < edges.length; i++){\\n            if(pre.containsKey(edges[i][0])){\\n                pre.get(edges[i][0]).add(edges[i][1]);\\n            }\\n            else{\\n                pre.put(edges[i][0], new ArrayList<>());\\n                pre.get(edges[i][0]).add(edges[i][1]);\\n            }\\n            if(pre.containsKey(edges[i][1])){\\n                pre.get(edges[i][1]).add(edges[i][0]);\\n            }\\n            else{\\n                pre.put(edges[i][1], new ArrayList<>());\\n                pre.get(edges[i][1]).add(edges[i][0]);\\n            }\\n        }\\n        queue.offer(0);\\n        map.put(0 ,0);\\n        boolean[] visit = new boolean[patience.length];\\n        visit[0] = true;\\n        while(!queue.isEmpty()){\\n            int key = queue.poll();\\n            List<Integer> candidate = pre.get(key);\\n            for(int i : candidate){\\n                if(visit[i] == true){\\n                    continue;\\n                }\\n                queue.offer(i);\\n                visit[i] = true;\\n                map.put(i, map.get(key) + 1);\\n            }\\n\\n        }\\n\\n        return helper(map, patience);\\n    }\\n\\n    private int helper(Map<Integer, Integer> map, int[] patience){\\n        int ans = Integer.MIN_VALUE;\\n        for(int key : map.keySet()){\\n            if(key == 0){\\n                continue;\\n            }\\n            int round = map.get(key) * 2;\\n            int pat = patience[key];\\n            int times;\\n            if(round % pat == 0){\\n                times = round / pat;\\n            }\\n            else{\\n                times = (round / pat) + 1;\\n            }\\n            int pre = (round * times) - ((round - pat) * (times - 1));\\n            ans = Math.max(ans, pre);\\n        }\\n        return ans+1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3965858,
                "title": "intuitive-dijkstra-math-c",
                "content": "```\\nclass Solution {\\npublic:\\n    int n;\\n    vector<int> dist;\\n\\n    void dijkstra(vector<vector<int>> &g){\\n        priority_queue<pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>>> pq;\\n\\n        pq.push({0, 0});\\n        dist[0] = 0;\\n        vector<int> vis(n ,0);\\n        while(!pq.empty()){\\n            auto [d, node] = pq.top();\\n            pq.pop();\\n            if(d > dist[node]) continue;\\n            vis[node] = 1;\\n\\n            for(int i: g[node]){\\n                if(vis[i]) continue;\\n                if(dist[i] > dist[node] + 1){\\n                    dist[i] = dist[node] + 1;\\n                    pq.push({dist[i], i});\\n                }\\n            }\\n        }\\n    }\\n    int networkBecomesIdle(vector<vector<int>>& edges, vector<int>& patience) {\\n        n = patience.size();\\n        dist.resize(n, 1e9);\\n        vector<vector<int>> g(n);\\n        for(auto v: edges){\\n            g[v[0]].push_back(v[1]);\\n            g[v[1]].push_back(v[0]);\\n        }\\n\\n        dijkstra(g);\\n\\n        // for(int i: dist)  cout << i << \" \";\\n\\n        int res = 0;\\n        for(int i = 1; i < n; i++){\\n            int replyTime = 2 * dist[i];\\n            int numberOfRequests = (int)ceil((double)replyTime / (double)patience[i]) - 1;\\n\\n            int lastSentRequest = numberOfRequests * patience[i];\\n\\n            res = max(res, lastSentRequest + replyTime + 1);\\n\\n        }\\n        return res;\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Graph"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int n;\\n    vector<int> dist;\\n\\n    void dijkstra(vector<vector<int>> &g){\\n        priority_queue<pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>>> pq;\\n\\n        pq.push({0, 0});\\n        dist[0] = 0;\\n        vector<int> vis(n ,0);\\n        while(!pq.empty()){\\n            auto [d, node] = pq.top();\\n            pq.pop();\\n            if(d > dist[node]) continue;\\n            vis[node] = 1;\\n\\n            for(int i: g[node]){\\n                if(vis[i]) continue;\\n                if(dist[i] > dist[node] + 1){\\n                    dist[i] = dist[node] + 1;\\n                    pq.push({dist[i], i});\\n                }\\n            }\\n        }\\n    }\\n    int networkBecomesIdle(vector<vector<int>>& edges, vector<int>& patience) {\\n        n = patience.size();\\n        dist.resize(n, 1e9);\\n        vector<vector<int>> g(n);\\n        for(auto v: edges){\\n            g[v[0]].push_back(v[1]);\\n            g[v[1]].push_back(v[0]);\\n        }\\n\\n        dijkstra(g);\\n\\n        // for(int i: dist)  cout << i << \" \";\\n\\n        int res = 0;\\n        for(int i = 1; i < n; i++){\\n            int replyTime = 2 * dist[i];\\n            int numberOfRequests = (int)ceil((double)replyTime / (double)patience[i]) - 1;\\n\\n            int lastSentRequest = numberOfRequests * patience[i];\\n\\n            res = max(res, lastSentRequest + replyTime + 1);\\n\\n        }\\n        return res;\\n\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3933319,
                "title": "bfs",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int networkBecomesIdle(vector<vector<int>>& edges, vector<int>& patience) {\\n        map<int,vector<int>>adj;\\n        \\n        priority_queue<pair<int,int>,vector<pair<int,int>>,greater<pair<int,int>>>pq;\\n        for(int i=0; i<edges.size(); i++){\\n            adj[edges[i][0]].push_back(edges[i][1]);\\n            adj[edges[i][1]].push_back(edges[i][0]);\\n        }\\n        vector<int>dist(patience.size(),INT_MAX);\\n        pq.push({0,0});\\n        dist[0] = 0;\\n        while(!pq.empty()){\\n            int dis = pq.top().first;\\n            int node = pq.top().second;\\n            pq.pop();\\n            for(int i=0; i<adj[node].size(); i++){\\n                if(dis+1<dist[adj[node][i]]){\\n                    dist[adj[node][i]] = dis+1;\\n                    pq.push({dist[adj[node][i]],adj[node][i]});\\n\\n                }\\n            }}\\n            int ans= INT_MIN;\\n            for(int i=1; i<dist.size(); i++){\\n                int e=(dist[i]*2-1)/patience[i];\\n                int lastout = e*patience[i];\\n                int lastin = lastout+dist[i]*2;\\n                ans = max(ans,lastin);\\n            }\\n\\n        return ans+1;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int networkBecomesIdle(vector<vector<int>>& edges, vector<int>& patience) {\\n        map<int,vector<int>>adj;\\n        \\n        priority_queue<pair<int,int>,vector<pair<int,int>>,greater<pair<int,int>>>pq;\\n        for(int i=0; i<edges.size(); i++){\\n            adj[edges[i][0]].push_back(edges[i][1]);\\n            adj[edges[i][1]].push_back(edges[i][0]);\\n        }\\n        vector<int>dist(patience.size(),INT_MAX);\\n        pq.push({0,0});\\n        dist[0] = 0;\\n        while(!pq.empty()){\\n            int dis = pq.top().first;\\n            int node = pq.top().second;\\n            pq.pop();\\n            for(int i=0; i<adj[node].size(); i++){\\n                if(dis+1<dist[adj[node][i]]){\\n                    dist[adj[node][i]] = dis+1;\\n                    pq.push({dist[adj[node][i]],adj[node][i]});\\n\\n                }\\n            }}\\n            int ans= INT_MIN;\\n            for(int i=1; i<dist.size(); i++){\\n                int e=(dist[i]*2-1)/patience[i];\\n                int lastout = e*patience[i];\\n                int lastin = lastout+dist[i]*2;\\n                ans = max(ans,lastin);\\n            }\\n\\n        return ans+1;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3893056,
                "title": "python3-shortest-path",
                "content": "# Intuition\\n- Shortest Path to trace the distance to each vertex to calculcate the distance\\n\\n# Approach\\n- Shortest Path to calculate the time take to reach vertex\\n- Calculate the last packet that would leave the node due to no response\\n- Calculate it\\'s arrival\\n\\n# Complexity\\n- Time complexity:\\n- O(V^2) worst case\\n\\n- Space complexity:\\n- O(N)\\n# Code\\n```\\nclass Solution:\\n    def networkBecomesIdle(self, edges: List[List[int]], patience: List[int]) -> int:\\n\\n        graph = {}\\n        for i in range(len(edges)):\\n            if edges[i][0] not in graph:\\n                graph[edges[i][0]] = []\\n            if edges[i][1] not in graph:\\n                graph[edges[i][1]] = []            \\n            graph[edges[i][0]].append(edges[i][1])\\n            graph[edges[i][1]].append(edges[i][0])\\n\\n        def solve():\\n            heap = []\\n            dist = [float(\\'inf\\') for _ in range(len(patience))]\\n            dist[0] = 0\\n            heapq.heappush(heap,(0,0))\\n            while len(heap)!=0:\\n                # print(heap)\\n                ele = heapq.heappop(heap)\\n                ver = ele[0]\\n                dis = ele[1]\\n\\n                for n in graph[ver]:\\n                    if dis+1 < dist[n]:\\n                        dist[n] = dis+1\\n                        heapq.heappush(heap,(n,dis+1))\\n            \\n            maxx = -1\\n            print(dist)\\n            for i in range(1,len(patience)):\\n                t = 2*dist[i]\\n                _rS = patience[i]\\n                if t%_rS == 0:\\n                    times = (t//_rS)-1\\n                else:\\n                    times = t//_rS\\n                if times!=0:\\n                    arrival = times*_rS + t\\n                    maxx = max(maxx,arrival)\\n                else:\\n                    maxx = max(maxx,t)\\n            return maxx\\n        return solve()+1\\n        # return 2\\n\\n```",
                "solutionTags": [
                    "Python3",
                    "Shortest Path"
                ],
                "code": "```\\nclass Solution:\\n    def networkBecomesIdle(self, edges: List[List[int]], patience: List[int]) -> int:\\n\\n        graph = {}\\n        for i in range(len(edges)):\\n            if edges[i][0] not in graph:\\n                graph[edges[i][0]] = []\\n            if edges[i][1] not in graph:\\n                graph[edges[i][1]] = []            \\n            graph[edges[i][0]].append(edges[i][1])\\n            graph[edges[i][1]].append(edges[i][0])\\n\\n        def solve():\\n            heap = []\\n            dist = [float(\\'inf\\') for _ in range(len(patience))]\\n            dist[0] = 0\\n            heapq.heappush(heap,(0,0))\\n            while len(heap)!=0:\\n                # print(heap)\\n                ele = heapq.heappop(heap)\\n                ver = ele[0]\\n                dis = ele[1]\\n\\n                for n in graph[ver]:\\n                    if dis+1 < dist[n]:\\n                        dist[n] = dis+1\\n                        heapq.heappush(heap,(n,dis+1))\\n            \\n            maxx = -1\\n            print(dist)\\n            for i in range(1,len(patience)):\\n                t = 2*dist[i]\\n                _rS = patience[i]\\n                if t%_rS == 0:\\n                    times = (t//_rS)-1\\n                else:\\n                    times = t//_rS\\n                if times!=0:\\n                    arrival = times*_rS + t\\n                    maxx = max(maxx,arrival)\\n                else:\\n                    maxx = max(maxx,t)\\n            return maxx\\n        return solve()+1\\n        # return 2\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3871275,
                "title": "c-dijkstra-s-algorithm-priority-queue",
                "content": "# Intuition\\nwe need to calculate the time required for each data server to send its message to the master server and receive the reply. We can model the network as a graph, where the servers are nodes, and the message channels between them are edges. Since messages can pass any number of messages directly in one second, the edge weights can be set to 1.\\n\\n# Approach\\nTo solve the problem, we can use Dijkstra\\'s algorithm to find the minimum time required for each data server to reach the master server. We can then calculate the time of the last message each data server sends and the time of the last reply it receives. The overall result would be the maximum of all these times plus one, representing the earliest second when the network becomes idle.\\n\\n# Complexity\\nTime complexity: The time complexity of Dijkstra\\'s algorithm is O(Elog(V)), where E is the number of edges and V is the number of vertices (servers). Additionally, the loop to calculate the last message and last reply times takes O(n) time. Thus, the overall time complexity is O(Elog(V) + n), but since E is at most n^2 (in a fully connected graph), the time complexity can be approximated to O(n^2*log(n)).\\nSpace complexity: The space complexity is O(n) for storing the time vector and the adjacency list of the graph. The priority queue used in Dijkstra\\'s algorithm also requires additional space, but it won\\'t exceed O(n) in this case. Thus, the overall space complexity is O(n).\\n# Code\\n```\\nclass Solution {\\npublic:\\n    unordered_map<int, vector<pair<int,int>>> adj;\\n    priority_queue<pair<int,int>, vector<pair<int,int>>, greater<pair<int,int>>>pq;\\n    vector<int> time;\\n\\n    void buildgraph(vector<vector<int>>& edges){\\n        for(auto each : edges){\\n            adj[each[0]].push_back({each[1],1});\\n            adj[each[1]].push_back({each[0],1});\\n        }\\n    }\\n\\n    void calculate(int nodes){\\n        pq.push({0,0});\\n        while(!pq.empty()){\\n            auto [wt, vertex] = pq.top();\\n            pq.pop();\\n            for(auto [node, nodewt] : adj[vertex]){\\n                if(time[node] > (wt+ nodewt)){\\n                    time[node] = wt + nodewt;\\n                    pq.push({time[node], node});\\n                }\\n            }\\n        }\\n    }\\n\\n\\n    int networkBecomesIdle(vector<vector<int>>& edges, vector<int>& patience) {\\n        int nodes =  patience.size();\\n        time = vector<int>(nodes, INT_MAX);\\n        buildgraph(edges);\\n        time[0] = 0;\\n        calculate(nodes);\\n        int result = 0;\\n\\n        for(int i = 1 ; i < nodes ; ++i){\\n            time[i] *= 2 ; \\n            int lastmsg = ( (time[i]-1) / patience[i]);\\n            lastmsg = lastmsg * patience[i];\\n            int lastreply = max(lastmsg + time[i], time[i]);\\n            result = max(result, lastreply+1);\\n        }\\n        return result;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    unordered_map<int, vector<pair<int,int>>> adj;\\n    priority_queue<pair<int,int>, vector<pair<int,int>>, greater<pair<int,int>>>pq;\\n    vector<int> time;\\n\\n    void buildgraph(vector<vector<int>>& edges){\\n        for(auto each : edges){\\n            adj[each[0]].push_back({each[1],1});\\n            adj[each[1]].push_back({each[0],1});\\n        }\\n    }\\n\\n    void calculate(int nodes){\\n        pq.push({0,0});\\n        while(!pq.empty()){\\n            auto [wt, vertex] = pq.top();\\n            pq.pop();\\n            for(auto [node, nodewt] : adj[vertex]){\\n                if(time[node] > (wt+ nodewt)){\\n                    time[node] = wt + nodewt;\\n                    pq.push({time[node], node});\\n                }\\n            }\\n        }\\n    }\\n\\n\\n    int networkBecomesIdle(vector<vector<int>>& edges, vector<int>& patience) {\\n        int nodes =  patience.size();\\n        time = vector<int>(nodes, INT_MAX);\\n        buildgraph(edges);\\n        time[0] = 0;\\n        calculate(nodes);\\n        int result = 0;\\n\\n        for(int i = 1 ; i < nodes ; ++i){\\n            time[i] *= 2 ; \\n            int lastmsg = ( (time[i]-1) / patience[i]);\\n            lastmsg = lastmsg * patience[i];\\n            int lastreply = max(lastmsg + time[i], time[i]);\\n            result = max(result, lastreply+1);\\n        }\\n        return result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3866736,
                "title": "java-hop-distance-graph-level-order-traversal-math-formula",
                "content": "# Intuition\\nFind #hops for each server from main server\\n\\n# Approach\\n- Graph\\n- level order travseral to get hop distance\\n- formula to get max time server channel will stay busy\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int networkBecomesIdle(int[][] edges, int[] delay) {\\n        int n = delay.length;\\n        HashMap<Integer, List<Integer>> net = new HashMap<>();\\n\\n        for(int i = 0; i<edges.length; i++) {\\n            List<Integer> s1 = net.getOrDefault(edges[i][0], new ArrayList<>());\\n            List<Integer> s2 = net.getOrDefault(edges[i][1], new ArrayList<>());\\n            s1.add(edges[i][1]);\\n            s2.add(edges[i][0]);\\n            net.put(edges[i][0], s1);\\n            net.put(edges[i][1], s2);\\n        }\\n\\n        //Get hop distance for each server to root server\\n        int []hop = new int[n];\\n        Queue<Integer> server = new LinkedList<>();\\n        server.add(0);  \\n        hop[0] = 0;      \\n        int hc = 0;\\n        while(!server.isEmpty()){\\n            int len=server.size();\\n            hc ++;\\n            for (int i= 0; i <len; i++) {\\n                int node = server.remove();\\n                for (int x: net.get(node)) {\\n                    if (x == 0 || hop[x] != 0) {\\n                        continue;\\n                    }\\n                    server.add(x);\\n                    hop[x] = hc;\\n                }\\n            }\\n        }\\n\\n        int maxHop = 0;\\n        for(int i=1; i<n; i++) {\\n            int totalHop = hop[i]*2;\\n            if(totalHop > delay[i]) {\\n                //# of resends happen during first msg reply will reach\\n                int resend = (int)(totalHop-1) / delay[i];\\n                totalHop += (delay[i]*resend); //Extra time needed till all resent msg reply reaches\\n            }\\n            maxHop = Math.max(maxHop, totalHop);\\n        }\\n        return maxHop +1;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Math",
                    "Graph"
                ],
                "code": "```\\nclass Solution {\\n    public int networkBecomesIdle(int[][] edges, int[] delay) {\\n        int n = delay.length;\\n        HashMap<Integer, List<Integer>> net = new HashMap<>();\\n\\n        for(int i = 0; i<edges.length; i++) {\\n            List<Integer> s1 = net.getOrDefault(edges[i][0], new ArrayList<>());\\n            List<Integer> s2 = net.getOrDefault(edges[i][1], new ArrayList<>());\\n            s1.add(edges[i][1]);\\n            s2.add(edges[i][0]);\\n            net.put(edges[i][0], s1);\\n            net.put(edges[i][1], s2);\\n        }\\n\\n        //Get hop distance for each server to root server\\n        int []hop = new int[n];\\n        Queue<Integer> server = new LinkedList<>();\\n        server.add(0);  \\n        hop[0] = 0;      \\n        int hc = 0;\\n        while(!server.isEmpty()){\\n            int len=server.size();\\n            hc ++;\\n            for (int i= 0; i <len; i++) {\\n                int node = server.remove();\\n                for (int x: net.get(node)) {\\n                    if (x == 0 || hop[x] != 0) {\\n                        continue;\\n                    }\\n                    server.add(x);\\n                    hop[x] = hc;\\n                }\\n            }\\n        }\\n\\n        int maxHop = 0;\\n        for(int i=1; i<n; i++) {\\n            int totalHop = hop[i]*2;\\n            if(totalHop > delay[i]) {\\n                //# of resends happen during first msg reply will reach\\n                int resend = (int)(totalHop-1) / delay[i];\\n                totalHop += (delay[i]*resend); //Extra time needed till all resent msg reply reaches\\n            }\\n            maxHop = Math.max(maxHop, totalHop);\\n        }\\n        return maxHop +1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3832937,
                "title": "c-depth-first-serach-explanation-in-detail",
                "content": "# Approach\\nWe can find for each server how much time it takes to send and receive a message. For example, server i sends a message at second 0 and receive it at second 10. Since sending a message and receiving it back take equal amount of time, We can send a message from server i to master server 0 in 5 seconds. In one second a message travels one vertex, then there are 5 vertices between the master server and this server.\\n\\nNow let\\'s say we have a server whose patience time is 3. And the number of vertices between this server and the master server  is 3. Then  the message sent by this server reaches the master server in 3 seconds and the master server sends the message back to this server in 3 seconds. In total, This server receive back a message in 6 seconds. Server has a patience time of 3 seconds after which it resends another message. Let\\'s say this server sends the first message, and after 3 seconds elapsed, it runs out of patience time and send the second message. After another 3 seconds, we receive the first message we send and stop resending any more messages. \\nNow we know that it has passed 6 seconds since we sent the first message. Now we just have to wait for the last message to come back to this server. At this point we have to determine how much time the last message has traveled. Since we sent the last message at second 3 and after 3 seconds we receive the first message, we come to know that the last message we sent must have travled 3 seconds of its total 6-second travle time. So that means after 6 - 3 = 3 seconds we will receive the very last message and then the sever becomes idle. \\n\\nUntil the server receives the first message it sent, we may send several other messages. However, we are only concerned with the last message we sent because it will be the last one to return to the server. We have to wait until we receive that last message, so we won\\'t be idle during that time.\\n\\n\\nSo we need to find the total time for a server to send and receive back a message and the time we wait for the last message sent by the server come back to us. \\n\\n\\n\\nWe do this for every server and take the maximum of them. \\n\\n\\n\\n# Code\\n```\\n\\n#define vv std::vector\\nclass Solution {\\npublic:\\n    int networkBecomesIdle(vector<vector<int>>& edges, vector<int>& patience)   {\\n        vv<vv<int>> graph(patience.size());\\n\\n        for (auto &edge : edges)\\n        {\\n            graph[edge[0]].push_back(edge[1]);\\n            graph[edge[1]].push_back(edge[0]);\\n        }\\n\\n        return dfs(graph, 0, patience);\\n    }\\nprivate:\\n    int dfs(vv<vv<int>> &graph, int v, vv<int>& patience)\\n{\\n    std::queue<int> q;\\n    vv<bool> visited(graph.size());\\n    visited[v] = true;\\n    q.push(v);\\n\\n    vv<int> numOfVertices(graph.size());\\n\\n    while (!q.empty())\\n    {\\n        v = q.front();\\n        q.pop();\\n        std::cout << v << \" \";\\n        for (int u : graph[v])\\n        {\\n            if (!visited[u])\\n            {\\n                numOfVertices[u] = 1 + numOfVertices[v];\\n                visited[u] = true;\\n                q.push(u);\\n            }\\n        }\\n    }\\n\\n    int ans = 0;\\n\\n    for(int i = 1; i < patience.size(); i++)\\n    {\\n        //2 * nodes + (2 * nodes - 1 ) // p * p\\n        ans = std::max(ans, 2 * numOfVertices[i] + ((2 * numOfVertices[i] - 1) / patience[i]) * patience[i]);\\n    }\\n\\n\\n    return ans + 1;\\n}\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n\\n#define vv std::vector\\nclass Solution {\\npublic:\\n    int networkBecomesIdle(vector<vector<int>>& edges, vector<int>& patience)   {\\n        vv<vv<int>> graph(patience.size());\\n\\n        for (auto &edge : edges)\\n        {\\n            graph[edge[0]].push_back(edge[1]);\\n            graph[edge[1]].push_back(edge[0]);\\n        }\\n\\n        return dfs(graph, 0, patience);\\n    }\\nprivate:\\n    int dfs(vv<vv<int>> &graph, int v, vv<int>& patience)\\n{\\n    std::queue<int> q;\\n    vv<bool> visited(graph.size());\\n    visited[v] = true;\\n    q.push(v);\\n\\n    vv<int> numOfVertices(graph.size());\\n\\n    while (!q.empty())\\n    {\\n        v = q.front();\\n        q.pop();\\n        std::cout << v << \" \";\\n        for (int u : graph[v])\\n        {\\n            if (!visited[u])\\n            {\\n                numOfVertices[u] = 1 + numOfVertices[v];\\n                visited[u] = true;\\n                q.push(u);\\n            }\\n        }\\n    }\\n\\n    int ans = 0;\\n\\n    for(int i = 1; i < patience.size(); i++)\\n    {\\n        //2 * nodes + (2 * nodes - 1 ) // p * p\\n        ans = std::max(ans, 2 * numOfVertices[i] + ((2 * numOfVertices[i] - 1) / patience[i]) * patience[i]);\\n    }\\n\\n\\n    return ans + 1;\\n}\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3733370,
                "title": "java-solution",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\n    public int networkBecomesIdle(int[][] edges, int[] patience) {\\n        ArrayList<ArrayList<Integer>> list = new ArrayList<>();\\n        int n = patience.length;\\n        for(int i=0 ; i<n ; i++){\\n            list.add(new ArrayList<>());\\n        }\\n        for(int e[]:edges){\\n            list.get(e[0]).add(e[1]);\\n            list.get(e[1]).add(e[0]);\\n        }\\n        int [] dist  = dij(list,n);\\n\\n        int max = 0;\\n        for(int i=1 ; i< n; i++){\\n            int time = 2*dist[i];\\n            int msg = time/patience[i];\\n            if(time%patience[i]==0){\\n                msg--;\\n            }\\n            max = Math.max((msg*patience[i])+(time),max);\\n        }\\n        return max+1;\\n        \\n    }\\n    int [] dij(ArrayList<ArrayList<Integer>> list , int n){\\n        int dist[] =new int[n];\\n        Arrays.fill(dist,-1);\\n        dist[0] = 0;\\n        Queue<Integer> q = new LinkedList<>();\\n        q.add(0);\\n        while(!q.isEmpty()){\\n            int u = q.poll();\\n            for(int v: list.get(u)){\\n                if(dist[v]==-1){\\n                    dist[v] = dist[u] +1;\\n                    q.add(v);\\n                }\\n            }\\n        }\\n        return dist;\\n    }\\n    \\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Breadth-First Search",
                    "Graph",
                    "Shortest Path"
                ],
                "code": "```\\nclass Solution {\\n    public int networkBecomesIdle(int[][] edges, int[] patience) {\\n        ArrayList<ArrayList<Integer>> list = new ArrayList<>();\\n        int n = patience.length;\\n        for(int i=0 ; i<n ; i++){\\n            list.add(new ArrayList<>());\\n        }\\n        for(int e[]:edges){\\n            list.get(e[0]).add(e[1]);\\n            list.get(e[1]).add(e[0]);\\n        }\\n        int [] dist  = dij(list,n);\\n\\n        int max = 0;\\n        for(int i=1 ; i< n; i++){\\n            int time = 2*dist[i];\\n            int msg = time/patience[i];\\n            if(time%patience[i]==0){\\n                msg--;\\n            }\\n            max = Math.max((msg*patience[i])+(time),max);\\n        }\\n        return max+1;\\n        \\n    }\\n    int [] dij(ArrayList<ArrayList<Integer>> list , int n){\\n        int dist[] =new int[n];\\n        Arrays.fill(dist,-1);\\n        dist[0] = 0;\\n        Queue<Integer> q = new LinkedList<>();\\n        q.add(0);\\n        while(!q.isEmpty()){\\n            int u = q.poll();\\n            for(int v: list.get(u)){\\n                if(dist[v]==-1){\\n                    dist[v] = dist[u] +1;\\n                    q.add(v);\\n                }\\n            }\\n        }\\n        return dist;\\n    }\\n    \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3717334,
                "title": "golang-bfs-solution",
                "content": "# Code\\n```\\nfunc getTime(dist, patience int) int {\\n    timetaken := 2*dist\\n    if patience > timetaken {\\n        return timetaken+1\\n    }\\n    extraMessages := (timetaken-1)/patience\\n    lastMessage := extraMessages * patience\\n    return lastMessage + timetaken + 1\\n}\\n\\nfunc networkBecomesIdle(edges [][]int, patience []int) int {\\n    adjList := map[int][]int{}\\n    for _, edge := range edges {\\n        adjList[edge[0]] = append(adjList[edge[0]], edge[1])\\n        adjList[edge[1]] = append(adjList[edge[1]], edge[0])\\n    }\\n    visited := make([]bool, len(patience))\\n    visited[0] = true\\n    queue := []int{}\\n    var maxTime, level int\\n    for _, el := range adjList[0] {\\n        queue = append(queue, el)\\n    }\\n    for len(queue) > 0 {\\n        var tmp []int\\n        level++\\n        for len(queue) > 0 {\\n            el := queue[0]\\n            queue = queue[1:]\\n            if visited[el] {\\n                continue\\n            }\\n            visited[el] = true\\n            maxTime = max(maxTime, getTime(level, patience[el]))\\n            if len(adjList[el]) > 0 {\\n                for _, serv := range adjList[el] {\\n                    if !visited[serv] {\\n                        tmp = append(tmp, serv)\\n                    }\\n                }\\n            }\\n        }\\n        queue = tmp\\n    }\\n    return maxTime\\n}\\n\\nfunc max(a, b int) int {\\n    if a > b { return a }\\n    return b\\n}\\n```",
                "solutionTags": [
                    "Go",
                    "Breadth-First Search"
                ],
                "code": "```\\nfunc getTime(dist, patience int) int {\\n    timetaken := 2*dist\\n    if patience > timetaken {\\n        return timetaken+1\\n    }\\n    extraMessages := (timetaken-1)/patience\\n    lastMessage := extraMessages * patience\\n    return lastMessage + timetaken + 1\\n}\\n\\nfunc networkBecomesIdle(edges [][]int, patience []int) int {\\n    adjList := map[int][]int{}\\n    for _, edge := range edges {\\n        adjList[edge[0]] = append(adjList[edge[0]], edge[1])\\n        adjList[edge[1]] = append(adjList[edge[1]], edge[0])\\n    }\\n    visited := make([]bool, len(patience))\\n    visited[0] = true\\n    queue := []int{}\\n    var maxTime, level int\\n    for _, el := range adjList[0] {\\n        queue = append(queue, el)\\n    }\\n    for len(queue) > 0 {\\n        var tmp []int\\n        level++\\n        for len(queue) > 0 {\\n            el := queue[0]\\n            queue = queue[1:]\\n            if visited[el] {\\n                continue\\n            }\\n            visited[el] = true\\n            maxTime = max(maxTime, getTime(level, patience[el]))\\n            if len(adjList[el]) > 0 {\\n                for _, serv := range adjList[el] {\\n                    if !visited[serv] {\\n                        tmp = append(tmp, serv)\\n                    }\\n                }\\n            }\\n        }\\n        queue = tmp\\n    }\\n    return maxTime\\n}\\n\\nfunc max(a, b int) int {\\n    if a > b { return a }\\n    return b\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3717333,
                "title": "golang-bfs-solution",
                "content": "# Code\\n```\\nfunc getTime(dist, patience int) int {\\n    timetaken := 2*dist\\n    if patience > timetaken {\\n        return timetaken+1\\n    }\\n    extraMessages := (timetaken-1)/patience\\n    lastMessage := extraMessages * patience\\n    return lastMessage + timetaken + 1\\n}\\n\\nfunc networkBecomesIdle(edges [][]int, patience []int) int {\\n    adjList := map[int][]int{}\\n    for _, edge := range edges {\\n        adjList[edge[0]] = append(adjList[edge[0]], edge[1])\\n        adjList[edge[1]] = append(adjList[edge[1]], edge[0])\\n    }\\n    visited := make([]bool, len(patience))\\n    visited[0] = true\\n    queue := []int{}\\n    var maxTime, level int\\n    for _, el := range adjList[0] {\\n        queue = append(queue, el)\\n    }\\n    for len(queue) > 0 {\\n        var tmp []int\\n        level++\\n        for len(queue) > 0 {\\n            el := queue[0]\\n            queue = queue[1:]\\n            if visited[el] {\\n                continue\\n            }\\n            visited[el] = true\\n            maxTime = max(maxTime, getTime(level, patience[el]))\\n            if len(adjList[el]) > 0 {\\n                for _, serv := range adjList[el] {\\n                    if !visited[serv] {\\n                        tmp = append(tmp, serv)\\n                    }\\n                }\\n            }\\n        }\\n        queue = tmp\\n    }\\n    return maxTime\\n}\\n\\nfunc max(a, b int) int {\\n    if a > b { return a }\\n    return b\\n}\\n```",
                "solutionTags": [
                    "Go",
                    "Breadth-First Search"
                ],
                "code": "```\\nfunc getTime(dist, patience int) int {\\n    timetaken := 2*dist\\n    if patience > timetaken {\\n        return timetaken+1\\n    }\\n    extraMessages := (timetaken-1)/patience\\n    lastMessage := extraMessages * patience\\n    return lastMessage + timetaken + 1\\n}\\n\\nfunc networkBecomesIdle(edges [][]int, patience []int) int {\\n    adjList := map[int][]int{}\\n    for _, edge := range edges {\\n        adjList[edge[0]] = append(adjList[edge[0]], edge[1])\\n        adjList[edge[1]] = append(adjList[edge[1]], edge[0])\\n    }\\n    visited := make([]bool, len(patience))\\n    visited[0] = true\\n    queue := []int{}\\n    var maxTime, level int\\n    for _, el := range adjList[0] {\\n        queue = append(queue, el)\\n    }\\n    for len(queue) > 0 {\\n        var tmp []int\\n        level++\\n        for len(queue) > 0 {\\n            el := queue[0]\\n            queue = queue[1:]\\n            if visited[el] {\\n                continue\\n            }\\n            visited[el] = true\\n            maxTime = max(maxTime, getTime(level, patience[el]))\\n            if len(adjList[el]) > 0 {\\n                for _, serv := range adjList[el] {\\n                    if !visited[serv] {\\n                        tmp = append(tmp, serv)\\n                    }\\n                }\\n            }\\n        }\\n        queue = tmp\\n    }\\n    return maxTime\\n}\\n\\nfunc max(a, b int) int {\\n    if a > b { return a }\\n    return b\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3643020,
                "title": "python-bfs",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nFind distance from each data node to master node, then use some math to calculate how long does it take for a data server to finish sending messages, taken into consideration its patience. \\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(N)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(N)\\n\\n# Code\\n```\\nclass Solution:\\n    def networkBecomesIdle(self, edges: List[List[int]], patience: List[int]) -> int:\\n        graph = defaultdict(list)\\n        for u,v in edges:\\n            graph[u].append(v)\\n            graph[v].append(u)\\n\\n        # find distance between each node and master node\\n        distances = defaultdict(int)\\n        bfs = [0]\\n        distance = -1\\n        visited = set()\\n        while bfs:\\n            distance += 1\\n            next_round = []\\n            for node in bfs:\\n                if node in visited:\\n                    continue\\n\\n                if node != 0:\\n                    distances[node] = distance\\n                \\n                visited.add(node)\\n                next_round.extend(graph[node])\\n            bfs = next_round\\n        \\n        # calculate idle time\\n        ans = 0\\n        for i, v in distances.items():\\n            round_trip = 2 * v\\n            remainder = round_trip % patience[i]\\n            if remainder == 0:\\n                subtrahend = patience[i]\\n            else:\\n                if patience[i] >= round_trip:\\n                    subtrahend = round_trip\\n                else:\\n                    subtrahend = remainder\\n\\n            ans = max(ans, round_trip + round_trip - subtrahend)\\n\\n        return ans + 1\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def networkBecomesIdle(self, edges: List[List[int]], patience: List[int]) -> int:\\n        graph = defaultdict(list)\\n        for u,v in edges:\\n            graph[u].append(v)\\n            graph[v].append(u)\\n\\n        # find distance between each node and master node\\n        distances = defaultdict(int)\\n        bfs = [0]\\n        distance = -1\\n        visited = set()\\n        while bfs:\\n            distance += 1\\n            next_round = []\\n            for node in bfs:\\n                if node in visited:\\n                    continue\\n\\n                if node != 0:\\n                    distances[node] = distance\\n                \\n                visited.add(node)\\n                next_round.extend(graph[node])\\n            bfs = next_round\\n        \\n        # calculate idle time\\n        ans = 0\\n        for i, v in distances.items():\\n            round_trip = 2 * v\\n            remainder = round_trip % patience[i]\\n            if remainder == 0:\\n                subtrahend = patience[i]\\n            else:\\n                if patience[i] >= round_trip:\\n                    subtrahend = round_trip\\n                else:\\n                    subtrahend = remainder\\n\\n            ans = max(ans, round_trip + round_trip - subtrahend)\\n\\n        return ans + 1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3593562,
                "title": "c-bfs",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int networkBecomesIdle(vector<vector<int>>& edges, vector<int>& pat) {\\n        int n = pat.size();\\n        vector<vector<int>> adj(n);\\n        for(auto &i:edges)\\n        {\\n            int a = i[0];\\n            int b = i[1];\\n            adj[a].push_back(b);\\n            adj[b].push_back(a);\\n        }\\n        vector<int> vis(n);\\n        vector<int> dis(n);\\n        dis[0] = 0;\\n        vis[0] = 1;\\n        queue<int> q;\\n        q.push(0);\\n        while(!q.empty())\\n        {\\n            int siz = q.size();\\n            for(int i=0;i<siz;i++)\\n            {\\n                int node = q.front();\\n                q.pop();\\n                for(auto &j:adj[node])\\n                {\\n                    if(!vis[j])\\n                    {\\n                        vis[j] = 1;\\n                        dis[j] = dis[node]+1;\\n                        q.push(j);\\n                    }\\n                }\\n            }\\n        }\\n        int ans = 0;\\n        for(int i=1;i<n;i++)\\n        {\\n            int tmp = dis[i];\\n            tmp*=2;\\n            if(pat[i]<=tmp)\\n            {\\n                int tmp1 = ceil((double)tmp/pat[i]);\\n                ans = max(ans,(tmp1-1)*pat[i]+tmp+1);\\n            }\\n            else\\n            {\\n                ans = max(ans,tmp+1);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int networkBecomesIdle(vector<vector<int>>& edges, vector<int>& pat) {\\n        int n = pat.size();\\n        vector<vector<int>> adj(n);\\n        for(auto &i:edges)\\n        {\\n            int a = i[0];\\n            int b = i[1];\\n            adj[a].push_back(b);\\n            adj[b].push_back(a);\\n        }\\n        vector<int> vis(n);\\n        vector<int> dis(n);\\n        dis[0] = 0;\\n        vis[0] = 1;\\n        queue<int> q;\\n        q.push(0);\\n        while(!q.empty())\\n        {\\n            int siz = q.size();\\n            for(int i=0;i<siz;i++)\\n            {\\n                int node = q.front();\\n                q.pop();\\n                for(auto &j:adj[node])\\n                {\\n                    if(!vis[j])\\n                    {\\n                        vis[j] = 1;\\n                        dis[j] = dis[node]+1;\\n                        q.push(j);\\n                    }\\n                }\\n            }\\n        }\\n        int ans = 0;\\n        for(int i=1;i<n;i++)\\n        {\\n            int tmp = dis[i];\\n            tmp*=2;\\n            if(pat[i]<=tmp)\\n            {\\n                int tmp1 = ceil((double)tmp/pat[i]);\\n                ans = max(ans,(tmp1-1)*pat[i]+tmp+1);\\n            }\\n            else\\n            {\\n                ans = max(ans,tmp+1);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3530822,
                "title": "rust-bfs-and-modular-arithmetic",
                "content": "# Intuition\\nBecause all connections are equally-weighted, the fastest route is just the route with the fewest steps. This can be determined using a breadth-first search, starting from the master node and working backwards until every node has been reached.\\n\\nThen, for every non-master server, we have a distance d and a patience p. The first message is sent at time 0, received at the master at time d, and the response is received by the sender at time 2d. However, the server will have continued to send messages at times [p, 2p, 3p, ... x] where x < 2d. Doing some math, we can work out that x = 2 * d - ((2d -1) % p) + 1.\\n\\nSince the last message is sent at time x, the response will be received at time x + 2d, and the server will become idle at x + 2d + 1. Plugging in x, we find that the server will become idle at 4d - r, where r = (2d-1) % p.\\n\\nThen we just take the maximum of these times and we\\'re done.\\n\\n# Complexity\\n- Time complexity: O(edges.len()), constructing the graph is the hardest part.\\n\\n- Space complexity: O(edges.len()). We need to store all edges in the graph. We also store a queue and distance vector, but these are all less than or equal to the number of edges because it\\'s a connected graph.\\n\\n# Code\\n```\\nuse std::collections::VecDeque;\\nimpl Solution {\\n    pub fn network_becomes_idle(edges: Vec<Vec<i32>>, patience: Vec<i32>) -> i32 {\\n        let n = patience.len();\\n        let graph = edges\\n        .into_iter()\\n        .map(|v| (v[0] as usize, v[1] as usize))\\n        .fold(vec![Vec::new(); n], |mut graph, (u, v)| {\\n            graph[u].push(v);\\n            graph[v].push(u);\\n            graph\\n        });\\n\\n        let mut distance_to_master = vec![-1; n];\\n        let mut queue = VecDeque::from([(0, 0)]);\\n\\n        while let Some((server, steps)) = queue.pop_front() {\\n            if distance_to_master[server] != -1 {\\n                continue;\\n            }\\n            distance_to_master[server] = steps;\\n            \\n            for &next_server in graph[server].iter() {\\n                queue.push_back((next_server, steps+1));\\n            }\\n        }\\n\\n        distance_to_master.into_iter().zip(patience.into_iter()).skip(1).map(|(d, p)| {\\n            let r = (2*d-1) % p;\\n            4*d - r\\n        }).max().unwrap()\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nuse std::collections::VecDeque;\\nimpl Solution {\\n    pub fn network_becomes_idle(edges: Vec<Vec<i32>>, patience: Vec<i32>) -> i32 {\\n        let n = patience.len();\\n        let graph = edges\\n        .into_iter()\\n        .map(|v| (v[0] as usize, v[1] as usize))\\n        .fold(vec![Vec::new(); n], |mut graph, (u, v)| {\\n            graph[u].push(v);\\n            graph[v].push(u);\\n            graph\\n        });\\n\\n        let mut distance_to_master = vec![-1; n];\\n        let mut queue = VecDeque::from([(0, 0)]);\\n\\n        while let Some((server, steps)) = queue.pop_front() {\\n            if distance_to_master[server] != -1 {\\n                continue;\\n            }\\n            distance_to_master[server] = steps;\\n            \\n            for &next_server in graph[server].iter() {\\n                queue.push_back((next_server, steps+1));\\n            }\\n        }\\n\\n        distance_to_master.into_iter().zip(patience.into_iter()).skip(1).map(|(d, p)| {\\n            let r = (2*d-1) % p;\\n            4*d - r\\n        }).max().unwrap()\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3527510,
                "title": "c-bfs-based-solution",
                "content": "# Intuition\\nThe problem simplifies once we think of one server and master server in isolation.\\n\\n# Approach\\n1. As the weight of edges is 1 hence we can compute single source shortest path using simple BFS.\\n2. Once computed the time when a given server becomes idle depends on whether the server recieves reply just before it was about to send a request i.e the condition whether 2*(distance between master and server)%2 ==0 or !=0.\\n3. if it is divisible by 2 hence just before the signal numbered ((2*distance[i])/patience[i]) was sent the reply was recieved. Hence the last signal was sent at (((2*distance[i])/patience[i])-1)*patience[i] which takes an additional 2*distance[i] come back.\\n4. else if it not divisible by 2 the last signal was sent at time (((2*distance[i])/patience[i]))*patience[i]. It takes an additional 2*distance[i] to come back.\\n5. We take maximum of such times over all servers except 0. We return 1 + maximum of such times. \\n\\n# Complexity\\n- Time complexity:\\nO(V+E)\\n\\n- Space complexity:\\nO(V+E)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int networkBecomesIdle(vector<vector<int>>& edges, vector<int>& patience) {\\n        int n=patience.size();\\n        vector<int>distance(n,INT_MAX);\\n        vector<vector<int>>adj(n);\\n        for(int i=0;i<edges.size();i++){\\n            adj[edges[i][0]].push_back(edges[i][1]);\\n            adj[edges[i][1]].push_back(edges[i][0]);\\n        }\\n        queue<int>q;\\n        q.push(0);\\n        int level=0;\\n        vector<int>visited(n,0);\\n        visited[0]=1;\\n        while(q.size()!=0){\\n            int len=q.size();\\n            for(int i=0;i<len;i++){\\n                int f=q.front();\\n                q.pop();\\n                distance[f]=level;\\n                for(int j=0;j<adj[f].size();j++){\\n                   if(visited[adj[f][j]]==0){\\n                       visited[adj[f][j]]=1;\\n                       q.push(adj[f][j]);\\n                   }\\n                }\\n            }\\n            level++;\\n        }\\n        int time=0;\\n        for(int i=1;i<n;i++){\\n            if((2*distance[i])%patience[i]!=0){\\n                time=max(time,((2*distance[i])/patience[i])*patience[i]+2*distance[i]);\\n            }\\n            else{\\n                time=max(time,((2*distance[i])/patience[i]-1)*patience[i]+2*distance[i]);\\n            }\\n        }\\n        return time+1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Math",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int networkBecomesIdle(vector<vector<int>>& edges, vector<int>& patience) {\\n        int n=patience.size();\\n        vector<int>distance(n,INT_MAX);\\n        vector<vector<int>>adj(n);\\n        for(int i=0;i<edges.size();i++){\\n            adj[edges[i][0]].push_back(edges[i][1]);\\n            adj[edges[i][1]].push_back(edges[i][0]);\\n        }\\n        queue<int>q;\\n        q.push(0);\\n        int level=0;\\n        vector<int>visited(n,0);\\n        visited[0]=1;\\n        while(q.size()!=0){\\n            int len=q.size();\\n            for(int i=0;i<len;i++){\\n                int f=q.front();\\n                q.pop();\\n                distance[f]=level;\\n                for(int j=0;j<adj[f].size();j++){\\n                   if(visited[adj[f][j]]==0){\\n                       visited[adj[f][j]]=1;\\n                       q.push(adj[f][j]);\\n                   }\\n                }\\n            }\\n            level++;\\n        }\\n        int time=0;\\n        for(int i=1;i<n;i++){\\n            if((2*distance[i])%patience[i]!=0){\\n                time=max(time,((2*distance[i])/patience[i])*patience[i]+2*distance[i]);\\n            }\\n            else{\\n                time=max(time,((2*distance[i])/patience[i]-1)*patience[i]+2*distance[i]);\\n            }\\n        }\\n        return time+1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3418139,
                "title": "java-solution-with-dijkstra-s",
                "content": "\\n\\n# Code\\n```\\nimport java.util.*; \\nclass Node implements Comparator<Node>\\n{\\n    private int v;\\n    private int weight;\\n    Node(int _v, int _w) { v = _v; weight = _w; }\\n    Node() {}\\n    int getV() { return v; }\\n    int getWeight() { return weight; }\\n    @Override\\n    public int compare(Node node1, Node node2) \\n    { \\n        if (node1.weight < node2.weight) \\n            return -1; \\n        if (node1.weight > node2.weight) \\n            return 1; \\n        return 0; \\n    } \\n}\\nclass Solution {\\n    public int shortestPath(int s, ArrayList<ArrayList<Node>> adj, int N,int patience[])\\n    {\\n        int dist[] = new int[N];\\n        for(int i = 0;i<N;i++) dist[i] = 100000000;\\n        dist[s] = 0; \\n        PriorityQueue<Node> pq = new PriorityQueue<Node>(N, new Node());\\n        pq.add(new Node(s, 0));\\n        while(pq.size() > 0) {\\n            Node node = pq.poll();\\n            \\n            for(Node it: adj.get(node.getV())) {\\n                if(dist[node.getV()] + it.getWeight() < dist[it.getV()]) {\\n                    dist[it.getV()] = dist[node.getV()] + it.getWeight(); \\n                    pq.add(new Node(it.getV(), dist[it.getV()]));\\n                }\\n            }\\n        }\\n        int res = Integer.MIN_VALUE;\\n        for(int i = 1; i < N ; i++) \\n        {\\n            int num = (2*dist[i])/patience[i];\\n            if((2*dist[i])%patience[i] == 0) \\n                num-=1;\\n            int time = num*patience[i];\\n            res = Math.max(res,time+ 2*dist[i]+1);\\n        }\\n        return res;\\n    }\\n    public int networkBecomesIdle(int[][] edges, int[] patience) {\\n        int n=patience.length;\\n        ArrayList<ArrayList<Node>>l=new ArrayList<>();\\n        for(int i=0;i<n;i++)l.add(new ArrayList<Node>());\\n        for(int r[]:edges)\\n        {\\n            l.get(r[0]).add(new Node(r[1],1));\\n            l.get(r[1]).add(new Node(r[0],1));\\n        }\\n        return shortestPath(0, l, n,patience); \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Graph"
                ],
                "code": "```\\nimport java.util.*; \\nclass Node implements Comparator<Node>\\n{\\n    private int v;\\n    private int weight;\\n    Node(int _v, int _w) { v = _v; weight = _w; }\\n    Node() {}\\n    int getV() { return v; }\\n    int getWeight() { return weight; }\\n    @Override\\n    public int compare(Node node1, Node node2) \\n    { \\n        if (node1.weight < node2.weight) \\n            return -1; \\n        if (node1.weight > node2.weight) \\n            return 1; \\n        return 0; \\n    } \\n}\\nclass Solution {\\n    public int shortestPath(int s, ArrayList<ArrayList<Node>> adj, int N,int patience[])\\n    {\\n        int dist[] = new int[N];\\n        for(int i = 0;i<N;i++) dist[i] = 100000000;\\n        dist[s] = 0; \\n        PriorityQueue<Node> pq = new PriorityQueue<Node>(N, new Node());\\n        pq.add(new Node(s, 0));\\n        while(pq.size() > 0) {\\n            Node node = pq.poll();\\n            \\n            for(Node it: adj.get(node.getV())) {\\n                if(dist[node.getV()] + it.getWeight() < dist[it.getV()]) {\\n                    dist[it.getV()] = dist[node.getV()] + it.getWeight(); \\n                    pq.add(new Node(it.getV(), dist[it.getV()]));\\n                }\\n            }\\n        }\\n        int res = Integer.MIN_VALUE;\\n        for(int i = 1; i < N ; i++) \\n        {\\n            int num = (2*dist[i])/patience[i];\\n            if((2*dist[i])%patience[i] == 0) \\n                num-=1;\\n            int time = num*patience[i];\\n            res = Math.max(res,time+ 2*dist[i]+1);\\n        }\\n        return res;\\n    }\\n    public int networkBecomesIdle(int[][] edges, int[] patience) {\\n        int n=patience.length;\\n        ArrayList<ArrayList<Node>>l=new ArrayList<>();\\n        for(int i=0;i<n;i++)l.add(new ArrayList<Node>());\\n        for(int r[]:edges)\\n        {\\n            l.get(r[0]).add(new Node(r[1],1));\\n            l.get(r[1]).add(new Node(r[0],1));\\n        }\\n        return shortestPath(0, l, n,patience); \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3338725,
                "title": "python-using-iterative-bfs",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution(object):\\n    def networkBecomesIdle(self, edges, patience):\\n        \"\"\"\\n        :type edges: List[List[int]]\\n        :type patience: List[int]\\n        :rtype: int\\n        \"\"\"\\n        from collections import defaultdict\\n\\n        adjacency = defaultdict(list)\\n        for u, v in edges:\\n            adjacency[u].append(v)\\n            adjacency[v].append(u)\\n\\n        shortest, bfs = {}, [(0, 0)]\\n        for pos, dist in bfs:\\n            if pos not in shortest:\\n                shortest[pos] = dist\\n                for node in adjacency[pos]:\\n                    bfs.append((node, dist+1))\\n\\n        res = 0\\n        for x in range(1, len(patience)):\\n            resent = patience[x]\\n            shutdown = shortest[x] * 2\\n            last = shutdown - 1\\n            last_resend = last // resent * resent\\n            pckt = last_resend + shutdown\\n            res = max(res, pckt)\\n        return res + 1\\n```",
                "solutionTags": [
                    "Python",
                    "Breadth-First Search",
                    "Graph"
                ],
                "code": "```\\nclass Solution(object):\\n    def networkBecomesIdle(self, edges, patience):\\n        \"\"\"\\n        :type edges: List[List[int]]\\n        :type patience: List[int]\\n        :rtype: int\\n        \"\"\"\\n        from collections import defaultdict\\n\\n        adjacency = defaultdict(list)\\n        for u, v in edges:\\n            adjacency[u].append(v)\\n            adjacency[v].append(u)\\n\\n        shortest, bfs = {}, [(0, 0)]\\n        for pos, dist in bfs:\\n            if pos not in shortest:\\n                shortest[pos] = dist\\n                for node in adjacency[pos]:\\n                    bfs.append((node, dist+1))\\n\\n        res = 0\\n        for x in range(1, len(patience)):\\n            resent = patience[x]\\n            shutdown = shortest[x] * 2\\n            last = shutdown - 1\\n            last_resend = last // resent * resent\\n            pckt = last_resend + shutdown\\n            res = max(res, pckt)\\n        return res + 1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3329047,
                "title": "using-bfs-c",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int networkBecomesIdle(vector<vector<int>>& edges, vector<int>& patience) {\\n        int n=patience.size();\\n        unordered_map <int,vector <int>> adj;\\n        unordered_map <int,int> visited;\\n        vector <int> distance(n);\\n        for(int i=0;i<edges.size();i++){\\n            adj[edges[i][0]].push_back(edges[i][1]);\\n            adj[edges[i][1]].push_back(edges[i][0]);\\n        }\\n        distance[0]=0;\\n        queue <int> q;\\n        q.push(0);\\n        visited[0]=1;\\n        while(!q.empty()){\\n            int tp=q.front();\\n            q.pop();\\n            for(auto &it:adj[tp]){\\n               if(visited[it] != 1){\\n                   distance[it]=distance[tp]+1;\\n                   q.push(it);\\n                   visited[it]=1;\\n               }\\n            }\\n        }\\n        int ans=0;\\n        for(int i=1;i<n;i++){\\n            if(patience[i] >= 2*distance[i]){\\n                ans=max(ans,(2*distance[i]));\\n            }\\n            else{\\n                int noms=((2*distance[i])-1)/patience[i];\\n                int lmst=(noms*patience[i]);\\n                int idletime=lmst+(2*distance[i]);\\n                ans=max(ans,idletime);\\n            }\\n        }\\n        // for(int i=0;i<n;i++){\\n        //     cout<<distance[i]<<\" \";\\n        // }\\n        // cout<<\"\\\\n\";\\n        return ans+1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int networkBecomesIdle(vector<vector<int>>& edges, vector<int>& patience) {\\n        int n=patience.size();\\n        unordered_map <int,vector <int>> adj;\\n        unordered_map <int,int> visited;\\n        vector <int> distance(n);\\n        for(int i=0;i<edges.size();i++){\\n            adj[edges[i][0]].push_back(edges[i][1]);\\n            adj[edges[i][1]].push_back(edges[i][0]);\\n        }\\n        distance[0]=0;\\n        queue <int> q;\\n        q.push(0);\\n        visited[0]=1;\\n        while(!q.empty()){\\n            int tp=q.front();\\n            q.pop();\\n            for(auto &it:adj[tp]){\\n               if(visited[it] != 1){\\n                   distance[it]=distance[tp]+1;\\n                   q.push(it);\\n                   visited[it]=1;\\n               }\\n            }\\n        }\\n        int ans=0;\\n        for(int i=1;i<n;i++){\\n            if(patience[i] >= 2*distance[i]){\\n                ans=max(ans,(2*distance[i]));\\n            }\\n            else{\\n                int noms=((2*distance[i])-1)/patience[i];\\n                int lmst=(noms*patience[i]);\\n                int idletime=lmst+(2*distance[i]);\\n                ans=max(ans,idletime);\\n            }\\n        }\\n        // for(int i=0;i<n;i++){\\n        //     cout<<distance[i]<<\" \";\\n        // }\\n        // cout<<\"\\\\n\";\\n        return ans+1;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3321334,
                "title": "secret-formula-bfs",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe distant data server is not always the culprit , it depends on the patience time .\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n**THIS FORMULA**\\n\\n`int cnt = (int)ceil((2*1.0*dist[i]) / patience[i]);\\nans = max(ans , (2*dist[i]) + (cnt - 1)*patience[i] + 1);`\\n\\nbasically 2*dist[i] gives the round trip time which is nothing but twice the shortest distance from master.\\n\\nby taking the ceil value we are getting the times the data server will resend before stoping \\n\\nfor the 1 resend it will be after (2*dist[i]) but after that it will only resend after patience[i] thats why (cnt - 1).\\n\\nI hope it helps!\\n\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(V+E)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(V + E)\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int networkBecomesIdle(vector<vector<int>>& edgess, vector<int>& patience) {\\n        int n = patience.size();\\n\\n        vector<vector<int>> edges(n + 1);\\n\\n        for(auto vec : edgess) {\\n            edges[vec[0]].push_back(vec[1]);\\n            edges[vec[1]].push_back(vec[0]);\\n        }\\n\\n        queue<int> q;\\n        q.push(0);\\n        int sz = 1 , lsz = 0 , lvl = 0;\\n        vector<int> vis(n + 1 , 0);\\n        vector<int> dist(n + 1 , 0);\\n\\n        while(!q.empty()) {\\n            lsz = 0;\\n\\n            while(sz--) {\\n                auto node = q.front();\\n                q.pop();\\n\\n                if(vis[node]) continue;\\n                dist[node] = lvl;\\n\\n                vis[node] = 1;\\n\\n                for(auto next : edges[node]) {\\n                    if(vis[next]) continue;\\n                    q.push(next);\\n                    lsz++;\\n                }\\n            }\\n            lvl++;\\n            sz = lsz;\\n        }\\n        lvl--;\\n        vector<pair<int , int>> vp;\\n        int ans = 0;\\n\\n        for(int i = 1 ; i < n ; i++) {\\n            int cnt = (int)ceil((2*1.0*dist[i]) / patience[i]);\\n            ans = max(ans , (2*dist[i]) + (cnt - 1)*patience[i] + 1);\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int networkBecomesIdle(vector<vector<int>>& edgess, vector<int>& patience) {\\n        int n = patience.size();\\n\\n        vector<vector<int>> edges(n + 1);\\n\\n        for(auto vec : edgess) {\\n            edges[vec[0]].push_back(vec[1]);\\n            edges[vec[1]].push_back(vec[0]);\\n        }\\n\\n        queue<int> q;\\n        q.push(0);\\n        int sz = 1 , lsz = 0 , lvl = 0;\\n        vector<int> vis(n + 1 , 0);\\n        vector<int> dist(n + 1 , 0);\\n\\n        while(!q.empty()) {\\n            lsz = 0;\\n\\n            while(sz--) {\\n                auto node = q.front();\\n                q.pop();\\n\\n                if(vis[node]) continue;\\n                dist[node] = lvl;\\n\\n                vis[node] = 1;\\n\\n                for(auto next : edges[node]) {\\n                    if(vis[next]) continue;\\n                    q.push(next);\\n                    lsz++;\\n                }\\n            }\\n            lvl++;\\n            sz = lsz;\\n        }\\n        lvl--;\\n        vector<pair<int , int>> vp;\\n        int ans = 0;\\n\\n        for(int i = 1 ; i < n ; i++) {\\n            int cnt = (int)ceil((2*1.0*dist[i]) / patience[i]);\\n            ans = max(ans , (2*dist[i]) + (cnt - 1)*patience[i] + 1);\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3276601,
                "title": "easy-to-understand-and-small-code",
                "content": "```\\nclass Solution {\\n    public int networkBecomesIdle(int[][] edges, int[] p) {\\n        int dis[] = new int[p.length];\\n        boolean reach[] = new boolean[p.length];\\n        List<List<Integer>> data = new ArrayList<>();\\n        for(int i=0;i<p.length;i++) data.add(new ArrayList<>());\\n        for(int row[]:edges) { data.get(row[0]).add(row[1]);data.get(row[1]).add(row[0]);}\\n        int index = 1,output = 0;\\n        Queue<Integer> info = new LinkedList<>();\\n        info.add(0);reach[0] = true;\\n        while(!info.isEmpty()){\\n            int n = info.size();\\n            while(n-->0){\\n                List<Integer> temp = data.get(info.remove());\\n                for(int i:temp) {if(!reach[i]) {dis[i] = index;info.add(i);reach[i]=true;}}\\n            }\\n            index++;\\n        }\\n        for(int i=1;i<p.length;i++) output = Math.max(output,2*dis[i]+((2*dis[i]-1)/p[i])*p[i]);\\n        return output+1;\\n    }\\n}",
                "solutionTags": [
                    "Java",
                    "Breadth-First Search"
                ],
                "code": "class Solution {\\n    public int networkBecomesIdle(int[][] edges, int[] p) {\\n        int dis[] = new int[p.length];\\n        boolean reach[] = new boolean[p.length];\\n        List<List<Integer>> data = new ArrayList<>();\\n        for(int i=0;i<p.length;i++) data.add(new ArrayList<>());\\n        for(int row[]:edges) { data.get(row[0]).add(row[1]);data.get(row[1]).add(row[0]);}",
                "codeTag": "Java"
            },
            {
                "id": 3245794,
                "title": "bfs-o-n-m",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nBfs and result is maximum of time of last messages\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n- O(n + m)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n- O(n + m)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\npublic class Solution {\\n    private void Bfs(List<int>[] graph, int start, int[] dist)\\n    {\\n        int n = graph.Length;\\n        bool[] visited = new bool[n];\\n        Queue<int> q = new Queue<int>();\\n        q.Enqueue(start);\\n        visited[start] = true;\\n        int count = 0;\\n        \\n        while (q.Count > 0)\\n        {\\n            int size = q.Count;\\n            \\n            count ++;\\n            while (size -- > 0)\\n            {\\n                int v = q.Dequeue();\\n                foreach (var u in graph[v])\\n                {\\n                    if (visited[u]) continue;\\n                    \\n                    visited[u] = true;\\n                    q.Enqueue(u);\\n                    dist[u] = count;\\n                }\\n            }\\n        }\\n    }\\n\\n    public int NetworkBecomesIdle(int[][] edges, int[] patience) {\\n        int n = patience.Length;\\n        List<int>[] graph = new List<int>[n];\\n        int[] dist = new int[n];\\n        \\n        for (int i = 0; i < n; i++)\\n        {\\n            graph[i] = new List<int>();\\n        }\\n        \\n        foreach (var edge in edges)\\n        {\\n            graph[edge[0]].Add(edge[1]);\\n            graph[edge[1]].Add(edge[0]);\\n        }\\n        \\n        Bfs(graph, 0, dist);\\n        \\n        int result = 0;\\n        \\n        for (int i = 1; i < n; i++)\\n        {\\n            int time = dist[i] * 2;\\n            int lastTime = time - (time - 1) % patience[i] + time;\\n            result = Math.Max(result, lastTime);\\n        }\\n        \\n        return result;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution {\\n    private void Bfs(List<int>[] graph, int start, int[] dist)\\n    {\\n        int n = graph.Length;\\n        bool[] visited = new bool[n];\\n        Queue<int> q = new Queue<int>();\\n        q.Enqueue(start);\\n        visited[start] = true;\\n        int count = 0;\\n        \\n        while (q.Count > 0)\\n        {\\n            int size = q.Count;\\n            \\n            count ++;\\n            while (size -- > 0)\\n            {\\n                int v = q.Dequeue();\\n                foreach (var u in graph[v])\\n                {\\n                    if (visited[u]) continue;\\n                    \\n                    visited[u] = true;\\n                    q.Enqueue(u);\\n                    dist[u] = count;\\n                }\\n            }\\n        }\\n    }\\n\\n    public int NetworkBecomesIdle(int[][] edges, int[] patience) {\\n        int n = patience.Length;\\n        List<int>[] graph = new List<int>[n];\\n        int[] dist = new int[n];\\n        \\n        for (int i = 0; i < n; i++)\\n        {\\n            graph[i] = new List<int>();\\n        }\\n        \\n        foreach (var edge in edges)\\n        {\\n            graph[edge[0]].Add(edge[1]);\\n            graph[edge[1]].Add(edge[0]);\\n        }\\n        \\n        Bfs(graph, 0, dist);\\n        \\n        int result = 0;\\n        \\n        for (int i = 1; i < n; i++)\\n        {\\n            int time = dist[i] * 2;\\n            int lastTime = time - (time - 1) % patience[i] + time;\\n            result = Math.Max(result, lastTime);\\n        }\\n        \\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3239567,
                "title": "bfs-with-explanation",
                "content": "# Intuition\\n\\nTime to master from data server and back is twice the path. So the time to idle for a data server i will be the time the last message returns from the master:\\n\\n \\nTTI[i] = For i data server, time to idle = last_m_t + path[i] * 2\\nlast_m_t = Last msg sent t = patience[i] * ((path[i]*2 - 1) // patience[i]).\\n\\nAs this is 1 weighted edge graph we do breadth first search from the master to get distance (path) to a data server. Use a queue for that (FIFO).  \\n\\n# Approach\\n\\nDo BFS and keep track of the max time to idle for a data server.\\n\\n# Complexity\\n- Time complexity:\\n\\n~V+E\\n\\n- Space complexity:\\n\\nO(V)\\n\\n# Code\\n```\\nfrom collections import deque\\nINF = float(\\'inf\\')\\nclass Solution:\\n    def networkBecomesIdle(self, edges: List[List[int]], patience: List[int]) -> int:\\n      res = 0\\n      n = len(patience)\\n      graph = [[] for _ in range(n)]\\n      for v,u in edges:\\n        graph[v] += [u]\\n        graph[u] += [v]\\n      q = deque([0])\\n      marked = [False] * n\\n      distto = [INF] * n\\n      distto[0] = 0\\n      while q:\\n        v = q.popleft()\\n        if marked[v]:\\n          continue\\n        marked[v] = True\\n        for u in graph[v]:\\n          if marked[u]:\\n            continue\\n          d = distto[v] + 1\\n          if distto[u] > d:\\n            distto[u] = d\\n            p = patience[u] \\n            res = max(\\n              res,\\n              p * ((d * 2 - 1) // p) + d*2 + 1\\n            )\\n            q.append(u)\\n      return res\\n\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nfrom collections import deque\\nINF = float(\\'inf\\')\\nclass Solution:\\n    def networkBecomesIdle(self, edges: List[List[int]], patience: List[int]) -> int:\\n      res = 0\\n      n = len(patience)\\n      graph = [[] for _ in range(n)]\\n      for v,u in edges:\\n        graph[v] += [u]\\n        graph[u] += [v]\\n      q = deque([0])\\n      marked = [False] * n\\n      distto = [INF] * n\\n      distto[0] = 0\\n      while q:\\n        v = q.popleft()\\n        if marked[v]:\\n          continue\\n        marked[v] = True\\n        for u in graph[v]:\\n          if marked[u]:\\n            continue\\n          d = distto[v] + 1\\n          if distto[u] > d:\\n            distto[u] = d\\n            p = patience[u] \\n            res = max(\\n              res,\\n              p * ((d * 2 - 1) // p) + d*2 + 1\\n            )\\n            q.append(u)\\n      return res\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3234974,
                "title": "c",
                "content": "```\\nclass Solution {\\npublic:\\n    int networkBecomesIdle(vector<vector<int>>& edges, vector<int>& patience) {\\n        int n = patience.size() ;\\n        vector<vector<int>>graph(n) ;\\n        vector<int>dist(n, -1) ;\\n        for(auto& e : edges){\\n            graph[e[0]].push_back(e[1]) ;\\n            graph[e[1]].push_back(e[0]) ;\\n        }\\n        dist[0] = 0 ;\\n        queue<int>q{{0}} ;\\n        while(!q.empty()){\\n            int cur = q.front() ;\\n            q.pop() ;\\n            for(auto& next : graph[cur]){\\n                if(dist[next] >= 0)\\n                    continue ;\\n                dist[next] = dist[cur] + 1 ;\\n                q.push(next) ;\\n            }\\n        }\\n        for(int i = 0 ;i < n; i++)\\n            cout << dist[i] << \",\" ;\\n        int ret = 0; \\n        for(int i = 1; i < n; i++){\\n            int time = 2*dist[i] ;\\n            if(2*dist[i]/patience[i] == 0)\\n                time += 1 ;\\n            else if(2*dist[i]%patience[i] == 0)\\n                time += (2*dist[i]/patience[i] - 1) * patience[i] + 1 ;\\n            else\\n                time += (2*dist[i]/patience[i]) * patience[i] + 1;\\n                \\n            ret = max(ret, time) ;\\n        }\\n        \\n        return ret ;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int networkBecomesIdle(vector<vector<int>>& edges, vector<int>& patience) {\\n        int n = patience.size() ;\\n        vector<vector<int>>graph(n) ;\\n        vector<int>dist(n, -1) ;\\n        for(auto& e : edges){\\n            graph[e[0]].push_back(e[1]) ;\\n            graph[e[1]].push_back(e[0]) ;\\n        }\\n        dist[0] = 0 ;\\n        queue<int>q{{0}} ;\\n        while(!q.empty()){\\n            int cur = q.front() ;\\n            q.pop() ;\\n            for(auto& next : graph[cur]){\\n                if(dist[next] >= 0)\\n                    continue ;\\n                dist[next] = dist[cur] + 1 ;\\n                q.push(next) ;\\n            }\\n        }\\n        for(int i = 0 ;i < n; i++)\\n            cout << dist[i] << \",\" ;\\n        int ret = 0; \\n        for(int i = 1; i < n; i++){\\n            int time = 2*dist[i] ;\\n            if(2*dist[i]/patience[i] == 0)\\n                time += 1 ;\\n            else if(2*dist[i]%patience[i] == 0)\\n                time += (2*dist[i]/patience[i] - 1) * patience[i] + 1 ;\\n            else\\n                time += (2*dist[i]/patience[i]) * patience[i] + 1;\\n                \\n            ret = max(ret, time) ;\\n        }\\n        \\n        return ret ;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3078980,
                "title": "java-bfs-math-solution",
                "content": "# Complexity\\n- Time complexity:\\nO(N)\\n\\n- Space complexity:\\nO(N)\\n\\n# Code\\n```\\nclass Solution {\\n    public int networkBecomesIdle(int[][] edges, int[] patience) {\\n        int res = 0, n = patience.length;\\n        int[] times = new int[n];\\n        Map<Integer, Set<Integer>> map = new HashMap<>();\\n        for (int i = 0; i < n; i++) map.put(i, new HashSet<Integer>());\\n        for (int[] edge : edges) {\\n            map.get(edge[0]).add(edge[1]);\\n            map.get(edge[1]).add(edge[0]);\\n        }\\n\\n        Queue<Integer> queue = new LinkedList<>();\\n        int step = 1;\\n        queue.offer(0);\\n        while (!queue.isEmpty()) {\\n            int size = queue.size();\\n            for (int i = 0; i < size; i++) {\\n                int cur = queue.poll();\\n                for (int next : map.get(cur)) {\\n                    if (times[next] == 0) {\\n                        times[next] = step * 2;\\n                        queue.offer(next);\\n                    }\\n                }\\n            }\\n            step++;\\n        }\\n\\n        for (int i = 1; i < n; i++) {\\n            int cur = 0;\\n            if (patience[i] >= times[i]) {\\n                cur = times[i];\\n            } else if (times[i] % patience[i] == 0) {\\n                cur = (times[i] / patience[i] - 1) * patience[i] + times[i];\\n            } else {\\n                cur = times[i] / patience[i] * patience[i] + times[i];\\n            }\\n            res = Math.max(res, cur);\\n        }\\n        return res + 1;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int networkBecomesIdle(int[][] edges, int[] patience) {\\n        int res = 0, n = patience.length;\\n        int[] times = new int[n];\\n        Map<Integer, Set<Integer>> map = new HashMap<>();\\n        for (int i = 0; i < n; i++) map.put(i, new HashSet<Integer>());\\n        for (int[] edge : edges) {\\n            map.get(edge[0]).add(edge[1]);\\n            map.get(edge[1]).add(edge[0]);\\n        }\\n\\n        Queue<Integer> queue = new LinkedList<>();\\n        int step = 1;\\n        queue.offer(0);\\n        while (!queue.isEmpty()) {\\n            int size = queue.size();\\n            for (int i = 0; i < size; i++) {\\n                int cur = queue.poll();\\n                for (int next : map.get(cur)) {\\n                    if (times[next] == 0) {\\n                        times[next] = step * 2;\\n                        queue.offer(next);\\n                    }\\n                }\\n            }\\n            step++;\\n        }\\n\\n        for (int i = 1; i < n; i++) {\\n            int cur = 0;\\n            if (patience[i] >= times[i]) {\\n                cur = times[i];\\n            } else if (times[i] % patience[i] == 0) {\\n                cur = (times[i] / patience[i] - 1) * patience[i] + times[i];\\n            } else {\\n                cur = times[i] / patience[i] * patience[i] + times[i];\\n            }\\n            res = Math.max(res, cur);\\n        }\\n        return res + 1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3057573,
                "title": "python-bfs-simple-solution-o-v-e",
                "content": "# Code\\n```\\nfrom collections import deque\\nfrom collections import defaultdict\\n\\nclass Solution:\\n    def networkBecomesIdle(self, edges: List[List[int]], patience: List[int]) -> int:\\n        G = defaultdict(list)\\n        que = deque([(0,0)])\\n        visited = set()\\n        for v,w in edges:\\n            G[v].append(w)\\n            G[w].append(v)\\n        dist = defaultdict(int)\\n        while que:\\n            d, v = que.popleft()\\n            if v in visited: continue\\n            dist[v] = d\\n            visited.add(v)\\n            for w in G[v]:\\n                que.append((d+1,w))\\n        n = len(patience)\\n        return max([((2*dist[v]-1)//patience[v]*patience[v] if patience[v] else 0) + 2*dist[v] for v in range(n)]) + 1\\n\\n\\n\\n\\n\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nfrom collections import deque\\nfrom collections import defaultdict\\n\\nclass Solution:\\n    def networkBecomesIdle(self, edges: List[List[int]], patience: List[int]) -> int:\\n        G = defaultdict(list)\\n        que = deque([(0,0)])\\n        visited = set()\\n        for v,w in edges:\\n            G[v].append(w)\\n            G[w].append(v)\\n        dist = defaultdict(int)\\n        while que:\\n            d, v = que.popleft()\\n            if v in visited: continue\\n            dist[v] = d\\n            visited.add(v)\\n            for w in G[v]:\\n                que.append((d+1,w))\\n        n = len(patience)\\n        return max([((2*dist[v]-1)//patience[v]*patience[v] if patience[v] else 0) + 2*dist[v] for v in range(n)]) + 1\\n\\n\\n\\n\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3025267,
                "title": "c-stepwise-thorough-solution-bfs-math",
                "content": "***Do Upvote if you find Informative.***\\n\\nGoal : Our Motive is to find the maximum time for which any data servers message stays alive \\n        in the server.\\n        \\n\\n1) Let\\'s create a tree out of it. It\\'s a wrong idea as it may create a loop and reach back to master server\\nin some cases. So what do we do. We will make a graph.\\n\\n2) And then we will find the shortest distance between the master server and \\nand the data server. We have to bfs for that. \\n\\n3) Calculate every data Server\\'s active time in the network.\\nThe one with the highest active time will be the answer. Because for that time the server is still\\npassing messages.\\n\\n```\\nclass Solution {\\npublic:\\n    int networkBecomesIdle(vector<vector<int>>& edges, vector<int>& patience) {\\n        \\n        // Implementation.\\n        // 1) Creation of Graph.\\n        int n = patience.size();\\n        vector<vector<int>> graph(n);\\n        \\n        for(int i = 0;i < edges.size();i++){\\n            int u = edges[i][0];\\n            int v = edges[i][1];\\n            graph[u].push_back(v);\\n            graph[v].push_back(u);\\n        }\\n        \\n        // time array works as visited array.\\n        vector<int> time(n, -1);\\n        time[0] = 0;\\n        queue<int> q;\\n        q.push(0);\\n        while(!q.empty()){\\n            int node = q.front();\\n            q.pop();\\n            \\n            for(auto child : graph[node]){\\n                // if the node is not visited.\\n                if(time[child] == -1){\\n                    time[child] = time[node] + 1;\\n                    q.push(child);\\n                }\\n            }\\n        }\\n        \\n        // Done computing minimum distance from master server to every data server.\\n        \\n        // Next job. Compute time for which every data server is active in the network.\\n        // Our aim is to find the time when all the data servers recieve the message and no data is circulated now.\\n        // The answer will be maximum among all the times which every server takes.\\n        \\n        int ans = 0;\\n        for(int i = 1;i < n;i++){\\n            // Now we have to first see, how many messages it would have sent.\\n            // It will continue to send messages, until it receives one.\\n            // When will it recieve?? at 2 * time[i].\\n            // From (0 to 2 * time[i] - 1) it will send the messages.\\n            // Now to calculate the messages sent you can easily divide it by patience[i].\\n            \\n            int messageTravelTime = 2 * time[i];\\n            int messagesSent = ((2*time[i] - 1)/patience[i]);\\n            int lastMessageSent = messagesSent * patience[i];\\n            int lastMessageRecieved = lastMessageSent + messageTravelTime;\\n            \\n            ans = max(ans, lastMessageRecieved);\\n        }\\n        \\n        return ans + 1; // Because after the last message was recieved, the next second the network becomes idle.\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Math",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int networkBecomesIdle(vector<vector<int>>& edges, vector<int>& patience) {\\n        \\n        // Implementation.\\n        // 1) Creation of Graph.\\n        int n = patience.size();\\n        vector<vector<int>> graph(n);\\n        \\n        for(int i = 0;i < edges.size();i++){\\n            int u = edges[i][0];\\n            int v = edges[i][1];\\n            graph[u].push_back(v);\\n            graph[v].push_back(u);\\n        }\\n        \\n        // time array works as visited array.\\n        vector<int> time(n, -1);\\n        time[0] = 0;\\n        queue<int> q;\\n        q.push(0);\\n        while(!q.empty()){\\n            int node = q.front();\\n            q.pop();\\n            \\n            for(auto child : graph[node]){\\n                // if the node is not visited.\\n                if(time[child] == -1){\\n                    time[child] = time[node] + 1;\\n                    q.push(child);\\n                }\\n            }\\n        }\\n        \\n        // Done computing minimum distance from master server to every data server.\\n        \\n        // Next job. Compute time for which every data server is active in the network.\\n        // Our aim is to find the time when all the data servers recieve the message and no data is circulated now.\\n        // The answer will be maximum among all the times which every server takes.\\n        \\n        int ans = 0;\\n        for(int i = 1;i < n;i++){\\n            // Now we have to first see, how many messages it would have sent.\\n            // It will continue to send messages, until it receives one.\\n            // When will it recieve?? at 2 * time[i].\\n            // From (0 to 2 * time[i] - 1) it will send the messages.\\n            // Now to calculate the messages sent you can easily divide it by patience[i].\\n            \\n            int messageTravelTime = 2 * time[i];\\n            int messagesSent = ((2*time[i] - 1)/patience[i]);\\n            int lastMessageSent = messagesSent * patience[i];\\n            int lastMessageRecieved = lastMessageSent + messageTravelTime;\\n            \\n            ans = max(ans, lastMessageRecieved);\\n        }\\n        \\n        return ans + 1; // Because after the last message was recieved, the next second the network becomes idle.\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2943249,
                "title": "java-bfs-solution",
                "content": "# Code\\n```\\nclass Solution {\\n    List<List<Integer>> graph;\\n    int n;\\n    public int networkBecomesIdle(int[][] edges, int[] patience) {\\n        n = patience.length;\\n        graph = new ArrayList<>();\\n        for(int i=0;i<n;i++){\\n            graph.add(new ArrayList<>());\\n        }\\n        for(int i=0;i<edges.length;i++){\\n            graph.get(edges[i][0]).add(edges[i][1]);\\n            graph.get(edges[i][1]).add(edges[i][0]);\\n        }\\n        return bfs(0, patience);\\n    }\\n    public int bfs(int start, int patience[]){\\n        Queue<Integer> q = new LinkedList<>();\\n        q.add(start);\\n        boolean visited[] = new boolean[n];\\n        visited[start]=true;\\n        int dist = 0;\\n        int maxSpentTime = -1;\\n        while(!q.isEmpty()){\\n            int size = q.size();\\n            dist++;\\n            while(size-->0){\\n                Integer nd = q.poll();\\n                for(Integer nb: graph.get(nd)){\\n                    if(!visited[nb]){\\n                        visited[nb]=true;\\n                        int lastSendSecond = (dist*2)%patience[nb]==0?(dist*2)-patience[nb]:(dist*2)-(dist*2)%patience[nb];\\n                        int totalTimeSpent = lastSendSecond + dist*2;\\n                        // System.out.printf(\"lastSendSecond=%s, totalTimeSpent=%s\\\\n\", lastSendSecond, totalTimeSpent);\\n                        maxSpentTime = Math.max(totalTimeSpent, maxSpentTime);\\n                        q.add(nb);\\n                    }\\n                }\\n            }\\n        }\\n        return maxSpentTime+1;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Math",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution {\\n    List<List<Integer>> graph;\\n    int n;\\n    public int networkBecomesIdle(int[][] edges, int[] patience) {\\n        n = patience.length;\\n        graph = new ArrayList<>();\\n        for(int i=0;i<n;i++){\\n            graph.add(new ArrayList<>());\\n        }\\n        for(int i=0;i<edges.length;i++){\\n            graph.get(edges[i][0]).add(edges[i][1]);\\n            graph.get(edges[i][1]).add(edges[i][0]);\\n        }\\n        return bfs(0, patience);\\n    }\\n    public int bfs(int start, int patience[]){\\n        Queue<Integer> q = new LinkedList<>();\\n        q.add(start);\\n        boolean visited[] = new boolean[n];\\n        visited[start]=true;\\n        int dist = 0;\\n        int maxSpentTime = -1;\\n        while(!q.isEmpty()){\\n            int size = q.size();\\n            dist++;\\n            while(size-->0){\\n                Integer nd = q.poll();\\n                for(Integer nb: graph.get(nd)){\\n                    if(!visited[nb]){\\n                        visited[nb]=true;\\n                        int lastSendSecond = (dist*2)%patience[nb]==0?(dist*2)-patience[nb]:(dist*2)-(dist*2)%patience[nb];\\n                        int totalTimeSpent = lastSendSecond + dist*2;\\n                        // System.out.printf(\"lastSendSecond=%s, totalTimeSpent=%s\\\\n\", lastSendSecond, totalTimeSpent);\\n                        maxSpentTime = Math.max(totalTimeSpent, maxSpentTime);\\n                        q.add(nb);\\n                    }\\n                }\\n            }\\n        }\\n        return maxSpentTime+1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2911900,
                "title": "python-using-dijkstra-s-algorithm",
                "content": "# Intuition\\nCalculate the distance from each node to destination node. And then go through each node\\'s patience to check last time the packet was sent using the distances found.\\n\\n# Approach\\nUsed Dijkstra\\'s algorithm \\n\\n# Complexity\\n- Time complexity:\\nTime complexity: (N + E + ElogE)\\nE: is needed to build the adjacents dictionary \\nElogE: we will go through each node at most as we are comparing the distance. For loop would iterate for E edges and logE for heap push.\\nN: Additionally, we iterate over patience list to go through each node to calculate the max idle time.\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nSpace complexity: (N + E)\\nN : Distance dict.\\nE : Adjancency dict.\\n\\n# Code\\n```\\nfrom collections import defaultdict\\nclass Solution:\\n    def networkBecomesIdle(self, edges: List[List[int]], patience: List[int]) -> int:\\n        \"\"\"\\n        Time complexity: (V + ElogE)\\n        Space complexity: (E + V)\\n        \"\"\"\\n        adj = defaultdict(list)\\n\\n        for s,d in edges:\\n            adj[s].append(d)\\n            adj[d].append(s)\\n        \\n        def djikstras(dest, vertices):\\n            heap = [(0, dest)]\\n            distances = {node: float(\\'inf\\') for node in range(vertices)}\\n            distances[dest] = 0\\n\\n            while heap:\\n                distance, node = heapq.heappop(heap)\\n                if distance > distances[node]:\\n                    continue\\n                for neighbor in adj[node]:\\n                    n_cost = distance + 1\\n                    if n_cost < distances[neighbor]:\\n                        distances[neighbor] = n_cost\\n                        heapq.heappush(heap, (n_cost, neighbor))\\n            \\n            return distances\\n        \\n        distances = djikstras(0, len(patience))\\n\\n        idle_time = float(\\'-inf\\')\\n\\n        for node in range(len(patience)):\\n            first_returned = distances[node] * 2\\n            if patience[node] < first_returned:\\n                if first_returned % patience[node] == 0:\\n                    last_recieved = first_returned*2 - patience[node]\\n                else:\\n                    last_recieved = first_returned*2 - first_returned%patience[node]\\n            else:\\n                last_recieved = first_returned\\n            \\n            idle_time = max(idle_time, last_recieved + 1)\\n        \\n        return idle_time\\n\\n\\n\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nfrom collections import defaultdict\\nclass Solution:\\n    def networkBecomesIdle(self, edges: List[List[int]], patience: List[int]) -> int:\\n        \"\"\"\\n        Time complexity: (V + ElogE)\\n        Space complexity: (E + V)\\n        \"\"\"\\n        adj = defaultdict(list)\\n\\n        for s,d in edges:\\n            adj[s].append(d)\\n            adj[d].append(s)\\n        \\n        def djikstras(dest, vertices):\\n            heap = [(0, dest)]\\n            distances = {node: float(\\'inf\\') for node in range(vertices)}\\n            distances[dest] = 0\\n\\n            while heap:\\n                distance, node = heapq.heappop(heap)\\n                if distance > distances[node]:\\n                    continue\\n                for neighbor in adj[node]:\\n                    n_cost = distance + 1\\n                    if n_cost < distances[neighbor]:\\n                        distances[neighbor] = n_cost\\n                        heapq.heappush(heap, (n_cost, neighbor))\\n            \\n            return distances\\n        \\n        distances = djikstras(0, len(patience))\\n\\n        idle_time = float(\\'-inf\\')\\n\\n        for node in range(len(patience)):\\n            first_returned = distances[node] * 2\\n            if patience[node] < first_returned:\\n                if first_returned % patience[node] == 0:\\n                    last_recieved = first_returned*2 - patience[node]\\n                else:\\n                    last_recieved = first_returned*2 - first_returned%patience[node]\\n            else:\\n                last_recieved = first_returned\\n            \\n            idle_time = max(idle_time, last_recieved + 1)\\n        \\n        return idle_time\\n\\n\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2896593,
                "title": "c-easy-solution-bfs-math",
                "content": "# Complexity\\n- Time complexity: O(V + E)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(V)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> createGraph(vector<vector<int>>& edges, int n) {\\n        vector<vector<int>> adj(n, vector<int>());\\n        for(int i=0; i<edges.size(); i++) {\\n            int u = edges[i][0];\\n            int v = edges[i][1];\\n            adj[u].push_back(v);\\n            adj[v].push_back(u);\\n        }\\n        return adj;\\n    }\\n\\n    vector<int> bfs(vector<vector<int>>& adj, int n) {\\n        vector<bool> visited(n, false);\\n        vector<int> dist(n, INT_MAX);\\n        queue<pair<int, int>> q;\\n        dist[0] = 0;\\n        q.push({0, 0});\\n        while(!q.empty()) {\\n            int currIndex = q.front().first;\\n            int currDist = q.front().second;\\n            dist[currIndex] = currDist;\\n            q.pop();\\n            for(int i=0; i<adj[currIndex].size(); i++) {\\n                if(!visited[adj[currIndex][i]]) {\\n                    q.push({adj[currIndex][i], currDist+1});\\n                    visited[adj[currIndex][i]] = true;\\n                }\\n            }\\n        }\\n        return dist;\\n    }\\n\\n    int networkBecomesIdle(vector<vector<int>>& edges, vector<int>& patience) {\\n        int n = patience.size();\\n        //networkDelayTime holds the maximum time a node will hold the network.\\n        int networkDelayTime = 0;\\n        //adj represents the adjacency list of the graph\\n        vector<vector<int>> adj = createGraph(edges, n);\\n        //dist vector stores the minimum distance of node i from 0 which could be easily calculate from bfs\\n        vector<int> dist = bfs(adj, n);\\n        //Now for each node i we calculate the maximum time it will hold the network and then return the maximum of all the network delay times.\\n        for(int i=1; i<dist.size(); i++) {\\n            // delatTime is equal to the total time required to send and recieve a message by node i\\n            int delayTime = 2*dist[i];\\n            //maxMessageSent is the total number of messages sent by the node, until it recieves the response from the master node\\n            int maxMessagesSent = (delayTime-1)/patience[i];\\n            //Node i will hold the network until it recieves the response to the final message sent which is equal to the delayTime + time when the final message was sent.\\n            int maxCurrDelay = delayTime + maxMessagesSent*patience[i];\\n            networkDelayTime = max(networkDelayTime, maxCurrDelay);\\n        }\\n        return networkDelayTime+1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> createGraph(vector<vector<int>>& edges, int n) {\\n        vector<vector<int>> adj(n, vector<int>());\\n        for(int i=0; i<edges.size(); i++) {\\n            int u = edges[i][0];\\n            int v = edges[i][1];\\n            adj[u].push_back(v);\\n            adj[v].push_back(u);\\n        }\\n        return adj;\\n    }\\n\\n    vector<int> bfs(vector<vector<int>>& adj, int n) {\\n        vector<bool> visited(n, false);\\n        vector<int> dist(n, INT_MAX);\\n        queue<pair<int, int>> q;\\n        dist[0] = 0;\\n        q.push({0, 0});\\n        while(!q.empty()) {\\n            int currIndex = q.front().first;\\n            int currDist = q.front().second;\\n            dist[currIndex] = currDist;\\n            q.pop();\\n            for(int i=0; i<adj[currIndex].size(); i++) {\\n                if(!visited[adj[currIndex][i]]) {\\n                    q.push({adj[currIndex][i], currDist+1});\\n                    visited[adj[currIndex][i]] = true;\\n                }\\n            }\\n        }\\n        return dist;\\n    }\\n\\n    int networkBecomesIdle(vector<vector<int>>& edges, vector<int>& patience) {\\n        int n = patience.size();\\n        //networkDelayTime holds the maximum time a node will hold the network.\\n        int networkDelayTime = 0;\\n        //adj represents the adjacency list of the graph\\n        vector<vector<int>> adj = createGraph(edges, n);\\n        //dist vector stores the minimum distance of node i from 0 which could be easily calculate from bfs\\n        vector<int> dist = bfs(adj, n);\\n        //Now for each node i we calculate the maximum time it will hold the network and then return the maximum of all the network delay times.\\n        for(int i=1; i<dist.size(); i++) {\\n            // delatTime is equal to the total time required to send and recieve a message by node i\\n            int delayTime = 2*dist[i];\\n            //maxMessageSent is the total number of messages sent by the node, until it recieves the response from the master node\\n            int maxMessagesSent = (delayTime-1)/patience[i];\\n            //Node i will hold the network until it recieves the response to the final message sent which is equal to the delayTime + time when the final message was sent.\\n            int maxCurrDelay = delayTime + maxMessagesSent*patience[i];\\n            networkDelayTime = max(networkDelayTime, maxCurrDelay);\\n        }\\n        return networkDelayTime+1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2847951,
                "title": "easiest-code-with-best-explanation-for-the-formula",
                "content": "# Intuition\\nWe need to find the fastest way to reach to main server. So we need to find the shortest path\\n\\n# Approach\\n1. Find shortest path. Since distance is not given we assume distance between 2 nodes to be 1. And since it takes 1 second to go from one node to other, time will be same as distance.\\n2. Apply the formula (explaination below along with code) for each node and return the max time needed.\\n\\n# Complexity\\n- Time complexity:\\n$$O(ElogV)$$ *where, V is the number of vertices and E is the total number of edges*\\n\\n- Space complexity:\\n$$O(V)$$ *for the graph and time_tracker array*\\n\\n# Code\\n```\\nclass Solution:\\n    def networkBecomesIdle(self, edges: List[List[int]], patience: List[int]) -> int:\\n        #part-1 of code\\n        #Djikstra for getting the shortest time\\n        graph = defaultdict(list)\\n        for u,v in edges:\\n            graph[u].append(v)\\n            graph[v].append(u)\\n\\n        time_tracker = [float(\"inf\")]*len(patience)\\n        time_tracker[0] = 0\\n\\n        heap = []\\n        heappush(heap,(0,0))\\n\\n        while heap:\\n            time,node = heappop(heap)\\n            for nei in graph[node]:\\n                if time+1 < time_tracker[nei]:\\n                    heappush(heap,(time+1,nei))\\n                    time_tracker[nei] = time+1\\n        \\n        #part-2 of code\\n        #To find the max time needed\\n        max_time_needed = 0\\n        for i in range(1,len(time_tracker)):\\n            #time needed will be 2 times what it takes one way\\n            time_needed = 2*time_tracker[i]\\n            #number of msgs sent will me time_needed/patience\\n            #why ceil? if time_needed -> 6 and patience -> 5\\n            #time_needed/patience -> 1.2, we can send 0.2 msg,we have\\n            #to send entire msg. So we take ceil\\n            msgs_sent = ceil(time_needed/patience[i])\\n            #total time needed will be the time when last msg is sent\\n            #plus the time it will take to come back(i.e. time_needed)\\n            #the first msg is sent at 0th second. that leaves us with\\n            #msgs_sent - 1. We multiply it by patience to get when\\n            #the last msg will be sent. \\n            total_time_needed = (patience[i])*(msgs_sent-1) +time_needed\\n            max_time_needed = max(max_time_needed,total_time_needed)\\n\\n        return max_time_needed + 1\\n            \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def networkBecomesIdle(self, edges: List[List[int]], patience: List[int]) -> int:\\n        #part-1 of code\\n        #Djikstra for getting the shortest time\\n        graph = defaultdict(list)\\n        for u,v in edges:\\n            graph[u].append(v)\\n            graph[v].append(u)\\n\\n        time_tracker = [float(\"inf\")]*len(patience)\\n        time_tracker[0] = 0\\n\\n        heap = []\\n        heappush(heap,(0,0))\\n\\n        while heap:\\n            time,node = heappop(heap)\\n            for nei in graph[node]:\\n                if time+1 < time_tracker[nei]:\\n                    heappush(heap,(time+1,nei))\\n                    time_tracker[nei] = time+1\\n        \\n        #part-2 of code\\n        #To find the max time needed\\n        max_time_needed = 0\\n        for i in range(1,len(time_tracker)):\\n            #time needed will be 2 times what it takes one way\\n            time_needed = 2*time_tracker[i]\\n            #number of msgs sent will me time_needed/patience\\n            #why ceil? if time_needed -> 6 and patience -> 5\\n            #time_needed/patience -> 1.2, we can send 0.2 msg,we have\\n            #to send entire msg. So we take ceil\\n            msgs_sent = ceil(time_needed/patience[i])\\n            #total time needed will be the time when last msg is sent\\n            #plus the time it will take to come back(i.e. time_needed)\\n            #the first msg is sent at 0th second. that leaves us with\\n            #msgs_sent - 1. We multiply it by patience to get when\\n            #the last msg will be sent. \\n            total_time_needed = (patience[i])*(msgs_sent-1) +time_needed\\n            max_time_needed = max(max_time_needed,total_time_needed)\\n\\n        return max_time_needed + 1\\n            \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2835536,
                "title": "c-bfs-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int networkBecomesIdle(vector<vector<int>>& E, vector<int>& P) {\\n        unordered_map<int, unordered_set<int>> g;\\n        for(auto & e : E) {\\n            g[e[0]].insert(e[1]);\\n            g[e[1]].insert(e[0]);\\n        }\\n\\n        \\n        int N = P.size();\\n        vector<int> D(N+1, 0);\\n        queue<int> q;\\n        q.push(0);\\n        D[0] = 1;\\n        while(!q.empty()) {\\n            for(int i = q.size(); i > 0; i--) {\\n                int t = q.front(); q.pop();\\n                for(int nxt : g[t]) {\\n                    if(!D[nxt]) {\\n                        D[nxt] = D[t]+1;\\n                        q.push(nxt);\\n                    }\\n                }\\n            }\\n        }\\n\\n        int res = 0;\\n        for(int i = 1; i < N; i++) {\\n            int loop = 2*(D[i]-1);\\n            int resend = (loop+P[i]-1)/P[i]-1;\\n            int total = resend*P[i] + loop;\\n            res = max(res, total);\\n        }\\n        return res+1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int networkBecomesIdle(vector<vector<int>>& E, vector<int>& P) {\\n        unordered_map<int, unordered_set<int>> g;\\n        for(auto & e : E) {\\n            g[e[0]].insert(e[1]);\\n            g[e[1]].insert(e[0]);\\n        }\\n\\n        \\n        int N = P.size();\\n        vector<int> D(N+1, 0);\\n        queue<int> q;\\n        q.push(0);\\n        D[0] = 1;\\n        while(!q.empty()) {\\n            for(int i = q.size(); i > 0; i--) {\\n                int t = q.front(); q.pop();\\n                for(int nxt : g[t]) {\\n                    if(!D[nxt]) {\\n                        D[nxt] = D[t]+1;\\n                        q.push(nxt);\\n                    }\\n                }\\n            }\\n        }\\n\\n        int res = 0;\\n        for(int i = 1; i < N; i++) {\\n            int loop = 2*(D[i]-1);\\n            int resend = (loop+P[i]-1)/P[i]-1;\\n            int total = resend*P[i] + loop;\\n            res = max(res, total);\\n        }\\n        return res+1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2774996,
                "title": "java-simple-bfs-math",
                "content": "# Code\\n```\\nclass Solution {\\n    public int networkBecomesIdle(int[][] edges, int[] patience) {\\n        int N = patience.length;\\n        int[] dist = new int[N];\\n        Arrays.fill(dist, -1);\\n        HashMap<Integer, HashSet<Integer>> graph = new HashMap<>();\\n\\n        for(int[] e : edges) {\\n            int u = e[0];\\n            int v = e[1];\\n\\n            if(!graph.containsKey(u)) graph.put(u, new HashSet<>());\\n            if(!graph.containsKey(v)) graph.put(v, new HashSet<>());\\n            \\n            graph.get(u).add(v);\\n            graph.get(v).add(u);\\n        }\\n\\n        Queue<Integer> q = new ArrayDeque<>();\\n        q.add(0);\\n        dist[0] = 0;\\n\\n        int cnt = 0;\\n        while(!q.isEmpty()) {\\n            int len = q.size();\\n\\n            for(int i=0; i<len; i++) {\\n                int u = q.poll();\\n\\n                for(int v : graph.get(u)) {\\n                    if(dist[v] == -1) {\\n                        dist[v] = cnt+1;\\n                        q.add(v);\\n                    }\\n                }\\n            }\\n            cnt++;\\n        }\\n\\n        int ans = 0;\\n\\n        for(int i=1; i<N; i++) {\\n            int d = dist[i];\\n            int p = patience[i];\\n            \\n            int tmp = ((2*d-1)/p) * p;\\n            ans = Math.max(ans, tmp + d*2 + 1);\\n        }\\n\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int networkBecomesIdle(int[][] edges, int[] patience) {\\n        int N = patience.length;\\n        int[] dist = new int[N];\\n        Arrays.fill(dist, -1);\\n        HashMap<Integer, HashSet<Integer>> graph = new HashMap<>();\\n\\n        for(int[] e : edges) {\\n            int u = e[0];\\n            int v = e[1];\\n\\n            if(!graph.containsKey(u)) graph.put(u, new HashSet<>());\\n            if(!graph.containsKey(v)) graph.put(v, new HashSet<>());\\n            \\n            graph.get(u).add(v);\\n            graph.get(v).add(u);\\n        }\\n\\n        Queue<Integer> q = new ArrayDeque<>();\\n        q.add(0);\\n        dist[0] = 0;\\n\\n        int cnt = 0;\\n        while(!q.isEmpty()) {\\n            int len = q.size();\\n\\n            for(int i=0; i<len; i++) {\\n                int u = q.poll();\\n\\n                for(int v : graph.get(u)) {\\n                    if(dist[v] == -1) {\\n                        dist[v] = cnt+1;\\n                        q.add(v);\\n                    }\\n                }\\n            }\\n            cnt++;\\n        }\\n\\n        int ans = 0;\\n\\n        for(int i=1; i<N; i++) {\\n            int d = dist[i];\\n            int p = patience[i];\\n            \\n            int tmp = ((2*d-1)/p) * p;\\n            ans = Math.max(ans, tmp + d*2 + 1);\\n        }\\n\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2774092,
                "title": "python-bfs-formulate-when-the-last-message-will-be-received-from-the-farthest-node",
                "content": "```\\nclass Solution:\\n    def networkBecomesIdle(self, edges: List[List[int]], patience: List[int]) -> int:\\n        G = defaultdict(list)\\n        for u, v in edges:\\n            G[u].append(v)\\n            G[v].append(u)\\n        \\n        n = len(patience)\\n        Q = deque()\\n        time = [math.inf]*n\\n        \\n        time[0] = 0\\n        Q.append([0,0])\\n        while Q:\\n            node, t = Q.popleft()\\n            for nei in G[node]:\\n                if time[nei] == math.inf:\\n                    time[nei] = t + 1\\n                    Q.append([nei,time[nei]])\\n        \\n        res = 0\\n        for i in range(1,n):\\n            t = 2 * time[i]\\n            if t % patience[i] == 0: temp = (2*t - patience[i])\\n            else: temp = (2*t - t % patience[i])\\n            res = max(res, temp)\\n        \\n        return res + 1\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def networkBecomesIdle(self, edges: List[List[int]], patience: List[int]) -> int:\\n        G = defaultdict(list)\\n        for u, v in edges:\\n            G[u].append(v)\\n            G[v].append(u)\\n        \\n        n = len(patience)\\n        Q = deque()\\n        time = [math.inf]*n\\n        \\n        time[0] = 0\\n        Q.append([0,0])\\n        while Q:\\n            node, t = Q.popleft()\\n            for nei in G[node]:\\n                if time[nei] == math.inf:\\n                    time[nei] = t + 1\\n                    Q.append([nei,time[nei]])\\n        \\n        res = 0\\n        for i in range(1,n):\\n            t = 2 * time[i]\\n            if t % patience[i] == 0: temp = (2*t - patience[i])\\n            else: temp = (2*t - t % patience[i])\\n            res = max(res, temp)\\n        \\n        return res + 1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2681168,
                "title": "c-bfs-maths-with-comments",
                "content": "\\n```\\nclass Solution {\\npublic:\\n    int networkBecomesIdle(vector<vector<int>>& edges, vector<int>& patience) {\\n        \\n        int n = patience.size();\\n        vector<int> adj[n];\\n        for(auto i: edges){\\n            adj[i[0]].push_back(i[1]);\\n            adj[i[1]].push_back(i[0]);\\n        }\\n        \\n        vector<int> dis(n, -1);\\n        dis[0] = 0;\\n        queue<int> q;\\n        q.push(0);\\n        \\n        while(!q.empty()){\\n            int node = q.front();\\n            q.pop();\\n            for(auto child: adj[node]){\\n                if(dis[child] == -1){\\n                    dis[child] = dis[node] + 1;\\n                    q.push(child);\\n                }\\n            }\\n        }\\n        \\n        int res = 0;\\n        int ans = 0;\\n        for(int i=1; i<n; i++){\\n            \\n            // WHEN REACHED BEFORE THE PATIENCE HAS OVER\\n            ans = 2*dis[i];\\n            \\n            // WHEN NO PATIENCE IS LEFT INDEED\\n            if(2*dis[i] > patience[i]){\\n                \\n                if(2*dis[i] % patience[i] == 0){\\n                    ans = 4*dis[i] - patience[i];\\n                }else{\\n                    ans = 4*dis[i] - (2*dis[i])%patience[i];\\n                }\\n            }\\n            res = max(res, ans);\\n        }   \\n        return res+1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Math",
                    "Depth-First Search",
                    "Breadth-First Search",
                    "Graph",
                    "Shortest Path"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int networkBecomesIdle(vector<vector<int>>& edges, vector<int>& patience) {\\n        \\n        int n = patience.size();\\n        vector<int> adj[n];\\n        for(auto i: edges){\\n            adj[i[0]].push_back(i[1]);\\n            adj[i[1]].push_back(i[0]);\\n        }\\n        \\n        vector<int> dis(n, -1);\\n        dis[0] = 0;\\n        queue<int> q;\\n        q.push(0);\\n        \\n        while(!q.empty()){\\n            int node = q.front();\\n            q.pop();\\n            for(auto child: adj[node]){\\n                if(dis[child] == -1){\\n                    dis[child] = dis[node] + 1;\\n                    q.push(child);\\n                }\\n            }\\n        }\\n        \\n        int res = 0;\\n        int ans = 0;\\n        for(int i=1; i<n; i++){\\n            \\n            // WHEN REACHED BEFORE THE PATIENCE HAS OVER\\n            ans = 2*dis[i];\\n            \\n            // WHEN NO PATIENCE IS LEFT INDEED\\n            if(2*dis[i] > patience[i]){\\n                \\n                if(2*dis[i] % patience[i] == 0){\\n                    ans = 4*dis[i] - patience[i];\\n                }else{\\n                    ans = 4*dis[i] - (2*dis[i])%patience[i];\\n                }\\n            }\\n            res = max(res, ans);\\n        }   \\n        return res+1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2669506,
                "title": "c-o-v-e-time-o-v-e-space-bfs",
                "content": "# Complexity\\n- Time complexity:\\n$$O(V+E)$$ ->\\n`V` is the number of server.\\n`E` is the number of edges.\\n\\n- Space complexity:\\n$$O(V+E)$$ ->\\n`V` is the number of server.\\n`E` is the number of edges.\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    static int networkBecomesIdle(const vector<vector<int>>& edges, const vector<int>& patience) {\\n        const int n = size(patience);\\n        vector<vector<int>> adj(n);\\n        for (auto& e : edges) {\\n            adj[e[0]].push_back(e[1]);\\n            adj[e[1]].push_back(e[0]);\\n        }\\n        vector<int> dist(n, -1);\\n        dist[0] = 0;\\n        {\\n            queue<pair<int, int>> q;\\n            q.push({0, 0});\\n            while (!q.empty()) {\\n                auto [i, d] = q.front();\\n                q.pop();\\n                for (auto j : adj[i])\\n                    if (dist[j] < 0)\\n                        q.push({j, dist[j] = d + 2});\\n            }\\n        }\\n        int ret = 0;\\n        for (int i = 1; i < n; ++i) {\\n            int tmp = (dist[i] - 1) / patience[i] * patience[i];\\n            ret = max(ret, tmp += dist[i]);\\n        }\\n        return ++ret;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Breadth-First Search",
                    "Graph",
                    "Shortest Path"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    static int networkBecomesIdle(const vector<vector<int>>& edges, const vector<int>& patience) {\\n        const int n = size(patience);\\n        vector<vector<int>> adj(n);\\n        for (auto& e : edges) {\\n            adj[e[0]].push_back(e[1]);\\n            adj[e[1]].push_back(e[0]);\\n        }\\n        vector<int> dist(n, -1);\\n        dist[0] = 0;\\n        {\\n            queue<pair<int, int>> q;\\n            q.push({0, 0});\\n            while (!q.empty()) {\\n                auto [i, d] = q.front();\\n                q.pop();\\n                for (auto j : adj[i])\\n                    if (dist[j] < 0)\\n                        q.push({j, dist[j] = d + 2});\\n            }\\n        }\\n        int ret = 0;\\n        for (int i = 1; i < n; ++i) {\\n            int tmp = (dist[i] - 1) / patience[i] * patience[i];\\n            ret = max(ret, tmp += dist[i]);\\n        }\\n        return ++ret;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2663012,
                "title": "easy-short-efficient-clean-code",
                "content": "```\\nclass Solution {\\ntypedef long long ll;\\n#define vi(x) vector<x>\\n#define pb push_back\\npublic:\\n    ll func(ll p, ll nd, ll d){\\n        if(p>=d){\\n            return d+1;\\n        }\\n        ll cnt=(d-p)/p;\\n        if((d-p)%p){\\n            ++cnt;\\n        } // num of emmisions\\n        return cnt*p+d+1; // the first second of no emission (+1)\\n    }\\n    int networkBecomesIdle(vector<vector<int>>&e, vector<int>&p) {\\n        ll n=p.size();\\n        vi(vi(ll))g(n);\\n        for(auto edge:e){\\n            g[edge[0]].pb(edge[1]);\\n            g[edge[1]].pb(edge[0]);\\n        }\\n        list<ll>l={0};\\n        vi(bool)vis(n);\\n        ll ans=0, d=-1;\\n        while(!l.empty()){\\n            ++d;\\n            ll sz=l.size();\\n            while(sz--){\\n                ll it=l.front();\\n                l.pop_front();\\n                if(vis[it]){\\n                    continue;\\n                }\\n                if(it){\\n                    ans=max(ans, func(p[it], it, d*2));\\n                }\\n                vis[it]=true;\\n                for(ll ti:g[it]){\\n                    if(!vis[ti]){\\n                        l.pb(ti);\\n                    }\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution {\\ntypedef long long ll;\\n#define vi(x) vector<x>\\n#define pb push_back\\npublic:\\n    ll func(ll p, ll nd, ll d){\\n        if(p>=d){\\n            return d+1;\\n        }\\n        ll cnt=(d-p)/p;\\n        if((d-p)%p){\\n            ++cnt;\\n        } // num of emmisions\\n        return cnt*p+d+1; // the first second of no emission (+1)\\n    }\\n    int networkBecomesIdle(vector<vector<int>>&e, vector<int>&p) {\\n        ll n=p.size();\\n        vi(vi(ll))g(n);\\n        for(auto edge:e){\\n            g[edge[0]].pb(edge[1]);\\n            g[edge[1]].pb(edge[0]);\\n        }\\n        list<ll>l={0};\\n        vi(bool)vis(n);\\n        ll ans=0, d=-1;\\n        while(!l.empty()){\\n            ++d;\\n            ll sz=l.size();\\n            while(sz--){\\n                ll it=l.front();\\n                l.pop_front();\\n                if(vis[it]){\\n                    continue;\\n                }\\n                if(it){\\n                    ans=max(ans, func(p[it], it, d*2));\\n                }\\n                vis[it]=true;\\n                for(ll ti:g[it]){\\n                    if(!vis[ti]){\\n                        l.pb(ti);\\n                    }\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2652995,
                "title": "python-dijkstra-solution-math-explanation",
                "content": "```\\nThe distance of data server is \\'d\\', and it patience is \\'p\\'.\\nThis server will send the message between [0, d*2-1] when it receive the message at d*2.\\nThere are total (d*2-1)//p message sent out and the last one is sent at ((d*2-1)//p)*p.\\nThis server will received the last message at ((d*2-1)//p)*p+d*2.\\n```\\n\\n```\\ndef networkBecomesIdle(self, edges: List[List[int]], pas: List[int]) -> int:\\n\\tg, k = defaultdict(list), len(pas)\\n\\tfor u, v in edges:\\n\\t\\tg[u].append(v)\\n\\t\\tg[v].append(u)\\n\\td = [0]+[k+10]*k\\n\\tq, step = deque([0]), 0\\n\\twhile(q):\\n\\t\\tfor _ in range(len(q)):\\n\\t\\t\\tn = q.popleft()\\n\\t\\t\\td[n] = min(d[n], step)\\n\\t\\t\\tfor x in g[n]:\\n\\t\\t\\t\\tif d[x]>step:\\n\\t\\t\\t\\t\\tq.append(x)\\n\\t\\tstep += 1\\n\\treturn max(pas[i]*((d[i]*2-1)//pas[i])+d[i]*2+1 for i in range(1, k))\\n```",
                "solutionTags": [],
                "code": "```\\nThe distance of data server is \\'d\\', and it patience is \\'p\\'.\\nThis server will send the message between [0, d*2-1] when it receive the message at d*2.\\nThere are total (d*2-1)//p message sent out and the last one is sent at ((d*2-1)//p)*p.\\nThis server will received the last message at ((d*2-1)//p)*p+d*2.\\n```\n```\\ndef networkBecomesIdle(self, edges: List[List[int]], pas: List[int]) -> int:\\n\\tg, k = defaultdict(list), len(pas)\\n\\tfor u, v in edges:\\n\\t\\tg[u].append(v)\\n\\t\\tg[v].append(u)\\n\\td = [0]+[k+10]*k\\n\\tq, step = deque([0]), 0\\n\\twhile(q):\\n\\t\\tfor _ in range(len(q)):\\n\\t\\t\\tn = q.popleft()\\n\\t\\t\\td[n] = min(d[n], step)\\n\\t\\t\\tfor x in g[n]:\\n\\t\\t\\t\\tif d[x]>step:\\n\\t\\t\\t\\t\\tq.append(x)\\n\\t\\tstep += 1\\n\\treturn max(pas[i]*((d[i]*2-1)//pas[i])+d[i]*2+1 for i in range(1, k))\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2638431,
                "title": "java-bfs-easy-to-understand",
                "content": "```\\nclass Solution {\\n    public int networkBecomesIdle(int[][] edges, int[] patience) \\n    {\\n        int n=patience.length;\\n        \\n        List<List<Integer>> adj=new ArrayList<>();\\n        for(int i=0;i<n;i++)\\n        {\\n            List<Integer> toAdd=new ArrayList<>();\\n            adj.add(toAdd);\\n        }\\n        \\n        for(int i=0;i<edges.length;i++)\\n        {\\n            adj.get(edges[i][0]).add(edges[i][1]);\\n            adj.get(edges[i][1]).add(edges[i][0]);\\n        }\\n        \\n        int dist[]=new int[n];\\n        Arrays.fill(dist,-1);\\n        dist[0]=0;\\n        \\n        Queue<Integer> queue=new LinkedList<>();\\n        queue.offer(0);\\n        while(!queue.isEmpty())\\n        {\\n            int curr=queue.poll();\\n            List<Integer> neigh=adj.get(curr);\\n            \\n            if(neigh.isEmpty())\\n            continue;\\n            \\n            for(int i=0;i<neigh.size();i++)\\n            {\\n                if(dist[neigh.get(i)]!=-1)\\n                continue;\\n                \\n                dist[neigh.get(i)]=dist[curr]+1;\\n                queue.offer(neigh.get(i));\\n            }\\n        }\\n        \\n        int max[]=new int[n];\\n        for(int i=1;i<n;i++)\\n        {\\n            int totalTime=dist[i]*2;\\n            \\n            if(patience[i]>=totalTime)\\n            max[i]=totalTime;\\n            \\n            else\\n            {\\n                int totalExtraMessage=totalTime/patience[i];\\n                \\n                if(totalTime%patience[i]==0)\\n                totalExtraMessage--;\\n                \\n                int timeOfSendingLatMsg=(totalExtraMessage*patience[i]);\\n                \\n                int time=timeOfSendingLatMsg+totalTime;\\n                max[i]=time;\\n            }\\n        }\\n        \\n        int ans=0;\\n        for(int i=0;i<n;i++)\\n        ans=Math.max(ans,max[i]);\\n        \\n        return ans+1;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution {\\n    public int networkBecomesIdle(int[][] edges, int[] patience) \\n    {\\n        int n=patience.length;\\n        \\n        List<List<Integer>> adj=new ArrayList<>();\\n        for(int i=0;i<n;i++)\\n        {\\n            List<Integer> toAdd=new ArrayList<>();\\n            adj.add(toAdd);\\n        }\\n        \\n        for(int i=0;i<edges.length;i++)\\n        {\\n            adj.get(edges[i][0]).add(edges[i][1]);\\n            adj.get(edges[i][1]).add(edges[i][0]);\\n        }\\n        \\n        int dist[]=new int[n];\\n        Arrays.fill(dist,-1);\\n        dist[0]=0;\\n        \\n        Queue<Integer> queue=new LinkedList<>();\\n        queue.offer(0);\\n        while(!queue.isEmpty())\\n        {\\n            int curr=queue.poll();\\n            List<Integer> neigh=adj.get(curr);\\n            \\n            if(neigh.isEmpty())\\n            continue;\\n            \\n            for(int i=0;i<neigh.size();i++)\\n            {\\n                if(dist[neigh.get(i)]!=-1)\\n                continue;\\n                \\n                dist[neigh.get(i)]=dist[curr]+1;\\n                queue.offer(neigh.get(i));\\n            }\\n        }\\n        \\n        int max[]=new int[n];\\n        for(int i=1;i<n;i++)\\n        {\\n            int totalTime=dist[i]*2;\\n            \\n            if(patience[i]>=totalTime)\\n            max[i]=totalTime;\\n            \\n            else\\n            {\\n                int totalExtraMessage=totalTime/patience[i];\\n                \\n                if(totalTime%patience[i]==0)\\n                totalExtraMessage--;\\n                \\n                int timeOfSendingLatMsg=(totalExtraMessage*patience[i]);\\n                \\n                int time=timeOfSendingLatMsg+totalTime;\\n                max[i]=time;\\n            }\\n        }\\n        \\n        int ans=0;\\n        for(int i=0;i<n;i++)\\n        ans=Math.max(ans,max[i]);\\n        \\n        return ans+1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2625630,
                "title": "c-easy-solution-dijkstra-s-algorithm",
                "content": "\\tclass Solution {\\n\\tpublic:\\n\\t\\tint networkBecomesIdle(vector<vector<int>>& edges, vector<int>& patience) {\\n\\t\\t\\tint n = patience.size();\\n\\t\\t\\tvector<int> adj[n];\\n\\t\\t\\tvector<int> dist(n,INT32_MAX);\\n\\t\\t\\tvector<int> vis(n,0);\\n\\t\\t\\tfor(auto i:edges){\\n\\t\\t\\t\\tadj[i[0]].push_back(i[1]);\\n\\t\\t\\t\\tadj[i[1]].push_back(i[0]);\\n\\t\\t\\t}\\n\\t\\t\\tset<pair<int,int>> s;\\n\\t\\t\\ts.insert({0,0});\\n\\t\\t\\tdist[0] = 0;\\n\\n\\t\\t\\twhile(!s.empty()){\\n\\t\\t\\t\\tauto x = *s.begin();\\n\\t\\t\\t\\ts.erase(x);\\n\\t\\t\\t\\tvis[x.second] = 1;\\n\\n\\t\\t\\t\\tfor(auto i:adj[x.second]){\\n\\n\\t\\t\\t\\t\\tif(vis[i]) continue;\\n\\n\\t\\t\\t\\t\\tif(dist[x.second] + 1 < dist[i]){\\n\\t\\t\\t\\t\\t\\ts.erase({dist[i],i});\\n\\t\\t\\t\\t\\t\\tdist[i] = dist[x.second] + 1;\\n\\t\\t\\t\\t\\t\\ts.insert({dist[i],i});\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\n\\t\\t\\tint ans = 0;\\n\\t\\t\\tfor(int i=1;i<n;i++){\\n\\t\\t\\t\\tint x = 2*dist[i];\\n\\t\\t\\t\\tint y = min(2*dist[i],patience[i]);\\n\\n\\t\\t\\t\\tans = max(ans,x + (int(ceil((x*1.0)/y)) - 1)*y);\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn ans + 1;\\n\\t\\t}\\n\\t};",
                "solutionTags": [
                    "C",
                    "Math",
                    "Breadth-First Search",
                    "Graph"
                ],
                "code": "class Solution {\\n\\tpublic:\\n\\t\\tint networkBecomesIdle(vector<vector<int>>& edges, vector<int>& patience) {\\n\\t\\t\\tint n = patience.size();\\n\\t\\t\\tvector<int> adj[n];\\n\\t\\t\\tvector<int> dist(n,INT32_MAX);\\n\\t\\t\\tvector<int> vis(n,0);\\n\\t\\t\\tfor(auto i:edges){\\n\\t\\t\\t\\tadj[i[0]].push_back(i[1]);\\n\\t\\t\\t\\tadj[i[1]].push_back(i[0]);\\n\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 2614432,
                "title": "bfs",
                "content": "As the graph is connected with edges of weight 0(server is connected where time to send message from one server to another server is 1) thus for finding the time to reach the last server from server 0 I had use level order Traversal as it will find the level of each node and time will be 2 of that.Below is the implementation of what i have said.First try on yourself as not very difficult.\\n\\n\\t\\tint networkBecomesIdle(vector<vector<int>>& edges, vector<int>& patience) {\\n\\t\\t\\tvector<vector<int>> graph(patience.size());\\n\\t\\t\\tfor(int i=0;i<edges.size();i++){\\n\\t\\t\\t\\tgraph[edges[i][0]].push_back(edges[i][1]);\\n\\t\\t\\t\\tgraph[edges[i][1]].push_back(edges[i][0]);\\n\\t\\t\\t}\\n\\t\\t\\tvector<int> level(patience.size(),-1);\\n\\t\\t\\tqueue<pair<int,int>> myque;\\n\\t\\t\\tmyque.push(make_pair(0,0));\\n\\n\\t\\t\\twhile(myque.size()!=0){\\n\\t\\t\\t\\tpair<int,int> a = myque.front();\\n\\t\\t\\t\\tmyque.pop();\\n\\n\\t\\t\\t\\tint k1 = a.first;\\n\\t\\t\\t\\tint k2 = a.second;\\n\\n\\t\\t\\t\\tif(level[k1]!=-1){\\n\\t\\t\\t\\t\\tcontinue;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tlevel[k1] = k2;\\n\\t\\t\\t\\tfor(int i=0;i<graph[k1].size();i++){\\n\\t\\t\\t\\t\\tmyque.push(make_pair(graph[k1][i],k2+1));\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t//         Time to reach is given in level and patience time is given in patience vector\\n\\t\\t\\tint ans = 0;\\n\\t\\t\\tfor(int i=1;i<level.size();i++){\\n\\t\\t\\t\\tint pos=(2*level[i]-1)/patience[i];\\n\\t\\t\\t\\tint val=pos*(patience[i]);\\n\\t\\t\\t\\tint final_val=val+2*level[i];\\n\\t\\t\\t\\tans=max(ans,final_val);\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn ans+1;\\n\\t\\t}\\n",
                "solutionTags": [
                    "Breadth-First Search"
                ],
                "code": "As the graph is connected with edges of weight 0(server is connected where time to send message from one server to another server is 1) thus for finding the time to reach the last server from server 0 I had use level order Traversal as it will find the level of each node and time will be 2 of that.Below is the implementation of what i have said.First try on yourself as not very difficult.\\n\\n\\t\\tint networkBecomesIdle(vector<vector<int>>& edges, vector<int>& patience) {\\n\\t\\t\\tvector<vector<int>> graph(patience.size());\\n\\t\\t\\tfor(int i=0;i<edges.size();i++){\\n\\t\\t\\t\\tgraph[edges[i][0]].push_back(edges[i][1]);\\n\\t\\t\\t\\tgraph[edges[i][1]].push_back(edges[i][0]);\\n\\t\\t\\t}\\n\\t\\t\\tvector<int> level(patience.size(),-1);\\n\\t\\t\\tqueue<pair<int,int>> myque;\\n\\t\\t\\tmyque.push(make_pair(0,0));\\n\\n\\t\\t\\twhile(myque.size()!=0){\\n\\t\\t\\t\\tpair<int,int> a = myque.front();\\n\\t\\t\\t\\tmyque.pop();\\n\\n\\t\\t\\t\\tint k1 = a.first;\\n\\t\\t\\t\\tint k2 = a.second;\\n\\n\\t\\t\\t\\tif(level[k1]!=-1){\\n\\t\\t\\t\\t\\tcontinue;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tlevel[k1] = k2;\\n\\t\\t\\t\\tfor(int i=0;i<graph[k1].size();i++){\\n\\t\\t\\t\\t\\tmyque.push(make_pair(graph[k1][i],k2+1));\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t//         Time to reach is given in level and patience time is given in patience vector\\n\\t\\t\\tint ans = 0;\\n\\t\\t\\tfor(int i=1;i<level.size();i++){\\n\\t\\t\\t\\tint pos=(2*level[i]-1)/patience[i];\\n\\t\\t\\t\\tint val=pos*(patience[i]);\\n\\t\\t\\t\\tint final_val=val+2*level[i];\\n\\t\\t\\t\\tans=max(ans,final_val);\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn ans+1;\\n\\t\\t}\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 2553072,
                "title": "cpp-level-order-traversal-bfs",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> pat;\\n    int networkBecomesIdle(vector<vector<int>>& edges, vector<int>& patience) {\\n        pat = patience;\\n        vector<vector<int>> adj(patience.size());\\n        for(auto x:edges){\\n            adj[x[0]].push_back(x[1]);\\n            adj[x[1]].push_back(x[0]);\\n        }\\n        // return recur(adj,0,-1,1)+1;\\n        queue<int> q;\\n        q.push(0);\\n        \\n        int ans = 0;\\n        vector<int> vis(patience.size());\\n        vis[0]=1;\\n        int i=1;\\n        int j=0;\\n        int d = 1;\\n        while(!q.empty()){\\n            int a= q.front();\\n            q.pop();\\n            i--;\\n            for(auto x:adj[a]){\\n                if(!vis[x]){\\n                    vis[x] = 1;\\n                    int val = 0;\\n                    if(pat[x]<2*d){\\n                        int temp =(2*d)%pat[x];\\n                        if(temp==0){\\n                            temp=pat[x];\\n                        }\\n                        val = 2*d+(2*d-(temp));\\n                        \\n                    }\\n                    else{\\n                        val = max(ans,2*d);\\n                    }\\n                    ans = max(ans,val);\\n                    q.push(x);\\n                    j++;\\n                }\\n            }\\n            if(i==0){\\n                i=j;\\n                j=0;\\n                d++;\\n            }\\n        }\\n        return ans+1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> pat;\\n    int networkBecomesIdle(vector<vector<int>>& edges, vector<int>& patience) {\\n        pat = patience;\\n        vector<vector<int>> adj(patience.size());\\n        for(auto x:edges){\\n            adj[x[0]].push_back(x[1]);\\n            adj[x[1]].push_back(x[0]);\\n        }\\n        // return recur(adj,0,-1,1)+1;\\n        queue<int> q;\\n        q.push(0);\\n        \\n        int ans = 0;\\n        vector<int> vis(patience.size());\\n        vis[0]=1;\\n        int i=1;\\n        int j=0;\\n        int d = 1;\\n        while(!q.empty()){\\n            int a= q.front();\\n            q.pop();\\n            i--;\\n            for(auto x:adj[a]){\\n                if(!vis[x]){\\n                    vis[x] = 1;\\n                    int val = 0;\\n                    if(pat[x]<2*d){\\n                        int temp =(2*d)%pat[x];\\n                        if(temp==0){\\n                            temp=pat[x];\\n                        }\\n                        val = 2*d+(2*d-(temp));\\n                        \\n                    }\\n                    else{\\n                        val = max(ans,2*d);\\n                    }\\n                    ans = max(ans,val);\\n                    q.push(x);\\n                    j++;\\n                }\\n            }\\n            if(i==0){\\n                i=j;\\n                j=0;\\n                d++;\\n            }\\n        }\\n        return ans+1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2549296,
                "title": "python-bfs-solution",
                "content": "```\\nclass Solution:\\n    def networkBecomesIdle(self, edges: List[List[int]], patience: List[int]) -> int:\\n        graph, curTime, ans = defaultdict(list), 0, 0\\n        for edge in edges:\\n            graph[edge[0]].append(edge[1])\\n            graph[edge[1]].append(edge[0])\\n        queue, minTime, visited = deque(), [0 for _ in range(len(patience))], [False for I in range(len(patience))]\\n        queue.append(0)\\n        visited[0] = True\\n        while len(queue):\\n            sz = len(queue)\\n            for i in range(sz):\\n                curr = queue.popleft()\\n                minTime[curr], visited[curr] = curTime, True\\n                for node in graph[curr]:\\n                    if not visited[node]:\\n                        queue.append(node)\\n                        visited[node] = True\\n            curTime += 1\\n        for i in range(1, len(patience)):\\n            totalTime = 2 * minTime[i]\\n            if totalTime <= patience[i]:\\n                ans = max(ans, totalTime)\\n            else:\\n                idx = totalTime // patience[i]\\n                if not totalTime % patience[i]:\\n                    idx -= 1\\n                ans = max(ans, totalTime + (idx * patience[i]))\\n        return ans + 1\\n```",
                "solutionTags": [
                    "Python",
                    "Breadth-First Search",
                    "Iterator"
                ],
                "code": "```\\nclass Solution:\\n    def networkBecomesIdle(self, edges: List[List[int]], patience: List[int]) -> int:\\n        graph, curTime, ans = defaultdict(list), 0, 0\\n        for edge in edges:\\n            graph[edge[0]].append(edge[1])\\n            graph[edge[1]].append(edge[0])\\n        queue, minTime, visited = deque(), [0 for _ in range(len(patience))], [False for I in range(len(patience))]\\n        queue.append(0)\\n        visited[0] = True\\n        while len(queue):\\n            sz = len(queue)\\n            for i in range(sz):\\n                curr = queue.popleft()\\n                minTime[curr], visited[curr] = curTime, True\\n                for node in graph[curr]:\\n                    if not visited[node]:\\n                        queue.append(node)\\n                        visited[node] = True\\n            curTime += 1\\n        for i in range(1, len(patience)):\\n            totalTime = 2 * minTime[i]\\n            if totalTime <= patience[i]:\\n                ans = max(ans, totalTime)\\n            else:\\n                idx = totalTime // patience[i]\\n                if not totalTime % patience[i]:\\n                    idx -= 1\\n                ans = max(ans, totalTime + (idx * patience[i]))\\n        return ans + 1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2539003,
                "title": "faster-than-99-c-graph-dijkstra-explained",
                "content": "```\\nclass Solution {\\npublic:\\n    int networkBecomesIdle(vector<vector<int>>& edges, vector<int>& patience) {\\n        int n = patience.size();\\n        vector<vector<int>> graph(n);\\n        for(int i=0; i<edges.size(); i++){\\n            int u = edges[i][0];\\n            int v = edges[i][1];\\n            graph[u].push_back(v);\\n            graph[v].push_back(u);\\n        }\\n        \\n        int dist[n];\\n        memset(dist,0,sizeof(dist));\\n        queue<int> q;\\n        q.push(0);\\n        while(!q.empty()){\\n            int v = q.front();\\n            q.pop();\\n            for(int i=0; i<graph[v].size(); i++){\\n                int u = graph[v][i];\\n                if(dist[u]==0){\\n                    //First visit\\n                    dist[u] = dist[v]+1;\\n                    q.push(u);\\n                }\\n                // else skip (already visited)\\n            }\\n        }\\n        int ans = 0;\\n        for(int i=1; i<n; i++){\\n            int time = 2*dist[i]+1;\\n\\t\\t\\t// Extra time for the last packet to come back to source server\\n            int extraTime = 0;\\n            if(patience[i]<2*dist[i]) {\\n\\t\\t\\t\\t// Means there is some extra packet sent\\n                int lastPkt = 2*dist[i]%patience[i];\\n                if(!lastPkt)\\n                    lastPkt = patience[i];\\n\\t\\t\\t\\t// lastPkt time is already travelled by the packet\\n                extraTime = 2*dist[i] - lastPkt;\\n            }\\n            \\n            ans = max(ans,time+extraTime);\\n        }\\n        return ans;\\n    }\\n};```",
                "solutionTags": [
                    "Math",
                    "Graph"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int networkBecomesIdle(vector<vector<int>>& edges, vector<int>& patience) {\\n        int n = patience.size();\\n        vector<vector<int>> graph(n);\\n        for(int i=0; i<edges.size(); i++){\\n            int u = edges[i][0];\\n            int v = edges[i][1];\\n            graph[u].push_back(v);\\n            graph[v].push_back(u);\\n        }\\n        \\n        int dist[n];\\n        memset(dist,0,sizeof(dist));\\n        queue<int> q;\\n        q.push(0);\\n        while(!q.empty()){\\n            int v = q.front();\\n            q.pop();\\n            for(int i=0; i<graph[v].size(); i++){\\n                int u = graph[v][i];\\n                if(dist[u]==0){\\n                    //First visit\\n                    dist[u] = dist[v]+1;\\n                    q.push(u);\\n                }\\n                // else skip (already visited)\\n            }\\n        }\\n        int ans = 0;\\n        for(int i=1; i<n; i++){\\n            int time = 2*dist[i]+1;\\n\\t\\t\\t// Extra time for the last packet to come back to source server\\n            int extraTime = 0;\\n            if(patience[i]<2*dist[i]) {\\n\\t\\t\\t\\t// Means there is some extra packet sent\\n                int lastPkt = 2*dist[i]%patience[i];\\n                if(!lastPkt)\\n                    lastPkt = patience[i];\\n\\t\\t\\t\\t// lastPkt time is already travelled by the packet\\n                extraTime = 2*dist[i] - lastPkt;\\n            }\\n            \\n            ans = max(ans,time+extraTime);\\n        }\\n        return ans;\\n    }\\n};```",
                "codeTag": "Java"
            },
            {
                "id": 2536319,
                "title": "javascript-bfs-iterative-build-graph-get-distances-do-math-on-distances",
                "content": "It\\'s important to remember when doing a breadth-first search using recursion that your \"horizon\" arrays/sets get \"freed\" along the way. That really tripped me up for a while (even though I\\'ve had that issue before). So I decided to do this iteratively instead. (Why not? DFS is more when you need recursion.)\\n\\n```\\nfunction networkBecomesIdle(edges, patience) {\\n    \\n    const graph = [];\\n    for (let n = 0; n < patience.length; n++) {\\n        graph[n] = [];\\n    }\\n    \\n    for (const [a, b] of edges) {\\n        graph[a].push(b);\\n        graph[b].push(a);\\n    }\\n    \\n    const distances = [];\\n    let distance = 1;\\n    \\n    let horizon = [0];\\n    \\n    while (horizon.length > 0) {\\n        const newHorizon = [];\\n        \\n        for (const n of horizon) {\\n            for (const m of graph[n]) {\\n                if (distances[m] === undefined) {\\n                    newHorizon.push(m);\\n                    distances[m] = distance;\\n                }\\n            }\\n        }\\n        \\n        horizon = newHorizon;\\n        distance++;\\n    }\\n    \\n    let max = 0;\\n    \\n    for (let n = 1; n < patience.length; n++) {\\n        const roundTrip = distances[n] * 2;\\n        const redundant = Math.floor((roundTrip - 1) / patience[n]);\\n        const seconds = roundTrip + patience[n] * redundant;\\n\\n        if (seconds > max) max = seconds;\\n    }\\n    \\n    return max + 1;\\n    \\n}\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Math",
                    "Graph",
                    "Iterator"
                ],
                "code": "```\\nfunction networkBecomesIdle(edges, patience) {\\n    \\n    const graph = [];\\n    for (let n = 0; n < patience.length; n++) {\\n        graph[n] = [];\\n    }\\n    \\n    for (const [a, b] of edges) {\\n        graph[a].push(b);\\n        graph[b].push(a);\\n    }\\n    \\n    const distances = [];\\n    let distance = 1;\\n    \\n    let horizon = [0];\\n    \\n    while (horizon.length > 0) {\\n        const newHorizon = [];\\n        \\n        for (const n of horizon) {\\n            for (const m of graph[n]) {\\n                if (distances[m] === undefined) {\\n                    newHorizon.push(m);\\n                    distances[m] = distance;\\n                }\\n            }\\n        }\\n        \\n        horizon = newHorizon;\\n        distance++;\\n    }\\n    \\n    let max = 0;\\n    \\n    for (let n = 1; n < patience.length; n++) {\\n        const roundTrip = distances[n] * 2;\\n        const redundant = Math.floor((roundTrip - 1) / patience[n]);\\n        const seconds = roundTrip + patience[n] * redundant;\\n\\n        if (seconds > max) max = seconds;\\n    }\\n    \\n    return max + 1;\\n    \\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2534190,
                "title": "beats-80-using-bfs",
                "content": "```\\n\\nclass Solution {\\npublic:\\n    int networkBecomesIdle(vector<vector<int>>& edges, vector<int>& patience) {\\n        int n=patience.size();\\n        \\n        vector <int> adj[n];\\n        \\n        \\n        for(int i=0;i<edges.size();i++){\\n            int u=edges[i][0];\\n            \\n            int v=edges[i][1];\\n            adj[u].push_back(v);\\n            adj[v].push_back(u);\\n        }\\n        \\n        \\n        queue <int> q;\\n        \\n        vector <int> minTime(n,0);\\n        \\n        q.push(0);\\n        vector <bool> vis(n,false);\\n        vis[0]=true;\\n        int t=0;\\n        while(!q.empty()){\\n            \\n            int sz=q.size();\\n            \\n            for(int i=0;i<sz;i++){\\n                int curr=q.front();\\n                q.pop();\\n                minTime[curr]=t;\\n                vis[curr]=true;\\n                for(int x: adj[curr]){\\n                    \\n                    if(vis[x]==false){\\n                        q.push(x);\\n                        vis[x]=true;\\n                    }\\n                }\\n            }\\n            t++;\\n        }\\n        \\n        int ans=0;\\n        \\n        \\n        for(int i=1;i<n;i++){\\n            \\n            int tot=2*minTime[i];\\n            \\n            \\n            if(tot<=patience[i]){\\n                ans=max(ans,tot);\\n            }\\n            else{\\n                int idx=tot/patience[i];\\n                if(tot%patience[i]==0){\\n                    idx--;\\n                }\\n                \\n                ans=max(ans,tot+(idx*patience[i]));\\n            }\\n        }\\n        return ans+1;\\n        \\n        \\n    }\\n};",
                "solutionTags": [
                    "Array",
                    "Breadth-First Search"
                ],
                "code": "class Solution {\\npublic:\\n    int networkBecomesIdle(vector<vector<int>>& edges, vector<int>& patience) {\\n        int n=patience.size();\\n        \\n        vector <int> adj[n];\\n        \\n        \\n        for(int i=0;i<edges.size();i++){\\n            int u=edges[i][0];\\n            \\n            int v=edges[i][1];\\n            adj[u].push_back(v);\\n            adj[v].push_back(u);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2533790,
                "title": "java-bfs-faster-than-90",
                "content": "```\\nclass Solution {\\n    public int networkBecomesIdle(int[][] edges, int[] patience) {\\n        int n = patience.length;\\n        List<List<Integer>> graph = buildGraph(edges, n);\\n        boolean[] visited = new boolean[n];\\n        Queue<Integer> q = new LinkedList<>();\\n        \\n        int[] time = new int[n];\\n        q.offer(0);\\n        visited[0] = true;\\n        time[0] = 0;\\n        \\n        while(!q.isEmpty()){\\n            int size = q.size();\\n            for(int i = 0; i < size ; i++){\\n                int current = q.poll();\\n                for(int x : graph.get(current)){\\n                    if(!visited[x]){\\n                        time[x] = time[current] + 2;\\n                        visited[x] = true;\\n                        q.offer(x);\\n                    }\\n                }\\n            }\\n        }\\n        \\n        int max = 0, last = 0, packets = 0 ;\\n        \\n        for(int i = 0; i < n ; i++){\\n            last = 0 ;\\n            packets = 0;\\n            if(time[i] > patience[i]){\\n                packets = time[i]/patience[i];\\n                if(time[i] % patience[i] == 0)\\n                    packets--;\\n                last = packets * patience[i];\\n            }  \\n            max = Math.max(last + time[i], max);\\n        }\\n        return max + 1;\\n    }\\n    \\n    public List<List<Integer>> buildGraph(int[][] edges, int n){\\n        List<List<Integer>> graph = new ArrayList<>();\\n        \\n        for(int i = 0 ; i < n ; i++){\\n            graph.add(new ArrayList<Integer>());\\n        }\\n        \\n        for(int[] edge : edges){\\n            graph.get(edge[0]).add(edge[1]);\\n            graph.get(edge[1]).add(edge[0]);\\n        }\\n        \\n        return graph;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution {\\n    public int networkBecomesIdle(int[][] edges, int[] patience) {\\n        int n = patience.length;\\n        List<List<Integer>> graph = buildGraph(edges, n);\\n        boolean[] visited = new boolean[n];\\n        Queue<Integer> q = new LinkedList<>();\\n        \\n        int[] time = new int[n];\\n        q.offer(0);\\n        visited[0] = true;\\n        time[0] = 0;\\n        \\n        while(!q.isEmpty()){\\n            int size = q.size();\\n            for(int i = 0; i < size ; i++){\\n                int current = q.poll();\\n                for(int x : graph.get(current)){\\n                    if(!visited[x]){\\n                        time[x] = time[current] + 2;\\n                        visited[x] = true;\\n                        q.offer(x);\\n                    }\\n                }\\n            }\\n        }\\n        \\n        int max = 0, last = 0, packets = 0 ;\\n        \\n        for(int i = 0; i < n ; i++){\\n            last = 0 ;\\n            packets = 0;\\n            if(time[i] > patience[i]){\\n                packets = time[i]/patience[i];\\n                if(time[i] % patience[i] == 0)\\n                    packets--;\\n                last = packets * patience[i];\\n            }  \\n            max = Math.max(last + time[i], max);\\n        }\\n        return max + 1;\\n    }\\n    \\n    public List<List<Integer>> buildGraph(int[][] edges, int n){\\n        List<List<Integer>> graph = new ArrayList<>();\\n        \\n        for(int i = 0 ; i < n ; i++){\\n            graph.add(new ArrayList<Integer>());\\n        }\\n        \\n        for(int[] edge : edges){\\n            graph.get(edge[0]).add(edge[1]);\\n            graph.get(edge[1]).add(edge[0]);\\n        }\\n        \\n        return graph;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2518855,
                "title": "python-super-easy-bfs",
                "content": "```\\nclass Solution:\\n    def networkBecomesIdle(self, edges: List[List[int]], patience: List[int]) -> int:\\n        queue = [0]\\n        dist = [float(\"inf\") for i in range(len(patience))]\\n        dist[0] = 0\\n        graph = collections.defaultdict(list)\\n        \\n        for a, b in edges:\\n            graph[a].append(b)\\n            graph[b].append(a)\\n        ans = -1\\n        while queue:\\n            node = queue.pop(0)\\n            for v in graph[node]:\\n                if dist[v] == float(\"inf\"):\\n                    dist[v] = dist[node] + 1\\n                    num_resending = (dist[v] * 2 - 1) // patience[v]\\n                    last_resending_time = 1 + patience[v] * num_resending # starting from second 1\\n                    last_arriving_time = last_resending_time + dist[v] * 2\\n                    ans = max(ans, last_arriving_time)\\n                    queue.append(v)\\n        return ans\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def networkBecomesIdle(self, edges: List[List[int]], patience: List[int]) -> int:\\n        queue = [0]\\n        dist = [float(\"inf\") for i in range(len(patience))]\\n        dist[0] = 0\\n        graph = collections.defaultdict(list)\\n        \\n        for a, b in edges:\\n            graph[a].append(b)\\n            graph[b].append(a)\\n        ans = -1\\n        while queue:\\n            node = queue.pop(0)\\n            for v in graph[node]:\\n                if dist[v] == float(\"inf\"):\\n                    dist[v] = dist[node] + 1\\n                    num_resending = (dist[v] * 2 - 1) // patience[v]\\n                    last_resending_time = 1 + patience[v] * num_resending # starting from second 1\\n                    last_arriving_time = last_resending_time + dist[v] * 2\\n                    ans = max(ans, last_arriving_time)\\n                    queue.append(v)\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2503688,
                "title": "bfs-mathematics-c",
                "content": "```\\nclass Solution {\\npublic:\\n    int networkBecomesIdle(vector<vector<int>>& edges, vector<int>& patience) {\\n        int n = patience.size();//number of vertices\\n        vector <int> adj[n];\\n        for(int i=0;i<edges.size();i++)\\n        {\\n            adj[edges[i][0]].push_back(edges[i][1]);\\n            adj[edges[i][1]].push_back(edges[i][0]);\\n        }\\n        vector <int> rtt(n,INT_MAX);//to store round trip times\\n        queue <int> q;\\n        q.push(0);\\n        rtt[0] = 0;\\n        while(q.empty() == false)\\n        {\\n            int x = q.front();\\n            q.pop();\\n            for(auto it : adj[x])\\n            {\\n                if(rtt[it] == INT_MAX)\\n                {\\n                    rtt[it] = rtt[x] + 1;\\n                    q.push(it);\\n                }\\n            }\\n        }\\n        int maxt = INT_MIN;\\n        for(int i=0;i<rtt.size();i++)\\n        {\\n            rtt[i] *= 2;\\n        }\\n        for(int i=0;i<n;i++)\\n        {\\n            if(rtt[i] <= patience[i])\\n            {\\n                maxt = max(maxt,rtt[i] + 1);\\n            }\\n            else\\n            {\\n                if(rtt[i] % patience[i] == 0)\\n                {\\n                    maxt = max(maxt,rtt[i] - patience[i] + rtt[i] + 1);\\n                }\\n                else\\n                {\\n                    maxt = max(maxt,rtt[i] - (rtt[i] % patience[i]) + rtt[i] +1);\\n                }\\n            }\\n        }\\n        \\n        return maxt;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Math",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int networkBecomesIdle(vector<vector<int>>& edges, vector<int>& patience) {\\n        int n = patience.size();//number of vertices\\n        vector <int> adj[n];\\n        for(int i=0;i<edges.size();i++)\\n        {\\n            adj[edges[i][0]].push_back(edges[i][1]);\\n            adj[edges[i][1]].push_back(edges[i][0]);\\n        }\\n        vector <int> rtt(n,INT_MAX);//to store round trip times\\n        queue <int> q;\\n        q.push(0);\\n        rtt[0] = 0;\\n        while(q.empty() == false)\\n        {\\n            int x = q.front();\\n            q.pop();\\n            for(auto it : adj[x])\\n            {\\n                if(rtt[it] == INT_MAX)\\n                {\\n                    rtt[it] = rtt[x] + 1;\\n                    q.push(it);\\n                }\\n            }\\n        }\\n        int maxt = INT_MIN;\\n        for(int i=0;i<rtt.size();i++)\\n        {\\n            rtt[i] *= 2;\\n        }\\n        for(int i=0;i<n;i++)\\n        {\\n            if(rtt[i] <= patience[i])\\n            {\\n                maxt = max(maxt,rtt[i] + 1);\\n            }\\n            else\\n            {\\n                if(rtt[i] % patience[i] == 0)\\n                {\\n                    maxt = max(maxt,rtt[i] - patience[i] + rtt[i] + 1);\\n                }\\n                else\\n                {\\n                    maxt = max(maxt,rtt[i] - (rtt[i] % patience[i]) + rtt[i] +1);\\n                }\\n            }\\n        }\\n        \\n        return maxt;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2484230,
                "title": "2039-python",
                "content": "\\tclass Solution:\\n\\t\\tdef networkBecomesIdle(self, edges: List[List[int]], patience: List[int]) -> int:\\n\\t\\t\\tdist = [math.inf]*(len(patience))\\n\\n\\t\\t\\tgraph = defaultdict(list)\\n\\n\\t\\t\\tfor i,j in edges:\\n\\t\\t\\t\\tgraph[i].append(j)\\n\\t\\t\\t\\tgraph[j].append(i)\\n\\n\\n\\t\\t\\tstack = [(0,0)]\\n\\n\\t\\t\\twhile stack:\\n\\t\\t\\t\\td,p = heapq.heappop(stack)\\n\\n\\t\\t\\t\\tif dist[p] != math.inf:\\n\\t\\t\\t\\t\\tcontinue\\n\\n\\t\\t\\t\\tdist[p] = d\\n\\n\\t\\t\\t\\tfor val in graph[p]:\\n\\t\\t\\t\\t\\tif dist[val] == math.inf:\\n\\t\\t\\t\\t\\t\\theapq.heappush(stack,(d+1,val))\\n\\t\\t\\tans = 0\\n\\n\\t\\t\\tfor i in range(1,len(patience)):\\n\\t\\t\\t\\ttot = 2*dist[i] + patience[0]\\n\\t\\t\\t\\tp,r = divmod(tot,patience[i])\\n\\t\\t\\t\\tif r == 0:\\n\\t\\t\\t\\t\\tp-= 1\\n\\t\\t\\t\\tout = tot+ p*patience[i]\\n\\n\\t\\t\\t\\tans = max(ans,out)\\n\\t\\t\\treturn ans+1\\n",
                "solutionTags": [
                    "Python"
                ],
                "code": "\\tclass Solution:\\n\\t\\tdef networkBecomesIdle(self, edges: List[List[int]], patience: List[int]) -> int:\\n\\t\\t\\tdist = [math.inf]*(len(patience))\\n\\n\\t\\t\\tgraph = defaultdict(list)\\n\\n\\t\\t\\tfor i,j in edges:\\n\\t\\t\\t\\tgraph[i].append(j)\\n\\t\\t\\t\\tgraph[j].append(i)\\n\\n\\n\\t\\t\\tstack = [(0,0)]\\n\\n\\t\\t\\twhile stack:\\n\\t\\t\\t\\td,p = heapq.heappop(stack)\\n\\n\\t\\t\\t\\tif dist[p] != math.inf:\\n\\t\\t\\t\\t\\tcontinue\\n\\n\\t\\t\\t\\tdist[p] = d\\n\\n\\t\\t\\t\\tfor val in graph[p]:\\n\\t\\t\\t\\t\\tif dist[val] == math.inf:\\n\\t\\t\\t\\t\\t\\theapq.heappush(stack,(d+1,val))\\n\\t\\t\\tans = 0\\n\\n\\t\\t\\tfor i in range(1,len(patience)):\\n\\t\\t\\t\\ttot = 2*dist[i] + patience[0]\\n\\t\\t\\t\\tp,r = divmod(tot,patience[i])\\n\\t\\t\\t\\tif r == 0:\\n\\t\\t\\t\\t\\tp-= 1\\n\\t\\t\\t\\tout = tot+ p*patience[i]\\n\\n\\t\\t\\t\\tans = max(ans,out)\\n\\t\\t\\treturn ans+1\\n",
                "codeTag": "Java"
            },
            {
                "id": 2466078,
                "title": "java-01-bfs-djikstra-s-algorithm-01-bfs-djikstra",
                "content": "```\\nclass Solution {\\n    class Item{\\n        int vertex,dist;\\n        Item(int vertex,int dist){\\n            this.vertex=vertex;\\n            this.dist=dist;\\n        }\\n        public int getDist(){\\n            return dist;\\n        }\\n    }\\n    public int networkBecomesIdle(int[][] edges, int[] patience) {\\n        int n = patience.length;\\n        List<List<Integer>> adjlist = new ArrayList<>();\\n        for(int index=0;index<n;index++){\\n            adjlist.add(new ArrayList<>());\\n        }\\n\\t\\t// Creating Graph as Adjacency list\\n        for(int index=0;index<edges.length;index++){\\n            adjlist.get(edges[index][0]).add(edges[index][1]);\\n            adjlist.get(edges[index][1]).add(edges[index][0]);\\n        }\\n\\t\\t// Finding shortest distance reach from source vertex 0 to all other vertices using 01 BFS.\\n\\t\\t// This means finding shortest path between master server 0 to all other data servers in given graph.\\n        int[] distance =new int[n];\\n        Arrays.fill(distance,Integer.MAX_VALUE);\\n        distance[0]=0;\\n        Comparator<Item> sorter = Comparator.comparing(Item::getDist);\\n        PriorityQueue<Item> heap = new PriorityQueue<>(sorter);\\n        heap.add(new Item(0,0));\\n        while(!heap.isEmpty()){\\n            Item polled = heap.poll();\\n            int curr = polled.vertex;\\n            List<Integer> neighbours = adjlist.get(curr);\\n            for(int index=0;index<neighbours.size();index++){\\n                int nearby = neighbours.get(index);\\n                if((distance[curr]+1)<distance[nearby]){\\n                    distance[nearby]=distance[curr]+1;\\n                    heap.add(new Item(nearby,distance[nearby]));\\n                }\\n            }\\n        }\\n\\t\\t// An arraylist to store the last message\\'s reply received time for every vertex from 1 to N-1\\n        List<Integer> timeOfLastReplyReceived = new ArrayList<>();\\n        for(int vertex=1;vertex<n;vertex++){\\n            int firstMsgReplyTime = distance[vertex]+distance[vertex]; // Time at which the reply received by data server for first message sent at 0 seconds \\n            int numExtraMsgs = 0,lastMsgSendTime=-1;\\n            int lastMsgReplyReceivedTime = firstMsgReplyTime;\\n\\t\\t\\t// If patience of vertex is less than the time at which the reply for first message from this vertex is received by this vertex, then calculate how many extra messages this vertex has send to master vertex 0.\\n\\t\\t\\t// Also calculate the reply time received by this vertex for the last message send from this vertex to master vertex 0.\\n            if(patience[vertex]<firstMsgReplyTime){\\n                numExtraMsgs = (firstMsgReplyTime-1)/patience[vertex];\\n                lastMsgSendTime = numExtraMsgs*patience[vertex];\\n                lastMsgReplyReceivedTime = lastMsgSendTime+distance[vertex]+distance[vertex];  \\n            }\\n            timeOfLastReplyReceived.add(lastMsgReplyReceivedTime);\\n        }\\n\\t\\t// Sort the time at which the last message\\'s REPLY has been received by every vertex (data server)\\n        Collections.sort(timeOfLastReplyReceived);\\n        return ((timeOfLastReplyReceived.get(timeOfLastReplyReceived.size()-1))+1); // Return the greatest time plus one as answer.\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution {\\n    class Item{\\n        int vertex,dist;\\n        Item(int vertex,int dist){\\n            this.vertex=vertex;\\n            this.dist=dist;\\n        }\\n        public int getDist(){\\n            return dist;\\n        }\\n    }\\n    public int networkBecomesIdle(int[][] edges, int[] patience) {\\n        int n = patience.length;\\n        List<List<Integer>> adjlist = new ArrayList<>();\\n        for(int index=0;index<n;index++){\\n            adjlist.add(new ArrayList<>());\\n        }\\n\\t\\t// Creating Graph as Adjacency list\\n        for(int index=0;index<edges.length;index++){\\n            adjlist.get(edges[index][0]).add(edges[index][1]);\\n            adjlist.get(edges[index][1]).add(edges[index][0]);\\n        }\\n\\t\\t// Finding shortest distance reach from source vertex 0 to all other vertices using 01 BFS.\\n\\t\\t// This means finding shortest path between master server 0 to all other data servers in given graph.\\n        int[] distance =new int[n];\\n        Arrays.fill(distance,Integer.MAX_VALUE);\\n        distance[0]=0;\\n        Comparator<Item> sorter = Comparator.comparing(Item::getDist);\\n        PriorityQueue<Item> heap = new PriorityQueue<>(sorter);\\n        heap.add(new Item(0,0));\\n        while(!heap.isEmpty()){\\n            Item polled = heap.poll();\\n            int curr = polled.vertex;\\n            List<Integer> neighbours = adjlist.get(curr);\\n            for(int index=0;index<neighbours.size();index++){\\n                int nearby = neighbours.get(index);\\n                if((distance[curr]+1)<distance[nearby]){\\n                    distance[nearby]=distance[curr]+1;\\n                    heap.add(new Item(nearby,distance[nearby]));\\n                }\\n            }\\n        }\\n\\t\\t// An arraylist to store the last message\\'s reply received time for every vertex from 1 to N-1\\n        List<Integer> timeOfLastReplyReceived = new ArrayList<>();\\n        for(int vertex=1;vertex<n;vertex++){\\n            int firstMsgReplyTime = distance[vertex]+distance[vertex]; // Time at which the reply received by data server for first message sent at 0 seconds \\n            int numExtraMsgs = 0,lastMsgSendTime=-1;\\n            int lastMsgReplyReceivedTime = firstMsgReplyTime;\\n\\t\\t\\t// If patience of vertex is less than the time at which the reply for first message from this vertex is received by this vertex, then calculate how many extra messages this vertex has send to master vertex 0.\\n\\t\\t\\t// Also calculate the reply time received by this vertex for the last message send from this vertex to master vertex 0.\\n            if(patience[vertex]<firstMsgReplyTime){\\n                numExtraMsgs = (firstMsgReplyTime-1)/patience[vertex];\\n                lastMsgSendTime = numExtraMsgs*patience[vertex];\\n                lastMsgReplyReceivedTime = lastMsgSendTime+distance[vertex]+distance[vertex];  \\n            }\\n            timeOfLastReplyReceived.add(lastMsgReplyReceivedTime);\\n        }\\n\\t\\t// Sort the time at which the last message\\'s REPLY has been received by every vertex (data server)\\n        Collections.sort(timeOfLastReplyReceived);\\n        return ((timeOfLastReplyReceived.get(timeOfLastReplyReceived.size()-1))+1); // Return the greatest time plus one as answer.\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2411029,
                "title": "c-math-easy-explanation",
                "content": "1) The first thing to do is to find the shortest distance of each data server from the master server. This can be done using dijkstra\\'s algorithm by considering master server as the source node.\\n2) Notice that for the first message of each data server, the message will take 2* dis[node] seconds to reach back to the data server. In the mean-time additional feedback messages are sent, let us find how many will be sent.\\n3) For node i, let p = patience[i] and t = traverse_time = 2*dis[i].\\n\\ttaking eg. p = 3 and t = 8 :\\n\\twe notice message m0 at 0 , m1 at 3 and m2 at 6 will be sent.\\n\\tafter the m0 is recieved at the node i, m1,m2 will come at interval of 3 seconds.\\n\\tso Idle_time[i] = 8+(3-1)*3 = 14 seconds.\\n\\t\\n\\t\\n\\tfor another node j with p = 3 and t = 6 :\\n\\tm0 at 0 , m1 at 3, m2 at 6 will be sent.\\n\\tso Idle_time[j] = 6+(3-1)*3 = 12 seconds.\\n\\t\\n\\tso, in general for node u, Idle_time[u] = traverse_time + (num_messages-1)*patience[u] .\\n\\t\\n\\twe see when t isn\\'t divisible by p an additional message gets sent along with t/p messages.\\n\\tHence,\\n\\tnum_messages = traverse_time/patience[u] .\\n\\tif(traverse_time % patience[u]) num_messages++ .\\n4) So using this equation we can find the idle time of all the data servers from node 1 to n-1 . The network hence becomes idle one second after the node requiring the maximum idle_time becomes idle.\\n```\\nint networkBecomesIdle(vector<vector<int>>& edges, vector<int>& patience) {\\n        int n = patience.size();\\n        vector<int> graph[n],dis(n,1e9),idleTime(n);\\n        for(auto edge: edges){\\n            int v1 = edge[0], v2 = edge[1];\\n            graph[v1].push_back(v2);\\n            graph[v2].push_back(v1);\\n        }\\n        dis[0] = 0;\\n        priority_queue<pair<int,int>,vector<pair<int,int>>,greater<pair<int,int>>> pq;\\n        pq.push({0,0});\\n        while(!pq.empty()){\\n            int u = pq.top().second;\\n            int currDis = pq.top().first;\\n            pq.pop();\\n            if(currDis>dis[u]) continue;\\n            for(auto v: graph[u]){\\n                if(dis[v]>currDis+1){\\n                    dis[v] = currDis+1;\\n                    pq.push({dis[v],v});\\n                }\\n            }\\n        }\\n        int ans = 0;\\n        for(int i=1;i<n;i++){\\n            int num = (2*dis[i])/patience[i];\\n            if((2*dis[i])%patience[i]) num++;\\n            ans = max(ans,(2*dis[i])+(num-1)*patience[i]+1);\\n        }\\n        return ans;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\nint networkBecomesIdle(vector<vector<int>>& edges, vector<int>& patience) {\\n        int n = patience.size();\\n        vector<int> graph[n],dis(n,1e9),idleTime(n);\\n        for(auto edge: edges){\\n            int v1 = edge[0], v2 = edge[1];\\n            graph[v1].push_back(v2);\\n            graph[v2].push_back(v1);\\n        }\\n        dis[0] = 0;\\n        priority_queue<pair<int,int>,vector<pair<int,int>>,greater<pair<int,int>>> pq;\\n        pq.push({0,0});\\n        while(!pq.empty()){\\n            int u = pq.top().second;\\n            int currDis = pq.top().first;\\n            pq.pop();\\n            if(currDis>dis[u]) continue;\\n            for(auto v: graph[u]){\\n                if(dis[v]>currDis+1){\\n                    dis[v] = currDis+1;\\n                    pq.push({dis[v],v});\\n                }\\n            }\\n        }\\n        int ans = 0;\\n        for(int i=1;i<n;i++){\\n            int num = (2*dis[i])/patience[i];\\n            if((2*dis[i])%patience[i]) num++;\\n            ans = max(ans,(2*dis[i])+(num-1)*patience[i]+1);\\n        }\\n        return ans;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2401566,
                "title": "c-dijkstra-math-based-solution-easy",
                "content": "class Solution {\\n\\n\\tpublic:   \\n\\tusing p = pair<int,int>;\\n    \\n    int networkBecomesIdle(vector<vector<int>>& edges, vector<int>& patience) {\\n        int n = patience.size();\\n        \\n        vector<vector<p>> graph(n, vector<p>());\\n        // here 1 is the (distance or time taken to reach) of edge\\n        for(auto road:edges){\\n            graph[road[0]].push_back({road[1], 1});\\n            graph[road[1]].push_back({road[0], 1});\\n        }\\n        \\n        vector<int> dist(n, INT_MAX);\\n        dist[0]=0;\\n        // min heap for dijkstra\\n        priority_queue<p, vector<p>, greater<p>> pq;\\n        pq.push({dist[0], 0});\\n        \\n        while(!pq.empty()){\\n            int u = pq.top().second;\\n            pq.pop();\\n            \\n            for(auto i: graph[u]){\\n                int v = i.first;\\n                int w = i.second;\\n                \\n                if(dist[u] + w < dist[v]){\\n                    dist[v] = dist[u] + w;\\n                    pq.push(make_pair(dist[v], v));\\n                }\\n            }\\n        }\\n\\t\\t// diskstra done values calculated in dist array\\n        int ans=0;\\n        for (int i=0; i<n; i++){\\n\\t\\t\\t// total distance to be travelled by packet \\n            int d = 2 * dist[i];\\n\\t\\t\\t// patience of that packet\\n            int p = patience[i];\\n            if (d <= p){\\n                ans = max(ans, d);\\n            }\\n            else{\\n\\t\\t\\t\\t// since at d-1 time last packet (see 1st example) will be generated so (d-1)/p\\n\\t\\t\\t\\t// number of extra packets will be generated at 0th second we have 1 packet\\n\\t\\t\\t\\t// so 1+ (d-1)/p\\n                int totalPackets = 1 + (d-1)/p;\\n\\t\\t\\t\\t// length or distance between all the packets generated\\n\\t\\t\\t\\t// packet3 <-(p)-> packet2 <-(p)-> packet1\\n                int chainLength = (totalPackets-1)*p;\\n\\t\\t\\t\\t// last packet has to travel this extra packet chain length so d+chainLength\\n                ans = max(ans, d + chainLength);\\n            }\\n        }\\n        \\n        return ans+1;\\n    }\\n};",
                "solutionTags": [
                    "Math"
                ],
                "code": "class Solution {\\n\\n\\tpublic:   \\n\\tusing p = pair<int,int>;\\n    \\n    int networkBecomesIdle(vector<vector<int>>& edges, vector<int>& patience) {\\n        int n = patience.size();\\n        \\n        vector<vector<p>> graph(n, vector<p>());\\n        // here 1 is the (distance or time taken to reach) of edge\\n        for(auto road:edges){\\n            graph[road[0]].push_back({road[1], 1}",
                "codeTag": "Java"
            },
            {
                "id": 2382875,
                "title": "c-bfs-dp-single-source-shortest-path",
                "content": "\\tclass Solution {\\n\\tpublic:\\n\\n\\t\\tint bfs(int n , vector<int> adj[] , vector<int> &patience){\\n\\n\\t\\t\\tvector<int> distance(n , INT_MAX);\\n\\t\\t\\tdistance[0] = 0;\\n\\n\\t\\t\\tqueue<int> q;\\n\\t\\t\\tq.push(0);\\n\\n\\t\\t\\twhile(!q.empty()){\\n\\t\\t\\t\\tauto node = q.front();\\n\\t\\t\\t\\tq.pop();\\n\\n\\t\\t\\t\\tfor(auto child : adj[node]){\\n\\t\\t\\t\\t\\t if(distance[child] == INT_MAX){\\n\\t\\t\\t\\t\\t\\t distance[child] = 1 + distance[node];\\n\\t\\t\\t\\t\\t\\t q.push(child);\\n\\t\\t\\t\\t\\t }\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\n\\t\\t\\tint ans = 0;\\n\\t\\t\\tfor(int i = 1 ; i < n ; i++){\\n\\t\\t\\t\\tans = max(ans , 2*distance[i] +  ((2*distance[i] - 1)/patience[i]) * patience[i] );\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn ans + 1;\\n\\t\\t}\\n\\n\\t\\tint networkBecomesIdle(vector<vector<int>>& edges, vector<int>& patience) {\\n\\n\\t\\t\\tint n = patience.size();  \\n\\t\\t\\tvector<int> adj[n];\\n\\n\\t\\t\\tfor(auto it : edges){\\n\\t\\t\\t\\tadj[it[0]].push_back(it[1]);\\n\\t\\t\\t\\tadj[it[1]].push_back(it[0]);\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn bfs(n , adj , patience);\\n\\t\\t}\\n\\t};",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Breadth-First Search",
                    "Graph"
                ],
                "code": "class Solution {\\n\\tpublic:\\n\\n\\t\\tint bfs(int n , vector<int> adj[] , vector<int> &patience){\\n\\n\\t\\t\\tvector<int> distance(n , INT_MAX);\\n\\t\\t\\tdistance[0] = 0;\\n\\n\\t\\t\\tqueue<int> q;\\n\\t\\t\\tq.push(0);\\n\\n\\t\\t\\twhile(!q.empty()){\\n\\t\\t\\t\\tauto node = q.front();\\n\\t\\t\\t\\tq.pop();\\n\\n\\t\\t\\t\\tfor(auto child : adj[node]){\\n\\t\\t\\t\\t\\t if(distance[child] == INT_MAX){\\n\\t\\t\\t\\t\\t\\t distance[child] = 1 + distance[node];\\n\\t\\t\\t\\t\\t\\t q.push(child);\\n\\t\\t\\t\\t\\t }",
                "codeTag": "Java"
            },
            {
                "id": 2355233,
                "title": "easy-java-level-order-traversal",
                "content": "```\\nclass Solution {\\n    public int networkBecomesIdle(int[][] edges, int[] patience) {\\n        int n = patience.length;\\n      List<Integer>[] li = new ArrayList[n];\\n      for(int i=0; i<n; i++) {\\n        li[i] = new ArrayList<>();\\n      }\\n      \\n      for(int[] edge : edges) {\\n        li[edge[0]].add(edge[1]);\\n        li[edge[1]].add(edge[0]);\\n      }\\n      \\n      Queue<Integer> que = new LinkedList<>();\\n      int[] visited = new int[n];\\n      Arrays.fill(visited,-1);\\n      visited[0] = 0;\\n      que.add(0);\\n      int level = 0;\\n      \\n      while(!que.isEmpty()) {\\n        int size = que.size();\\n        level++;\\n        while(size-->0) {\\n          int node = que.poll();\\n        for(int neigh : li[node]) {\\n          if(visited[neigh]==-1) {\\n            visited[neigh] = 2*level;\\n            que.offer(neigh);\\n          }\\n        }\\n        }\\n      }\\n      \\n      int res = 0;\\n      int currDist = 0;\\n      for(int i=1; i<n; i++) {\\n        int val = visited[i]%patience[i];\\n          res = Math.max(res, 2*visited[i]-(val==0?patience[i]:val));\\n      }\\n      return res+1;\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public int networkBecomesIdle(int[][] edges, int[] patience) {\\n        int n = patience.length;\\n      List<Integer>[] li = new ArrayList[n];\\n      for(int i=0; i<n; i++) {\\n        li[i] = new ArrayList<>();\\n      }",
                "codeTag": "Java"
            },
            {
                "id": 2353546,
                "title": "solution-c-bfs-explanation",
                "content": "**Explanation**:\\n- main idea is to find the last time any node receives a message. \\n- a trip back to data server takes 2 * distance time. \\n- a data server stops broadcasting the first time it receives a message.  last time it could have broadcasted would be `2*distance[i] - 1` . so last time it would broadcast message is\\n ```\\n\\t s =  ((2*distance[i]-1) / patience[i])*patience[i] \\n ``` \\n- so last time it would receive would be ` t =  s*distance[i] `. \\n- then take max of all values. the first idle time would be next second of it. \\n\\n**Space complexity**: `O(n)`\\n**time complexity**: `O(n + e)`\\n\\n```cpp\\nclass Solution {\\npublic:\\n    int networkBecomesIdle(vector<vector<int>>& edges, vector<int>& patience) {\\n         int n = patience.size();\\n         vector<int>adjList[n];\\n\\n         vector<int>distance(n, INT_MAX);\\n\\n         distance[0]=0;\\n\\n        for(auto &it: edges) {\\n            adjList[it[0]].push_back(it[1]);\\n            adjList[it[1]].push_back(it[0]);\\n        }\\n\\n        queue<int>q;\\n\\n        q.push(0); // server node. \\n\\n        // finding shortest path to all nodes from server.\\n        while(!q.empty()) {\\n            int node = q.front();\\n\\n            q.pop();\\n\\n            for(auto it: adjList[node]) {\\n                if(distance[node] + 1 < distance[it]) {\\n                    distance[it]=distance[node]+1;\\n                    q.push(it);\\n                }\\n            }\\n        }\\n\\n        int lastTimeMessageReceived = 0, lastTimeMessageSent, times = INT_MAX;\\n\\n        // finding last time a data server sent a message to main server.\\n        for(int i = 1; i < n; i++) {\\n            times = (2*distance[i]-1) / patience[i];\\n\\n            lastTimeMessageSent = times * patience[i];\\n\\n            lastTimeMessageReceived = max(lastTimeMessageSent + distance[i]*2, lastTimeMessageReceived);\\n\\n        }\\n\\n        return lastTimeMessageReceived + 1;\\n    }\\n};\\n\\n```\\n\\n\\n",
                "solutionTags": [],
                "code": "```\\n\\t s =  ((2*distance[i]-1) / patience[i])*patience[i] \\n ```\n```cpp\\nclass Solution {\\npublic:\\n    int networkBecomesIdle(vector<vector<int>>& edges, vector<int>& patience) {\\n         int n = patience.size();\\n         vector<int>adjList[n];\\n\\n         vector<int>distance(n, INT_MAX);\\n\\n         distance[0]=0;\\n\\n        for(auto &it: edges) {\\n            adjList[it[0]].push_back(it[1]);\\n            adjList[it[1]].push_back(it[0]);\\n        }\\n\\n        queue<int>q;\\n\\n        q.push(0); // server node. \\n\\n        // finding shortest path to all nodes from server.\\n        while(!q.empty()) {\\n            int node = q.front();\\n\\n            q.pop();\\n\\n            for(auto it: adjList[node]) {\\n                if(distance[node] + 1 < distance[it]) {\\n                    distance[it]=distance[node]+1;\\n                    q.push(it);\\n                }\\n            }\\n        }\\n\\n        int lastTimeMessageReceived = 0, lastTimeMessageSent, times = INT_MAX;\\n\\n        // finding last time a data server sent a message to main server.\\n        for(int i = 1; i < n; i++) {\\n            times = (2*distance[i]-1) / patience[i];\\n\\n            lastTimeMessageSent = times * patience[i];\\n\\n            lastTimeMessageReceived = max(lastTimeMessageSent + distance[i]*2, lastTimeMessageReceived);\\n\\n        }\\n\\n        return lastTimeMessageReceived + 1;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2345927,
                "title": "simple-c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int networkBecomesIdle(vector<vector<int>>& edges, vector<int>& patience) {\\n        int n = patience.size();\\n        queue<vector<int>> q;\\n        vector<int> dist(n, INT_MAX);\\n        vector<vector<int> > graph(n);\\n        for(auto e : edges) {\\n            int u = e[0], v = e[1];\\n            graph[u].push_back(v);\\n            graph[v].push_back(u);\\n        }\\n        dist[0] = 0;\\n        q.push({0, 0});\\n        while(!q.empty()) {\\n            int node = q.front()[0];\\n            int d = q.front()[1];\\n            q.pop();\\n            for(auto nbr : graph[node]) {\\n                if(dist[nbr] != INT_MAX) continue;\\n                q.push({nbr, d+1});\\n                dist[nbr] = d+1;\\n            }\\n        }\\n        int res = 0;\\n        for(int i = 1; i < n; i++) {\\n            int val = 2*dist[i] + patience[i]*((2*dist[i]-1)/patience[i]) + 1;\\n            res = max(res,val);\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Math",
                    "Breadth-First Search",
                    "Graph"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int networkBecomesIdle(vector<vector<int>>& edges, vector<int>& patience) {\\n        int n = patience.size();\\n        queue<vector<int>> q;\\n        vector<int> dist(n, INT_MAX);\\n        vector<vector<int> > graph(n);\\n        for(auto e : edges) {\\n            int u = e[0], v = e[1];\\n            graph[u].push_back(v);\\n            graph[v].push_back(u);\\n        }\\n        dist[0] = 0;\\n        q.push({0, 0});\\n        while(!q.empty()) {\\n            int node = q.front()[0];\\n            int d = q.front()[1];\\n            q.pop();\\n            for(auto nbr : graph[node]) {\\n                if(dist[nbr] != INT_MAX) continue;\\n                q.push({nbr, d+1});\\n                dist[nbr] = d+1;\\n            }\\n        }\\n        int res = 0;\\n        for(int i = 1; i < n; i++) {\\n            int val = 2*dist[i] + patience[i]*((2*dist[i]-1)/patience[i]) + 1;\\n            res = max(res,val);\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2326908,
                "title": "c-o-n-time-o-n-space-bfs",
                "content": "```\\nclass Solution {\\npublic:\\n    int networkBecomesIdle(vector<vector<int>> &g , vector<int>& pat) {\\n        int n = pat.size();\\n        vector<int> adj[n];\\n        for(int i=0 ; i<g.size() ; i++) {\\n            int u = g[i][0];\\n            int v = g[i][1];\\n            adj[u].push_back(v);\\n            adj[v].push_back(u);\\n        }\\n        queue<int> q;\\n        vector<int> dist(n , INT_MAX);\\n        dist[0] = 0;\\n        q.push(0);\\n        while(!q.empty()) {\\n            int u = q.front();\\n            q.pop();\\n            for(int v : adj[u]) {\\n                if(dist[v] > dist[u] + 1) {\\n                    q.push(v);\\n                    dist[v] = dist[u] + 1;\\n                }\\n            }\\n        }\\n        int ans = 0;\\n        for(int i=0 ; i<n ; i++) {\\n            if(pat[i] == 0) continue;\\n            int r = (2*dist[i]) % pat[i];\\n            if(r == 0) ans = max(ans , 2*dist[i] + dist[i] - r + dist[i] - pat[i]); \\n            else ans = max(ans , 2*dist[i] + dist[i] - r + dist[i]);\\n        }\\n        return ans + 1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Math",
                    "Breadth-First Search",
                    "Shortest Path"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int networkBecomesIdle(vector<vector<int>> &g , vector<int>& pat) {\\n        int n = pat.size();\\n        vector<int> adj[n];\\n        for(int i=0 ; i<g.size() ; i++) {\\n            int u = g[i][0];\\n            int v = g[i][1];\\n            adj[u].push_back(v);\\n            adj[v].push_back(u);\\n        }\\n        queue<int> q;\\n        vector<int> dist(n , INT_MAX);\\n        dist[0] = 0;\\n        q.push(0);\\n        while(!q.empty()) {\\n            int u = q.front();\\n            q.pop();\\n            for(int v : adj[u]) {\\n                if(dist[v] > dist[u] + 1) {\\n                    q.push(v);\\n                    dist[v] = dist[u] + 1;\\n                }\\n            }\\n        }\\n        int ans = 0;\\n        for(int i=0 ; i<n ; i++) {\\n            if(pat[i] == 0) continue;\\n            int r = (2*dist[i]) % pat[i];\\n            if(r == 0) ans = max(ans , 2*dist[i] + dist[i] - r + dist[i] - pat[i]); \\n            else ans = max(ans , 2*dist[i] + dist[i] - r + dist[i]);\\n        }\\n        return ans + 1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2315795,
                "title": "dijkstra-solution-python3",
                "content": "```\\nfrom sys import maxsize\\nimport heapq\\nclass Solution:\\n    def networkBecomesIdle(self, edges: List[List[int]], pat: List[int]) -> int:\\n        graph=defaultdict(lambda:[])\\n        n=len(pat)\\n        for u,v in edges:\\n            graph[u].append(v)\\n            graph[v].append(u)\\n        dist=[maxsize]*n\\n        dist[0]=0\\n        heap=[]\\n        heapq.heapify(heap)\\n        heapq.heappush(heap,(0,0))\\n        while len(heap)>0:\\n            f=heapq.heappop(heap)\\n            s1=f[1]\\n            d1=f[0]*-1\\n            for s2 in graph[s1]:\\n                if dist[s2]>dist[s1]+1:\\n                    dist[s2]=dist[s1]+1\\n                    heapq.heappush(heap,(-dist[s2],s2))\\n        ans=0            \\n        for i in range(1,n):\\n            if 2*dist[i]<=pat[i]:\\n                ans=max(ans,2*dist[i])\\n            else:\\n                x=pat[i]\\n                a=x\\n                b=2*dist[i]\\n                if (b-a)%x==0:\\n                    q=(b-a)//x\\n                    a=a+(q-1)*x\\n                else:\\n                    q=(b-a)//x\\n                    a=a+q*x\\n                ans=max(ans,a+2*dist[i])\\n        return ans+1        \\n        \\n        \\n        \\n```",
                "solutionTags": [],
                "code": "```\\nfrom sys import maxsize\\nimport heapq\\nclass Solution:\\n    def networkBecomesIdle(self, edges: List[List[int]], pat: List[int]) -> int:\\n        graph=defaultdict(lambda:[])\\n        n=len(pat)\\n        for u,v in edges:\\n            graph[u].append(v)\\n            graph[v].append(u)\\n        dist=[maxsize]*n\\n        dist[0]=0\\n        heap=[]\\n        heapq.heapify(heap)\\n        heapq.heappush(heap,(0,0))\\n        while len(heap)>0:\\n            f=heapq.heappop(heap)\\n            s1=f[1]\\n            d1=f[0]*-1\\n            for s2 in graph[s1]:\\n                if dist[s2]>dist[s1]+1:\\n                    dist[s2]=dist[s1]+1\\n                    heapq.heappush(heap,(-dist[s2],s2))\\n        ans=0            \\n        for i in range(1,n):\\n            if 2*dist[i]<=pat[i]:\\n                ans=max(ans,2*dist[i])\\n            else:\\n                x=pat[i]\\n                a=x\\n                b=2*dist[i]\\n                if (b-a)%x==0:\\n                    q=(b-a)//x\\n                    a=a+(q-1)*x\\n                else:\\n                    q=(b-a)//x\\n                    a=a+q*x\\n                ans=max(ans,a+2*dist[i])\\n        return ans+1        \\n        \\n        \\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2311992,
                "title": "simple-bfs-the-formula",
                "content": "1. Time will take to reach master server = shortest path from  that server to master server (used BFS for that since path cost is constant otherwise we would have used BFS + priority queue also known as dijkstra algo)\\n2. So the total time will be 2 * ( shortest path from  that server to master server )\\n3. In that period, find out the last time the server release the message( please refer the description explaination of the question) formula;  waitingTime = ( (2 * ( shortest path from  that server to master server ) -1) // patience[i]) * patience[i]\\n4. for server i, totalWaitingTime = 2 * ( shortest path from  that server to master server ) + waitingTime\\n5. return the maximum (totalWaitingTime + 1)\\n\\n```\\nfrom collections import defaultdict\\nclass Solution:\\n    def networkBecomesIdle(self, edges: List[List[int]], patience: List[int]) -> int:\\n        graph = defaultdict(list)\\n        N = len(patience)\\n        for x,y in edges:\\n            graph[x].append(y)\\n            graph[y].append(x)\\n            \\n        Q = [(0,0)]\\n        isVisited = [0] * N\\n        isVisited[0] = 1\\n        def BFS():\\n            nonlocal Q\\n            nonlocal isVisited\\n            nonlocal graph\\n            nonlocal patience\\n            ans = 0\\n            while Q:\\n                node, level = Q.pop(0)\\n                waitingTime = max(1,patience[node])\\n                lastNodeTime = ((2*level-1)// waitingTime) * patience[node]\\n                ans = max(ans , 2*level + lastNodeTime)\\n                for x in graph[node]:\\n                    if isVisited[x] == 0:\\n                        isVisited[x] = 1\\n                        Q.append((x, level+1))\\n            return ans                \\n        \\n        return BFS()+1\\n```",
                "solutionTags": [
                    "Python",
                    "Graph"
                ],
                "code": "```\\nfrom collections import defaultdict\\nclass Solution:\\n    def networkBecomesIdle(self, edges: List[List[int]], patience: List[int]) -> int:\\n        graph = defaultdict(list)\\n        N = len(patience)\\n        for x,y in edges:\\n            graph[x].append(y)\\n            graph[y].append(x)\\n            \\n        Q = [(0,0)]\\n        isVisited = [0] * N\\n        isVisited[0] = 1\\n        def BFS():\\n            nonlocal Q\\n            nonlocal isVisited\\n            nonlocal graph\\n            nonlocal patience\\n            ans = 0\\n            while Q:\\n                node, level = Q.pop(0)\\n                waitingTime = max(1,patience[node])\\n                lastNodeTime = ((2*level-1)// waitingTime) * patience[node]\\n                ans = max(ans , 2*level + lastNodeTime)\\n                for x in graph[node]:\\n                    if isVisited[x] == 0:\\n                        isVisited[x] = 1\\n                        Q.append((x, level+1))\\n            return ans                \\n        \\n        return BFS()+1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2280299,
                "title": "bfs-explained-c",
                "content": "Make a graph where ith index stores the edges connected with ith vertex directly.\\nBfs using a queue where we push all the edges of curr level to queue and also calculate their time.\\nFor time calculation -> Assume a vertex is at level n, then the minimum time for this server to go idle will be T = [2 x n] as a msg needs to go to root taking n time and then returning taking n time. Now considering the patience also. \\nCheck no of extra msgs generated in time T. The no of extra msgs generated will be (T-1)/patience , T-1 because at last second our first msg has got back so no new msg can generate now. Now if the extra msgs were generated after every p second. Then they will get back after p second of first msg. So total time will be T + extra x patience.\\nFind the max time using the approach. \\n\\n*Implementation ->*\\n```\\nclass Solution {\\npublic:\\n    int networkBecomesIdle(vector<vector<int>>& edges, vector<int>& patience) {\\n        int n = patience.size();\\n        vector<vector<int>> graph(n);\\n        int x,y;\\n        // a graph storing all the edges whcich curr vertex is connected to\\n        for(int i=0; i<edges.size(); i++){\\n            x = edges[i][0]; y = edges[i][1];\\n            graph[x].push_back(y);\\n            graph[y].push_back(x);\\n        }\\n        // to maintain the server visited\\n        vector<int> visited(n,0);\\n        visited[0] = 1;\\n        // queue for the bfs\\n        queue<int> q; q.push(0);\\n        int time, curr, ans = 0;\\n        int lvl = 0;\\n        while(!q.empty() && q.front() != -1){\\n            // for separating the levels\\n            q.push(-1);\\n            lvl++;\\n            while(q.front() != -1){\\n                curr = q.front();\\n                q.pop();\\n                // for curr server find the time for all the servers next to it, it means the next level servers\\n                for(int i=0; i<graph[curr].size(); i++){\\n                    if(!visited[graph[curr][i]]){\\n                        q.push(graph[curr][i]);\\n                        // mark visited\\n                        visited[graph[curr][i]] = 1;\\n                        // calculating time for each server\\n                        time = ((2*lvl-1)/patience[graph[curr][i]])*patience[graph[curr][i]];\\n                        time = max(0, time);\\n                        time += 2*lvl;\\n                        ans = max(ans, time);\\n                    }\\n                }\\n            }\\n            q.pop();\\n        }\\n        //return the next second \\n        return ans+1;\\n    }\\n};\\nstatic const auto speedup =[](){\\n    std::ios::sync_with_stdio(false);\\n    std::cin.tie(nullptr);\\n    std::cout.tie(nullptr);\\n    return 0;\\n}();\\n```",
                "solutionTags": [
                    "C",
                    "Breadth-First Search",
                    "Queue"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int networkBecomesIdle(vector<vector<int>>& edges, vector<int>& patience) {\\n        int n = patience.size();\\n        vector<vector<int>> graph(n);\\n        int x,y;\\n        // a graph storing all the edges whcich curr vertex is connected to\\n        for(int i=0; i<edges.size(); i++){\\n            x = edges[i][0]; y = edges[i][1];\\n            graph[x].push_back(y);\\n            graph[y].push_back(x);\\n        }\\n        // to maintain the server visited\\n        vector<int> visited(n,0);\\n        visited[0] = 1;\\n        // queue for the bfs\\n        queue<int> q; q.push(0);\\n        int time, curr, ans = 0;\\n        int lvl = 0;\\n        while(!q.empty() && q.front() != -1){\\n            // for separating the levels\\n            q.push(-1);\\n            lvl++;\\n            while(q.front() != -1){\\n                curr = q.front();\\n                q.pop();\\n                // for curr server find the time for all the servers next to it, it means the next level servers\\n                for(int i=0; i<graph[curr].size(); i++){\\n                    if(!visited[graph[curr][i]]){\\n                        q.push(graph[curr][i]);\\n                        // mark visited\\n                        visited[graph[curr][i]] = 1;\\n                        // calculating time for each server\\n                        time = ((2*lvl-1)/patience[graph[curr][i]])*patience[graph[curr][i]];\\n                        time = max(0, time);\\n                        time += 2*lvl;\\n                        ans = max(ans, time);\\n                    }\\n                }\\n            }\\n            q.pop();\\n        }\\n        //return the next second \\n        return ans+1;\\n    }\\n};\\nstatic const auto speedup =[](){\\n    std::ios::sync_with_stdio(false);\\n    std::cin.tie(nullptr);\\n    std::cout.tie(nullptr);\\n    return 0;\\n}();\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2278103,
                "title": "the-time-when-network-becomes-idle-c-explained-solution",
                "content": "The problem here is a simple shortest path question. Basically first we need to calculate the shortest path of a node from Master Server (**0**). Since the graph is unweighted, we can directly use Breadth First Search to obtain shortest path for every node by starting bfs from 0 with **distance[0] = 0**. After we have calculated shortest distance,  we will find max time taken by a node such that all sent out message reach it. As soon as first reply from Node 0 arrives, our Node will stop sending message. Thus if 2 x dis[i] where dis[i] is distance of node **i** from 0 is less than or equal to **patience[i]**, then 2 x dis[i] is max time for this node. In case its greater, then we can see that all messages sent out, each of them reaches back after a gap of patience[i] seconds later than its predecessor message. Thus we can say that time taken in total would be equal to **2 x dis[i] + (sent-1) x patience[i]**. Thus we can do this over all nodes from 1 to N-1 ( 0 not taken cause its master node). Implementation goes below :\\n\\nTime Complexity : O(N)\\nSpace Complexity : O(N)\\n\\nCode \\n```\\nclass Solution {\\npublic:\\n    int networkBecomesIdle(vector<vector<int>>& edges, vector<int>& patience) {\\n        ios_base::sync_with_stdio(0);\\n        int n = patience.size();\\n        vector<int>dis(n,INT_MAX);\\n        vector<vector<int>>servers(n);\\n        for(auto p : edges){\\n            servers[p[0]].push_back(p[1]);\\n            servers[p[1]].push_back(p[0]);\\n        }\\n        vector<bool>visited(n,false);\\n        queue<int>q;\\n        q.push(0);\\n        visited[0] = true;\\n        dis[0] = 0;\\n        while(!q.empty()){\\n            int u = q.front(); q.pop();\\n            for(int v : servers[u]){\\n                if(!visited[v]){\\n                    dis[v] = dis[u]+1;\\n                    q.push(v);\\n                    visited[v] = true;\\n                }\\n            }\\n        }\\n        int ans = 0;\\n        for(int i = 1; i<n; i++){\\n            if(dis[i]*2<=patience[i]){\\n                ans = max(ans,2*dis[i]+1);\\n            }\\n            else{\\n                int sent = ceil((double)(2*dis[i])/patience[i]);\\n                ans = max(ans,(2*dis[i]+(sent-1)*patience[i])+1);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```\\n**Do Upvote !**",
                "solutionTags": [
                    "C",
                    "Math",
                    "Breadth-First Search",
                    "Shortest Path"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int networkBecomesIdle(vector<vector<int>>& edges, vector<int>& patience) {\\n        ios_base::sync_with_stdio(0);\\n        int n = patience.size();\\n        vector<int>dis(n,INT_MAX);\\n        vector<vector<int>>servers(n);\\n        for(auto p : edges){\\n            servers[p[0]].push_back(p[1]);\\n            servers[p[1]].push_back(p[0]);\\n        }\\n        vector<bool>visited(n,false);\\n        queue<int>q;\\n        q.push(0);\\n        visited[0] = true;\\n        dis[0] = 0;\\n        while(!q.empty()){\\n            int u = q.front(); q.pop();\\n            for(int v : servers[u]){\\n                if(!visited[v]){\\n                    dis[v] = dis[u]+1;\\n                    q.push(v);\\n                    visited[v] = true;\\n                }\\n            }\\n        }\\n        int ans = 0;\\n        for(int i = 1; i<n; i++){\\n            if(dis[i]*2<=patience[i]){\\n                ans = max(ans,2*dis[i]+1);\\n            }\\n            else{\\n                int sent = ceil((double)(2*dis[i])/patience[i]);\\n                ans = max(ans,(2*dis[i]+(sent-1)*patience[i])+1);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2274980,
                "title": "java-solution-using-shortest-path-algorithm",
                "content": "Simple BFS solution, calcuate minimum distance of each node from the source and check the turn around time for last packet.\\n\\n\\tclass Solution {\\n\\t\\tpublic int networkBecomesIdle(int[][] edges, int[] patience) {\\n\\t\\t\\tint n=patience.length;\\n\\t\\t\\tArrayList<ArrayList<Integer>> adj = new ArrayList<>();\\n\\t\\t\\tfor(int i=0;i<n;i++)\\n\\t\\t\\t\\tadj.add(new ArrayList<Integer>());\\n\\t\\t\\tfor(int i=0;i<edges.length;i++)\\n\\t\\t\\t{\\n\\t\\t\\t   adj.get(edges[i][0]).add(edges[i][1]);\\n\\t\\t\\t\\tadj.get(edges[i][1]).add(edges[i][0]);\\n\\t\\t\\t}\\n\\t\\t\\tint dist[]=new int[n];\\n\\t\\t\\tfor(int i=0;i<n;i++)\\n\\t\\t\\t\\tdist[i]=Integer.MAX_VALUE;\\n\\t\\t\\tdist[0]=0;\\n\\t\\t\\tQueue<Integer> q = new LinkedList<>();\\n\\t\\t\\tq.add(0);\\n\\t\\t\\tfor(int j=0;j<n-1;j++)\\n\\t\\t\\t{\\n\\t\\t\\t\\tint p = q.poll();\\n\\t\\t\\t\\tfor(int i : adj.get(p))\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tif(dist[i]>dist[p]+1)\\n\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\tdist[i]=dist[p]+1;\\n\\t\\t\\t\\t\\t\\tq.add(i);\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\tint max=0;\\n\\t\\t\\tfor(int i=0;i<n;i++)\\n\\t\\t\\t{\\n\\t\\t\\t\\t//if patience time is greater than turn around time \\n\\t\\t\\t\\t//then no other packet will be introduced by ith node so max time will be just double of distance\\n\\t\\t\\t\\tif(patience[i]>=2*dist[i])      \\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tmax=Math.max(max,2*dist[i]);\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\telse\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tint lasTime = 0;\\n\\t\\t\\t\\t\\t// calculating time for last packet which was introduced by ith node\\n\\t\\t\\t\\t\\tif((2*dist[i])%patience[i]==0)\\n\\t\\t\\t\\t\\t\\tlasTime = 2*dist[i]-patience[i];\\n\\t\\t\\t\\t\\telse\\n\\t\\t\\t\\t\\t\\tlasTime = 2*dist[i]-(2*dist[i])%patience[i];\\n\\t\\t\\t\\t\\t//total time ith node is active is when its last packet reply comes back from source\\n\\t\\t\\t\\t\\tmax=Math.max(max,lasTime+2*dist[i]);\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\t// idle time will be max time network is active +1\\n\\t\\t\\treturn max+1;\\n\\t\\t}\\n\\t}\\n",
                "solutionTags": [
                    "Java",
                    "Breadth-First Search"
                ],
                "code": "class Solution {\\n\\t\\tpublic int networkBecomesIdle(int[][] edges, int[] patience) {\\n\\t\\t\\tint n=patience.length;\\n\\t\\t\\tArrayList<ArrayList<Integer>> adj = new ArrayList<>();\\n\\t\\t\\tfor(int i=0;i<n;i++)\\n\\t\\t\\t\\tadj.add(new ArrayList<Integer>());\\n\\t\\t\\tfor(int i=0;i<edges.length;i++)\\n\\t\\t\\t{\\n\\t\\t\\t   adj.get(edges[i][0]).add(edges[i][1]);\\n\\t\\t\\t\\tadj.get(edges[i][1]).add(edges[i][0]);\\n\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 2272867,
                "title": "python-3-bfs",
                "content": "\\tclass Solution:      \\n\\t\\tdef networkBecomesIdle(self, edges: List[List[int]], patience: List[int]) -> int:\\n\\t\\t\\tn=len(patience)\\n\\t\\t\\tG=[[] for _ in range(n)]\\n\\t\\t\\tfor x,y in edges:\\n\\t\\t\\t\\tG[x].append(y)\\n\\t\\t\\t\\tG[y].append(x)\\n\\t\\t\\tvis,q=[False]*n,[0]\\n\\t\\t\\tvis[0]=True\\n\\t\\t\\tres,d=0,1\\n\\t\\t\\twhile q:\\n\\t\\t\\t\\tnew_q=[]\\n\\t\\t\\t\\tfor node in q:\\n\\t\\t\\t\\t\\tfor child in G[node]:\\n\\t\\t\\t\\t\\t\\tif not vis[child]:\\n\\t\\t\\t\\t\\t\\t\\tres=max(res,2*d+((2*d-1)//patience[child])*patience[child])\\n\\t\\t\\t\\t\\t\\t\\tvis[child]=True\\n\\t\\t\\t\\t\\t\\t\\tnew_q.append(child)\\n\\t\\t\\t\\tq=new_q\\n\\t\\t\\t\\td+=1\\n\\t\\t\\treturn res+1",
                "solutionTags": [
                    "Python3",
                    "Breadth-First Search"
                ],
                "code": "\\tclass Solution:      \\n\\t\\tdef networkBecomesIdle(self, edges: List[List[int]], patience: List[int]) -> int:\\n\\t\\t\\tn=len(patience)\\n\\t\\t\\tG=[[] for _ in range(n)]\\n\\t\\t\\tfor x,y in edges:\\n\\t\\t\\t\\tG[x].append(y)\\n\\t\\t\\t\\tG[y].append(x)\\n\\t\\t\\tvis,q=[False]*n,[0]\\n\\t\\t\\tvis[0]=True\\n\\t\\t\\tres,d=0,1\\n\\t\\t\\twhile q:\\n\\t\\t\\t\\tnew_q=[]\\n\\t\\t\\t\\tfor node in q:\\n\\t\\t\\t\\t\\tfor child in G[node]:\\n\\t\\t\\t\\t\\t\\tif not vis[child]:\\n\\t\\t\\t\\t\\t\\t\\tres=max(res,2*d+((2*d-1)//patience[child])*patience[child])\\n\\t\\t\\t\\t\\t\\t\\tvis[child]=True\\n\\t\\t\\t\\t\\t\\t\\tnew_q.append(child)\\n\\t\\t\\t\\tq=new_q\\n\\t\\t\\t\\td+=1\\n\\t\\t\\treturn res+1",
                "codeTag": "Java"
            },
            {
                "id": 2245578,
                "title": "simple-c-solution-shortest-path-algo-maths",
                "content": "```\\nclass Solution {\\npublic:\\n\\n    int networkBecomesIdle(vector<vector<int>>& edges, vector<int>& patience) {\\n        int n= patience.size();\\n        vector<vector<int>> graph(n);\\n        \\n        //forming graph\\n        for(auto e: edges){\\n            graph[e[0]].push_back(e[1]);\\n            graph[e[1]].push_back(e[0]);\\n        }\\n        \\n        vector<int> minDist(n, INT_MAX);\\n        findMinDistances(minDist, graph); //storing the min dist for all servers from 0.\\n\\n        int latestTime= 0;\\n        for(int i=1; i<n; i++){\\n            \\n            //barring the 1st primary signal, the number of signals produced till 2*dist -1\\n            //seconds (because after the 1st signal reaches the server, no more signals \\n            //will be produced)\\n            int numberOfSecondarySignals= (2*minDist[i] -1)/patience[i];\\n            \\n            //the last secondary signal will be produced after this much time has elapsed\\n            int lastSecondarySignalProducedTime= numberOfSecondarySignals * patience[i];\\n            \\n            //the last secondary signal will reach the server after this much time\\n            int lastSignalReceivedAt= 2*minDist[i] + lastSecondarySignalProducedTime;\\n            \\n            //updating the lastest time\\n            latestTime= max(latestTime, lastSignalReceivedAt);\\n        }\\n        \\n        return latestTime+1;\\n        //latestTime +1, because at the latestTime-th moment, the server just received its \\n        //last msg and is still considered as busy and so we take the next second.\\n    }\\n    \\n    \\n    //storing the min dist of each node from 0 (djikstra)\\n    void findMinDistances(vector<int> &minDist, vector<vector<int>>& graph){\\n        \\n        priority_queue<pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>>> q;\\n        minDist[0]= 0;\\n        q.push({0, 0});\\n\\n        while(!q.empty()){\\n            int currNode= q.top().second;\\n            int dist= q.top().first;\\n            q.pop();\\n            \\n            for(auto &adj: graph[currNode]){\\n                int adjNode= adj;\\n                if(minDist[adj]> dist+ 1){\\n                    minDist[adj]= dist+ 1;\\n                    q.push({minDist[adj], adj});\\n                }\\n            }\\n        }\\n    }\\n}; \\n```",
                "solutionTags": [
                    "C",
                    "Math",
                    "Graph",
                    "Shortest Path"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\n    int networkBecomesIdle(vector<vector<int>>& edges, vector<int>& patience) {\\n        int n= patience.size();\\n        vector<vector<int>> graph(n);\\n        \\n        //forming graph\\n        for(auto e: edges){\\n            graph[e[0]].push_back(e[1]);\\n            graph[e[1]].push_back(e[0]);\\n        }\\n        \\n        vector<int> minDist(n, INT_MAX);\\n        findMinDistances(minDist, graph); //storing the min dist for all servers from 0.\\n\\n        int latestTime= 0;\\n        for(int i=1; i<n; i++){\\n            \\n            //barring the 1st primary signal, the number of signals produced till 2*dist -1\\n            //seconds (because after the 1st signal reaches the server, no more signals \\n            //will be produced)\\n            int numberOfSecondarySignals= (2*minDist[i] -1)/patience[i];\\n            \\n            //the last secondary signal will be produced after this much time has elapsed\\n            int lastSecondarySignalProducedTime= numberOfSecondarySignals * patience[i];\\n            \\n            //the last secondary signal will reach the server after this much time\\n            int lastSignalReceivedAt= 2*minDist[i] + lastSecondarySignalProducedTime;\\n            \\n            //updating the lastest time\\n            latestTime= max(latestTime, lastSignalReceivedAt);\\n        }\\n        \\n        return latestTime+1;\\n        //latestTime +1, because at the latestTime-th moment, the server just received its \\n        //last msg and is still considered as busy and so we take the next second.\\n    }\\n    \\n    \\n    //storing the min dist of each node from 0 (djikstra)\\n    void findMinDistances(vector<int> &minDist, vector<vector<int>>& graph){\\n        \\n        priority_queue<pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>>> q;\\n        minDist[0]= 0;\\n        q.push({0, 0});\\n\\n        while(!q.empty()){\\n            int currNode= q.top().second;\\n            int dist= q.top().first;\\n            q.pop();\\n            \\n            for(auto &adj: graph[currNode]){\\n                int adjNode= adj;\\n                if(minDist[adj]> dist+ 1){\\n                    minDist[adj]= dist+ 1;\\n                    q.push({minDist[adj], adj});\\n                }\\n            }\\n        }\\n    }\\n}; \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2189218,
                "title": "python-bfs-formular",
                "content": "```\\ndef networkBecomesIdle(self, edges: List[List[int]], patience: List[int]) -> int:\\n\\tedic = collections.defaultdict(list)\\n\\tfor a, b in edges:\\n\\t\\tedic[a].append(b)\\n\\t\\tedic[b].append(a)\\n\\tseen = {0:1}\\n\\tans, level = 0, 0\\n\\tcurr = [0]\\n\\twhile curr:\\n\\t\\tnextt = set()\\n\\t\\tfor node in curr:\\n\\t\\t\\tround_trip = level * 2\\n\\t\\t\\tif patience[node] > 0:\\n\\t\\t\\t\\tlast_msg = level * 2 - (level * 2 - 1) % patience[node]\\n\\t\\t\\telse:\\n\\t\\t\\t\\tlast_msg = 0\\n\\t\\t\\tans = max(ans, round_trip + last_msg)\\n\\n\\t\\t\\tfor x in edic[node]:\\n\\t\\t\\t\\tif x in seen:\\n\\t\\t\\t\\t\\tcontinue\\n\\t\\t\\t\\tseen[x] = 1\\n\\t\\t\\t\\tnextt.add(x)\\n\\t\\tcurr = nextt\\n\\t\\tlevel += 1\\n\\treturn ans\\n\\t```",
                "solutionTags": [],
                "code": "```\\ndef networkBecomesIdle(self, edges: List[List[int]], patience: List[int]) -> int:\\n\\tedic = collections.defaultdict(list)\\n\\tfor a, b in edges:\\n\\t\\tedic[a].append(b)\\n\\t\\tedic[b].append(a)\\n\\tseen = {0:1}\\n\\tans, level = 0, 0\\n\\tcurr = [0]\\n\\twhile curr:\\n\\t\\tnextt = set()\\n\\t\\tfor node in curr:\\n\\t\\t\\tround_trip = level * 2\\n\\t\\t\\tif patience[node] > 0:\\n\\t\\t\\t\\tlast_msg = level * 2 - (level * 2 - 1) % patience[node]\\n\\t\\t\\telse:\\n\\t\\t\\t\\tlast_msg = 0\\n\\t\\t\\tans = max(ans, round_trip + last_msg)\\n\\n\\t\\t\\tfor x in edic[node]:\\n\\t\\t\\t\\tif x in seen:\\n\\t\\t\\t\\t\\tcontinue\\n\\t\\t\\t\\tseen[x] = 1\\n\\t\\t\\t\\tnextt.add(x)\\n\\t\\tcurr = nextt\\n\\t\\tlevel += 1\\n\\treturn ans\\n\\t```",
                "codeTag": "Python3"
            },
            {
                "id": 2175432,
                "title": "c-bfs-and-simple-math",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>>adjList;\\n    const int inf = INT_MAX ;\\n    vector<int>bfs(vector<vector<int>>&adjList , int source , int n){\\n        vector<int>dis(n , inf);\\n        dis[source] = 0 ;\\n        queue<int>q;\\n        q.push(source);\\n        while(!q.empty()){\\n            int curr = q.front();\\n            q.pop();\\n            for(auto it : adjList[curr]){\\n                if(dis[it] == inf){\\n                    dis[it] = dis[curr] + 1 ;\\n                    q.push(it);\\n                }\\n            }\\n        }\\n        \\n        for(int i = 0 ; i < n ; i++){\\n            dis[i] *= 2 ;\\n        }\\n        \\n        return dis ;\\n    }\\n    int networkBecomesIdle(vector<vector<int>>& edges, vector<int>& pat) {\\n        int n = pat.size();\\n        adjList.assign(n , {});\\n        \\n        for(auto it : edges){\\n            adjList[it[0]].push_back(it[1]);\\n            adjList[it[1]].push_back(it[0]);\\n        }\\n        vector<int>dis = bfs(adjList , 0 , n);\\n        int res = 0 ;\\n        for(int i = 1 ; i < n ; i++){\\n            res = max(res , dis[i]);\\n            if(pat[i] < dis[i]){\\n                int k = dis[i] - (dis[i]% pat[i]);\\n                if(k == dis[i]){\\n                    res = max(res , 2 * dis[i] - pat[i]);\\n                }\\n                else{\\n                    res = max(res ,k + dis[i]);\\n                }\\n            }\\n        }\\n        return res+1;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Math",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>>adjList;\\n    const int inf = INT_MAX ;\\n    vector<int>bfs(vector<vector<int>>&adjList , int source , int n){\\n        vector<int>dis(n , inf);\\n        dis[source] = 0 ;\\n        queue<int>q;\\n        q.push(source);\\n        while(!q.empty()){\\n            int curr = q.front();\\n            q.pop();\\n            for(auto it : adjList[curr]){\\n                if(dis[it] == inf){\\n                    dis[it] = dis[curr] + 1 ;\\n                    q.push(it);\\n                }\\n            }\\n        }\\n        \\n        for(int i = 0 ; i < n ; i++){\\n            dis[i] *= 2 ;\\n        }\\n        \\n        return dis ;\\n    }\\n    int networkBecomesIdle(vector<vector<int>>& edges, vector<int>& pat) {\\n        int n = pat.size();\\n        adjList.assign(n , {});\\n        \\n        for(auto it : edges){\\n            adjList[it[0]].push_back(it[1]);\\n            adjList[it[1]].push_back(it[0]);\\n        }\\n        vector<int>dis = bfs(adjList , 0 , n);\\n        int res = 0 ;\\n        for(int i = 1 ; i < n ; i++){\\n            res = max(res , dis[i]);\\n            if(pat[i] < dis[i]){\\n                int k = dis[i] - (dis[i]% pat[i]);\\n                if(k == dis[i]){\\n                    res = max(res , 2 * dis[i] - pat[i]);\\n                }\\n                else{\\n                    res = max(res ,k + dis[i]);\\n                }\\n            }\\n        }\\n        return res+1;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2154589,
                "title": "java-simple-bfs",
                "content": "```\\nclass Solution {\\n    public int networkBecomesIdle(int[][] edges, int[] patience) {\\n        ArrayList<ArrayList<Integer>> graph = new ArrayList<>();\\n        for(int i=0;i<=patience.length;i++){\\n            graph.add(new ArrayList<>());\\n        }\\n        \\n        for(int i=0;i<edges.length;i++){\\n            int src = edges[i][0];\\n            int dest = edges[i][1];\\n            graph.get(src).add(dest);\\n            graph.get(dest).add(src);\\n        }       \\n        int[] distance = new int[patience.length];\\n        distance[0] = 0;\\n        boolean[] visited = new boolean[patience.length];\\n        int count = 0;\\n        Queue<Integer> q = new LinkedList<>();\\n        visited[0] = true;\\n        q.add(0);\\n        while(!q.isEmpty()){\\n            int size = q.size();\\n            count++;\\n            for(int i=0;i<size;i++){\\n                int front = q.remove();  \\n            for(int j=0;j<graph.get(front).size();j++){\\n                int dest = graph.get(front).get(j);\\n               if(visited[dest] == false){\\n                    q.add(dest);\\n                distance[dest] = count;\\n                   visited[dest] = true;\\n               }\\n            }\\n            }\\n        }\\n        for(int i=0;i<distance.length;i++){\\n            System.out.print(distance[i]+\" \");\\n        }\\n        \\n        int max=0;\\n        for(int i=1;i<distance.length;i++){\\n            if(2* distance[i] <= patience[i]){\\n                max= Math.max(2*distance[i],max);\\n            }\\n            else{\\n//\\n                int numOfPac =  ((2*distance[i]-1)/patience[i]) ;\\n                int totTime = 2*distance[i] + numOfPac * patience[i];\\n                max = Math.max(totTime,max);\\n            }\\n        }\\n        return max+1;\\n    }\\n\\n}\\n\\n```",
                "solutionTags": [
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution {\\n    public int networkBecomesIdle(int[][] edges, int[] patience) {\\n        ArrayList<ArrayList<Integer>> graph = new ArrayList<>();\\n        for(int i=0;i<=patience.length;i++){\\n            graph.add(new ArrayList<>());\\n        }\\n        \\n        for(int i=0;i<edges.length;i++){\\n            int src = edges[i][0];\\n            int dest = edges[i][1];\\n            graph.get(src).add(dest);\\n            graph.get(dest).add(src);\\n        }       \\n        int[] distance = new int[patience.length];\\n        distance[0] = 0;\\n        boolean[] visited = new boolean[patience.length];\\n        int count = 0;\\n        Queue<Integer> q = new LinkedList<>();\\n        visited[0] = true;\\n        q.add(0);\\n        while(!q.isEmpty()){\\n            int size = q.size();\\n            count++;\\n            for(int i=0;i<size;i++){\\n                int front = q.remove();  \\n            for(int j=0;j<graph.get(front).size();j++){\\n                int dest = graph.get(front).get(j);\\n               if(visited[dest] == false){\\n                    q.add(dest);\\n                distance[dest] = count;\\n                   visited[dest] = true;\\n               }\\n            }\\n            }\\n        }\\n        for(int i=0;i<distance.length;i++){\\n            System.out.print(distance[i]+\" \");\\n        }\\n        \\n        int max=0;\\n        for(int i=1;i<distance.length;i++){\\n            if(2* distance[i] <= patience[i]){\\n                max= Math.max(2*distance[i],max);\\n            }\\n            else{\\n//\\n                int numOfPac =  ((2*distance[i]-1)/patience[i]) ;\\n                int totTime = 2*distance[i] + numOfPac * patience[i];\\n                max = Math.max(totTime,max);\\n            }\\n        }\\n        return max+1;\\n    }\\n\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2116288,
                "title": "golang-solution-faster-than-92",
                "content": "```\\nconst oo int = 0x3f3f3f3f\\nfunc networkBecomesIdle(edges [][]int, patience []int) int {\\n\\tn := len(patience)\\n\\tg := make([][]int, n)\\n\\tfor _, e := range edges {\\n\\t\\tg[e[0]] = append(g[e[0]], e[1])\\n\\t\\tg[e[1]] = append(g[e[1]], e[0])\\n\\t}\\n\\n\\tdist := make([]int, n)\\n\\tfor i := 0; i < n; i++ {\\n\\t\\tdist[i] = oo\\n\\t}\\n\\n\\tdist[0] = 0\\n\\tq := make([]int, 0)\\n\\tq = append(q, 0)\\n\\n\\tfor len(q) > 0 {\\n\\t\\tx := q[0]\\n\\t\\tq = q[1:]\\n\\n\\t\\tfor _, y := range g[x] {\\n\\t\\t\\tif dist[y] > dist[x]+1 {\\n\\t\\t\\t\\tdist[y] = dist[x] + 1\\n\\t\\t\\t\\tq = append(q, y)\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\n\\tres := 0\\n\\tfor i := 1; i < n; i++ {\\n\\t\\td := 2 * dist[i]\\n\\t\\tif d > patience[i] {\\n\\t\\t\\tm := d / patience[i]\\n\\t\\t\\tif d%patience[i] == 0 {\\n\\t\\t\\t\\tm--\\n\\t\\t\\t}\\n\\n\\t\\t\\tt := m*patience[i] + d + 1\\n\\t\\t\\tif t > res {\\n\\t\\t\\t\\tres = t\\n\\t\\t\\t}\\n\\t\\t} else {\\n\\t\\t\\tt := d + 1\\n\\t\\t\\tif t > res {\\n\\t\\t\\t\\tres = t\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\n\\treturn res\\n}\\n```\\n",
                "solutionTags": [],
                "code": "```\\nconst oo int = 0x3f3f3f3f\\nfunc networkBecomesIdle(edges [][]int, patience []int) int {\\n\\tn := len(patience)\\n\\tg := make([][]int, n)\\n\\tfor _, e := range edges {\\n\\t\\tg[e[0]] = append(g[e[0]], e[1])\\n\\t\\tg[e[1]] = append(g[e[1]], e[0])\\n\\t}\\n\\n\\tdist := make([]int, n)\\n\\tfor i := 0; i < n; i++ {\\n\\t\\tdist[i] = oo\\n\\t}\\n\\n\\tdist[0] = 0\\n\\tq := make([]int, 0)\\n\\tq = append(q, 0)\\n\\n\\tfor len(q) > 0 {\\n\\t\\tx := q[0]\\n\\t\\tq = q[1:]\\n\\n\\t\\tfor _, y := range g[x] {\\n\\t\\t\\tif dist[y] > dist[x]+1 {\\n\\t\\t\\t\\tdist[y] = dist[x] + 1\\n\\t\\t\\t\\tq = append(q, y)\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\n\\tres := 0\\n\\tfor i := 1; i < n; i++ {\\n\\t\\td := 2 * dist[i]\\n\\t\\tif d > patience[i] {\\n\\t\\t\\tm := d / patience[i]\\n\\t\\t\\tif d%patience[i] == 0 {\\n\\t\\t\\t\\tm--\\n\\t\\t\\t}\\n\\n\\t\\t\\tt := m*patience[i] + d + 1\\n\\t\\t\\tif t > res {\\n\\t\\t\\t\\tres = t\\n\\t\\t\\t}\\n\\t\\t} else {\\n\\t\\t\\tt := d + 1\\n\\t\\t\\tif t > res {\\n\\t\\t\\t\\tres = t\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\n\\treturn res\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2099087,
                "title": "java-soln-using-bfs",
                "content": "```\\nclass Solution {\\n    public int networkBecomesIdle(int[][] edges, int[] p) {\\n        \\n            ArrayList<Integer>[] graph=new ArrayList[p.length];\\n        \\n            for(int i=0;i<p.length;i++)\\n            {\\n                graph[i]=new ArrayList<Integer>();\\n                \\n            }\\n        \\n            for(int i=0;i<edges.length;i++)\\n            {\\n                int v=edges[i][0];\\n                int nbr=edges[i][1];\\n                \\n                graph[v].add(nbr);\\n                graph[nbr].add(v);\\n            }\\n            Integer[] level=new Integer[p.length];\\n            Queue<Integer> q=new ArrayDeque<>();\\n            q.add(0);\\n            level[0]=0;\\n            int l=0;\\n            while(!q.isEmpty())\\n            {\\n                int size=q.size();\\n                l++;\\n                for(int i=0;i<size;i++)\\n                {\\n                    int rem=q.remove();\\n                    for(Integer e:graph[rem])\\n                    {\\n                        if(level[e]==null)\\n                        {\\n                            q.add(e);\\n                            level[e]=l;\\n                        }\\n                    }\\n                    \\n                \\n                    \\n                }\\n                \\n                \\n            }\\n            int max=0;\\n            for(int i=0;i<p.length;i++)\\n            {\\n                if(p[i]>=2*level[i])\\n                {\\n                    max=Math.max(max,2*level[i]);\\n                }\\n                else \\n                {\\n                    max=Math.max(((2*level[i]-1)/p[i])*p[i]+2*level[i],max);\\n                    \\n                }\\n            }\\n            return max+1;\\n        \\n        \\n        \\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int networkBecomesIdle(int[][] edges, int[] p) {\\n        \\n            ArrayList<Integer>[] graph=new ArrayList[p.length];\\n        \\n            for(int i=0;i<p.length;i++)\\n            {\\n                graph[i]=new ArrayList<Integer>();\\n                \\n            }\\n        \\n            for(int i=0;i<edges.length;i++)\\n            {\\n                int v=edges[i][0];\\n                int nbr=edges[i][1];\\n                \\n                graph[v].add(nbr);\\n                graph[nbr].add(v);\\n            }\\n            Integer[] level=new Integer[p.length];\\n            Queue<Integer> q=new ArrayDeque<>();\\n            q.add(0);\\n            level[0]=0;\\n            int l=0;\\n            while(!q.isEmpty())\\n            {\\n                int size=q.size();\\n                l++;\\n                for(int i=0;i<size;i++)\\n                {\\n                    int rem=q.remove();\\n                    for(Integer e:graph[rem])\\n                    {\\n                        if(level[e]==null)\\n                        {\\n                            q.add(e);\\n                            level[e]=l;\\n                        }\\n                    }\\n                    \\n                \\n                    \\n                }\\n                \\n                \\n            }\\n            int max=0;\\n            for(int i=0;i<p.length;i++)\\n            {\\n                if(p[i]>=2*level[i])\\n                {\\n                    max=Math.max(max,2*level[i]);\\n                }\\n                else \\n                {\\n                    max=Math.max(((2*level[i]-1)/p[i])*p[i]+2*level[i],max);\\n                    \\n                }\\n            }\\n            return max+1;\\n        \\n        \\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2070319,
                "title": "spfa",
                "content": "```\\nclass Solution:\\n    def networkBecomesIdle(self, edges: List[List[int]], patience: List[int]) -> int:\\n        \\n        graph = collections.defaultdict(list)\\n        for i,j in edges:\\n            graph[i].append(j)\\n            graph[j].append(i)\\n\\n        distances = [float(\\'inf\\')]*len(graph)\\n        distances[0] = 0\\n        queue = []\\n        queue.append(0)\\n        while queue:\\n            u  = queue.pop(0)\\n            for v in graph[u]:\\n                if distances[u] + 1 < distances[v]:\\n                    distances[v] = distances[u] +1\\n                    queue.append(v)\\n        distances = [2*i for i in distances]\\n        ans = 0\\n        for d, p in zip(distances, patience): \\n            if p: \\n                k = d//p - int(d%p == 0)\\n                ans = max(ans, d + k*p)\\n        return ans + 1\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def networkBecomesIdle(self, edges: List[List[int]], patience: List[int]) -> int:\\n        \\n        graph = collections.defaultdict(list)\\n        for i,j in edges:\\n            graph[i].append(j)\\n            graph[j].append(i)\\n\\n        distances = [float(\\'inf\\')]*len(graph)\\n        distances[0] = 0\\n        queue = []\\n        queue.append(0)\\n        while queue:\\n            u  = queue.pop(0)\\n            for v in graph[u]:\\n                if distances[u] + 1 < distances[v]:\\n                    distances[v] = distances[u] +1\\n                    queue.append(v)\\n        distances = [2*i for i in distances]\\n        ans = 0\\n        for d, p in zip(distances, patience): \\n            if p: \\n                k = d//p - int(d%p == 0)\\n                ans = max(ans, d + k*p)\\n        return ans + 1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2058650,
                "title": "python-count-each-node-s-last-signal-travel-ends",
                "content": "idea:\\n(1) compute for each node, the round trip time, and therefore decide the last signal sending time;\\n(2) the round time is 2*distance from node 0 to the node. BFS will do the job;\\n(3) round_trip_time+last_signal_start_time;\\n(4) [(roundtrip_time-1)//patience] how many signals sent for a node;\\n\\n\\n```\\ndef networkBecomesIdle(self, edges: List[List[int]], patience: List[int]) -> int:\\n        n=len(patience)\\n        g=defaultdict(list)\\n        for st,ed in edges:\\n            g[st].append(ed)\\n            g[ed].append(st)\\n        ## time to nd 0\\n        dist20=[float(\\'inf\\')]*n\\n        step=0\\n        q=deque([(0,0)]) ##(node_id,step)\\n        visited=set([0])\\n        while q:\\n            cur,step=q.popleft()\\n            dist20[cur]=step\\n            for nei in g[cur]:\\n                if nei not in visited:\\n                    q.append((nei,step+1))\\n                    visited.add(nei)\\n        res=0\\n        for i in range(1,n):\\n            roundtrip=dist20[i]*2\\n            last_st=patience[i]*((roundtrip-1)//patience[i])\\n            tot=last_st+roundtrip\\n            res=max(res,tot)\\n        return res+1",
                "solutionTags": [],
                "code": "idea:\\n(1) compute for each node, the round trip time, and therefore decide the last signal sending time;\\n(2) the round time is 2*distance from node 0 to the node. BFS will do the job;\\n(3) round_trip_time+last_signal_start_time;\\n(4) [(roundtrip_time-1)//patience] how many signals sent for a node;\\n\\n\\n```\\ndef networkBecomesIdle(self, edges: List[List[int]], patience: List[int]) -> int:\\n        n=len(patience)\\n        g=defaultdict(list)\\n        for st,ed in edges:\\n            g[st].append(ed)\\n            g[ed].append(st)\\n        ## time to nd 0\\n        dist20=[float(\\'inf\\')]*n\\n        step=0\\n        q=deque([(0,0)]) ##(node_id,step)\\n        visited=set([0])\\n        while q:\\n            cur,step=q.popleft()\\n            dist20[cur]=step\\n            for nei in g[cur]:\\n                if nei not in visited:\\n                    q.append((nei,step+1))\\n                    visited.add(nei)\\n        res=0\\n        for i in range(1,n):\\n            roundtrip=dist20[i]*2\\n            last_st=patience[i]*((roundtrip-1)//patience[i])\\n            tot=last_st+roundtrip\\n            res=max(res,tot)\\n        return res+1",
                "codeTag": "Python3"
            },
            {
                "id": 2048803,
                "title": "bfs-solution-with-explanation",
                "content": "**Algorithm:**\\n\\t 1. find total distance travel by packet from every dataNode to server node.\\n        Total distance Time = (node -> server) + (server ->node )\\n                        = 2* shortest distance from server {BSF SEARCH}\\n\\t2. for every node there will be 2 cases-\\n  ** {case-1}** i) if patience[node] > distTime[node]\\n            then ans will be just distTime for this node\\n        ii) otherwise we have to calculate redundant time which is-\\n             ans=distTime + redundant Time\\n\\t\\t\\t \\n**To calculate Extra Time-**\\n  ** {case-2} \\n\\t\\ti) find number of packet send before arrival of 1st acknowledgement from server\\n         number of Packet= (dist[node]-1)/patience[node]\\n        ii) total time to get acknowledgement of last pacet\\n            extra Time= num_of_packet*patience[node]\\n```\\n    int networkBecomesIdle(vector<vector<int>>& edge, vector<int>& P) {\\n        int n=P.size();\\n        vector<vector<int>>adj(n);\\n        // create adjacency list\\n        vector<int>dist(n,INT_MAX);\\n        for(auto x:edge){\\n            adj[x[0]].push_back(x[1]);\\n            adj[x[1]].push_back(x[0]);\\n        }\\n        queue<int>q;\\n        dist[0]=0;\\n        q.push(0);\\n        int len=0;\\n        // calculate distance Time = {2* distance from master server} \\n        while(!q.empty()){\\n            int m=q.size();\\n            //cout<<m<<endl;\\n            while(m--){\\n                int src=q.front();\\n                q.pop();\\n                dist[src]=min(len*2,dist[src]);\\n                for(auto x:adj[src]){\\n                    if(dist[x]==INT_MAX)\\n                        q.push(x);\\n                }\\n            }\\n            len++;\\n        }\\n        // calculate total time to receive last packet\\n        int ans=0;\\n        for(int i=0;i<n;i++){\\n            ans=max(dist[i],ans);\\n            if(P[i]< dist[i]){ // case-2\\n                int temp=(dist[i]-1)/P[i];\\n                //cout<<temp*P[i]<<endl;\\n                ans=max(ans,(temp*P[i]) + dist[i]);\\n            }\\n        }\\n        // channel will be free after 1 sec \\n        return ans+1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Breadth-First Search"
                ],
                "code": "```\\n    int networkBecomesIdle(vector<vector<int>>& edge, vector<int>& P) {\\n        int n=P.size();\\n        vector<vector<int>>adj(n);\\n        // create adjacency list\\n        vector<int>dist(n,INT_MAX);\\n        for(auto x:edge){\\n            adj[x[0]].push_back(x[1]);\\n            adj[x[1]].push_back(x[0]);\\n        }\\n        queue<int>q;\\n        dist[0]=0;\\n        q.push(0);\\n        int len=0;\\n        // calculate distance Time = {2* distance from master server} \\n        while(!q.empty()){\\n            int m=q.size();\\n            //cout<<m<<endl;\\n            while(m--){\\n                int src=q.front();\\n                q.pop();\\n                dist[src]=min(len*2,dist[src]);\\n                for(auto x:adj[src]){\\n                    if(dist[x]==INT_MAX)\\n                        q.push(x);\\n                }\\n            }\\n            len++;\\n        }\\n        // calculate total time to receive last packet\\n        int ans=0;\\n        for(int i=0;i<n;i++){\\n            ans=max(dist[i],ans);\\n            if(P[i]< dist[i]){ // case-2\\n                int temp=(dist[i]-1)/P[i];\\n                //cout<<temp*P[i]<<endl;\\n                ans=max(ans,(temp*P[i]) + dist[i]);\\n            }\\n        }\\n        // channel will be free after 1 sec \\n        return ans+1;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2036903,
                "title": "c-bfs",
                "content": "```\\nclass Solution {\\npublic:\\n    int networkBecomesIdle(vector<vector<int>>& edges, vector<int>& patience) {\\n        unordered_map<int, vector<int>> g;\\n        for (auto& e : edges) {\\n            g[e[0]].push_back(e[1]);\\n            g[e[1]].push_back(e[0]);\\n        }\\n        \\n        vector<int> visited(patience.size());\\n        \\n        queue<int> q;\\n        q.push(0);\\n        \\n        int ans = 0, sec = 0;\\n        \\n        while(!q.empty()) {\\n            int cnt = q.size();\\n            \\n            while (cnt-- > 0) {\\n                auto node = q.front();\\n                q.pop();\\n                \\n                int p = patience[node];\\n                int t = 2 * sec;\\n                \\n                if (p > 0) {\\n                    if (p >= t) {\\n                        ans = max(ans, t);\\n                    } else {\\n                        int resend = (t - 1) / p;\\n                        int delay = p * resend;\\n                        ans = max(ans, t + delay);\\n                    }\\n                }\\n                \\n                for (auto& next : g[node]) {\\n                    if (visited[next]) {\\n                        continue;\\n                    }\\n                    \\n                    q.push(next);\\n                    visited[next] = true;\\n                }\\n            }            \\n            ++sec;\\n        }\\n        \\n        return ans + 1;\\n    }\\n};\\n```\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int networkBecomesIdle(vector<vector<int>>& edges, vector<int>& patience) {\\n        unordered_map<int, vector<int>> g;\\n        for (auto& e : edges) {\\n            g[e[0]].push_back(e[1]);\\n            g[e[1]].push_back(e[0]);\\n        }\\n        \\n        vector<int> visited(patience.size());\\n        \\n        queue<int> q;\\n        q.push(0);\\n        \\n        int ans = 0, sec = 0;\\n        \\n        while(!q.empty()) {\\n            int cnt = q.size();\\n            \\n            while (cnt-- > 0) {\\n                auto node = q.front();\\n                q.pop();\\n                \\n                int p = patience[node];\\n                int t = 2 * sec;\\n                \\n                if (p > 0) {\\n                    if (p >= t) {\\n                        ans = max(ans, t);\\n                    } else {\\n                        int resend = (t - 1) / p;\\n                        int delay = p * resend;\\n                        ans = max(ans, t + delay);\\n                    }\\n                }\\n                \\n                for (auto& next : g[node]) {\\n                    if (visited[next]) {\\n                        continue;\\n                    }\\n                    \\n                    q.push(next);\\n                    visited[next] = true;\\n                }\\n            }            \\n            ++sec;\\n        }\\n        \\n        return ans + 1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2015453,
                "title": "java-find-the-shortest-distance-for-each-server-and-then-calculate-time-for-each-server",
                "content": "```\\nclass Solution {\\n    public int networkBecomesIdle(int[][] edges, int[] patience) {\\n        // Requests are processed at the same time\\n        \\n        // Create Graph\\n        HashMap<Integer, List<Integer>> map = new HashMap<>();\\n        for(int[] e : edges){\\n            map.computeIfAbsent(e[0], k -> new ArrayList<>()).add(e[1]);\\n            map.computeIfAbsent(e[1], k -> new ArrayList<>()).add(e[0]);\\n        }\\n        \\n        // Find the shortest distance of each node from the master node\\n        int[] dis = new int[patience.length];\\n        Arrays.fill(dis, -1);\\n        dis[0] = 0;\\n        Queue<Integer> queue = new LinkedList<>();\\n        queue.offer(0);\\n        \\n        while(!queue.isEmpty()){\\n            int node = queue.poll();\\n            \\n            if(!map.containsKey(node)) continue;\\n            \\n            for(int neigh : map.get(node)){\\n               if(dis[neigh] == -1){\\n                   dis[neigh] = dis[node] + 1;\\n                   queue.offer(neigh);\\n               }\\n            }\\n        }\\n        \\n        // Find the the time when the network becomes idle\\n        int ans = 0;\\n        for(int i=1; i<dis.length; i++){\\n            int lastRequest = (2*dis[i] - 1)/patience[i];\\n            \\n            int timeOfLastRequest = patience[i]*lastRequest;\\n            int timeTakenByLastRequest = 2*dis[i];\\n            \\n            int totalTime = timeOfLastRequest + timeTakenByLastRequest;\\n            ans = Math.max(ans, totalTime);\\n        }\\n        \\n        return ans + 1;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int networkBecomesIdle(int[][] edges, int[] patience) {\\n        // Requests are processed at the same time\\n        \\n        // Create Graph\\n        HashMap<Integer, List<Integer>> map = new HashMap<>();\\n        for(int[] e : edges){\\n            map.computeIfAbsent(e[0], k -> new ArrayList<>()).add(e[1]);\\n            map.computeIfAbsent(e[1], k -> new ArrayList<>()).add(e[0]);\\n        }\\n        \\n        // Find the shortest distance of each node from the master node\\n        int[] dis = new int[patience.length];\\n        Arrays.fill(dis, -1);\\n        dis[0] = 0;\\n        Queue<Integer> queue = new LinkedList<>();\\n        queue.offer(0);\\n        \\n        while(!queue.isEmpty()){\\n            int node = queue.poll();\\n            \\n            if(!map.containsKey(node)) continue;\\n            \\n            for(int neigh : map.get(node)){\\n               if(dis[neigh] == -1){\\n                   dis[neigh] = dis[node] + 1;\\n                   queue.offer(neigh);\\n               }\\n            }\\n        }\\n        \\n        // Find the the time when the network becomes idle\\n        int ans = 0;\\n        for(int i=1; i<dis.length; i++){\\n            int lastRequest = (2*dis[i] - 1)/patience[i];\\n            \\n            int timeOfLastRequest = patience[i]*lastRequest;\\n            int timeTakenByLastRequest = 2*dis[i];\\n            \\n            int totalTime = timeOfLastRequest + timeTakenByLastRequest;\\n            ans = Math.max(ans, totalTime);\\n        }\\n        \\n        return ans + 1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1961980,
                "title": "javascript-iterative-bfs-o-n-time-o-n-space",
                "content": "```\\nvar networkBecomesIdle = function(edges, patience) {\\n    let graph = {};\\n    for (let [edge, neighbor] of edges) {\\n        if (!(edge in graph)) graph[edge] = [];\\n        graph[edge].push(neighbor);\\n        if (!(neighbor in graph)) graph[neighbor] = [];\\n        graph[neighbor].push(edge);\\n    }\\n\\n    // Initialize queue with server 0\\n    let q = [0];\\n\\tlet seconds = 0, complete = {};\\n    while (q.length) {\\n        let newQ = [];\\n        while (q.length) {\\n            let current = q.pop();\\n            if (current in complete) continue;\\n            complete[current] = seconds * 2;\\n            for (let edge of graph[current]) {\\n                if (complete[edge]) continue;\\n                newQ.push(edge);\\n            }\\n        }\\n        q = newQ;\\n        seconds++;\\n    }\\n    \\n    // Total servers\\n    let servers = Object.keys(graph).length;\\n    \\n    let maxSeconds = 0;\\n    for (let i = 1; i < servers; i++) {\\n        let timeToComplete = complete[i];\\n        let resendInterval = patience[i];\\n        \\n        // If timeToComplete == 4 and resendInterval == 2, the msg will be resent 1 time at second 2 and not second 4\\n        // If timeToComplete == 5 and resendInterval == 2, the msg will be resent 2 times at second 2 and second 4\\n        // Hence we use Math.ceil(...) - 1\\n        let resendCount = Math.ceil(timeToComplete / resendInterval) - 1;\\n        \\n        let seconds = timeToComplete + (resendInterval * resendCount);\\n        maxSeconds = Math.max(maxSeconds, seconds);\\n    }\\n    return maxSeconds + 1;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar networkBecomesIdle = function(edges, patience) {\\n    let graph = {};\\n    for (let [edge, neighbor] of edges) {\\n        if (!(edge in graph)) graph[edge] = [];\\n        graph[edge].push(neighbor);\\n        if (!(neighbor in graph)) graph[neighbor] = [];\\n        graph[neighbor].push(edge);\\n    }\\n\\n    // Initialize queue with server 0\\n    let q = [0];\\n\\tlet seconds = 0, complete = {};\\n    while (q.length) {\\n        let newQ = [];\\n        while (q.length) {\\n            let current = q.pop();\\n            if (current in complete) continue;\\n            complete[current] = seconds * 2;\\n            for (let edge of graph[current]) {\\n                if (complete[edge]) continue;\\n                newQ.push(edge);\\n            }\\n        }\\n        q = newQ;\\n        seconds++;\\n    }\\n    \\n    // Total servers\\n    let servers = Object.keys(graph).length;\\n    \\n    let maxSeconds = 0;\\n    for (let i = 1; i < servers; i++) {\\n        let timeToComplete = complete[i];\\n        let resendInterval = patience[i];\\n        \\n        // If timeToComplete == 4 and resendInterval == 2, the msg will be resent 1 time at second 2 and not second 4\\n        // If timeToComplete == 5 and resendInterval == 2, the msg will be resent 2 times at second 2 and second 4\\n        // Hence we use Math.ceil(...) - 1\\n        let resendCount = Math.ceil(timeToComplete / resendInterval) - 1;\\n        \\n        let seconds = timeToComplete + (resendInterval * resendCount);\\n        maxSeconds = Math.max(maxSeconds, seconds);\\n    }\\n    return maxSeconds + 1;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1934199,
                "title": "c-simple-solution",
                "content": "```\\npublic class Solution \\n{\\n    private int n;\\n    \\n    public int NetworkBecomesIdle(int[][] edges, int[] patience) \\n    {\\n        n = patience.Length;\\n        var adjList = GetAdjacencyList(edges,n);\\n        int[] shortestTimes = GetShortestTimeToMaster(adjList);\\n        int[] timeTaken = GetTotalTimeTakenByAllMessagesOfDataServerToReachMaster(shortestTimes,patience);\\n        return 1+timeTaken.Max();\\n    }\\n    \\n    private int[] GetTotalTimeTakenByAllMessagesOfDataServerToReachMaster(int[] shortestTimes, int[] patience)\\n    {\\n        int[] timeTaken = new int[n];\\n        \\n        for(int i=1; i<n; i++)\\n        {\\n            if(patience[i] >= 2*shortestTimes[i])\\n                timeTaken[i] = 2*shortestTimes[i];\\n            else\\n            {\\n                int messagesGenerated = Convert.ToInt32(Math.Ceiling(2.0*shortestTimes[i] / patience[i]));\\n                timeTaken[i] = 2*shortestTimes[i] + (messagesGenerated - 1) * patience[i];\\n            }\\n        }\\n        \\n        return timeTaken;\\n    }\\n    \\n    private int[] GetShortestTimeToMaster(List<List<int>> adjList)\\n    {\\n        return PerformDijkstraAndGetShortestTime(adjList);\\n    }\\n    \\n    private int[] PerformDijkstraAndGetShortestTime(List<List<int>> adjList)\\n    {\\n        int path = 0;\\n        \\n        int[] shortestTimes = new int[n];\\n        for(int i=0;i<n;i++)\\n        {\\n            shortestTimes[i] = int.MaxValue-1;\\n        }\\n        shortestTimes[0] = 0;\\n        \\n        PriorityQueue<int,int> qu = new();\\n        qu.Enqueue(0,0);\\n        \\n        while(qu.Count>0)\\n        {\\n            var cur = qu.Dequeue();\\n            \\n            foreach(var nd in adjList[cur])\\n            {\\n                if(shortestTimes[nd] > 1 + shortestTimes[cur])\\n                {\\n                    shortestTimes[nd] = 1 + shortestTimes[cur];\\n                    qu.Enqueue(nd,shortestTimes[nd]);\\n                }\\n            }\\n        }\\n        \\n        return shortestTimes;\\n    }\\n    \\n    private List<List<int>> GetAdjacencyList(int[][] edges, int n)\\n    {\\n        List<List<int>> adjList = new();\\n        \\n        for(int i=0; i<n; i++)\\n        {\\n            adjList.Add(new());\\n        }\\n        \\n        foreach(var ed in edges)\\n        {\\n            adjList[ed[0]].Add(ed[1]);\\n            adjList[ed[1]].Add(ed[0]);\\n        }\\n        \\n        return adjList;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution \\n{\\n    private int n;\\n    \\n    public int NetworkBecomesIdle(int[][] edges, int[] patience) \\n    {\\n        n = patience.Length;\\n        var adjList = GetAdjacencyList(edges,n);\\n        int[] shortestTimes = GetShortestTimeToMaster(adjList);\\n        int[] timeTaken = GetTotalTimeTakenByAllMessagesOfDataServerToReachMaster(shortestTimes,patience);\\n        return 1+timeTaken.Max();\\n    }\\n    \\n    private int[] GetTotalTimeTakenByAllMessagesOfDataServerToReachMaster(int[] shortestTimes, int[] patience)\\n    {\\n        int[] timeTaken = new int[n];\\n        \\n        for(int i=1; i<n; i++)\\n        {\\n            if(patience[i] >= 2*shortestTimes[i])\\n                timeTaken[i] = 2*shortestTimes[i];\\n            else\\n            {\\n                int messagesGenerated = Convert.ToInt32(Math.Ceiling(2.0*shortestTimes[i] / patience[i]));\\n                timeTaken[i] = 2*shortestTimes[i] + (messagesGenerated - 1) * patience[i];\\n            }\\n        }\\n        \\n        return timeTaken;\\n    }\\n    \\n    private int[] GetShortestTimeToMaster(List<List<int>> adjList)\\n    {\\n        return PerformDijkstraAndGetShortestTime(adjList);\\n    }\\n    \\n    private int[] PerformDijkstraAndGetShortestTime(List<List<int>> adjList)\\n    {\\n        int path = 0;\\n        \\n        int[] shortestTimes = new int[n];\\n        for(int i=0;i<n;i++)\\n        {\\n            shortestTimes[i] = int.MaxValue-1;\\n        }\\n        shortestTimes[0] = 0;\\n        \\n        PriorityQueue<int,int> qu = new();\\n        qu.Enqueue(0,0);\\n        \\n        while(qu.Count>0)\\n        {\\n            var cur = qu.Dequeue();\\n            \\n            foreach(var nd in adjList[cur])\\n            {\\n                if(shortestTimes[nd] > 1 + shortestTimes[cur])\\n                {\\n                    shortestTimes[nd] = 1 + shortestTimes[cur];\\n                    qu.Enqueue(nd,shortestTimes[nd]);\\n                }\\n            }\\n        }\\n        \\n        return shortestTimes;\\n    }\\n    \\n    private List<List<int>> GetAdjacencyList(int[][] edges, int n)\\n    {\\n        List<List<int>> adjList = new();\\n        \\n        for(int i=0; i<n; i++)\\n        {\\n            adjList.Add(new());\\n        }\\n        \\n        foreach(var ed in edges)\\n        {\\n            adjList[ed[0]].Add(ed[1]);\\n            adjList[ed[1]].Add(ed[0]);\\n        }\\n        \\n        return adjList;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1920835,
                "title": "cpp-priority-queue-dijkstras",
                "content": "```\\n/*\\n    use dikstras algo and find min distance to rach \\n    now for each distance \\n       calulate  time= 2*distance +(number of resends)*(gap between two mesaages)\\n                     = 2*distance +(2*dist -1)*(patience);\\n    */\\n    int networkBecomesIdle(vector<vector<int>>& edges, vector<int>& patience) {\\n        int n=patience.size();\\n        vector<int>adj[n];\\n        for(auto edge:edges){\\n            adj[edge[0]].push_back(edge[1]);\\n            adj[edge[1]].push_back(edge[0]);\\n        }\\n        vector<int>dist(n,INT_MAX);\\n        vector<bool>processed(n,false);\\n        priority_queue<pair<int,int>,vector<pair<int,int>>,greater<pair<int,int>>>pq;\\n        pq.push({0,0});\\n        dist[0]=0;\\n        while(!pq.empty()){\\n            auto it=pq.top();\\n            pq.pop();\\n            processed[it.second]=true;\\n            for(auto i:adj[it.second]){\\n                if(!processed[i]&&dist[i]>it.first+1)dist[i]=it.first+1,pq.push({it.first+1,i});\\n            }\\n        }\\n        int ans=0;\\n        for(int i=1;i<n;i++){\\n            cout<<dist[i]<<\" \";\\n            if(dist[i]==INT_MAX)continue;\\n            int val=(2*dist[i])+(patience[i]*(((2*dist[i])-1)/patience[i]));\\n            if(ans<val)ans=val;\\n        }\\n       // cout<<endl<<index<<endl;\\n        \\n        return ans+1;\\n    }",
                "solutionTags": [],
                "code": "```\\n/*\\n    use dikstras algo and find min distance to rach \\n    now for each distance \\n       calulate  time= 2*distance +(number of resends)*(gap between two mesaages)\\n                     = 2*distance +(2*dist -1)*(patience);\\n    */\\n    int networkBecomesIdle(vector<vector<int>>& edges, vector<int>& patience) {\\n        int n=patience.size();\\n        vector<int>adj[n];\\n        for(auto edge:edges){\\n            adj[edge[0]].push_back(edge[1]);\\n            adj[edge[1]].push_back(edge[0]);\\n        }\\n        vector<int>dist(n,INT_MAX);\\n        vector<bool>processed(n,false);\\n        priority_queue<pair<int,int>,vector<pair<int,int>>,greater<pair<int,int>>>pq;\\n        pq.push({0,0});\\n        dist[0]=0;\\n        while(!pq.empty()){\\n            auto it=pq.top();\\n            pq.pop();\\n            processed[it.second]=true;\\n            for(auto i:adj[it.second]){\\n                if(!processed[i]&&dist[i]>it.first+1)dist[i]=it.first+1,pq.push({it.first+1,i});\\n            }\\n        }\\n        int ans=0;\\n        for(int i=1;i<n;i++){\\n            cout<<dist[i]<<\" \";\\n            if(dist[i]==INT_MAX)continue;\\n            int val=(2*dist[i])+(patience[i]*(((2*dist[i])-1)/patience[i]));\\n            if(ans<val)ans=val;\\n        }\\n       // cout<<endl<<index<<endl;\\n        \\n        return ans+1;\\n    }",
                "codeTag": "C++"
            },
            {
                "id": 1900611,
                "title": "java-easy-solution",
                "content": "```\\nclass Solution {\\n    public int networkBecomesIdle(int[][] edges, int[] pat) {\\n        int n = pat.length;\\n        ArrayList<ArrayList<Integer>> adj =  new ArrayList<>();\\n        for(int i = 0; i < n ; i++){\\n            adj.add(new ArrayList<>());\\n        }\\n        \\n        for(int[] arr : edges){\\n            adj.get(arr[0]).add(arr[1]);\\n            adj.get(arr[1]).add(arr[0]);\\n        }\\n        \\n        int[] distance = new int[n];\\n        Arrays.fill(distance , 99999);\\n        distance[0] = 0;\\n        PriorityQueue<int[]> pq = new PriorityQueue<>(new Comparator<int[]>(){\\n            @Override\\n            public int compare(int[] a1 , int[] a2){\\n                return Integer.compare(a1[1] , a2[1]);\\n            }\\n        });\\n        \\n        pq.add(new int[]{0 , 0});\\n        \\n        while(!pq.isEmpty()){\\n            int[] a = pq.poll();\\n            int node = a[0] , cost = a[1];\\n            \\n            for(Integer nn : adj.get(node)){\\n                if(distance[node] + 1 < distance[nn]){\\n                    distance[nn] = 1 + distance[node];\\n                    pq.add(new int[]{nn , distance[nn]});\\n                }\\n            }\\n        }\\n        \\n        int max = 0; \\n        \\n        for(int i = 1 ; i< n ; i++){\\n            int num1 = 2 * distance[i];\\n            int num2 = (num1 / pat[i]);\\n            if(num1 % pat[i] != 0) num2++;\\n            num2--;\\n            num2 *= pat[i];\\n            \\n            max = Math.max(max , num2 + num1);\\n        }\\n        \\n        return max+1;\\n        \\n        \\n    }\\n}",
                "solutionTags": [
                    "Java",
                    "Breadth-First Search"
                ],
                "code": "class Solution {\\n    public int networkBecomesIdle(int[][] edges, int[] pat) {\\n        int n = pat.length;\\n        ArrayList<ArrayList<Integer>> adj =  new ArrayList<>();\\n        for(int i = 0; i < n ; i++){\\n            adj.add(new ArrayList<>());\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1890330,
                "title": "c-bfs-solution",
                "content": "- use BFS to find the shortest time to reach a node (one-direction message time cost)\\n- denote the time to reach a node as `t`, then the total time of a node to send & receive a message is equal to: \\n\\t- 1) if `2 * t > patience[node]`, then the max time will be `2 * t + lastOut`, `lastOut = ((2 *t - 1) / patience[node]) * patience[node]`;\\n\\t- 2) if `2 * t <= patience[node]`, then `2 * t` will be the max time;\\n\\n- Just update the maxTime as we traverse through the nodes;\\n- NOTE: the idle time is 1 second plus the maxTime.\\n```\\nclass Solution {\\npublic:\\n    int networkBecomesIdle(vector<vector<int>>& edges, vector<int>& patience) {\\n        if (patience.empty()) return 0;\\n        // create connection records \\n        int n = patience.size();\\n        vector<vector<int>> connections(n);\\n        vector<bool> visited(n, false);\\n        \\n        for(auto edge: edges){\\n            connections[edge[0]].push_back(edge[1]);\\n            connections[edge[1]].push_back(edge[0]);\\n        }\\n        // and use BFS to find the shortest path \\n        queue<int> bfs;\\n        bfs.push(0);\\n        visited[0] = true;\\n        int t = 0;\\n        int minTime = 0;\\n        while(!bfs.empty()){\\n            int size = bfs.size();\\n            for (int i = 0; i < size; i++){\\n                int cur = bfs.front();\\n                bfs.pop();\\n                // the time of the node to be idle:\\n                // record time to reach this nodeL: t;\\n                // 1) if patience < 2 * t, totalTime = patience + 2 * (t);\\n                // 2) if patience > 2 * t, totalTime = 2 * (t);\\n                \\n                int cost = 2 * t;\\n                if (cost > patience[cur]){\\n                    int lastOut = ((cost - 1) / patience[cur]) * patience[cur];\\n                    cost = 2 * t + lastOut;\\n                }\\n                \\n                minTime = max(minTime, cost);\\n\\n                // add children nodes into bfs\\n                for (auto x : connections[cur]){\\n                   if (!visited[x]) {\\n                       bfs.push(x);\\n                       visited[x] = true;\\n                   }\\n                }\\n            }\\n            t += 1;\\n        }\\n        \\n        return minTime + 1;\\n        \\n        \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int networkBecomesIdle(vector<vector<int>>& edges, vector<int>& patience) {\\n        if (patience.empty()) return 0;\\n        // create connection records \\n        int n = patience.size();\\n        vector<vector<int>> connections(n);\\n        vector<bool> visited(n, false);\\n        \\n        for(auto edge: edges){\\n            connections[edge[0]].push_back(edge[1]);\\n            connections[edge[1]].push_back(edge[0]);\\n        }\\n        // and use BFS to find the shortest path \\n        queue<int> bfs;\\n        bfs.push(0);\\n        visited[0] = true;\\n        int t = 0;\\n        int minTime = 0;\\n        while(!bfs.empty()){\\n            int size = bfs.size();\\n            for (int i = 0; i < size; i++){\\n                int cur = bfs.front();\\n                bfs.pop();\\n                // the time of the node to be idle:\\n                // record time to reach this nodeL: t;\\n                // 1) if patience < 2 * t, totalTime = patience + 2 * (t);\\n                // 2) if patience > 2 * t, totalTime = 2 * (t);\\n                \\n                int cost = 2 * t;\\n                if (cost > patience[cur]){\\n                    int lastOut = ((cost - 1) / patience[cur]) * patience[cur];\\n                    cost = 2 * t + lastOut;\\n                }\\n                \\n                minTime = max(minTime, cost);\\n\\n                // add children nodes into bfs\\n                for (auto x : connections[cur]){\\n                   if (!visited[x]) {\\n                       bfs.push(x);\\n                       visited[x] = true;\\n                   }\\n                }\\n            }\\n            t += 1;\\n        }\\n        \\n        return minTime + 1;\\n        \\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1840256,
                "title": "c",
                "content": "```\\nclass Solution {\\npublic:\\n    int networkBecomesIdle(vector<vector<int>>& edges, vector<int>& patience) {\\n        int n = patience.size();\\n        vector<vector<int>> graph(n);\\n        for(auto edge : edges){\\n            graph[edge[0]].push_back(edge[1]);\\n            graph[edge[1]].push_back(edge[0]);\\n        }\\n        \\n        queue<int> queue;\\n        vector<bool> visited(n,false);\\n        vector<int> dist(n);\\n        queue.push(0);\\n        visited[0]=true;\\n        int d=0;\\n        while(!queue.empty()){\\n            int maxSize=queue.size();\\n            for(auto i=maxSize;i>0;i--){\\n                int u=queue.front();\\n                queue.pop();\\n                dist[u]=d;\\n                for(auto v: graph[u]){\\n                    if(!visited[v]){\\n                        queue.push(v);\\n                        visited[v]=true;\\n                    }\\n                }\\n            }\\n            d++;\\n        }\\n\\n        int slowest =0;\\n        \\n        for(int i=1;i<n;i++){\\n            int twoD = 2*dist[i];\\n            int pat = patience[i];\\n            int time = twoD + ((twoD-1)/pat)*pat;\\n            slowest= max(slowest,time);\\n        }\\n        \\n        return slowest+1;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int networkBecomesIdle(vector<vector<int>>& edges, vector<int>& patience) {\\n        int n = patience.size();\\n        vector<vector<int>> graph(n);\\n        for(auto edge : edges){\\n            graph[edge[0]].push_back(edge[1]);\\n            graph[edge[1]].push_back(edge[0]);\\n        }\\n        \\n        queue<int> queue;\\n        vector<bool> visited(n,false);\\n        vector<int> dist(n);\\n        queue.push(0);\\n        visited[0]=true;\\n        int d=0;\\n        while(!queue.empty()){\\n            int maxSize=queue.size();\\n            for(auto i=maxSize;i>0;i--){\\n                int u=queue.front();\\n                queue.pop();\\n                dist[u]=d;\\n                for(auto v: graph[u]){\\n                    if(!visited[v]){\\n                        queue.push(v);\\n                        visited[v]=true;\\n                    }\\n                }\\n            }\\n            d++;\\n        }\\n\\n        int slowest =0;\\n        \\n        for(int i=1;i<n;i++){\\n            int twoD = 2*dist[i];\\n            int pat = patience[i];\\n            int time = twoD + ((twoD-1)/pat)*pat;\\n            slowest= max(slowest,time);\\n        }\\n        \\n        return slowest+1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1840255,
                "title": "c-solution-using-bfs-o-n",
                "content": "```\\nclass Solution {\\npublic:\\n    int networkBecomesIdle(vector<vector<int>>& edges, vector<int>& patience) \\n    {\\n        int n = patience.size();\\n        vector<int> dist(n);\\n        vector<vector<int>> g(n);\\n        for(auto ed:edges)\\n        {\\n            g[ed[0]].push_back(ed[1]);\\n            g[ed[1]].push_back(ed[0]);\\n        }\\n        unordered_set<int> vis;\\n        \\n        queue<int> q;\\n        q.push(0);\\n        vis.insert(0);\\n        \\n        int lev=0;\\n        while(!q.empty())\\n        {\\n            int qsize=q.size();\\n            for(int i=0;i<qsize;i++)\\n            {\\n                int temp = q.front();\\n                q.pop();\\n                dist[temp] = lev;\\n                for(int j=0;j<g[temp].size();j++)\\n                {\\n                    if(vis.find(g[temp][j])==vis.end())\\n                    {\\n                        vis.insert(g[temp][j]);\\n                        q.push(g[temp][j]);\\n                    }\\n                }\\n            }\\n            \\n            lev++;\\n        }\\n        \\n        int maxTime=0;\\n        for(int i=1;i<n;i++)\\n        {\\n            int time = (((2*dist[i]-1)/patience[i])*patience[i])+2*dist[i];\\n            maxTime = max(maxTime,time);\\n        }\\n        \\n        return maxTime+1;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int networkBecomesIdle(vector<vector<int>>& edges, vector<int>& patience) \\n    {\\n        int n = patience.size();\\n        vector<int> dist(n);\\n        vector<vector<int>> g(n);\\n        for(auto ed:edges)\\n        {\\n            g[ed[0]].push_back(ed[1]);\\n            g[ed[1]].push_back(ed[0]);\\n        }\\n        unordered_set<int> vis;\\n        \\n        queue<int> q;\\n        q.push(0);\\n        vis.insert(0);\\n        \\n        int lev=0;\\n        while(!q.empty())\\n        {\\n            int qsize=q.size();\\n            for(int i=0;i<qsize;i++)\\n            {\\n                int temp = q.front();\\n                q.pop();\\n                dist[temp] = lev;\\n                for(int j=0;j<g[temp].size();j++)\\n                {\\n                    if(vis.find(g[temp][j])==vis.end())\\n                    {\\n                        vis.insert(g[temp][j]);\\n                        q.push(g[temp][j]);\\n                    }\\n                }\\n            }\\n            \\n            lev++;\\n        }\\n        \\n        int maxTime=0;\\n        for(int i=1;i<n;i++)\\n        {\\n            int time = (((2*dist[i]-1)/patience[i])*patience[i])+2*dist[i];\\n            maxTime = max(maxTime,time);\\n        }\\n        \\n        return maxTime+1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1838121,
                "title": "bfs",
                "content": "```\\nclass Solution:\\n    def networkBecomesIdle(self, edges: List[List[int]], patience: List[int]) -> int:\\n        n = len(patience)\\n        dist = [n] * n\\n        dist[0] = 0\\n        graph = defaultdict(list)\\n        for u, v in edges:\\n            graph[u].append(v)\\n            graph[v].append(u)\\n        dq = deque([0])\\n        while dq:\\n            node = dq.popleft()\\n            for child in graph[node]:\\n                if dist[child] == n:\\n                    dist[child] = dist[node] + 1\\n                    dq.append(child)\\n        return max((2 * dist[i] - 1) // patience[i] * patience[i] + 2 * dist[i] + 1 for i in range(1, n))",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def networkBecomesIdle(self, edges: List[List[int]], patience: List[int]) -> int:\\n        n = len(patience)\\n        dist = [n] * n\\n        dist[0] = 0\\n        graph = defaultdict(list)\\n        for u, v in edges:\\n            graph[u].append(v)\\n            graph[v].append(u)\\n        dq = deque([0])\\n        while dq:\\n            node = dq.popleft()\\n            for child in graph[node]:\\n                if dist[child] == n:\\n                    dist[child] = dist[node] + 1\\n                    dq.append(child)\\n        return max((2 * dist[i] - 1) // patience[i] * patience[i] + 2 * dist[i] + 1 for i in range(1, n))",
                "codeTag": "Java"
            },
            {
                "id": 1810647,
                "title": "python-bfs",
                "content": "The algorithm is consisted with 3 steps:\\n1. Build a graph based on the edges\\n2. Find the min seconds to pass a message one way to the 0 server (using BFS)\\n3. Calculate the max time when the network is idle\\n\\t* For each server, we can get how many messages are sent after the first message\\n\\t* We can get the time when the last message was sent from the current server\\n\\t* We know the one way time to the 0 server, so the result is the time that the last message was sent + the total travel time\\n\\n\\n```python\\nclass Solution:\\n    def networkBecomesIdle(self, edges: List[List[int]], patience: List[int]) -> int:\\n\\t\\t# step1\\n        size = len(patience)\\n        graph = [[] for _ in range(size)]\\n        for u, v in edges:\\n            graph[u].append(v)\\n            graph[v].append(u)\\n\\t\\t\\n\\t\\t# step 2\\n        from collections import deque\\n        queue = deque([0])\\n        times = [0] * size\\n        moves = 0\\n        while queue:\\n            for _ in range(len(queue)):\\n                server = queue.popleft()\\n                for connected in graph[server]:\\n                    if times[connected] == 0 and connected != 0:\\n                        queue.append(connected)\\n                        times[connected] = moves + 1\\n            moves += 1\\n\\t\\t\\t\\n\\t\\t# step 3\\n        max_time = max(times) * 2 + 1\\n        for time, wait in zip(times, patience): \\n            if time * 2 <= wait: continue\\n            num_of_messages = (time * 2 - 1) // wait # num of messages sent after the first message\\n\\t\\t\\t# `wait * num_of_messages` is the time when the last message was sent\\n\\t\\t\\t# `2 * time` is the round way travel time\\n\\t\\t\\t# `+1` is one second after the last response received\\n            max_time = max(max_time, wait * num_of_messages + 2 * time + 1)\\n        return max_time\\n```",
                "solutionTags": [
                    "Breadth-First Search"
                ],
                "code": "```python\\nclass Solution:\\n    def networkBecomesIdle(self, edges: List[List[int]], patience: List[int]) -> int:\\n\\t\\t# step1\\n        size = len(patience)\\n        graph = [[] for _ in range(size)]\\n        for u, v in edges:\\n            graph[u].append(v)\\n            graph[v].append(u)\\n\\t\\t\\n\\t\\t# step 2\\n        from collections import deque\\n        queue = deque([0])\\n        times = [0] * size\\n        moves = 0\\n        while queue:\\n            for _ in range(len(queue)):\\n                server = queue.popleft()\\n                for connected in graph[server]:\\n                    if times[connected] == 0 and connected != 0:\\n                        queue.append(connected)\\n                        times[connected] = moves + 1\\n            moves += 1\\n\\t\\t\\t\\n\\t\\t# step 3\\n        max_time = max(times) * 2 + 1\\n        for time, wait in zip(times, patience): \\n            if time * 2 <= wait: continue\\n            num_of_messages = (time * 2 - 1) // wait # num of messages sent after the first message\\n\\t\\t\\t# `wait * num_of_messages` is the time when the last message was sent\\n\\t\\t\\t# `2 * time` is the round way travel time\\n\\t\\t\\t# `+1` is one second after the last response received\\n            max_time = max(max_time, wait * num_of_messages + 2 * time + 1)\\n        return max_time\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1748043,
                "title": "python-dfs-w-comments",
                "content": "I found not counting resends that would be sent from a server the second the server receives it\\'s first message the most conceptually difficult part of this problem.\\n```\\nclass Solution(object):\\n    def networkBecomesIdle(self, edges, patience):\\n        \"\"\"\\n        :type edges: List[List[int]]\\n        :type patience: List[int]\\n        :rtype: int\\n        \"\"\"\\n        from collections import defaultdict, deque\\n\\t\\t\\n        adj = defaultdict(list)\\n        for e1, e2 in edges:\\n            adj[e1].append(e2)\\n            adj[e2].append(e1)\\n\\n#       dist will track distance from root to each node   \\n#       q contains (node, distance from root)\\n        dist = {}\\n        visited = set()\\n        q = deque([(0, 0)])\\n        \\n#       BFS to find distance of each node from root\\n        while q:\\n            node, distance = q.popleft()\\n            if node in visited: continue\\n            dist[node] = distance\\n            visited.add(node)\\n\\t\\t\\t# increment by 2 to find round trip distance\\n            distance += 2\\n            \\n            for nei in adj[node]:\\n                if nei in visited: continue\\n                q.append((nei, distance))\\n                \\n        time = 0\\n        \\n        for node, distance in dist.items():\\n            if node == 0:\\n                continue\\n#           Find the number of resends for each server\\n#           A server will stop resending the second it receives a response. \\n#           Therefore, we must subtract 1 to prevent overccounting resends\\n            resends = ((distance) - 1)//patience[node] \\n            temp_time = (resends * patience[node] ) + distance\\n#           If the number of resends * patience + total distance is greater\\n#           than the current max time, replace time\\n            time = max(time, temp_time)\\n    \\n        return time + 1\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def networkBecomesIdle(self, edges, patience):\\n        \"\"\"\\n        :type edges: List[List[int]]\\n        :type patience: List[int]\\n        :rtype: int\\n        \"\"\"\\n        from collections import defaultdict, deque\\n\\t\\t\\n        adj = defaultdict(list)\\n        for e1, e2 in edges:\\n            adj[e1].append(e2)\\n            adj[e2].append(e1)\\n\\n#       dist will track distance from root to each node   \\n#       q contains (node, distance from root)\\n        dist = {}\\n        visited = set()\\n        q = deque([(0, 0)])\\n        \\n#       BFS to find distance of each node from root\\n        while q:\\n            node, distance = q.popleft()\\n            if node in visited: continue\\n            dist[node] = distance\\n            visited.add(node)\\n\\t\\t\\t# increment by 2 to find round trip distance\\n            distance += 2\\n            \\n            for nei in adj[node]:\\n                if nei in visited: continue\\n                q.append((nei, distance))\\n                \\n        time = 0\\n        \\n        for node, distance in dist.items():\\n            if node == 0:\\n                continue\\n#           Find the number of resends for each server\\n#           A server will stop resending the second it receives a response. \\n#           Therefore, we must subtract 1 to prevent overccounting resends\\n            resends = ((distance) - 1)//patience[node] \\n            temp_time = (resends * patience[node] ) + distance\\n#           If the number of resends * patience + total distance is greater\\n#           than the current max time, replace time\\n            time = max(time, temp_time)\\n    \\n        return time + 1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1723677,
                "title": "python-3-bfs-simple",
                "content": "\\n```\\n    def networkBecomesIdle(self, edges: List[List[int]], patience: List[int]) -> int:\\n        \\n        nN = len(patience)\\n        \\n\\t\\t# set of direct neighbors\\n        dictS2 = defaultdict(set)\\n        for a,b in edges:\\n            dictS2[a].add(b)\\n            dictS2[b].add(a)\\n        \\n\\t\\t# BFS\\n        dictSD = defaultdict(set)\\n        setSeen = {0}\\n        d = 0\\n        dictSD[d] = {0}\\n        while len(setSeen)<nN:\\n            d += 1\\n            dictSD[d] = set( n for i in dictSD[d-1] for n in dictS2[i] ) - setSeen\\n            setSeen |= dictSD[d]\\n\\n        return max( 2*k + patience[i]*((2*k-1)//patience[i]) for k in range(1,len(dictSD)) for i in dictSD[k]) + 1\\n```",
                "solutionTags": [],
                "code": "```\\n    def networkBecomesIdle(self, edges: List[List[int]], patience: List[int]) -> int:\\n        \\n        nN = len(patience)\\n        \\n\\t\\t# set of direct neighbors\\n        dictS2 = defaultdict(set)\\n        for a,b in edges:\\n            dictS2[a].add(b)\\n            dictS2[b].add(a)\\n        \\n\\t\\t# BFS\\n        dictSD = defaultdict(set)\\n        setSeen = {0}\\n        d = 0\\n        dictSD[d] = {0}\\n        while len(setSeen)<nN:\\n            d += 1\\n            dictSD[d] = set( n for i in dictSD[d-1] for n in dictS2[i] ) - setSeen\\n            setSeen |= dictSD[d]\\n\\n        return max( 2*k + patience[i]*((2*k-1)//patience[i]) for k in range(1,len(dictSD)) for i in dictSD[k]) + 1\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1711659,
                "title": "java-bfs-clean-solution",
                "content": "```\\nclass Solution {\\n    public int networkBecomesIdle(int[][] edges, int[] patience) {\\n        HashMap<Integer, HashSet<Integer>> graph = new HashMap<>();\\n        int lastServer = -1, noPack = 0, copPack = 0, lastBusy = Integer.MIN_VALUE;\\n        int distance = 0, count = 1, nextCount = 0;\\n        \\n        for(int[] e : edges)\\n        {\\n            graph.computeIfAbsent(e[0], k-> new HashSet<Integer>());\\n            graph.computeIfAbsent(e[1], k-> new HashSet<Integer>());\\n            graph.get(e[0]).add(e[1]);\\n            graph.get(e[1]).add(e[0]);\\n            lastServer = Math.max(lastServer, Math.max(e[0],e[1]));\\n        }\\n        \\n        int[] map = new int[lastServer+1];\\n        Queue<Integer> q = new LinkedList<>();\\n        HashSet<Integer> visited = new HashSet<>();\\n        q.add(0);\\n        visited.add(0);\\n        \\n        while(count > 0)\\n        {\\n            distance++;\\n            while(count-- > 0)\\n            {\\n                int temp = q.poll();\\n                for(int neighbour : graph.get(temp))\\n                {\\n                    if(!visited.contains(neighbour))\\n                    {\\n                        visited.add(neighbour);\\n                        q.add(neighbour);\\n                        nextCount++;\\n                        map[neighbour] = distance * 2;\\n                    }\\n                }\\n            }\\n            count = nextCount;\\n            nextCount = 0;\\n        }\\n        \\n        for(int i = 1 ; i <= lastServer ; i++)\\n        {\\n            noPack = (map[i]%patience[i]) == 0 ?  map[i]/patience[i] : map[i]/patience[i] + 1;\\n            copPack = noPack - 1;\\n            int currBusy = (copPack * patience[i]) + map[i];\\n            lastBusy = Math.max(lastBusy, currBusy);\\n        }\\n        \\n        return lastBusy + 1;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution {\\n    public int networkBecomesIdle(int[][] edges, int[] patience) {\\n        HashMap<Integer, HashSet<Integer>> graph = new HashMap<>();\\n        int lastServer = -1, noPack = 0, copPack = 0, lastBusy = Integer.MIN_VALUE;\\n        int distance = 0, count = 1, nextCount = 0;\\n        \\n        for(int[] e : edges)\\n        {\\n            graph.computeIfAbsent(e[0], k-> new HashSet<Integer>());\\n            graph.computeIfAbsent(e[1], k-> new HashSet<Integer>());\\n            graph.get(e[0]).add(e[1]);\\n            graph.get(e[1]).add(e[0]);\\n            lastServer = Math.max(lastServer, Math.max(e[0],e[1]));\\n        }\\n        \\n        int[] map = new int[lastServer+1];\\n        Queue<Integer> q = new LinkedList<>();\\n        HashSet<Integer> visited = new HashSet<>();\\n        q.add(0);\\n        visited.add(0);\\n        \\n        while(count > 0)\\n        {\\n            distance++;\\n            while(count-- > 0)\\n            {\\n                int temp = q.poll();\\n                for(int neighbour : graph.get(temp))\\n                {\\n                    if(!visited.contains(neighbour))\\n                    {\\n                        visited.add(neighbour);\\n                        q.add(neighbour);\\n                        nextCount++;\\n                        map[neighbour] = distance * 2;\\n                    }\\n                }\\n            }\\n            count = nextCount;\\n            nextCount = 0;\\n        }\\n        \\n        for(int i = 1 ; i <= lastServer ; i++)\\n        {\\n            noPack = (map[i]%patience[i]) == 0 ?  map[i]/patience[i] : map[i]/patience[i] + 1;\\n            copPack = noPack - 1;\\n            int currBusy = (copPack * patience[i]) + map[i];\\n            lastBusy = Math.max(lastBusy, currBusy);\\n        }\\n        \\n        return lastBusy + 1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1710416,
                "title": "dijkstra-with-explaining-comments-java",
                "content": "\\tclass Solution {\\n\\t  public int networkBecomesIdle(int[][] edges, int[] patience) {\\n\\t\\t// Use Dijkstra\\'s algo to find distances from source server (0) to every\\n\\t\\t// other server.\\n\\t\\tint[] distances = findShortestDistances(edges);\\n\\n\\t\\tint maxTimeToIdle = 0;\\n\\t\\t// Ignore source server while computing minimum time to idle since network \\n\\t\\t// becomes idle when all data servers have received response from the\\n\\t\\t// source server.\\n\\t\\tfor (int i = 1; i < distances.length; i++) {\\n\\t\\t  int timeToIdle = 0;\\n\\t\\t  if (patience[i] >= distances[i]) {\\n\\t\\t\\ttimeToIdle = distances[i] + 1;\\n\\t\\t  } else {\\n\\t\\t\\t// No of messages EXCLUDING the initial message. \\n\\t\\t\\tint numberOfFollowUpMessages = (distances[i] - 1) / patience[i];\\n\\t\\t\\ttimeToIdle =\\n\\t\\t\\t\\tdistances[i] + (numberOfFollowUpMessages * patience[i]) + 1;\\n\\t\\t  }\\n\\t\\t  maxTimeToIdle = Math.max(timeToIdle, maxTimeToIdle);\\n\\t\\t}\\n\\n\\t\\treturn maxTimeToIdle;\\n\\t  }\\n\\n\\t  // Dijkstra\\'s Algo.\\n\\t  private int[] findShortestDistances(int[][] edges) {\\n\\t\\tint sourceNode = 0;\\n\\t\\t// Setting distance between two nodes as 2 seconds since we are looking for a round-trip duration.\\n\\t\\tint distanceBetweenTwoNodes = 2;\\n\\n\\t\\tHashMap<Integer, ArrayList<Integer>> graph = new HashMap<>();\\n\\t\\tfor (int i = 0; i < edges.length; i++) {\\n\\t\\t  int source = edges[i][0];\\n\\t\\t  int target = edges[i][1];\\n\\t\\t  if (!graph.containsKey(source)) {\\n\\t\\t\\tgraph.put(source, new ArrayList<Integer>());\\n\\t\\t  }\\n\\t\\t  if (!graph.containsKey(target)) {\\n\\t\\t\\tgraph.put(target, new ArrayList<Integer>());\\n\\t\\t  }\\n\\t\\t  graph.get(source).add(target);\\n\\t\\t  graph.get(target).add(source);\\n\\t\\t}\\n\\n\\t\\t// Set to track visited nodes. \\n\\t\\tHashSet<Integer> visitedNodes = new HashSet<>();\\n\\n\\t\\t// Array to keep track of distances from source to other nodes.\\n\\t\\tint[] distances = new int[graph.keySet().size()];\\n\\t\\tArrays.fill(distances, Integer.MAX_VALUE);\\n\\n\\t\\t// Priority queue to track unvisited nodes and their distance from the source node.\\n\\t\\tPriorityQueue<int[]> unvisitedNodesInfo =\\n\\t\\t\\tnew PriorityQueue<>((info1, info2) -> info1[1] - info2[1]);\\n\\n\\t\\t// Set distance from source node to itself to 0.\\n\\t\\tunvisitedNodesInfo.add(new int[]{sourceNode, 0});\\n\\t\\tdistances[sourceNode] = 0;\\n\\n\\t\\t// While some unvisited nodes remain.\\n\\t\\twhile (unvisitedNodesInfo.size() > 0) {\\n\\t\\t  int[] nodeInfo = unvisitedNodesInfo.remove();\\n\\t\\t  // If the node is already visited and distance from source to it is frozen.\\n\\t\\t  if (visitedNodes.contains(nodeInfo[0])) {\\n\\t\\t\\tcontinue;\\n\\t\\t  }\\n\\n\\t\\t  int currentNode = nodeInfo[0];\\n\\t\\t  int distanceToCurrentNode = nodeInfo[1];\\n\\n\\t\\t  // Iterate over every neighbour of the current node.\\n\\t\\t  graph.get(currentNode).forEach((target) -> {\\n\\t\\t\\t// Do not relax distance to a target node if it has already been visited.\\n\\t\\t\\tif (visitedNodes.contains(target)) {\\n\\t\\t\\t  return;\\n\\t\\t\\t}\\n\\n\\t\\t\\t// Relax distance to the target node.\\n\\t\\t\\tint proposedShorterDistance =\\n\\t\\t\\t\\tdistanceToCurrentNode + distanceBetweenTwoNodes;\\n\\t\\t\\tif (proposedShorterDistance < distances[target]) {\\n\\t\\t\\t  unvisitedNodesInfo\\n\\t\\t\\t\\t.add(new int[]{target, proposedShorterDistance});\\n\\t\\t\\t  distances[target] = proposedShorterDistance;\\n\\t\\t\\t}\\n\\t\\t  });\\n\\n\\t\\t  // Mark current node as visited.\\n\\t\\t  visitedNodes.add(currentNode);\\n\\t\\t}\\n\\n\\t\\treturn distances;\\n\\t  }\\n\\t}",
                "solutionTags": [],
                "code": "class Solution {\\n\\t  public int networkBecomesIdle(int[][] edges, int[] patience) {\\n\\t\\t// Use Dijkstra\\'s algo to find distances from source server (0) to every\\n\\t\\t// other server.\\n\\t\\tint[] distances = findShortestDistances(edges);\\n\\n\\t\\tint maxTimeToIdle = 0;\\n\\t\\t// Ignore source server while computing minimum time to idle since network \\n\\t\\t// becomes idle when all data servers have received response from the\\n\\t\\t// source server.\\n\\t\\tfor (int i = 1; i < distances.length; i++) {\\n\\t\\t  int timeToIdle = 0;\\n\\t\\t  if (patience[i] >= distances[i]) {\\n\\t\\t\\ttimeToIdle = distances[i] + 1;\\n\\t\\t  }",
                "codeTag": "Java"
            },
            {
                "id": 1670121,
                "title": "python-simple-bfs-implementation",
                "content": "Approach:\\n\\n1. Build an adjency list.\\n2. BFS from the master to get the shortest path from node to master.\\n3. Calculate when the last message transmission time is, and time for the reply to that message to reach the node.\\n\\n```\\nclass Solution:\\n    def networkBecomesIdle(self, edges: List[List[int]], patience: List[int]) -> int:\\n        # create adjacency list\\n        adj_list = defaultdict(list)\\n        for i,j in edges:\\n            adj_list[i].append(j)\\n            adj_list[j].append(i)\\n        \\n        # min_time is the time taken for a message to reach master and come back. Set to -1\\n        min_time = {i:-1 for i in adj_list.keys()}\\n        \\n        # set master to node 0\\n        master = 0\\n        queue = [master]\\n        visited = {master}\\n        # time variable keeps track of distance from master\\n        time = 0\\n        min_time[master] = time\\n        \\n        # BFS to get minimum distance for each node to master\\n        while queue:\\n            new_queue = []\\n            for node in queue:\\n                for neighbor in adj_list[node]:\\n                    if neighbor not in visited:\\n                        # Multiply time by 2 to account for roundabout time\\n                        min_time[neighbor] = 2*(time+1)\\n                        visited.add(neighbor)\\n                        new_queue.append(neighbor)\\n            \\n            time += 1\\n            queue = new_queue\\n        \\n        # remove master from further calculations as it will always be 0\\n        del min_time[master]\\n        \\n        # (time-1) - (time-1)%patience[i] is used to calculate the time the last message was sent\\n        # before the first reply reached the server i\\n        # time - 1 is used because if the message reaches the server at the same time the message is\\n        # supposed to be transmitted, the message is not transmitted anymore\\n        min_time = {i:(time-1) - (time-1)%patience[i] + time for i,time in min_time.items()}\\n        \\n        return max(min_time.values()) + 1\\n",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Breadth-First Search",
                    "Graph"
                ],
                "code": "class Solution:\\n    def networkBecomesIdle(self, edges: List[List[int]], patience: List[int]) -> int:\\n        # create adjacency list\\n        adj_list = defaultdict(list)\\n        for i,j in edges:\\n            adj_list[i].append(j)\\n            adj_list[j].append(i)\\n        \\n        # min_time is the time taken for a message to reach master and come back. Set to -1\\n        min_time = {i:-1 for i in adj_list.keys()}",
                "codeTag": "Java"
            },
            {
                "id": 1660167,
                "title": "c-clean-bfs-solution-with-explaination",
                "content": "To understand:\\n1. The  network will be ideal when the last signal will be processed.\\n2. To know that we first need to know the shortest path for all nodes using BFS.\\n3. The first signal will be received after t = 2* shortest path seconds.\\n4. The servers can send signals between 1 to t-1; So the last signal will be sent at  let t_last =   (t-1) - ((t-1)%patience[i]). \\n5. The last signal will be received at t_last + t; The process ends at t_last+t+1;\\n6. Now find this for all nodes and find maximum among them\\n\\n\\n```\\nclass Solution {\\npublic:\\n    vector<int> bfs(int source,  vector<int> adj[],int n){\\n      vector<bool>visited(n,false);\\n      visited[source]=true;\\n      vector<int> dis(n);\\n      queue<int> q;\\n      q.push(source);\\n      dis[source]=0;\\n        \\n        while(!q.empty()){\\n            auto node = q.front();q.pop();\\n            for(auto  child:adj[node]){\\n               if(!visited[child]){\\n                   dis[child] = 1+dis[node];\\n                   visited[child]=true;\\n                   q.push(child);\\n               }\\n            }\\n        }\\n        return dis;\\n    }\\n    int networkBecomesIdle(vector<vector<int>>& edges, vector<int>& patience) {\\n        int n = patience.size();\\n        vector<int> adj[n];\\n        \\n        for(auto x:edges){\\n            adj[x[0]].push_back(x[1]);\\n            adj[x[1]].push_back(x[0]);\\n        }\\n        \\n     \\n        auto dis = bfs(0,adj,n);\\n        \\n        for(int i=0;i<n;i++){\\n            dis[i]*=2;\\n        }\\n        \\n        int ans=INT_MIN;\\n        \\n        for(int i=1;i<n;i++){\\n            if(patience[i]<dis[i]){\\n                int valid_time = dis[i]-1;\\n                int last_signal = valid_time - (valid_time%patience[i]);\\n                dis[i] = last_signal + dis[i] + 1;\\n            }\\n            else{\\n                dis[i]++;\\n            }\\n            ans=max(ans,dis[i]);\\n        }\\n        \\n        return ans;       \\n        \\n    }\\n};\\n\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> bfs(int source,  vector<int> adj[],int n){\\n      vector<bool>visited(n,false);\\n      visited[source]=true;\\n      vector<int> dis(n);\\n      queue<int> q;\\n      q.push(source);\\n      dis[source]=0;\\n        \\n        while(!q.empty()){\\n            auto node = q.front();q.pop();\\n            for(auto  child:adj[node]){\\n               if(!visited[child]){\\n                   dis[child] = 1+dis[node];\\n                   visited[child]=true;\\n                   q.push(child);\\n               }\\n            }\\n        }\\n        return dis;\\n    }\\n    int networkBecomesIdle(vector<vector<int>>& edges, vector<int>& patience) {\\n        int n = patience.size();\\n        vector<int> adj[n];\\n        \\n        for(auto x:edges){\\n            adj[x[0]].push_back(x[1]);\\n            adj[x[1]].push_back(x[0]);\\n        }\\n        \\n     \\n        auto dis = bfs(0,adj,n);\\n        \\n        for(int i=0;i<n;i++){\\n            dis[i]*=2;\\n        }\\n        \\n        int ans=INT_MIN;\\n        \\n        for(int i=1;i<n;i++){\\n            if(patience[i]<dis[i]){\\n                int valid_time = dis[i]-1;\\n                int last_signal = valid_time - (valid_time%patience[i]);\\n                dis[i] = last_signal + dis[i] + 1;\\n            }\\n            else{\\n                dis[i]++;\\n            }\\n            ans=max(ans,dis[i]);\\n        }\\n        \\n        return ans;       \\n        \\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1654730,
                "title": "c-simple-bfs-most-readable-amateur-friendly",
                "content": "```\\nclass Solution {\\npublic:\\n    int networkBecomesIdle(vector<vector<int>>& edges, vector<int>& p) {\\n        int n = p.size();\\n\\n        //making an adjacency list of undirected graph\\n        vector<int> adj[n];\\n        for(auto& e : edges){\\n            int u = e[0];\\n            int v = e[1];\\n\\n            adj[u].push_back(v);\\n            adj[v].push_back(u);\\n        }\\n\\n        //finding the shortest distance from master node(0) to all other nodes in the graph\\n        // we will use bfs since each edge is equal weighted (weight = 1 second)\\n        vector<int> dist(n, INT_MAX);\\n        dist[0]  = 0;\\n\\n        queue<int> q;\\n        q.push(0);\\n\\n        while(q.size()){\\n            int qsize = q.size();\\n            while(qsize--){\\n                int currNode = q.front();\\n                q.pop();\\n                int currDist = dist[currNode];\\n\\n                for(auto adjNode : adj[currNode]){\\n                    if(dist[adjNode] == INT_MAX){\\n                        dist[adjNode] = 1 + currDist;\\n                        q.push(adjNode);\\n                    }\\n                }\\n            }\\n        }\\n\\n        //now, for each data node, calculate the last recieving time for it \\n        vector<int> rcvdTime(n,0);\\n        for(int i=1;i<n;i++){\\n            int totPacketsSent = 1 + (2*dist[i] - 1)/p[i];\\n            \\n            int lastSentTime =  (totPacketsSent-1)*p[i];\\n            int lastRcvdTime = lastSentTime + 2*dist[i];\\n\\n            rcvdTime[i] = lastRcvdTime;\\n        }\\n\\n\\n        //now find the maximum of all these last recieving times\\n        int maxiTime = 0;\\n        for(int i=1;i<n;i++)\\n            maxiTime = max(maxiTime, rcvdTime[i]);\\n\\n        \\n        return maxiTime+1;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int networkBecomesIdle(vector<vector<int>>& edges, vector<int>& p) {\\n        int n = p.size();\\n\\n        //making an adjacency list of undirected graph\\n        vector<int> adj[n];\\n        for(auto& e : edges){\\n            int u = e[0];\\n            int v = e[1];\\n\\n            adj[u].push_back(v);\\n            adj[v].push_back(u);\\n        }\\n\\n        //finding the shortest distance from master node(0) to all other nodes in the graph\\n        // we will use bfs since each edge is equal weighted (weight = 1 second)\\n        vector<int> dist(n, INT_MAX);\\n        dist[0]  = 0;\\n\\n        queue<int> q;\\n        q.push(0);\\n\\n        while(q.size()){\\n            int qsize = q.size();\\n            while(qsize--){\\n                int currNode = q.front();\\n                q.pop();\\n                int currDist = dist[currNode];\\n\\n                for(auto adjNode : adj[currNode]){\\n                    if(dist[adjNode] == INT_MAX){\\n                        dist[adjNode] = 1 + currDist;\\n                        q.push(adjNode);\\n                    }\\n                }\\n            }\\n        }\\n\\n        //now, for each data node, calculate the last recieving time for it \\n        vector<int> rcvdTime(n,0);\\n        for(int i=1;i<n;i++){\\n            int totPacketsSent = 1 + (2*dist[i] - 1)/p[i];\\n            \\n            int lastSentTime =  (totPacketsSent-1)*p[i];\\n            int lastRcvdTime = lastSentTime + 2*dist[i];\\n\\n            rcvdTime[i] = lastRcvdTime;\\n        }\\n\\n\\n        //now find the maximum of all these last recieving times\\n        int maxiTime = 0;\\n        for(int i=1;i<n;i++)\\n            maxiTime = max(maxiTime, rcvdTime[i]);\\n\\n        \\n        return maxiTime+1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1615517,
                "title": "o-n-check-position-of-latest-request-when-first-request-is-back-to-source",
                "content": "```\\n// https://leetcode.com/problems/the-time-when-the-network-becomes-idle/\\n// Medium\\n// BFS, List\\n// O(n)\\n\\nclass Server {\\npublic:\\n    int val, patience;\\n    int distance = 0;\\n    bool visited = false;\\n    list<int>edges;\\n    \\n    Server(int val, int patience): val(val), patience(patience) {\\n    }\\n    void updateState(int distance) {\\n        // printf(\"val : %d, dis : %d\\\\n\", val, distance);\\n        this->distance = distance;\\n        this->visited = true;\\n    }\\n};\\nclass Solution {\\nprivate:\\n    // Iterate the graph from server 0 and find the distance to all the server\\n    void shortestDistanceFromSource(int sourceIndex, vector<Server*>& servers) {\\n        \\n        list<Server*> serverList;\\n        Server *source, *child;\\n        int distance = 0,\\n            size;\\n        \\n        source = servers[sourceIndex];\\n        serverList.push_back(source);\\n        source->updateState(0);\\n        \\n        while(!serverList.empty()) {\\n            size = serverList.size();\\n            while (size--) {\\n                source = serverList.front();\\n                serverList.pop_front();\\n                \\n                list<int>& edges = source->edges;\\n                for (int x : edges) {\\n                    child = servers[x];\\n                    if (!child->visited) {\\n                        serverList.push_back(child);\\n                        child->updateState(distance + 1);\\n                    }\\n                }\\n            }\\n            ++distance;\\n        }\\n    }\\n    \\npublic:\\n    int networkBecomesIdle(vector<vector<int>>& edges, vector<int>& patience) {\\n        \\n        int len = patience.size(),\\n            u, v;\\n        vector<Server*> servers(len);\\n        \\n        for (int i = 0; i != len; ++i) {\\n            servers[i] = new Server(i, patience[i]);\\n        }\\n        \\n        // Create Server Graph\\n        for(vector<int>& edge: edges) {\\n            u = edge[0];\\n            v = edge[1];\\n            servers[u]->edges.push_back(v);\\n            servers[v]->edges.push_back(u);\\n        }\\n        \\n        shortestDistanceFromSource(0, servers);\\n        \\n        Server *server;\\n        int idleTime = 0, dis, pat, minim, lastRequest;\\n        for(int i = 1; i != len; ++i) {\\n            server = servers[i];\\n            \\n            dis = 2 * server->distance;\\n            pat = server->patience;\\n            \\n            // printf(\"pat : %d, dis : %d\\\\n\", pat, dis);\\n            // --> move from server the source\\n            // <-- move from source to server\\n            if (pat < dis) {\\n                // if the first request is `pat` distance away from master -->,\\n                // then the distance of latest new request is pat distance away from master <--\\n                if (dis % pat == 0) {\\n                    lastRequest = pat;\\n                }\\n                // else the remaining distance of first request from master -->,\\n                // is the distance of last request away from source <--\\n                else {    \\n                    lastRequest = (dis % pat);\\n                }\\n                // (dis - lastRequest) --> hops left from last request back to source\\n                idleTime = max(idleTime, dis + (dis - lastRequest));\\n            }\\n            else { // only one request is transmitted\\n                idleTime = max(idleTime, dis);\\n            }\\n            // printf(\"idleTime : %d\\\\n\", idleTime);\\n        }\\n        return idleTime + 1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Breadth-First Search"
                ],
                "code": "```\\n// https://leetcode.com/problems/the-time-when-the-network-becomes-idle/\\n// Medium\\n// BFS, List\\n// O(n)\\n\\nclass Server {\\npublic:\\n    int val, patience;\\n    int distance = 0;\\n    bool visited = false;\\n    list<int>edges;\\n    \\n    Server(int val, int patience): val(val), patience(patience) {\\n    }\\n    void updateState(int distance) {\\n        // printf(\"val : %d, dis : %d\\\\n\", val, distance);\\n        this->distance = distance;\\n        this->visited = true;\\n    }\\n};\\nclass Solution {\\nprivate:\\n    // Iterate the graph from server 0 and find the distance to all the server\\n    void shortestDistanceFromSource(int sourceIndex, vector<Server*>& servers) {\\n        \\n        list<Server*> serverList;\\n        Server *source, *child;\\n        int distance = 0,\\n            size;\\n        \\n        source = servers[sourceIndex];\\n        serverList.push_back(source);\\n        source->updateState(0);\\n        \\n        while(!serverList.empty()) {\\n            size = serverList.size();\\n            while (size--) {\\n                source = serverList.front();\\n                serverList.pop_front();\\n                \\n                list<int>& edges = source->edges;\\n                for (int x : edges) {\\n                    child = servers[x];\\n                    if (!child->visited) {\\n                        serverList.push_back(child);\\n                        child->updateState(distance + 1);\\n                    }\\n                }\\n            }\\n            ++distance;\\n        }\\n    }\\n    \\npublic:\\n    int networkBecomesIdle(vector<vector<int>>& edges, vector<int>& patience) {\\n        \\n        int len = patience.size(),\\n            u, v;\\n        vector<Server*> servers(len);\\n        \\n        for (int i = 0; i != len; ++i) {\\n            servers[i] = new Server(i, patience[i]);\\n        }\\n        \\n        // Create Server Graph\\n        for(vector<int>& edge: edges) {\\n            u = edge[0];\\n            v = edge[1];\\n            servers[u]->edges.push_back(v);\\n            servers[v]->edges.push_back(u);\\n        }\\n        \\n        shortestDistanceFromSource(0, servers);\\n        \\n        Server *server;\\n        int idleTime = 0, dis, pat, minim, lastRequest;\\n        for(int i = 1; i != len; ++i) {\\n            server = servers[i];\\n            \\n            dis = 2 * server->distance;\\n            pat = server->patience;\\n            \\n            // printf(\"pat : %d, dis : %d\\\\n\", pat, dis);\\n            // --> move from server the source\\n            // <-- move from source to server\\n            if (pat < dis) {\\n                // if the first request is `pat` distance away from master -->,\\n                // then the distance of latest new request is pat distance away from master <--\\n                if (dis % pat == 0) {\\n                    lastRequest = pat;\\n                }\\n                // else the remaining distance of first request from master -->,\\n                // is the distance of last request away from source <--\\n                else {    \\n                    lastRequest = (dis % pat);\\n                }\\n                // (dis - lastRequest) --> hops left from last request back to source\\n                idleTime = max(idleTime, dis + (dis - lastRequest));\\n            }\\n            else { // only one request is transmitted\\n                idleTime = max(idleTime, dis);\\n            }\\n            // printf(\"idleTime : %d\\\\n\", idleTime);\\n        }\\n        return idleTime + 1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 2048147,
                "content": [
                    {
                        "username": "pa-one55",
                        "content": "Okay, later."
                    },
                    {
                        "username": "lucifer_65",
                        "content": "This should be marked easy!!"
                    }
                ]
            },
            {
                "id": 2035795,
                "content": [
                    {
                        "username": "pa-one55",
                        "content": "Okay, later."
                    },
                    {
                        "username": "lucifer_65",
                        "content": "This should be marked easy!!"
                    }
                ]
            }
        ]
    }
]