[
    {
        "title": "H-Index",
        "question_content": "Given an array of integers citations where citations[i] is the number of citations a researcher received for their ith paper, return the researcher's h-index.\nAccording to the definition of h-index on Wikipedia: The h-index is defined as the maximum value of h such that the given researcher has published at least h papers that have each been cited at least h times.\n&nbsp;\nExample 1:\n\nInput: citations = [3,0,6,1,5]\nOutput: 3\nExplanation: [3,0,6,1,5] means the researcher has 5 papers in total and each of them had received 3, 0, 6, 1, 5 citations respectively.\nSince the researcher has 3 papers with at least 3 citations each and the remaining two with no more than 3 citations each, their h-index is 3.\n\nExample 2:\n\nInput: citations = [1,3,1]\nOutput: 1\n\n&nbsp;\nConstraints:\n\n\tn == citations.length\n\t1 <= n <= 5000\n\t0 <= citations[i] <= 1000",
        "solutions": [
            {
                "id": 70768,
                "title": "java-bucket-sort-o-n-solution-with-detail-explanation",
                "content": "This type of problems always throw me off, but it just takes some getting used to.  The idea behind it is some bucket sort mechanisms.  First, you may ask why bucket sort.  Well, the h-index is defined as the number of papers with reference greater than the number.  So assume `n` is the total number of papers, if we have `n+1` buckets, number from 0 to n, then for any paper with reference corresponding to the index of the bucket, we increment the count for that bucket.  The only exception is that for any paper with larger number of reference than `n`, we put in the `n`-th bucket.  \\n\\nThen we iterate from the back to the front of the buckets, whenever the total count exceeds the index of the bucket, meaning that we have the index number of papers that have reference greater than or equal to the index.  Which will be our h-index result.  The reason to scan from the end of the array is that we are looking for the greatest h-index.  For example, given array `[3,0,6,5,1]`, we have 6 buckets to contain how many papers have the corresponding index.  Hope to image and explanation help.\\n\\n\\n![Buckets][1]\\n\\n\\n\\n\\n    public int hIndex(int[] citations) {\\n        int n = citations.length;\\n        int[] buckets = new int[n+1];\\n        for(int c : citations) {\\n            if(c >= n) {\\n                buckets[n]++;\\n            } else {\\n                buckets[c]++;\\n            }\\n        }\\n        int count = 0;\\n        for(int i = n; i >= 0; i--) {\\n            count += buckets[i];\\n            if(count >= i) {\\n                return i;\\n            }\\n        }\\n        return 0;\\n    }\\n\\n\\n  [1]: http://i67.tinypic.com/2yvpfv5.jpg",
                "solutionTags": [
                    "Java"
                ],
                "code": "This type of problems always throw me off, but it just takes some getting used to.  The idea behind it is some bucket sort mechanisms.  First, you may ask why bucket sort.  Well, the h-index is defined as the number of papers with reference greater than the number.  So assume `n` is the total number of papers, if we have `n+1` buckets, number from 0 to n, then for any paper with reference corresponding to the index of the bucket, we increment the count for that bucket.  The only exception is that for any paper with larger number of reference than `n`, we put in the `n`-th bucket.  \\n\\nThen we iterate from the back to the front of the buckets, whenever the total count exceeds the index of the bucket, meaning that we have the index number of papers that have reference greater than or equal to the index.  Which will be our h-index result.  The reason to scan from the end of the array is that we are looking for the greatest h-index.  For example, given array `[3,0,6,5,1]`, we have 6 buckets to contain how many papers have the corresponding index.  Hope to image and explanation help.\\n\\n\\n![Buckets][1]\\n\\n\\n\\n\\n    public int hIndex(int[] citations) {\\n        int n = citations.length;\\n        int[] buckets = new int[n+1];\\n        for(int c : citations) {\\n            if(c >= n) {\\n                buckets[n]++;\\n            } else {\\n                buckets[c]++;\\n            }\\n        }\\n        int count = 0;\\n        for(int i = n; i >= 0; i--) {\\n            count += buckets[i];\\n            if(count >= i) {\\n                return i;\\n            }\\n        }\\n        return 0;\\n    }\\n\\n\\n  [1]: http://i67.tinypic.com/2yvpfv5.jpg",
                "codeTag": "Unknown"
            },
            {
                "id": 70810,
                "title": "a-clean-o-n-solution-in-java",
                "content": "    public int hIndex(int[] citations) {\\n        int len = citations.length;\\n        int[] count = new int[len + 1];\\n        \\n        for (int c: citations)\\n            if (c > len) \\n                count[len]++;\\n            else \\n                count[c]++;\\n        \\n        \\n        int total = 0;\\n        for (int i = len; i >= 0; i--) {\\n            total += count[i];\\n            if (total >= i)\\n                return i;\\n        }\\n        \\n        return 0;\\n    }",
                "solutionTags": [],
                "code": "    public int hIndex(int[] citations) {\\n        int len = citations.length;\\n        int[] count = new int[len + 1];\\n        \\n        for (int c: citations)\\n            if (c > len) \\n                count[len]++;\\n            else \\n                count[c]++;\\n        \\n        \\n        int total = 0;\\n        for (int i = len; i >= 0; i--) {\\n            total += count[i];\\n            if (total >= i)\\n                return i;\\n        }\\n        \\n        return 0;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 71055,
                "title": "1-line-python-solution",
                "content": "It's straightforward:\\n\\n        return sum(i < j for i, j in enumerate(sorted(citations, reverse=True)))",
                "solutionTags": [
                    "Python"
                ],
                "code": "It's straightforward:\\n\\n        return sum(i < j for i, j in enumerate(sorted(citations, reverse=True)))",
                "codeTag": "Unknown"
            },
            {
                "id": 70818,
                "title": "java-o-n-time-with-easy-explanation",
                "content": "The idea is to see that the result can only range from 0 to the length of the array (because we can't have h-index greater than the total papers published). So we create an array \"arr\" which acts like a HashMap (using pigeon hole principle) and loop backwards from the highest element, then we find \"tot\" which is the total number of papers that has more than i citations, and we stop when tot>=i (total number of papers with more than i citations >= i). We don't need to keep going because we are trying the biggest i possible, we we stop and return the result.\\n\\n    public class Solution {\\n    public int hIndex(int[] citations) {\\n        int n = citations.length, tot=0;\\n        int[] arr = new int[n+1];\\n        for (int i=0; i<n; i++) {\\n            if (citations[i]>=n) arr[n]++;\\n            else arr[citations[i]]++;\\n        }\\n        for (int i=n; i>=0; i--) {\\n            tot += arr[i];\\n            if (tot>=i) return i;\\n        }\\n        return 0;\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public int hIndex(int[] citations) {\\n        int n = citations.length, tot=0;\\n        int[] arr = new int[n+1];\\n        for (int i=0; i<n; i++) {\\n            if (citations[i]>=n) arr[n]++;\\n            else arr[citations[i]]++;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 785570,
                "title": "java-100-no-sort-o-n-explanation",
                "content": "**If useful, please up-vote.**\\nThe citations[ ] array contains the number of citations for each paper.  The number of papers publish is citations.length.\\n\\nThis is actually a \"counting sort\", which simply counts the number of papers with x citations.  Some discussion entries call this a \"bucket sort\", but technically a counting sort is different in that a bucket sort saves all of the original data.  A counting sort throws out the original data, and only saves aggregate information.  Counting sorts are O(N).  I don\\'t really consider counting sorts to be real sorts, because the original data is lost.  I consider it more of a data analysis.\\n\\nThe h-index value cannot be higher than the total number of papers, so we only need the count sort to hold values from 0 to the number of papers (citations.length).  Papers with more citations than the number of papers, will be counted as though they had number-of-papers citations.\\n```\\nclass Solution {\\n    public int hIndex(int[] citations) {\\n        // Array to the contain the counts for number of papers \\n        // with x citations, where counts[x] will be the number of \\n        // papers with x citations.  Because the h value cannot be \\n        // larger than the number of papers, the last used count in \\n        // this array, count[citations.length], is a count of the \\n        // number of papers with citations.length or more citations.\\n        int[] counts = new int[citations.length + 2];\\n        \\n        // Build the counts of how many papers have x citations.  \\n        // If a paper has more than citations.length citations, then \\n        // count it as citations.length citations.\\n        for (int i = citations.length - 1; i >= 0; i--)  \\n            counts[Math.min(citations[i], citations.length)]++;\\n        \\n        // Go through the count[] array from last index down to 0, trying \\n        // successively smaller values for h.  Looping from high to low \\n        // possible values for h, will find the highest valid value for \\n        // h.  While descending through the count array, add the count \\n        // from the next higher index in the count array, which will \\n        // convert the current counts[h] value to become a count of \\n        // papers with h or more citations.  This is slightly confusing \\n        // because h is used as both an index and a value to compare to \\n        // the array value at that index.  The \"units\" for h feel \\n        // inconsistent.\\n        int h;\\n        for (h = citations.length; h > 0; h--) {\\n            counts[h] += counts[h + 1];\\n            if (counts[h] >= h)  break;\\n        }\\n        return h;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int hIndex(int[] citations) {\\n        // Array to the contain the counts for number of papers \\n        // with x citations, where counts[x] will be the number of \\n        // papers with x citations.  Because the h value cannot be \\n        // larger than the number of papers, the last used count in \\n        // this array, count[citations.length], is a count of the \\n        // number of papers with citations.length or more citations.\\n        int[] counts = new int[citations.length + 2];\\n        \\n        // Build the counts of how many papers have x citations.  \\n        // If a paper has more than citations.length citations, then \\n        // count it as citations.length citations.\\n        for (int i = citations.length - 1; i >= 0; i--)  \\n            counts[Math.min(citations[i], citations.length)]++;\\n        \\n        // Go through the count[] array from last index down to 0, trying \\n        // successively smaller values for h.  Looping from high to low \\n        // possible values for h, will find the highest valid value for \\n        // h.  While descending through the count array, add the count \\n        // from the next higher index in the count array, which will \\n        // convert the current counts[h] value to become a count of \\n        // papers with h or more citations.  This is slightly confusing \\n        // because h is used as both an index and a value to compare to \\n        // the array value at that index.  The \"units\" for h feel \\n        // inconsistent.\\n        int h;\\n        for (h = citations.length; h > 0; h--) {\\n            counts[h] += counts[h + 1];\\n            if (counts[h] >= h)  break;\\n        }\\n        return h;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 70918,
                "title": "my-easy-solution",
                "content": "     public int hIndex(int[] citations) {\\n       Arrays.sort(citations);\\n       int len=citations.length;\\n        for(int i=0;i<len;i++){\\n            if(citations[i]>=len-i) return len-i;\\n            \\n        }\\n        return 0;\\n    }",
                "solutionTags": [],
                "code": "     public int hIndex(int[] citations) {\\n       Arrays.sort(citations);\\n       int len=citations.length;\\n        for(int i=0;i<len;i++){\\n            if(citations[i]>=len-i) return len-i;\\n            \\n        }\\n        return 0;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 70894,
                "title": "o-n-time-c-solution-using-hash-table",
                "content": "class Solution {\\npublic:\\n\\n    int hIndex(vector<int>& citations) {\\n        if(citations.empty())\\n            return 0;\\n        int n = citations.size();\\n        vector<int> hash(n + 1, 0);\\n        for(int i = 0; i < n; ++i){\\n            if(citations[i] >= n)\\n                hash[n]++;\\n            else\\n                hash[citations[i]]++;\\n        }\\n        int paper = 0;\\n        for(int i = n; i >= 0; --i){\\n            paper += hash[i];\\n            if(paper >= i)\\n                return i;\\n        }\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n\\n    int hIndex(vector<int>& citations) {\\n        if(citations.empty())\\n            return 0;\\n        int n = citations.size();\\n        vector<int> hash(n + 1, 0);\\n        for(int i = 0; i < n; ++i){\\n            if(citations[i] >= n)\\n                hash[n]++;\\n            else\\n                hash[citations[i]]++;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 70897,
                "title": "python-o-n-lgn-time-with-sort-o-n-time-with-o-n-space",
                "content": "Sort\\n\\n    def hIndex(self, citations):\\n        citations.sort()\\n        n = len(citations)\\n        for i in xrange(n):\\n            if citations[i] >= (n-i):\\n                return n-i\\n        return 0\\n\\n\\nO(n) space, O(n) time\\n\\n    def hIndex(self, citations):\\n        n = len(citations)\\n        citeCount = [0] * (n+1)\\n        for c in citations:\\n            if c >= n:\\n                citeCount[n] += 1\\n            else:\\n                citeCount[c] += 1\\n        \\n        i = n-1\\n        while i >= 0:\\n            citeCount[i] += citeCount[i+1]\\n            if citeCount[i+1] >= i+1:\\n                return i+1\\n            i -= 1\\n        return 0",
                "solutionTags": [],
                "code": "Sort\\n\\n    def hIndex(self, citations):\\n        citations.sort()\\n        n = len(citations)\\n        for i in xrange(n):\\n            if citations[i] >= (n-i):\\n                return n-i\\n        return 0\\n\\n\\nO(n) space, O(n) time\\n\\n    def hIndex(self, citations):\\n        n = len(citations)\\n        citeCount = [0] * (n+1)\\n        for c in citations:\\n            if c >= n:\\n                citeCount[n] += 1\\n            else:\\n                citeCount[c] += 1\\n        \\n        i = n-1\\n        while i >= 0:\\n            citeCount[i] += citeCount[i+1]\\n            if citeCount[i+1] >= i+1:\\n                return i+1\\n            i -= 1\\n        return 0",
                "codeTag": "Python3"
            },
            {
                "id": 785444,
                "title": "c-clean-and-simple-binary-search-based-solution-explained-92-time-80-space",
                "content": "So, in order to meet the requirement of this problem, we need to find a way to meet the `N - h` condition described in the specs, and for the maximum possible value.\\n\\nWell, that seems to me like a good use case of binary search and, since the problem boils down to this, I would not even bother to use the built-in C++ functions for that (`lower_bound` or, rather. `upper_bound`, but it really depends on how you play with them here).\\n\\nAlso, it is rather likely that in an interview you will be asked to avoid them and write your own logic, so I see no reason not to practice it here, not to mention that with the built in solutions you would have needed another vector to also store the respective index of each element (not sure you can otherwise access them, but correct me if I am wrong).\\n\\nFirst of all I will need 3 support variables to store the coordinates of my current start (`s`), end (`e`) and average (`avg`), respectively, and (have to) sort my array for the BS (I mean Binary Search!) to work.\\n\\nThen I will move on with it as long as my current start is `<=` current my end; if the condition is met (`c[avg = (e + s) / 2] < c.size() - avg`), then we move right (ie: towards higher values, since we sorted) updating `s`, otherwise we move left, updating `e` (ie: to lower values).\\n\\nOnce we have found our ideal value, we returrn `c.size - s` and we are done :)\\n\\nThe code:\\n\\n```cpp\\nclass Solution {\\npublic:\\n    int hIndex(vector<int>& c) {\\n        // 3 support variables for us\\n        int s = 0, e = c.size() - 1, avg;\\n        // the base of every happy binary search ever: having a sorted dataset\\n        sort(begin(c), end(c));\\n        // some good old binary search here to find the maximum element meeting the conditions\\n        while (s <= e) {\\n            if (c[avg = (e + s) / 2] < c.size() - avg) s = avg + 1;\\n            else e = avg - 1;\\n        }\\n        return c.size() - s;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Binary Search",
                    "Binary Tree"
                ],
                "code": "```cpp\\nclass Solution {\\npublic:\\n    int hIndex(vector<int>& c) {\\n        // 3 support variables for us\\n        int s = 0, e = c.size() - 1, avg;\\n        // the base of every happy binary search ever: having a sorted dataset\\n        sort(begin(c), end(c));\\n        // some good old binary search here to find the maximum element meeting the conditions\\n        while (s <= e) {\\n            if (c[avg = (e + s) / 2] < c.size() - avg) s = avg + 1;\\n            else e = avg - 1;\\n        }\\n        return c.size() - s;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 656820,
                "title": "python-short-o-n-time-space-explained",
                "content": "### Explanations\\nThe main trick is to count for each possible number of citations, how many times we see this number in our `citations`. Note, that if number of citations is more than total number of papers `N`, we can reduce this numer to `N` and nothing will change. Let me explain my solutoin given test example `[3,0,6,1,5]`.\\n1. We create array, which I called `buckets = [1, 1, 0, 1, 0, 2]`, where `buckets[i]` is number of papers with `i` citations if `i < N` and `bucket[N]` is number of papers with `>=N` citations.\\n2. Now, we create `accum` array, where `accum[0]` is number of papers with `>=1` citation, `accum[1]` is number of papers with `>=2` citations and so on. When we evaluate it for our example we can see, that it is equal to `accum = [4,3,3,2,2]`. Note, that we start with 1 citation, not with zero, that is why we need to use `accum[1:]` in our code.\\n3. Finally, we need to go through this array and find the bigest number `i`, for which `accum[i] >= i + 1` and return `i + 1`, in our example it is equal to `3`.\\n\\n### Complexity\\nComplexity is O(n), though we traverse our data 4 times, and it is not the optimal solution. We can evaluate cumulative sums in place, and compare them in place with `i + 1` and keep the index of maximum reached so far, and interrupt when inequality `accum[i] >= i + 1` does not hold anymore. Howerer I like cumulative sums and code is more clean in my way.\\n\\n### Code\\n\\n```\\nclass Solution:\\n    def hIndex(self, citations):\\n        N = len(citations)\\n        buckets = [0] * (N + 1)\\n        \\n        for elem in citations:\\n            buckets[min(elem, N)] += 1\\n        \\n        accum = list(accumulate(buckets[1:][::-1]))[::-1]  \\n        compar = [accum[i] >= i + 1 for i in range(N)]  \\n        return (compar + [0]).index(0)      \\n```\\n\\nIf you have any questoins, feel free to ask. If you like the solution and explanation, please **upvote**!",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def hIndex(self, citations):\\n        N = len(citations)\\n        buckets = [0] * (N + 1)\\n        \\n        for elem in citations:\\n            buckets[min(elem, N)] += 1\\n        \\n        accum = list(accumulate(buckets[1:][::-1]))[::-1]  \\n        compar = [accum[i] >= i + 1 for i in range(N)]  \\n        return (compar + [0]).index(0)      \\n```",
                "codeTag": "Java"
            },
            {
                "id": 70808,
                "title": "simple-java-solution-with-sort",
                "content": "    public class Solution {\\n        public int hIndex(int[] citations) {\\n            if (citations == null || citations.length == 0) return 0;\\n            Arrays.sort(citations);\\n            int len = citations.length;\\n            for (int i = 0; i < citations.length; i++) {\\n                if (len <= citations[i])\\n                    return len;\\n                else\\n                    len--;\\n            }\\n            return len;\\n        }\\n    }",
                "solutionTags": [],
                "code": "class Solution {\\n        public int hIndex(int[] citations) {\\n            if (citations == null || citations.length == 0) return 0;\\n            Arrays.sort(citations);\\n            int len = citations.length;\\n            for (int i = 0; i < citations.length; i++) {\\n                if (len <= citations[i])\\n                    return len;\\n                else\\n                    len--;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 786227,
                "title": "h-index-all-you-need-is-an-explanation",
                "content": "I found the definition of *h*-index really confusing. Luckily, I looked up the [Wikipedia page of *h*-index](http://https://en.wikipedia.org/wiki/H-index) which makes its calculation crystal clear.\\nIt states that,\\n>First we order the values of f from the largest to the lowest value. Then, we look for the last position in which f is greater than or equal to the position (we call h this position). For example, if we have a researcher with 5 publications A, B, C, D, and E with 10, 8, 5, 4, and 3 citations, respectively, the h-index is equal to 4 because the 4th publication has 4 citations and the 5th has only 3. In contrast, if the same publications have 25, 8, 5, 3, and 3 citations, then the index is 3 (i.e. the 3rd position) because the fourth paper has only 3 citations.\\n>\\n>    ```\\n>    f(A)=10, f(B)=8, f(C)=5, f(D)=4, f(E)=3\\u3000\\u2192 h-index=4\\n>    f(A)=25, f(B)=8, f(C)=5, f(D)=3, f(E)=3\\u3000\\u2192 h-index=3\\n\\nCode:\\n```\\nclass Solution {\\npublic:\\n    int hIndex(vector<int>& citations) {\\n        int ans = 0;\\n        sort(citations.begin(), citations.end(), greater<int>());\\n        for (int i = 1; i <= citations.size(); i++) {\\n            if (citations[i-1] < i) break;\\n            ans = i;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n>    f(A)=10, f(B)=8, f(C)=5, f(D)=4, f(E)=3\\u3000\\u2192 h-index=4\\n>    f(A)=25, f(B)=8, f(C)=5, f(D)=3, f(E)=3\\u3000\\u2192 h-index=3\\n\\nCode:\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 71008,
                "title": "o-n-java-solution-using-o-n-space",
                "content": "Explanation: The idea is to use another array, index is the citation and value is the number of papers that has at least the citation. Since the h-index can only be n, the new array will only need the index to be at most n, thus the array size will only need n+1. Papers that have more than n citations will store in array[n].\\nGo through the array based on h index definition: array[i]>=i, find the max value of i.\\n\\n\\n    public class Solution {\\n    public int hIndex(int[] citations) {\\n        if(citations == null || citations.length == 0) return 0;\\n        \\n        int n = citations.length;\\n        int[] num = new int[n+1];\\n        \\n        for(int i=0; i<n; i++) {\\n            if(citations[i]>n) num[n]++;\\n            else num[citations[i]]++;\\n        }\\n        \\n        if(num[n]>=n) return n;\\n        for(int i=n-1; i>=0; i--) {\\n            num[i] += num[i+1];\\n            if(num[i]>=i) return i;\\n        }\\n        return 0;\\n    }\\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    public int hIndex(int[] citations) {\\n        if(citations == null || citations.length == 0) return 0;\\n        \\n        int n = citations.length;\\n        int[] num = new int[n+1];\\n        \\n        for(int i=0; i<n; i++) {\\n            if(citations[i]>n) num[n]++;\\n            else num[citations[i]]++;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 3822262,
                "title": "binary-search-easy-explanation-short-code",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nMaximum h-index possible is n and minimum possible is 0.\\nso we have a range of 0-n to apply **Binary Search**\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nCalculate the count of paper greater than mid.\\nNow if count is greater than we increase h-index =>i=mid\\n\\n\\n\\n# Complexity\\n- Time complexity:O(NlogN)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```C++ []\\nclass Solution {\\npublic:\\n    int hIndex(vector<int>& c) {\\n        int low=0 , high = c.size();\\n        while(low < high){\\n            int mid = (low+high+1)/2;\\n            int cnt=0;\\n            for(int i=0 ; i<c.size() ; i++) if(c[i] >= mid) cnt++;\\n            if(cnt >= mid) low = mid;\\n            else high = mid-1;\\n        }\\n        return low;\\n    }\\n};\\n```\\n```Java []\\nclass Solution {\\n    public int hIndex(int[] c) {\\n        int low=0 , high = c.length;\\n        while(low < high){\\n            int mid = (low+high+1)/2;\\n            int cnt=0;\\n            for(int i=0 ; i<c.length ; i++) if(c[i] >= mid) cnt++;\\n            if(cnt >= mid) low = mid;\\n            else high = high=mid-1;\\n        }\\n        return low;\\n    }\\n}\\n```\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Binary Search"
                ],
                "code": "```C++ []\\nclass Solution {\\npublic:\\n    int hIndex(vector<int>& c) {\\n        int low=0 , high = c.size();\\n        while(low < high){\\n            int mid = (low+high+1)/2;\\n            int cnt=0;\\n            for(int i=0 ; i<c.size() ; i++) if(c[i] >= mid) cnt++;\\n            if(cnt >= mid) low = mid;\\n            else high = mid-1;\\n        }\\n        return low;\\n    }\\n};\\n```\n```Java []\\nclass Solution {\\n    public int hIndex(int[] c) {\\n        int low=0 , high = c.length;\\n        while(low < high){\\n            int mid = (low+high+1)/2;\\n            int cnt=0;\\n            for(int i=0 ; i<c.length ; i++) if(c[i] >= mid) cnt++;\\n            if(cnt >= mid) low = mid;\\n            else high = high=mid-1;\\n        }\\n        return low;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 70927,
                "title": "better-solution-than-hint-no-extra-space",
                "content": "Have a better solution without extra space. \\nUsing in place divide (not sort) and the time in normal case is n + n/2 + n/4 + ... ~= 2n = O(n). \\nIn worst case is: O(n^2), but just like quicksort, in most cases, it's a better solution.\\nIt beats 100% submits at least in my desktop.\\n\\nHere is the code:\\n\\n    public int hIndex(int[] citations) \\n    {\\n        int length = citations.length;\\n        int start = 0;\\n        int end = length - 1;\\n        int hIndex = 0;\\n        \\n        while (start <= end)\\n        {\\n            int current = divideByPartition(citations, start, end);\\n            if (length - current <= citations[current])\\n            {\\n                hIndex = length - current;\\n                end = current - 1;\\n            }\\n            else\\n                start = current + 1;\\n        }\\n        \\n        return hIndex;\\n    }\\n\\n     // divide the array by the last item and return the new index of this partition item.\\n    private int divideByPartition(int[] a, int start, int end)\\n    {\\n        if (start == end) return end;\\n        \\n        int p = a[end];\\n        int head = start;\\n        for (int current = start; current < end; current++)\\n        {\\n            if (a[current] < p)\\n            {\\n                int temp = a[head];\\n                a[head] = a[current];\\n                a[current] = temp;\\n                head++;\\n            }\\n        }\\n        a[end] = a[head];\\n        a[head] = p;\\n        return head;\\n    }",
                "solutionTags": [],
                "code": "Have a better solution without extra space. \\nUsing in place divide (not sort) and the time in normal case is n + n/2 + n/4 + ... ~= 2n = O(n). \\nIn worst case is: O(n^2), but just like quicksort, in most cases, it's a better solution.\\nIt beats 100% submits at least in my desktop.\\n\\nHere is the code:\\n\\n    public int hIndex(int[] citations) \\n    {\\n        int length = citations.length;\\n        int start = 0;\\n        int end = length - 1;\\n        int hIndex = 0;\\n        \\n        while (start <= end)\\n        {\\n            int current = divideByPartition(citations, start, end);\\n            if (length - current <= citations[current])\\n            {\\n                hIndex = length - current;\\n                end = current - 1;\\n            }\\n            else\\n                start = current + 1;\\n        }\\n        \\n        return hIndex;\\n    }\\n\\n     // divide the array by the last item and return the new index of this partition item.\\n    private int divideByPartition(int[] a, int start, int end)\\n    {\\n        if (start == end) return end;\\n        \\n        int p = a[end];\\n        int head = start;\\n        for (int current = start; current < end; current++)\\n        {\\n            if (a[current] < p)\\n            {\\n                int temp = a[head];\\n                a[head] = a[current];\\n                a[current] = temp;\\n                head++;\\n            }\\n        }\\n        a[end] = a[head];\\n        a[head] = p;\\n        return head;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 3602383,
                "title": "explained-simple-and-clear-python3-code",
                "content": "# Intuition\\nThe problem asks for the h-index of a researcher based on the number of citations received for their papers. The h-index is the maximum value of h such that the researcher has published at least h papers that have each been cited at least h times. To find the h-index, we need to sort the array of citations in descending order and identify the largest h-value that satisfies the given condition.\\n\\n\\n# Approach\\nThe solution begins by sorting the array of citations in reverse order, ensuring that the papers with the highest citation counts are at the beginning. Next, several conditions are checked to determine the h-index. First, if the array contains only one element and it is greater than zero, the h-index is 1. If the smallest value in the sorted array is greater than or equal to the length of the array, the h-index is equal to the array length. Otherwise, the array is traversed, and for each index i, the value at that index is compared to i+1. If the value is less than i+1, i is returned as the h-index. If none of the conditions are met, the h-index is 0.\\n\\n\\n# Complexity\\n- Time complexity:\\nThe time complexity of the solution primarily depends on the sorting operation, which has a time complexity of O(n log n), where n is the length of the input array. The subsequent iterations through the array and the condition checks have a linear time complexity of O(n). Therefore, the overall time complexity is O(n log n).\\n\\n\\n- Space complexity:\\nThe solution has a space complexity of O(1) since it only uses a constant amount of extra space to store variables and does not depend on the input size. No additional data structures are employed, and the sorting operation is performed in-place.\\n\\n# Code\\n```\\nclass Solution:\\n    def hIndex(self, c: List[int]) -> int:\\n        c.sort(reverse=True)\\n        if len(c)==1 and c[0]>0:\\n            return 1\\n        if c[-1]>=len(c):\\n            return len(c)\\n        for i in range(len(c)):\\n            if c[i]<i+1:\\n                return i\\n        return 0\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def hIndex(self, c: List[int]) -> int:\\n        c.sort(reverse=True)\\n        if len(c)==1 and c[0]>0:\\n            return 1\\n        if c[-1]>=len(c):\\n            return len(c)\\n        for i in range(len(c)):\\n            if c[i]<i+1:\\n                return i\\n        return 0\\n```",
                "codeTag": "Java"
            },
            {
                "id": 70946,
                "title": "ac-python-40-ms-solution-o-n-time-o-n-space-using-counting-sort",
                "content": "    def hIndex(self, citations):\\n        n = len(citations)\\n        papers = [0] * (n + 1)  # papers[i] is the number of papers with i citations.\\n        for c in citations:\\n            papers[min(n, c)] += 1  # All papers with citations larger than n is count as n.\\n        i = n\\n        s = papers[n]  # sum of papers with citations >= i\\n        while i > s:\\n            i -= 1\\n            s += papers[i]\\n        return i\\n\\n\\n    # 81 / 81 test cases passed.\\n    # Status: Accepted\\n    # Runtime: 40 ms\\n    # 97.08%\\n\\nThe question is quite simple if the citations are sorted. Which means we need some kind of \"sorting\". The observation h index is limited by both citation and paper count gives us the idea of counting/bucket sort. We can consider any paper with citations larger than n as citation == n. This way we can sort the citations in O(n) time with O(n) space. The rest is trivial.",
                "solutionTags": [
                    "Python",
                    "Counting Sort"
                ],
                "code": "    def hIndex(self, citations):\\n        n = len(citations)\\n        papers = [0] * (n + 1)  # papers[i] is the number of papers with i citations.\\n        for c in citations:\\n            papers[min(n, c)] += 1  # All papers with citations larger than n is count as n.\\n        i = n\\n        s = papers[n]  # sum of papers with citations >= i\\n        while i > s:\\n            i -= 1\\n            s += papers[i]\\n        return i\\n\\n\\n    # 81 / 81 test cases passed.\\n    # Status: Accepted\\n    # Runtime: 40 ms\\n    # 97.08%\\n\\nThe question is quite simple if the citations are sorted. Which means we need some kind of \"sorting\". The observation h index is limited by both citation and paper count gives us the idea of counting/bucket sort. We can consider any paper with citations larger than n as citation == n. This way we can sort the citations in O(n) time with O(n) space. The rest is trivial.",
                "codeTag": "Python3"
            },
            {
                "id": 70772,
                "title": "according-to-the-definition-of-h-index-in-wiki-it-is-simple",
                "content": "    static bool comp(int left, int right){return left>right;}\\n    int hIndex(vector<int>& citations) {\\n        if(citations.size()==0) return 0;\\n        sort(citations.begin(),citations.end(),comp);\\n        for(size_t i=0;i<citations.size();++i){\\n            if(citations[i]<i+1) return i;\\n        }\\n        return citations.size();\\n    }\\n\\nFrom wiki: Formally, if f is the function that corresponds to the number of citations for each publication, we compute the h index as follows. First we order the values of f from the largest to the lowest value. Then, we look for the last position in which f is greater than or equal to the position (we call h this position).",
                "solutionTags": [
                    "Math"
                ],
                "code": "    static bool comp(int left, int right){return left>right;}\\n    int hIndex(vector<int>& citations) {\\n        if(citations.size()==0) return 0;\\n        sort(citations.begin(),citations.end(),comp);\\n        for(size_t i=0;i<citations.size();++i){\\n            if(citations[i]<i+1) return i;\\n        }\\n        return citations.size();\\n    }\\n\\nFrom wiki: Formally, if f is the function that corresponds to the number of citations for each publication, we compute the h index as follows. First we order the values of f from the largest to the lowest value. Then, we look for the last position in which f is greater than or equal to the position (we call h this position).",
                "codeTag": "Unknown"
            },
            {
                "id": 71060,
                "title": "o-nlogn-12ms-solution",
                "content": "    class Solution {\\n    public:\\n        int hIndex(vector<int>& citations) {\\n            if(citations.empty())\\n                return 0;\\n            sort(citations.begin(), citations.end());\\n            int n=citations.size();\\n            int i=0;\\n            while(i<n && citations[i]<(n-i)) i++;\\n            return n-i;\\n        }\\n    };",
                "solutionTags": [
                    "C++"
                ],
                "code": "class Solution {\\n    public:\\n        int hIndex(vector<int>& citations) {\\n            if(citations.empty())\\n                return 0;\\n            sort(citations.begin(), citations.end());\\n            int n=citations.size();\\n            int i=0;\\n            while(i<n && citations[i]<(n-i)) i++;\\n            return n-i;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 694842,
                "title": "python-sol-by-sorting-w-comment",
                "content": "Python sol by sorting.\\n\\n\\n---\\n\\n**Implementation** by sorting:\\n\\n```\\nclass Solution:\\n    def hIndex(self, citations: List[int]) -> int:\\n        \\n        citations.sort( reverse = True )\\n        \\n        for idx, citation in enumerate(citations):\\n\\n            # find the first index where citation is smaller than or equal to array index            \\n            if idx >= citation:\\n                return idx\\n        \\n        return len(citations)\\n```\\n\\n---\\n\\nReference:\\n\\n[1] [Python official docs about sorting](https://docs.python.org/3/library/stdtypes.html#list.sort)",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Sorting"
                ],
                "code": "```\\nclass Solution:\\n    def hIndex(self, citations: List[int]) -> int:\\n        \\n        citations.sort( reverse = True )\\n        \\n        for idx, citation in enumerate(citations):\\n\\n            # find the first index where citation is smaller than or equal to array index            \\n            if idx >= citation:\\n                return idx\\n        \\n        return len(citations)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 70990,
                "title": "java-ac-solution-by-binary-search",
                "content": "Suppose the citations is sorted, binary search could be used to solve this problem; at each check point, say k, and its value is v; we could check whether there are not more than v citations behind it, by comparing v and n - k; and after processing, the pointer j will be at the index which is just invalid; so the final answer is n - j - 1;\\n\\nthe code may be more clear to understand:\\n\\n    public int hIndex(int[] citations) {\\n        Arrays.sort(citations);\\n\\n        int n = citations.length;\\n        int i = 0, j = n - 1;\\n\\n        while (i <= j) {\\n            int k = (i + j) / 2;\\n            int v = citations[k];\\n            int h = n - k;\\n            if (v >= h) {\\n                j = k - 1;\\n            } else {\\n                i = k + 1;\\n            }\\n        }\\n\\n        return n - j - 1;\\n    }\\n\\nit takes O(nlogn) to sort, O(logn) to binary search;",
                "solutionTags": [
                    "Java",
                    "Binary Tree"
                ],
                "code": "Suppose the citations is sorted, binary search could be used to solve this problem; at each check point, say k, and its value is v; we could check whether there are not more than v citations behind it, by comparing v and n - k; and after processing, the pointer j will be at the index which is just invalid; so the final answer is n - j - 1;\\n\\nthe code may be more clear to understand:\\n\\n    public int hIndex(int[] citations) {\\n        Arrays.sort(citations);\\n\\n        int n = citations.length;\\n        int i = 0, j = n - 1;\\n\\n        while (i <= j) {\\n            int k = (i + j) / 2;\\n            int v = citations[k];\\n            int h = n - k;\\n            if (v >= h) {\\n                j = k - 1;\\n            } else {\\n                i = k + 1;\\n            }\\n        }\\n\\n        return n - j - 1;\\n    }\\n\\nit takes O(nlogn) to sort, O(logn) to binary search;",
                "codeTag": "Unknown"
            },
            {
                "id": 3842150,
                "title": "c-very-easy-and-intuitive-approach-in-o-nlogn-time-and-o-1-space-beats-100-of-users",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nIts all about finding the sweet spot!\\n->you have to find maximum number of `h` papers who have got citations more than equal to `h` times.\\n->you can do this by`sorting` the citations array, and decrementing the value of `h`(initially equal to the size of array) one by one in each step then finding and returning the very first sweet spot that you encountered \\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n- Step 1: Sort the citations vector in ascending order\\n- Step 2: Initialize a variable \\'h\\' to store the starting h-index value, which is equal to the size of the citations vector\\n- Step 3: Loop through the citations vector using a for loop\\n- Step 4: Check if the current citation count (citations[i]) is greater than or equal to the current h-index value (h)\\n- Step 5: If true, return the current h-index value as it represents the maximum h-index\\n- Step 6: If the current citation count is smaller than the current h-index value,\\ndecrease the h-index value by 1 to check the next lower h-index\\nNote: If h == 1, it means the lowest possible h-index is 1, and if there\\'s any citation count greater than 0, then the h-index is 1.\\n\\n- Step 7: If the loop completes without finding the h-index, it means h = 0, indicating that there are no citations meeting the h-index criteria.\\nIn this case, return h (which is 0).\\n\\n`I have also Commented step-by-step in the code for better understanding.`\\n\\n# Complexity\\n- Time complexity:O(nlogn)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int hIndex(vector<int>& citations) {\\n        // Step 1\\n        sort(citations.begin(), citations.end());\\n        // Step 2\\n        int h = citations.size();\\n        // Step 3\\n        for (int i = 0; i < citations.size(); i++) {\\n            // Step 4\\n            if (citations[i] >= h) {\\n                // Step 5:\\n                return h;\\n            } \\n            else {\\n                // Step 6: \\n                if (h == 1 && citations[i] != 0)\\n                    return 1;\\n                h--;\\n            }\\n        }\\n        return h;\\n    }\\n};\\n\\n```\\n# visual explanation\\n##### 1st test case simulated:\\n![image.png](https://assets.leetcode.com/users/images/9a198891-0a84-4bd7-93f5-285e23a1716c_1690794986.920532.png)\\n- here we can say that there are \\'3\\' papers who have got cited for more than equal to \\'3\\' times\\n- It can be possible for \\'2\\' and \\'1\\' also. but since \\'3\\' is the greatest it will return 3.\\n# Here you Go!\\n![WhatsApp Image 2023-07-30 at 23.55.32.jpg](https://assets.leetcode.com/users/images/54e80819-870f-40c9-8ef4-b341df5e70f6_1690741559.1301308.jpeg)",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int hIndex(vector<int>& citations) {\\n        // Step 1\\n        sort(citations.begin(), citations.end());\\n        // Step 2\\n        int h = citations.size();\\n        // Step 3\\n        for (int i = 0; i < citations.size(); i++) {\\n            // Step 4\\n            if (citations[i] >= h) {\\n                // Step 5:\\n                return h;\\n            } \\n            else {\\n                // Step 6: \\n                if (h == 1 && citations[i] != 0)\\n                    return 1;\\n                h--;\\n            }\\n        }\\n        return h;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2004209,
                "title": "c-0-ms-2-solutions-with-without-priority-queue-same-code-for-275-h-index-ii",
                "content": "//same solution for [275. H-Index II](https://leetcode.com/problems/h-index-ii/)\\n**WITH PRIORITY QUEUE**\\n\\n\\tclass Solution {\\n\\t\\tpublic:\\n\\t\\t\\tint hIndex(vector<int>& citations) {\\n\\t\\t\\t\\tint index;\\n\\t\\t\\t\\tpriority_queue<int> pq(begin(citations), end(citations));\\n\\n\\t\\t\\t\\tfor (index = 0; !pq.empty() && index < pq.top();index++)\\n\\t\\t\\t\\t\\tpq.pop();  \\n\\n\\t\\t\\t\\treturn index;\\n\\t\\t\\t}\\n\\t\\t};\\n\\t\\t\\n**WITHOUT PRIORITY QUEUE**\\n\\n\\t\\tclass Solution {\\n\\t\\tpublic:\\n\\t\\t\\tint hIndex(vector<int>& citations) {\\n\\t\\t\\t\\tint index;\\n\\t\\t\\t\\tsort(citations.begin(),citations.end(),greater<int>());\\n\\t\\t\\t\\tint n=citations.size();\\n\\t\\t\\t\\tfor (index = 0;index<n;index++){\\n\\t\\t\\t\\t\\tif(index>=citations[index])break;\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\treturn index;\\n\\t\\t\\t}\\n\\t\\t};\\n",
                "solutionTags": [
                    "C++",
                    "C",
                    "Sorting"
                ],
                "code": "class Solution {\\n\\t\\tpublic:\\n\\t\\t\\tint hIndex(vector<int>& citations) {\\n\\t\\t\\t\\tint index;\\n\\t\\t\\t\\tpriority_queue<int> pq(begin(citations), end(citations));\\n\\n\\t\\t\\t\\tfor (index = 0; !pq.empty() && index < pq.top();index++)\\n\\t\\t\\t\\t\\tpq.pop();  \\n\\n\\t\\t\\t\\treturn index;\\n\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 70823,
                "title": "o-n-time-o-1-space-solution",
                "content": "in order to reach O(N) time ,we need to sort array in O(N) time.\\nIn this problem, we can do that using counting sort.<br>However, counting sort requires extra O(N) space to do the trick, and as a result ,we will get the \"count\" for every element. <br>But in this problem, we only need the \"count\" information for element smaller than n <br>because h-index will be in range [0, n] <br>\\nSo we can get rid of elements bigger than n, then consider the array as a linkedlist  and do the counting sort right on itself <br>\\nHere is my implementation.\\n\\n    public int hIndex(int[] citations) {\\n        int c=0, num=0;\\n        \\n        for(int i=0;i<citations.length;i++){\\n            c = citations[i];\\n            if(c<0)continue;\\n            //-1 means that the count of number is 0\\n            //-2 means that the count of number is 1, and so forth\\n            citations[i] = -1;\\n            if(c<citations.length){\\n                //loop like a linkedlist\\n                while((num=citations[c])>-1){\\n                    citations[c] = -2;  \\n                    if(num>citations.length-1){\\n                        break;\\n                    }\\n                    c = num;\\n                }\\n                if(num<citations.length){\\n                    citations[c]--;\\n                }\\n            }\\n        }\\n        c = 0;\\n        for(int i=0;i<citations.length;i++){\\n            num = -citations[i]-1;  //occurrences of i\\n            if(num>0){\\n                if(i>=citations.length-(c+num-1)){\\n                    return i>=citations.length-c ? citations.length-c : i;\\n                }\\n                c += num;\\n            }\\n        }\\n        return citations.length-c;\\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "in order to reach O(N) time ,we need to sort array in O(N) time.\\nIn this problem, we can do that using counting sort.<br>However, counting sort requires extra O(N) space to do the trick, and as a result ,we will get the \"count\" for every element. <br>But in this problem, we only need the \"count\" information for element smaller than n <br>because h-index will be in range [0, n] <br>\\nSo we can get rid of elements bigger than n, then consider the array as a linkedlist  and do the counting sort right on itself <br>\\nHere is my implementation.\\n\\n    public int hIndex(int[] citations) {\\n        int c=0, num=0;\\n        \\n        for(int i=0;i<citations.length;i++){\\n            c = citations[i];\\n            if(c<0)continue;\\n            //-1 means that the count of number is 0\\n            //-2 means that the count of number is 1, and so forth\\n            citations[i] = -1;\\n            if(c<citations.length){\\n                //loop like a linkedlist\\n                while((num=citations[c])>-1){\\n                    citations[c] = -2;  \\n                    if(num>citations.length-1){\\n                        break;\\n                    }\\n                    c = num;\\n                }\\n                if(num<citations.length){\\n                    citations[c]--;\\n                }\\n            }\\n        }\\n        c = 0;\\n        for(int i=0;i<citations.length;i++){\\n            num = -citations[i]-1;  //occurrences of i\\n            if(num>0){\\n                if(i>=citations.length-(c+num-1)){\\n                    return i>=citations.length-c ? citations.length-c : i;\\n                }\\n                c += num;\\n            }\\n        }\\n        return citations.length-c;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 3235206,
                "title": "274-time-90-70-solution-with-step-by-step-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nTo compute the researcher\\'s h-index, we can sort the citations array in non-increasing order and then iterate through the sorted array. For each citation count, we compare it to the number of papers that have at least that many citations, which can be calculated as the remaining elements in the array. If the citation count is greater than or equal to the number of papers with at least that many citations, we have found the h-index.\\n\\nFor example, given the citations array [3,0,6,1,5], we can sort it to obtain [6,5,3,1,0]. We then iterate through the sorted array and for each citation count, we compare it to the number of remaining elements in the array. For the first element, 6, there are 5 remaining elements in the array, all of which have at least 6 citations, so the h-index is 6. For the second element, 5, there are 4 remaining elements in the array, all of which have at least 5 citations, so the h-index is 5. For the third element, 3, there are 3 remaining elements in the array that have at least 3 citations, so the h-index is 3.\\n\\nTime Complexity: O(nlogn), where n is the length of the citations array. This is because we need to sort the array in non-increasing order, which takes O(nlogn) time.\\n\\nSpace Complexity: O(1), as we are sorting the array in-place and using only constant extra space.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def hIndex(self, citations: List[int]) -> int:\\n        citations.sort(reverse=True) # Sort the array in non-increasing order\\n        n = len(citations)\\n        h = 0\\n        \\n        # Iterate through the sorted array and compare each citation count to the number of papers that have at least that many citations\\n        for i in range(n):\\n            if citations[i] >= i+1: # If the citation count is greater than or equal to the number of papers with at least that many citations, we have found the h-index\\n                h = i+1\\n        \\n        return h\\n\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Array",
                    "Sorting",
                    "Counting Sort"
                ],
                "code": "```\\nclass Solution:\\n    def hIndex(self, citations: List[int]) -> int:\\n        citations.sort(reverse=True) # Sort the array in non-increasing order\\n        n = len(citations)\\n        h = 0\\n        \\n        # Iterate through the sorted array and compare each citation count to the number of papers that have at least that many citations\\n        for i in range(n):\\n            if citations[i] >= i+1: # If the citation count is greater than or equal to the number of papers with at least that many citations, we have found the h-index\\n                h = i+1\\n        \\n        return h\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 70874,
                "title": "two-method-with-explaination",
                "content": "I use Java.\\n\\nThere are two basic methods. The easy approach is sorting. Since the 0 elements don't effect the result,\\nwe can eliminate them in advance. The idea is: If index + nums[index] is greater or equal to `length`, which means we have found the `max(min (f(i), i)) (i = 0 ~ length - 1)`.\\n\\n    *  nums  : 0  3  3  3  6  7  9 \\n    *  index : 0  1  2  3  4  5  6\\n    *  sum   : 0  4  5  6 10 12 13\\n                           \\u2191\\n                          stop\\n\\ne.g. We have to stop at `index = 4`, and `length - index = 3` is the result we want.\\nWe used sorting, so the time Complexity is `o(nlogn)`.\\n\\n\\n    public class Solution {\\n        public int hIndex(int[] citations) {\\n            if(citations == null || citations.length == 0)\\n                return 0;\\n            Arrays.sort(citations);\\n            int index = 0;\\n            while(citations[index] == 0){\\n                index++;\\n                if(index == citations.length)\\n                    break;\\n            }\\n            int i;\\n            for(i = index; i < citations.length; i++)\\n                if(citations[i] + i >= citations.length)\\n                    break;\\n            return citations.length - i;\\n        }\\n    }\\n\\nThe second method uses extra spaces for faster speed. We maintain a table counting the the appearance of the numbers.\\n\\n    *  nums  : 0  3  3  3  6  7  9 \\n\\n    * -----------------table---------------------\\n    *       n     : 0  1  2  3  4  5  6  >=7  (length = 7) \\n    * appearance  : 0  0  0  3  0  0  1   2\\n    * -------------------------------------------\\n\\nThen we sum up from the end of the appearance array, if `sum >= n`, which means we have enough numbers greater than or equal to `n`. Then return. The time complexity is o(n).\\n\\n    public class Solution {\\n        public int hIndex(int[] citations) {\\n            int size = citations.length;\\n            if(size == 0)\\n                return 0;\\n            int[] stats = new int[size + 1];\\n            for(int element : citations){\\n                if(element > size)\\n                    stats[size] += 1;\\n                else\\n                    stats[element] += 1;\\n            }\\n            int sum = 0;\\n            for(int i = size; i >= 0; i--){\\n                sum += stats[i];\\n                if(sum >= i)\\n                    return i;\\n            }\\n            return 0;\\n        }\\n    }\\nEnglish is not my native language, may beg your pardon if my English ever bothered you.",
                "solutionTags": [],
                "code": "class Solution {\\n        public int hIndex(int[] citations) {\\n            if(citations == null || citations.length == 0)\\n                return 0;\\n            Arrays.sort(citations);\\n            int index = 0;\\n            while(citations[index] == 0){\\n                index++;\\n                if(index == citations.length)\\n                    break;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 71018,
                "title": "java-o-n-log-n-time-o-1-space-with-explanation",
                "content": "Idea is we need to find if there exist a position in sorted array, that citation[i] >= citation.length - i.\\n\\nfor example:\\n\\n    2 5 6 9 10 12 15\\n    7 6 5 4 3  2  1   <=== reverse index, tells how many elements(inclusive) to the right.\\n\\nin order to find the h-index. we need to find if there exist a position that citation[i] >= reverse index.\\n\\n    So, like\\n    check elements 2 and after >= 7? --> No\\n    check elements 5 and after >= 6? --> No\\n    check elements 6 and after >= 5? --> Yes! This is the max \"h\" value, we return this 5.\\n\\n\\nCode:\\n\\n    public class Solution {\\n        public int hIndex(int[] citations) {\\n            if(citations == null || citations.length == 0)\\n                return 0;\\n                \\n            Arrays.sort(citations);\\n            for(int i = 0; i < citations.length; i++){\\n                if(citations[i] >= citations.length - i)\\n                    return citations.length - i;\\n            }\\n            return 0;\\n        }\\n    }\\n\\nTime Complexity O(n log n) + O(n) = O(n log n)\\nSpace Complexity O(1)",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n        public int hIndex(int[] citations) {\\n            if(citations == null || citations.length == 0)\\n                return 0;\\n                \\n            Arrays.sort(citations);\\n            for(int i = 0; i < citations.length; i++){\\n                if(citations[i] >= citations.length - i)\\n                    return citations.length - i;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 694000,
                "title": "simple-solution-with-priority-queue",
                "content": "```\\nclass Solution {\\npublic:\\n    int hIndex(vector<int>& citations) {\\n        int h;\\n        priority_queue<int> pq(begin(citations), end(citations));\\n        \\n        for (h = 0; !pq.empty() && h < pq.top(); ++h)\\n            pq.pop();  \\n\\n        return h;\\n    }\\n};\\n```\\n",
                "solutionTags": [
                    "C++",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int hIndex(vector<int>& citations) {\\n        int h;\\n        priority_queue<int> pq(begin(citations), end(citations));\\n        \\n        for (h = 0; !pq.empty() && h < pq.top(); ++h)\\n            pq.pop();  \\n\\n        return h;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 558876,
                "title": "c-min-heap",
                "content": "```cpp\\nint hIndex(vector<int>& cit) {\\n    priority_queue<int, vector<int>, greater<int>> pq(begin(cit), end(cit));\\n    while (!pq.empty() && pq.top() < pq.size())\\n        pq.pop();\\n    return pq.size();\\n}\\n```\\nAnd another without using extra memory:\\n```cpp\\nint hIndex(vector<int>& cit) {\\n    make_heap(begin(cit), end(cit), greater<int>());\\n    while(!cit.empty() && cit.front() < cit.size()) {\\n        pop_heap (cit.begin(), cit.end(), greater<int>()); \\n        cit.pop_back();\\n    }\\n    return cit.size();\\n}\\n```",
                "solutionTags": [],
                "code": "```cpp\\nint hIndex(vector<int>& cit) {\\n    priority_queue<int, vector<int>, greater<int>> pq(begin(cit), end(cit));\\n    while (!pq.empty() && pq.top() < pq.size())\\n        pq.pop();\\n    return pq.size();\\n}\\n```\n```cpp\\nint hIndex(vector<int>& cit) {\\n    make_heap(begin(cit), end(cit), greater<int>());\\n    while(!cit.empty() && cit.front() < cit.size()) {\\n        pop_heap (cit.begin(), cit.end(), greater<int>()); \\n        cit.pop_back();\\n    }\\n    return cit.size();\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3570805,
                "title": "easy-c-beats-100",
                "content": "\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nApproach is simple, sort the array first and Travers the array and apply this formula:-\\n\\n**if(left-elements <= arr[i])\\nrerurn left;**\\n\\nThis formula check that how many papers have citations greater then or equal to current paper.\\n\\n# Complexity\\n- Time complexity: O(N*Log(N))\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int hIndex(vector<int>& arr) {\\n\\n        int n = arr.size();\\n        sort(arr.begin(),arr.end());\\n        if(arr[0]>=n)  return n;\\n        if(n==1) return !(arr[0]==0);\\n        for(int i = 0;i<n;i++)\\n        {\\n           int left = n-i;\\n           if(arr[i] >= left) return left;\\n        }\\n        return 0;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int hIndex(vector<int>& arr) {\\n\\n        int n = arr.size();\\n        sort(arr.begin(),arr.end());\\n        if(arr[0]>=n)  return n;\\n        if(n==1) return !(arr[0]==0);\\n        for(int i = 0;i<n;i++)\\n        {\\n           int left = n-i;\\n           if(arr[i] >= left) return left;\\n        }\\n        return 0;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2604353,
                "title": "c-sort-4-lines",
                "content": "```\\nint hIndex(vector<int>& cit) {\\n        sort(cit.begin(),cit.end());\\n        int n=cit.size(),count=0;\\n        for(int i=n-1;i>=0;i--)\\n        {\\n            if(n-i<=cit[i])\\n                count++;\\n        }\\n        return count;\\n    }",
                "solutionTags": [],
                "code": "```\\nint hIndex(vector<int>& cit) {\\n        sort(cit.begin(),cit.end());\\n        int n=cit.size(),count=0;\\n        for(int i=n-1;i>=0;i--)\\n        {\\n            if(n-i<=cit[i])\\n                count++;\\n        }\\n        return count;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 785622,
                "title": "python-clean-simple-solution-faster-than-92",
                "content": "```\\nclass Solution:\\n    def hIndex(self, citations: List[int]) -> int:\\n        if len(citations) == 0:\\n            return 0\\n        \\n        res = 0\\n        citations.sort(reverse = True)\\n        \\n        if citations[-1] >= len(citations):\\n            return len(citations)\\n        \\n        for i in range(1, len(citations)+1):\\n            if i > citations[i-1]:\\n                res = i-1\\n                break\\n        return res\\n                \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def hIndex(self, citations: List[int]) -> int:\\n        if len(citations) == 0:\\n            return 0\\n        \\n        res = 0\\n        citations.sort(reverse = True)\\n        \\n        if citations[-1] >= len(citations):\\n            return len(citations)\\n        \\n        for i in range(1, len(citations)+1):\\n            if i > citations[i-1]:\\n                res = i-1\\n                break\\n        return res\\n                \\n```",
                "codeTag": "Java"
            },
            {
                "id": 785493,
                "title": "clean-c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int hIndex(vector<int>& citations) {\\n\\t\\t// Sorting it so that \\n        sort(citations.begin(), citations.end(), greater<int>());\\n\\t\\t// while going from left to right, H-index will increase and will be matched with the decreasing no. of citations for the paper\\n        for(int i = 0; i < citations.size(); i++)\\n\\t\\t// the index at which H-index (i in this case) becomes >= to no. of citations at [i], it means the H - index cannot be greater than current i \\n            if(i >= citations[i]) {\\n\\t\\t\\t\\t// return i due to 0 - based indexing\\n                return i;\\n            }\\n\\t\\t//  when smallest value citation is > the total no. of citations on the paper (i.e. its size)\\n        return citations.size();\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int hIndex(vector<int>& citations) {\\n\\t\\t// Sorting it so that \\n        sort(citations.begin(), citations.end(), greater<int>());\\n\\t\\t// while going from left to right, H-index will increase and will be matched with the decreasing no. of citations for the paper\\n        for(int i = 0; i < citations.size(); i++)\\n\\t\\t// the index at which H-index (i in this case) becomes >= to no. of citations at [i], it means the H - index cannot be greater than current i \\n            if(i >= citations[i]) {\\n\\t\\t\\t\\t// return i due to 0 - based indexing\\n                return i;\\n            }\\n\\t\\t//  when smallest value citation is > the total no. of citations on the paper (i.e. its size)\\n        return citations.size();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 71043,
                "title": "1-line-ruby-5-lines-c-6-lines-java",
                "content": "I saw [the picture](https://commons.wikimedia.org/wiki/File%3AH-index-en.svg) in the Wikipedia article and thought I'll just count the papers above the diagonal (first sort by decreasing citation number, then count the papers whose citation number is larger than their array index).\\n\\n---\\n\\n**Ruby**\\n\\n    def h_index(citations)\\n      citations.sort.reverse.each_with_index.count(&:>)\\n    end\\n\\n---\\n\\n**C++**\\n\\n    int hIndex(vector<int>& citations) {\\n        sort(citations.rbegin(), citations.rend());\\n        int h = 0, i = 0;\\n        for (int c : citations)\\n            h += c > i++;\\n        return h;\\n    }\\n\\n---\\n\\n**Java**\\n\\nSince Java doesn't let me sort in reverse order nicely, I sort in normal order and reverse the array indexes instead.\\n\\n    public int hIndex(int[] citations) {\\n        Arrays.sort(citations);\\n        int h = 0, i = citations.length;\\n        for (int c : citations)\\n            if (c > --i)\\n                ++h;\\n        return h;\\n    }",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Ruby"
                ],
                "code": "I saw [the picture](https://commons.wikimedia.org/wiki/File%3AH-index-en.svg) in the Wikipedia article and thought I'll just count the papers above the diagonal (first sort by decreasing citation number, then count the papers whose citation number is larger than their array index).\\n\\n---\\n\\n**Ruby**\\n\\n    def h_index(citations)\\n      citations.sort.reverse.each_with_index.count(&:>)\\n    end\\n\\n---\\n\\n**C++**\\n\\n    int hIndex(vector<int>& citations) {\\n        sort(citations.rbegin(), citations.rend());\\n        int h = 0, i = 0;\\n        for (int c : citations)\\n            h += c > i++;\\n        return h;\\n    }\\n\\n---\\n\\n**Java**\\n\\nSince Java doesn't let me sort in reverse order nicely, I sort in normal order and reverse the array indexes instead.\\n\\n    public int hIndex(int[] citations) {\\n        Arrays.sort(citations);\\n        int h = 0, i = citations.length;\\n        for (int c : citations)\\n            if (c > --i)\\n                ++h;\\n        return h;\\n    }",
                "codeTag": "Python3"
            },
            {
                "id": 3825543,
                "title": "100-faster-sufficient-intuition-binary-search-line-by-line-code-explained",
                "content": "# Intuition\\n\\n **100 % fast solution**\\uD83C\\uDFC6\\uD83C\\uDFC6\\n\\n![Screenshot 2023-07-28 001104.png](https://assets.leetcode.com/users/images/f2c1960a-04b2-436d-b781-e3799a9c5dcf_1690484829.7037516.png)\\n\\n**we require atleast m numbers of papers, which having greater or equal to m citations.**\\n\\neg. [ 3 , 2 , 5 , 1 , 7 , 4] in this array [5,7,4] these are the elements that we can select (because these 3 papers citations are >= 3). \\n\\nif we select [3,5,7,4] from input array then there should be atleast 4 elements(in this problem called research paper) which have to greater than or equal to 4 . but in above selected array 3 element is not greater than 4 . which is not valid for citation criteria\\n\\nSo , we can\\'t include 3. hence ans will be 3 which is [5 , 7, 4].\\n\\n\\n# Complexity\\n- Time complexity:\\n    O(n logn + logn) ---- sorting + searching   \\uD83C\\uDFC6\\n\\n- Space complexity:\\n  O(1)\\n\\n\\n    ***if you find this helpful Kindly upvote me***\\uD83C\\uDFC6\\uD83C\\uDFC6\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int hIndex(vector<int>& citations) {\\n      sort(citations.begin() , citations.end());\\n\\t\\t\\tint l = 0 , h = citations.size()-1;\\n\\t\\t\\tint n = citations.size();\\n\\t\\t\\tint ans = 0; // to store ans \\n\\t\\t\\twhile(l <= h){\\n\\t\\t\\t\\tint mid  = l +(h-l)/2;\\n\\t\\t\\t    int idx = n  - mid ; // index = total number of papers - mid(almost half)\\n\\t\\t\\t\\tif(citations[mid] >= idx){ \\n\\t\\t\\t\\t\\tans = idx;\\n\\t\\t\\t\\t\\th = mid-1; //we want to include more papers for citations(maximize ans )\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\telse{\\n\\t\\t\\t\\t\\tl = mid +1;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\treturn ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Binary Search",
                    "Sorting",
                    "Counting Sort"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int hIndex(vector<int>& citations) {\\n      sort(citations.begin() , citations.end());\\n\\t\\t\\tint l = 0 , h = citations.size()-1;\\n\\t\\t\\tint n = citations.size();\\n\\t\\t\\tint ans = 0; // to store ans \\n\\t\\t\\twhile(l <= h){\\n\\t\\t\\t\\tint mid  = l +(h-l)/2;\\n\\t\\t\\t    int idx = n  - mid ; // index = total number of papers - mid(almost half)\\n\\t\\t\\t\\tif(citations[mid] >= idx){ \\n\\t\\t\\t\\t\\tans = idx;\\n\\t\\t\\t\\t\\th = mid-1; //we want to include more papers for citations(maximize ans )\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\telse{\\n\\t\\t\\t\\t\\tl = mid +1;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\treturn ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3507840,
                "title": "c-easy-solution",
                "content": "# Code\\n```\\npublic class Solution {\\n    public int HIndex(int[] citations) {\\n        int res = 0;\\n        Array.Sort(citations);\\n\\n        for(int i = citations.Length -1; i>-1; i--)\\n        {\\n            if (res < citations[i])\\n            {\\n                res++;\\n            }\\n            else\\n            {\\n                return res;\\n            }\\n        }\\n        \\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution {\\n    public int HIndex(int[] citations) {\\n        int res = 0;\\n        Array.Sort(citations);\\n\\n        for(int i = citations.Length -1; i>-1; i--)\\n        {\\n            if (res < citations[i])\\n            {\\n                res++;\\n            }\\n            else\\n            {\\n                return res;\\n            }\\n        }\\n        \\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 786206,
                "title": "o-n-bucket-approach",
                "content": "This approach **does not involve sorting** of the array, which would result in the solution being nlog n. *Hence, the overall complexity of the solution would be **O(n)**.* \\nWe take a bucket array of size n + 1, where n being the size of the given array.\\n\\nThe idea is to store the frequency of elements of the input array. If however we get a value which is larger than the size of the array, that itself won\\'t be a candidate for h-index, so we store it at the last index value. Otherwise we just store those values at the index value. Here is an implementation.\\n\\n```\\nclass Solution:\\n    def hIndex(self, citations: List[int]) -> int:\\n        bucket = [0] * (len(citations) + 1)\\n        \\n        for i in range(len(citations)):\\n            if citations[i] > len(citations):\\n                bucket[len(citations)] += 1\\n            else:\\n                bucket[citations[i]] += 1\\n                \\n        count = 0\\n        for i in range(len(bucket) - 1, -1, -1):\\n            count += bucket[i]\\n            if count >= i:  #  If the value of count is greater than the index value then we return the index\\n                return i\\n        \\n        return 0  # If no such index is found then we simply return 0\\n```\\n\\nThe approach runs only twice, so the overall worst case scenario of the solution would be **O(n)**.",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def hIndex(self, citations: List[int]) -> int:\\n        bucket = [0] * (len(citations) + 1)\\n        \\n        for i in range(len(citations)):\\n            if citations[i] > len(citations):\\n                bucket[len(citations)] += 1\\n            else:\\n                bucket[citations[i]] += 1\\n                \\n        count = 0\\n        for i in range(len(bucket) - 1, -1, -1):\\n            count += bucket[i]\\n            if count >= i:  #  If the value of count is greater than the index value then we return the index\\n                return i\\n        \\n        return 0  # If no such index is found then we simply return 0\\n```",
                "codeTag": "Java"
            },
            {
                "id": 785586,
                "title": "python3-o-n-without-sorting",
                "content": "```\\nclass Solution:\\n    def hIndex(self, citations: List[int]) -> int:\\n        tmp = [0] * (len(citations) + 1)\\n\\t\\t\\n        for i in range(len(citations)):\\n            if citations[i] > len(citations):\\n                tmp[len(citations)] += 1\\n            else:\\n                tmp[citations[i]] += 1\\n\\n        sum_ = 0\\n        for i in range(len(tmp) - 1, -1, -1):\\n            sum_ += tmp[i]\\n            if sum_ >= i:\\n                return i\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def hIndex(self, citations: List[int]) -> int:\\n        tmp = [0] * (len(citations) + 1)\\n\\t\\t\\n        for i in range(len(citations)):\\n            if citations[i] > len(citations):\\n                tmp[len(citations)] += 1\\n            else:\\n                tmp[citations[i]] += 1\\n\\n        sum_ = 0\\n        for i in range(len(tmp) - 1, -1, -1):\\n            sum_ += tmp[i]\\n            if sum_ >= i:\\n                return i\\n```",
                "codeTag": "Java"
            },
            {
                "id": 70957,
                "title": "simple-java-o-n-time-o-n-space-solution",
                "content": "   \\nBasically we iterate the array for two rounds. In first round we count how many citation in each bucket and in the second round we traverse back to find the maximum h.\\n\\n\\n    \\n    //O(n) solution O(n) space\\n    public int hIndex(int[] citations) {\\n        \\n        if(citations == null)   return 0;\\n        int[] buffer = new int[citations.length+1];\\n        Arrays.fill(buffer, 0);\\n        \\n        for(int num : citations) {\\n            int idx = Math.min(num, citations.length);\\n            buffer[idx]++;\\n        }\\n        \\n        int sum = 0;\\n        for(int i = buffer.length -1 ; i >= 0 ; i--) {\\n            sum += buffer[i];\\n            if(sum >= i) return i;\\n        }\\n        \\n        return 0;\\n}",
                "solutionTags": [],
                "code": "   \\nBasically we iterate the array for two rounds. In first round we count how many citation in each bucket and in the second round we traverse back to find the maximum h.\\n\\n\\n    \\n    //O(n) solution O(n) space\\n    public int hIndex(int[] citations) {\\n        \\n        if(citations == null)   return 0;\\n        int[] buffer = new int[citations.length+1];\\n        Arrays.fill(buffer, 0);\\n        \\n        for(int num : citations) {\\n            int idx = Math.min(num, citations.length);\\n            buffer[idx]++;\\n        }\\n        \\n        int sum = 0;\\n        for(int i = buffer.length -1 ; i >= 0 ; i--) {\\n            sum += buffer[i];\\n            if(sum >= i) return i;\\n        }\\n        \\n        return 0;\\n}",
                "codeTag": "Unknown"
            },
            {
                "id": 70965,
                "title": "c-0-ms-o-n-solution",
                "content": "    int hIndex(int* citations, int citationsSize) {\\n        int i, j = 0, index = 0, *count = malloc(sizeof(int) * (citationsSize + 1));\\n        memset(count, 0, sizeof(int) * citationsSize);\\n        for (i = 0; i < citationsSize; ++i) {\\n            count[citations[i] > citationsSize ? citationsSize : citations[i]]++;\\n        }\\n        for (i = 0; i <= citationsSize; ++i) {\\n            if (citationsSize - j >= i) {\\n                index = i;\\n            }\\n            j += count[i];\\n        }\\n        free(count);\\n        return index;\\n    }",
                "solutionTags": [],
                "code": "    int hIndex(int* citations, int citationsSize) {\\n        int i, j = 0, index = 0, *count = malloc(sizeof(int) * (citationsSize + 1));\\n        memset(count, 0, sizeof(int) * citationsSize);\\n        for (i = 0; i < citationsSize; ++i) {\\n            count[citations[i] > citationsSize ? citationsSize : citations[i]]++;\\n        }\\n        for (i = 0; i <= citationsSize; ++i) {\\n            if (citationsSize - j >= i) {\\n                index = i;\\n            }\\n            j += count[i];\\n        }\\n        free(count);\\n        return index;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 3248866,
                "title": "solution-in-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int hIndex(vector<int>& c) \\n    { int ans=0;\\n        sort(c.begin(),c.end());\\n        for(int i=c.size()-1;i>=0;i--) {\\n            if(c[i]>=c.size()-i) {\\n                  ans++;\\n            }  \\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int hIndex(vector<int>& c) \\n    { int ans=0;\\n        sort(c.begin(),c.end());\\n        for(int i=c.size()-1;i>=0;i--) {\\n            if(c[i]>=c.size()-i) {\\n                  ans++;\\n            }  \\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3140725,
                "title": "c-simple-hash-map-solution",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int hIndex(vector<int>& citations) {\\n        unordered_map<int,int>m;\\n        for(int i=0;i<citations.size();i++){\\n            int count=citations[i];\\n            for(int i=0;i<=count;i++){\\n                m[i]++;\\n            }\\n        }\\n\\n        int ans=-1;\\n        for(auto it:m){\\n            int h=it.first;\\n            if(it.second>=h){\\n                ans=max(ans,h);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```\\nConsider Upvoting if it helped :)",
                "solutionTags": [
                    "C++",
                    "Hash Table"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int hIndex(vector<int>& citations) {\\n        unordered_map<int,int>m;\\n        for(int i=0;i<citations.size();i++){\\n            int count=citations[i];\\n            for(int i=0;i<=count;i++){\\n                m[i]++;\\n            }\\n        }\\n\\n        int ans=-1;\\n        for(auto it:m){\\n            int h=it.first;\\n            if(it.second>=h){\\n                ans=max(ans,h);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3086384,
                "title": "easy-python-solution-sorting",
                "content": "\\n# Code\\n```\\nclass Solution:\\n    def hIndex(self, citations: List[int]) -> int:\\n        citations.sort()\\n        citations=citations[::-1]\\n        for i in range(len(citations)):\\n            if citations[i]<=i:\\n                return i\\n        return len(citations)     \\n```",
                "solutionTags": [
                    "Python3",
                    "Sort",
                    "Sorting"
                ],
                "code": "```\\nclass Solution:\\n    def hIndex(self, citations: List[int]) -> int:\\n        citations.sort()\\n        citations=citations[::-1]\\n        for i in range(len(citations)):\\n            if citations[i]<=i:\\n                return i\\n        return len(citations)     \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1170888,
                "title": "javascript-two-easy-understand-solutions-brute-force-binary-search",
                "content": "**1. Brute Force**\\nRuntime: 76 ms, faster than 82.98% of JavaScript online submissions for H-Index.\\nMemory Usage: 38.5 MB, less than 84.04% of JavaScript online submissions for H-Index.\\n```\\nvar hIndex = function(citations) {\\n    citations.sort((a,b)=>b-a)\\n    for(i=0;i<citations.length;i++){\\n        if(citations[i]<i+1) return i\\n    }\\n    return i\\n};\\n```\\n**2. Binary Search**\\nRuntime: 76 ms, faster than 82.98% of JavaScript online submissions for H-Index.\\nMemory Usage: 38.4 MB, less than 94.68% of JavaScript online submissions for H-Index.\\n```\\nvar hIndex = function(citations) {\\n    let a = 0\\n    let b = citations.length-1\\n    citations.sort((a,b)=>b-a)\\n    while(a<=b){\\n        let mid = a+Math.floor((b-a)/2)       \\n        if(citations[mid]>mid) a = mid+1\\n        else b = mid-1  \\n    }\\n    return a\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar hIndex = function(citations) {\\n    citations.sort((a,b)=>b-a)\\n    for(i=0;i<citations.length;i++){\\n        if(citations[i]<i+1) return i\\n    }\\n    return i\\n};\\n```\n```\\nvar hIndex = function(citations) {\\n    let a = 0\\n    let b = citations.length-1\\n    citations.sort((a,b)=>b-a)\\n    while(a<=b){\\n        let mid = a+Math.floor((b-a)/2)       \\n        if(citations[mid]>mid) a = mid+1\\n        else b = mid-1  \\n    }\\n    return a\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 786170,
                "title": "java-0ms-confusing-problem-statement-simplified",
                "content": "The problem statement seemed a little confusing to me, here is my attempt at simplifying it.\\n\\nWe are given a list of publications of an author that have been cited, the citations obviously would be positive numbers. We are then asked to calculate a metric called the Hirsch Index for the citation count.\\n\\nWikipedia does a great job explaining what the H index is and how it is calculated. Here is an excerpt:\\n\\nFormally, if f is the function that corresponds to the number of citations for each publication, we compute the h-index as follows: First we order the values of f from the largest to the lowest value. Then, we look for the last position in which f is greater than or equal to the position (we call h this position). For example, if we have a researcher with 5 publications A, B, C, D, and E with 10, 8, 5, 4, and 3 citations, respectively, the h-index is equal to 4 because the 4th publication has 4 citations and the 5th has only 3. In contrast, if the same publications have 25, 8, 5, 3, and 3 citations, then the index is 3 (i.e. the 3rd position) because the fourth paper has only 3 citations.\\n\\n    f(A)=10, f(B)=8, f(C)=5, f(D)=4, f(E)=3\\u3000\\u2192 h-index=4\\n    f(A)=25, f(B)=8, f(C)=5, f(D)=3, f(E)=3\\u3000\\u2192 h-index=3\\n\\nIf we have the function f ordered in decreasing order from the largest value to the lowest one, we can compute the h-index as follows:\\n\\n    h-index (f) = max i min ( f ( i ) , i ) {\\\\displaystyle \\\\max _{i}\\\\min(f(i),i)} \\\\max _{i}\\\\min(f(i),i)\\n\\t\\nHere are some key pieces of information for us to solve our problem.\\n\\n\"First we order the values of f from the largest to the lowest value\" \\n\\nThis tells me I need to sort the input array\\n\\n\"Then, we look for the last position in which f is greater than or equal to the position (we call h this position)\"\\n\\nThis tells me that I need to skip each item in the sorted array till I get to a point where the citations count is less than the current index. In our example, the 5th(index) publication has 3 citations, hence our H index is the index before 5.\\n\\nLets see how our pseudocode is shaping up.\\n\\n```\\nfunc(citations array) {\\n\\tSort the citations array \\n\\t//Java doesnt let me sort a primitive array in descending order, so I ll have to play with the indices\\n\\tSet current index to 1\\n\\tLoop through citations array\\n\\t\\tif current citation < current index\\n\\t\\t\\tbreak\\n\\t\\tincrement current index\\n\\treturn current index - 1\\n```\\n\\nLets test this with our example [10, 8, 5, 4, 3]\\n\\nSort in descding order (already sorted) -> [10, 8, 5, 4, 3]\\ncurrent index = 1\\nLoop through the array\\n\\tcurrent citation = 10\\n\\tcurrent index = 1, break condition not met\\n\\t\\n\\tcurrent citation = 8\\n\\tcurrent index = 2, break condition not met\\n\\t\\n\\tcurrent citation = 5\\n\\tcurrent index = 3, break condition not met\\n\\t\\n\\tcurrent citation = 4\\n\\tcurrent index = 4, break condition not met\\n\\t\\n\\tcurrent citation = 3\\n\\tcurrent index = 5, break condition met\\n\\tbreak the loop\\n\\nreturn current index - 1\\n\\nLets look at the code now:\\n\\n```\\npublic int hIndex(int[] citations) {\\n        Arrays.sort(citations);\\n        int currentIndex = 1;\\n\\n        while (currentIndex <= citations.length) {\\n            if (citations[citations.length - currentIndex] < currentIndex) {\\n                break;\\n            }\\n            currentIndex++;\\n        }\\n        return currentIndex-1;\\n    }\\n```\\n\\nI have seen people solve it without sorting and I commend them, I happened to read through the wiki and coded the way wiki explained it.\\n\\n\\t\\t\\n\\n",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nfunc(citations array) {\\n\\tSort the citations array \\n\\t//Java doesnt let me sort a primitive array in descending order, so I ll have to play with the indices\\n\\tSet current index to 1\\n\\tLoop through citations array\\n\\t\\tif current citation < current index\\n\\t\\t\\tbreak\\n\\t\\tincrement current index\\n\\treturn current index - 1\\n```\n```\\npublic int hIndex(int[] citations) {\\n        Arrays.sort(citations);\\n        int currentIndex = 1;\\n\\n        while (currentIndex <= citations.length) {\\n            if (citations[citations.length - currentIndex] < currentIndex) {\\n                break;\\n            }\\n            currentIndex++;\\n        }\\n        return currentIndex-1;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 785640,
                "title": "easy-java-solution-faster-than-100-submission-in-0ms",
                "content": "```\\nclass Solution {\\n    public int hIndex(int[] citations) {\\n        Arrays.sort(citations);\\n        int n=citations.length;\\n        for(int i=0;i<n;i++)\\n        {\\n            if(citations[i]>=n-i)\\n            {\\n                return (n-i);\\n            }\\n        }\\n        return 0;\\n        \\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int hIndex(int[] citations) {\\n        Arrays.sort(citations);\\n        int n=citations.length;\\n        for(int i=0;i<n;i++)\\n        {\\n            if(citations[i]>=n-i)\\n            {\\n                return (n-i);\\n            }\\n        }\\n        return 0;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 734842,
                "title": "how-to-explain-to-interviewer-274-h-index",
                "content": "#### 1. Clarify\\n- If citations = [100, 100], is h-index 2?  Answer is Yes, because we have at least 2 papers whose citation is >= 2 and 2 - 2 = 0 papers have no more than 2 citations\\n\\n#### 2. Idea, Code, Complexity Analysis\\nLet\\'s sort the citations array in increasing order and list the sorted array as below\\n\\n|sorted citations (there can be duplicates)|c<sub>0</sub> |c<sub>1</sub>|...|c<sub>n-(i+1)|c<sub>n-i</sub>|...|c<sub>n - 2</sub>|c<sub>n - 1</sub>|\\n|:---:|:---:|:---:|:---:|:---:|:---:|:---:|:---:|:---:|\\n|paper count accumulation(right to left)|n|n-1|...|i+1|i|...|2|1|\\n\\n\\nIf we can find an i such that:\\n-  i <= c<sub>n-i</sub> \\n-  c<sub>n-(i+1)</sub> <= i\\n\\nin which\\n-  i <= c<sub>n-i</sub> means that i papers have citations >= i because i <= c<sub>n-i</sub> < ...< c<sub>n - 2</sub> < c<sub>n - 1</sub>\\n-  c<sub>n-(i+1)</sub> <= i means that n - i papers have citations <= i because c<sub>0</sub> < c<sub>1</sub> <   ... < c<sub>n-(i+1)</sub> <= i\\n\\nThen i meets the definition of h-index:\\n- i papers\\' citations >= i each\\n- The other N - i papers\\' citations <= i each\\n\\nSo i is the h-index of this scientist\\n\\nThe code is below(**search i either from smallest or largest**):\\n```java\\nclass Solution {\\n\\t//search i from 1 to n\\n    public int hIndex(int[] citations) {\\n        Arrays.sort(citations);\\n        int n = citations.length;\\n        for(int i = 1; i <= n; i ++){\\n            if(citations[n - i] >= i && (n - i - 1 < 0 || citations[n - i - 1] <= i)){\\n                return i;\\n            }\\n        }\\n        return 0;\\n    }\\n}\\n\\nclass Solution {\\n\\t//search i from n to 1\\n    public int hIndex(int[] citations) {\\n        Arrays.sort(citations);\\n        int n = citations.length;\\n        for(int i = n; i >= 1; i --){\\n            if(citations[n - i] >= i && (n - i - 1 < 0 || citations[n - i - 1] <= i)){\\n                return i;\\n            }\\n        }\\n        return 0;\\n    }\\n}\\n```\\n**The time complexity** is O(nlogn) where n is the length of citations array\\n**The space complexity** is O(1) because we only use some variables\\n\\nCan the time complexity be improved? The answer is Yes\\n\\n#### 3. Improvement\\nWe could use **bucket sort** to solve this problem:\\n\\n|sorted citations (no duplicates)|0|1|...|i|i+1|...|n|\\n|:---|:---:|:---:|:---:|:---:|:---:|:---:|:---:|:---:|\\n|paper count <br/>p<sub>i</sub> means<br/>- the number of papers that have i citations(if i < n) <br/>-  or the number of papers that have >= i citations(if i == n) |p<sub>0</sub>|p<sub>1</sub>|...|p<sub>i</sub>|p<sub>i+1</sub>|...|p<sub>n</sub>|\\n|paper count accumulation(right to left)<br/>a<sub>i</sub> = p<sub>i</sub>+p<sub>i+1</sub>+...+p<sub>n</sub>=a<sub>i+1</sub>+p<sub>i</sub>|a<sub>0</sub>|a<sub>1</sub>|...|a<sub>i</sub>|a<sub>i+1</sub>|...|a<sub>n</sub>| cc \\n\\n\\nIf we can find an i such that:\\n-  i <= a<sub>i</sub>\\n-  i + 1 > a<sub>i+1</sub> (is equal to a<sub>i+1</sub> - i < 1)\\n\\nin which\\n-  a<sub>i</sub> means the number of papers whose citations = [i, n], so a<sub>i</sub> papers have at least i citations each, and because a<sub>i</sub> >= i, **i papers have at least i citations each**\\n-  **The other n - i papers have <= i citations**, to prove this, we could divide them into two parts\\n\\t- part 1: a<sub>i</sub> - i papers\\n\\tbecause a<sub>i</sub> - i = a<sub>i+1</sub> + p<sub>i</sub> - i = (a<sub>i+1</sub> - i) + p<sub>i</sub> < 1 + p<sub>i</sub> <= p<sub>i</sub>, so all a<sub>i</sub> - i papers fall into papers with i citations\\n\\t- part 2: n - a<sub>i</sub> papers\\n\\ta<sub>i</sub> means the number of papers whose citations = [i, n], so n - a<sub>i</sub> means the number of papers whose citaions = [0, i - 1], all n - a<sub>i</sub> papers have < i citations\\n\\nThen i meets the definition of h-index:\\n- i papers\\' citations >= i each\\n- The other N - i papers\\' citations <= i each\\n\\nSo i is the h-index of this scientist\\n\\nThe code is below(search i either from smallest or largest):\\n```java\\nclass Solution {\\n\\t//search i from 1 to n\\n    public int hIndex(int[] citations) {\\n        int n = citations.length;\\n        int[] count = new int[n + 1];\\n        int[] accumulation = new int[n + 1];\\n\\n        for(int citation: citations){\\n            if(citation <= n){\\n                count[citation] ++;\\n            }\\n            else{\\n                count[n] ++;\\n            }\\n        }\\n        \\n        accumulation[n] = count[n];\\n        for(int i = n - 1; i >= 0; i --){\\n            accumulation[i] = count[i] + accumulation[i + 1];\\n        }\\n\\n        for(int i = 1; i <= n; i ++){\\n            if(i <= accumulation[i] && (i == n || i + 1 > accumulation[i + 1])){\\n                return i;\\n            }\\n        }\\n        \\n        return 0;\\n    }\\n}\\n\\nclass Solution {\\n\\t//search i from n to 1\\n    public int hIndex(int[] citations) {\\n        int n = citations.length;\\n        int[] count = new int[n + 1];\\n\\n        for(int citation: citations){\\n            if(citation <= n){\\n                count[citation] ++;\\n            }\\n            else{\\n                count[n] ++;\\n            }\\n        }\\n\\n        int accumualtion = 0;\\n        for(int i = n; i >= 1; i --){\\n            accumualtion += count[i];\\n            if(i <= accumualtion){\\n                return i;\\n            }\\n        }\\n        return 0;\\n    }\\n}\\n```\\n\\nTime Complexity: O(n) where n is the length of citations[] array\\nSpace Complexity: O(n)\\n\\n#### 4. There is one and only one h-index for any citations[] array\\nIn part 2, we proved that if we can find an i such that:\\n-  i <= c<sub>n-i</sub> \\n-  c<sub>n-(i+1)</sub> <= i\\n\\nThen i is the h-index of this scientist. \\n\\nActually, such an i is the only h-index of this scientist. \\n- If we increase i, for example we check i + 1, if i + 1 is the h-index of this scientist, then the following conditions must be met:\\n\\t-  i + 1 <= c<sub>n-(i+1)</sub> < c<sub>n-i</sub> < ...< c<sub>n - 2</sub> < c<sub>n - 1</sub> ----- condition 1\\n\\t-  c<sub>0</sub> < c<sub>1</sub> <   ... < c<sub>n-(i+2)</sub> <= i + 1 ------ condition 2\\n\\nApparently, conditions 2 is met but condition 1 isn\\'t because we know c<sub>n-(i+1)</sub> <= i but not c<sub>n-(i+1)</sub> >= i + 1\\n\\n- If we decrease i, for example we check i - 1, if i - 1 is the h-index of this scientist, then the following conditions must be met:\\n\\t-  i - 1 <= c<sub>n-(i-1)</sub> < ...< c<sub>n - 2</sub> < c<sub>n - 1</sub> ----- condition 1\\n\\t-  c<sub>0</sub> < c<sub>1</sub> <   ... < c<sub>n-i</sub> <= i - 1 ------ condition 2\\n\\nApparently, conditions 1 is met but condition 2 isn\\'t because we know c<sub>n-i</sub> >= i but not c<sub>n-i</sub> <= i - 1\\n\\nFrom the proof above we know that for a given citations[], there is one and only one h-index",
                "solutionTags": [],
                "code": "```java\\nclass Solution {\\n\\t//search i from 1 to n\\n    public int hIndex(int[] citations) {\\n        Arrays.sort(citations);\\n        int n = citations.length;\\n        for(int i = 1; i <= n; i ++){\\n            if(citations[n - i] >= i && (n - i - 1 < 0 || citations[n - i - 1] <= i)){\\n                return i;\\n            }\\n        }\\n        return 0;\\n    }\\n}\\n\\nclass Solution {\\n\\t//search i from n to 1\\n    public int hIndex(int[] citations) {\\n        Arrays.sort(citations);\\n        int n = citations.length;\\n        for(int i = n; i >= 1; i --){\\n            if(citations[n - i] >= i && (n - i - 1 < 0 || citations[n - i - 1] <= i)){\\n                return i;\\n            }\\n        }\\n        return 0;\\n    }\\n}\\n```\n```java\\nclass Solution {\\n\\t//search i from 1 to n\\n    public int hIndex(int[] citations) {\\n        int n = citations.length;\\n        int[] count = new int[n + 1];\\n        int[] accumulation = new int[n + 1];\\n\\n        for(int citation: citations){\\n            if(citation <= n){\\n                count[citation] ++;\\n            }\\n            else{\\n                count[n] ++;\\n            }\\n        }\\n        \\n        accumulation[n] = count[n];\\n        for(int i = n - 1; i >= 0; i --){\\n            accumulation[i] = count[i] + accumulation[i + 1];\\n        }\\n\\n        for(int i = 1; i <= n; i ++){\\n            if(i <= accumulation[i] && (i == n || i + 1 > accumulation[i + 1])){\\n                return i;\\n            }\\n        }\\n        \\n        return 0;\\n    }\\n}\\n\\nclass Solution {\\n\\t//search i from n to 1\\n    public int hIndex(int[] citations) {\\n        int n = citations.length;\\n        int[] count = new int[n + 1];\\n\\n        for(int citation: citations){\\n            if(citation <= n){\\n                count[citation] ++;\\n            }\\n            else{\\n                count[n] ++;\\n            }\\n        }\\n\\n        int accumualtion = 0;\\n        for(int i = n; i >= 1; i --){\\n            accumualtion += count[i];\\n            if(i <= accumualtion){\\n                return i;\\n            }\\n        }\\n        return 0;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 71032,
                "title": "simple-o-n-python-code-with-explanation",
                "content": "H-index is at most the number of papers, which is len(citations) . keep a list of length len(citations)+1, and at each index i, record the number of papers with citations exactly i (except for the last index, which records number of papers with citations >= i). After constructing such list, scan the list from the back, maintain the sum of all encountered number. The sum means how many paper with citation >= the index. If sum>= index, then the index is the h-index.\\n\\n        def hIndex(self, citations):\\n            stat = [0]*(len(citations)+1)\\n            for i in citations:\\n                if i>len(citations):\\n                    i = len(citations)\\n                stat[i] += 1\\n            \\n            sum = 0 \\n            for j in xrange(len(citations), -1, -1):\\n                sum += stat[j]\\n                if sum >= j:\\n                    return j\\n            return 0",
                "solutionTags": [],
                "code": "H-index is at most the number of papers, which is len(citations) . keep a list of length len(citations)+1, and at each index i, record the number of papers with citations exactly i (except for the last index, which records number of papers with citations >= i). After constructing such list, scan the list from the back, maintain the sum of all encountered number. The sum means how many paper with citation >= the index. If sum>= index, then the index is the h-index.\\n\\n        def hIndex(self, citations):\\n            stat = [0]*(len(citations)+1)\\n            for i in citations:\\n                if i>len(citations):\\n                    i = len(citations)\\n                stat[i] += 1\\n            \\n            sum = 0 \\n            for j in xrange(len(citations), -1, -1):\\n                sum += stat[j]\\n                if sum >= j:\\n                    return j\\n            return 0",
                "codeTag": "Python3"
            },
            {
                "id": 71061,
                "title": "ac-java-solution",
                "content": "    public class Solution {\\n        public int hIndex(int[] citations) {\\n            Arrays.sort(citations);\\n            for(int i = 0; i < citations.length; i++) {\\n                if(citations[i] >= citations.length - i) return citations.length - i;\\n            }\\n            return 0;\\n        }\\n    }",
                "solutionTags": [],
                "code": "class Solution {\\n        public int hIndex(int[] citations) {\\n            Arrays.sort(citations);\\n            for(int i = 0; i < citations.length; i++) {\\n                if(citations[i] >= citations.length - i) return citations.length - i;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 3990012,
                "title": "simple-and-intuitive-solution-sort-c",
                "content": "### Intuition behind the approach\\n\\nAccording to the definition of h index, it is the maximum value of h such that the given researcher has published at least h papers that have each been cited at least h times. \\n\\nSo if we have any array which is sorted in non decreasing order, the h value for a particular index will be mininmum value of the difference between the total number of publications and i th index and number of number of citations of the ith index. \\n\\n* Initially we\\'ll sort the citations vector to get them in non decreasing order.\\n* Then we\\'ll just iterate over the citations index and for each index, ``` h_index = min(citations[i],m-i) ```  where m is the total number of publications.\\n\\n```\\n    int hIndex(vector<int>& citations) {\\n        sort(citations.begin(),citations.end());\\n        int h_index = 0;\\n        const int m = citations.size();\\n        for(int i=0;i<m;++i){\\n            h_index = max(h_index,min(citations[i],m-i));\\n        }\\n        return h_index;\\n    }\\n\\n```\\n\\nPlease upvote if it helped you! And also comment if you have any questions or modifications. It helps me as well!",
                "solutionTags": [
                    "C",
                    "Sorting"
                ],
                "code": "``` h_index = min(citations[i],m-i) ```\n```\\n    int hIndex(vector<int>& citations) {\\n        sort(citations.begin(),citations.end());\\n        int h_index = 0;\\n        const int m = citations.size();\\n        for(int i=0;i<m;++i){\\n            h_index = max(h_index,min(citations[i],m-i));\\n        }\\n        return h_index;\\n    }\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3945230,
                "title": "2-java-solutions-beats-100-users-with-java",
                "content": "# Method 1\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nFirstly, I have created an Frequency array to Store the quantity of Papers. Then I traverse from last to frquency array till i did not get the count of papers Quantity greater or equal to Number of Papers(Current Index).\\n\\n# Complexity\\n- Time complexity:$$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:$$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int hIndex(int[] citations) {\\n       int n = citations.length;\\n       int[]freq = new int[n+1];\\n\\n       for(int i=0;i<n;i++){\\n           if(citations[i]>citations.length){\\n               freq[citations.length]++;\\n           }else{\\n               freq[citations[i]]++;\\n           }\\n       }\\n        int cCount =0;\\n        for(int i=n;i>=0;i--){\\n            cCount+=freq[i];\\n            if(cCount>=i){\\n                return i;\\n            }\\n        }\\n\\n        return 0;\\n    }\\n\\n\\n}\\n```\\n\\n# Method 2\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. Sort the Arrays first\\n2. Check each index till count of papers left `(n-currentIndex)`\\n\\n# Complexity\\n- Time complexity:$$O(nlogn)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:$$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\nclass Solution {\\n     \\n      public int hIndex(int[] citations){\\n\\n         Arrays.sort(citations);\\n         int n = citations.length;\\n       \\n         int idx = 0 ;\\n\\n         while(idx < n &&  n-idx >citations[idx]){\\n             idx++;\\n         }\\n\\n    return n-idx;\\n\\n   }\\n\\n}\\n```\\n\\n",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int hIndex(int[] citations) {\\n       int n = citations.length;\\n       int[]freq = new int[n+1];\\n\\n       for(int i=0;i<n;i++){\\n           if(citations[i]>citations.length){\\n               freq[citations.length]++;\\n           }else{\\n               freq[citations[i]]++;\\n           }\\n       }\\n        int cCount =0;\\n        for(int i=n;i>=0;i--){\\n            cCount+=freq[i];\\n            if(cCount>=i){\\n                return i;\\n            }\\n        }\\n\\n        return 0;\\n    }\\n\\n\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3775124,
                "title": "o-n-time-complexity",
                "content": "# Complexity\\n- Time complexity: $$O(n)$$ \\n\\n- Space complexity: $$O(n)$$ \\n\\n# Code\\n```\\nclass Solution {\\n    // citations means quality and index of array means quantity, x quality is h index if there are more than x papers\\n    // with atleast x quality.\\n    public int hIndex(int[] citations) {\\n        int n = citations.length;\\n        int[] freq = new int[n + 1];\\n        for(int num : citations){\\n            if(num > n) freq[n]++;\\n            else{\\n                freq[num]++;\\n            }\\n        }\\n        int sum = 0;\\n        for(int i = n; i >= 0; i--){\\n            sum += freq[i];\\n            if(sum >= i) return i;\\n        }\\n        return 0;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Counting Sort"
                ],
                "code": "```\\nclass Solution {\\n    // citations means quality and index of array means quantity, x quality is h index if there are more than x papers\\n    // with atleast x quality.\\n    public int hIndex(int[] citations) {\\n        int n = citations.length;\\n        int[] freq = new int[n + 1];\\n        for(int num : citations){\\n            if(num > n) freq[n]++;\\n            else{\\n                freq[num]++;\\n            }\\n        }\\n        int sum = 0;\\n        for(int i = n; i >= 0; i--){\\n            sum += freq[i];\\n            if(sum >= i) return i;\\n        }\\n        return 0;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3755376,
                "title": "simple-and-easy-to-understand-python-solution-with-98-runtime-and-57-memory-beat",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n\\n# Code\\n```\\nclass Solution:\\n    def hIndex(self, citations: List[int]) -> int:\\n        citations.sort()\\n        n = len(citations)\\n        h = 0\\n\\n        if n == 1 and citations[0] == 0:\\n            return 0\\n        else:\\n            for i in range(n):\\n                if citations[i] < n - i:\\n                   h = citations[i]\\n                else:\\n                    h = max(h, n-i)\\n            return h\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def hIndex(self, citations: List[int]) -> int:\\n        citations.sort()\\n        n = len(citations)\\n        h = 0\\n\\n        if n == 1 and citations[0] == 0:\\n            return 0\\n        else:\\n            for i in range(n):\\n                if citations[i] < n - i:\\n                   h = citations[i]\\n                else:\\n                    h = max(h, n-i)\\n            return h\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3744147,
                "title": "most-easy-c-solution",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int hIndex(vector<int>& citations) {\\n    sort(citations.rbegin(), citations.rend());\\n    int h = 0;\\n    while (h < citations.size() && citations[h] > h) {\\n        h++;\\n    }\\n    return h;\\n}\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int hIndex(vector<int>& citations) {\\n    sort(citations.rbegin(), citations.rend());\\n    int h = 0;\\n    while (h < citations.size() && citations[h] > h) {\\n        h++;\\n    }\\n    return h;\\n}\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3224563,
                "title": "100-faster-then-c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n# store the freq.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n# using loop\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n# O(n)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n# O(n)\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int hIndex(vector<int>& citations) {\\n      int n = citations.size();  \\n      vector<int> dp(n+1,0);\\n      for(int i=0;i<n;i++){\\n          if(citations[i] > n) dp[n]++; \\n          else dp[citations[i]]++;\\n      }\\n      int sum=0;\\n      for(int i=n;i>=0;i--){\\n          sum+=dp[i];\\n          if(i <= sum)\\n            return i;\\n      }\\n      return -1;\\n    }\\n    \\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int hIndex(vector<int>& citations) {\\n      int n = citations.size();  \\n      vector<int> dp(n+1,0);\\n      for(int i=0;i<n;i++){\\n          if(citations[i] > n) dp[n]++; \\n          else dp[citations[i]]++;\\n      }\\n      int sum=0;\\n      for(int i=n;i>=0;i--){\\n          sum+=dp[i];\\n          if(i <= sum)\\n            return i;\\n      }\\n      return -1;\\n    }\\n    \\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2793205,
                "title": "simple-java-solution-binary-search-n-log-n",
                "content": "```\\nclass Solution {\\n    public int find(int[]nums, int mid){\\n        int count = 0;\\n        for(int ele : nums){\\n            if(ele >= mid){\\n                count++;\\n            }\\n        }\\n        return count;\\n    }\\n    public int hIndex(int[] citations) {\\n        int low = 1;\\n        int high = citations.length;\\n        int ans = 0;\\n        while(low <= high){\\n            int mid = low + (high - low)/2;\\n            int k = find(citations, mid);\\n            if(k >= mid){\\n                ans = mid;\\n                low = mid + 1;\\n            }\\n            else{\\n                high = mid - 1;\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\n    public int find(int[]nums, int mid){\\n        int count = 0;\\n        for(int ele : nums){\\n            if(ele >= mid){\\n                count++;\\n            }\\n        }\\n        return count;\\n    }\\n    public int hIndex(int[] citations) {\\n        int low = 1;\\n        int high = citations.length;\\n        int ans = 0;\\n        while(low <= high){\\n            int mid = low + (high - low)/2;\\n            int k = find(citations, mid);\\n            if(k >= mid){\\n                ans = mid;\\n                low = mid + 1;\\n            }\\n            else{\\n                high = mid - 1;\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1738248,
                "title": "simple-python-counting-sort-o-n-solution-with-explanation",
                "content": "```\\n# Counting sort. Why? Number value range correlates with index.\\n# Given n papers, max H index is n. Have an additional one bucket to store all \\n# papers that have > n citations. To align array index number with citation value, add one \\n# more bucket. So total n+2 bucket. Then loop from index n to 0, accumulate the citation value\\n# along the way. If citations[i] >= i, i is the resulting max H index. \\nclass Solution:\\n    def hIndex(self, citations: List[int]) -> int:\\n        n = len(citations)\\n        arr = [0] * (n + 2)\\n        for i in range(n):\\n            if citations[i] > n:\\n                arr[n + 1] += 1\\n            else:\\n                arr[citations[i]] += 1\\n            \\n        accSum = arr[n + 1]\\n        # iterate in reversed order from the last second one\\n        for i in range(n, -1, -1):\\n            accSum += arr[i]\\n            if accSum >= i:\\n                return i\\n        return 0\\n```",
                "solutionTags": [
                    "Python",
                    "Counting Sort"
                ],
                "code": "```\\n# Counting sort. Why? Number value range correlates with index.\\n# Given n papers, max H index is n. Have an additional one bucket to store all \\n# papers that have > n citations. To align array index number with citation value, add one \\n# more bucket. So total n+2 bucket. Then loop from index n to 0, accumulate the citation value\\n# along the way. If citations[i] >= i, i is the resulting max H index. \\nclass Solution:\\n    def hIndex(self, citations: List[int]) -> int:\\n        n = len(citations)\\n        arr = [0] * (n + 2)\\n        for i in range(n):\\n            if citations[i] > n:\\n                arr[n + 1] += 1\\n            else:\\n                arr[citations[i]] += 1\\n            \\n        accSum = arr[n + 1]\\n        # iterate in reversed order from the last second one\\n        for i in range(n, -1, -1):\\n            accSum += arr[i]\\n            if accSum >= i:\\n                return i\\n        return 0\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1605037,
                "title": "counting-sort-with-a-really-simple-explanation",
                "content": "This solution is an optimization of the worst-case solution i.e. simply running a linear search for each h-index to find the number of elements that are greater than or equal to it.\\n\\nFor instance, in our O(N^2) solution we do a linear search on each possible h-index 1 ~ array.length:\\n\\n\\n**idx = 1\\nnum_citations_greater_or_equal = 4\\nisPossibleSolution = true**\\n\\n**idx = 2\\nnum_citations_greater_or_equal = 3\\nisPossibleSolution = true**\\n\\n**idx = 3\\nnum_citations_greater_or_equal = 3\\nisPossibleSolution = true**\\n\\n**idx = 4\\nnum_citations_greater_or_equal = 2\\nisPossibleSolution = false**\\n\\n**idx = 5\\nnum_citations_greater_or_equal = 1\\nisPossibleSolution = false**\\n\\n\\nThis solution is exactly the same thing, except we pre-process the counts ahead of time - placing the values at their associated index.\\n\\n**input:  [3, 0, 6, 1, 5]**\\n\\n**index:  [0, 1, 2, 3, 4, 5]**\\n**count:  [1, 1, 0, 1, 0, 2]**\\n**sum  :  [5, 4, 3, 3, 2, 2]**\\n\\nNow, you may be wondering how the count array or sum arra may be useful.ne thing to remember is that we are simply looking for any h-index where at least h papers with h or more citations exist.  This is a confusing explanation, so an example helps:  if h = 2, we need at least 2 or more papers to exist that were cited at least twice.  \\n\\nHow do we do this? \\n\\nWe can simply walk from the end of our count array and compare our running sum with the current h-index (current index in this case).  If our sum, which represents the number of papers with at least h-index citations exists, is >= our index then we have found a solution.  We simply stop at the first value that meets this criteria, because it is the largest possible value.\\n\\n\\n```\\nclass Solution {\\n    public int hIndex(int[] citations) {\\n        if (citations == null || citations.length == 0) return 0;\\n        \\n        final int MAX_SIZE = citations.length;\\n        int[] count = new int[MAX_SIZE + 1];\\n        int citationSum = 0;\\n        \\n        for (int citation : citations) {\\n            int idx = citation <= MAX_SIZE? citation : MAX_SIZE;\\n            count[idx]++;\\n        }\\n        \\n        for (int i = MAX_SIZE; i >= 0; i--) {\\n            citationSum += count[i];\\n            if (citationSum >= i) return i;\\n        }\\n        return 0;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int hIndex(int[] citations) {\\n        if (citations == null || citations.length == 0) return 0;\\n        \\n        final int MAX_SIZE = citations.length;\\n        int[] count = new int[MAX_SIZE + 1];\\n        int citationSum = 0;\\n        \\n        for (int citation : citations) {\\n            int idx = citation <= MAX_SIZE? citation : MAX_SIZE;\\n            count[idx]++;\\n        }\\n        \\n        for (int i = MAX_SIZE; i >= 0; i--) {\\n            citationSum += count[i];\\n            if (citationSum >= i) return i;\\n        }\\n        return 0;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1457176,
                "title": "h-index-using-sorting-library-c-easy-to-understand",
                "content": "class Solution {\\npublic:\\n    int hIndex(vector<int>& citations) {\\n        \\n        //sort the citations(0,1,3,5,6)\\n        sort(citations.begin(),citations.end());\\n        //store citations in n\\n        int n=citations.size();\\n        //create index i\\n        int i;\\n        //iterate the loop \\n        for( i=1;i<=n;i++)\\n            \\n        //if n=6 and i=5 -> 6-5=1 <5 so its break the loop\\n            \\n            if(citations[n-i]<i)\\n                break;\\n        \\n        return i-1;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    int hIndex(vector<int>& citations) {\\n        \\n        //sort the citations(0,1,3,5,6)\\n        sort(citations.begin(),citations.end());\\n        //store citations in n\\n        int n=citations.size();\\n        //create index i\\n        int i;\\n        //iterate the loop \\n        for( i=1;i<=n;i++)\\n            \\n        //if n=6 and i=5 -> 6-5=1 <5 so its break the loop\\n            \\n            if(citations[n-i]<i)\\n                break;\\n        \\n        return i-1;\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 785356,
                "title": "c-bucket-sort-o-n",
                "content": "Suppose the author has `N` papers, then the `H-index <= N`. The straightforward approach is to sort with `O(N(logN))`, then count. But this is not fast enough for this problem. The trick for an `O(N)` solution is to sort papers into buckets.\\n\\nAssume we have N buckets, from `0`..`N-1`, one for each paper.\\n* for each paper, if the number of citations `n < N`, put that paper in the `n`-th bucket\\n* if `n >= N`, put that in that `N-1`-th bucket\\nHere is the code:\\n```\\n    int hIndex(vector<int>& citations) {\\n        int N = citations.size();\\n        vector<int> buckets(N+1, 0);\\n\\n        for(int i : citations){\\n            if (i >= N){\\n                buckets[N]++;\\n            } else {\\n                buckets[i]++;\\n            }\\n        }\\n\\n        int count = 0;\\n        for(int i = N; i >= 0; i--){\\n            count += buckets[i];\\n            if(count >= i) {\\n                return i;\\n            }\\n        }\\n\\n        // should not reach here\\n        return 0;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    int hIndex(vector<int>& citations) {\\n        int N = citations.size();\\n        vector<int> buckets(N+1, 0);\\n\\n        for(int i : citations){\\n            if (i >= N){\\n                buckets[N]++;\\n            } else {\\n                buckets[i]++;\\n            }\\n        }\\n\\n        int count = 0;\\n        for(int i = N; i >= 0; i--){\\n            count += buckets[i];\\n            if(count >= i) {\\n                return i;\\n            }\\n        }\\n\\n        // should not reach here\\n        return 0;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 693513,
                "title": "python-3-binary-search-sort-iterative-solution",
                "content": "```\\nclass Solution:\\n    def hIndex(self, citations: List[int]) -> int:\\n        n , left , right = len(citations) , 0 , len(citations)\\n        citations.sort()\\n        while left < right:\\n            mid = left + (right - left) // 2\\n            numGreater = n - mid\\n            if numGreater <= citations[mid]:\\n                right = mid\\n            else:\\n                left = mid + 1\\n        return n - left\\n```",
                "solutionTags": [
                    "Python3",
                    "Binary Search",
                    "Iterator"
                ],
                "code": "```\\nclass Solution:\\n    def hIndex(self, citations: List[int]) -> int:\\n        n , left , right = len(citations) , 0 , len(citations)\\n        citations.sort()\\n        while left < right:\\n            mid = left + (right - left) // 2\\n            numGreater = n - mid\\n            if numGreater <= citations[mid]:\\n                right = mid\\n            else:\\n                left = mid + 1\\n        return n - left\\n```",
                "codeTag": "Java"
            },
            {
                "id": 70954,
                "title": "4-line-nlogn-simple-solution",
                "content": "      int hIndex(vector<int>& citations) {\\n            sort(citations.begin(), citations.end());\\n            const int size_c = citations.size();\\n            for (int i = 0; i < size_c; i++) {\\n                if (citations[i] >= size_c - i) return size_c - i;\\n            }\\n            return 0;\\n        }",
                "solutionTags": [],
                "code": "      int hIndex(vector<int>& citations) {\\n            sort(citations.begin(), citations.end());\\n            const int size_c = citations.size();\\n            for (int i = 0; i < size_c; i++) {\\n                if (citations[i] >= size_c - i) return size_c - i;\\n            }\\n            return 0;\\n        }",
                "codeTag": "Unknown"
            },
            {
                "id": 70997,
                "title": "my-0ms-ac-solution-using-hash-table",
                "content": "    int hIndex(vector<int>& citations) {\\n        int n = citations.size();\\n        if (n == 0) return 0;\\n        int* map = new int[n+1];\\n        memset(map, 0, (n+1)*sizeof(int));\\n        for (int i = 0; i < n; ++i){\\n            if (citations[i] < n) map[citations[i]] += 1;\\n            else map[n] += 1;\\n        }\\n        \\n        int acc = 0;\\n        for (int i = n; i >= 0; --i){\\n            acc += map[i];\\n            if (acc >= i) return i;\\n        }\\n    }",
                "solutionTags": [],
                "code": "    int hIndex(vector<int>& citations) {\\n        int n = citations.size();\\n        if (n == 0) return 0;\\n        int* map = new int[n+1];\\n        memset(map, 0, (n+1)*sizeof(int));\\n        for (int i = 0; i < n; ++i){\\n            if (citations[i] < n) map[citations[i]] += 1;\\n            else map[n] += 1;\\n        }\\n        \\n        int acc = 0;\\n        for (int i = n; i >= 0; --i){\\n            acc += map[i];\\n            if (acc >= i) return i;\\n        }\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 71019,
                "title": "java-o-n-solution",
                "content": "    public class Solution {\\n        public int hIndex(int[] citations) {\\n            int n = citations.length;\\n            int[] indexs = new int[n+1];\\n            for(int i = 0; i < n; i++) {\\n                if(citations[i]>=n) indexs[n]++; \\n                else indexs[citations[i]]++;\\n            }\\n            for(int j = n; j >= 0; j--) {\\n                if(indexs[j] >= j) return j;\\n                if(j!=0) indexs[j-1] += indexs[j];\\n            }\\n            return 0;\\n        }\\n    }",
                "solutionTags": [],
                "code": "class Solution {\\n        public int hIndex(int[] citations) {\\n            int n = citations.length;\\n            int[] indexs = new int[n+1];\\n            for(int i = 0; i < n; i++) {\\n                if(citations[i]>=n) indexs[n]++; \\n                else indexs[citations[i]]++;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 71054,
                "title": "o-n-c-solution",
                "content": "    class Solution {\\n    public:\\n    int hIndex(vector<int>& cit) {\\n        vector<long> hist(cit.size()+1,0);\\n        for(int i=0;i<cit.size();++i)\\n            ++hist[min<int>(cit.size(),cit[i])];\\n\\n        long cumSum=0;\\n        for(int i=hist.size()-1;i>=0;--i) {\\n            cumSum+=hist[i];\\n            if(cumSum>=i)\\n                return i;\\n        }        \\n        return 0;\\n    }\\n    };",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n    int hIndex(vector<int>& cit) {\\n        vector<long> hist(cit.size()+1,0);\\n        for(int i=0;i<cit.size();++i)\\n            ++hist[min<int>(cit.size(),cit[i])];\\n\\n        long cumSum=0;\\n        for(int i=hist.size()-1;i>=0;--i) {\\n            cumSum+=hist[i];\\n            if(cumSum>=i)\\n                return i;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 3989302,
                "title": "two-easy-code-in-cpp",
                "content": "# Code1\\n```\\nclass Solution {\\npublic:\\n    int hIndex(vector<int>& citations) {\\n        sort(citations.begin(),citations.end());\\n        int n=citations.size();\\n        for(int i=0;i<citations.size();i++){\\n            if(citations[i] >= n){\\n                return n;\\n            }\\n            else{\\n                if(n==1 && citations[i]!=0)\\n                    return 1;\\n                n--;\\n            }\\n        }\\n        return n;\\n    }\\n};\\n```\\n# Code2\\n```\\nclass Solution {\\npublic:\\n    int hIndex(vector<int>& citations) {\\n        unordered_map<int, int>mp;\\n        int maxi=0;\\n        for(int i:citations){\\n            maxi = max(maxi, i);\\n            mp[i]++;\\n        }\\n        int tot=0;\\n        for(int i=maxi;i>=0;i--){\\n            tot += mp[i];\\n            if(tot >= i && i!=0) \\n                return i;\\n        }\\n        return citations.size()-mp[0];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Hash Table",
                    "Binary Search",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int hIndex(vector<int>& citations) {\\n        sort(citations.begin(),citations.end());\\n        int n=citations.size();\\n        for(int i=0;i<citations.size();i++){\\n            if(citations[i] >= n){\\n                return n;\\n            }\\n            else{\\n                if(n==1 && citations[i]!=0)\\n                    return 1;\\n                n--;\\n            }\\n        }\\n        return n;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int hIndex(vector<int>& citations) {\\n        unordered_map<int, int>mp;\\n        int maxi=0;\\n        for(int i:citations){\\n            maxi = max(maxi, i);\\n            mp[i]++;\\n        }\\n        int tot=0;\\n        for(int i=maxi;i>=0;i--){\\n            tot += mp[i];\\n            if(tot >= i && i!=0) \\n                return i;\\n        }\\n        return citations.size()-mp[0];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3728231,
                "title": "frequency-array-o-n-time-and-o-n-space",
                "content": "# Intuition\\nCounting the number of occurences would allow us to determine the max h-index. But the range for the possible number of citations is quite large. Since the maximum h-index can only be the length of the citation array all occurences of papers with more than length many citations can be counted together.\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n1. Initialize the varible to count papers with large citation counts.\\n2. Initialize the frequency array, include zero.\\n3. Count the occurences of number of citations in citation array.\\n4. To find the maximum h-index, check if the largest possible h-index is an h-index, if not continue.\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: $$O(n)$$. Two linear time loops.\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n)$$. The frequency array increases linearly with the length of the citation array.\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def hIndex(self, citations: List[int]) -> int:\\n        citationsAboveH = 0\\n        citationFrequencies = [0] * (len(citations)+1)\\n\\n        for i in range(len(citations)):\\n            if citations[i] > len(citations):\\n                citationsAboveH += 1 \\n            else:\\n                citationFrequencies[citations[i]] += 1\\n\\n        qualifyingPapers = citationsAboveH\\n        for h in range(len(citations), 0, -1):\\n            qualifyingPapers += citationFrequencies[h]\\n            if qualifyingPapers >= h:\\n                return h\\n        \\n        return 0\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def hIndex(self, citations: List[int]) -> int:\\n        citationsAboveH = 0\\n        citationFrequencies = [0] * (len(citations)+1)\\n\\n        for i in range(len(citations)):\\n            if citations[i] > len(citations):\\n                citationsAboveH += 1 \\n            else:\\n                citationFrequencies[citations[i]] += 1\\n\\n        qualifyingPapers = citationsAboveH\\n        for h in range(len(citations), 0, -1):\\n            qualifyingPapers += citationFrequencies[h]\\n            if qualifyingPapers >= h:\\n                return h\\n        \\n        return 0\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3686346,
                "title": "very-very-easy-solution-o-n",
                "content": "# Complexity\\n- Time complexity:\\nO(nlogn)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\npublic class Solution {\\n    public int HIndex(int[] citations) {\\n        Array.Sort(citations, new Comparison<int>((i1, i2) => i2.CompareTo(i1)));\\n            for (int i = 0; i < citations.Length; i++)\\n                if (citations[i] < i + 1)\\n                    return i;\\n\\n            return citations.Length; \\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution {\\n    public int HIndex(int[] citations) {\\n        Array.Sort(citations, new Comparison<int>((i1, i2) => i2.CompareTo(i1)));\\n            for (int i = 0; i < citations.Length; i++)\\n                if (citations[i] < i + 1)\\n                    return i;\\n\\n            return citations.Length; \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3676377,
                "title": "faster-than-100-sc-o-1-easy-to-understand",
                "content": "# Intuition\\nBrute force approach regardless of sorting the array and compare with position\\n\\n# Approach\\nSort the array in descending order then compare with the position of the element if position is less than equal to element then increase the count..\\nFor e.g. arr[]={4,3,2} the 4 belong to the the index 0 i.e. at place 1 which means (index+1)... \\nIf arr[i]>=arr[i+1] then it considered to be count...\\n\\n# Complexity\\n- Time complexity:\\n# **O(nlogn)+o(n)-->O(nlogn)**\\n\\n- Space complexity:\\n# **O(1)**\\n\\n# Code\\n//There is two solution for the given problem\\n```\\nclass Solution {\\npublic:\\n    int hIndex(vector<int>& citations) {\\n        int count=0,val=1;\\n        sort(citations.begin(),citations.end(),greater<int>());\\n        for(int i=0;i<citations.size();i++)\\n        {\\n            if(citations[i]>=val)\\n            {\\n                count++;\\n            }\\n            val=val+1;//increment every time\\n        }\\n        return count;\\n    }\\n};\\n```\\n\\n//Second Solution will be \\n```\\nclass Solution {\\npublic:\\n    int hIndex(vector<int>& citations) {\\n        int mini=0,maxi=INT_MIN;\\n        sort(citations.begin(),citations.end(),greater<int>());\\n        for(int i=0;i<citations.size();i++)\\n        {\\n            mini=min(citations[i],i+1);\\n            maxi=max(maxi,mini);\\n        }\\n        return maxi;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int hIndex(vector<int>& citations) {\\n        int count=0,val=1;\\n        sort(citations.begin(),citations.end(),greater<int>());\\n        for(int i=0;i<citations.size();i++)\\n        {\\n            if(citations[i]>=val)\\n            {\\n                count++;\\n            }\\n            val=val+1;//increment every time\\n        }\\n        return count;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int hIndex(vector<int>& citations) {\\n        int mini=0,maxi=INT_MIN;\\n        sort(citations.begin(),citations.end(),greater<int>());\\n        for(int i=0;i<citations.size();i++)\\n        {\\n            mini=min(citations[i],i+1);\\n            maxi=max(maxi,mini);\\n        }\\n        return maxi;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3624671,
                "title": "count-sort-o-n-classical-overlapping-interval-problem",
                "content": "```\\nclass Solution {\\npublic:\\n    int hIndex(vector<int>& citations) {\\n        int n = citations.size(); \\n        vector<int> f(1002);\\n\\n        for(int i=0; i<n; i++) {\\n            f[0]++;\\n            f[citations[i]+1]--;\\n        }\\n\\n        int h_index = 0;\\n        int accumulate = 0;\\n\\n        for (int i=0; i<1002; i++) {\\n            accumulate += f[i];\\n            if (accumulate >= i) h_index = i;\\n        }\\n\\n        return h_index;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int hIndex(vector<int>& citations) {\\n        int n = citations.size(); \\n        vector<int> f(1002);\\n\\n        for(int i=0; i<n; i++) {\\n            f[0]++;\\n            f[citations[i]+1]--;\\n        }\\n\\n        int h_index = 0;\\n        int accumulate = 0;\\n\\n        for (int i=0; i<1002; i++) {\\n            accumulate += f[i];\\n            if (accumulate >= i) h_index = i;\\n        }\\n\\n        return h_index;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3496403,
                "title": "easy-solution-by-sorting",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(nlogn)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int hIndex(vector<int>& citations) {\\n        int n = citations.size();\\n        sort(citations.begin(), citations.end());\\n        int ans = 0;\\n        for(int i = 0; i < n; i++){\\n            if((n - i) >= citations[i]){\\n                ans = citations[i];\\n            }\\n            else{\\n                ans = max(ans, n - i);\\n                break;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int hIndex(vector<int>& citations) {\\n        int n = citations.size();\\n        sort(citations.begin(), citations.end());\\n        int ans = 0;\\n        for(int i = 0; i < n; i++){\\n            if((n - i) >= citations[i]){\\n                ans = citations[i];\\n            }\\n            else{\\n                ans = max(ans, n - i);\\n                break;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3474203,
                "title": "typescript-javascript-oneliner",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nSort and filter the array and extract the length.\\n\\n# Code\\n```\\nfunction hIndex(citations: number[]): number {\\n    return citations.sort((a,b) => b-a).filter((x,i) => x > i).length \\n};\\n```",
                "solutionTags": [
                    "TypeScript"
                ],
                "code": "```\\nfunction hIndex(citations: number[]): number {\\n    return citations.sort((a,b) => b-a).filter((x,i) => x > i).length \\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2738305,
                "title": "java-solution-understanding-problem-watch-yt-video",
                "content": "# class Solution {\\n    public int hIndex(int[] citations) {\\n        Arrays.sort(citations);\\n        int n=citations.length;\\n        int index=0;\\n           while(index<n && citations[index]<n-index)\\n           {\\n               index++;\\n           }\\n        return n-index;\\n    }\\n}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    public int hIndex(int[] citations) {\\n        Arrays.sort(citations);\\n        int n=citations.length;\\n        int index=0;\\n           while(index<n && citations[index]<n-index)\\n           {\\n               index++;\\n           }",
                "codeTag": "Java"
            },
            {
                "id": 2617728,
                "title": "very-easy-c-solution-very-fast",
                "content": "```\\nclass Solution {\\npublic:\\n    int hIndex(vector<int>& c) \\n    {\\n        int ans=0;\\n        sort(c.begin(),c.end());\\n        for(int i=c.size()-1;i>=0;i--)\\n        {\\n            if(c[i]>=c.size()-i)\\n            {\\n                 ans++;\\n            }  \\n        }\\n        return ans;\\n    }\\n};\\n//Please upvote if you find the solution useful.\\n```",
                "solutionTags": [
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int hIndex(vector<int>& c) \\n    {\\n        int ans=0;\\n        sort(c.begin(),c.end());\\n        for(int i=c.size()-1;i>=0;i--)\\n        {\\n            if(c[i]>=c.size()-i)\\n            {\\n                 ans++;\\n            }  \\n        }\\n        return ans;\\n    }\\n};\\n//Please upvote if you find the solution useful.\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2336982,
                "title": "simple-c-solution-0ms-beats-100",
                "content": "```\\nclass Solution {\\npublic:\\n    int hIndex(vector<int>& citations) {\\n        sort(citations.begin(),citations.end(),greater<int>());\\n        int ans=0;\\n        for(int i=0;i<citations.size();i++){\\n            if(citations[i]>=i+1) ans=i+1;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int hIndex(vector<int>& citations) {\\n        sort(citations.begin(),citations.end(),greater<int>());\\n        int ans=0;\\n        for(int i=0;i<citations.size();i++){\\n            if(citations[i]>=i+1) ans=i+1;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2228457,
                "title": "simple-sort",
                "content": "```\\nvar hIndex = function(citations) {\\n    citations.sort((a,b)=>b-a)\\n    let i=0\\n    while(citations[i]>i) i++\\n    \\n    return i\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar hIndex = function(citations) {\\n    citations.sort((a,b)=>b-a)\\n    let i=0\\n    while(citations[i]>i) i++\\n    \\n    return i\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1988187,
                "title": "c-clean-and-simple-binary-search-solution",
                "content": "class Solution {\\npublic:\\n    \\n    bool isValid(vector<int> &v,int mid){\\n        int count  = 0;\\n        for(auto x:v){\\n            if(x>=mid) count++;\\n        }\\n\\n    return count>=mid;\\n}\\n\\n    \\n    int hIndex(vector<int>& v) {\\n    \\n        int high = *max_element(v.begin(),v.end());\\n        int low = 1;\\n        int ans = 0;\\n\\n        while(low<=high){\\n            int mid = low + (high-low)/2;\\n            if(isValid(v,mid)){\\n                ans = mid;\\n                low = mid+1;\\n            }\\n            else high = mid-1;\\n        }   \\n        return ans; \\n        \\n    }\\n};",
                "solutionTags": [
                    "C",
                    "Binary Tree"
                ],
                "code": "class Solution {\\npublic:\\n    \\n    bool isValid(vector<int> &v,int mid){\\n        int count  = 0;\\n        for(auto x:v){\\n            if(x>=mid) count++;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 786005,
                "title": "0-ms-and-o-1-space-soln",
                "content": "```\\nclass Solution {\\npublic:\\n    int hIndex(vector<int>& citations) { \\n        sort(citations.begin(),citations.end());\\n        int n=citations.size();\\n          if(n==0||citations[n-1]==0){return 0;}\\n     \\n      for(int i=0;i<n;i++)\\n        { if(n-i-1<citations[i]){return n-i;}   }\\n       \\n\\t   return 0;}\\n};\\n```\\n\\none more soln\\n```\\nclass Solution {\\npublic:\\n    int hIndex(vector<int>& cit) {\\n    priority_queue<int, vector<int>, greater<int>> pq(begin(cit), end(cit));\\n    while (!pq.empty() && pq.top() < pq.size())\\n        pq.pop();\\n    return pq.size();\\n}\\n};\\n```\\n\\n\\nhappy coding :)\\nplease upvote",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int hIndex(vector<int>& citations) { \\n        sort(citations.begin(),citations.end());\\n        int n=citations.size();\\n          if(n==0||citations[n-1]==0){return 0;}\\n     \\n      for(int i=0;i<n;i++)\\n        { if(n-i-1<citations[i]){return n-i;}   }\\n       \\n\\t   return 0;}\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int hIndex(vector<int>& cit) {\\n    priority_queue<int, vector<int>, greater<int>> pq(begin(cit), end(cit));\\n    while (!pq.empty() && pq.top() < pq.size())\\n        pq.pop();\\n    return pq.size();\\n}\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 693431,
                "title": "simple-binary-search",
                "content": "```java\\nclass Solution {\\n    public int hIndex(int[] citations) {\\n        Arrays.sort(citations);\\n        int n = citations.length, l = 0, r = n - 1, result = 0;\\n        while (l <= r) {\\n            int mid = l + ((r - l) >> 1);\\n            int distance = n - mid;\\n            if (distance <= citations[mid]) {\\n                result = Math.max(result, distance);\\n                r = mid - 1;\\n            }\\n            else\\n                l = mid + 1;\\n        }\\n        return result;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```java\\nclass Solution {\\n    public int hIndex(int[] citations) {\\n        Arrays.sort(citations);\\n        int n = citations.length, l = 0, r = n - 1, result = 0;\\n        while (l <= r) {\\n            int mid = l + ((r - l) >> 1);\\n            int distance = n - mid;\\n            if (distance <= citations[mid]) {\\n                result = Math.max(result, distance);\\n                r = mid - 1;\\n            }\\n            else\\n                l = mid + 1;\\n        }\\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 693375,
                "title": "short-c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int hIndex(vector<int>& c) {\\n        sort(c.begin(),c.end());\\n        int n=c.size(),l=0,h=n;\\n        while(l<h)\\n        {\\n            auto mid=(l+h)/2;\\n            if(c[mid]<n-mid) l=mid+1;\\n            else h=mid;\\n        }\\n        return n-l;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int hIndex(vector<int>& c) {\\n        sort(c.begin(),c.end());\\n        int n=c.size(),l=0,h=n;\\n        while(l<h)\\n        {\\n            auto mid=(l+h)/2;\\n            if(c[mid]<n-mid) l=mid+1;\\n            else h=mid;\\n        }\\n        return n-l;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 149341,
                "title": "java-very-easy-to-understand",
                "content": "```java\\nclass Solution {\\n    public int hIndex(int[] citations) {\\n        if(citations==null|| citations.length==0) return 0;  \\n        Arrays.sort(citations);\\n        int len = citations.length;\\n        int hIndex = 0;\\n        for (int i= 0; i<len; i++){\\n            if(citations[i]>=len-i){\\n                hIndex = len-i;\\n                break;\\n            }\\n        }\\n        return hIndex;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```java\\nclass Solution {\\n    public int hIndex(int[] citations) {\\n        if(citations==null|| citations.length==0) return 0;  \\n        Arrays.sort(citations);\\n        int len = citations.length;\\n        int hIndex = 0;\\n        for (int i= 0; i<len; i++){\\n            if(citations[i]>=len-i){\\n                hIndex = len-i;\\n                break;\\n            }\\n        }\\n        return hIndex;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 70900,
                "title": "o-n-1ms-solution-with-extra-space",
                "content": "This solution is inspired by skoy12 (https://leetcode.com/discuss/105676/o-n-with-java-1-ms). One modification is that the h-index can be at most n, the length of array. So I change \\n\"sum = Math.max(i, sum - hindex[i]); \" into just \"return i\".\\n\\n    public int hIndex(int[] citations) {\\n    int n = citations.length;\\n    if (n == 0) return 0;\\n    int[] hindex = new int[n + 1];\\n    for(int val: citations){\\n        if(val >= n) hindex[n]++;\\n        else hindex[val]++;\\n    }\\n    int sum = 0;\\n    int i = n;\\n    while (i > 0) {\\n        sum += hindex[i];\\n        if (i <= sum) return i;\\n        i--;\\n    }\\n    return 0;\\n   }",
                "solutionTags": [
                    "Java"
                ],
                "code": "This solution is inspired by skoy12 (https://leetcode.com/discuss/105676/o-n-with-java-1-ms). One modification is that the h-index can be at most n, the length of array. So I change \\n\"sum = Math.max(i, sum - hindex[i]); \" into just \"return i\".\\n\\n    public int hIndex(int[] citations) {\\n    int n = citations.length;\\n    if (n == 0) return 0;\\n    int[] hindex = new int[n + 1];\\n    for(int val: citations){\\n        if(val >= n) hindex[n]++;\\n        else hindex[val]++;\\n    }\\n    int sum = 0;\\n    int i = n;\\n    while (i > 0) {\\n        sum += hindex[i];\\n        if (i <= sum) return i;\\n        i--;\\n    }\\n    return 0;\\n   }",
                "codeTag": "Unknown"
            },
            {
                "id": 70911,
                "title": "java-o-n-solution-1ms",
                "content": "The thinking is, if an author has N papers, then his/her h-index cannot be higher than N.\\nThat means we only need to have an array with size N + 1, the index of which records the citation number. If the citation number > N, i.e, one of his 5 papers was referenced 100 times, then this credit goes to citation N.\\nIn the first pass, we can build the freq array with the number of papers in each citation bucket.\\nThen the 2nd pass, we iterate from tail to head, add all the citations backwards until freq[i] > i, then return i.\\n\\n    public int hIndex(int[] citations) {\\n        if(citations == null || citations.length == 0)\\n            return 0;\\n\\n        int N = citations.length;\\n        int[] freq = new int[N+1];\\n        for(int i=0;i<N;i++){\\n            if(citations[i] == 0)\\n                continue;\\n            if(citations[i] > N)\\n                freq[N]++;\\n            else\\n                freq[citations[i]]++;\\n        }\\n        \\n        for(int i=N;i>0;i--){\\n            if(i < N){\\n                freq[i] = freq[i] + freq[i+1];\\n            }\\n            if(freq[i] >= i)\\n                return i;\\n        }\\n        return 0;\\n    }",
                "solutionTags": [],
                "code": "The thinking is, if an author has N papers, then his/her h-index cannot be higher than N.\\nThat means we only need to have an array with size N + 1, the index of which records the citation number. If the citation number > N, i.e, one of his 5 papers was referenced 100 times, then this credit goes to citation N.\\nIn the first pass, we can build the freq array with the number of papers in each citation bucket.\\nThen the 2nd pass, we iterate from tail to head, add all the citations backwards until freq[i] > i, then return i.\\n\\n    public int hIndex(int[] citations) {\\n        if(citations == null || citations.length == 0)\\n            return 0;\\n\\n        int N = citations.length;\\n        int[] freq = new int[N+1];\\n        for(int i=0;i<N;i++){\\n            if(citations[i] == 0)\\n                continue;\\n            if(citations[i] > N)\\n                freq[N]++;\\n            else\\n                freq[citations[i]]++;\\n        }\\n        \\n        for(int i=N;i>0;i--){\\n            if(i < N){\\n                freq[i] = freq[i] + freq[i+1];\\n            }\\n            if(freq[i] >= i)\\n                return i;\\n        }\\n        return 0;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 70934,
                "title": "using-sorting-really-small-solution",
                "content": "We can optimize this from O(n) to O(logn) (leaving aside the time complexity of sorting)   by travelling the array as a binary tree using mid, low and high\\n\\n    public int hIndex(int[] a) {\\n                if(a==null)\\n                    return 0;\\n                Arrays.sort(a);\\n                int len = a.length;\\n                int i = len-1, h = 1, hMax = 0;\\n                while(i >= 0){\\n                    if(h <= a[i] && h == len-i){\\n                        hMax = Math.max(h, hMax);\\n                    }\\n                    h++; i--;\\n                }\\n                return hMax;\\n            }",
                "solutionTags": [
                    "Java"
                ],
                "code": "We can optimize this from O(n) to O(logn) (leaving aside the time complexity of sorting)   by travelling the array as a binary tree using mid, low and high\\n\\n    public int hIndex(int[] a) {\\n                if(a==null)\\n                    return 0;\\n                Arrays.sort(a);\\n                int len = a.length;\\n                int i = len-1, h = 1, hMax = 0;\\n                while(i >= 0){\\n                    if(h <= a[i] && h == len-i){\\n                        hMax = Math.max(h, hMax);\\n                    }\\n                    h++; i--;\\n                }\\n                return hMax;\\n            }",
                "codeTag": "Unknown"
            },
            {
                "id": 70943,
                "title": "binary-search-in-python-with-explanation",
                "content": "My idea is using binary search.\\n\\n\\n 1. Suppose we have a list of citation [3,0,6,1,5]. First, sort the\\n   citation in decreasing order --> [6,5,3,1,0] \\n 2. Now it is obvious that we need to find the one whose number of citation is just >= its\\n   index+1 (citations[i] >= i+1), and those who is after this element,\\n   the number of citation should <= its index + 1(citations[i] < i+1). \\n   This is because, if we look from left to right, the index+1 shows us\\n   how many elements appears for now,  and we want to find how many\\n   elements whose number of citation > the number of those elements. \\n\\n 3. Therefore, using binary search. Reduce the size of list by comparing\\n   citations[mid] with mid+1\\n\\n========================================================================\\n\\n    def hIndex(self, citations):\\n        \"\"\"\\n        :type citations: List[int]\\n        :rtype: int\\n        \"\"\"\\n        if citations == []:\\n            return 0\\n        citations.sort(reverse = True)\\n        end = len(citations) - 1\\n        start = 0\\n        while start < end - 1:\\n            mid = (start + end) / 2\\n            if citations[mid] < mid + 1: # cut the right part and remain left part\\n                end = mid\\n            elif citations[mid] == mid + 1: # just the answer\\n                return mid+1\\n            else: # remain the right part\\n                start = mid\\n        # If only two elements left, check if all the citation>=index+1 or h-index=0 or just around the boundary\\n        if citations[end] >= end + 1:\\n            return end + 1\\n        elif citations[start] < start + 1:\\n                return 0\\n        else:\\n            return start + 1",
                "solutionTags": [
                    "Python",
                    "Binary Tree"
                ],
                "code": "My idea is using binary search.\\n\\n\\n 1. Suppose we have a list of citation [3,0,6,1,5]. First, sort the\\n   citation in decreasing order --> [6,5,3,1,0] \\n 2. Now it is obvious that we need to find the one whose number of citation is just >= its\\n   index+1 (citations[i] >= i+1), and those who is after this element,\\n   the number of citation should <= its index + 1(citations[i] < i+1). \\n   This is because, if we look from left to right, the index+1 shows us\\n   how many elements appears for now,  and we want to find how many\\n   elements whose number of citation > the number of those elements. \\n\\n 3. Therefore, using binary search. Reduce the size of list by comparing\\n   citations[mid] with mid+1\\n\\n========================================================================\\n\\n    def hIndex(self, citations):\\n        \"\"\"\\n        :type citations: List[int]\\n        :rtype: int\\n        \"\"\"\\n        if citations == []:\\n            return 0\\n        citations.sort(reverse = True)\\n        end = len(citations) - 1\\n        start = 0\\n        while start < end - 1:\\n            mid = (start + end) / 2\\n            if citations[mid] < mid + 1: # cut the right part and remain left part\\n                end = mid\\n            elif citations[mid] == mid + 1: # just the answer\\n                return mid+1\\n            else: # remain the right part\\n                start = mid\\n        # If only two elements left, check if all the citation>=index+1 or h-index=0 or just around the boundary\\n        if citations[end] >= end + 1:\\n            return end + 1\\n        elif citations[start] < start + 1:\\n                return 0\\n        else:\\n            return start + 1",
                "codeTag": "Python3"
            },
            {
                "id": 70964,
                "title": "javascript-solution",
                "content": "    function hIndex(citations) {\\n      var map = {};\\n      var h = citations.length;\\n      var i = 0;\\n      var max = 0;\\n      citations.map(c => map[c] = map[c] ? map[c] + 1 : 1);\\n      for (; i <= h; i++) {\\n        max = Math.max(max, h >= i ? i : 0);\\n        h -= map[i] ? map[i] : 0;\\n      }\\n      return max;\\n    }",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "    function hIndex(citations) {\\n      var map = {};\\n      var h = citations.length;\\n      var i = 0;\\n      var max = 0;\\n      citations.map(c => map[c] = map[c] ? map[c] + 1 : 1);\\n      for (; i <= h; i++) {\\n        max = Math.max(max, h >= i ? i : 0);\\n        h -= map[i] ? map[i] : 0;\\n      }\\n      return max;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 70985,
                "title": "java-1ms-o-n-solution-using-counting-sort",
                "content": "    \\n    public int hIndex(int[] citations) {\\n        int n = citations.length;\\n        int[] count = new int[n+1];\\n        for (int i = 0; i < n; i++) {\\n            if (citations[i] > n) count[n]++;\\n            else count[citations[i]]++;\\n        }\\n        for (int i = n; i > 0; i--) {\\n            if (count[i] >= i) return i;\\n            count[i-1] += count[i];\\n        }\\n        return 0;\\n    }",
                "solutionTags": [],
                "code": "    \\n    public int hIndex(int[] citations) {\\n        int n = citations.length;\\n        int[] count = new int[n+1];\\n        for (int i = 0; i < n; i++) {\\n            if (citations[i] > n) count[n]++;\\n            else count[citations[i]]++;\\n        }\\n        for (int i = n; i > 0; i--) {\\n            if (count[i] >= i) return i;\\n            count[i-1] += count[i];\\n        }\\n        return 0;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 70986,
                "title": "4ms-c-without-sort-beats-100",
                "content": "    int hIndex(vector<int>& citations) {\\n            if (citations.empty())\\n                return 0;\\n            vector<int> count(citations.size()+1, 0); // record 0-size\\n            for (int i = 0; i < citations.size(); ++i)\\n            {\\n                count[citations[i] < count.size() ? citations[i] : count.size() - 1]++;\\n            }\\n            int sum = 0;\\n            for (int j = count.size() - 1; j >= 0; --j)\\n            {\\n                sum += count[j];\\n                if (j <= sum)\\n                    return j;\\n            }\\n            return 0;\\n        }",
                "solutionTags": [],
                "code": "    int hIndex(vector<int>& citations) {\\n            if (citations.empty())\\n                return 0;\\n            vector<int> count(citations.size()+1, 0); // record 0-size\\n            for (int i = 0; i < citations.size(); ++i)\\n            {\\n                count[citations[i] < count.size() ? citations[i] : count.size() - 1]++;\\n            }\\n            int sum = 0;\\n            for (int j = count.size() - 1; j >= 0; --j)\\n            {\\n                sum += count[j];\\n                if (j <= sum)\\n                    return j;\\n            }\\n            return 0;\\n        }",
                "codeTag": "Unknown"
            },
            {
                "id": 70989,
                "title": "c-solution-sort-first-and-hash-table",
                "content": "sort first\\n\\n    static bool myfun(int a, int b)\\n    {\\n    \\treturn a > b; \\n    }\\n    int hIndex(vector<int>& cit) \\n    {\\n    \\tif (!cit.size())\\n    \\t\\treturn 0;\\n    \\tint sz = cit.size();\\n    \\tsort(cit.begin(), cit.end(), myfun);\\n    \\tint i;\\n    \\tfor (i = 0; i < sz && (cit[i] >= i + 1); ++i);\\n    \\treturn i;\\n    }\\n\\nhash table\\n\\n    int hIndex(vector<int>& cit)\\n    {\\n    \\tif (!cit.size())\\n    \\t\\treturn 0;\\n    \\tint sz = cit.size();\\n    \\tvector<int> table(sz + 1);\\n    \\tint i, sum = 0;\\n    \\tfor (i = 0; i < sz; ++i)\\n    \\t{\\n    \\t\\tif (cit[i] >= sz)\\n    \\t\\t\\t++table[sz];\\n    \\t\\telse\\n    \\t\\t\\t++table[cit[i]];\\n    \\t}\\n    \\tfor (i = sz; i >= 0; --i)\\n    \\t{\\n    \\t\\tsum += table[i];\\n    \\t\\tif (sum >= i)\\n    \\t\\t\\tbreak;\\n    \\t}\\n    \\treturn i;\\n    }",
                "solutionTags": [
                    "Hash Table"
                ],
                "code": "sort first\\n\\n    static bool myfun(int a, int b)\\n    {\\n    \\treturn a > b; \\n    }\\n    int hIndex(vector<int>& cit) \\n    {\\n    \\tif (!cit.size())\\n    \\t\\treturn 0;\\n    \\tint sz = cit.size();\\n    \\tsort(cit.begin(), cit.end(), myfun);\\n    \\tint i;\\n    \\tfor (i = 0; i < sz && (cit[i] >= i + 1); ++i);\\n    \\treturn i;\\n    }\\n\\nhash table\\n\\n    int hIndex(vector<int>& cit)\\n    {\\n    \\tif (!cit.size())\\n    \\t\\treturn 0;\\n    \\tint sz = cit.size();\\n    \\tvector<int> table(sz + 1);\\n    \\tint i, sum = 0;\\n    \\tfor (i = 0; i < sz; ++i)\\n    \\t{\\n    \\t\\tif (cit[i] >= sz)\\n    \\t\\t\\t++table[sz];\\n    \\t\\telse\\n    \\t\\t\\t++table[cit[i]];\\n    \\t}\\n    \\tfor (i = sz; i >= 0; --i)\\n    \\t{\\n    \\t\\tsum += table[i];\\n    \\t\\tif (sum >= i)\\n    \\t\\t\\tbreak;\\n    \\t}\\n    \\treturn i;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 70992,
                "title": "detailed-explanation-and-my-3-line-sample-python-code",
                "content": "Most important of all: The definition.\\n\\n\"A scientist has index h if h of his/her N papers have at least h citations each, and the other N \\u2212 h papers have no more than h citations each.\"\\n\\nSo the observation is: If I `sort` the *citations*, then the `idx`-element in the sorted array means `there are at least N-idx papers have citations count more than or equal to citations[idx]`\\n\\nFor example, \\n\\n               idx:  0 1 2 3 4\\n             N-idx:  5 4 3 2 1\\n    citations[idx]:  0 1 3 5 6\\n\\n - For idx == 0, it means there are at least 5 papers have citations count more than or equal to 0\\n - For idx == 3, it means there are at least 3 papers have citations count more than or equal to 3\\n - For idx == 4, it means there are at least 1 papers have citations count more than or equal to 6\\n\\nBut how do we connect it to the definition, which said that it want h papers with at least h citations?\\nThe answer is that  we can further modify the observation to\\n\\n `there are at least N-idx papers have citations count more than or equal to min(N-idx, citations[idx])`\\n\\nWhy? I actually notice this transformation when I failed with the case [100], which follow by what I observed could be:\\n\\n - For idx == 0, it means there are at least 1 papers have citations count more than or equal to 100\\n\\nIt's right, but from the definition, h papers with at least h citations, h could not be 100, instead, it should be 1!!\\n\\nAnd the answer would be the largest value for `min(N-idx, citations[idx])` in each idx!\\nSo, that's pretty much how I think of this problem, hope it helps you!\\n\\nSample Python Code:\\n\\n    def hIndex(self, citations):\\n        citations.sort()\\n        comparePairs = zip([len(citations)-i for i in range(len(citations))], citations)\\n        return max([min(p) for p in comparePairs]) if citations else 0\\n\\nor\\n\\n    def hIndex(self, citations):\\n        citations.sort()\\n        maxh, lc = 0, len(citations)\\n        for i, n in enumerate(citations):\\n            maxh = max(min(lc-i, n), maxh)\\n        return maxh",
                "solutionTags": [
                    "Python"
                ],
                "code": "Most important of all: The definition.\\n\\n\"A scientist has index h if h of his/her N papers have at least h citations each, and the other N \\u2212 h papers have no more than h citations each.\"\\n\\nSo the observation is: If I `sort` the *citations*, then the `idx`-element in the sorted array means `there are at least N-idx papers have citations count more than or equal to citations[idx]`\\n\\nFor example, \\n\\n               idx:  0 1 2 3 4\\n             N-idx:  5 4 3 2 1\\n    citations[idx]:  0 1 3 5 6\\n\\n - For idx == 0, it means there are at least 5 papers have citations count more than or equal to 0\\n - For idx == 3, it means there are at least 3 papers have citations count more than or equal to 3\\n - For idx == 4, it means there are at least 1 papers have citations count more than or equal to 6\\n\\nBut how do we connect it to the definition, which said that it want h papers with at least h citations?\\nThe answer is that  we can further modify the observation to\\n\\n `there are at least N-idx papers have citations count more than or equal to min(N-idx, citations[idx])`\\n\\nWhy? I actually notice this transformation when I failed with the case [100], which follow by what I observed could be:\\n\\n - For idx == 0, it means there are at least 1 papers have citations count more than or equal to 100\\n\\nIt's right, but from the definition, h papers with at least h citations, h could not be 100, instead, it should be 1!!\\n\\nAnd the answer would be the largest value for `min(N-idx, citations[idx])` in each idx!\\nSo, that's pretty much how I think of this problem, hope it helps you!\\n\\nSample Python Code:\\n\\n    def hIndex(self, citations):\\n        citations.sort()\\n        comparePairs = zip([len(citations)-i for i in range(len(citations))], citations)\\n        return max([min(p) for p in comparePairs]) if citations else 0\\n\\nor\\n\\n    def hIndex(self, citations):\\n        citations.sort()\\n        maxh, lc = 0, len(citations)\\n        for i, n in enumerate(citations):\\n            maxh = max(min(lc-i, n), maxh)\\n        return maxh",
                "codeTag": "Python3"
            },
            {
                "id": 4007955,
                "title": "simplest-approch",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n1.) Sort the vector in descending order.\\n2.) For loop the vector:\\n        the number of elements the loop passed through should be greater than the value of h. h less than x means there are less than h elements are equal or greater than the value h.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(nlogn)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int hIndex(vector<int>& citations) {\\n        // Sort in descending order\\n        sort(citations.begin(), citations.end(), greater<int>());\\n\\n        int h = 0;\\n        for(auto x : citations){\\n            if(x > h){\\n                h++;\\n            } else {\\n                return h;\\n            }\\n        }\\n\\n        return h;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int hIndex(vector<int>& citations) {\\n        // Sort in descending order\\n        sort(citations.begin(), citations.end(), greater<int>());\\n\\n        int h = 0;\\n        for(auto x : citations){\\n            if(x > h){\\n                h++;\\n            } else {\\n                return h;\\n            }\\n        }\\n\\n        return h;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4001857,
                "title": "easy-and-simple-code-in-c-100-beats",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nPut n as size, .sort\\u2026 while iterating if (c[I]>=n) return n; else decrese n\\u2014 and check if (c[I]!=0 && n==1) return 1;\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int hIndex(vector<int>& citations) {\\n        int n=citations.size();\\n        sort(citations.begin(),citations.end());\\n        for(int i=0;i<citations.size();i++){\\n            if(citations[i]>=n)\\n                return n;\\n            else{\\n                if(n==1 && citations[i]!=0)\\n                    return 1;\\n                n--;\\n            }\\n        }\\n        return n;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int hIndex(vector<int>& citations) {\\n        int n=citations.size();\\n        sort(citations.begin(),citations.end());\\n        for(int i=0;i<citations.size();i++){\\n            if(citations[i]>=n)\\n                return n;\\n            else{\\n                if(n==1 && citations[i]!=0)\\n                    return 1;\\n                n--;\\n            }\\n        }\\n        return n;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3809728,
                "title": "simple-c-beats-100-easy-to-understand",
                "content": "## Please upvote if you like the solution\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int hIndex(vector<int>& c) {\\n        int n = c.size();\\n        sort(c.begin(), c.end(), greater<int>()); // Sort the vector in descending order\\n\\n        int hIndex = 0;\\n        for (int i = 0; i < n; i++) {\\n            if (c[i] >= i + 1) {\\n                hIndex = i + 1;\\n            } else {\\n                break;\\n            }\\n        }\\n        return hIndex;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int hIndex(vector<int>& c) {\\n        int n = c.size();\\n        sort(c.begin(), c.end(), greater<int>()); // Sort the vector in descending order\\n\\n        int hIndex = 0;\\n        for (int i = 0; i < n; i++) {\\n            if (c[i] >= i + 1) {\\n                hIndex = i + 1;\\n            } else {\\n                break;\\n            }\\n        }\\n        return hIndex;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3754983,
                "title": "without-using-any-in-built-function-easy-to-understand",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int hIndex(int[] citations) {\\n        int ans=0;\\n        for(int i=0;i<citations.length;i++)\\n        {\\n            for(int j=i+1;j<citations.length;j++)\\n            {\\n                if( citations[i]< citations[j])\\n                {\\n                    int temp =  citations[i];\\n                     citations[i]= citations[j];\\n                      citations[j]=temp;\\n                }\\n            }\\n        }\\n        int check=0;\\n        for(int i=0;i<citations.length;i++)\\n        {    check++;\\n            if(citations[i]>=check)\\n              // System.out.print(check);\\n            ans = check;\\n    \\n            else break;\\n        }\\n        //System.out.print(Arrays.toString( citations));\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "C",
                    "Sort"
                ],
                "code": "```\\nclass Solution {\\n    public int hIndex(int[] citations) {\\n        int ans=0;\\n        for(int i=0;i<citations.length;i++)\\n        {\\n            for(int j=i+1;j<citations.length;j++)\\n            {\\n                if( citations[i]< citations[j])\\n                {\\n                    int temp =  citations[i];\\n                     citations[i]= citations[j];\\n                      citations[j]=temp;\\n                }\\n            }\\n        }\\n        int check=0;\\n        for(int i=0;i<citations.length;i++)\\n        {    check++;\\n            if(citations[i]>=check)\\n              // System.out.print(check);\\n            ans = check;\\n    \\n            else break;\\n        }\\n        //System.out.print(Arrays.toString( citations));\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3607514,
                "title": "sorting-and-linear-search-c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int hIndex(vector<int>& c) {\\n        //sorting\\n        sort(c.begin(), c.end());\\n        //linear search\\n        int max_val = 0;\\n        for(int i = 1; i <= c.size(); i++){\\n            if(c[c.size()-i] >= i){\\n                if((i == c.size()) || (c[c.size()-i-1] <= i))\\n                    max_val = i;\\n                }\\n        }\\n\\t\\t\\n        return max_val;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int hIndex(vector<int>& c) {\\n        //sorting\\n        sort(c.begin(), c.end());\\n        //linear search\\n        int max_val = 0;\\n        for(int i = 1; i <= c.size(); i++){\\n            if(c[c.size()-i] >= i){\\n                if((i == c.size()) || (c[c.size()-i-1] <= i))\\n                    max_val = i;\\n                }\\n        }\\n\\t\\t\\n        return max_val;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3591133,
                "title": "h-index-javascript-sort-an-array-70-63",
                "content": "```\\n/**\\n * @param {number[]} citations\\n * @return {number}\\n */\\nvar hIndex = function(citations) {    \\n    citations.sort((a, b) => b - a)    \\n    i = 0\\n\\n    while (citations[i] > i) {        \\n        i ++        \\n    }\\n    \\n    return i \\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} citations\\n * @return {number}\\n */\\nvar hIndex = function(citations) {    \\n    citations.sort((a, b) => b - a)    \\n    i = 0\\n\\n    while (citations[i] > i) {        \\n        i ++        \\n    }\\n    \\n    return i \\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3562476,
                "title": "simple-solution-linear-time",
                "content": "\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {number[]} citations\\n * @return {number}\\n */\\nvar hIndex = function(citations) {\\n    const len = citations.length\\n    let i = 1\\n    let j = 0\\n\\n    if (len === 1 && citations[j] === 0) return 0\\n    if (len === 1) return i\\n\\n    const sortedArray = citations.sort((a, b) => b - a)\\n\\n    while(j < len) {\\n        const el = sortedArray[j]\\n        if (el === i) return i\\n        if (len === i && el > i) return i\\n        if (len === i && el < i) return i - 1\\n        if (el < i) return i - 1\\n        i++\\n        j++\\n    }\\n\\n    return i\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} citations\\n * @return {number}\\n */\\nvar hIndex = function(citations) {\\n    const len = citations.length\\n    let i = 1\\n    let j = 0\\n\\n    if (len === 1 && citations[j] === 0) return 0\\n    if (len === 1) return i\\n\\n    const sortedArray = citations.sort((a, b) => b - a)\\n\\n    while(j < len) {\\n        const el = sortedArray[j]\\n        if (el === i) return i\\n        if (len === i && el > i) return i\\n        if (len === i && el < i) return i - 1\\n        if (el < i) return i - 1\\n        i++\\n        j++\\n    }\\n\\n    return i\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3557783,
                "title": "python-single-line-solution",
                "content": "# Intuition\\nTop `i+1` papers have a h-index of `min(i+1, citations[i])` since they have at least `i+1` papers with h-index of `citations[i]`.\\n\\n# Code\\n```\\nfrom sortedcontainers import SortedList\\n\\nclass Solution:\\n    def hIndex(self, citations: List[int]) -> int:\\n        return max(min(i+1, c) for i, c in enumerate(sorted(citations, reverse=True)))\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nfrom sortedcontainers import SortedList\\n\\nclass Solution:\\n    def hIndex(self, citations: List[int]) -> int:\\n        return max(min(i+1, c) for i, c in enumerate(sorted(citations, reverse=True)))\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3518414,
                "title": "simplest-intuitive-java-solution-5-lines-of-logic",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nWe have to find the h_index such that there are atleast h citations for atleast h papers. We can achieve this by sorting.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nWhen we sort the array, we can find the remaining papers with atleast h citations for a given h.\\n\\nExample:\\n[3, 0, 1, 6, 5]\\n\\nWhen we sort this array, we get\\n[0, 1, 3, 5, 6]\\n\\nSo we have to find the maximum h value such that there are atleast h papers with h citations. We can find this by finding the remaining number of papers. As the array is sorted, the remaining papers will always have atleast h citations.(i.e. h or more)\\n\\nLets say, n is the number of research papers.\\n\\nIn the given array,\\n\\nFor 0, \\n\\n0 is not greater than the remaining number of papers which is n-i = 5-0 = 5. (0 < 5)\\nSo we continue.\\n\\nSame with 1. n-i = 5-1 = 4. (1 < 4)\\n\\nFor 3, there are atleast 3 papers with atleast 3 citations (n-i = 5-2 = 3) (3 == 3)\\n\\nMath.max (3,0) = 3\\nSo h_index = 3\\n\\nWe can break the loop at this point because 3 is the maximum value which has atleast 3 citations.\\n\\nWhen we go to the next element 5, there are only 2 papers with atleast 5 citations. For 5 to be the h_index, there should be atleast 5 papers. Therefore, it cant be the h_index.\\n\\nWe are skipping 0 and 1 because, though there are atleast 0 paper with atleast 0 citations & atleast 1 paper with atleast 1 citation, it cant be the maximum value.\\n\\n# Complexity\\n- Time complexity: O(n*logn)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1) -> No extra space is used\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int hIndex(int[] citations) {\\n        int n = citations.length;\\n        int h_index = 0;\\n        // Sorting the array\\n        Arrays.sort(citations);\\n        // Finding the citations[i] say t such that the remaining papers have atleast t citations\\n        for (int i=0; i<citations.length; i++) {\\n            if (citations[i] >= n-i) {\\n                h_index = Math.max(n-i, h_index);\\n                break;\\n            }\\n        }\\n        return h_index;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int hIndex(int[] citations) {\\n        int n = citations.length;\\n        int h_index = 0;\\n        // Sorting the array\\n        Arrays.sort(citations);\\n        // Finding the citations[i] say t such that the remaining papers have atleast t citations\\n        for (int i=0; i<citations.length; i++) {\\n            if (citations[i] >= n-i) {\\n                h_index = Math.max(n-i, h_index);\\n                break;\\n            }\\n        }\\n        return h_index;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3274633,
                "title": "solution-using-sort-and-binary-search",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\nO(nlogn)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\npublic class Solution {\\n    public int HIndex(int[] citations) {\\n        Array.Sort(citations);\\n        int min = 0, n = citations.Length, max = n - 1;\\n        \\n        while(min <= max){\\n            int mid = (min + max)/2;\\n            if(citations[mid] < n - mid)\\n                min = mid + 1;\\n            else\\n                max = mid - 1;\\n        }\\n        return n - min;\\n    }\\n\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution {\\n    public int HIndex(int[] citations) {\\n        Array.Sort(citations);\\n        int min = 0, n = citations.Length, max = n - 1;\\n        \\n        while(min <= max){\\n            int mid = (min + max)/2;\\n            if(citations[mid] < n - mid)\\n                min = mid + 1;\\n            else\\n                max = mid - 1;\\n        }\\n        return n - min;\\n    }\\n\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3064834,
                "title": "c-4-lines-sort-and-traverse-o-nlogn",
                "content": "```c++\\nclass Solution {\\npublic:\\n    int hIndex(vector<int>& citations) {\\n        sort(citations.begin(), citations.end());\\n        int ans = citations.size() + 1;\\n        for (int i = 0; i < citations.size(); i++) {\\n            if (citations[i] >= ans) return ans;\\n            ans--;\\n        }\\n        return ans;\\n    }\\n};\\n```\\n\\n**For more solutions, check out this \\uD83C\\uDFC6  [GITHUB REPOSITORY](https://github.com/MuhtasimTanmoy/playground) with over 1500+ solutions.**",
                "solutionTags": [],
                "code": "```c++\\nclass Solution {\\npublic:\\n    int hIndex(vector<int>& citations) {\\n        sort(citations.begin(), citations.end());\\n        int ans = citations.size() + 1;\\n        for (int i = 0; i < citations.size(); i++) {\\n            if (citations[i] >= ans) return ans;\\n            ans--;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2951798,
                "title": "python3-using-heaps",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nUse heaps\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def hIndex(self, citations: List[int]) -> int:\\n\\n        cit = [-i for i in citations]\\n\\n        heapq.heapify(cit)\\n\\n        res = 0\\n        i = 1\\n        while i <= len(citations):\\n            val = heapq.heappop(cit)\\n\\n            if -val < i:\\n                break\\n            else:\\n                res = i\\n            i += 1\\n        \\n        return res\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def hIndex(self, citations: List[int]) -> int:\\n\\n        cit = [-i for i in citations]\\n\\n        heapq.heapify(cit)\\n\\n        res = 0\\n        i = 1\\n        while i <= len(citations):\\n            val = heapq.heappop(cit)\\n\\n            if -val < i:\\n                break\\n            else:\\n                res = i\\n            i += 1\\n        \\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2946516,
                "title": "c-binary-search-easy-approach",
                "content": "Here is my c++ code for this problem.\\n\\n# Complexity\\n- Time complexity:O(logN)+O(nlogn)\\n\\n- Space complexity:O(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int hIndex(vector<int>& citations) {\\n        sort(citations.begin(), citations.end());\\n        int i=0, j=1e9, n=citations.size(), ans=0;\\n        while(i<=j){\\n            int mid=i+(j-i)/2;\\n            int cnt=lower_bound(citations.begin(), citations.end(), mid)-citations.begin();\\n            if(n-cnt>=mid){\\n                ans=mid;\\n                i=mid+1;\\n            }\\n            else{\\n                j=mid-1;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Binary Search",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int hIndex(vector<int>& citations) {\\n        sort(citations.begin(), citations.end());\\n        int i=0, j=1e9, n=citations.size(), ans=0;\\n        while(i<=j){\\n            int mid=i+(j-i)/2;\\n            int cnt=lower_bound(citations.begin(), citations.end(), mid)-citations.begin();\\n            if(n-cnt>=mid){\\n                ans=mid;\\n                i=mid+1;\\n            }\\n            else{\\n                j=mid-1;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2927488,
                "title": "c-o-n-0ms-w-explanation",
                "content": "Just looking at the problem you can guess you need to sort.\\nDoing some examples shows the information you need is always held further down the array.\\n\\n--- begin example ---\\n[3,0,6,1,5]\\nsorted is [0,1,3,5,6]\\n\\nLook at the two conditions for a valid h-index for h\\'s starting at 0.\\n\\nh=0\\n1 - 0 papers have atleast 0 citations, true (0,1,3,5,6)\\n2 - 5 - 0 = 5 papers have no more than 0 citation, false (1,3,5,6)\\nh=1\\n1 - 1 papers have atleast 1 citation, true (1,3,5,6)\\n2 - 5 - 1 = 4 papers have no mare than 1 citation, false (3,5,6)\\nh=2\\n1 - true (3,5,6) \\n2 - true (3,5,6)\\nh=3\\n1 - true (3,5,6) \\n2 - true (5,6)\\nh=4\\n1 - false (5,6)\\n2 - true (5,6)\\n\\ncontinue to h=1000 since h is bounded by number of citations.\\n--- end example --- \\n\\nAt every h we only need to know about papers with >= h citations. Let\\'s us conclude sorting is not actually needed and can simply keep track of in array the frequency of which number of citations occur. Bringing complexity from nlgn to n;\\n\\nDoing more examples should bring out two rules when to determine when a value of h is valid.\\n1. \\\\>= h papers have >= h citations each\\n2. number of papers > h is <= h\\n\\nUsing these rules on an example\\n--- begin example ---\\n [3,0,6,1,5]\\n \\nCan create frequency array where index i is a h value and arr[i] is the number of times a paper with i citations occured.\\n1,1,0,1,0,1,1,0,... length 1000\\n\\nThen creating arrays based of the two rules\\n(1) At index i, arr[i] is number of papers with citations >= i\\n5,4,4,3,3,2,1,0,...\\n(2) At index i, arr[i] is the number of papers with citations > i\\n4,3,3,2,2,1,0,0,...\\n\\nCan see array (2) is just array (1) shifterd one to the left.\\n--- end example ---\\n\\nCode\\n```\\n        vector<int> v(1028, 0);\\n        \\n        for (int i : citations) ++v[i];\\n        \\n        int total = size(citations), prev = 0;\\n        for (int i = 0; i != size(v); ++i){\\n            int temp = v[i];\\n            total -= prev;\\n            v[i] = total;\\n            prev = temp;\\n        }\\n        \\n        int res = 0;\\n        for (int i = 0; v[i]; ++i) {\\n            if (v[i] >= i && v[i + 1] <= i) {\\n                res = i;\\n            }\\n        }\\n        \\n        return res;\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\n        vector<int> v(1028, 0);\\n        \\n        for (int i : citations) ++v[i];\\n        \\n        int total = size(citations), prev = 0;\\n        for (int i = 0; i != size(v); ++i){\\n            int temp = v[i];\\n            total -= prev;\\n            v[i] = total;\\n            prev = temp;\\n        }\\n        \\n        int res = 0;\\n        for (int i = 0; v[i]; ++i) {\\n            if (v[i] >= i && v[i + 1] <= i) {\\n                res = i;\\n            }\\n        }\\n        \\n        return res;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2226072,
                "title": "java-solution-using-typical-binary-search-easy-to-understand-beginner-friendly",
                "content": "Here I am just counting how many elements are greater than or equal to mid. And if this count is greater than or equal to mid, i am soring mid in ans and checking for right side for better ans.\\n```\\nclass Solution {\\n    public int hIndex(int[] citations) {\\n        int n = citations.length;\\n        int max=citations[0];\\n        for(int i=0;i<n;i++){\\n            max=Math.max(max,citations[i]);}\\n        int low=0;\\n        int high=max;\\n        int ans=low;\\n        while(low<=high){\\n            int mid = low+(high-low)/2;\\n            int k = find(citations,n,mid);\\n            if(k>=mid){\\n                ans=mid;\\n                low=mid+1;\\n            }\\n            else{\\n                high=mid-1;\\n            }\\n        }\\n        return ans;\\n    }\\n    public static int find(int arr[],int n,int mid){\\n        int count=0;\\n        for(int i=0;i<n;i++){\\n            if(arr[i]>=mid){\\n                count++;\\n            }\\n        }\\n        return count;\\n    }\\n}\\n//Please upvote if you find it helpful....Thank You..!",
                "solutionTags": [
                    "Java",
                    "Binary Search",
                    "Binary Tree"
                ],
                "code": "class Solution {\\n    public int hIndex(int[] citations) {\\n        int n = citations.length;\\n        int max=citations[0];\\n        for(int i=0;i<n;i++){\\n            max=Math.max(max,citations[i]);}",
                "codeTag": "Java"
            },
            {
                "id": 2101138,
                "title": "python-sorting-solution-with-explanation",
                "content": "Sort all the citations in descending order. Now iterate through all the citations starting from the largest one. Since we require ```h``` papers to have ```h``` citations atleast, we keep going onto smaller and smaller number of citations until we reach a point where the index (the number of papers) is greater than the number of citations.\\n\\nNote that at each point of iteration (until we stop), the number of papers covered so far (starting from the left-most index) are less than the value of the smallest citations encountered so far.\\nUpon encountering an index that\\'s greater than the number of citations, we can say that it was till the previous index that the constraint (that ```h``` number of papers need to have ```h``` citations atleast) was satisfied.\\n\\nHence it\\'s all the papers till the previous index that we need to count and return. To do that, we can simply return the index at which the constraint breaks, since because the indexing actually starts from ```0``` (meaning index ```5``` means we\\'re on the 6th element).\\n\\nIf we never encounter a point where the constraint breaks, then all the papers have very large number of citations (by large I mean the least value of the number of citations is greater than the number of papers themselves).\\n\\nFor example:\\n\\n```[103,102,101,100,99]```\\n\\nHere, there are just 5 papers but the least value of the number of citations is ```99```.\\n\\nIn this kind of scenario, we need to return the number of paper themselves, because it\\'s for certain then that the number of citations are greater than the number of papers themselves.\\n\\nSo, in the given example, we would return ```5```.\\n\\nHere\\'s the code for the same:\\n\\n    def hIndex(self, citations):\\n        citations.sort(reverse = True)\\n        i = 0\\n        for i,citation in enumerate(citations):\\n            if i >= citation:\\n                return i\\n        return i+1",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Sorting"
                ],
                "code": "```h```\n```h```\n```h```\n```h```\n```0```\n```5```\n```[103,102,101,100,99]```\n```99```\n```5```",
                "codeTag": "Unknown"
            },
            {
                "id": 2049204,
                "title": "java-simple-o-n-o-n-without-sorting",
                "content": "1. create a memo and increase the counter having value as index.\\n2. traverse throught the memo and if running sum is greater than the index, return the index.\\n```\\npublic int hIndex(int[] citations) {\\n        int[] memo = new int[1001];\\n        \\n        for(int i: citations)\\n            memo[i]++;\\n        \\n        int sum=0;\\n        for(int i=1000; i>=0; i--){\\n            sum += memo[i];\\n            if(sum >=i) return i;\\n        }\\n        \\n        return 0;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\npublic int hIndex(int[] citations) {\\n        int[] memo = new int[1001];\\n        \\n        for(int i: citations)\\n            memo[i]++;\\n        \\n        int sum=0;\\n        for(int i=1000; i>=0; i--){\\n            sum += memo[i];\\n            if(sum >=i) return i;\\n        }\\n        \\n        return 0;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2003487,
                "title": "c-intuitive-solution-with-comments",
                "content": "```\\nclass Solution {\\npublic:\\n    int hIndex(vector<int> &citations)\\n    {\\n        sort(citations.begin(), citations.end());\\n        int n = citations.size();\\n        for (int i = 0; i < n; ++i) {\\n            int hi = n-i;   // num papers with citations  >= citations[i]\\n            if (citations[i] >= hi) return hi; // there are atleast \"hi\" papers with citation >= citations[i] (and automatically there are n-hi papers with citations <= hi)\\n        }\\n        return 0;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int hIndex(vector<int> &citations)\\n    {\\n        sort(citations.begin(), citations.end());\\n        int n = citations.size();\\n        for (int i = 0; i < n; ++i) {\\n            int hi = n-i;   // num papers with citations  >= citations[i]\\n            if (citations[i] >= hi) return hi; // there are atleast \"hi\" papers with citation >= citations[i] (and automatically there are n-hi papers with citations <= hi)\\n        }\\n        return 0;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1971978,
                "title": "isn-t-the-second-example-incorrect",
                "content": "The second given example is [1,3,1], and the given answer is 1\\n\\nIn this example, according to the h-index definition, for 1 to be h-index, it has to meet the following two conditions which it doesn\\'t\\n\\nh=1, n=3\\n1 of 3 papers have at least 1 citation (x) -> all 3 papers have at least 1 citation\\n2 papers have no more than 1 citation each (x) -> All exceed or equal to 1\\n\\nI feel like I am the only one not understanding this question correctly.\\nCan someone please explain it for me? \\n\\n\\n",
                "solutionTags": [],
                "code": "The second given example is [1,3,1], and the given answer is 1\\n\\nIn this example, according to the h-index definition, for 1 to be h-index, it has to meet the following two conditions which it doesn\\'t\\n\\nh=1, n=3\\n1 of 3 papers have at least 1 citation (x) -> all 3 papers have at least 1 citation\\n2 papers have no more than 1 citation each (x) -> All exceed or equal to 1\\n\\nI feel like I am the only one not understanding this question correctly.\\nCan someone please explain it for me? \\n\\n\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 1774991,
                "title": "c-postfix-sum-o-n-t-c-o-max-element-s-c",
                "content": "```\\nclass Solution {\\npublic:\\n    int hIndex(vector<int>& citations) {\\n         int mx = *max_element(citations.begin(), citations.end());\\n         vector<int> post_sum(mx + 1, 0);\\n         \\n         for(int ele : citations){\\n             post_sum[ele]++;\\n         }\\n        \\n         for(int i=post_sum.size() - 2; i>0; i--){\\n              post_sum[i] = post_sum[i] + post_sum[i+1];\\n         }\\n        \\n         int ans = 0;\\n        \\n         for(int i=1; i<post_sum.size(); i++){\\n             if(post_sum[i] >= i){\\n                 ans = max(ans, i);\\n             }\\n         }\\n        return ans;\\n    }\\n};",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n    int hIndex(vector<int>& citations) {\\n         int mx = *max_element(citations.begin(), citations.end());\\n         vector<int> post_sum(mx + 1, 0);\\n         \\n         for(int ele : citations){\\n             post_sum[ele]++;\\n         }",
                "codeTag": "Java"
            },
            {
                "id": 1608438,
                "title": "why-use-count-sort-when-you-can-use-binary-search-100-percent",
                "content": "since the input size is small  we can use binary search\\ncount sort -> time O(N) space O(N)\\nbinary search  -> time(Nlog(N)) space O(1)\\n\\n```\\nclass Solution {\\npublic:\\n    int count(vector<int> arr, int val){\\n        int cnt = 0;\\n        for(int i = 0; i < arr.size(); ++i){\\n            if(arr[i] >= val){\\n                cnt++;\\n            }\\n        }\\n        return cnt;\\n    }\\n    \\n    int hIndex(vector<int>& arr) {\\n        int n = arr.size();\\n        int i = 0;\\n        int j = n;\\n        int ans = 0;\\n        while(i <= j){\\n            int mid = (i+j)/2;\\n            if(count(arr,mid) >= mid){\\n                ans = mid;\\n                i = mid+1;\\n            }\\n            else{\\n                j = mid-1;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Binary Tree",
                    "Counting Sort"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int count(vector<int> arr, int val){\\n        int cnt = 0;\\n        for(int i = 0; i < arr.size(); ++i){\\n            if(arr[i] >= val){\\n                cnt++;\\n            }\\n        }\\n        return cnt;\\n    }\\n    \\n    int hIndex(vector<int>& arr) {\\n        int n = arr.size();\\n        int i = 0;\\n        int j = n;\\n        int ans = 0;\\n        while(i <= j){\\n            int mid = (i+j)/2;\\n            if(count(arr,mid) >= mid){\\n                ans = mid;\\n                i = mid+1;\\n            }\\n            else{\\n                j = mid-1;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1546654,
                "title": "no-binary-search-easy-c",
                "content": "Idea- since range of numbers is upto 5000 , first make array which will contain count of each number.\\n\\ne.g-  3 0 6 1 5 \\n        here max number is 6 so we will make array of size 7. \\n\\t\\tthis array will look like this\\n\\t\\t0->1\\n\\t\\t1->1\\n\\t\\t2->0\\n\\t\\t3->1\\n\\t\\t4->0\\n\\t\\t5->1\\n\\t\\t6->1\\n\\tnow start from the end of this new array, take a count of citations, add cnt[i] to count for every i and when condition count>=i is met that i is your answer.\\n\\t\\t\\n\\t\\t\\n\\t\\t\\n\\t\\t```\\n\\t\\tclass Solution {\\n\\t\\tpublic:\\n    \\n\\t\\tint hIndex(vector<int>& c) {\\n        \\n        int max=0;\\n        for(int i=0;i<c.size();i++)\\n        {\\n            \\n            if(max<c[i])\\n            {\\n                max=c[i];\\n            }\\n        }\\n        \\n        vector<int>count(max+1,0);\\n        \\n        for(int i=0;i<c.size();i++)\\n        {\\n            count[c[i]]++;\\n        }\\n        \\n        int cnt=0;\\n        \\n        for(int i=max;i>=0;i--)\\n        {\\n            cnt+=count[i];\\n            \\n            if(cnt>=i)\\n            {\\n                return i;\\n            }\\n        }\\n        \\n        \\n        return 0;\\n        \\n\\t\\t}\\n\\t\\t};\\n\\t\\t```",
                "solutionTags": [
                    "C",
                    "Counting Sort"
                ],
                "code": "```\\n\\t\\tclass Solution {\\n\\t\\tpublic:\\n    \\n\\t\\tint hIndex(vector<int>& c) {\\n        \\n        int max=0;\\n        for(int i=0;i<c.size();i++)\\n        {\\n            \\n            if(max<c[i])\\n            {\\n                max=c[i];\\n            }\\n        }\\n        \\n        vector<int>count(max+1,0);\\n        \\n        for(int i=0;i<c.size();i++)\\n        {\\n            count[c[i]]++;\\n        }\\n        \\n        int cnt=0;\\n        \\n        for(int i=max;i>=0;i--)\\n        {\\n            cnt+=count[i];\\n            \\n            if(cnt>=i)\\n            {\\n                return i;\\n            }\\n        }\\n        \\n        \\n        return 0;\\n        \\n\\t\\t}\\n\\t\\t};\\n\\t\\t```",
                "codeTag": "Java"
            },
            {
                "id": 1370235,
                "title": "question-description-is-wrong",
                "content": "I wonder why don\\'t they just copy and paste the definition of H index from WIKI, because the description in problem is wrong.\\nIn wiki:\\n```\\nThe h-index is defined as the maximum value of h such that the given author/journal has published at least h papers that have each been cited at least h times.\\n```\\nBut in question description:\\n```\\nA scientist has an index h if h of their n papers have at least h citations each, and the other n \\u2212 h papers have no more than h citations each.\\n```\\nBut it should be\\n```\\nA scientist has an index h if at least h of their n papers have at least h citations each...\\n```\\nHehe, it takes me a bit time to figure out. Am I the only one notice this?",
                "solutionTags": [],
                "code": "```\\nThe h-index is defined as the maximum value of h such that the given author/journal has published at least h papers that have each been cited at least h times.\\n```\n```\\nA scientist has an index h if h of their n papers have at least h citations each, and the other n \\u2212 h papers have no more than h citations each.\\n```\n```\\nA scientist has an index h if at least h of their n papers have at least h citations each...\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1003285,
                "title": "java-0-ms-sorting-binary-search",
                "content": "```\\nclass Solution {\\n    public int hIndex(int[] nums) {\\n        int n = nums.length;\\n        int left = 0, right = n-1;\\n\\n        Arrays.sort(nums);\\n        while(left <= right){\\n            int mid = left + (right-left)/2;\\n            if(nums[mid] == n-mid){\\n                return nums[mid];\\n            } else if(nums[mid] > n-mid){\\n                right = mid-1;\\n            } else {\\n                left = mid+1;\\n            }\\n        }\\n\\n        return n-left;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Sorting",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\n    public int hIndex(int[] nums) {\\n        int n = nums.length;\\n        int left = 0, right = n-1;\\n\\n        Arrays.sort(nums);\\n        while(left <= right){\\n            int mid = left + (right-left)/2;\\n            if(nums[mid] == n-mid){\\n                return nums[mid];\\n            } else if(nums[mid] > n-mid){\\n                right = mid-1;\\n            } else {\\n                left = mid+1;\\n            }\\n        }\\n\\n        return n-left;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 786707,
                "title": "java-accepted-with-approach-0-ms-binary-search",
                "content": "# ***Please upvote if helpful!!!***\\n * Problem is same as h-index 2 .\\n* We need to sort the elements and use binary search.\\n* If you are unable to understand the code. This is the best video : https://www.youtube.com/watch?v=CjKJDloMnwE . Very clear approach. and excellent explaination .\\n\\nCode : \\n\\n```\\n\\t\\tArrays.sort(citations);\\n        int low = 0;\\n        int high = citations.length - 1;\\n\\n        while (low <= high) {\\n            int mid = low + (high - low) / 2;\\n\\n            final int numberOfCitationsGreaterThanOrEqualToCurrentMidElement = citations.length - mid; // array is ascending order. .\\n            // so the number of elements after the mid elements is the number of citations greater than equal to the mid Element.\\n            if (citations[mid] == numberOfCitationsGreaterThanOrEqualToCurrentMidElement)\\n                return citations[mid];\\n            else if (citations[mid] < numberOfCitationsGreaterThanOrEqualToCurrentMidElement) {\\n                low = mid + 1;\\n            } else {\\n                high = mid - 1;\\n            }\\n        }\\n        return citations.length - low;\\n```",
                "solutionTags": [
                    "Java",
                    "Binary Tree"
                ],
                "code": "```\\n\\t\\tArrays.sort(citations);\\n        int low = 0;\\n        int high = citations.length - 1;\\n\\n        while (low <= high) {\\n            int mid = low + (high - low) / 2;\\n\\n            final int numberOfCitationsGreaterThanOrEqualToCurrentMidElement = citations.length - mid; // array is ascending order. .\\n            // so the number of elements after the mid elements is the number of citations greater than equal to the mid Element.\\n            if (citations[mid] == numberOfCitationsGreaterThanOrEqualToCurrentMidElement)\\n                return citations[mid];\\n            else if (citations[mid] < numberOfCitationsGreaterThanOrEqualToCurrentMidElement) {\\n                low = mid + 1;\\n            } else {\\n                high = mid - 1;\\n            }\\n        }\\n        return citations.length - low;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 786250,
                "title": "c-h-index-100-o-n-o-n",
                "content": "First, count the number of citations for each possible h (clamped to the number of citations). Then build a prefix sum from the right by initially setting h = n and decrementing h until sum >= h. As soon as sum >= h, we know that 1) there are at least h papers with h citations each and 2) there are no other papers that have more than h citations left, so it\\'s a valid solution.\\n\\n```\\nclass Solution {\\npublic:\\n    // Time: O(n)\\n    // Space: O(n)\\n    int hIndex(vector<int>& citations) {\\n        \\n        if (citations.empty()) return 0;\\n        \\n        const int n = citations.size();\\n        vector<int> counts(n+1, 0);\\n        for (int i = 0; i < n; ++i) {\\n            int h = min(citations[i], n);\\n            counts[h]++;\\n        }\\n        \\n        int h = n;\\n        for (int sum = 0; h > 0; --h) {\\n            sum += counts[h];\\n            if (sum >= h) {\\n                break;\\n            }\\n        }\\n                \\n        return h;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    // Time: O(n)\\n    // Space: O(n)\\n    int hIndex(vector<int>& citations) {\\n        \\n        if (citations.empty()) return 0;\\n        \\n        const int n = citations.size();\\n        vector<int> counts(n+1, 0);\\n        for (int i = 0; i < n; ++i) {\\n            int h = min(citations[i], n);\\n            counts[h]++;\\n        }\\n        \\n        int h = n;\\n        for (int sum = 0; h > 0; --h) {\\n            sum += counts[h];\\n            if (sum >= h) {\\n                break;\\n            }\\n        }\\n                \\n        return h;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 786145,
                "title": "java-0ms-beats-100-sorting-then-binary-search",
                "content": "```\\nclass Solution {\\n    public int hIndex(int[] citations) {\\n        Arrays.sort(citations);\\n        int n = citations.length;\\n        int left = 0;\\n        int right = n - 1;\\n        \\n        while(left <= right) {\\n            int mid = left + (right - left) / 2;\\n            if(citations[mid] < n - mid)\\n                left = mid + 1;\\n            else\\n                right = mid - 1;\\n        }\\n        return n - left;\\n    }\\n}",
                "solutionTags": [
                    "Java",
                    "Binary Tree"
                ],
                "code": "class Solution {\\n    public int hIndex(int[] citations) {\\n        Arrays.sort(citations);\\n        int n = citations.length;\\n        int left = 0;\\n        int right = n - 1;\\n        \\n        while(left <= right) {\\n            int mid = left + (right - left) / 2;\\n            if(citations[mid] < n - mid)\\n                left = mid + 1;\\n            else\\n                right = mid - 1;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 786032,
                "title": "h-index-python-98",
                "content": "```\\nclass Solution:\\n    def hIndex(self, citations: List[int]) -> int:\\n        citations.sort(reverse=True)\\n        c=0\\n        for i in range(len(citations)):\\n            if citations[i]>=i+1:\\n                c+=1\\n            else:\\n                break\\n        return c\\n        \\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def hIndex(self, citations: List[int]) -> int:\\n        citations.sort(reverse=True)\\n        c=0\\n        for i in range(len(citations)):\\n            if citations[i]>=i+1:\\n                c+=1\\n            else:\\n                break\\n        return c\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 786007,
                "title": "c-not-all-sorting-are-equal-o-nlogn-vs-o-n",
                "content": "Solution 1: O(NlogN) sorting soltuion\\n```\\nclass Solution {\\npublic: //Time/Space: O(NlogN); O(1)\\n    int hIndex(vector<int>& citations) {\\n        sort(citations.rbegin(), citations.rend()); // descending order\\n        int ans = 0;\\n        for(int i = 0; i < citations.size(); i++) // linear search\\n            if(citations[i]>i) ans++;        \\n        return ans;        \\n    }\\n};\\n```\\n\\nSolution 2: O(N) counting sorting soltuion\\nRef: https://leetcode.com/problems/h-index/solution/\\n```\\nclass Solution { // Counting sort\\npublic: // Time/Space: O(N); O(N)\\n    int hIndex(vector<int>& citations) {\\n        const int n = citations.size();\\n        vector<int> paper(n+1); // paper[i]: # of paper with i-citation\\n        for(int c: citations) paper[min(n, c)]++; // compress range with cutting-off trick, then count\\n        int k = n;\\n        for(int s = paper[k]; k > s; s += paper[k]) k--;\\n        return k; // when hit here: k <= s, then k is the answer, i.e., h-index\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic: //Time/Space: O(NlogN); O(1)\\n    int hIndex(vector<int>& citations) {\\n        sort(citations.rbegin(), citations.rend()); // descending order\\n        int ans = 0;\\n        for(int i = 0; i < citations.size(); i++) // linear search\\n            if(citations[i]>i) ans++;        \\n        return ans;        \\n    }\\n};\\n```\n```\\nclass Solution { // Counting sort\\npublic: // Time/Space: O(N); O(N)\\n    int hIndex(vector<int>& citations) {\\n        const int n = citations.size();\\n        vector<int> paper(n+1); // paper[i]: # of paper with i-citation\\n        for(int c: citations) paper[min(n, c)]++; // compress range with cutting-off trick, then count\\n        int k = n;\\n        for(int s = paper[k]; k > s; s += paper[k]) k--;\\n        return k; // when hit here: k <= s, then k is the answer, i.e., h-index\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 785724,
                "title": "java-100-basic-explanation-no-more-confusion-about-problem-statement",
                "content": "**If helpful please do Upvote!!!**\\n```\\nclass Solution {\\n    public int hIndex(int[] citations) {\\n        //Problem Statement:-\\n        //In this we have to find the H-index , A number x is said to be H-index ,if and only if one researcher publish x or more quality(citations) papers ,at least x times.\\n        \\n        //example :- \\n        //arr[3,1,2,3,2]\\n        // In this 3 occur 2 times -> 3 is not H-index because 3 not occur atleast 3 times\\n        //         2 occur 2 times -> 2 is H-index because 2 occur at least 2 time (and it is greater number among H-index eligible numbers , So we consider it as H-index )\\n        //         1 occur 1 time ->  1 is H-index because 1 occur at least 1 time (but we don\\'t consider it as we it is smaller than and we want Greatest number)\\n        \\n        \\n        //Solution:- (Bucket Sort) O(n) complexity , we can also use sorting but it takes O(nlogn)\\n        //idea:-.\\n        //Step-1 (populate bucket array)\\n        //we make the bucket array for n+1 size\\n        //For every number in citations we increament that particular index in our bucket array\\n        //for all numbers which are greater than our index array increament our last index(that is n)\\n        \\n        //Step-2 (Find the H-index)\\n        //Start from last and add the value to the countSum and when we get countSum greater than or equal to index return that index\\n        //(means we are able to find atleast i numbers)\\n        int n=citations.length;\\n        int[] bucket=new int[n+1];\\n        for(int i=0;i<n;i++){\\n            if(citations[i]>n){\\n                bucket[n]++;\\n            }\\n            else{\\n                bucket[citations[i]]++;\\n            }\\n        }\\n        int countSum=0;\\n        for(int i=n;i>=0;i--){\\n            countSum+=bucket[i];\\n            if(countSum>=i){\\n                return i;\\n            }\\n        }\\n        return 0;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int hIndex(int[] citations) {\\n        //Problem Statement:-\\n        //In this we have to find the H-index , A number x is said to be H-index ,if and only if one researcher publish x or more quality(citations) papers ,at least x times.\\n        \\n        //example :- \\n        //arr[3,1,2,3,2]\\n        // In this 3 occur 2 times -> 3 is not H-index because 3 not occur atleast 3 times\\n        //         2 occur 2 times -> 2 is H-index because 2 occur at least 2 time (and it is greater number among H-index eligible numbers , So we consider it as H-index )\\n        //         1 occur 1 time ->  1 is H-index because 1 occur at least 1 time (but we don\\'t consider it as we it is smaller than and we want Greatest number)\\n        \\n        \\n        //Solution:- (Bucket Sort) O(n) complexity , we can also use sorting but it takes O(nlogn)\\n        //idea:-.\\n        //Step-1 (populate bucket array)\\n        //we make the bucket array for n+1 size\\n        //For every number in citations we increament that particular index in our bucket array\\n        //for all numbers which are greater than our index array increament our last index(that is n)\\n        \\n        //Step-2 (Find the H-index)\\n        //Start from last and add the value to the countSum and when we get countSum greater than or equal to index return that index\\n        //(means we are able to find atleast i numbers)\\n        int n=citations.length;\\n        int[] bucket=new int[n+1];\\n        for(int i=0;i<n;i++){\\n            if(citations[i]>n){\\n                bucket[n]++;\\n            }\\n            else{\\n                bucket[citations[i]]++;\\n            }\\n        }\\n        int countSum=0;\\n        for(int i=n;i>=0;i--){\\n            countSum+=bucket[i];\\n            if(countSum>=i){\\n                return i;\\n            }\\n        }\\n        return 0;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 785716,
                "title": "sorting-binary-search-o-n-logn",
                "content": "```\\nclass Solution {\\npublic:\\n    int hIndex(vector<int>& arr) {\\n        sort(arr.begin(), arr.end(), greater<int>());\\n        int n = arr.size();\\n        int ans = 0;\\n        int lo=0, hi=n-1;\\n        while(lo<=hi){\\n            int mid = (lo+hi)/2;\\n            int cur_idx = min(arr[mid], mid+1);\\n            ans = max(ans, cur_idx);\\n\\t\\t\\t\\n            if(arr[mid]>mid)lo = mid+1;\\n            else hi = mid-1;\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int hIndex(vector<int>& arr) {\\n        sort(arr.begin(), arr.end(), greater<int>());\\n        int n = arr.size();\\n        int ans = 0;\\n        int lo=0, hi=n-1;\\n        while(lo<=hi){\\n            int mid = (lo+hi)/2;\\n            int cur_idx = min(arr[mid], mid+1);\\n            ans = max(ans, cur_idx);\\n\\t\\t\\t\\n            if(arr[mid]>mid)lo = mid+1;\\n            else hi = mid-1;\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 693946,
                "title": "javascript-two-approaches-1-with-o-n-time-o-n-space-and-another-with-o-n-log-n-time",
                "content": "```\\n\\n// how to do better than O(n*logn)?\\n// most h can be is total\\n// \\'bucket\\' sort.  bucket size bounded by total papers or citations.length\\n// Much better at O(n) time complexity with extra O(n) space\\nvar hIndex = function(citations) {\\n    let total = citations.length\\n    if (total === 0) return 0\\n    let bucket = new Array(total+1).fill(0)\\n    for (let i = 0; i < total; i++){\\n        if (citations[i] >= total){\\n            bucket[total]++\\n        } else {\\n            bucket[citations[i]]++\\n        }\\n    }\\n    // console.log(bucket)\\n    let sum = 0\\n    for (let i = 0; i < bucket.length; i++){\\n        sum+=bucket[i]\\n        if (sum >= total-i) {\\n            return i\\n        }\\n    }\\n    return 0\\n}\\n```\\nnaive approach  is by sorting which takes O(n log n) time, & then search either linearly at O(n) or binary search O(log n). Overall time is still dominated by sort O(n log n) though\\n```\\n var hIndex = function(citations) {\\n     let total = citations.length\\n     if (total === 0) return 0\\n    \\n     citations.sort((a,b) => a - b)\\n     let left = 0, right = total - 1\\n     while (left <= right){\\n         let mid = left + Math.floor((right - left) / 2)\\n         if (citations[mid] === total - mid) return total - mid\\n         else if (citations[mid] < total - mid){\\n             left = mid + 1\\n         } else{\\n             right = mid - 1\\n         }\\n     }\\n     return total - left\\n };\\n```",
                "solutionTags": [],
                "code": "```\\n\\n// how to do better than O(n*logn)?\\n// most h can be is total\\n// \\'bucket\\' sort.  bucket size bounded by total papers or citations.length\\n// Much better at O(n) time complexity with extra O(n) space\\nvar hIndex = function(citations) {\\n    let total = citations.length\\n    if (total === 0) return 0\\n    let bucket = new Array(total+1).fill(0)\\n    for (let i = 0; i < total; i++){\\n        if (citations[i] >= total){\\n            bucket[total]++\\n        } else {\\n            bucket[citations[i]]++\\n        }\\n    }\\n    // console.log(bucket)\\n    let sum = 0\\n    for (let i = 0; i < bucket.length; i++){\\n        sum+=bucket[i]\\n        if (sum >= total-i) {\\n            return i\\n        }\\n    }\\n    return 0\\n}\\n```\n```\\n var hIndex = function(citations) {\\n     let total = citations.length\\n     if (total === 0) return 0\\n    \\n     citations.sort((a,b) => a - b)\\n     let left = 0, right = total - 1\\n     while (left <= right){\\n         let mid = left + Math.floor((right - left) / 2)\\n         if (citations[mid] === total - mid) return total - mid\\n         else if (citations[mid] < total - mid){\\n             left = mid + 1\\n         } else{\\n             right = mid - 1\\n         }\\n     }\\n     return total - left\\n };\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 675332,
                "title": "c-o-n-time",
                "content": "```\\nclass Solution {\\npublic:\\n    int hIndex(vector<int>& c) {\\n        int n = c.size();\\n        vector<int> res(n+1,0);\\n        for(auto x: c){\\n            x >= n ? res[n]++ : res[x]++;\\n        }\\n        if(res[n]==n) return n;\\n        for(int i=n-1;i>=0;i--){\\n            res[i] += res[i+1];\\n            if(res[i] >= i) return i;\\n        }\\n        return 0;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int hIndex(vector<int>& c) {\\n        int n = c.size();\\n        vector<int> res(n+1,0);\\n        for(auto x: c){\\n            x >= n ? res[n]++ : res[x]++;\\n        }\\n        if(res[n]==n) return n;\\n        for(int i=n-1;i>=0;i--){\\n            res[i] += res[i+1];\\n            if(res[i] >= i) return i;\\n        }\\n        return 0;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 605785,
                "title": "o-n-java-solution",
                "content": "```\\nclass Solution {\\n    public int hIndex(int[] citations) {\\n        int[] count = new int[citations.length + 1];\\n        \\n        for (int c : citations)\\n            count[Math.min(count.length - 1, c)]++;\\n        \\n        int sum = 0;\\n        for (int i = count.length - 1; i >=0; i--) {\\n            sum += count[i];\\n            if (sum >= i)\\n                return i;\\n        }\\n        \\n        return 0;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int hIndex(int[] citations) {\\n        int[] count = new int[citations.length + 1];\\n        \\n        for (int c : citations)\\n            count[Math.min(count.length - 1, c)]++;\\n        \\n        int sum = 0;\\n        for (int i = count.length - 1; i >=0; i--) {\\n            sum += count[i];\\n            if (sum >= i)\\n                return i;\\n        }\\n        \\n        return 0;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 479756,
                "title": "single-pass-o-n-solution-very-easy-to-understand-and-works-for-online-data",
                "content": "I discovered this problem when I was practicing Google\\'s Kickstart archives. I came up with this O(n) solution after re-attempting the problem after a few days.\\n\\nWe create an empty list. Let\\'s call it `greaterThanMax`. As we iterate through the array, we keep track of the maximum possible H-Index till i\\'th citations (I\\'ll explain later how). And in our list `greaterThanMax`, we maintain elements that are **more than or equal to our current maximum H-index**.\\n\\nLet\\'s take this example : `[1,2,3,3,1,4,4,4,10,12,0,14,5]`\\n\\n**0th iteration:**\\n`[1,2,3,3,1,4,4,4,10,12,0,14,5]`\\n`greaterThanMax : []`\\n`h_index: 0`\\n\\n**1st iteration:**\\nWe see that 1 is more than current h_index. We add 1 to our list, and h_index is equal to the size of the list.\\n`[*1*,2,3,3,1,4,4,4,10,12,0,14,5]`\\n`greaterThanMax : [1]`\\n `h_index=1`\\n\\n **2nd iteration:**\\nHere notice that, we can add 2 to our list. But we are now limited by the least element in our list, 1. No matter what we add, h_index will always be limited by that element. So, **replace** 1 with 2. Again, h_index is equal to the size of the `greaterThanMax` list.\\n `[1,*2*,3,3,1,4,4,4,10,12,0,14,5]`\\n `greaterThanMax : [2]`\\n  `h_index=1`\\n \\n**3rd iteration**:\\nSimilarly, we add 3 and update h_index:\\n `[1,2,*3*,3,1,4,4,4,10,12,0,14,5]`\\n `greaterThanMax : [2,3]`\\n  `h_index=2`\\n \\n**4th iteration:** (important)\\n `[1,2,3,*3*,1,4,4,4,10,12,0,14,5]`\\n `greaterThanMax : [2,3,3]` <- WRONG\\n  `h_index=3` <- WRONG\\n\\nWe encounter 3. However, if we straightaway add it to the list and increment h_index to 3 we will break our constraint -  *All elements in the list must be more than or equal current h_index*. We cannot increase h_index. However, we can improve our state by replacing 2 by 3.\\n\\n `[1,2,3,*3*,1,4,4,4,10,12,0,14,5]`\\n `greaterThanMax : [3,3]`\\n  `h_index=2`\\n\\nOur h_index stays the same, but we have replaced 2 with 3, and we are no longer limited by that element. Any time we encounter an element more than our current h_index, if there\\'s an element equal h_index, we replace it with this larger element. (This way, in future iterations we are no longer limited by that least element.) Otherwise, we simply add the element. \\n\\nNow, follow this logic till the end:\\n 5. `greaterThanMax : [3,3]`  - `h_index=2`\\n 6. `greaterThanMax : [3,3,4]`  - `h_index=3`\\n 7. `greaterThanMax : [3,4,4]`  - `h_index=3`\\n 8. `greaterThanMax : [4,4,4]`  - `h_index=3`\\n 9. `greaterThanMax : [4,4,4,10]`  - `h_index=4`\\n 10. `greaterThanMax : [12,4,4,10]`  `h_index=4`\\n 11. `greaterThanMax : [12,4,4,10]`  `h_index=4`\\n 12. `greaterThanMax : [12,14,4,10]`  `h_index=4`\\n 13. `greaterThanMax : [12,14,5,10]`  `h_index=4`\\n\\nWe can use this logic and implement it with a minHeap. However, we can improve it further. We don\\'t really need to maintain a minHeap list to figure out our limiting element. We know that the least possible element that can be in our `greaterThanMax` list is always the h_index. So all we need to know is how many elements in our list are equal to h_index. We can use a hash table to store this.\\n\\nWhenever we encounter an element greater than h_index, we check if there is an element with the same value as h_index in the table. If so, we cannot increase h_index, but we can improve our state. The least element can be replaced by our current greater element, and we do that by decrementing the value in the table at h_index.\\n\\nWe also put this larger element in our hash table and increment it by one, since this element can be the least limiting element in the future.\\n\\nFinally, here\\'s the code that implements this:\\n\\n```\\nclass Solution {\\n    public int hIndex(int[] citations) {\\n        int N = citations.length;\\n\\t\\t\\n\\t\\t/* h_index can range from 0 to number of citations, hence the size+1 */\\n        int[] table = new int[N+1];\\n        \\n\\t\\t/* maintains max possible H-Index at ith index */\\n\\t\\tint max = 0;\\n        \\n\\t\\tfor (int i = 0; i < N; i++) {\\n            int x = citations[i];\\n        \\n\\t\\t\\t/* elements less than current h_index cannot affect its value */\\n\\t\\t\\tif(x<=max) continue;\\n            \\n\\t\\t\\t/* element which is greater than no. of citations is equivalent to maximum h_index value possible */\\n            table[Math.min(x,N)]++; \\n            \\n\\t\\t\\t/* we can only increment h_index if there\\'s no element in our \"list\" with same value as h_index, otherwise we can only improve our state */\\n            if(table[max]>0) table[max]--;\\n\\t\\t\\telse max++;\\n        }\\n        \\n\\t\\treturn max;\\n    }\\n}\\n```\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int hIndex(int[] citations) {\\n        int N = citations.length;\\n\\t\\t\\n\\t\\t/* h_index can range from 0 to number of citations, hence the size+1 */\\n        int[] table = new int[N+1];\\n        \\n\\t\\t/* maintains max possible H-Index at ith index */\\n\\t\\tint max = 0;\\n        \\n\\t\\tfor (int i = 0; i < N; i++) {\\n            int x = citations[i];\\n        \\n\\t\\t\\t/* elements less than current h_index cannot affect its value */\\n\\t\\t\\tif(x<=max) continue;\\n            \\n\\t\\t\\t/* element which is greater than no. of citations is equivalent to maximum h_index value possible */\\n            table[Math.min(x,N)]++; \\n            \\n\\t\\t\\t/* we can only increment h_index if there\\'s no element in our \"list\" with same value as h_index, otherwise we can only improve our state */\\n            if(table[max]>0) table[max]--;\\n\\t\\t\\telse max++;\\n        }\\n        \\n\\t\\treturn max;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 420554,
                "title": "java-0-n-compact-solution",
                "content": "```\\nclass Solution {\\n    public int hIndex(int[] citations) {\\n        int n = citations.length;\\n        int[] map = new int[n + 1];\\n\\n        for (int val : citations) {\\n            map[Math.min(val, n)] += 1;\\n        }\\n        \\n        int sum = 0;\\n        while (n > 0) {\\n            sum += map[n];\\n            if (sum >= n) {\\n                return n;\\n            }\\n            \\n            n--;\\n        }\\n        \\n        return n;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int hIndex(int[] citations) {\\n        int n = citations.length;\\n        int[] map = new int[n + 1];\\n\\n        for (int val : citations) {\\n            map[Math.min(val, n)] += 1;\\n        }\\n        \\n        int sum = 0;\\n        while (n > 0) {\\n            sum += map[n];\\n            if (sum >= n) {\\n                return n;\\n            }\\n            \\n            n--;\\n        }\\n        \\n        return n;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 359359,
                "title": "a-few-lines-of-javascript-without-map",
                "content": "```\\n/**\\n * @param {number[]} citations\\n * @return {number}\\n */\\nvar hIndex = function(citations) {    \\n    let pass = [];\\n    \\n    for (let i = 0; i < citations.length; i++) {\\n        if (citations[i] > pass.length) {\\n            pass.push(citations[i]);\\n            \\n            if (Math.min(...pass) < pass.length) {\\n                pass.splice(pass.indexOf(Math.min(...pass)), 1);\\n            }\\n        }\\n    }\\n    \\n    return pass.length;\\n};\\n```\\n\\nExplaination: the if (Math.min(...pass) < pass.length) removes paper less than the updated citations after push.",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} citations\\n * @return {number}\\n */\\nvar hIndex = function(citations) {    \\n    let pass = [];\\n    \\n    for (let i = 0; i < citations.length; i++) {\\n        if (citations[i] > pass.length) {\\n            pass.push(citations[i]);\\n            \\n            if (Math.min(...pass) < pass.length) {\\n                pass.splice(pass.indexOf(Math.min(...pass)), 1);\\n            }\\n        }\\n    }\\n    \\n    return pass.length;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 179097,
                "title": "java-quick-select-solution",
                "content": "```\\n    public int hIndex(int[] c) {\\n        if(c.length == 0) return 0;\\n        int l = 0, h = c.length - 1;\\n        while(l < h) {\\n            int pos = partition(c, l, h);\\n            if(c[pos] >= pos + 1) {\\n                l = pos + 1;\\n            } else {\\n                h = pos - 1;\\n            }\\n        }\\n        if(l == c.length) return l;\\n        return c[l] >= l + 1 ? l + 1 : l;\\n    }\\n    \\n    int partition(int[] c, int s, int e) {\\n        int pivot = c[e];\\n        int j = s;\\n        for(int i = s; i < e; i++) {\\n          if(c[i] > pivot) swap(c, i, j++);  \\n        }\\n        swap(c, j, e);\\n        return j;\\n    }\\n    \\n    void swap(int[] c, int i, int j) {\\n        int t = c[i];\\n        c[i] = c[j];\\n        c[j] = t;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    public int hIndex(int[] c) {\\n        if(c.length == 0) return 0;\\n        int l = 0, h = c.length - 1;\\n        while(l < h) {\\n            int pos = partition(c, l, h);\\n            if(c[pos] >= pos + 1) {\\n                l = pos + 1;\\n            } else {\\n                h = pos - 1;\\n            }\\n        }\\n        if(l == c.length) return l;\\n        return c[l] >= l + 1 ? l + 1 : l;\\n    }\\n    \\n    int partition(int[] c, int s, int e) {\\n        int pivot = c[e];\\n        int j = s;\\n        for(int i = s; i < e; i++) {\\n          if(c[i] > pivot) swap(c, i, j++);  \\n        }\\n        swap(c, j, e);\\n        return j;\\n    }\\n    \\n    void swap(int[] c, int i, int j) {\\n        int t = c[i];\\n        c[i] = c[j];\\n        c[j] = t;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 70844,
                "title": "with-and-without-sort-java-ac-solution",
                "content": "Below is using `sort()`. The idea is actually the same with no sort() solution. The most significant disadvantage I think is not the time performance, is the `if statement`, I tried many times to pass all the test cases.....\\n```\\npublic int hIndex(int[] c) {\\n        if (c.length == 0) return 0;\\n        int len = c.length;\\n        Arrays.sort(c);\\n        \\n        int count = 0;\\n        int h = 1;\\n        \\n        for (int i = len - 1; i >= 0; i--) {\\n            h = c[i];\\n            count++;\\n            if (count == h) return h;\\n            if (count > h && count > 1) return Math.min(count - 1, c[i + 1]);\\n            if (count == 1 && count > h) return 0;\\n        }\\n        return count;\\n    }\\n```\\n\\nWithout `sort()`, this method actually also *sorts* (not real sort, but kind of sort) the citation, just by ourselves instead of `sort()`. \\n```\\npublic int hIndex(int[] c) {\\n        int n = c.length;\\n        if (n == 0) return 0;\\n        \\n        // the number of high citations\\n        int[] record = new int[n + 1];\\n        \\n        // count the citations\\n        for (int i : c) {\\n            if (i >= n) record[n]++;\\n            else record[i]++;\\n        }\\n        \\n        // get the h\\n        int count = 0;\\n        for (int i = n; i > 0; i--) {\\n            count += record[i];\\n            if (count >= i) {\\n                return i;\\n            } \\n        }\\n        return 0;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\npublic int hIndex(int[] c) {\\n        if (c.length == 0) return 0;\\n        int len = c.length;\\n        Arrays.sort(c);\\n        \\n        int count = 0;\\n        int h = 1;\\n        \\n        for (int i = len - 1; i >= 0; i--) {\\n            h = c[i];\\n            count++;\\n            if (count == h) return h;\\n            if (count > h && count > 1) return Math.min(count - 1, c[i + 1]);\\n            if (count == 1 && count > h) return 0;\\n        }\\n        return count;\\n    }\\n```\n```\\npublic int hIndex(int[] c) {\\n        int n = c.length;\\n        if (n == 0) return 0;\\n        \\n        // the number of high citations\\n        int[] record = new int[n + 1];\\n        \\n        // count the citations\\n        for (int i : c) {\\n            if (i >= n) record[n]++;\\n            else record[i]++;\\n        }\\n        \\n        // get the h\\n        int count = 0;\\n        for (int i = n; i > 0; i--) {\\n            count += record[i];\\n            if (count >= i) {\\n                return i;\\n            } \\n        }\\n        return 0;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 70909,
                "title": "o-n-5-lines-1ms-concise-code",
                "content": "    public int hIndex(int[] citations) {\\n            int n = citations.length, h = n, sum;\\n            int[] cnt = new int[n + 1];\\n            for (int c : citations) cnt[Math.min(n, c)]++;\\n            for (h = n, sum = cnt[n]; sum < h; sum += cnt[--h]);\\n            return h;\\n        }",
                "solutionTags": [],
                "code": "    public int hIndex(int[] citations) {\\n            int n = citations.length, h = n, sum;\\n            int[] cnt = new int[n + 1];\\n            for (int c : citations) cnt[Math.min(n, c)]++;\\n            for (h = n, sum = cnt[n]; sum < h; sum += cnt[--h]);\\n            return h;\\n        }",
                "codeTag": "Unknown"
            },
            {
                "id": 70920,
                "title": "8ms-golang-solution-with-o-n-space-o-n-time",
                "content": "    func hIndex(citations []int) int {\\n    \\tm, max := make(map[int]int), 0\\n    \\tfor _, v := range citations {\\n    \\t\\tm[v]++\\n    \\t}\\n    \\tfor i, h := 0, len(citations); i <= h; i++ {\\n    \\t\\tmax = i\\n    \\t\\th = h - m[i]\\n    \\t}\\n    \\treturn max\\n    }",
                "solutionTags": [
                    "Go"
                ],
                "code": "    func hIndex(citations []int) int {\\n    \\tm, max := make(map[int]int), 0\\n    \\tfor _, v := range citations {\\n    \\t\\tm[v]++\\n    \\t}\\n    \\tfor i, h := 0, len(citations); i <= h; i++ {\\n    \\t\\tmax = i\\n    \\t\\th = h - m[i]\\n    \\t}\\n    \\treturn max\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 70928,
                "title": "easy-java-solution-with-comments-runs-in-2ms",
                "content": "public class Solution {\\n    public int hIndex(int[] citations) {\\n        \\n        //Base case : if array is empty, return 0\\n        if(citations==null || citations.length==0 )\\n            return 0;\\n        \\n        //if array has 1 element greater than 0, return 1    \\n        if(citations.length==1 && citations[0]>=1)\\n            return 1;\\n            \\n        //sort the array\\n        Arrays.sort(citations);\\n            \\n        //variable to keep track of length of array, hIndex\\n        int length=citations.length;\\n        int hIndex=0;\\n        \\n        //for loop to traverse the array\\n        for(int i=length-1;i>=0;i--)\\n        {\\n            //if value is present in array\\n            if(length-i==citations[i])\\n            {\\n                hIndex=citations[i];\\n            }\\n            else\\n            {\\n                //if value is not present in array\\n                if(i>0 &&citations[i-1]<=length-i && citations[i]>=length-i)\\n                    hIndex=length-i;\\n            }\\n            \\n            \\n        }\\n        \\n        //first element is greater than 0, and hash index is 0, return the length of the array as answer\\n        if(citations.length>1 && citations[0]>citations.length && hIndex==0)\\n            hIndex=citations.length;\\n        \\n        \\n        //return the answer\\n        return hIndex;\\n        \\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public int hIndex(int[] citations) {\\n        \\n        //Base case : if array is empty, return 0\\n        if(citations==null || citations.length==0 )\\n            return 0;\\n        \\n        //if array has 1 element greater than 0, return 1    \\n        if(citations.length==1 && citations[0]>=1)\\n            return 1;\\n            \\n        //sort the array\\n        Arrays.sort(citations);\\n            \\n        //variable to keep track of length of array, hIndex\\n        int length=citations.length;\\n        int hIndex=0;\\n        \\n        //for loop to traverse the array\\n        for(int i=length-1;i>=0;i--)\\n        {\\n            //if value is present in array\\n            if(length-i==citations[i])\\n            {\\n                hIndex=citations[i];\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 70949,
                "title": "c-solution-with-o-n-time-and-o-n-space",
                "content": "    int hIndex(int* citations, int citationsSize) {\\n        if (!citations || (citationsSize <= 0)) return 0;\\n        const int N = citationsSize;\\n        int hi[N + 1];\\n        int i, h;\\n        memset(hi, 0, sizeof(int) * (N + 1));\\n        for (i = 0; i < N; i++) {\\n            h = citations[i];\\n            if (h > N) h = N; // If a paper has > N citations, treat it as N citations\\n            hi[h]++;\\n        }\\n        for (i = N; i > 0; i--) {\\n            if (hi[i] >= i) return i; // At least i papers has >= i citations\\n            hi[i - 1] += hi[i];\\n        }\\n        return 0;\\n    }",
                "solutionTags": [],
                "code": "    int hIndex(int* citations, int citationsSize) {\\n        if (!citations || (citationsSize <= 0)) return 0;\\n        const int N = citationsSize;\\n        int hi[N + 1];\\n        int i, h;\\n        memset(hi, 0, sizeof(int) * (N + 1));\\n        for (i = 0; i < N; i++) {\\n            h = citations[i];\\n            if (h > N) h = N; // If a paper has > N citations, treat it as N citations\\n            hi[h]++;\\n        }\\n        for (i = N; i > 0; i--) {\\n            if (hi[i] >= i) return i; // At least i papers has >= i citations\\n            hi[i - 1] += hi[i];\\n        }\\n        return 0;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 70952,
                "title": "12-line-of-c-code-o-n-0-00012s-execution-time-3-solutions-inside",
                "content": "## my best solution as described in the title\\n\\n     class Solution {\\n        public:\\n            int cycle(vector<int>& citations){\\n                // there are 'flag' nums greater than 'ret + 1'\\n                int ret = 0, flag = 0, size = citations.size();\\n                int record[size + 1];\\n                memset(record, 0, sizeof(record));\\n                for (int i = 0; i < size; ++i){\\n                    int cur = citations[i];\\n                    if (cur >= size) record[size]++;\\n                    else record[cur] += 1;\\n                    if (cur <= ret) continue;\\n                    if (++flag < ret + 1) continue;\\n                    flag -= record[++ret];\\n                }\\n                return ret;\\n            }\\n        \\n            int hIndex(vector<int>& citations) {\\n                for (int i = 0; i < 99; ++i) cycle(citations);\\n                return cycle(citations);   \\n            }\\n        };\\n\\nSince the execution time is so fast, I wrap it with a 100 times cycle. \\nWhile it still only needs 12ms time.\\n\\n**several tips to consider:**\\nlet's assume the total num of vector is 6\\n\\n1. the answer must be less than or equal 6.\\n2. any number larger than 6 can be treated the same as 6.\\n3. record 2 number: flag and ret. which means there are 'flag' nums greater than 'ret + 1'\\n4. iterate the vector once, and the ret is what the solution is.\\n\\n\\n##here I provide another 2 solutions: \\n### second solution:\\nthe second solution is the same idea with the first but I use `unordered_map`, which takes much more time of 2.56ms:\\n\\n    class Solution {\\n    public:\\n        int cycle(vector<int>& citations){\\n            // there are 'flag' nums greater than 'ret + 1'\\n            int ret = 0, flag = 0;\\n            unordered_map<int, int> uii;\\n            for (int i = 0; i < citations.size(); ++i){\\n                int cur = citations[i];\\n                uii[cur] += 1;\\n                if (cur <= ret) continue;\\n                if (++flag >= ret + 1){\\n                    ++ret;\\n                    flag -= uii[ret];\\n                }\\n            }\\n            return ret;\\n        }\\n    \\n        int hIndex(vector<int>& citations) {\\n            for (int i = 0; i < 99; ++i) cycle(citations);\\n            return cycle(citations);   \\n        }\\n    };\\n\\n### the third solution:\\nit sorts the vector first. time complexity of O(n*logn), **it is faster than the second(1.16ms), amazing!**\\n\\n    class Solution {\\n    public:\\n        int cycle(vector<int>& citations){\\n            sort(citations.begin(), citations.end());\\n            int i = citations.size() - 1;\\n            for (; i >= 0; --i){\\n                int c = citations.size() - i;\\n                if (citations[i] < c) break;\\n            }\\n            return citations.size() - 1 -i;\\n        }\\n    \\n        int hIndex(vector<int>& citations) {\\n            for (int i = 0; i < 99; ++i) cycle(citations);\\n            return cycle(citations);   \\n        }\\n    };",
                "solutionTags": [
                    "C++",
                    "Hash Table"
                ],
                "code": "class Solution {\\n        public:\\n            int cycle(vector<int>& citations){\\n                // there are 'flag' nums greater than 'ret + 1'\\n                int ret = 0, flag = 0, size = citations.size();\\n                int record[size + 1];\\n                memset(record, 0, sizeof(record));\\n                for (int i = 0; i < size; ++i){\\n                    int cur = citations[i];\\n                    if (cur >= size) record[size]++;\\n                    else record[cur] += 1;\\n                    if (cur <= ret) continue;\\n                    if (++flag < ret + 1) continue;\\n                    flag -= record[++ret];\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 70969,
                "title": "share-my-c-solution-using-o-1-space-and-o-n-average-time",
                "content": "the algorithm is binary search and the partition of qsort. Here is my code: \\n\\n    class Solution {\\n    public:\\n        int hIndex(vector<int>& citations) {\\n            int l = 0, r = citations.size(), ans = 0; \\n            while (l < r) {\\n                int pix = citations[l];\\n                int i = l, j = r; \\n                while (i < j) {  \\n                    while (i < --j && citations[j] < pix); \\n                    while (++i < j && citations[i] >= pix);\\n                    if (i < j) {\\n                        swap(citations[i], citations[j]); \\n                    }\\n                }\\n                swap(citations[j], citations[l]); \\n                if (pix >= j + 1) {\\n                    ans = j + 1; \\n                    l = j + 1; \\n                } else {\\n                    r = j; \\n                }\\n            }\\n            return l; \\n        }\\n    };",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n        int hIndex(vector<int>& citations) {\\n            int l = 0, r = citations.size(), ans = 0; \\n            while (l < r) {\\n                int pix = citations[l];\\n                int i = l, j = r; \\n                while (i < j) {  \\n                    while (i < --j && citations[j] < pix); \\n                    while (++i < j && citations[i] >= pix);\\n                    if (i < j) {\\n                        swap(citations[i], citations[j]); \\n                    }",
                "codeTag": "Java"
            },
            {
                "id": 70991,
                "title": "6-line-concise-java-sort-solution",
                "content": "    public int hIndex(int[] citations) {\\n    \\n    \\t\\tArrays.sort(citations);\\n    \\n    \\t\\tint h_index = 0;\\n    \\t\\tfor (int i = citations.length - 1; i >= 0; i--)\\n    \\t\\t\\tif (citations[i] > h_index)\\n    \\t\\t\\t\\th_index++;\\n    \\n    \\t\\treturn h_index;\\n    \\t}",
                "solutionTags": [],
                "code": "    public int hIndex(int[] citations) {\\n    \\n    \\t\\tArrays.sort(citations);\\n    \\n    \\t\\tint h_index = 0;\\n    \\t\\tfor (int i = citations.length - 1; i >= 0; i--)\\n    \\t\\t\\tif (citations[i] > h_index)\\n    \\t\\t\\t\\th_index++;\\n    \\n    \\t\\treturn h_index;\\n    \\t}",
                "codeTag": "Unknown"
            },
            {
                "id": 70966,
                "title": "fast-java-solution",
                "content": "    public class Solution {\\n        public int hIndex(int[] citations) {\\n            int len = citations.length;\\n            int[] map = new int[len + 1];\\n            for (int i = 0; i < len; i++) {\\n                if (citations[i] >= len) map[len]++;\\n                else map[citations[i]]++;\\n            }\\n            for (int i = len; i >= 1; i--) {\\n                if (map[i] >= i) return i;\\n                map[i - 1] += map[i];\\n            }\\n            return 0;\\n        }\\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n        public int hIndex(int[] citations) {\\n            int len = citations.length;\\n            int[] map = new int[len + 1];\\n            for (int i = 0; i < len; i++) {\\n                if (citations[i] >= len) map[len]++;\\n                else map[citations[i]]++;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 71025,
                "title": "c-solution-using-heap-faster-than-sort",
                "content": "    int hIndex(vector<int>& citations) {\\n        int len = citations.size(), last = INT_MIN;\\n        make_heap(citations.begin(),citations.end(),greater<int>());\\n        for (int h = len;h >0;--h) {\\n            if (citations[0] >= h && last <= h)\\n                return h;\\n            last = citations[0];\\n            pop_heap(citations.begin(),citations.end()-(len-h),greater<int>());\\n        }\\n        return 0;\\n    }",
                "solutionTags": [
                    "C++",
                    "Heap (Priority Queue)"
                ],
                "code": "    int hIndex(vector<int>& citations) {\\n        int len = citations.size(), last = INT_MIN;\\n        make_heap(citations.begin(),citations.end(),greater<int>());\\n        for (int h = len;h >0;--h) {\\n            if (citations[0] >= h && last <= h)\\n                return h;\\n            last = citations[0];\\n            pop_heap(citations.begin(),citations.end()-(len-h),greater<int>());\\n        }\\n        return 0;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 4044089,
                "title": "o-n-kotlin-solution-without-sorting",
                "content": "# Intuition\\nA lot of solutions here rely on sorting the input array which isn\\'t very elegant. An $$O(n)$$ solution is possible using a cache.\\n\\n# Approach\\n$$P$$ is a set of citation counts (papers) $$ p_i^k $$. We can define a function $$\\\\phi(P, c)$$ that counts the number of papers in $$P$$ having a citation count as least as big as $$c$$.\\n\\n$ \\\\phi(P, c) = \\\\sum_{0}^{n} \\\\delta[p_i^k \\\\ge c]  $\\n\\nWe can rewrite the sum as:\\n\\n$$ \\\\phi(P, c) = \\\\sum_{c}^{1000} \\\\sum_{0}^{n} \\\\delta[p_i^k = c] $$\\n\\nWhere the inner sum is the count of all papers with a given citation count ($$C(P, c)$$). Note that $$\\\\phi$$ is decreasing in $$c$$ and that we can efficiently calculate $$C(P, c)$$ in one pass over the input.\\n\\nTo compute the H-index for $$P$$ we need:\\n$$ \\\\text{H}(P) = \\\\underset{c}{\\\\arg\\\\max} \\\\{ \\\\phi(P, c) : \\\\phi(P, c) \\\\ge c \\\\} = \\\\underset{c}{\\\\arg\\\\max} \\\\{ \\\\sum_{c}^{1000} C(P, c) : \\\\sum_{c}^{1000} C(P, c)  \\\\ge c \\\\} $$\\n\\nBecause $$\\\\phi$$ is decreasing in $$c$$, finding the value of $$c$$ that maximises $$\\\\phi(P, c)$$ can be done by setting $$c=1000$$, calculating the sum $$\\\\sum_{c}^{1000} C(P, c)$$, halting and returning if the condition is met or decrementing $$c$$ and looping. This calculation takes constant time.\\n\\n# Complexity\\n- Time complexity:\\n$$O(n)$$, one pass across the input data\\n\\n- Space complexity:\\n$$O(1)$$, preallocated cache to hold $$C(P, c)$$\\n\\n# Code\\n```\\nclass Solution {\\n    fun hIndex(citations: IntArray): Int {\\n\\n        // Set up the cache to hold C(P, c)\\n        val counts = IntArray(1000) { 0 }\\n\\n        // Calculate C(P, c)\\n        for (c in citations) {\\n            counts[c]++\\n        }\\n\\n        // Calculate argmax_c starting at c=1000\\n        return counts.foldRightIndexed(0) { i, acc, c ->\\n\\n            // phi(P, i)\\n            val new = acc + c\\n\\n            // Check the halting condition\\n            if (new >= i) {\\n                return i\\n            }\\n            new\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Kotlin"
                ],
                "code": "```\\nclass Solution {\\n    fun hIndex(citations: IntArray): Int {\\n\\n        // Set up the cache to hold C(P, c)\\n        val counts = IntArray(1000) { 0 }\\n\\n        // Calculate C(P, c)\\n        for (c in citations) {\\n            counts[c]++\\n        }\\n\\n        // Calculate argmax_c starting at c=1000\\n        return counts.foldRightIndexed(0) { i, acc, c ->\\n\\n            // phi(P, i)\\n            val new = acc + c\\n\\n            // Check the halting condition\\n            if (new >= i) {\\n                return i\\n            }\\n            new\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4019226,
                "title": "h-index",
                "content": "# Intuition\\nsorting the array: Why? read the Hvalue definition again.\\nNow, the largest no is at end and let the numbering from behind is from 1{n-i, 0<=i<=n-1} which acts as a possible Hvalue. Here, we can get some idea how we can get the h value. two things - no of elements(n-i) and element value(citation[i])\\n if(citations[i] >= n-i) hvalue = n-i \\ntry dry run on [5,0,0,0,0,8,9,6,3]\\n\\n# Complexity\\n- Time complexity: O(nlogn){sorting} + O(n){array traversal} => O(nlogn){overall complexity}\\n- for taversal we can also do binary search but with some modifications.\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int hIndex(vector<int>& citations) {\\n        int n = citations.size();\\n        if(n==1)\\n        {\\n            if(citations[0] >=1) return 1;\\n            else return 0;\\n        }\\n        sort(citations.begin(),citations.end());\\n\\n        int hValue=citations[0];\\n        for(int i = n-1 ;i>=0;i--)\\n        {\\n            if(citations[i] >= n-i) {hValue = n-i;}\\n        }\\n        return hValue;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int hIndex(vector<int>& citations) {\\n        int n = citations.size();\\n        if(n==1)\\n        {\\n            if(citations[0] >=1) return 1;\\n            else return 0;\\n        }\\n        sort(citations.begin(),citations.end());\\n\\n        int hValue=citations[0];\\n        for(int i = n-1 ;i>=0;i--)\\n        {\\n            if(citations[i] >= n-i) {hValue = n-i;}\\n        }\\n        return hValue;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4008527,
                "title": "c-solution-with-bucket-sort-o-n",
                "content": "# Complexity\\n- Time complexity: $$O(n)$$\\n\\n- Space complexity: $$O(n)$$\\n\\n# Code\\n```\\nint hIndex(int* citations, int citationsSize){\\n    int *buckets = calloc(citationsSize+1, sizeof(*buckets));\\n\\n    for (int i = 0; i < citationsSize; ++i) {\\n        if(citations[i] >= citationsSize) {\\n            buckets[citationsSize]++;\\n        } else {\\n            buckets[citations[i]]++;\\n        }\\n    }\\n    int count = 0;\\n    for (int i = citationsSize; i >= 0; --i) {\\n        count += buckets[i];\\n        if (count >= i) {\\n            return i;\\n        }\\n    }\\n    free(buckets);\\n    \\n    return 0;\\n}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nint hIndex(int* citations, int citationsSize){\\n    int *buckets = calloc(citationsSize+1, sizeof(*buckets));\\n\\n    for (int i = 0; i < citationsSize; ++i) {\\n        if(citations[i] >= citationsSize) {\\n            buckets[citationsSize]++;\\n        } else {\\n            buckets[citations[i]]++;\\n        }\\n    }\\n    int count = 0;\\n    for (int i = citationsSize; i >= 0; --i) {\\n        count += buckets[i];\\n        if (count >= i) {\\n            return i;\\n        }\\n    }\\n    free(buckets);\\n    \\n    return 0;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3975577,
                "title": "c-binary-search-nlogn",
                "content": "# Intuition\\n- Calculate the cound of element present in the right of current element including current one `countOfElementsInRightIncludingCurrent`\\n- if current citation count == `countOfElementsInRightIncludingCurrent`, that is the answer\\n- if current citation count < countOfElementsInRightIncludingCurrent, the possible answer will be present in the right\\n- else possible answer will be present in the left\\n- once the while loop is over, possible answer would be n - start;\\n\\n# Complexity\\n- Time complexity: O(nLogn)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\npublic class Solution {\\n    public int HIndex(int[] citations) {\\n        \\n        Array.Sort(citations);\\n        \\n        int n = citations.Length;\\n        int start = 0;\\n        int end = n - 1;\\n\\n        while(start <= end)\\n        {\\n            int mid = start +  (end - start)/2;\\n            int countOfElementsInRightIncludingCurrent = n - mid ;\\n\\n            if(citations[mid] == countOfElementsInRightIncludingCurrent){\\n                return citations[mid];\\n            }\\n            else if(citations[mid] < countOfElementsInRightIncludingCurrent)\\n            {\\n                start = mid + 1;\\n            }   \\n            else\\n                end = mid - 1;\\n        }\\n\\n        return n - start;\\n    }\\n\\n}\\n```",
                "solutionTags": [
                    "C#",
                    "Binary Search"
                ],
                "code": "```\\npublic class Solution {\\n    public int HIndex(int[] citations) {\\n        \\n        Array.Sort(citations);\\n        \\n        int n = citations.Length;\\n        int start = 0;\\n        int end = n - 1;\\n\\n        while(start <= end)\\n        {\\n            int mid = start +  (end - start)/2;\\n            int countOfElementsInRightIncludingCurrent = n - mid ;\\n\\n            if(citations[mid] == countOfElementsInRightIncludingCurrent){\\n                return citations[mid];\\n            }\\n            else if(citations[mid] < countOfElementsInRightIncludingCurrent)\\n            {\\n                start = mid + 1;\\n            }   \\n            else\\n                end = mid - 1;\\n        }\\n\\n        return n - start;\\n    }\\n\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3959453,
                "title": "swift-solution-using-sorting",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nSort in decending order and then keep moving to index till we have \\n`sortedCitations[i] > i` and next index will be the answer, since the value at `index + 1` should be the min value present in all citations.\\n\\n# Complexity\\n- Time complexity:\\n$$ 0(2n) ~ sorting will also take 0(n)\\n\\n- Space complexity:\\n$$0(1)\\n\\n# Code\\n```\\nclass Solution {\\n    func hIndex(_ citations: [Int]) -> Int {\\n        let sortedCitations = citations.sorted {$0 > $1}\\n\\n        var i = 0 \\n        var hIndex = 0 \\n\\n        while i < sortedCitations.count {\\n            if sortedCitations[i] > i {\\n                hIndex = i + 1\\n            }\\n\\n            i += 1\\n        }\\n\\n        return hIndex\\n    }\\n}\\n```",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nclass Solution {\\n    func hIndex(_ citations: [Int]) -> Int {\\n        let sortedCitations = citations.sorted {$0 > $1}\\n\\n        var i = 0 \\n        var hIndex = 0 \\n\\n        while i < sortedCitations.count {\\n            if sortedCitations[i] > i {\\n                hIndex = i + 1\\n            }\\n\\n            i += 1\\n        }\\n\\n        return hIndex\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3904184,
                "title": "5-lines-of-code-the-easiest-solution-with-o-n-log-and-o-1-for-space-complexity",
                "content": "\\n# Approach\\n1. Let\\'s sort the given array and take a look at a random element.\\n\\n2. All elements after this element are greater or equal.\\n\\n3. So we can take Math.min(citations[i], n-i) elements including this one. The answer shall be the maximum of this calculated values for each i = 0...n-1\\n\\n# Complexity\\n- Time complexity:\\nO(n log)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\n/**\\n * @param {number[]} citations\\n * @return {number}\\n */\\nvar hIndex = function(citations) {\\n    citations.sort((a, b) => a - b)\\n    let result = 0;\\n    let n = citations.length;\\n    for(let i = 0; i < n; i++){\\n        result = Math.max(result, Math.min(citations[i], n-i))\\n    }\\n    return result;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} citations\\n * @return {number}\\n */\\nvar hIndex = function(citations) {\\n    citations.sort((a, b) => a - b)\\n    let result = 0;\\n    let n = citations.length;\\n    for(let i = 0; i < n; i++){\\n        result = Math.max(result, Math.min(citations[i], n-i))\\n    }\\n    return result;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3888144,
                "title": "o-n-using-hash-map-h-index-solution-beats-99-typescript",
                "content": "# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(n)\\n\\n# Code\\n```\\nfunction hIndex(citations: number[]): number {\\n  const map = new Map<number, number>(); // <citations, papers count>\\n  let maxCitations = 0;\\n\\n  for (let currCitations of citations) {\\n    maxCitations = Math.max(currCitations, maxCitations);\\n    const papersCount = map.has(currCitations) ? map.get(currCitations) : 0;\\n    map.set(currCitations, papersCount + 1);\\n  }\\n\\n  let citationsPapers = 0;\\n\\n  for (let index = maxCitations; index > 0; index--) {\\n    const currCitationsPapers = map.get(index) || 0;\\n    citationsPapers += currCitationsPapers;\\n\\n    if (citationsPapers >= index) return index;\\n  }\\n\\n  return 0;\\n}\\n\\n```",
                "solutionTags": [
                    "TypeScript",
                    "Hash Table"
                ],
                "code": "```\\nfunction hIndex(citations: number[]): number {\\n  const map = new Map<number, number>(); // <citations, papers count>\\n  let maxCitations = 0;\\n\\n  for (let currCitations of citations) {\\n    maxCitations = Math.max(currCitations, maxCitations);\\n    const papersCount = map.has(currCitations) ? map.get(currCitations) : 0;\\n    map.set(currCitations, papersCount + 1);\\n  }\\n\\n  let citationsPapers = 0;\\n\\n  for (let index = maxCitations; index > 0; index--) {\\n    const currCitationsPapers = map.get(index) || 0;\\n    citationsPapers += currCitationsPapers;\\n\\n    if (citationsPapers >= index) return index;\\n  }\\n\\n  return 0;\\n}\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3847860,
                "title": "easy-approch",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {number[]} citations\\n * @return {number}\\n */\\nvar hIndex = function(citations) {\\n    const h = citations.length;\\n  citations.sort ((a,b)=>(a-b));\\n         let i;\\n    for(i=0;i<h;i++){\\n        if(h-i<=citations[i]){\\n            break;\\n        }\\n    }\\n    return h-i;\\n};\\n \\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} citations\\n * @return {number}\\n */\\nvar hIndex = function(citations) {\\n    const h = citations.length;\\n  citations.sort ((a,b)=>(a-b));\\n         let i;\\n    for(i=0;i<h;i++){\\n        if(h-i<=citations[i]){\\n            break;\\n        }\\n    }\\n    return h-i;\\n};\\n \\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3839806,
                "title": "beats-98-78-using-binary-search",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n$$O(log(len(citations)))$$\\n\\n- Space complexity:\\n$$O(1)$$\\n\\n# Code\\n```\\nclass Solution:\\n    def hIndex(self, citations: List[int]) -> int:\\n        def util(mid):\\n            cnt = 0\\n            for citation in citations:\\n                if citation >= mid:\\n                    cnt += 1\\n            return cnt\\n\\n        left = 0\\n        right = len(citations)\\n        while left <= right:\\n            mid = (left + right) // 2\\n            res = util(mid)\\n            if res >= mid:\\n                left = mid + 1\\n            if res < mid:\\n                right = mid - 1\\n        return left - 1\\n```",
                "solutionTags": [
                    "Python3",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution:\\n    def hIndex(self, citations: List[int]) -> int:\\n        def util(mid):\\n            cnt = 0\\n            for citation in citations:\\n                if citation >= mid:\\n                    cnt += 1\\n            return cnt\\n\\n        left = 0\\n        right = len(citations)\\n        while left <= right:\\n            mid = (left + right) // 2\\n            res = util(mid)\\n            if res >= mid:\\n                left = mid + 1\\n            if res < mid:\\n                right = mid - 1\\n        return left - 1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3819863,
                "title": "c-beats-100",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int hIndex(vector<int>& citations) \\n    {\\n        int ans=0;\\n        int n=citations.size();\\n        sort(citations.begin(),citations.begin()+n);\\n        for(int i=0;i<n;i++)\\n        {\\n            if(citations[i]>= n-i) \\n            ans = max(ans, n-i);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int hIndex(vector<int>& citations) \\n    {\\n        int ans=0;\\n        int n=citations.size();\\n        sort(citations.begin(),citations.begin()+n);\\n        for(int i=0;i<n;i++)\\n        {\\n            if(citations[i]>= n-i) \\n            ans = max(ans, n-i);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3772365,
                "title": "using-counting-sort-technique",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nUsing Counting Sort Techinque\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n/**\\n    * For this input this how algo works citations = [3,0,6,1,5]\\n    * Freq array = [0, 0, 0, 0, 0, 0] => after all freq = [1, 1, 0, 1, 0, 2]\\n    * Cumative from reverse => where sum >= i \\n     */\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nTC :- O(n)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nSpace Complexity:- O(n)\\n\\n# Code\\n```\\nclass Solution {\\n    public int hIndex(int[] citations) {\\n    /**\\n    * For this input this how algo works citations = [3,0,6,1,5]\\n    * Freq array = [0, 0, 0, 0, 0, 0] => after all freq = [1, 1, 0, 1, 0, 2]\\n    * Cumative from reverse => where sum >= i \\n     */\\n\\n        int[] freq = new int [citations.length+1];\\n        int freqSum =0;\\n        //Storing the citations frequency based on counting Sort\\n        for(int i=0; i<citations.length; i++){\\n            if(citations[i]>citations.length){\\n               freq[citations.length]=  freq[citations.length]+1;\\n            }else{\\n               freq[citations[i]] = freq[citations[i]]+1;\\n            }\\n        }\\n\\n        for(int j= citations.length; j>=0; j--){\\n            freqSum +=freq[j];\\n            if(freqSum >= j){\\n                return j;\\n            }\\n        }\\n        return -1;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int hIndex(int[] citations) {\\n    /**\\n    * For this input this how algo works citations = [3,0,6,1,5]\\n    * Freq array = [0, 0, 0, 0, 0, 0] => after all freq = [1, 1, 0, 1, 0, 2]\\n    * Cumative from reverse => where sum >= i \\n     */\\n\\n        int[] freq = new int [citations.length+1];\\n        int freqSum =0;\\n        //Storing the citations frequency based on counting Sort\\n        for(int i=0; i<citations.length; i++){\\n            if(citations[i]>citations.length){\\n               freq[citations.length]=  freq[citations.length]+1;\\n            }else{\\n               freq[citations[i]] = freq[citations[i]]+1;\\n            }\\n        }\\n\\n        for(int j= citations.length; j>=0; j--){\\n            freqSum +=freq[j];\\n            if(freqSum >= j){\\n                return j;\\n            }\\n        }\\n        return -1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3753679,
                "title": "java-simple-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int hIndex(int[] citations) {\\n        if(citations == null || citations.length == 0) return 0;\\n    \\n    int n = citations.length;\\n    int[] num = new int[n+1];\\n    \\n    for(int i=0; i<n; i++) {\\n        if(citations[i]>n) num[n]++;\\n        else num[citations[i]]++;\\n    }\\n    \\n    if(num[n]>=n) return n;\\n    for(int i=n-1; i>=0; i--) {\\n        num[i] += num[i+1];\\n        if(num[i]>=i) return i;\\n    }\\n    return 0;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int hIndex(int[] citations) {\\n        if(citations == null || citations.length == 0) return 0;\\n    \\n    int n = citations.length;\\n    int[] num = new int[n+1];\\n    \\n    for(int i=0; i<n; i++) {\\n        if(citations[i]>n) num[n]++;\\n        else num[citations[i]]++;\\n    }\\n    \\n    if(num[n]>=n) return n;\\n    for(int i=n-1; i>=0; i--) {\\n        num[i] += num[i+1];\\n        if(num[i]>=i) return i;\\n    }\\n    return 0;\\n    }\\n}\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1870167,
                "content": [
                    {
                        "username": "cartesPerforees",
                        "content": "Excuse me, what kind of madman has published 5000 highly-cited papers?\\nI swear that dude must know incredibly much about Riemannian geometry and incredibly little about women"
                    },
                    {
                        "username": "ignacioariasdev",
                        "content": "[@dungtuanuet](/dungtuanuet) what gives u money?"
                    },
                    {
                        "username": "dungtuanuet",
                        "content": "rolf\\n"
                    },
                    {
                        "username": "ourlord",
                        "content": "According to the hint, I tried my version with the build-in `sort()` and get a one time AC. But if in a real interview scenario, do we allow to use build-in sort to solve this problem?\\n\\nWhat would the actual point the interviewee might look for?"
                    },
                    {
                        "username": "isydor",
                        "content": "[@Tribhuwan-Joshi](/Tribhuwan-Joshi) it is literally mentioned on the wiki page..."
                    },
                    {
                        "username": "NareshSawlani",
                        "content": "interviewer would be looking for your approach like in this question it would be using count sort manually no API"
                    },
                    {
                        "username": "Tribhuwan-Joshi",
                        "content": "Please don\\'t share hints like using `sort()` in the discussion "
                    },
                    {
                        "username": "haucaucau",
                        "content": "What if the input is [4,4,4,4,4,4,5]?\\nWhen I run with my code the answer is 4 and it was accepted.\\nBut I don\\'t understand cause there are 7 papers that have at least 4 citations,\\nand 0 paper no more than 4, which contradicts the description."
                    },
                    {
                        "username": "DxRz729",
                        "content": "Yes your the input has 7 papers with 4 citations, but the h in h-index means that it should be the same for no of citations and no of papers, so we will only take 4 papers as it is min of (4,7)"
                    },
                    {
                        "username": "hemantsingh4774",
                        "content": "[@hemantsingh4774](/hemantsingh4774)  reference: https://en.wikipedia.org/wiki/H-index"
                    },
                    {
                        "username": "hemantsingh4774",
                        "content": " For example, if an author has five publications, with 9, 7, 6, 2, and 1 citations (ordered from greatest to least), then the author\\'s h-index is 3, because the author has three publications with 3 or more citations. However, the author does not have four publications with 4 or more citations."
                    },
                    {
                        "username": "han35",
                        "content": "[0] means there is 1 paper and the citation is 0.\\nAccording to the description\\n\\n> A scientist has index h if h of his/her N papers have at least h citations each, and the other N \\u2212 h papers have no more than h citations each\\n\\nA scientist has 1(h) of his/her 1 paper has at least 0(h) citation, and the other 0 paper has no more than 0 citation.\\n\\nIs this a contradiction?"
                    },
                    {
                        "username": "yellowstar1014",
                        "content": "is it possible to have two h in this problem? please give an example?"
                    },
                    {
                        "username": "Dzuchun",
                        "content": "it literaly says to be a maximum value. how in the world would something have two distinct maximum values?"
                    },
                    {
                        "username": "pieceofpie",
                        "content": "![hehe.png](https://assets.leetcode.com/users/images/f16e4f9d-434f-4e5c-bf36-3cc106ea074a_1677794934.0254838.png)"
                    },
                    {
                        "username": "shuyi@cvs",
                        "content": "Hi,\\n\\nI came across a situation:  given citations = [3, 1, 7, 8, 9]. What will be the answer be?\\n\\nAccording to the definition of h-index on Wikipedia: \"A scientist has index h if h of his/her N papers have at least h citations each, and the other N \\u2212 h papers have no more than h citations each.\"\\n\\nWhen h=3, the definition will be \"A scientist has index 3 if 3 of his/her 5 papers have at least 3 citations each, and the other 2 papers have no more than 3 citations each.\" Obviously wrong....\\n\\nWhen h=4, the definition will be \"A scientist has index 4 if 4 of his/her 5 papers have at least 4 citations each, and the other 1 papers have no more than 4 citations each.\" Obviously wrong....\\n\\nWhen h=2, the definition will be \"A scientist has index 2 if 2 of his/her 5 papers have at least 2 citations each, and the other 3 papers have no more than 3 citations each.\" Obviously wrong....\\n\\nSo anybody can give me an answer? Or this question is a wrong one?"
                    },
                    {
                        "username": "user2118U",
                        "content": "Definition of h is The h-index is defined as the maximum value of h such that the given researcher has published at least h papers that have each been cited at least h times. See it is written at least h papers not exact h papers"
                    },
                    {
                        "username": "user2118U",
                        "content": "Dude there  is nothing written like that other papers have no more h citations. your example answer is 3 because researcher has published at least 3 papers and each paper has atleast 3 citations"
                    },
                    {
                        "username": "saurabh8katyal",
                        "content": "Answer will be 3, as the other 2 papers have no more than 3 citations each(1, 3). Not more than 3. Can be equal to."
                    },
                    {
                        "username": "Tsien",
                        "content": "In the problem description, there is a line \"Note: If there are several possible values for h, the maximum one is taken as the h-index.\"\\nI cannot come up with an example that could have several possible values for h. \\nIMO, there is only one value for h for each example according to the definition of H-Index.\\nPlease correct me if i'm wrong.\\nThanks!"
                    },
                    {
                        "username": "Shubh2407",
                        "content": "Anyone thought of Binary search, no need of sorting technique required,\\nDon\\'t open solution if you have not gave it a try using binary search:\\nhttps://leetcode.com/problems/h-index/solutions/3741453/easy-binary-search-problem-no-sorting-technique-required-o-nlogn/ "
                    },
                    {
                        "username": "vishalshrm539",
                        "content": "[@RajputShivraj](/RajputShivraj) He probably meant to apply binary search on the answer and not on the given array."
                    },
                    {
                        "username": "CriticalCorduroy",
                        "content": "How would binary search be beneficial without a sort applied to the citations?"
                    },
                    {
                        "username": "RajputShivraj",
                        "content": "binary search can be applied on sorted arrays na and you are saying no need of sorting techniques\\n"
                    },
                    {
                        "username": "lowiq",
                        "content": "According to the definition of h, \"if h of his/her N papers have at least h citations each, and the other N \\u2212 h papers have no more than h citations each.\" Looks like the h value is unique. The \"Note\" part looks unnecessary. \\n\\nProof: say there exist two h-indices, h1 < h2 (1), which means that, there are h2 numbers have value at least h2 (2) and N-h2 values have value at most h2 (3); there are h1 numbers have value at least h1 (4) and N-h1 values have value at most h1(5).\\n\\nWe have (1)(2)(3), (1) and (2) implies (4), but we can see (5) is not possible. Because we have N-h1 > N-h2, there exists at least one paper not in the set of N-h2 but in the set of N-h1, this paper should have value <= h1 (according to 5) and have value >= h2 (according to 2), this contradicts to (1). \\n\\nThe uniqueness follows."
                    },
                    {
                        "username": "job_xu",
                        "content": "Have two questions about the example 1:why not 5? There are two papers be cited at least 5 times.  why not 1? There are four papers be cited at least 1 times.  "
                    },
                    {
                        "username": "shivam_sharma2004",
                        "content": "5 cant be the ans because there do not exist atleast 5 elements in the array which are greater than 5. Talking about 1 yes it is valid value of h but you need to return the max value of h possible which is 3 in this case ."
                    }
                ]
            },
            {
                "id": 1565530,
                "content": [
                    {
                        "username": "cartesPerforees",
                        "content": "Excuse me, what kind of madman has published 5000 highly-cited papers?\\nI swear that dude must know incredibly much about Riemannian geometry and incredibly little about women"
                    },
                    {
                        "username": "ignacioariasdev",
                        "content": "[@dungtuanuet](/dungtuanuet) what gives u money?"
                    },
                    {
                        "username": "dungtuanuet",
                        "content": "rolf\\n"
                    },
                    {
                        "username": "ourlord",
                        "content": "According to the hint, I tried my version with the build-in `sort()` and get a one time AC. But if in a real interview scenario, do we allow to use build-in sort to solve this problem?\\n\\nWhat would the actual point the interviewee might look for?"
                    },
                    {
                        "username": "isydor",
                        "content": "[@Tribhuwan-Joshi](/Tribhuwan-Joshi) it is literally mentioned on the wiki page..."
                    },
                    {
                        "username": "NareshSawlani",
                        "content": "interviewer would be looking for your approach like in this question it would be using count sort manually no API"
                    },
                    {
                        "username": "Tribhuwan-Joshi",
                        "content": "Please don\\'t share hints like using `sort()` in the discussion "
                    },
                    {
                        "username": "haucaucau",
                        "content": "What if the input is [4,4,4,4,4,4,5]?\\nWhen I run with my code the answer is 4 and it was accepted.\\nBut I don\\'t understand cause there are 7 papers that have at least 4 citations,\\nand 0 paper no more than 4, which contradicts the description."
                    },
                    {
                        "username": "DxRz729",
                        "content": "Yes your the input has 7 papers with 4 citations, but the h in h-index means that it should be the same for no of citations and no of papers, so we will only take 4 papers as it is min of (4,7)"
                    },
                    {
                        "username": "hemantsingh4774",
                        "content": "[@hemantsingh4774](/hemantsingh4774)  reference: https://en.wikipedia.org/wiki/H-index"
                    },
                    {
                        "username": "hemantsingh4774",
                        "content": " For example, if an author has five publications, with 9, 7, 6, 2, and 1 citations (ordered from greatest to least), then the author\\'s h-index is 3, because the author has three publications with 3 or more citations. However, the author does not have four publications with 4 or more citations."
                    },
                    {
                        "username": "han35",
                        "content": "[0] means there is 1 paper and the citation is 0.\\nAccording to the description\\n\\n> A scientist has index h if h of his/her N papers have at least h citations each, and the other N \\u2212 h papers have no more than h citations each\\n\\nA scientist has 1(h) of his/her 1 paper has at least 0(h) citation, and the other 0 paper has no more than 0 citation.\\n\\nIs this a contradiction?"
                    },
                    {
                        "username": "yellowstar1014",
                        "content": "is it possible to have two h in this problem? please give an example?"
                    },
                    {
                        "username": "Dzuchun",
                        "content": "it literaly says to be a maximum value. how in the world would something have two distinct maximum values?"
                    },
                    {
                        "username": "pieceofpie",
                        "content": "![hehe.png](https://assets.leetcode.com/users/images/f16e4f9d-434f-4e5c-bf36-3cc106ea074a_1677794934.0254838.png)"
                    },
                    {
                        "username": "shuyi@cvs",
                        "content": "Hi,\\n\\nI came across a situation:  given citations = [3, 1, 7, 8, 9]. What will be the answer be?\\n\\nAccording to the definition of h-index on Wikipedia: \"A scientist has index h if h of his/her N papers have at least h citations each, and the other N \\u2212 h papers have no more than h citations each.\"\\n\\nWhen h=3, the definition will be \"A scientist has index 3 if 3 of his/her 5 papers have at least 3 citations each, and the other 2 papers have no more than 3 citations each.\" Obviously wrong....\\n\\nWhen h=4, the definition will be \"A scientist has index 4 if 4 of his/her 5 papers have at least 4 citations each, and the other 1 papers have no more than 4 citations each.\" Obviously wrong....\\n\\nWhen h=2, the definition will be \"A scientist has index 2 if 2 of his/her 5 papers have at least 2 citations each, and the other 3 papers have no more than 3 citations each.\" Obviously wrong....\\n\\nSo anybody can give me an answer? Or this question is a wrong one?"
                    },
                    {
                        "username": "user2118U",
                        "content": "Definition of h is The h-index is defined as the maximum value of h such that the given researcher has published at least h papers that have each been cited at least h times. See it is written at least h papers not exact h papers"
                    },
                    {
                        "username": "user2118U",
                        "content": "Dude there  is nothing written like that other papers have no more h citations. your example answer is 3 because researcher has published at least 3 papers and each paper has atleast 3 citations"
                    },
                    {
                        "username": "saurabh8katyal",
                        "content": "Answer will be 3, as the other 2 papers have no more than 3 citations each(1, 3). Not more than 3. Can be equal to."
                    },
                    {
                        "username": "Tsien",
                        "content": "In the problem description, there is a line \"Note: If there are several possible values for h, the maximum one is taken as the h-index.\"\\nI cannot come up with an example that could have several possible values for h. \\nIMO, there is only one value for h for each example according to the definition of H-Index.\\nPlease correct me if i'm wrong.\\nThanks!"
                    },
                    {
                        "username": "Shubh2407",
                        "content": "Anyone thought of Binary search, no need of sorting technique required,\\nDon\\'t open solution if you have not gave it a try using binary search:\\nhttps://leetcode.com/problems/h-index/solutions/3741453/easy-binary-search-problem-no-sorting-technique-required-o-nlogn/ "
                    },
                    {
                        "username": "vishalshrm539",
                        "content": "[@RajputShivraj](/RajputShivraj) He probably meant to apply binary search on the answer and not on the given array."
                    },
                    {
                        "username": "CriticalCorduroy",
                        "content": "How would binary search be beneficial without a sort applied to the citations?"
                    },
                    {
                        "username": "RajputShivraj",
                        "content": "binary search can be applied on sorted arrays na and you are saying no need of sorting techniques\\n"
                    },
                    {
                        "username": "lowiq",
                        "content": "According to the definition of h, \"if h of his/her N papers have at least h citations each, and the other N \\u2212 h papers have no more than h citations each.\" Looks like the h value is unique. The \"Note\" part looks unnecessary. \\n\\nProof: say there exist two h-indices, h1 < h2 (1), which means that, there are h2 numbers have value at least h2 (2) and N-h2 values have value at most h2 (3); there are h1 numbers have value at least h1 (4) and N-h1 values have value at most h1(5).\\n\\nWe have (1)(2)(3), (1) and (2) implies (4), but we can see (5) is not possible. Because we have N-h1 > N-h2, there exists at least one paper not in the set of N-h2 but in the set of N-h1, this paper should have value <= h1 (according to 5) and have value >= h2 (according to 2), this contradicts to (1). \\n\\nThe uniqueness follows."
                    },
                    {
                        "username": "job_xu",
                        "content": "Have two questions about the example 1:why not 5? There are two papers be cited at least 5 times.  why not 1? There are four papers be cited at least 1 times.  "
                    },
                    {
                        "username": "shivam_sharma2004",
                        "content": "5 cant be the ans because there do not exist atleast 5 elements in the array which are greater than 5. Talking about 1 yes it is valid value of h but you need to return the max value of h possible which is 3 in this case ."
                    }
                ]
            },
            {
                "id": 1573901,
                "content": [
                    {
                        "username": "cartesPerforees",
                        "content": "Excuse me, what kind of madman has published 5000 highly-cited papers?\\nI swear that dude must know incredibly much about Riemannian geometry and incredibly little about women"
                    },
                    {
                        "username": "ignacioariasdev",
                        "content": "[@dungtuanuet](/dungtuanuet) what gives u money?"
                    },
                    {
                        "username": "dungtuanuet",
                        "content": "rolf\\n"
                    },
                    {
                        "username": "ourlord",
                        "content": "According to the hint, I tried my version with the build-in `sort()` and get a one time AC. But if in a real interview scenario, do we allow to use build-in sort to solve this problem?\\n\\nWhat would the actual point the interviewee might look for?"
                    },
                    {
                        "username": "isydor",
                        "content": "[@Tribhuwan-Joshi](/Tribhuwan-Joshi) it is literally mentioned on the wiki page..."
                    },
                    {
                        "username": "NareshSawlani",
                        "content": "interviewer would be looking for your approach like in this question it would be using count sort manually no API"
                    },
                    {
                        "username": "Tribhuwan-Joshi",
                        "content": "Please don\\'t share hints like using `sort()` in the discussion "
                    },
                    {
                        "username": "haucaucau",
                        "content": "What if the input is [4,4,4,4,4,4,5]?\\nWhen I run with my code the answer is 4 and it was accepted.\\nBut I don\\'t understand cause there are 7 papers that have at least 4 citations,\\nand 0 paper no more than 4, which contradicts the description."
                    },
                    {
                        "username": "DxRz729",
                        "content": "Yes your the input has 7 papers with 4 citations, but the h in h-index means that it should be the same for no of citations and no of papers, so we will only take 4 papers as it is min of (4,7)"
                    },
                    {
                        "username": "hemantsingh4774",
                        "content": "[@hemantsingh4774](/hemantsingh4774)  reference: https://en.wikipedia.org/wiki/H-index"
                    },
                    {
                        "username": "hemantsingh4774",
                        "content": " For example, if an author has five publications, with 9, 7, 6, 2, and 1 citations (ordered from greatest to least), then the author\\'s h-index is 3, because the author has three publications with 3 or more citations. However, the author does not have four publications with 4 or more citations."
                    },
                    {
                        "username": "han35",
                        "content": "[0] means there is 1 paper and the citation is 0.\\nAccording to the description\\n\\n> A scientist has index h if h of his/her N papers have at least h citations each, and the other N \\u2212 h papers have no more than h citations each\\n\\nA scientist has 1(h) of his/her 1 paper has at least 0(h) citation, and the other 0 paper has no more than 0 citation.\\n\\nIs this a contradiction?"
                    },
                    {
                        "username": "yellowstar1014",
                        "content": "is it possible to have two h in this problem? please give an example?"
                    },
                    {
                        "username": "Dzuchun",
                        "content": "it literaly says to be a maximum value. how in the world would something have two distinct maximum values?"
                    },
                    {
                        "username": "pieceofpie",
                        "content": "![hehe.png](https://assets.leetcode.com/users/images/f16e4f9d-434f-4e5c-bf36-3cc106ea074a_1677794934.0254838.png)"
                    },
                    {
                        "username": "shuyi@cvs",
                        "content": "Hi,\\n\\nI came across a situation:  given citations = [3, 1, 7, 8, 9]. What will be the answer be?\\n\\nAccording to the definition of h-index on Wikipedia: \"A scientist has index h if h of his/her N papers have at least h citations each, and the other N \\u2212 h papers have no more than h citations each.\"\\n\\nWhen h=3, the definition will be \"A scientist has index 3 if 3 of his/her 5 papers have at least 3 citations each, and the other 2 papers have no more than 3 citations each.\" Obviously wrong....\\n\\nWhen h=4, the definition will be \"A scientist has index 4 if 4 of his/her 5 papers have at least 4 citations each, and the other 1 papers have no more than 4 citations each.\" Obviously wrong....\\n\\nWhen h=2, the definition will be \"A scientist has index 2 if 2 of his/her 5 papers have at least 2 citations each, and the other 3 papers have no more than 3 citations each.\" Obviously wrong....\\n\\nSo anybody can give me an answer? Or this question is a wrong one?"
                    },
                    {
                        "username": "user2118U",
                        "content": "Definition of h is The h-index is defined as the maximum value of h such that the given researcher has published at least h papers that have each been cited at least h times. See it is written at least h papers not exact h papers"
                    },
                    {
                        "username": "user2118U",
                        "content": "Dude there  is nothing written like that other papers have no more h citations. your example answer is 3 because researcher has published at least 3 papers and each paper has atleast 3 citations"
                    },
                    {
                        "username": "saurabh8katyal",
                        "content": "Answer will be 3, as the other 2 papers have no more than 3 citations each(1, 3). Not more than 3. Can be equal to."
                    },
                    {
                        "username": "Tsien",
                        "content": "In the problem description, there is a line \"Note: If there are several possible values for h, the maximum one is taken as the h-index.\"\\nI cannot come up with an example that could have several possible values for h. \\nIMO, there is only one value for h for each example according to the definition of H-Index.\\nPlease correct me if i'm wrong.\\nThanks!"
                    },
                    {
                        "username": "Shubh2407",
                        "content": "Anyone thought of Binary search, no need of sorting technique required,\\nDon\\'t open solution if you have not gave it a try using binary search:\\nhttps://leetcode.com/problems/h-index/solutions/3741453/easy-binary-search-problem-no-sorting-technique-required-o-nlogn/ "
                    },
                    {
                        "username": "vishalshrm539",
                        "content": "[@RajputShivraj](/RajputShivraj) He probably meant to apply binary search on the answer and not on the given array."
                    },
                    {
                        "username": "CriticalCorduroy",
                        "content": "How would binary search be beneficial without a sort applied to the citations?"
                    },
                    {
                        "username": "RajputShivraj",
                        "content": "binary search can be applied on sorted arrays na and you are saying no need of sorting techniques\\n"
                    },
                    {
                        "username": "lowiq",
                        "content": "According to the definition of h, \"if h of his/her N papers have at least h citations each, and the other N \\u2212 h papers have no more than h citations each.\" Looks like the h value is unique. The \"Note\" part looks unnecessary. \\n\\nProof: say there exist two h-indices, h1 < h2 (1), which means that, there are h2 numbers have value at least h2 (2) and N-h2 values have value at most h2 (3); there are h1 numbers have value at least h1 (4) and N-h1 values have value at most h1(5).\\n\\nWe have (1)(2)(3), (1) and (2) implies (4), but we can see (5) is not possible. Because we have N-h1 > N-h2, there exists at least one paper not in the set of N-h2 but in the set of N-h1, this paper should have value <= h1 (according to 5) and have value >= h2 (according to 2), this contradicts to (1). \\n\\nThe uniqueness follows."
                    },
                    {
                        "username": "job_xu",
                        "content": "Have two questions about the example 1:why not 5? There are two papers be cited at least 5 times.  why not 1? There are four papers be cited at least 1 times.  "
                    },
                    {
                        "username": "shivam_sharma2004",
                        "content": "5 cant be the ans because there do not exist atleast 5 elements in the array which are greater than 5. Talking about 1 yes it is valid value of h but you need to return the max value of h possible which is 3 in this case ."
                    }
                ]
            },
            {
                "id": 1567937,
                "content": [
                    {
                        "username": "cartesPerforees",
                        "content": "Excuse me, what kind of madman has published 5000 highly-cited papers?\\nI swear that dude must know incredibly much about Riemannian geometry and incredibly little about women"
                    },
                    {
                        "username": "ignacioariasdev",
                        "content": "[@dungtuanuet](/dungtuanuet) what gives u money?"
                    },
                    {
                        "username": "dungtuanuet",
                        "content": "rolf\\n"
                    },
                    {
                        "username": "ourlord",
                        "content": "According to the hint, I tried my version with the build-in `sort()` and get a one time AC. But if in a real interview scenario, do we allow to use build-in sort to solve this problem?\\n\\nWhat would the actual point the interviewee might look for?"
                    },
                    {
                        "username": "isydor",
                        "content": "[@Tribhuwan-Joshi](/Tribhuwan-Joshi) it is literally mentioned on the wiki page..."
                    },
                    {
                        "username": "NareshSawlani",
                        "content": "interviewer would be looking for your approach like in this question it would be using count sort manually no API"
                    },
                    {
                        "username": "Tribhuwan-Joshi",
                        "content": "Please don\\'t share hints like using `sort()` in the discussion "
                    },
                    {
                        "username": "haucaucau",
                        "content": "What if the input is [4,4,4,4,4,4,5]?\\nWhen I run with my code the answer is 4 and it was accepted.\\nBut I don\\'t understand cause there are 7 papers that have at least 4 citations,\\nand 0 paper no more than 4, which contradicts the description."
                    },
                    {
                        "username": "DxRz729",
                        "content": "Yes your the input has 7 papers with 4 citations, but the h in h-index means that it should be the same for no of citations and no of papers, so we will only take 4 papers as it is min of (4,7)"
                    },
                    {
                        "username": "hemantsingh4774",
                        "content": "[@hemantsingh4774](/hemantsingh4774)  reference: https://en.wikipedia.org/wiki/H-index"
                    },
                    {
                        "username": "hemantsingh4774",
                        "content": " For example, if an author has five publications, with 9, 7, 6, 2, and 1 citations (ordered from greatest to least), then the author\\'s h-index is 3, because the author has three publications with 3 or more citations. However, the author does not have four publications with 4 or more citations."
                    },
                    {
                        "username": "han35",
                        "content": "[0] means there is 1 paper and the citation is 0.\\nAccording to the description\\n\\n> A scientist has index h if h of his/her N papers have at least h citations each, and the other N \\u2212 h papers have no more than h citations each\\n\\nA scientist has 1(h) of his/her 1 paper has at least 0(h) citation, and the other 0 paper has no more than 0 citation.\\n\\nIs this a contradiction?"
                    },
                    {
                        "username": "yellowstar1014",
                        "content": "is it possible to have two h in this problem? please give an example?"
                    },
                    {
                        "username": "Dzuchun",
                        "content": "it literaly says to be a maximum value. how in the world would something have two distinct maximum values?"
                    },
                    {
                        "username": "pieceofpie",
                        "content": "![hehe.png](https://assets.leetcode.com/users/images/f16e4f9d-434f-4e5c-bf36-3cc106ea074a_1677794934.0254838.png)"
                    },
                    {
                        "username": "shuyi@cvs",
                        "content": "Hi,\\n\\nI came across a situation:  given citations = [3, 1, 7, 8, 9]. What will be the answer be?\\n\\nAccording to the definition of h-index on Wikipedia: \"A scientist has index h if h of his/her N papers have at least h citations each, and the other N \\u2212 h papers have no more than h citations each.\"\\n\\nWhen h=3, the definition will be \"A scientist has index 3 if 3 of his/her 5 papers have at least 3 citations each, and the other 2 papers have no more than 3 citations each.\" Obviously wrong....\\n\\nWhen h=4, the definition will be \"A scientist has index 4 if 4 of his/her 5 papers have at least 4 citations each, and the other 1 papers have no more than 4 citations each.\" Obviously wrong....\\n\\nWhen h=2, the definition will be \"A scientist has index 2 if 2 of his/her 5 papers have at least 2 citations each, and the other 3 papers have no more than 3 citations each.\" Obviously wrong....\\n\\nSo anybody can give me an answer? Or this question is a wrong one?"
                    },
                    {
                        "username": "user2118U",
                        "content": "Definition of h is The h-index is defined as the maximum value of h such that the given researcher has published at least h papers that have each been cited at least h times. See it is written at least h papers not exact h papers"
                    },
                    {
                        "username": "user2118U",
                        "content": "Dude there  is nothing written like that other papers have no more h citations. your example answer is 3 because researcher has published at least 3 papers and each paper has atleast 3 citations"
                    },
                    {
                        "username": "saurabh8katyal",
                        "content": "Answer will be 3, as the other 2 papers have no more than 3 citations each(1, 3). Not more than 3. Can be equal to."
                    },
                    {
                        "username": "Tsien",
                        "content": "In the problem description, there is a line \"Note: If there are several possible values for h, the maximum one is taken as the h-index.\"\\nI cannot come up with an example that could have several possible values for h. \\nIMO, there is only one value for h for each example according to the definition of H-Index.\\nPlease correct me if i'm wrong.\\nThanks!"
                    },
                    {
                        "username": "Shubh2407",
                        "content": "Anyone thought of Binary search, no need of sorting technique required,\\nDon\\'t open solution if you have not gave it a try using binary search:\\nhttps://leetcode.com/problems/h-index/solutions/3741453/easy-binary-search-problem-no-sorting-technique-required-o-nlogn/ "
                    },
                    {
                        "username": "vishalshrm539",
                        "content": "[@RajputShivraj](/RajputShivraj) He probably meant to apply binary search on the answer and not on the given array."
                    },
                    {
                        "username": "CriticalCorduroy",
                        "content": "How would binary search be beneficial without a sort applied to the citations?"
                    },
                    {
                        "username": "RajputShivraj",
                        "content": "binary search can be applied on sorted arrays na and you are saying no need of sorting techniques\\n"
                    },
                    {
                        "username": "lowiq",
                        "content": "According to the definition of h, \"if h of his/her N papers have at least h citations each, and the other N \\u2212 h papers have no more than h citations each.\" Looks like the h value is unique. The \"Note\" part looks unnecessary. \\n\\nProof: say there exist two h-indices, h1 < h2 (1), which means that, there are h2 numbers have value at least h2 (2) and N-h2 values have value at most h2 (3); there are h1 numbers have value at least h1 (4) and N-h1 values have value at most h1(5).\\n\\nWe have (1)(2)(3), (1) and (2) implies (4), but we can see (5) is not possible. Because we have N-h1 > N-h2, there exists at least one paper not in the set of N-h2 but in the set of N-h1, this paper should have value <= h1 (according to 5) and have value >= h2 (according to 2), this contradicts to (1). \\n\\nThe uniqueness follows."
                    },
                    {
                        "username": "job_xu",
                        "content": "Have two questions about the example 1:why not 5? There are two papers be cited at least 5 times.  why not 1? There are four papers be cited at least 1 times.  "
                    },
                    {
                        "username": "shivam_sharma2004",
                        "content": "5 cant be the ans because there do not exist atleast 5 elements in the array which are greater than 5. Talking about 1 yes it is valid value of h but you need to return the max value of h possible which is 3 in this case ."
                    }
                ]
            },
            {
                "id": 1566081,
                "content": [
                    {
                        "username": "cartesPerforees",
                        "content": "Excuse me, what kind of madman has published 5000 highly-cited papers?\\nI swear that dude must know incredibly much about Riemannian geometry and incredibly little about women"
                    },
                    {
                        "username": "ignacioariasdev",
                        "content": "[@dungtuanuet](/dungtuanuet) what gives u money?"
                    },
                    {
                        "username": "dungtuanuet",
                        "content": "rolf\\n"
                    },
                    {
                        "username": "ourlord",
                        "content": "According to the hint, I tried my version with the build-in `sort()` and get a one time AC. But if in a real interview scenario, do we allow to use build-in sort to solve this problem?\\n\\nWhat would the actual point the interviewee might look for?"
                    },
                    {
                        "username": "isydor",
                        "content": "[@Tribhuwan-Joshi](/Tribhuwan-Joshi) it is literally mentioned on the wiki page..."
                    },
                    {
                        "username": "NareshSawlani",
                        "content": "interviewer would be looking for your approach like in this question it would be using count sort manually no API"
                    },
                    {
                        "username": "Tribhuwan-Joshi",
                        "content": "Please don\\'t share hints like using `sort()` in the discussion "
                    },
                    {
                        "username": "haucaucau",
                        "content": "What if the input is [4,4,4,4,4,4,5]?\\nWhen I run with my code the answer is 4 and it was accepted.\\nBut I don\\'t understand cause there are 7 papers that have at least 4 citations,\\nand 0 paper no more than 4, which contradicts the description."
                    },
                    {
                        "username": "DxRz729",
                        "content": "Yes your the input has 7 papers with 4 citations, but the h in h-index means that it should be the same for no of citations and no of papers, so we will only take 4 papers as it is min of (4,7)"
                    },
                    {
                        "username": "hemantsingh4774",
                        "content": "[@hemantsingh4774](/hemantsingh4774)  reference: https://en.wikipedia.org/wiki/H-index"
                    },
                    {
                        "username": "hemantsingh4774",
                        "content": " For example, if an author has five publications, with 9, 7, 6, 2, and 1 citations (ordered from greatest to least), then the author\\'s h-index is 3, because the author has three publications with 3 or more citations. However, the author does not have four publications with 4 or more citations."
                    },
                    {
                        "username": "han35",
                        "content": "[0] means there is 1 paper and the citation is 0.\\nAccording to the description\\n\\n> A scientist has index h if h of his/her N papers have at least h citations each, and the other N \\u2212 h papers have no more than h citations each\\n\\nA scientist has 1(h) of his/her 1 paper has at least 0(h) citation, and the other 0 paper has no more than 0 citation.\\n\\nIs this a contradiction?"
                    },
                    {
                        "username": "yellowstar1014",
                        "content": "is it possible to have two h in this problem? please give an example?"
                    },
                    {
                        "username": "Dzuchun",
                        "content": "it literaly says to be a maximum value. how in the world would something have two distinct maximum values?"
                    },
                    {
                        "username": "pieceofpie",
                        "content": "![hehe.png](https://assets.leetcode.com/users/images/f16e4f9d-434f-4e5c-bf36-3cc106ea074a_1677794934.0254838.png)"
                    },
                    {
                        "username": "shuyi@cvs",
                        "content": "Hi,\\n\\nI came across a situation:  given citations = [3, 1, 7, 8, 9]. What will be the answer be?\\n\\nAccording to the definition of h-index on Wikipedia: \"A scientist has index h if h of his/her N papers have at least h citations each, and the other N \\u2212 h papers have no more than h citations each.\"\\n\\nWhen h=3, the definition will be \"A scientist has index 3 if 3 of his/her 5 papers have at least 3 citations each, and the other 2 papers have no more than 3 citations each.\" Obviously wrong....\\n\\nWhen h=4, the definition will be \"A scientist has index 4 if 4 of his/her 5 papers have at least 4 citations each, and the other 1 papers have no more than 4 citations each.\" Obviously wrong....\\n\\nWhen h=2, the definition will be \"A scientist has index 2 if 2 of his/her 5 papers have at least 2 citations each, and the other 3 papers have no more than 3 citations each.\" Obviously wrong....\\n\\nSo anybody can give me an answer? Or this question is a wrong one?"
                    },
                    {
                        "username": "user2118U",
                        "content": "Definition of h is The h-index is defined as the maximum value of h such that the given researcher has published at least h papers that have each been cited at least h times. See it is written at least h papers not exact h papers"
                    },
                    {
                        "username": "user2118U",
                        "content": "Dude there  is nothing written like that other papers have no more h citations. your example answer is 3 because researcher has published at least 3 papers and each paper has atleast 3 citations"
                    },
                    {
                        "username": "saurabh8katyal",
                        "content": "Answer will be 3, as the other 2 papers have no more than 3 citations each(1, 3). Not more than 3. Can be equal to."
                    },
                    {
                        "username": "Tsien",
                        "content": "In the problem description, there is a line \"Note: If there are several possible values for h, the maximum one is taken as the h-index.\"\\nI cannot come up with an example that could have several possible values for h. \\nIMO, there is only one value for h for each example according to the definition of H-Index.\\nPlease correct me if i'm wrong.\\nThanks!"
                    },
                    {
                        "username": "Shubh2407",
                        "content": "Anyone thought of Binary search, no need of sorting technique required,\\nDon\\'t open solution if you have not gave it a try using binary search:\\nhttps://leetcode.com/problems/h-index/solutions/3741453/easy-binary-search-problem-no-sorting-technique-required-o-nlogn/ "
                    },
                    {
                        "username": "vishalshrm539",
                        "content": "[@RajputShivraj](/RajputShivraj) He probably meant to apply binary search on the answer and not on the given array."
                    },
                    {
                        "username": "CriticalCorduroy",
                        "content": "How would binary search be beneficial without a sort applied to the citations?"
                    },
                    {
                        "username": "RajputShivraj",
                        "content": "binary search can be applied on sorted arrays na and you are saying no need of sorting techniques\\n"
                    },
                    {
                        "username": "lowiq",
                        "content": "According to the definition of h, \"if h of his/her N papers have at least h citations each, and the other N \\u2212 h papers have no more than h citations each.\" Looks like the h value is unique. The \"Note\" part looks unnecessary. \\n\\nProof: say there exist two h-indices, h1 < h2 (1), which means that, there are h2 numbers have value at least h2 (2) and N-h2 values have value at most h2 (3); there are h1 numbers have value at least h1 (4) and N-h1 values have value at most h1(5).\\n\\nWe have (1)(2)(3), (1) and (2) implies (4), but we can see (5) is not possible. Because we have N-h1 > N-h2, there exists at least one paper not in the set of N-h2 but in the set of N-h1, this paper should have value <= h1 (according to 5) and have value >= h2 (according to 2), this contradicts to (1). \\n\\nThe uniqueness follows."
                    },
                    {
                        "username": "job_xu",
                        "content": "Have two questions about the example 1:why not 5? There are two papers be cited at least 5 times.  why not 1? There are four papers be cited at least 1 times.  "
                    },
                    {
                        "username": "shivam_sharma2004",
                        "content": "5 cant be the ans because there do not exist atleast 5 elements in the array which are greater than 5. Talking about 1 yes it is valid value of h but you need to return the max value of h possible which is 3 in this case ."
                    }
                ]
            },
            {
                "id": 1569052,
                "content": [
                    {
                        "username": "cartesPerforees",
                        "content": "Excuse me, what kind of madman has published 5000 highly-cited papers?\\nI swear that dude must know incredibly much about Riemannian geometry and incredibly little about women"
                    },
                    {
                        "username": "ignacioariasdev",
                        "content": "[@dungtuanuet](/dungtuanuet) what gives u money?"
                    },
                    {
                        "username": "dungtuanuet",
                        "content": "rolf\\n"
                    },
                    {
                        "username": "ourlord",
                        "content": "According to the hint, I tried my version with the build-in `sort()` and get a one time AC. But if in a real interview scenario, do we allow to use build-in sort to solve this problem?\\n\\nWhat would the actual point the interviewee might look for?"
                    },
                    {
                        "username": "isydor",
                        "content": "[@Tribhuwan-Joshi](/Tribhuwan-Joshi) it is literally mentioned on the wiki page..."
                    },
                    {
                        "username": "NareshSawlani",
                        "content": "interviewer would be looking for your approach like in this question it would be using count sort manually no API"
                    },
                    {
                        "username": "Tribhuwan-Joshi",
                        "content": "Please don\\'t share hints like using `sort()` in the discussion "
                    },
                    {
                        "username": "haucaucau",
                        "content": "What if the input is [4,4,4,4,4,4,5]?\\nWhen I run with my code the answer is 4 and it was accepted.\\nBut I don\\'t understand cause there are 7 papers that have at least 4 citations,\\nand 0 paper no more than 4, which contradicts the description."
                    },
                    {
                        "username": "DxRz729",
                        "content": "Yes your the input has 7 papers with 4 citations, but the h in h-index means that it should be the same for no of citations and no of papers, so we will only take 4 papers as it is min of (4,7)"
                    },
                    {
                        "username": "hemantsingh4774",
                        "content": "[@hemantsingh4774](/hemantsingh4774)  reference: https://en.wikipedia.org/wiki/H-index"
                    },
                    {
                        "username": "hemantsingh4774",
                        "content": " For example, if an author has five publications, with 9, 7, 6, 2, and 1 citations (ordered from greatest to least), then the author\\'s h-index is 3, because the author has three publications with 3 or more citations. However, the author does not have four publications with 4 or more citations."
                    },
                    {
                        "username": "han35",
                        "content": "[0] means there is 1 paper and the citation is 0.\\nAccording to the description\\n\\n> A scientist has index h if h of his/her N papers have at least h citations each, and the other N \\u2212 h papers have no more than h citations each\\n\\nA scientist has 1(h) of his/her 1 paper has at least 0(h) citation, and the other 0 paper has no more than 0 citation.\\n\\nIs this a contradiction?"
                    },
                    {
                        "username": "yellowstar1014",
                        "content": "is it possible to have two h in this problem? please give an example?"
                    },
                    {
                        "username": "Dzuchun",
                        "content": "it literaly says to be a maximum value. how in the world would something have two distinct maximum values?"
                    },
                    {
                        "username": "pieceofpie",
                        "content": "![hehe.png](https://assets.leetcode.com/users/images/f16e4f9d-434f-4e5c-bf36-3cc106ea074a_1677794934.0254838.png)"
                    },
                    {
                        "username": "shuyi@cvs",
                        "content": "Hi,\\n\\nI came across a situation:  given citations = [3, 1, 7, 8, 9]. What will be the answer be?\\n\\nAccording to the definition of h-index on Wikipedia: \"A scientist has index h if h of his/her N papers have at least h citations each, and the other N \\u2212 h papers have no more than h citations each.\"\\n\\nWhen h=3, the definition will be \"A scientist has index 3 if 3 of his/her 5 papers have at least 3 citations each, and the other 2 papers have no more than 3 citations each.\" Obviously wrong....\\n\\nWhen h=4, the definition will be \"A scientist has index 4 if 4 of his/her 5 papers have at least 4 citations each, and the other 1 papers have no more than 4 citations each.\" Obviously wrong....\\n\\nWhen h=2, the definition will be \"A scientist has index 2 if 2 of his/her 5 papers have at least 2 citations each, and the other 3 papers have no more than 3 citations each.\" Obviously wrong....\\n\\nSo anybody can give me an answer? Or this question is a wrong one?"
                    },
                    {
                        "username": "user2118U",
                        "content": "Definition of h is The h-index is defined as the maximum value of h such that the given researcher has published at least h papers that have each been cited at least h times. See it is written at least h papers not exact h papers"
                    },
                    {
                        "username": "user2118U",
                        "content": "Dude there  is nothing written like that other papers have no more h citations. your example answer is 3 because researcher has published at least 3 papers and each paper has atleast 3 citations"
                    },
                    {
                        "username": "saurabh8katyal",
                        "content": "Answer will be 3, as the other 2 papers have no more than 3 citations each(1, 3). Not more than 3. Can be equal to."
                    },
                    {
                        "username": "Tsien",
                        "content": "In the problem description, there is a line \"Note: If there are several possible values for h, the maximum one is taken as the h-index.\"\\nI cannot come up with an example that could have several possible values for h. \\nIMO, there is only one value for h for each example according to the definition of H-Index.\\nPlease correct me if i'm wrong.\\nThanks!"
                    },
                    {
                        "username": "Shubh2407",
                        "content": "Anyone thought of Binary search, no need of sorting technique required,\\nDon\\'t open solution if you have not gave it a try using binary search:\\nhttps://leetcode.com/problems/h-index/solutions/3741453/easy-binary-search-problem-no-sorting-technique-required-o-nlogn/ "
                    },
                    {
                        "username": "vishalshrm539",
                        "content": "[@RajputShivraj](/RajputShivraj) He probably meant to apply binary search on the answer and not on the given array."
                    },
                    {
                        "username": "CriticalCorduroy",
                        "content": "How would binary search be beneficial without a sort applied to the citations?"
                    },
                    {
                        "username": "RajputShivraj",
                        "content": "binary search can be applied on sorted arrays na and you are saying no need of sorting techniques\\n"
                    },
                    {
                        "username": "lowiq",
                        "content": "According to the definition of h, \"if h of his/her N papers have at least h citations each, and the other N \\u2212 h papers have no more than h citations each.\" Looks like the h value is unique. The \"Note\" part looks unnecessary. \\n\\nProof: say there exist two h-indices, h1 < h2 (1), which means that, there are h2 numbers have value at least h2 (2) and N-h2 values have value at most h2 (3); there are h1 numbers have value at least h1 (4) and N-h1 values have value at most h1(5).\\n\\nWe have (1)(2)(3), (1) and (2) implies (4), but we can see (5) is not possible. Because we have N-h1 > N-h2, there exists at least one paper not in the set of N-h2 but in the set of N-h1, this paper should have value <= h1 (according to 5) and have value >= h2 (according to 2), this contradicts to (1). \\n\\nThe uniqueness follows."
                    },
                    {
                        "username": "job_xu",
                        "content": "Have two questions about the example 1:why not 5? There are two papers be cited at least 5 times.  why not 1? There are four papers be cited at least 1 times.  "
                    },
                    {
                        "username": "shivam_sharma2004",
                        "content": "5 cant be the ans because there do not exist atleast 5 elements in the array which are greater than 5. Talking about 1 yes it is valid value of h but you need to return the max value of h possible which is 3 in this case ."
                    }
                ]
            },
            {
                "id": 1569050,
                "content": [
                    {
                        "username": "cartesPerforees",
                        "content": "Excuse me, what kind of madman has published 5000 highly-cited papers?\\nI swear that dude must know incredibly much about Riemannian geometry and incredibly little about women"
                    },
                    {
                        "username": "ignacioariasdev",
                        "content": "[@dungtuanuet](/dungtuanuet) what gives u money?"
                    },
                    {
                        "username": "dungtuanuet",
                        "content": "rolf\\n"
                    },
                    {
                        "username": "ourlord",
                        "content": "According to the hint, I tried my version with the build-in `sort()` and get a one time AC. But if in a real interview scenario, do we allow to use build-in sort to solve this problem?\\n\\nWhat would the actual point the interviewee might look for?"
                    },
                    {
                        "username": "isydor",
                        "content": "[@Tribhuwan-Joshi](/Tribhuwan-Joshi) it is literally mentioned on the wiki page..."
                    },
                    {
                        "username": "NareshSawlani",
                        "content": "interviewer would be looking for your approach like in this question it would be using count sort manually no API"
                    },
                    {
                        "username": "Tribhuwan-Joshi",
                        "content": "Please don\\'t share hints like using `sort()` in the discussion "
                    },
                    {
                        "username": "haucaucau",
                        "content": "What if the input is [4,4,4,4,4,4,5]?\\nWhen I run with my code the answer is 4 and it was accepted.\\nBut I don\\'t understand cause there are 7 papers that have at least 4 citations,\\nand 0 paper no more than 4, which contradicts the description."
                    },
                    {
                        "username": "DxRz729",
                        "content": "Yes your the input has 7 papers with 4 citations, but the h in h-index means that it should be the same for no of citations and no of papers, so we will only take 4 papers as it is min of (4,7)"
                    },
                    {
                        "username": "hemantsingh4774",
                        "content": "[@hemantsingh4774](/hemantsingh4774)  reference: https://en.wikipedia.org/wiki/H-index"
                    },
                    {
                        "username": "hemantsingh4774",
                        "content": " For example, if an author has five publications, with 9, 7, 6, 2, and 1 citations (ordered from greatest to least), then the author\\'s h-index is 3, because the author has three publications with 3 or more citations. However, the author does not have four publications with 4 or more citations."
                    },
                    {
                        "username": "han35",
                        "content": "[0] means there is 1 paper and the citation is 0.\\nAccording to the description\\n\\n> A scientist has index h if h of his/her N papers have at least h citations each, and the other N \\u2212 h papers have no more than h citations each\\n\\nA scientist has 1(h) of his/her 1 paper has at least 0(h) citation, and the other 0 paper has no more than 0 citation.\\n\\nIs this a contradiction?"
                    },
                    {
                        "username": "yellowstar1014",
                        "content": "is it possible to have two h in this problem? please give an example?"
                    },
                    {
                        "username": "Dzuchun",
                        "content": "it literaly says to be a maximum value. how in the world would something have two distinct maximum values?"
                    },
                    {
                        "username": "pieceofpie",
                        "content": "![hehe.png](https://assets.leetcode.com/users/images/f16e4f9d-434f-4e5c-bf36-3cc106ea074a_1677794934.0254838.png)"
                    },
                    {
                        "username": "shuyi@cvs",
                        "content": "Hi,\\n\\nI came across a situation:  given citations = [3, 1, 7, 8, 9]. What will be the answer be?\\n\\nAccording to the definition of h-index on Wikipedia: \"A scientist has index h if h of his/her N papers have at least h citations each, and the other N \\u2212 h papers have no more than h citations each.\"\\n\\nWhen h=3, the definition will be \"A scientist has index 3 if 3 of his/her 5 papers have at least 3 citations each, and the other 2 papers have no more than 3 citations each.\" Obviously wrong....\\n\\nWhen h=4, the definition will be \"A scientist has index 4 if 4 of his/her 5 papers have at least 4 citations each, and the other 1 papers have no more than 4 citations each.\" Obviously wrong....\\n\\nWhen h=2, the definition will be \"A scientist has index 2 if 2 of his/her 5 papers have at least 2 citations each, and the other 3 papers have no more than 3 citations each.\" Obviously wrong....\\n\\nSo anybody can give me an answer? Or this question is a wrong one?"
                    },
                    {
                        "username": "user2118U",
                        "content": "Definition of h is The h-index is defined as the maximum value of h such that the given researcher has published at least h papers that have each been cited at least h times. See it is written at least h papers not exact h papers"
                    },
                    {
                        "username": "user2118U",
                        "content": "Dude there  is nothing written like that other papers have no more h citations. your example answer is 3 because researcher has published at least 3 papers and each paper has atleast 3 citations"
                    },
                    {
                        "username": "saurabh8katyal",
                        "content": "Answer will be 3, as the other 2 papers have no more than 3 citations each(1, 3). Not more than 3. Can be equal to."
                    },
                    {
                        "username": "Tsien",
                        "content": "In the problem description, there is a line \"Note: If there are several possible values for h, the maximum one is taken as the h-index.\"\\nI cannot come up with an example that could have several possible values for h. \\nIMO, there is only one value for h for each example according to the definition of H-Index.\\nPlease correct me if i'm wrong.\\nThanks!"
                    },
                    {
                        "username": "Shubh2407",
                        "content": "Anyone thought of Binary search, no need of sorting technique required,\\nDon\\'t open solution if you have not gave it a try using binary search:\\nhttps://leetcode.com/problems/h-index/solutions/3741453/easy-binary-search-problem-no-sorting-technique-required-o-nlogn/ "
                    },
                    {
                        "username": "vishalshrm539",
                        "content": "[@RajputShivraj](/RajputShivraj) He probably meant to apply binary search on the answer and not on the given array."
                    },
                    {
                        "username": "CriticalCorduroy",
                        "content": "How would binary search be beneficial without a sort applied to the citations?"
                    },
                    {
                        "username": "RajputShivraj",
                        "content": "binary search can be applied on sorted arrays na and you are saying no need of sorting techniques\\n"
                    },
                    {
                        "username": "lowiq",
                        "content": "According to the definition of h, \"if h of his/her N papers have at least h citations each, and the other N \\u2212 h papers have no more than h citations each.\" Looks like the h value is unique. The \"Note\" part looks unnecessary. \\n\\nProof: say there exist two h-indices, h1 < h2 (1), which means that, there are h2 numbers have value at least h2 (2) and N-h2 values have value at most h2 (3); there are h1 numbers have value at least h1 (4) and N-h1 values have value at most h1(5).\\n\\nWe have (1)(2)(3), (1) and (2) implies (4), but we can see (5) is not possible. Because we have N-h1 > N-h2, there exists at least one paper not in the set of N-h2 but in the set of N-h1, this paper should have value <= h1 (according to 5) and have value >= h2 (according to 2), this contradicts to (1). \\n\\nThe uniqueness follows."
                    },
                    {
                        "username": "job_xu",
                        "content": "Have two questions about the example 1:why not 5? There are two papers be cited at least 5 times.  why not 1? There are four papers be cited at least 1 times.  "
                    },
                    {
                        "username": "shivam_sharma2004",
                        "content": "5 cant be the ans because there do not exist atleast 5 elements in the array which are greater than 5. Talking about 1 yes it is valid value of h but you need to return the max value of h possible which is 3 in this case ."
                    }
                ]
            },
            {
                "id": 1963174,
                "content": [
                    {
                        "username": "cartesPerforees",
                        "content": "Excuse me, what kind of madman has published 5000 highly-cited papers?\\nI swear that dude must know incredibly much about Riemannian geometry and incredibly little about women"
                    },
                    {
                        "username": "ignacioariasdev",
                        "content": "[@dungtuanuet](/dungtuanuet) what gives u money?"
                    },
                    {
                        "username": "dungtuanuet",
                        "content": "rolf\\n"
                    },
                    {
                        "username": "ourlord",
                        "content": "According to the hint, I tried my version with the build-in `sort()` and get a one time AC. But if in a real interview scenario, do we allow to use build-in sort to solve this problem?\\n\\nWhat would the actual point the interviewee might look for?"
                    },
                    {
                        "username": "isydor",
                        "content": "[@Tribhuwan-Joshi](/Tribhuwan-Joshi) it is literally mentioned on the wiki page..."
                    },
                    {
                        "username": "NareshSawlani",
                        "content": "interviewer would be looking for your approach like in this question it would be using count sort manually no API"
                    },
                    {
                        "username": "Tribhuwan-Joshi",
                        "content": "Please don\\'t share hints like using `sort()` in the discussion "
                    },
                    {
                        "username": "haucaucau",
                        "content": "What if the input is [4,4,4,4,4,4,5]?\\nWhen I run with my code the answer is 4 and it was accepted.\\nBut I don\\'t understand cause there are 7 papers that have at least 4 citations,\\nand 0 paper no more than 4, which contradicts the description."
                    },
                    {
                        "username": "DxRz729",
                        "content": "Yes your the input has 7 papers with 4 citations, but the h in h-index means that it should be the same for no of citations and no of papers, so we will only take 4 papers as it is min of (4,7)"
                    },
                    {
                        "username": "hemantsingh4774",
                        "content": "[@hemantsingh4774](/hemantsingh4774)  reference: https://en.wikipedia.org/wiki/H-index"
                    },
                    {
                        "username": "hemantsingh4774",
                        "content": " For example, if an author has five publications, with 9, 7, 6, 2, and 1 citations (ordered from greatest to least), then the author\\'s h-index is 3, because the author has three publications with 3 or more citations. However, the author does not have four publications with 4 or more citations."
                    },
                    {
                        "username": "han35",
                        "content": "[0] means there is 1 paper and the citation is 0.\\nAccording to the description\\n\\n> A scientist has index h if h of his/her N papers have at least h citations each, and the other N \\u2212 h papers have no more than h citations each\\n\\nA scientist has 1(h) of his/her 1 paper has at least 0(h) citation, and the other 0 paper has no more than 0 citation.\\n\\nIs this a contradiction?"
                    },
                    {
                        "username": "yellowstar1014",
                        "content": "is it possible to have two h in this problem? please give an example?"
                    },
                    {
                        "username": "Dzuchun",
                        "content": "it literaly says to be a maximum value. how in the world would something have two distinct maximum values?"
                    },
                    {
                        "username": "pieceofpie",
                        "content": "![hehe.png](https://assets.leetcode.com/users/images/f16e4f9d-434f-4e5c-bf36-3cc106ea074a_1677794934.0254838.png)"
                    },
                    {
                        "username": "shuyi@cvs",
                        "content": "Hi,\\n\\nI came across a situation:  given citations = [3, 1, 7, 8, 9]. What will be the answer be?\\n\\nAccording to the definition of h-index on Wikipedia: \"A scientist has index h if h of his/her N papers have at least h citations each, and the other N \\u2212 h papers have no more than h citations each.\"\\n\\nWhen h=3, the definition will be \"A scientist has index 3 if 3 of his/her 5 papers have at least 3 citations each, and the other 2 papers have no more than 3 citations each.\" Obviously wrong....\\n\\nWhen h=4, the definition will be \"A scientist has index 4 if 4 of his/her 5 papers have at least 4 citations each, and the other 1 papers have no more than 4 citations each.\" Obviously wrong....\\n\\nWhen h=2, the definition will be \"A scientist has index 2 if 2 of his/her 5 papers have at least 2 citations each, and the other 3 papers have no more than 3 citations each.\" Obviously wrong....\\n\\nSo anybody can give me an answer? Or this question is a wrong one?"
                    },
                    {
                        "username": "user2118U",
                        "content": "Definition of h is The h-index is defined as the maximum value of h such that the given researcher has published at least h papers that have each been cited at least h times. See it is written at least h papers not exact h papers"
                    },
                    {
                        "username": "user2118U",
                        "content": "Dude there  is nothing written like that other papers have no more h citations. your example answer is 3 because researcher has published at least 3 papers and each paper has atleast 3 citations"
                    },
                    {
                        "username": "saurabh8katyal",
                        "content": "Answer will be 3, as the other 2 papers have no more than 3 citations each(1, 3). Not more than 3. Can be equal to."
                    },
                    {
                        "username": "Tsien",
                        "content": "In the problem description, there is a line \"Note: If there are several possible values for h, the maximum one is taken as the h-index.\"\\nI cannot come up with an example that could have several possible values for h. \\nIMO, there is only one value for h for each example according to the definition of H-Index.\\nPlease correct me if i'm wrong.\\nThanks!"
                    },
                    {
                        "username": "Shubh2407",
                        "content": "Anyone thought of Binary search, no need of sorting technique required,\\nDon\\'t open solution if you have not gave it a try using binary search:\\nhttps://leetcode.com/problems/h-index/solutions/3741453/easy-binary-search-problem-no-sorting-technique-required-o-nlogn/ "
                    },
                    {
                        "username": "vishalshrm539",
                        "content": "[@RajputShivraj](/RajputShivraj) He probably meant to apply binary search on the answer and not on the given array."
                    },
                    {
                        "username": "CriticalCorduroy",
                        "content": "How would binary search be beneficial without a sort applied to the citations?"
                    },
                    {
                        "username": "RajputShivraj",
                        "content": "binary search can be applied on sorted arrays na and you are saying no need of sorting techniques\\n"
                    },
                    {
                        "username": "lowiq",
                        "content": "According to the definition of h, \"if h of his/her N papers have at least h citations each, and the other N \\u2212 h papers have no more than h citations each.\" Looks like the h value is unique. The \"Note\" part looks unnecessary. \\n\\nProof: say there exist two h-indices, h1 < h2 (1), which means that, there are h2 numbers have value at least h2 (2) and N-h2 values have value at most h2 (3); there are h1 numbers have value at least h1 (4) and N-h1 values have value at most h1(5).\\n\\nWe have (1)(2)(3), (1) and (2) implies (4), but we can see (5) is not possible. Because we have N-h1 > N-h2, there exists at least one paper not in the set of N-h2 but in the set of N-h1, this paper should have value <= h1 (according to 5) and have value >= h2 (according to 2), this contradicts to (1). \\n\\nThe uniqueness follows."
                    },
                    {
                        "username": "job_xu",
                        "content": "Have two questions about the example 1:why not 5? There are two papers be cited at least 5 times.  why not 1? There are four papers be cited at least 1 times.  "
                    },
                    {
                        "username": "shivam_sharma2004",
                        "content": "5 cant be the ans because there do not exist atleast 5 elements in the array which are greater than 5. Talking about 1 yes it is valid value of h but you need to return the max value of h possible which is 3 in this case ."
                    }
                ]
            },
            {
                "id": 1569051,
                "content": [
                    {
                        "username": "cartesPerforees",
                        "content": "Excuse me, what kind of madman has published 5000 highly-cited papers?\\nI swear that dude must know incredibly much about Riemannian geometry and incredibly little about women"
                    },
                    {
                        "username": "ignacioariasdev",
                        "content": "[@dungtuanuet](/dungtuanuet) what gives u money?"
                    },
                    {
                        "username": "dungtuanuet",
                        "content": "rolf\\n"
                    },
                    {
                        "username": "ourlord",
                        "content": "According to the hint, I tried my version with the build-in `sort()` and get a one time AC. But if in a real interview scenario, do we allow to use build-in sort to solve this problem?\\n\\nWhat would the actual point the interviewee might look for?"
                    },
                    {
                        "username": "isydor",
                        "content": "[@Tribhuwan-Joshi](/Tribhuwan-Joshi) it is literally mentioned on the wiki page..."
                    },
                    {
                        "username": "NareshSawlani",
                        "content": "interviewer would be looking for your approach like in this question it would be using count sort manually no API"
                    },
                    {
                        "username": "Tribhuwan-Joshi",
                        "content": "Please don\\'t share hints like using `sort()` in the discussion "
                    },
                    {
                        "username": "haucaucau",
                        "content": "What if the input is [4,4,4,4,4,4,5]?\\nWhen I run with my code the answer is 4 and it was accepted.\\nBut I don\\'t understand cause there are 7 papers that have at least 4 citations,\\nand 0 paper no more than 4, which contradicts the description."
                    },
                    {
                        "username": "DxRz729",
                        "content": "Yes your the input has 7 papers with 4 citations, but the h in h-index means that it should be the same for no of citations and no of papers, so we will only take 4 papers as it is min of (4,7)"
                    },
                    {
                        "username": "hemantsingh4774",
                        "content": "[@hemantsingh4774](/hemantsingh4774)  reference: https://en.wikipedia.org/wiki/H-index"
                    },
                    {
                        "username": "hemantsingh4774",
                        "content": " For example, if an author has five publications, with 9, 7, 6, 2, and 1 citations (ordered from greatest to least), then the author\\'s h-index is 3, because the author has three publications with 3 or more citations. However, the author does not have four publications with 4 or more citations."
                    },
                    {
                        "username": "han35",
                        "content": "[0] means there is 1 paper and the citation is 0.\\nAccording to the description\\n\\n> A scientist has index h if h of his/her N papers have at least h citations each, and the other N \\u2212 h papers have no more than h citations each\\n\\nA scientist has 1(h) of his/her 1 paper has at least 0(h) citation, and the other 0 paper has no more than 0 citation.\\n\\nIs this a contradiction?"
                    },
                    {
                        "username": "yellowstar1014",
                        "content": "is it possible to have two h in this problem? please give an example?"
                    },
                    {
                        "username": "Dzuchun",
                        "content": "it literaly says to be a maximum value. how in the world would something have two distinct maximum values?"
                    },
                    {
                        "username": "pieceofpie",
                        "content": "![hehe.png](https://assets.leetcode.com/users/images/f16e4f9d-434f-4e5c-bf36-3cc106ea074a_1677794934.0254838.png)"
                    },
                    {
                        "username": "shuyi@cvs",
                        "content": "Hi,\\n\\nI came across a situation:  given citations = [3, 1, 7, 8, 9]. What will be the answer be?\\n\\nAccording to the definition of h-index on Wikipedia: \"A scientist has index h if h of his/her N papers have at least h citations each, and the other N \\u2212 h papers have no more than h citations each.\"\\n\\nWhen h=3, the definition will be \"A scientist has index 3 if 3 of his/her 5 papers have at least 3 citations each, and the other 2 papers have no more than 3 citations each.\" Obviously wrong....\\n\\nWhen h=4, the definition will be \"A scientist has index 4 if 4 of his/her 5 papers have at least 4 citations each, and the other 1 papers have no more than 4 citations each.\" Obviously wrong....\\n\\nWhen h=2, the definition will be \"A scientist has index 2 if 2 of his/her 5 papers have at least 2 citations each, and the other 3 papers have no more than 3 citations each.\" Obviously wrong....\\n\\nSo anybody can give me an answer? Or this question is a wrong one?"
                    },
                    {
                        "username": "user2118U",
                        "content": "Definition of h is The h-index is defined as the maximum value of h such that the given researcher has published at least h papers that have each been cited at least h times. See it is written at least h papers not exact h papers"
                    },
                    {
                        "username": "user2118U",
                        "content": "Dude there  is nothing written like that other papers have no more h citations. your example answer is 3 because researcher has published at least 3 papers and each paper has atleast 3 citations"
                    },
                    {
                        "username": "saurabh8katyal",
                        "content": "Answer will be 3, as the other 2 papers have no more than 3 citations each(1, 3). Not more than 3. Can be equal to."
                    },
                    {
                        "username": "Tsien",
                        "content": "In the problem description, there is a line \"Note: If there are several possible values for h, the maximum one is taken as the h-index.\"\\nI cannot come up with an example that could have several possible values for h. \\nIMO, there is only one value for h for each example according to the definition of H-Index.\\nPlease correct me if i'm wrong.\\nThanks!"
                    },
                    {
                        "username": "Shubh2407",
                        "content": "Anyone thought of Binary search, no need of sorting technique required,\\nDon\\'t open solution if you have not gave it a try using binary search:\\nhttps://leetcode.com/problems/h-index/solutions/3741453/easy-binary-search-problem-no-sorting-technique-required-o-nlogn/ "
                    },
                    {
                        "username": "vishalshrm539",
                        "content": "[@RajputShivraj](/RajputShivraj) He probably meant to apply binary search on the answer and not on the given array."
                    },
                    {
                        "username": "CriticalCorduroy",
                        "content": "How would binary search be beneficial without a sort applied to the citations?"
                    },
                    {
                        "username": "RajputShivraj",
                        "content": "binary search can be applied on sorted arrays na and you are saying no need of sorting techniques\\n"
                    },
                    {
                        "username": "lowiq",
                        "content": "According to the definition of h, \"if h of his/her N papers have at least h citations each, and the other N \\u2212 h papers have no more than h citations each.\" Looks like the h value is unique. The \"Note\" part looks unnecessary. \\n\\nProof: say there exist two h-indices, h1 < h2 (1), which means that, there are h2 numbers have value at least h2 (2) and N-h2 values have value at most h2 (3); there are h1 numbers have value at least h1 (4) and N-h1 values have value at most h1(5).\\n\\nWe have (1)(2)(3), (1) and (2) implies (4), but we can see (5) is not possible. Because we have N-h1 > N-h2, there exists at least one paper not in the set of N-h2 but in the set of N-h1, this paper should have value <= h1 (according to 5) and have value >= h2 (according to 2), this contradicts to (1). \\n\\nThe uniqueness follows."
                    },
                    {
                        "username": "job_xu",
                        "content": "Have two questions about the example 1:why not 5? There are two papers be cited at least 5 times.  why not 1? There are four papers be cited at least 1 times.  "
                    },
                    {
                        "username": "shivam_sharma2004",
                        "content": "5 cant be the ans because there do not exist atleast 5 elements in the array which are greater than 5. Talking about 1 yes it is valid value of h but you need to return the max value of h possible which is 3 in this case ."
                    }
                ]
            },
            {
                "id": 1941363,
                "content": [
                    {
                        "username": "cartesPerforees",
                        "content": "Excuse me, what kind of madman has published 5000 highly-cited papers?\\nI swear that dude must know incredibly much about Riemannian geometry and incredibly little about women"
                    },
                    {
                        "username": "ignacioariasdev",
                        "content": "[@dungtuanuet](/dungtuanuet) what gives u money?"
                    },
                    {
                        "username": "dungtuanuet",
                        "content": "rolf\\n"
                    },
                    {
                        "username": "ourlord",
                        "content": "According to the hint, I tried my version with the build-in `sort()` and get a one time AC. But if in a real interview scenario, do we allow to use build-in sort to solve this problem?\\n\\nWhat would the actual point the interviewee might look for?"
                    },
                    {
                        "username": "isydor",
                        "content": "[@Tribhuwan-Joshi](/Tribhuwan-Joshi) it is literally mentioned on the wiki page..."
                    },
                    {
                        "username": "NareshSawlani",
                        "content": "interviewer would be looking for your approach like in this question it would be using count sort manually no API"
                    },
                    {
                        "username": "Tribhuwan-Joshi",
                        "content": "Please don\\'t share hints like using `sort()` in the discussion "
                    },
                    {
                        "username": "haucaucau",
                        "content": "What if the input is [4,4,4,4,4,4,5]?\\nWhen I run with my code the answer is 4 and it was accepted.\\nBut I don\\'t understand cause there are 7 papers that have at least 4 citations,\\nand 0 paper no more than 4, which contradicts the description."
                    },
                    {
                        "username": "DxRz729",
                        "content": "Yes your the input has 7 papers with 4 citations, but the h in h-index means that it should be the same for no of citations and no of papers, so we will only take 4 papers as it is min of (4,7)"
                    },
                    {
                        "username": "hemantsingh4774",
                        "content": "[@hemantsingh4774](/hemantsingh4774)  reference: https://en.wikipedia.org/wiki/H-index"
                    },
                    {
                        "username": "hemantsingh4774",
                        "content": " For example, if an author has five publications, with 9, 7, 6, 2, and 1 citations (ordered from greatest to least), then the author\\'s h-index is 3, because the author has three publications with 3 or more citations. However, the author does not have four publications with 4 or more citations."
                    },
                    {
                        "username": "han35",
                        "content": "[0] means there is 1 paper and the citation is 0.\\nAccording to the description\\n\\n> A scientist has index h if h of his/her N papers have at least h citations each, and the other N \\u2212 h papers have no more than h citations each\\n\\nA scientist has 1(h) of his/her 1 paper has at least 0(h) citation, and the other 0 paper has no more than 0 citation.\\n\\nIs this a contradiction?"
                    },
                    {
                        "username": "yellowstar1014",
                        "content": "is it possible to have two h in this problem? please give an example?"
                    },
                    {
                        "username": "Dzuchun",
                        "content": "it literaly says to be a maximum value. how in the world would something have two distinct maximum values?"
                    },
                    {
                        "username": "pieceofpie",
                        "content": "![hehe.png](https://assets.leetcode.com/users/images/f16e4f9d-434f-4e5c-bf36-3cc106ea074a_1677794934.0254838.png)"
                    },
                    {
                        "username": "shuyi@cvs",
                        "content": "Hi,\\n\\nI came across a situation:  given citations = [3, 1, 7, 8, 9]. What will be the answer be?\\n\\nAccording to the definition of h-index on Wikipedia: \"A scientist has index h if h of his/her N papers have at least h citations each, and the other N \\u2212 h papers have no more than h citations each.\"\\n\\nWhen h=3, the definition will be \"A scientist has index 3 if 3 of his/her 5 papers have at least 3 citations each, and the other 2 papers have no more than 3 citations each.\" Obviously wrong....\\n\\nWhen h=4, the definition will be \"A scientist has index 4 if 4 of his/her 5 papers have at least 4 citations each, and the other 1 papers have no more than 4 citations each.\" Obviously wrong....\\n\\nWhen h=2, the definition will be \"A scientist has index 2 if 2 of his/her 5 papers have at least 2 citations each, and the other 3 papers have no more than 3 citations each.\" Obviously wrong....\\n\\nSo anybody can give me an answer? Or this question is a wrong one?"
                    },
                    {
                        "username": "user2118U",
                        "content": "Definition of h is The h-index is defined as the maximum value of h such that the given researcher has published at least h papers that have each been cited at least h times. See it is written at least h papers not exact h papers"
                    },
                    {
                        "username": "user2118U",
                        "content": "Dude there  is nothing written like that other papers have no more h citations. your example answer is 3 because researcher has published at least 3 papers and each paper has atleast 3 citations"
                    },
                    {
                        "username": "saurabh8katyal",
                        "content": "Answer will be 3, as the other 2 papers have no more than 3 citations each(1, 3). Not more than 3. Can be equal to."
                    },
                    {
                        "username": "Tsien",
                        "content": "In the problem description, there is a line \"Note: If there are several possible values for h, the maximum one is taken as the h-index.\"\\nI cannot come up with an example that could have several possible values for h. \\nIMO, there is only one value for h for each example according to the definition of H-Index.\\nPlease correct me if i'm wrong.\\nThanks!"
                    },
                    {
                        "username": "Shubh2407",
                        "content": "Anyone thought of Binary search, no need of sorting technique required,\\nDon\\'t open solution if you have not gave it a try using binary search:\\nhttps://leetcode.com/problems/h-index/solutions/3741453/easy-binary-search-problem-no-sorting-technique-required-o-nlogn/ "
                    },
                    {
                        "username": "vishalshrm539",
                        "content": "[@RajputShivraj](/RajputShivraj) He probably meant to apply binary search on the answer and not on the given array."
                    },
                    {
                        "username": "CriticalCorduroy",
                        "content": "How would binary search be beneficial without a sort applied to the citations?"
                    },
                    {
                        "username": "RajputShivraj",
                        "content": "binary search can be applied on sorted arrays na and you are saying no need of sorting techniques\\n"
                    },
                    {
                        "username": "lowiq",
                        "content": "According to the definition of h, \"if h of his/her N papers have at least h citations each, and the other N \\u2212 h papers have no more than h citations each.\" Looks like the h value is unique. The \"Note\" part looks unnecessary. \\n\\nProof: say there exist two h-indices, h1 < h2 (1), which means that, there are h2 numbers have value at least h2 (2) and N-h2 values have value at most h2 (3); there are h1 numbers have value at least h1 (4) and N-h1 values have value at most h1(5).\\n\\nWe have (1)(2)(3), (1) and (2) implies (4), but we can see (5) is not possible. Because we have N-h1 > N-h2, there exists at least one paper not in the set of N-h2 but in the set of N-h1, this paper should have value <= h1 (according to 5) and have value >= h2 (according to 2), this contradicts to (1). \\n\\nThe uniqueness follows."
                    },
                    {
                        "username": "job_xu",
                        "content": "Have two questions about the example 1:why not 5? There are two papers be cited at least 5 times.  why not 1? There are four papers be cited at least 1 times.  "
                    },
                    {
                        "username": "shivam_sharma2004",
                        "content": "5 cant be the ans because there do not exist atleast 5 elements in the array which are greater than 5. Talking about 1 yes it is valid value of h but you need to return the max value of h possible which is 3 in this case ."
                    }
                ]
            },
            {
                "id": 1870167,
                "content": [
                    {
                        "username": "cartesPerforees",
                        "content": "Excuse me, what kind of madman has published 5000 highly-cited papers?\\nI swear that dude must know incredibly much about Riemannian geometry and incredibly little about women"
                    },
                    {
                        "username": "ignacioariasdev",
                        "content": "[@dungtuanuet](/dungtuanuet) what gives u money?"
                    },
                    {
                        "username": "dungtuanuet",
                        "content": "rolf\\n"
                    },
                    {
                        "username": "ourlord",
                        "content": "According to the hint, I tried my version with the build-in `sort()` and get a one time AC. But if in a real interview scenario, do we allow to use build-in sort to solve this problem?\\n\\nWhat would the actual point the interviewee might look for?"
                    },
                    {
                        "username": "isydor",
                        "content": "[@Tribhuwan-Joshi](/Tribhuwan-Joshi) it is literally mentioned on the wiki page..."
                    },
                    {
                        "username": "NareshSawlani",
                        "content": "interviewer would be looking for your approach like in this question it would be using count sort manually no API"
                    },
                    {
                        "username": "Tribhuwan-Joshi",
                        "content": "Please don\\'t share hints like using `sort()` in the discussion "
                    },
                    {
                        "username": "haucaucau",
                        "content": "What if the input is [4,4,4,4,4,4,5]?\\nWhen I run with my code the answer is 4 and it was accepted.\\nBut I don\\'t understand cause there are 7 papers that have at least 4 citations,\\nand 0 paper no more than 4, which contradicts the description."
                    },
                    {
                        "username": "DxRz729",
                        "content": "Yes your the input has 7 papers with 4 citations, but the h in h-index means that it should be the same for no of citations and no of papers, so we will only take 4 papers as it is min of (4,7)"
                    },
                    {
                        "username": "hemantsingh4774",
                        "content": "[@hemantsingh4774](/hemantsingh4774)  reference: https://en.wikipedia.org/wiki/H-index"
                    },
                    {
                        "username": "hemantsingh4774",
                        "content": " For example, if an author has five publications, with 9, 7, 6, 2, and 1 citations (ordered from greatest to least), then the author\\'s h-index is 3, because the author has three publications with 3 or more citations. However, the author does not have four publications with 4 or more citations."
                    },
                    {
                        "username": "han35",
                        "content": "[0] means there is 1 paper and the citation is 0.\\nAccording to the description\\n\\n> A scientist has index h if h of his/her N papers have at least h citations each, and the other N \\u2212 h papers have no more than h citations each\\n\\nA scientist has 1(h) of his/her 1 paper has at least 0(h) citation, and the other 0 paper has no more than 0 citation.\\n\\nIs this a contradiction?"
                    },
                    {
                        "username": "yellowstar1014",
                        "content": "is it possible to have two h in this problem? please give an example?"
                    },
                    {
                        "username": "Dzuchun",
                        "content": "it literaly says to be a maximum value. how in the world would something have two distinct maximum values?"
                    },
                    {
                        "username": "pieceofpie",
                        "content": "![hehe.png](https://assets.leetcode.com/users/images/f16e4f9d-434f-4e5c-bf36-3cc106ea074a_1677794934.0254838.png)"
                    },
                    {
                        "username": "shuyi@cvs",
                        "content": "Hi,\\n\\nI came across a situation:  given citations = [3, 1, 7, 8, 9]. What will be the answer be?\\n\\nAccording to the definition of h-index on Wikipedia: \"A scientist has index h if h of his/her N papers have at least h citations each, and the other N \\u2212 h papers have no more than h citations each.\"\\n\\nWhen h=3, the definition will be \"A scientist has index 3 if 3 of his/her 5 papers have at least 3 citations each, and the other 2 papers have no more than 3 citations each.\" Obviously wrong....\\n\\nWhen h=4, the definition will be \"A scientist has index 4 if 4 of his/her 5 papers have at least 4 citations each, and the other 1 papers have no more than 4 citations each.\" Obviously wrong....\\n\\nWhen h=2, the definition will be \"A scientist has index 2 if 2 of his/her 5 papers have at least 2 citations each, and the other 3 papers have no more than 3 citations each.\" Obviously wrong....\\n\\nSo anybody can give me an answer? Or this question is a wrong one?"
                    },
                    {
                        "username": "user2118U",
                        "content": "Definition of h is The h-index is defined as the maximum value of h such that the given researcher has published at least h papers that have each been cited at least h times. See it is written at least h papers not exact h papers"
                    },
                    {
                        "username": "user2118U",
                        "content": "Dude there  is nothing written like that other papers have no more h citations. your example answer is 3 because researcher has published at least 3 papers and each paper has atleast 3 citations"
                    },
                    {
                        "username": "saurabh8katyal",
                        "content": "Answer will be 3, as the other 2 papers have no more than 3 citations each(1, 3). Not more than 3. Can be equal to."
                    },
                    {
                        "username": "Tsien",
                        "content": "In the problem description, there is a line \"Note: If there are several possible values for h, the maximum one is taken as the h-index.\"\\nI cannot come up with an example that could have several possible values for h. \\nIMO, there is only one value for h for each example according to the definition of H-Index.\\nPlease correct me if i'm wrong.\\nThanks!"
                    },
                    {
                        "username": "Shubh2407",
                        "content": "Anyone thought of Binary search, no need of sorting technique required,\\nDon\\'t open solution if you have not gave it a try using binary search:\\nhttps://leetcode.com/problems/h-index/solutions/3741453/easy-binary-search-problem-no-sorting-technique-required-o-nlogn/ "
                    },
                    {
                        "username": "vishalshrm539",
                        "content": "[@RajputShivraj](/RajputShivraj) He probably meant to apply binary search on the answer and not on the given array."
                    },
                    {
                        "username": "CriticalCorduroy",
                        "content": "How would binary search be beneficial without a sort applied to the citations?"
                    },
                    {
                        "username": "RajputShivraj",
                        "content": "binary search can be applied on sorted arrays na and you are saying no need of sorting techniques\\n"
                    },
                    {
                        "username": "lowiq",
                        "content": "According to the definition of h, \"if h of his/her N papers have at least h citations each, and the other N \\u2212 h papers have no more than h citations each.\" Looks like the h value is unique. The \"Note\" part looks unnecessary. \\n\\nProof: say there exist two h-indices, h1 < h2 (1), which means that, there are h2 numbers have value at least h2 (2) and N-h2 values have value at most h2 (3); there are h1 numbers have value at least h1 (4) and N-h1 values have value at most h1(5).\\n\\nWe have (1)(2)(3), (1) and (2) implies (4), but we can see (5) is not possible. Because we have N-h1 > N-h2, there exists at least one paper not in the set of N-h2 but in the set of N-h1, this paper should have value <= h1 (according to 5) and have value >= h2 (according to 2), this contradicts to (1). \\n\\nThe uniqueness follows."
                    },
                    {
                        "username": "job_xu",
                        "content": "Have two questions about the example 1:why not 5? There are two papers be cited at least 5 times.  why not 1? There are four papers be cited at least 1 times.  "
                    },
                    {
                        "username": "shivam_sharma2004",
                        "content": "5 cant be the ans because there do not exist atleast 5 elements in the array which are greater than 5. Talking about 1 yes it is valid value of h but you need to return the max value of h possible which is 3 in this case ."
                    }
                ]
            },
            {
                "id": 1565530,
                "content": [
                    {
                        "username": "cartesPerforees",
                        "content": "Excuse me, what kind of madman has published 5000 highly-cited papers?\\nI swear that dude must know incredibly much about Riemannian geometry and incredibly little about women"
                    },
                    {
                        "username": "ignacioariasdev",
                        "content": "[@dungtuanuet](/dungtuanuet) what gives u money?"
                    },
                    {
                        "username": "dungtuanuet",
                        "content": "rolf\\n"
                    },
                    {
                        "username": "ourlord",
                        "content": "According to the hint, I tried my version with the build-in `sort()` and get a one time AC. But if in a real interview scenario, do we allow to use build-in sort to solve this problem?\\n\\nWhat would the actual point the interviewee might look for?"
                    },
                    {
                        "username": "isydor",
                        "content": "[@Tribhuwan-Joshi](/Tribhuwan-Joshi) it is literally mentioned on the wiki page..."
                    },
                    {
                        "username": "NareshSawlani",
                        "content": "interviewer would be looking for your approach like in this question it would be using count sort manually no API"
                    },
                    {
                        "username": "Tribhuwan-Joshi",
                        "content": "Please don\\'t share hints like using `sort()` in the discussion "
                    },
                    {
                        "username": "haucaucau",
                        "content": "What if the input is [4,4,4,4,4,4,5]?\\nWhen I run with my code the answer is 4 and it was accepted.\\nBut I don\\'t understand cause there are 7 papers that have at least 4 citations,\\nand 0 paper no more than 4, which contradicts the description."
                    },
                    {
                        "username": "DxRz729",
                        "content": "Yes your the input has 7 papers with 4 citations, but the h in h-index means that it should be the same for no of citations and no of papers, so we will only take 4 papers as it is min of (4,7)"
                    },
                    {
                        "username": "hemantsingh4774",
                        "content": "[@hemantsingh4774](/hemantsingh4774)  reference: https://en.wikipedia.org/wiki/H-index"
                    },
                    {
                        "username": "hemantsingh4774",
                        "content": " For example, if an author has five publications, with 9, 7, 6, 2, and 1 citations (ordered from greatest to least), then the author\\'s h-index is 3, because the author has three publications with 3 or more citations. However, the author does not have four publications with 4 or more citations."
                    },
                    {
                        "username": "han35",
                        "content": "[0] means there is 1 paper and the citation is 0.\\nAccording to the description\\n\\n> A scientist has index h if h of his/her N papers have at least h citations each, and the other N \\u2212 h papers have no more than h citations each\\n\\nA scientist has 1(h) of his/her 1 paper has at least 0(h) citation, and the other 0 paper has no more than 0 citation.\\n\\nIs this a contradiction?"
                    },
                    {
                        "username": "yellowstar1014",
                        "content": "is it possible to have two h in this problem? please give an example?"
                    },
                    {
                        "username": "Dzuchun",
                        "content": "it literaly says to be a maximum value. how in the world would something have two distinct maximum values?"
                    },
                    {
                        "username": "pieceofpie",
                        "content": "![hehe.png](https://assets.leetcode.com/users/images/f16e4f9d-434f-4e5c-bf36-3cc106ea074a_1677794934.0254838.png)"
                    },
                    {
                        "username": "shuyi@cvs",
                        "content": "Hi,\\n\\nI came across a situation:  given citations = [3, 1, 7, 8, 9]. What will be the answer be?\\n\\nAccording to the definition of h-index on Wikipedia: \"A scientist has index h if h of his/her N papers have at least h citations each, and the other N \\u2212 h papers have no more than h citations each.\"\\n\\nWhen h=3, the definition will be \"A scientist has index 3 if 3 of his/her 5 papers have at least 3 citations each, and the other 2 papers have no more than 3 citations each.\" Obviously wrong....\\n\\nWhen h=4, the definition will be \"A scientist has index 4 if 4 of his/her 5 papers have at least 4 citations each, and the other 1 papers have no more than 4 citations each.\" Obviously wrong....\\n\\nWhen h=2, the definition will be \"A scientist has index 2 if 2 of his/her 5 papers have at least 2 citations each, and the other 3 papers have no more than 3 citations each.\" Obviously wrong....\\n\\nSo anybody can give me an answer? Or this question is a wrong one?"
                    },
                    {
                        "username": "user2118U",
                        "content": "Definition of h is The h-index is defined as the maximum value of h such that the given researcher has published at least h papers that have each been cited at least h times. See it is written at least h papers not exact h papers"
                    },
                    {
                        "username": "user2118U",
                        "content": "Dude there  is nothing written like that other papers have no more h citations. your example answer is 3 because researcher has published at least 3 papers and each paper has atleast 3 citations"
                    },
                    {
                        "username": "saurabh8katyal",
                        "content": "Answer will be 3, as the other 2 papers have no more than 3 citations each(1, 3). Not more than 3. Can be equal to."
                    },
                    {
                        "username": "Tsien",
                        "content": "In the problem description, there is a line \"Note: If there are several possible values for h, the maximum one is taken as the h-index.\"\\nI cannot come up with an example that could have several possible values for h. \\nIMO, there is only one value for h for each example according to the definition of H-Index.\\nPlease correct me if i'm wrong.\\nThanks!"
                    },
                    {
                        "username": "Shubh2407",
                        "content": "Anyone thought of Binary search, no need of sorting technique required,\\nDon\\'t open solution if you have not gave it a try using binary search:\\nhttps://leetcode.com/problems/h-index/solutions/3741453/easy-binary-search-problem-no-sorting-technique-required-o-nlogn/ "
                    },
                    {
                        "username": "vishalshrm539",
                        "content": "[@RajputShivraj](/RajputShivraj) He probably meant to apply binary search on the answer and not on the given array."
                    },
                    {
                        "username": "CriticalCorduroy",
                        "content": "How would binary search be beneficial without a sort applied to the citations?"
                    },
                    {
                        "username": "RajputShivraj",
                        "content": "binary search can be applied on sorted arrays na and you are saying no need of sorting techniques\\n"
                    },
                    {
                        "username": "lowiq",
                        "content": "According to the definition of h, \"if h of his/her N papers have at least h citations each, and the other N \\u2212 h papers have no more than h citations each.\" Looks like the h value is unique. The \"Note\" part looks unnecessary. \\n\\nProof: say there exist two h-indices, h1 < h2 (1), which means that, there are h2 numbers have value at least h2 (2) and N-h2 values have value at most h2 (3); there are h1 numbers have value at least h1 (4) and N-h1 values have value at most h1(5).\\n\\nWe have (1)(2)(3), (1) and (2) implies (4), but we can see (5) is not possible. Because we have N-h1 > N-h2, there exists at least one paper not in the set of N-h2 but in the set of N-h1, this paper should have value <= h1 (according to 5) and have value >= h2 (according to 2), this contradicts to (1). \\n\\nThe uniqueness follows."
                    },
                    {
                        "username": "job_xu",
                        "content": "Have two questions about the example 1:why not 5? There are two papers be cited at least 5 times.  why not 1? There are four papers be cited at least 1 times.  "
                    },
                    {
                        "username": "shivam_sharma2004",
                        "content": "5 cant be the ans because there do not exist atleast 5 elements in the array which are greater than 5. Talking about 1 yes it is valid value of h but you need to return the max value of h possible which is 3 in this case ."
                    }
                ]
            },
            {
                "id": 1573901,
                "content": [
                    {
                        "username": "cartesPerforees",
                        "content": "Excuse me, what kind of madman has published 5000 highly-cited papers?\\nI swear that dude must know incredibly much about Riemannian geometry and incredibly little about women"
                    },
                    {
                        "username": "ignacioariasdev",
                        "content": "[@dungtuanuet](/dungtuanuet) what gives u money?"
                    },
                    {
                        "username": "dungtuanuet",
                        "content": "rolf\\n"
                    },
                    {
                        "username": "ourlord",
                        "content": "According to the hint, I tried my version with the build-in `sort()` and get a one time AC. But if in a real interview scenario, do we allow to use build-in sort to solve this problem?\\n\\nWhat would the actual point the interviewee might look for?"
                    },
                    {
                        "username": "isydor",
                        "content": "[@Tribhuwan-Joshi](/Tribhuwan-Joshi) it is literally mentioned on the wiki page..."
                    },
                    {
                        "username": "NareshSawlani",
                        "content": "interviewer would be looking for your approach like in this question it would be using count sort manually no API"
                    },
                    {
                        "username": "Tribhuwan-Joshi",
                        "content": "Please don\\'t share hints like using `sort()` in the discussion "
                    },
                    {
                        "username": "haucaucau",
                        "content": "What if the input is [4,4,4,4,4,4,5]?\\nWhen I run with my code the answer is 4 and it was accepted.\\nBut I don\\'t understand cause there are 7 papers that have at least 4 citations,\\nand 0 paper no more than 4, which contradicts the description."
                    },
                    {
                        "username": "DxRz729",
                        "content": "Yes your the input has 7 papers with 4 citations, but the h in h-index means that it should be the same for no of citations and no of papers, so we will only take 4 papers as it is min of (4,7)"
                    },
                    {
                        "username": "hemantsingh4774",
                        "content": "[@hemantsingh4774](/hemantsingh4774)  reference: https://en.wikipedia.org/wiki/H-index"
                    },
                    {
                        "username": "hemantsingh4774",
                        "content": " For example, if an author has five publications, with 9, 7, 6, 2, and 1 citations (ordered from greatest to least), then the author\\'s h-index is 3, because the author has three publications with 3 or more citations. However, the author does not have four publications with 4 or more citations."
                    },
                    {
                        "username": "han35",
                        "content": "[0] means there is 1 paper and the citation is 0.\\nAccording to the description\\n\\n> A scientist has index h if h of his/her N papers have at least h citations each, and the other N \\u2212 h papers have no more than h citations each\\n\\nA scientist has 1(h) of his/her 1 paper has at least 0(h) citation, and the other 0 paper has no more than 0 citation.\\n\\nIs this a contradiction?"
                    },
                    {
                        "username": "yellowstar1014",
                        "content": "is it possible to have two h in this problem? please give an example?"
                    },
                    {
                        "username": "Dzuchun",
                        "content": "it literaly says to be a maximum value. how in the world would something have two distinct maximum values?"
                    },
                    {
                        "username": "pieceofpie",
                        "content": "![hehe.png](https://assets.leetcode.com/users/images/f16e4f9d-434f-4e5c-bf36-3cc106ea074a_1677794934.0254838.png)"
                    },
                    {
                        "username": "shuyi@cvs",
                        "content": "Hi,\\n\\nI came across a situation:  given citations = [3, 1, 7, 8, 9]. What will be the answer be?\\n\\nAccording to the definition of h-index on Wikipedia: \"A scientist has index h if h of his/her N papers have at least h citations each, and the other N \\u2212 h papers have no more than h citations each.\"\\n\\nWhen h=3, the definition will be \"A scientist has index 3 if 3 of his/her 5 papers have at least 3 citations each, and the other 2 papers have no more than 3 citations each.\" Obviously wrong....\\n\\nWhen h=4, the definition will be \"A scientist has index 4 if 4 of his/her 5 papers have at least 4 citations each, and the other 1 papers have no more than 4 citations each.\" Obviously wrong....\\n\\nWhen h=2, the definition will be \"A scientist has index 2 if 2 of his/her 5 papers have at least 2 citations each, and the other 3 papers have no more than 3 citations each.\" Obviously wrong....\\n\\nSo anybody can give me an answer? Or this question is a wrong one?"
                    },
                    {
                        "username": "user2118U",
                        "content": "Definition of h is The h-index is defined as the maximum value of h such that the given researcher has published at least h papers that have each been cited at least h times. See it is written at least h papers not exact h papers"
                    },
                    {
                        "username": "user2118U",
                        "content": "Dude there  is nothing written like that other papers have no more h citations. your example answer is 3 because researcher has published at least 3 papers and each paper has atleast 3 citations"
                    },
                    {
                        "username": "saurabh8katyal",
                        "content": "Answer will be 3, as the other 2 papers have no more than 3 citations each(1, 3). Not more than 3. Can be equal to."
                    },
                    {
                        "username": "Tsien",
                        "content": "In the problem description, there is a line \"Note: If there are several possible values for h, the maximum one is taken as the h-index.\"\\nI cannot come up with an example that could have several possible values for h. \\nIMO, there is only one value for h for each example according to the definition of H-Index.\\nPlease correct me if i'm wrong.\\nThanks!"
                    },
                    {
                        "username": "Shubh2407",
                        "content": "Anyone thought of Binary search, no need of sorting technique required,\\nDon\\'t open solution if you have not gave it a try using binary search:\\nhttps://leetcode.com/problems/h-index/solutions/3741453/easy-binary-search-problem-no-sorting-technique-required-o-nlogn/ "
                    },
                    {
                        "username": "vishalshrm539",
                        "content": "[@RajputShivraj](/RajputShivraj) He probably meant to apply binary search on the answer and not on the given array."
                    },
                    {
                        "username": "CriticalCorduroy",
                        "content": "How would binary search be beneficial without a sort applied to the citations?"
                    },
                    {
                        "username": "RajputShivraj",
                        "content": "binary search can be applied on sorted arrays na and you are saying no need of sorting techniques\\n"
                    },
                    {
                        "username": "lowiq",
                        "content": "According to the definition of h, \"if h of his/her N papers have at least h citations each, and the other N \\u2212 h papers have no more than h citations each.\" Looks like the h value is unique. The \"Note\" part looks unnecessary. \\n\\nProof: say there exist two h-indices, h1 < h2 (1), which means that, there are h2 numbers have value at least h2 (2) and N-h2 values have value at most h2 (3); there are h1 numbers have value at least h1 (4) and N-h1 values have value at most h1(5).\\n\\nWe have (1)(2)(3), (1) and (2) implies (4), but we can see (5) is not possible. Because we have N-h1 > N-h2, there exists at least one paper not in the set of N-h2 but in the set of N-h1, this paper should have value <= h1 (according to 5) and have value >= h2 (according to 2), this contradicts to (1). \\n\\nThe uniqueness follows."
                    },
                    {
                        "username": "job_xu",
                        "content": "Have two questions about the example 1:why not 5? There are two papers be cited at least 5 times.  why not 1? There are four papers be cited at least 1 times.  "
                    },
                    {
                        "username": "shivam_sharma2004",
                        "content": "5 cant be the ans because there do not exist atleast 5 elements in the array which are greater than 5. Talking about 1 yes it is valid value of h but you need to return the max value of h possible which is 3 in this case ."
                    }
                ]
            },
            {
                "id": 1567937,
                "content": [
                    {
                        "username": "cartesPerforees",
                        "content": "Excuse me, what kind of madman has published 5000 highly-cited papers?\\nI swear that dude must know incredibly much about Riemannian geometry and incredibly little about women"
                    },
                    {
                        "username": "ignacioariasdev",
                        "content": "[@dungtuanuet](/dungtuanuet) what gives u money?"
                    },
                    {
                        "username": "dungtuanuet",
                        "content": "rolf\\n"
                    },
                    {
                        "username": "ourlord",
                        "content": "According to the hint, I tried my version with the build-in `sort()` and get a one time AC. But if in a real interview scenario, do we allow to use build-in sort to solve this problem?\\n\\nWhat would the actual point the interviewee might look for?"
                    },
                    {
                        "username": "isydor",
                        "content": "[@Tribhuwan-Joshi](/Tribhuwan-Joshi) it is literally mentioned on the wiki page..."
                    },
                    {
                        "username": "NareshSawlani",
                        "content": "interviewer would be looking for your approach like in this question it would be using count sort manually no API"
                    },
                    {
                        "username": "Tribhuwan-Joshi",
                        "content": "Please don\\'t share hints like using `sort()` in the discussion "
                    },
                    {
                        "username": "haucaucau",
                        "content": "What if the input is [4,4,4,4,4,4,5]?\\nWhen I run with my code the answer is 4 and it was accepted.\\nBut I don\\'t understand cause there are 7 papers that have at least 4 citations,\\nand 0 paper no more than 4, which contradicts the description."
                    },
                    {
                        "username": "DxRz729",
                        "content": "Yes your the input has 7 papers with 4 citations, but the h in h-index means that it should be the same for no of citations and no of papers, so we will only take 4 papers as it is min of (4,7)"
                    },
                    {
                        "username": "hemantsingh4774",
                        "content": "[@hemantsingh4774](/hemantsingh4774)  reference: https://en.wikipedia.org/wiki/H-index"
                    },
                    {
                        "username": "hemantsingh4774",
                        "content": " For example, if an author has five publications, with 9, 7, 6, 2, and 1 citations (ordered from greatest to least), then the author\\'s h-index is 3, because the author has three publications with 3 or more citations. However, the author does not have four publications with 4 or more citations."
                    },
                    {
                        "username": "han35",
                        "content": "[0] means there is 1 paper and the citation is 0.\\nAccording to the description\\n\\n> A scientist has index h if h of his/her N papers have at least h citations each, and the other N \\u2212 h papers have no more than h citations each\\n\\nA scientist has 1(h) of his/her 1 paper has at least 0(h) citation, and the other 0 paper has no more than 0 citation.\\n\\nIs this a contradiction?"
                    },
                    {
                        "username": "yellowstar1014",
                        "content": "is it possible to have two h in this problem? please give an example?"
                    },
                    {
                        "username": "Dzuchun",
                        "content": "it literaly says to be a maximum value. how in the world would something have two distinct maximum values?"
                    },
                    {
                        "username": "pieceofpie",
                        "content": "![hehe.png](https://assets.leetcode.com/users/images/f16e4f9d-434f-4e5c-bf36-3cc106ea074a_1677794934.0254838.png)"
                    },
                    {
                        "username": "shuyi@cvs",
                        "content": "Hi,\\n\\nI came across a situation:  given citations = [3, 1, 7, 8, 9]. What will be the answer be?\\n\\nAccording to the definition of h-index on Wikipedia: \"A scientist has index h if h of his/her N papers have at least h citations each, and the other N \\u2212 h papers have no more than h citations each.\"\\n\\nWhen h=3, the definition will be \"A scientist has index 3 if 3 of his/her 5 papers have at least 3 citations each, and the other 2 papers have no more than 3 citations each.\" Obviously wrong....\\n\\nWhen h=4, the definition will be \"A scientist has index 4 if 4 of his/her 5 papers have at least 4 citations each, and the other 1 papers have no more than 4 citations each.\" Obviously wrong....\\n\\nWhen h=2, the definition will be \"A scientist has index 2 if 2 of his/her 5 papers have at least 2 citations each, and the other 3 papers have no more than 3 citations each.\" Obviously wrong....\\n\\nSo anybody can give me an answer? Or this question is a wrong one?"
                    },
                    {
                        "username": "user2118U",
                        "content": "Definition of h is The h-index is defined as the maximum value of h such that the given researcher has published at least h papers that have each been cited at least h times. See it is written at least h papers not exact h papers"
                    },
                    {
                        "username": "user2118U",
                        "content": "Dude there  is nothing written like that other papers have no more h citations. your example answer is 3 because researcher has published at least 3 papers and each paper has atleast 3 citations"
                    },
                    {
                        "username": "saurabh8katyal",
                        "content": "Answer will be 3, as the other 2 papers have no more than 3 citations each(1, 3). Not more than 3. Can be equal to."
                    },
                    {
                        "username": "Tsien",
                        "content": "In the problem description, there is a line \"Note: If there are several possible values for h, the maximum one is taken as the h-index.\"\\nI cannot come up with an example that could have several possible values for h. \\nIMO, there is only one value for h for each example according to the definition of H-Index.\\nPlease correct me if i'm wrong.\\nThanks!"
                    },
                    {
                        "username": "Shubh2407",
                        "content": "Anyone thought of Binary search, no need of sorting technique required,\\nDon\\'t open solution if you have not gave it a try using binary search:\\nhttps://leetcode.com/problems/h-index/solutions/3741453/easy-binary-search-problem-no-sorting-technique-required-o-nlogn/ "
                    },
                    {
                        "username": "vishalshrm539",
                        "content": "[@RajputShivraj](/RajputShivraj) He probably meant to apply binary search on the answer and not on the given array."
                    },
                    {
                        "username": "CriticalCorduroy",
                        "content": "How would binary search be beneficial without a sort applied to the citations?"
                    },
                    {
                        "username": "RajputShivraj",
                        "content": "binary search can be applied on sorted arrays na and you are saying no need of sorting techniques\\n"
                    },
                    {
                        "username": "lowiq",
                        "content": "According to the definition of h, \"if h of his/her N papers have at least h citations each, and the other N \\u2212 h papers have no more than h citations each.\" Looks like the h value is unique. The \"Note\" part looks unnecessary. \\n\\nProof: say there exist two h-indices, h1 < h2 (1), which means that, there are h2 numbers have value at least h2 (2) and N-h2 values have value at most h2 (3); there are h1 numbers have value at least h1 (4) and N-h1 values have value at most h1(5).\\n\\nWe have (1)(2)(3), (1) and (2) implies (4), but we can see (5) is not possible. Because we have N-h1 > N-h2, there exists at least one paper not in the set of N-h2 but in the set of N-h1, this paper should have value <= h1 (according to 5) and have value >= h2 (according to 2), this contradicts to (1). \\n\\nThe uniqueness follows."
                    },
                    {
                        "username": "job_xu",
                        "content": "Have two questions about the example 1:why not 5? There are two papers be cited at least 5 times.  why not 1? There are four papers be cited at least 1 times.  "
                    },
                    {
                        "username": "shivam_sharma2004",
                        "content": "5 cant be the ans because there do not exist atleast 5 elements in the array which are greater than 5. Talking about 1 yes it is valid value of h but you need to return the max value of h possible which is 3 in this case ."
                    }
                ]
            },
            {
                "id": 1566081,
                "content": [
                    {
                        "username": "cartesPerforees",
                        "content": "Excuse me, what kind of madman has published 5000 highly-cited papers?\\nI swear that dude must know incredibly much about Riemannian geometry and incredibly little about women"
                    },
                    {
                        "username": "ignacioariasdev",
                        "content": "[@dungtuanuet](/dungtuanuet) what gives u money?"
                    },
                    {
                        "username": "dungtuanuet",
                        "content": "rolf\\n"
                    },
                    {
                        "username": "ourlord",
                        "content": "According to the hint, I tried my version with the build-in `sort()` and get a one time AC. But if in a real interview scenario, do we allow to use build-in sort to solve this problem?\\n\\nWhat would the actual point the interviewee might look for?"
                    },
                    {
                        "username": "isydor",
                        "content": "[@Tribhuwan-Joshi](/Tribhuwan-Joshi) it is literally mentioned on the wiki page..."
                    },
                    {
                        "username": "NareshSawlani",
                        "content": "interviewer would be looking for your approach like in this question it would be using count sort manually no API"
                    },
                    {
                        "username": "Tribhuwan-Joshi",
                        "content": "Please don\\'t share hints like using `sort()` in the discussion "
                    },
                    {
                        "username": "haucaucau",
                        "content": "What if the input is [4,4,4,4,4,4,5]?\\nWhen I run with my code the answer is 4 and it was accepted.\\nBut I don\\'t understand cause there are 7 papers that have at least 4 citations,\\nand 0 paper no more than 4, which contradicts the description."
                    },
                    {
                        "username": "DxRz729",
                        "content": "Yes your the input has 7 papers with 4 citations, but the h in h-index means that it should be the same for no of citations and no of papers, so we will only take 4 papers as it is min of (4,7)"
                    },
                    {
                        "username": "hemantsingh4774",
                        "content": "[@hemantsingh4774](/hemantsingh4774)  reference: https://en.wikipedia.org/wiki/H-index"
                    },
                    {
                        "username": "hemantsingh4774",
                        "content": " For example, if an author has five publications, with 9, 7, 6, 2, and 1 citations (ordered from greatest to least), then the author\\'s h-index is 3, because the author has three publications with 3 or more citations. However, the author does not have four publications with 4 or more citations."
                    },
                    {
                        "username": "han35",
                        "content": "[0] means there is 1 paper and the citation is 0.\\nAccording to the description\\n\\n> A scientist has index h if h of his/her N papers have at least h citations each, and the other N \\u2212 h papers have no more than h citations each\\n\\nA scientist has 1(h) of his/her 1 paper has at least 0(h) citation, and the other 0 paper has no more than 0 citation.\\n\\nIs this a contradiction?"
                    },
                    {
                        "username": "yellowstar1014",
                        "content": "is it possible to have two h in this problem? please give an example?"
                    },
                    {
                        "username": "Dzuchun",
                        "content": "it literaly says to be a maximum value. how in the world would something have two distinct maximum values?"
                    },
                    {
                        "username": "pieceofpie",
                        "content": "![hehe.png](https://assets.leetcode.com/users/images/f16e4f9d-434f-4e5c-bf36-3cc106ea074a_1677794934.0254838.png)"
                    },
                    {
                        "username": "shuyi@cvs",
                        "content": "Hi,\\n\\nI came across a situation:  given citations = [3, 1, 7, 8, 9]. What will be the answer be?\\n\\nAccording to the definition of h-index on Wikipedia: \"A scientist has index h if h of his/her N papers have at least h citations each, and the other N \\u2212 h papers have no more than h citations each.\"\\n\\nWhen h=3, the definition will be \"A scientist has index 3 if 3 of his/her 5 papers have at least 3 citations each, and the other 2 papers have no more than 3 citations each.\" Obviously wrong....\\n\\nWhen h=4, the definition will be \"A scientist has index 4 if 4 of his/her 5 papers have at least 4 citations each, and the other 1 papers have no more than 4 citations each.\" Obviously wrong....\\n\\nWhen h=2, the definition will be \"A scientist has index 2 if 2 of his/her 5 papers have at least 2 citations each, and the other 3 papers have no more than 3 citations each.\" Obviously wrong....\\n\\nSo anybody can give me an answer? Or this question is a wrong one?"
                    },
                    {
                        "username": "user2118U",
                        "content": "Definition of h is The h-index is defined as the maximum value of h such that the given researcher has published at least h papers that have each been cited at least h times. See it is written at least h papers not exact h papers"
                    },
                    {
                        "username": "user2118U",
                        "content": "Dude there  is nothing written like that other papers have no more h citations. your example answer is 3 because researcher has published at least 3 papers and each paper has atleast 3 citations"
                    },
                    {
                        "username": "saurabh8katyal",
                        "content": "Answer will be 3, as the other 2 papers have no more than 3 citations each(1, 3). Not more than 3. Can be equal to."
                    },
                    {
                        "username": "Tsien",
                        "content": "In the problem description, there is a line \"Note: If there are several possible values for h, the maximum one is taken as the h-index.\"\\nI cannot come up with an example that could have several possible values for h. \\nIMO, there is only one value for h for each example according to the definition of H-Index.\\nPlease correct me if i'm wrong.\\nThanks!"
                    },
                    {
                        "username": "Shubh2407",
                        "content": "Anyone thought of Binary search, no need of sorting technique required,\\nDon\\'t open solution if you have not gave it a try using binary search:\\nhttps://leetcode.com/problems/h-index/solutions/3741453/easy-binary-search-problem-no-sorting-technique-required-o-nlogn/ "
                    },
                    {
                        "username": "vishalshrm539",
                        "content": "[@RajputShivraj](/RajputShivraj) He probably meant to apply binary search on the answer and not on the given array."
                    },
                    {
                        "username": "CriticalCorduroy",
                        "content": "How would binary search be beneficial without a sort applied to the citations?"
                    },
                    {
                        "username": "RajputShivraj",
                        "content": "binary search can be applied on sorted arrays na and you are saying no need of sorting techniques\\n"
                    },
                    {
                        "username": "lowiq",
                        "content": "According to the definition of h, \"if h of his/her N papers have at least h citations each, and the other N \\u2212 h papers have no more than h citations each.\" Looks like the h value is unique. The \"Note\" part looks unnecessary. \\n\\nProof: say there exist two h-indices, h1 < h2 (1), which means that, there are h2 numbers have value at least h2 (2) and N-h2 values have value at most h2 (3); there are h1 numbers have value at least h1 (4) and N-h1 values have value at most h1(5).\\n\\nWe have (1)(2)(3), (1) and (2) implies (4), but we can see (5) is not possible. Because we have N-h1 > N-h2, there exists at least one paper not in the set of N-h2 but in the set of N-h1, this paper should have value <= h1 (according to 5) and have value >= h2 (according to 2), this contradicts to (1). \\n\\nThe uniqueness follows."
                    },
                    {
                        "username": "job_xu",
                        "content": "Have two questions about the example 1:why not 5? There are two papers be cited at least 5 times.  why not 1? There are four papers be cited at least 1 times.  "
                    },
                    {
                        "username": "shivam_sharma2004",
                        "content": "5 cant be the ans because there do not exist atleast 5 elements in the array which are greater than 5. Talking about 1 yes it is valid value of h but you need to return the max value of h possible which is 3 in this case ."
                    }
                ]
            },
            {
                "id": 1569052,
                "content": [
                    {
                        "username": "cartesPerforees",
                        "content": "Excuse me, what kind of madman has published 5000 highly-cited papers?\\nI swear that dude must know incredibly much about Riemannian geometry and incredibly little about women"
                    },
                    {
                        "username": "ignacioariasdev",
                        "content": "[@dungtuanuet](/dungtuanuet) what gives u money?"
                    },
                    {
                        "username": "dungtuanuet",
                        "content": "rolf\\n"
                    },
                    {
                        "username": "ourlord",
                        "content": "According to the hint, I tried my version with the build-in `sort()` and get a one time AC. But if in a real interview scenario, do we allow to use build-in sort to solve this problem?\\n\\nWhat would the actual point the interviewee might look for?"
                    },
                    {
                        "username": "isydor",
                        "content": "[@Tribhuwan-Joshi](/Tribhuwan-Joshi) it is literally mentioned on the wiki page..."
                    },
                    {
                        "username": "NareshSawlani",
                        "content": "interviewer would be looking for your approach like in this question it would be using count sort manually no API"
                    },
                    {
                        "username": "Tribhuwan-Joshi",
                        "content": "Please don\\'t share hints like using `sort()` in the discussion "
                    },
                    {
                        "username": "haucaucau",
                        "content": "What if the input is [4,4,4,4,4,4,5]?\\nWhen I run with my code the answer is 4 and it was accepted.\\nBut I don\\'t understand cause there are 7 papers that have at least 4 citations,\\nand 0 paper no more than 4, which contradicts the description."
                    },
                    {
                        "username": "DxRz729",
                        "content": "Yes your the input has 7 papers with 4 citations, but the h in h-index means that it should be the same for no of citations and no of papers, so we will only take 4 papers as it is min of (4,7)"
                    },
                    {
                        "username": "hemantsingh4774",
                        "content": "[@hemantsingh4774](/hemantsingh4774)  reference: https://en.wikipedia.org/wiki/H-index"
                    },
                    {
                        "username": "hemantsingh4774",
                        "content": " For example, if an author has five publications, with 9, 7, 6, 2, and 1 citations (ordered from greatest to least), then the author\\'s h-index is 3, because the author has three publications with 3 or more citations. However, the author does not have four publications with 4 or more citations."
                    },
                    {
                        "username": "han35",
                        "content": "[0] means there is 1 paper and the citation is 0.\\nAccording to the description\\n\\n> A scientist has index h if h of his/her N papers have at least h citations each, and the other N \\u2212 h papers have no more than h citations each\\n\\nA scientist has 1(h) of his/her 1 paper has at least 0(h) citation, and the other 0 paper has no more than 0 citation.\\n\\nIs this a contradiction?"
                    },
                    {
                        "username": "yellowstar1014",
                        "content": "is it possible to have two h in this problem? please give an example?"
                    },
                    {
                        "username": "Dzuchun",
                        "content": "it literaly says to be a maximum value. how in the world would something have two distinct maximum values?"
                    },
                    {
                        "username": "pieceofpie",
                        "content": "![hehe.png](https://assets.leetcode.com/users/images/f16e4f9d-434f-4e5c-bf36-3cc106ea074a_1677794934.0254838.png)"
                    },
                    {
                        "username": "shuyi@cvs",
                        "content": "Hi,\\n\\nI came across a situation:  given citations = [3, 1, 7, 8, 9]. What will be the answer be?\\n\\nAccording to the definition of h-index on Wikipedia: \"A scientist has index h if h of his/her N papers have at least h citations each, and the other N \\u2212 h papers have no more than h citations each.\"\\n\\nWhen h=3, the definition will be \"A scientist has index 3 if 3 of his/her 5 papers have at least 3 citations each, and the other 2 papers have no more than 3 citations each.\" Obviously wrong....\\n\\nWhen h=4, the definition will be \"A scientist has index 4 if 4 of his/her 5 papers have at least 4 citations each, and the other 1 papers have no more than 4 citations each.\" Obviously wrong....\\n\\nWhen h=2, the definition will be \"A scientist has index 2 if 2 of his/her 5 papers have at least 2 citations each, and the other 3 papers have no more than 3 citations each.\" Obviously wrong....\\n\\nSo anybody can give me an answer? Or this question is a wrong one?"
                    },
                    {
                        "username": "user2118U",
                        "content": "Definition of h is The h-index is defined as the maximum value of h such that the given researcher has published at least h papers that have each been cited at least h times. See it is written at least h papers not exact h papers"
                    },
                    {
                        "username": "user2118U",
                        "content": "Dude there  is nothing written like that other papers have no more h citations. your example answer is 3 because researcher has published at least 3 papers and each paper has atleast 3 citations"
                    },
                    {
                        "username": "saurabh8katyal",
                        "content": "Answer will be 3, as the other 2 papers have no more than 3 citations each(1, 3). Not more than 3. Can be equal to."
                    },
                    {
                        "username": "Tsien",
                        "content": "In the problem description, there is a line \"Note: If there are several possible values for h, the maximum one is taken as the h-index.\"\\nI cannot come up with an example that could have several possible values for h. \\nIMO, there is only one value for h for each example according to the definition of H-Index.\\nPlease correct me if i'm wrong.\\nThanks!"
                    },
                    {
                        "username": "Shubh2407",
                        "content": "Anyone thought of Binary search, no need of sorting technique required,\\nDon\\'t open solution if you have not gave it a try using binary search:\\nhttps://leetcode.com/problems/h-index/solutions/3741453/easy-binary-search-problem-no-sorting-technique-required-o-nlogn/ "
                    },
                    {
                        "username": "vishalshrm539",
                        "content": "[@RajputShivraj](/RajputShivraj) He probably meant to apply binary search on the answer and not on the given array."
                    },
                    {
                        "username": "CriticalCorduroy",
                        "content": "How would binary search be beneficial without a sort applied to the citations?"
                    },
                    {
                        "username": "RajputShivraj",
                        "content": "binary search can be applied on sorted arrays na and you are saying no need of sorting techniques\\n"
                    },
                    {
                        "username": "lowiq",
                        "content": "According to the definition of h, \"if h of his/her N papers have at least h citations each, and the other N \\u2212 h papers have no more than h citations each.\" Looks like the h value is unique. The \"Note\" part looks unnecessary. \\n\\nProof: say there exist two h-indices, h1 < h2 (1), which means that, there are h2 numbers have value at least h2 (2) and N-h2 values have value at most h2 (3); there are h1 numbers have value at least h1 (4) and N-h1 values have value at most h1(5).\\n\\nWe have (1)(2)(3), (1) and (2) implies (4), but we can see (5) is not possible. Because we have N-h1 > N-h2, there exists at least one paper not in the set of N-h2 but in the set of N-h1, this paper should have value <= h1 (according to 5) and have value >= h2 (according to 2), this contradicts to (1). \\n\\nThe uniqueness follows."
                    },
                    {
                        "username": "job_xu",
                        "content": "Have two questions about the example 1:why not 5? There are two papers be cited at least 5 times.  why not 1? There are four papers be cited at least 1 times.  "
                    },
                    {
                        "username": "shivam_sharma2004",
                        "content": "5 cant be the ans because there do not exist atleast 5 elements in the array which are greater than 5. Talking about 1 yes it is valid value of h but you need to return the max value of h possible which is 3 in this case ."
                    }
                ]
            },
            {
                "id": 1569050,
                "content": [
                    {
                        "username": "cartesPerforees",
                        "content": "Excuse me, what kind of madman has published 5000 highly-cited papers?\\nI swear that dude must know incredibly much about Riemannian geometry and incredibly little about women"
                    },
                    {
                        "username": "ignacioariasdev",
                        "content": "[@dungtuanuet](/dungtuanuet) what gives u money?"
                    },
                    {
                        "username": "dungtuanuet",
                        "content": "rolf\\n"
                    },
                    {
                        "username": "ourlord",
                        "content": "According to the hint, I tried my version with the build-in `sort()` and get a one time AC. But if in a real interview scenario, do we allow to use build-in sort to solve this problem?\\n\\nWhat would the actual point the interviewee might look for?"
                    },
                    {
                        "username": "isydor",
                        "content": "[@Tribhuwan-Joshi](/Tribhuwan-Joshi) it is literally mentioned on the wiki page..."
                    },
                    {
                        "username": "NareshSawlani",
                        "content": "interviewer would be looking for your approach like in this question it would be using count sort manually no API"
                    },
                    {
                        "username": "Tribhuwan-Joshi",
                        "content": "Please don\\'t share hints like using `sort()` in the discussion "
                    },
                    {
                        "username": "haucaucau",
                        "content": "What if the input is [4,4,4,4,4,4,5]?\\nWhen I run with my code the answer is 4 and it was accepted.\\nBut I don\\'t understand cause there are 7 papers that have at least 4 citations,\\nand 0 paper no more than 4, which contradicts the description."
                    },
                    {
                        "username": "DxRz729",
                        "content": "Yes your the input has 7 papers with 4 citations, but the h in h-index means that it should be the same for no of citations and no of papers, so we will only take 4 papers as it is min of (4,7)"
                    },
                    {
                        "username": "hemantsingh4774",
                        "content": "[@hemantsingh4774](/hemantsingh4774)  reference: https://en.wikipedia.org/wiki/H-index"
                    },
                    {
                        "username": "hemantsingh4774",
                        "content": " For example, if an author has five publications, with 9, 7, 6, 2, and 1 citations (ordered from greatest to least), then the author\\'s h-index is 3, because the author has three publications with 3 or more citations. However, the author does not have four publications with 4 or more citations."
                    },
                    {
                        "username": "han35",
                        "content": "[0] means there is 1 paper and the citation is 0.\\nAccording to the description\\n\\n> A scientist has index h if h of his/her N papers have at least h citations each, and the other N \\u2212 h papers have no more than h citations each\\n\\nA scientist has 1(h) of his/her 1 paper has at least 0(h) citation, and the other 0 paper has no more than 0 citation.\\n\\nIs this a contradiction?"
                    },
                    {
                        "username": "yellowstar1014",
                        "content": "is it possible to have two h in this problem? please give an example?"
                    },
                    {
                        "username": "Dzuchun",
                        "content": "it literaly says to be a maximum value. how in the world would something have two distinct maximum values?"
                    },
                    {
                        "username": "pieceofpie",
                        "content": "![hehe.png](https://assets.leetcode.com/users/images/f16e4f9d-434f-4e5c-bf36-3cc106ea074a_1677794934.0254838.png)"
                    },
                    {
                        "username": "shuyi@cvs",
                        "content": "Hi,\\n\\nI came across a situation:  given citations = [3, 1, 7, 8, 9]. What will be the answer be?\\n\\nAccording to the definition of h-index on Wikipedia: \"A scientist has index h if h of his/her N papers have at least h citations each, and the other N \\u2212 h papers have no more than h citations each.\"\\n\\nWhen h=3, the definition will be \"A scientist has index 3 if 3 of his/her 5 papers have at least 3 citations each, and the other 2 papers have no more than 3 citations each.\" Obviously wrong....\\n\\nWhen h=4, the definition will be \"A scientist has index 4 if 4 of his/her 5 papers have at least 4 citations each, and the other 1 papers have no more than 4 citations each.\" Obviously wrong....\\n\\nWhen h=2, the definition will be \"A scientist has index 2 if 2 of his/her 5 papers have at least 2 citations each, and the other 3 papers have no more than 3 citations each.\" Obviously wrong....\\n\\nSo anybody can give me an answer? Or this question is a wrong one?"
                    },
                    {
                        "username": "user2118U",
                        "content": "Definition of h is The h-index is defined as the maximum value of h such that the given researcher has published at least h papers that have each been cited at least h times. See it is written at least h papers not exact h papers"
                    },
                    {
                        "username": "user2118U",
                        "content": "Dude there  is nothing written like that other papers have no more h citations. your example answer is 3 because researcher has published at least 3 papers and each paper has atleast 3 citations"
                    },
                    {
                        "username": "saurabh8katyal",
                        "content": "Answer will be 3, as the other 2 papers have no more than 3 citations each(1, 3). Not more than 3. Can be equal to."
                    },
                    {
                        "username": "Tsien",
                        "content": "In the problem description, there is a line \"Note: If there are several possible values for h, the maximum one is taken as the h-index.\"\\nI cannot come up with an example that could have several possible values for h. \\nIMO, there is only one value for h for each example according to the definition of H-Index.\\nPlease correct me if i'm wrong.\\nThanks!"
                    },
                    {
                        "username": "Shubh2407",
                        "content": "Anyone thought of Binary search, no need of sorting technique required,\\nDon\\'t open solution if you have not gave it a try using binary search:\\nhttps://leetcode.com/problems/h-index/solutions/3741453/easy-binary-search-problem-no-sorting-technique-required-o-nlogn/ "
                    },
                    {
                        "username": "vishalshrm539",
                        "content": "[@RajputShivraj](/RajputShivraj) He probably meant to apply binary search on the answer and not on the given array."
                    },
                    {
                        "username": "CriticalCorduroy",
                        "content": "How would binary search be beneficial without a sort applied to the citations?"
                    },
                    {
                        "username": "RajputShivraj",
                        "content": "binary search can be applied on sorted arrays na and you are saying no need of sorting techniques\\n"
                    },
                    {
                        "username": "lowiq",
                        "content": "According to the definition of h, \"if h of his/her N papers have at least h citations each, and the other N \\u2212 h papers have no more than h citations each.\" Looks like the h value is unique. The \"Note\" part looks unnecessary. \\n\\nProof: say there exist two h-indices, h1 < h2 (1), which means that, there are h2 numbers have value at least h2 (2) and N-h2 values have value at most h2 (3); there are h1 numbers have value at least h1 (4) and N-h1 values have value at most h1(5).\\n\\nWe have (1)(2)(3), (1) and (2) implies (4), but we can see (5) is not possible. Because we have N-h1 > N-h2, there exists at least one paper not in the set of N-h2 but in the set of N-h1, this paper should have value <= h1 (according to 5) and have value >= h2 (according to 2), this contradicts to (1). \\n\\nThe uniqueness follows."
                    },
                    {
                        "username": "job_xu",
                        "content": "Have two questions about the example 1:why not 5? There are two papers be cited at least 5 times.  why not 1? There are four papers be cited at least 1 times.  "
                    },
                    {
                        "username": "shivam_sharma2004",
                        "content": "5 cant be the ans because there do not exist atleast 5 elements in the array which are greater than 5. Talking about 1 yes it is valid value of h but you need to return the max value of h possible which is 3 in this case ."
                    }
                ]
            },
            {
                "id": 1963174,
                "content": [
                    {
                        "username": "cartesPerforees",
                        "content": "Excuse me, what kind of madman has published 5000 highly-cited papers?\\nI swear that dude must know incredibly much about Riemannian geometry and incredibly little about women"
                    },
                    {
                        "username": "ignacioariasdev",
                        "content": "[@dungtuanuet](/dungtuanuet) what gives u money?"
                    },
                    {
                        "username": "dungtuanuet",
                        "content": "rolf\\n"
                    },
                    {
                        "username": "ourlord",
                        "content": "According to the hint, I tried my version with the build-in `sort()` and get a one time AC. But if in a real interview scenario, do we allow to use build-in sort to solve this problem?\\n\\nWhat would the actual point the interviewee might look for?"
                    },
                    {
                        "username": "isydor",
                        "content": "[@Tribhuwan-Joshi](/Tribhuwan-Joshi) it is literally mentioned on the wiki page..."
                    },
                    {
                        "username": "NareshSawlani",
                        "content": "interviewer would be looking for your approach like in this question it would be using count sort manually no API"
                    },
                    {
                        "username": "Tribhuwan-Joshi",
                        "content": "Please don\\'t share hints like using `sort()` in the discussion "
                    },
                    {
                        "username": "haucaucau",
                        "content": "What if the input is [4,4,4,4,4,4,5]?\\nWhen I run with my code the answer is 4 and it was accepted.\\nBut I don\\'t understand cause there are 7 papers that have at least 4 citations,\\nand 0 paper no more than 4, which contradicts the description."
                    },
                    {
                        "username": "DxRz729",
                        "content": "Yes your the input has 7 papers with 4 citations, but the h in h-index means that it should be the same for no of citations and no of papers, so we will only take 4 papers as it is min of (4,7)"
                    },
                    {
                        "username": "hemantsingh4774",
                        "content": "[@hemantsingh4774](/hemantsingh4774)  reference: https://en.wikipedia.org/wiki/H-index"
                    },
                    {
                        "username": "hemantsingh4774",
                        "content": " For example, if an author has five publications, with 9, 7, 6, 2, and 1 citations (ordered from greatest to least), then the author\\'s h-index is 3, because the author has three publications with 3 or more citations. However, the author does not have four publications with 4 or more citations."
                    },
                    {
                        "username": "han35",
                        "content": "[0] means there is 1 paper and the citation is 0.\\nAccording to the description\\n\\n> A scientist has index h if h of his/her N papers have at least h citations each, and the other N \\u2212 h papers have no more than h citations each\\n\\nA scientist has 1(h) of his/her 1 paper has at least 0(h) citation, and the other 0 paper has no more than 0 citation.\\n\\nIs this a contradiction?"
                    },
                    {
                        "username": "yellowstar1014",
                        "content": "is it possible to have two h in this problem? please give an example?"
                    },
                    {
                        "username": "Dzuchun",
                        "content": "it literaly says to be a maximum value. how in the world would something have two distinct maximum values?"
                    },
                    {
                        "username": "pieceofpie",
                        "content": "![hehe.png](https://assets.leetcode.com/users/images/f16e4f9d-434f-4e5c-bf36-3cc106ea074a_1677794934.0254838.png)"
                    },
                    {
                        "username": "shuyi@cvs",
                        "content": "Hi,\\n\\nI came across a situation:  given citations = [3, 1, 7, 8, 9]. What will be the answer be?\\n\\nAccording to the definition of h-index on Wikipedia: \"A scientist has index h if h of his/her N papers have at least h citations each, and the other N \\u2212 h papers have no more than h citations each.\"\\n\\nWhen h=3, the definition will be \"A scientist has index 3 if 3 of his/her 5 papers have at least 3 citations each, and the other 2 papers have no more than 3 citations each.\" Obviously wrong....\\n\\nWhen h=4, the definition will be \"A scientist has index 4 if 4 of his/her 5 papers have at least 4 citations each, and the other 1 papers have no more than 4 citations each.\" Obviously wrong....\\n\\nWhen h=2, the definition will be \"A scientist has index 2 if 2 of his/her 5 papers have at least 2 citations each, and the other 3 papers have no more than 3 citations each.\" Obviously wrong....\\n\\nSo anybody can give me an answer? Or this question is a wrong one?"
                    },
                    {
                        "username": "user2118U",
                        "content": "Definition of h is The h-index is defined as the maximum value of h such that the given researcher has published at least h papers that have each been cited at least h times. See it is written at least h papers not exact h papers"
                    },
                    {
                        "username": "user2118U",
                        "content": "Dude there  is nothing written like that other papers have no more h citations. your example answer is 3 because researcher has published at least 3 papers and each paper has atleast 3 citations"
                    },
                    {
                        "username": "saurabh8katyal",
                        "content": "Answer will be 3, as the other 2 papers have no more than 3 citations each(1, 3). Not more than 3. Can be equal to."
                    },
                    {
                        "username": "Tsien",
                        "content": "In the problem description, there is a line \"Note: If there are several possible values for h, the maximum one is taken as the h-index.\"\\nI cannot come up with an example that could have several possible values for h. \\nIMO, there is only one value for h for each example according to the definition of H-Index.\\nPlease correct me if i'm wrong.\\nThanks!"
                    },
                    {
                        "username": "Shubh2407",
                        "content": "Anyone thought of Binary search, no need of sorting technique required,\\nDon\\'t open solution if you have not gave it a try using binary search:\\nhttps://leetcode.com/problems/h-index/solutions/3741453/easy-binary-search-problem-no-sorting-technique-required-o-nlogn/ "
                    },
                    {
                        "username": "vishalshrm539",
                        "content": "[@RajputShivraj](/RajputShivraj) He probably meant to apply binary search on the answer and not on the given array."
                    },
                    {
                        "username": "CriticalCorduroy",
                        "content": "How would binary search be beneficial without a sort applied to the citations?"
                    },
                    {
                        "username": "RajputShivraj",
                        "content": "binary search can be applied on sorted arrays na and you are saying no need of sorting techniques\\n"
                    },
                    {
                        "username": "lowiq",
                        "content": "According to the definition of h, \"if h of his/her N papers have at least h citations each, and the other N \\u2212 h papers have no more than h citations each.\" Looks like the h value is unique. The \"Note\" part looks unnecessary. \\n\\nProof: say there exist two h-indices, h1 < h2 (1), which means that, there are h2 numbers have value at least h2 (2) and N-h2 values have value at most h2 (3); there are h1 numbers have value at least h1 (4) and N-h1 values have value at most h1(5).\\n\\nWe have (1)(2)(3), (1) and (2) implies (4), but we can see (5) is not possible. Because we have N-h1 > N-h2, there exists at least one paper not in the set of N-h2 but in the set of N-h1, this paper should have value <= h1 (according to 5) and have value >= h2 (according to 2), this contradicts to (1). \\n\\nThe uniqueness follows."
                    },
                    {
                        "username": "job_xu",
                        "content": "Have two questions about the example 1:why not 5? There are two papers be cited at least 5 times.  why not 1? There are four papers be cited at least 1 times.  "
                    },
                    {
                        "username": "shivam_sharma2004",
                        "content": "5 cant be the ans because there do not exist atleast 5 elements in the array which are greater than 5. Talking about 1 yes it is valid value of h but you need to return the max value of h possible which is 3 in this case ."
                    }
                ]
            },
            {
                "id": 1569051,
                "content": [
                    {
                        "username": "cartesPerforees",
                        "content": "Excuse me, what kind of madman has published 5000 highly-cited papers?\\nI swear that dude must know incredibly much about Riemannian geometry and incredibly little about women"
                    },
                    {
                        "username": "ignacioariasdev",
                        "content": "[@dungtuanuet](/dungtuanuet) what gives u money?"
                    },
                    {
                        "username": "dungtuanuet",
                        "content": "rolf\\n"
                    },
                    {
                        "username": "ourlord",
                        "content": "According to the hint, I tried my version with the build-in `sort()` and get a one time AC. But if in a real interview scenario, do we allow to use build-in sort to solve this problem?\\n\\nWhat would the actual point the interviewee might look for?"
                    },
                    {
                        "username": "isydor",
                        "content": "[@Tribhuwan-Joshi](/Tribhuwan-Joshi) it is literally mentioned on the wiki page..."
                    },
                    {
                        "username": "NareshSawlani",
                        "content": "interviewer would be looking for your approach like in this question it would be using count sort manually no API"
                    },
                    {
                        "username": "Tribhuwan-Joshi",
                        "content": "Please don\\'t share hints like using `sort()` in the discussion "
                    },
                    {
                        "username": "haucaucau",
                        "content": "What if the input is [4,4,4,4,4,4,5]?\\nWhen I run with my code the answer is 4 and it was accepted.\\nBut I don\\'t understand cause there are 7 papers that have at least 4 citations,\\nand 0 paper no more than 4, which contradicts the description."
                    },
                    {
                        "username": "DxRz729",
                        "content": "Yes your the input has 7 papers with 4 citations, but the h in h-index means that it should be the same for no of citations and no of papers, so we will only take 4 papers as it is min of (4,7)"
                    },
                    {
                        "username": "hemantsingh4774",
                        "content": "[@hemantsingh4774](/hemantsingh4774)  reference: https://en.wikipedia.org/wiki/H-index"
                    },
                    {
                        "username": "hemantsingh4774",
                        "content": " For example, if an author has five publications, with 9, 7, 6, 2, and 1 citations (ordered from greatest to least), then the author\\'s h-index is 3, because the author has three publications with 3 or more citations. However, the author does not have four publications with 4 or more citations."
                    },
                    {
                        "username": "han35",
                        "content": "[0] means there is 1 paper and the citation is 0.\\nAccording to the description\\n\\n> A scientist has index h if h of his/her N papers have at least h citations each, and the other N \\u2212 h papers have no more than h citations each\\n\\nA scientist has 1(h) of his/her 1 paper has at least 0(h) citation, and the other 0 paper has no more than 0 citation.\\n\\nIs this a contradiction?"
                    },
                    {
                        "username": "yellowstar1014",
                        "content": "is it possible to have two h in this problem? please give an example?"
                    },
                    {
                        "username": "Dzuchun",
                        "content": "it literaly says to be a maximum value. how in the world would something have two distinct maximum values?"
                    },
                    {
                        "username": "pieceofpie",
                        "content": "![hehe.png](https://assets.leetcode.com/users/images/f16e4f9d-434f-4e5c-bf36-3cc106ea074a_1677794934.0254838.png)"
                    },
                    {
                        "username": "shuyi@cvs",
                        "content": "Hi,\\n\\nI came across a situation:  given citations = [3, 1, 7, 8, 9]. What will be the answer be?\\n\\nAccording to the definition of h-index on Wikipedia: \"A scientist has index h if h of his/her N papers have at least h citations each, and the other N \\u2212 h papers have no more than h citations each.\"\\n\\nWhen h=3, the definition will be \"A scientist has index 3 if 3 of his/her 5 papers have at least 3 citations each, and the other 2 papers have no more than 3 citations each.\" Obviously wrong....\\n\\nWhen h=4, the definition will be \"A scientist has index 4 if 4 of his/her 5 papers have at least 4 citations each, and the other 1 papers have no more than 4 citations each.\" Obviously wrong....\\n\\nWhen h=2, the definition will be \"A scientist has index 2 if 2 of his/her 5 papers have at least 2 citations each, and the other 3 papers have no more than 3 citations each.\" Obviously wrong....\\n\\nSo anybody can give me an answer? Or this question is a wrong one?"
                    },
                    {
                        "username": "user2118U",
                        "content": "Definition of h is The h-index is defined as the maximum value of h such that the given researcher has published at least h papers that have each been cited at least h times. See it is written at least h papers not exact h papers"
                    },
                    {
                        "username": "user2118U",
                        "content": "Dude there  is nothing written like that other papers have no more h citations. your example answer is 3 because researcher has published at least 3 papers and each paper has atleast 3 citations"
                    },
                    {
                        "username": "saurabh8katyal",
                        "content": "Answer will be 3, as the other 2 papers have no more than 3 citations each(1, 3). Not more than 3. Can be equal to."
                    },
                    {
                        "username": "Tsien",
                        "content": "In the problem description, there is a line \"Note: If there are several possible values for h, the maximum one is taken as the h-index.\"\\nI cannot come up with an example that could have several possible values for h. \\nIMO, there is only one value for h for each example according to the definition of H-Index.\\nPlease correct me if i'm wrong.\\nThanks!"
                    },
                    {
                        "username": "Shubh2407",
                        "content": "Anyone thought of Binary search, no need of sorting technique required,\\nDon\\'t open solution if you have not gave it a try using binary search:\\nhttps://leetcode.com/problems/h-index/solutions/3741453/easy-binary-search-problem-no-sorting-technique-required-o-nlogn/ "
                    },
                    {
                        "username": "vishalshrm539",
                        "content": "[@RajputShivraj](/RajputShivraj) He probably meant to apply binary search on the answer and not on the given array."
                    },
                    {
                        "username": "CriticalCorduroy",
                        "content": "How would binary search be beneficial without a sort applied to the citations?"
                    },
                    {
                        "username": "RajputShivraj",
                        "content": "binary search can be applied on sorted arrays na and you are saying no need of sorting techniques\\n"
                    },
                    {
                        "username": "lowiq",
                        "content": "According to the definition of h, \"if h of his/her N papers have at least h citations each, and the other N \\u2212 h papers have no more than h citations each.\" Looks like the h value is unique. The \"Note\" part looks unnecessary. \\n\\nProof: say there exist two h-indices, h1 < h2 (1), which means that, there are h2 numbers have value at least h2 (2) and N-h2 values have value at most h2 (3); there are h1 numbers have value at least h1 (4) and N-h1 values have value at most h1(5).\\n\\nWe have (1)(2)(3), (1) and (2) implies (4), but we can see (5) is not possible. Because we have N-h1 > N-h2, there exists at least one paper not in the set of N-h2 but in the set of N-h1, this paper should have value <= h1 (according to 5) and have value >= h2 (according to 2), this contradicts to (1). \\n\\nThe uniqueness follows."
                    },
                    {
                        "username": "job_xu",
                        "content": "Have two questions about the example 1:why not 5? There are two papers be cited at least 5 times.  why not 1? There are four papers be cited at least 1 times.  "
                    },
                    {
                        "username": "shivam_sharma2004",
                        "content": "5 cant be the ans because there do not exist atleast 5 elements in the array which are greater than 5. Talking about 1 yes it is valid value of h but you need to return the max value of h possible which is 3 in this case ."
                    }
                ]
            },
            {
                "id": 1941363,
                "content": [
                    {
                        "username": "cartesPerforees",
                        "content": "Excuse me, what kind of madman has published 5000 highly-cited papers?\\nI swear that dude must know incredibly much about Riemannian geometry and incredibly little about women"
                    },
                    {
                        "username": "ignacioariasdev",
                        "content": "[@dungtuanuet](/dungtuanuet) what gives u money?"
                    },
                    {
                        "username": "dungtuanuet",
                        "content": "rolf\\n"
                    },
                    {
                        "username": "ourlord",
                        "content": "According to the hint, I tried my version with the build-in `sort()` and get a one time AC. But if in a real interview scenario, do we allow to use build-in sort to solve this problem?\\n\\nWhat would the actual point the interviewee might look for?"
                    },
                    {
                        "username": "isydor",
                        "content": "[@Tribhuwan-Joshi](/Tribhuwan-Joshi) it is literally mentioned on the wiki page..."
                    },
                    {
                        "username": "NareshSawlani",
                        "content": "interviewer would be looking for your approach like in this question it would be using count sort manually no API"
                    },
                    {
                        "username": "Tribhuwan-Joshi",
                        "content": "Please don\\'t share hints like using `sort()` in the discussion "
                    },
                    {
                        "username": "haucaucau",
                        "content": "What if the input is [4,4,4,4,4,4,5]?\\nWhen I run with my code the answer is 4 and it was accepted.\\nBut I don\\'t understand cause there are 7 papers that have at least 4 citations,\\nand 0 paper no more than 4, which contradicts the description."
                    },
                    {
                        "username": "DxRz729",
                        "content": "Yes your the input has 7 papers with 4 citations, but the h in h-index means that it should be the same for no of citations and no of papers, so we will only take 4 papers as it is min of (4,7)"
                    },
                    {
                        "username": "hemantsingh4774",
                        "content": "[@hemantsingh4774](/hemantsingh4774)  reference: https://en.wikipedia.org/wiki/H-index"
                    },
                    {
                        "username": "hemantsingh4774",
                        "content": " For example, if an author has five publications, with 9, 7, 6, 2, and 1 citations (ordered from greatest to least), then the author\\'s h-index is 3, because the author has three publications with 3 or more citations. However, the author does not have four publications with 4 or more citations."
                    },
                    {
                        "username": "han35",
                        "content": "[0] means there is 1 paper and the citation is 0.\\nAccording to the description\\n\\n> A scientist has index h if h of his/her N papers have at least h citations each, and the other N \\u2212 h papers have no more than h citations each\\n\\nA scientist has 1(h) of his/her 1 paper has at least 0(h) citation, and the other 0 paper has no more than 0 citation.\\n\\nIs this a contradiction?"
                    },
                    {
                        "username": "yellowstar1014",
                        "content": "is it possible to have two h in this problem? please give an example?"
                    },
                    {
                        "username": "Dzuchun",
                        "content": "it literaly says to be a maximum value. how in the world would something have two distinct maximum values?"
                    },
                    {
                        "username": "pieceofpie",
                        "content": "![hehe.png](https://assets.leetcode.com/users/images/f16e4f9d-434f-4e5c-bf36-3cc106ea074a_1677794934.0254838.png)"
                    },
                    {
                        "username": "shuyi@cvs",
                        "content": "Hi,\\n\\nI came across a situation:  given citations = [3, 1, 7, 8, 9]. What will be the answer be?\\n\\nAccording to the definition of h-index on Wikipedia: \"A scientist has index h if h of his/her N papers have at least h citations each, and the other N \\u2212 h papers have no more than h citations each.\"\\n\\nWhen h=3, the definition will be \"A scientist has index 3 if 3 of his/her 5 papers have at least 3 citations each, and the other 2 papers have no more than 3 citations each.\" Obviously wrong....\\n\\nWhen h=4, the definition will be \"A scientist has index 4 if 4 of his/her 5 papers have at least 4 citations each, and the other 1 papers have no more than 4 citations each.\" Obviously wrong....\\n\\nWhen h=2, the definition will be \"A scientist has index 2 if 2 of his/her 5 papers have at least 2 citations each, and the other 3 papers have no more than 3 citations each.\" Obviously wrong....\\n\\nSo anybody can give me an answer? Or this question is a wrong one?"
                    },
                    {
                        "username": "user2118U",
                        "content": "Definition of h is The h-index is defined as the maximum value of h such that the given researcher has published at least h papers that have each been cited at least h times. See it is written at least h papers not exact h papers"
                    },
                    {
                        "username": "user2118U",
                        "content": "Dude there  is nothing written like that other papers have no more h citations. your example answer is 3 because researcher has published at least 3 papers and each paper has atleast 3 citations"
                    },
                    {
                        "username": "saurabh8katyal",
                        "content": "Answer will be 3, as the other 2 papers have no more than 3 citations each(1, 3). Not more than 3. Can be equal to."
                    },
                    {
                        "username": "Tsien",
                        "content": "In the problem description, there is a line \"Note: If there are several possible values for h, the maximum one is taken as the h-index.\"\\nI cannot come up with an example that could have several possible values for h. \\nIMO, there is only one value for h for each example according to the definition of H-Index.\\nPlease correct me if i'm wrong.\\nThanks!"
                    },
                    {
                        "username": "Shubh2407",
                        "content": "Anyone thought of Binary search, no need of sorting technique required,\\nDon\\'t open solution if you have not gave it a try using binary search:\\nhttps://leetcode.com/problems/h-index/solutions/3741453/easy-binary-search-problem-no-sorting-technique-required-o-nlogn/ "
                    },
                    {
                        "username": "vishalshrm539",
                        "content": "[@RajputShivraj](/RajputShivraj) He probably meant to apply binary search on the answer and not on the given array."
                    },
                    {
                        "username": "CriticalCorduroy",
                        "content": "How would binary search be beneficial without a sort applied to the citations?"
                    },
                    {
                        "username": "RajputShivraj",
                        "content": "binary search can be applied on sorted arrays na and you are saying no need of sorting techniques\\n"
                    },
                    {
                        "username": "lowiq",
                        "content": "According to the definition of h, \"if h of his/her N papers have at least h citations each, and the other N \\u2212 h papers have no more than h citations each.\" Looks like the h value is unique. The \"Note\" part looks unnecessary. \\n\\nProof: say there exist two h-indices, h1 < h2 (1), which means that, there are h2 numbers have value at least h2 (2) and N-h2 values have value at most h2 (3); there are h1 numbers have value at least h1 (4) and N-h1 values have value at most h1(5).\\n\\nWe have (1)(2)(3), (1) and (2) implies (4), but we can see (5) is not possible. Because we have N-h1 > N-h2, there exists at least one paper not in the set of N-h2 but in the set of N-h1, this paper should have value <= h1 (according to 5) and have value >= h2 (according to 2), this contradicts to (1). \\n\\nThe uniqueness follows."
                    },
                    {
                        "username": "job_xu",
                        "content": "Have two questions about the example 1:why not 5? There are two papers be cited at least 5 times.  why not 1? There are four papers be cited at least 1 times.  "
                    },
                    {
                        "username": "shivam_sharma2004",
                        "content": "5 cant be the ans because there do not exist atleast 5 elements in the array which are greater than 5. Talking about 1 yes it is valid value of h but you need to return the max value of h possible which is 3 in this case ."
                    }
                ]
            },
            {
                "id": 2039649,
                "content": [
                    {
                        "username": "Vinayellulla",
                        "content": "what is meant by citations?\\n"
                    },
                    {
                        "username": "StefanelStan",
                        "content": "A very similar question with https://leetcode.com/problems/h-index-ii/ .\\nBoth can be solved by sorting and binary search the best h index. (max number of \"good\" publications)"
                    },
                    {
                        "username": "lenhatduc30042003",
                        "content": " given citations = [1,2]. What will be the answer be?"
                    },
                    {
                        "username": "harishgokul",
                        "content": "i think 1 because each value has 1 citations."
                    },
                    {
                        "username": "SlaveToJavascript",
                        "content": "Why would a binary search solution that searches for the max valid h-index not work for this question?"
                    },
                    {
                        "username": "bernikovich",
                        "content": "It works. I think it\\'s even better than sorting. However, counting has a better time complexity of $$O(n)$$ compared to $$O(n logn)$$."
                    },
                    {
                        "username": "LearnUnlearnRepeat",
                        "content": "how come the expected answer is 2 for the input [11,15].."
                    },
                    {
                        "username": "bernikovich",
                        "content": "Because [11, 15] indicates that the researcher has only 2 papers with 11 and 15 citations, respectively. By definition, the H-index cannot exceed the number of papers, which in this case is 2."
                    },
                    {
                        "username": "minhphamduy",
                        "content": "This is solution is java: https://leetcode.com/problems/h-index/submissions/987689138"
                    },
                    {
                        "username": "Anantashayana",
                        "content": "For [100] why 1 and not 100?"
                    },
                    {
                        "username": "psionl0",
                        "content": "You are returning the number of papers, not the number of citations."
                    },
                    {
                        "username": "sandeepmit25",
                        "content": "[1,2,0] what would be the output?\nmy output is 0\n"
                    },
                    {
                        "username": "psionl0",
                        "content": "The answer is 1. The researcher published 2 papers that had at least 1 citation.\\n(Had we said that the answer was 2 then there is only 1 paper published that has 2 citations and that is less than the h-index)."
                    },
                    {
                        "username": "prakhar3062",
                        "content": "I tried to apply counting sort in non-increasing order but only one test case passes\\n "
                    },
                    {
                        "username": "Avirat06",
                        "content": "getting internal error on my submission for this question"
                    }
                ]
            },
            {
                "id": 2026158,
                "content": [
                    {
                        "username": "Vinayellulla",
                        "content": "what is meant by citations?\\n"
                    },
                    {
                        "username": "StefanelStan",
                        "content": "A very similar question with https://leetcode.com/problems/h-index-ii/ .\\nBoth can be solved by sorting and binary search the best h index. (max number of \"good\" publications)"
                    },
                    {
                        "username": "lenhatduc30042003",
                        "content": " given citations = [1,2]. What will be the answer be?"
                    },
                    {
                        "username": "harishgokul",
                        "content": "i think 1 because each value has 1 citations."
                    },
                    {
                        "username": "SlaveToJavascript",
                        "content": "Why would a binary search solution that searches for the max valid h-index not work for this question?"
                    },
                    {
                        "username": "bernikovich",
                        "content": "It works. I think it\\'s even better than sorting. However, counting has a better time complexity of $$O(n)$$ compared to $$O(n logn)$$."
                    },
                    {
                        "username": "LearnUnlearnRepeat",
                        "content": "how come the expected answer is 2 for the input [11,15].."
                    },
                    {
                        "username": "bernikovich",
                        "content": "Because [11, 15] indicates that the researcher has only 2 papers with 11 and 15 citations, respectively. By definition, the H-index cannot exceed the number of papers, which in this case is 2."
                    },
                    {
                        "username": "minhphamduy",
                        "content": "This is solution is java: https://leetcode.com/problems/h-index/submissions/987689138"
                    },
                    {
                        "username": "Anantashayana",
                        "content": "For [100] why 1 and not 100?"
                    },
                    {
                        "username": "psionl0",
                        "content": "You are returning the number of papers, not the number of citations."
                    },
                    {
                        "username": "sandeepmit25",
                        "content": "[1,2,0] what would be the output?\nmy output is 0\n"
                    },
                    {
                        "username": "psionl0",
                        "content": "The answer is 1. The researcher published 2 papers that had at least 1 citation.\\n(Had we said that the answer was 2 then there is only 1 paper published that has 2 citations and that is less than the h-index)."
                    },
                    {
                        "username": "prakhar3062",
                        "content": "I tried to apply counting sort in non-increasing order but only one test case passes\\n "
                    },
                    {
                        "username": "Avirat06",
                        "content": "getting internal error on my submission for this question"
                    }
                ]
            },
            {
                "id": 2022443,
                "content": [
                    {
                        "username": "Vinayellulla",
                        "content": "what is meant by citations?\\n"
                    },
                    {
                        "username": "StefanelStan",
                        "content": "A very similar question with https://leetcode.com/problems/h-index-ii/ .\\nBoth can be solved by sorting and binary search the best h index. (max number of \"good\" publications)"
                    },
                    {
                        "username": "lenhatduc30042003",
                        "content": " given citations = [1,2]. What will be the answer be?"
                    },
                    {
                        "username": "harishgokul",
                        "content": "i think 1 because each value has 1 citations."
                    },
                    {
                        "username": "SlaveToJavascript",
                        "content": "Why would a binary search solution that searches for the max valid h-index not work for this question?"
                    },
                    {
                        "username": "bernikovich",
                        "content": "It works. I think it\\'s even better than sorting. However, counting has a better time complexity of $$O(n)$$ compared to $$O(n logn)$$."
                    },
                    {
                        "username": "LearnUnlearnRepeat",
                        "content": "how come the expected answer is 2 for the input [11,15].."
                    },
                    {
                        "username": "bernikovich",
                        "content": "Because [11, 15] indicates that the researcher has only 2 papers with 11 and 15 citations, respectively. By definition, the H-index cannot exceed the number of papers, which in this case is 2."
                    },
                    {
                        "username": "minhphamduy",
                        "content": "This is solution is java: https://leetcode.com/problems/h-index/submissions/987689138"
                    },
                    {
                        "username": "Anantashayana",
                        "content": "For [100] why 1 and not 100?"
                    },
                    {
                        "username": "psionl0",
                        "content": "You are returning the number of papers, not the number of citations."
                    },
                    {
                        "username": "sandeepmit25",
                        "content": "[1,2,0] what would be the output?\nmy output is 0\n"
                    },
                    {
                        "username": "psionl0",
                        "content": "The answer is 1. The researcher published 2 papers that had at least 1 citation.\\n(Had we said that the answer was 2 then there is only 1 paper published that has 2 citations and that is less than the h-index)."
                    },
                    {
                        "username": "prakhar3062",
                        "content": "I tried to apply counting sort in non-increasing order but only one test case passes\\n "
                    },
                    {
                        "username": "Avirat06",
                        "content": "getting internal error on my submission for this question"
                    }
                ]
            },
            {
                "id": 2017824,
                "content": [
                    {
                        "username": "Vinayellulla",
                        "content": "what is meant by citations?\\n"
                    },
                    {
                        "username": "StefanelStan",
                        "content": "A very similar question with https://leetcode.com/problems/h-index-ii/ .\\nBoth can be solved by sorting and binary search the best h index. (max number of \"good\" publications)"
                    },
                    {
                        "username": "lenhatduc30042003",
                        "content": " given citations = [1,2]. What will be the answer be?"
                    },
                    {
                        "username": "harishgokul",
                        "content": "i think 1 because each value has 1 citations."
                    },
                    {
                        "username": "SlaveToJavascript",
                        "content": "Why would a binary search solution that searches for the max valid h-index not work for this question?"
                    },
                    {
                        "username": "bernikovich",
                        "content": "It works. I think it\\'s even better than sorting. However, counting has a better time complexity of $$O(n)$$ compared to $$O(n logn)$$."
                    },
                    {
                        "username": "LearnUnlearnRepeat",
                        "content": "how come the expected answer is 2 for the input [11,15].."
                    },
                    {
                        "username": "bernikovich",
                        "content": "Because [11, 15] indicates that the researcher has only 2 papers with 11 and 15 citations, respectively. By definition, the H-index cannot exceed the number of papers, which in this case is 2."
                    },
                    {
                        "username": "minhphamduy",
                        "content": "This is solution is java: https://leetcode.com/problems/h-index/submissions/987689138"
                    },
                    {
                        "username": "Anantashayana",
                        "content": "For [100] why 1 and not 100?"
                    },
                    {
                        "username": "psionl0",
                        "content": "You are returning the number of papers, not the number of citations."
                    },
                    {
                        "username": "sandeepmit25",
                        "content": "[1,2,0] what would be the output?\nmy output is 0\n"
                    },
                    {
                        "username": "psionl0",
                        "content": "The answer is 1. The researcher published 2 papers that had at least 1 citation.\\n(Had we said that the answer was 2 then there is only 1 paper published that has 2 citations and that is less than the h-index)."
                    },
                    {
                        "username": "prakhar3062",
                        "content": "I tried to apply counting sort in non-increasing order but only one test case passes\\n "
                    },
                    {
                        "username": "Avirat06",
                        "content": "getting internal error on my submission for this question"
                    }
                ]
            },
            {
                "id": 2001424,
                "content": [
                    {
                        "username": "Vinayellulla",
                        "content": "what is meant by citations?\\n"
                    },
                    {
                        "username": "StefanelStan",
                        "content": "A very similar question with https://leetcode.com/problems/h-index-ii/ .\\nBoth can be solved by sorting and binary search the best h index. (max number of \"good\" publications)"
                    },
                    {
                        "username": "lenhatduc30042003",
                        "content": " given citations = [1,2]. What will be the answer be?"
                    },
                    {
                        "username": "harishgokul",
                        "content": "i think 1 because each value has 1 citations."
                    },
                    {
                        "username": "SlaveToJavascript",
                        "content": "Why would a binary search solution that searches for the max valid h-index not work for this question?"
                    },
                    {
                        "username": "bernikovich",
                        "content": "It works. I think it\\'s even better than sorting. However, counting has a better time complexity of $$O(n)$$ compared to $$O(n logn)$$."
                    },
                    {
                        "username": "LearnUnlearnRepeat",
                        "content": "how come the expected answer is 2 for the input [11,15].."
                    },
                    {
                        "username": "bernikovich",
                        "content": "Because [11, 15] indicates that the researcher has only 2 papers with 11 and 15 citations, respectively. By definition, the H-index cannot exceed the number of papers, which in this case is 2."
                    },
                    {
                        "username": "minhphamduy",
                        "content": "This is solution is java: https://leetcode.com/problems/h-index/submissions/987689138"
                    },
                    {
                        "username": "Anantashayana",
                        "content": "For [100] why 1 and not 100?"
                    },
                    {
                        "username": "psionl0",
                        "content": "You are returning the number of papers, not the number of citations."
                    },
                    {
                        "username": "sandeepmit25",
                        "content": "[1,2,0] what would be the output?\nmy output is 0\n"
                    },
                    {
                        "username": "psionl0",
                        "content": "The answer is 1. The researcher published 2 papers that had at least 1 citation.\\n(Had we said that the answer was 2 then there is only 1 paper published that has 2 citations and that is less than the h-index)."
                    },
                    {
                        "username": "prakhar3062",
                        "content": "I tried to apply counting sort in non-increasing order but only one test case passes\\n "
                    },
                    {
                        "username": "Avirat06",
                        "content": "getting internal error on my submission for this question"
                    }
                ]
            },
            {
                "id": 1958622,
                "content": [
                    {
                        "username": "Vinayellulla",
                        "content": "what is meant by citations?\\n"
                    },
                    {
                        "username": "StefanelStan",
                        "content": "A very similar question with https://leetcode.com/problems/h-index-ii/ .\\nBoth can be solved by sorting and binary search the best h index. (max number of \"good\" publications)"
                    },
                    {
                        "username": "lenhatduc30042003",
                        "content": " given citations = [1,2]. What will be the answer be?"
                    },
                    {
                        "username": "harishgokul",
                        "content": "i think 1 because each value has 1 citations."
                    },
                    {
                        "username": "SlaveToJavascript",
                        "content": "Why would a binary search solution that searches for the max valid h-index not work for this question?"
                    },
                    {
                        "username": "bernikovich",
                        "content": "It works. I think it\\'s even better than sorting. However, counting has a better time complexity of $$O(n)$$ compared to $$O(n logn)$$."
                    },
                    {
                        "username": "LearnUnlearnRepeat",
                        "content": "how come the expected answer is 2 for the input [11,15].."
                    },
                    {
                        "username": "bernikovich",
                        "content": "Because [11, 15] indicates that the researcher has only 2 papers with 11 and 15 citations, respectively. By definition, the H-index cannot exceed the number of papers, which in this case is 2."
                    },
                    {
                        "username": "minhphamduy",
                        "content": "This is solution is java: https://leetcode.com/problems/h-index/submissions/987689138"
                    },
                    {
                        "username": "Anantashayana",
                        "content": "For [100] why 1 and not 100?"
                    },
                    {
                        "username": "psionl0",
                        "content": "You are returning the number of papers, not the number of citations."
                    },
                    {
                        "username": "sandeepmit25",
                        "content": "[1,2,0] what would be the output?\nmy output is 0\n"
                    },
                    {
                        "username": "psionl0",
                        "content": "The answer is 1. The researcher published 2 papers that had at least 1 citation.\\n(Had we said that the answer was 2 then there is only 1 paper published that has 2 citations and that is less than the h-index)."
                    },
                    {
                        "username": "prakhar3062",
                        "content": "I tried to apply counting sort in non-increasing order but only one test case passes\\n "
                    },
                    {
                        "username": "Avirat06",
                        "content": "getting internal error on my submission for this question"
                    }
                ]
            },
            {
                "id": 1956621,
                "content": [
                    {
                        "username": "Vinayellulla",
                        "content": "what is meant by citations?\\n"
                    },
                    {
                        "username": "StefanelStan",
                        "content": "A very similar question with https://leetcode.com/problems/h-index-ii/ .\\nBoth can be solved by sorting and binary search the best h index. (max number of \"good\" publications)"
                    },
                    {
                        "username": "lenhatduc30042003",
                        "content": " given citations = [1,2]. What will be the answer be?"
                    },
                    {
                        "username": "harishgokul",
                        "content": "i think 1 because each value has 1 citations."
                    },
                    {
                        "username": "SlaveToJavascript",
                        "content": "Why would a binary search solution that searches for the max valid h-index not work for this question?"
                    },
                    {
                        "username": "bernikovich",
                        "content": "It works. I think it\\'s even better than sorting. However, counting has a better time complexity of $$O(n)$$ compared to $$O(n logn)$$."
                    },
                    {
                        "username": "LearnUnlearnRepeat",
                        "content": "how come the expected answer is 2 for the input [11,15].."
                    },
                    {
                        "username": "bernikovich",
                        "content": "Because [11, 15] indicates that the researcher has only 2 papers with 11 and 15 citations, respectively. By definition, the H-index cannot exceed the number of papers, which in this case is 2."
                    },
                    {
                        "username": "minhphamduy",
                        "content": "This is solution is java: https://leetcode.com/problems/h-index/submissions/987689138"
                    },
                    {
                        "username": "Anantashayana",
                        "content": "For [100] why 1 and not 100?"
                    },
                    {
                        "username": "psionl0",
                        "content": "You are returning the number of papers, not the number of citations."
                    },
                    {
                        "username": "sandeepmit25",
                        "content": "[1,2,0] what would be the output?\nmy output is 0\n"
                    },
                    {
                        "username": "psionl0",
                        "content": "The answer is 1. The researcher published 2 papers that had at least 1 citation.\\n(Had we said that the answer was 2 then there is only 1 paper published that has 2 citations and that is less than the h-index)."
                    },
                    {
                        "username": "prakhar3062",
                        "content": "I tried to apply counting sort in non-increasing order but only one test case passes\\n "
                    },
                    {
                        "username": "Avirat06",
                        "content": "getting internal error on my submission for this question"
                    }
                ]
            },
            {
                "id": 1950086,
                "content": [
                    {
                        "username": "Vinayellulla",
                        "content": "what is meant by citations?\\n"
                    },
                    {
                        "username": "StefanelStan",
                        "content": "A very similar question with https://leetcode.com/problems/h-index-ii/ .\\nBoth can be solved by sorting and binary search the best h index. (max number of \"good\" publications)"
                    },
                    {
                        "username": "lenhatduc30042003",
                        "content": " given citations = [1,2]. What will be the answer be?"
                    },
                    {
                        "username": "harishgokul",
                        "content": "i think 1 because each value has 1 citations."
                    },
                    {
                        "username": "SlaveToJavascript",
                        "content": "Why would a binary search solution that searches for the max valid h-index not work for this question?"
                    },
                    {
                        "username": "bernikovich",
                        "content": "It works. I think it\\'s even better than sorting. However, counting has a better time complexity of $$O(n)$$ compared to $$O(n logn)$$."
                    },
                    {
                        "username": "LearnUnlearnRepeat",
                        "content": "how come the expected answer is 2 for the input [11,15].."
                    },
                    {
                        "username": "bernikovich",
                        "content": "Because [11, 15] indicates that the researcher has only 2 papers with 11 and 15 citations, respectively. By definition, the H-index cannot exceed the number of papers, which in this case is 2."
                    },
                    {
                        "username": "minhphamduy",
                        "content": "This is solution is java: https://leetcode.com/problems/h-index/submissions/987689138"
                    },
                    {
                        "username": "Anantashayana",
                        "content": "For [100] why 1 and not 100?"
                    },
                    {
                        "username": "psionl0",
                        "content": "You are returning the number of papers, not the number of citations."
                    },
                    {
                        "username": "sandeepmit25",
                        "content": "[1,2,0] what would be the output?\nmy output is 0\n"
                    },
                    {
                        "username": "psionl0",
                        "content": "The answer is 1. The researcher published 2 papers that had at least 1 citation.\\n(Had we said that the answer was 2 then there is only 1 paper published that has 2 citations and that is less than the h-index)."
                    },
                    {
                        "username": "prakhar3062",
                        "content": "I tried to apply counting sort in non-increasing order but only one test case passes\\n "
                    },
                    {
                        "username": "Avirat06",
                        "content": "getting internal error on my submission for this question"
                    }
                ]
            },
            {
                "id": 1940189,
                "content": [
                    {
                        "username": "Vinayellulla",
                        "content": "what is meant by citations?\\n"
                    },
                    {
                        "username": "StefanelStan",
                        "content": "A very similar question with https://leetcode.com/problems/h-index-ii/ .\\nBoth can be solved by sorting and binary search the best h index. (max number of \"good\" publications)"
                    },
                    {
                        "username": "lenhatduc30042003",
                        "content": " given citations = [1,2]. What will be the answer be?"
                    },
                    {
                        "username": "harishgokul",
                        "content": "i think 1 because each value has 1 citations."
                    },
                    {
                        "username": "SlaveToJavascript",
                        "content": "Why would a binary search solution that searches for the max valid h-index not work for this question?"
                    },
                    {
                        "username": "bernikovich",
                        "content": "It works. I think it\\'s even better than sorting. However, counting has a better time complexity of $$O(n)$$ compared to $$O(n logn)$$."
                    },
                    {
                        "username": "LearnUnlearnRepeat",
                        "content": "how come the expected answer is 2 for the input [11,15].."
                    },
                    {
                        "username": "bernikovich",
                        "content": "Because [11, 15] indicates that the researcher has only 2 papers with 11 and 15 citations, respectively. By definition, the H-index cannot exceed the number of papers, which in this case is 2."
                    },
                    {
                        "username": "minhphamduy",
                        "content": "This is solution is java: https://leetcode.com/problems/h-index/submissions/987689138"
                    },
                    {
                        "username": "Anantashayana",
                        "content": "For [100] why 1 and not 100?"
                    },
                    {
                        "username": "psionl0",
                        "content": "You are returning the number of papers, not the number of citations."
                    },
                    {
                        "username": "sandeepmit25",
                        "content": "[1,2,0] what would be the output?\nmy output is 0\n"
                    },
                    {
                        "username": "psionl0",
                        "content": "The answer is 1. The researcher published 2 papers that had at least 1 citation.\\n(Had we said that the answer was 2 then there is only 1 paper published that has 2 citations and that is less than the h-index)."
                    },
                    {
                        "username": "prakhar3062",
                        "content": "I tried to apply counting sort in non-increasing order but only one test case passes\\n "
                    },
                    {
                        "username": "Avirat06",
                        "content": "getting internal error on my submission for this question"
                    }
                ]
            },
            {
                "id": 1886242,
                "content": [
                    {
                        "username": "Vinayellulla",
                        "content": "what is meant by citations?\\n"
                    },
                    {
                        "username": "StefanelStan",
                        "content": "A very similar question with https://leetcode.com/problems/h-index-ii/ .\\nBoth can be solved by sorting and binary search the best h index. (max number of \"good\" publications)"
                    },
                    {
                        "username": "lenhatduc30042003",
                        "content": " given citations = [1,2]. What will be the answer be?"
                    },
                    {
                        "username": "harishgokul",
                        "content": "i think 1 because each value has 1 citations."
                    },
                    {
                        "username": "SlaveToJavascript",
                        "content": "Why would a binary search solution that searches for the max valid h-index not work for this question?"
                    },
                    {
                        "username": "bernikovich",
                        "content": "It works. I think it\\'s even better than sorting. However, counting has a better time complexity of $$O(n)$$ compared to $$O(n logn)$$."
                    },
                    {
                        "username": "LearnUnlearnRepeat",
                        "content": "how come the expected answer is 2 for the input [11,15].."
                    },
                    {
                        "username": "bernikovich",
                        "content": "Because [11, 15] indicates that the researcher has only 2 papers with 11 and 15 citations, respectively. By definition, the H-index cannot exceed the number of papers, which in this case is 2."
                    },
                    {
                        "username": "minhphamduy",
                        "content": "This is solution is java: https://leetcode.com/problems/h-index/submissions/987689138"
                    },
                    {
                        "username": "Anantashayana",
                        "content": "For [100] why 1 and not 100?"
                    },
                    {
                        "username": "psionl0",
                        "content": "You are returning the number of papers, not the number of citations."
                    },
                    {
                        "username": "sandeepmit25",
                        "content": "[1,2,0] what would be the output?\nmy output is 0\n"
                    },
                    {
                        "username": "psionl0",
                        "content": "The answer is 1. The researcher published 2 papers that had at least 1 citation.\\n(Had we said that the answer was 2 then there is only 1 paper published that has 2 citations and that is less than the h-index)."
                    },
                    {
                        "username": "prakhar3062",
                        "content": "I tried to apply counting sort in non-increasing order but only one test case passes\\n "
                    },
                    {
                        "username": "Avirat06",
                        "content": "getting internal error on my submission for this question"
                    }
                ]
            }
        ]
    }
]