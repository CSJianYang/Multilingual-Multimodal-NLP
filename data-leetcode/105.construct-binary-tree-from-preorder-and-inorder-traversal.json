[
    {
        "title": "Longest Palindromic Substring",
        "question_content": "Given a string s, return the longest palindromic substring in s.\n&nbsp;\nExample 1:\nInput: s = \"babad\"\nOutput: \"bab\"\nExplanation: \"aba\" is also a valid answer.\nExample 2:\nInput: s = \"cbbd\"\nOutput: \"bb\"\n&nbsp;\nConstraints:\n\t1 <= s.length <= 1000\n\ts consist of only digits and English letters.",
        "solutions": [
            {
                "id": 2928,
                "title": "very-simple-clean-java-solution",
                "content": "The performance is pretty good, surprisingly.\\n\\n    public class Solution {\\n\\tprivate int lo, maxLen;\\n\\t\\n    public String longestPalindrome(String s) {\\n    \\tint len = s.length();\\n    \\tif (len < 2)\\n    \\t\\treturn s;\\n    \\t\\n        for (int i = 0; i < len-1; i++) {\\n         \\textendPalindrome(s, i, i);  //assume odd length, try to extend Palindrome as possible\\n         \\textendPalindrome(s, i, i+1); //assume even length.\\n        }\\n        return s.substring(lo, lo + maxLen);\\n    }\\n\\n\\tprivate void extendPalindrome(String s, int j, int k) {\\n\\t\\twhile (j >= 0 && k < s.length() && s.charAt(j) == s.charAt(k)) {\\n\\t\\t\\tj--;\\n\\t\\t\\tk++;\\n\\t\\t}\\n\\t\\tif (maxLen < k - j - 1) {\\n\\t\\t\\tlo = j + 1;\\n\\t\\t\\tmaxLen = k - j - 1;\\n\\t\\t}\\n\\t}}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n\\tprivate int lo, maxLen;\\n\\t\\n    public String longestPalindrome(String s) {\\n    \\tint len = s.length();\\n    \\tif (len < 2)\\n    \\t\\treturn s;\\n    \\t\\n        for (int i = 0; i < len-1; i++) {\\n         \\textendPalindrome(s, i, i);  //assume odd length, try to extend Palindrome as possible\\n         \\textendPalindrome(s, i, i+1); //assume even length.\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 151144,
                "title": "bottom-up-dp-two-pointers",
                "content": "Intuitively, we list all the substrings, pick those palindromic, and get the longest one. This approach takes O(n^3) time complexity, where n is the length of `s`.\\n\\n# Dynamic Programming\\nThe problem can be broken down into subproblems which are reused several times. Overlapping subproblems lead us to Dynamic Programming.\\n\\nWe decompose the problem as follows:\\n\\n- State variable\\nThe `start` index and `end` index of a substring can identify a state, which **influences our decision**.\\nSo the state variable is `state(start, end)` indicates whether `s[start, end]` inclusive is palindromic\\n\\n- Goal state\\n`max(end - start + 1)` for all `state(start, end) = true`\\n\\n- State transition\\n```\\nfor start = end (e.g. \\'a\\'), state(start, end) is True\\nfor start + 1 = end (e.g. \\'aa\\'), state(start, end) is True if s[start] = s[end]\\nfor start + 2 = end (e.g. \\'aba\\'),  state(start, end) is True if s[start] = s[end] and state(start + 1, end - 1)\\nfor start + 3 = end (e.g. \\'abba\\'),  state(start, end) is True if s[start] = s[end] and state(start + 1, end - 1)\\n...\\n```\\n\\nThis approach takes O(n^2) time complexity, O(n^2) space complexity, where n is the length of `s`.\\n\\n```\\nclass Solution:\\n    def longestPalindrome(self, s: str) -> str:\\n        n = len(s)\\n        dp = [[False] * n for _ in range(n)]\\n        for i in range(n):\\n            dp[i][i] = True\\n        longest_palindrome_start, longest_palindrome_len = 0, 1\\n\\n        for end in range(0, n):\\n            for start in range(end - 1, -1, -1):\\n                # print(\\'start: %s, end: %s\\' % (start, end))\\n                if s[start] == s[end]:\\n                    if end - start == 1 or dp[start + 1][end - 1]:\\n                        dp[start][end] = True\\n                        palindrome_len = end - start + 1\\n                        if longest_palindrome_len < palindrome_len:\\n                            longest_palindrome_start = start\\n                            longest_palindrome_len = palindrome_len\\n        return s[longest_palindrome_start: longest_palindrome_start + longest_palindrome_len]\\n```\\n\\n# Two pointers\\nThis approach takes O(n^2) time complexity, O(1) space complexity, where n is the length of `s`.\\n\\nFor each character `s[i]`, we get the first character to its right which isn\\'t equal to `s[i]`.\\nThen `s[i, right - 1]` inclusive are equal characters e.g. \"aaa\".\\nThen we make `left = i - 1`, while s[left] == s[right], s[left, right] inclusive is palindrome, and we keep extending both ends by `left -= 1, right += 1`.\\nFinally we update the tracked longest palindrome if needed.\\n\\n```\\nclass Solution:\\n    def longestPalindrome(self, s: str) -> str:\\n        n = len(s)\\n        longest_palindrome_start, longest_palindrome_len = 0, 1\\n\\n        for i in range(0, n):\\n            right = i\\n            while right < n and s[i] == s[right]:\\n                right += 1\\n            # s[i, right - 1] inclusive are equal characters e.g. \"aaa\"\\n            \\n            # while s[left] == s[right], s[left, right] inclusive is palindrome e.g. \"baaab\"\\n            left = i - 1\\n            while left >= 0 and right < n and s[left] == s[right]:\\n                left -= 1\\n                right += 1\\n            \\n            # s[left + 1, right - 1] inclusive is palindromic\\n            palindrome_len = right - left - 1\\n            if palindrome_len > longest_palindrome_len:\\n                longest_palindrome_len = palindrome_len\\n                longest_palindrome_start = left + 1\\n            \\n        return s[longest_palindrome_start: longest_palindrome_start + longest_palindrome_len]\\n         \\n```\\n",
                "solutionTags": [],
                "code": "```\\nfor start = end (e.g. \\'a\\'), state(start, end) is True\\nfor start + 1 = end (e.g. \\'aa\\'), state(start, end) is True if s[start] = s[end]\\nfor start + 2 = end (e.g. \\'aba\\'),  state(start, end) is True if s[start] = s[end] and state(start + 1, end - 1)\\nfor start + 3 = end (e.g. \\'abba\\'),  state(start, end) is True if s[start] = s[end] and state(start + 1, end - 1)\\n...\\n```\n```\\nclass Solution:\\n    def longestPalindrome(self, s: str) -> str:\\n        n = len(s)\\n        dp = [[False] * n for _ in range(n)]\\n        for i in range(n):\\n            dp[i][i] = True\\n        longest_palindrome_start, longest_palindrome_len = 0, 1\\n\\n        for end in range(0, n):\\n            for start in range(end - 1, -1, -1):\\n                # print(\\'start: %s, end: %s\\' % (start, end))\\n                if s[start] == s[end]:\\n                    if end - start == 1 or dp[start + 1][end - 1]:\\n                        dp[start][end] = True\\n                        palindrome_len = end - start + 1\\n                        if longest_palindrome_len < palindrome_len:\\n                            longest_palindrome_start = start\\n                            longest_palindrome_len = palindrome_len\\n        return s[longest_palindrome_start: longest_palindrome_start + longest_palindrome_len]\\n```\n```\\nclass Solution:\\n    def longestPalindrome(self, s: str) -> str:\\n        n = len(s)\\n        longest_palindrome_start, longest_palindrome_len = 0, 1\\n\\n        for i in range(0, n):\\n            right = i\\n            while right < n and s[i] == s[right]:\\n                right += 1\\n            # s[i, right - 1] inclusive are equal characters e.g. \"aaa\"\\n            \\n            # while s[left] == s[right], s[left, right] inclusive is palindrome e.g. \"baaab\"\\n            left = i - 1\\n            while left >= 0 and right < n and s[left] == s[right]:\\n                left -= 1\\n                right += 1\\n            \\n            # s[left + 1, right - 1] inclusive is palindromic\\n            palindrome_len = right - left - 1\\n            if palindrome_len > longest_palindrome_len:\\n                longest_palindrome_len = palindrome_len\\n                longest_palindrome_start = left + 1\\n            \\n        return s[longest_palindrome_start: longest_palindrome_start + longest_palindrome_len]\\n         \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2954,
                "title": "python-easy-to-understand-solution-with-comments-from-middle-to-two-ends",
                "content": "        \\n    def longestPalindrome(self, s):\\n        res = \"\"\\n        for i in xrange(len(s)):\\n            # odd case, like \"aba\"\\n            tmp = self.helper(s, i, i)\\n            if len(tmp) > len(res):\\n                res = tmp\\n            # even case, like \"abba\"\\n            tmp = self.helper(s, i, i+1)\\n            if len(tmp) > len(res):\\n                res = tmp\\n        return res\\n     \\n    # get the longest palindrome, l, r are the middle indexes   \\n    # from inner to outer\\n    def helper(self, s, l, r):\\n        while l >= 0 and r < len(s) and s[l] == s[r]:\\n            l -= 1; r += 1\\n        return s[l+1:r]",
                "solutionTags": [
                    "Python"
                ],
                "code": "        \\n    def longestPalindrome(self, s):\\n        res = \"\"\\n        for i in xrange(len(s)):\\n            # odd case, like \"aba\"\\n            tmp = self.helper(s, i, i)\\n            if len(tmp) > len(res):\\n                res = tmp\\n            # even case, like \"abba\"\\n            tmp = self.helper(s, i, i+1)\\n            if len(tmp) > len(res):\\n                res = tmp\\n        return res\\n     \\n    # get the longest palindrome, l, r are the middle indexes   \\n    # from inner to outer\\n    def helper(self, s, l, r):\\n        while l >= 0 and r < len(s) and s[l] == s[r]:\\n            l -= 1; r += 1\\n        return s[l+1:r]",
                "codeTag": "Python3"
            },
            {
                "id": 2921,
                "title": "share-my-java-solution-using-dynamic-programming",
                "content": "`dp(i, j)` represents whether `s(i ... j)` can form a palindromic substring, `dp(i, j)` is true when `s(i)` equals to `s(j)` and `s(i+1 ... j-1)` is a palindromic substring. When we found a palindrome, check if it's the longest one. Time complexity O(n^2).\\n\\n    public String longestPalindrome(String s) {\\n      int n = s.length();\\n      String res = null;\\n        \\n      boolean[][] dp = new boolean[n][n];\\n        \\n      for (int i = n - 1; i >= 0; i--) {\\n        for (int j = i; j < n; j++) {\\n          dp[i][j] = s.charAt(i) == s.charAt(j) && (j - i < 3 || dp[i + 1][j - 1]);\\n                \\n          if (dp[i][j] && (res == null || j - i + 1 > res.length())) {\\n            res = s.substring(i, j + 1);\\n          }\\n        }\\n      }\\n        \\n      return res;\\n    }",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "`dp(i, j)` represents whether `s(i ... j)` can form a palindromic substring, `dp(i, j)` is true when `s(i)` equals to `s(j)` and `s(i+1 ... j-1)` is a palindromic substring. When we found a palindrome, check if it's the longest one. Time complexity O(n^2).\\n\\n    public String longestPalindrome(String s) {\\n      int n = s.length();\\n      String res = null;\\n        \\n      boolean[][] dp = new boolean[n][n];\\n        \\n      for (int i = n - 1; i >= 0; i--) {\\n        for (int j = i; j < n; j++) {\\n          dp[i][j] = s.charAt(i) == s.charAt(j) && (j - i < 3 || dp[i + 1][j - 1]);\\n                \\n          if (dp[i][j] && (res == null || j - i + 1 > res.length())) {\\n            res = s.substring(i, j + 1);\\n          }\\n        }\\n      }\\n        \\n      return res;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 900639,
                "title": "python-solution-with-detailed-explanation-using-dp",
                "content": "####  Approach (implemented Dp rules)\\n* #####             Definition : the row and col in the dp table represent the slicing index on the string s  (inclusive)\\n* #####                 example s = \\'babad\\'  -- > dp[2][3] = s[2:3] = ba\\n#####             Steps : \\n* #####             Fill the diagonal with True, b/c every single character by itself is palindrom \\n* #####             Don\\'t traverse in the bottom part of the diagonal \\n\\t* #####                 Becuase, that represent reverse slicing (which is not valid)\\n#####             \\n* #####             Iterate backward starting from the most right bottom cell to top (only on the right side of the digonal) \\n\\t* #####                 How ? \\n\\t\\t* ##### \\t\\tStart itertating backward for the outer loop (i) and for the inner loop (j) iterate forward starting from the index of outer loop ) : see the code (the for loops) \\n#####                 \\n* #####                 - Pick character from the input string based on the at i and j position, If the characters matches : you need to check two conditions\\n\\t* #####                     1. If the length of the sub_string is just one (a letter matching is good to be a palindrom)\\n\\t* #####                     2. But if the length of the sub_string is > 1 \\n\\t\\t* #####                         - You need to check if the inner sub_sting is also palindrom\\n\\t\\t* #####                             - How ?\\n\\t\\t\\t* #####                                 - You go to the left bottom corner and check if it is True \\n\\t\\t\\t* #####                                     - Left bottom corrner represent the inner sub_string of the current_sub_string \\n\\t\\t\\t\\t* #####                                         -Eg. if  dp[i][j]= cur_sub_string = \\'ababa\\' --> True because dp[i+1][j-1] is True\\n\\t\\t\\t\\t* #####                                                  dp[i+1][j-1] = \\'bab\\' = True\\n\\t\\t\\t\\t* #####                                          .Howerver if  dp[i][j]= cur_sub_string = \\'abaca\\'  --> False because  dp[i+1][j-1] is False\\n\\t\\t\\t\\t* #####                                                  dp[i+1][j-1] = \\'bac\\' = False  --> not palindrom \\n\\t\\t* #####                                                  \\n\\t\\t* #####                         If dp[i+1][j-1] == True:\\n\\t\\t\\t* #####                             Ok that means the current sub_string is also palindrom                      \\n\\t\\t* #####                             - Now compare the length of the current_palindrom sub_string with the prvious longest one and take the max\\n* #####                 - Else : the characters don\\'t match\\n\\t* #####                     Just pass\\n* #####             - Finally return the maximum number in the dp\\n* ##### If this solution/explanation helps you, don\\'t forget to upvote as appreciation\\n\\n```\\ndef longestPalindrome(self, s):\\n        longest_palindrom = \\'\\'\\n        dp = [[0]*len(s) for _ in range(len(s))]\\n        #filling out the diagonal by 1\\n        for i in range(len(s)):\\n            dp[i][i] = True\\n            longest_palindrom = s[i]\\n\\t\\t\\t\\n        # filling the dp table\\n        for i in range(len(s)-1,-1,-1):\\n\\t\\t\\t\\t# j starts from the i location : to only work on the upper side of the diagonal \\n            for j in range(i+1,len(s)):  \\n                if s[i] == s[j]:  #if the chars mathces\\n                    # if len slicied sub_string is just one letter if the characters are equal, we can say they are palindomr dp[i][j] =True \\n                    #if the slicied sub_string is longer than 1, then we should check if the inner string is also palindrom (check dp[i+1][j-1] is True)\\n                    if j-i ==1 or dp[i+1][j-1] is True:\\n                        dp[i][j] = True\\n                        # we also need to keep track of the maximum palindrom sequence \\n                        if len(longest_palindrom) < len(s[i:j+1]):\\n                            longest_palindrom = s[i:j+1]\\n                \\n        return longest_palindrom\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Dynamic Programming"
                ],
                "code": "```\\ndef longestPalindrome(self, s):\\n        longest_palindrom = \\'\\'\\n        dp = [[0]*len(s) for _ in range(len(s))]\\n        #filling out the diagonal by 1\\n        for i in range(len(s)):\\n            dp[i][i] = True\\n            longest_palindrom = s[i]\\n\\t\\t\\t\\n        # filling the dp table\\n        for i in range(len(s)-1,-1,-1):\\n\\t\\t\\t\\t# j starts from the i location : to only work on the upper side of the diagonal \\n            for j in range(i+1,len(s)):  \\n                if s[i] == s[j]:  #if the chars mathces\\n                    # if len slicied sub_string is just one letter if the characters are equal, we can say they are palindomr dp[i][j] =True \\n                    #if the slicied sub_string is longer than 1, then we should check if the inner string is also palindrom (check dp[i+1][j-1] is True)\\n                    if j-i ==1 or dp[i+1][j-1] is True:\\n                        dp[i][j] = True\\n                        # we also need to keep track of the maximum palindrom sequence \\n                        if len(longest_palindrom) < len(s[i:j+1]):\\n                            longest_palindrom = s[i:j+1]\\n                \\n        return longest_palindrom\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3202985,
                "title": "best-c-3-solution-dp-string-brute-force-optimize-one-stop-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nWe can solve this question using Multiple Approaches. (Here I have explained all the possible solutions of this problem).\\n\\n1. Solved using string(Three Nested Loop). Brute Force Approach.\\n2. Solved using string(TwoNested Loop). Brute Force Approach.\\n3. Solved using Dynamic Programming Approach(tabulation). Optimized Approach.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nWe can easily understand the All the approaches by seeing the code which is easy to understand with comments.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nTime complexity is given in code comment.\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nSpace complexity is given in code comment.\\n\\n# Code\\n```\\n/*\\n\\n    Time Complexity : O(N^3), Here three nested loop creates the time complexity. Where N is the size of the\\n    string(s).\\n\\n    Space Complexity : O(1), Constant space.\\n\\n    Solved using string(Three Nested Loop). Brute Force Approach.\\n\\n    Note : this may give TLE.\\n\\n*/\\n\\n\\n/***************************************** Approach 1 *****************************************/\\n\\nclass Solution {\\nprivate: \\n    bool check(string &s, int i, int j){\\n        while(i<j){\\n            if(s[i] != s[j]){\\n                return false;\\n            }\\n            i++;\\n            j--;\\n        }\\n        return true;\\n    }            \\npublic:\\n    string longestPalindrome(string s) {\\n        int n = s.size();\\n        int starting_index = 0;\\n        int max_len = 0;\\n        for(int i=0; i<n; i++){\\n            for(int j=i; j<n; j++){\\n                if(check(s, i, j)){\\n                    if(j-i+1 > max_len){\\n                        max_len = j-i+1;\\n                        starting_index = i;\\n                    }\\n                }\\n            }\\n        }\\n        return s.substr(starting_index, max_len);\\n    }\\n}; \\n\\n\\n\\n\\n\\n\\n/*\\n\\n    Time Complexity : O(N^2), Here Two nested loop creates the time complexity. Where N is the size of the\\n    string(s).\\n\\n    Space Complexity : O(N^2*N), vector(substring) space.\\n\\n    Solved using string(TwoNested Loop). Brute Force Approach.\\n\\n    Note : this may give TLE.\\n\\n*/\\n\\n\\n/***************************************** Approach 2 *****************************************/\\n\\nclass Solution { \\nprivate: \\n    bool check(string &s, int i, int j){\\n        while(i<j){\\n            if(s[i] != s[j]){\\n                return false;\\n            }\\n            i++;\\n            j--;\\n        }\\n        return true;\\n    }\\npublic:\\n    string longestPalindrome(string s) {\\n        int n = s.size();\\n        vector<string> substring;\\n        for(int i=0; i<n; i++){\\n            string temp = \"\";\\n            for(int j=i; j<n; j++){\\n                temp += s[j];\\n                substring.push_back(temp);\\n            }\\n        }\\n        int max_len = 0;\\n        string finalans = substring[0];\\n        int m = substring.size();\\n        for(int i=0; i<m; i++){\\n            int s = substring[i].size();\\n            if(check(substring[i], 0, s-1)){\\n                if(s > max_len){\\n                    max_len = s;\\n                    finalans = substring[i];\\n                }\\n            }       \\n        }\\n        return finalans;\\n    }\\n};\\n\\n\\n\\n\\n\\n\\n/*\\n\\n    Time Complexity : O(N^2), The time complexity of the above code is O(N^2) because we are traversing over all\\n    the substrings and then checking each substring if it is a palindrome or not. There are N^2 substrings and\\n    checking a substring takes O(1) time, so total time complexity is O(N^2).\\n\\n    Space Complexity : (N^2), The space complexity of the above code is O(N^2) because we are using the dp array\\n    in which we are storing whether a substring is a palindrome or not.\\n\\n    Solved using Dynamic Programming Approach(tabulation). Optimized Approach.\\n\\n*/\\n\\n\\n/***************************************** Approach 3 *****************************************/\\n\\nclass Solution {\\nprivate: \\n    bool solve(vector<vector<bool>> &dp, int i, int j, string &s){\\n        if(i == j){\\n            return dp[i][j] = true;\\n        }\\n        if(j-i == 1){\\n            if(s[i] == s[j]){\\n                return dp[i][j] = true;\\n            }\\n            else{\\n                return dp[i][j] = false;\\n            }\\n        }\\n        if(s[i] == s[j] && dp[i+1][j-1] == true){\\n            return dp[i][j] = true;\\n        } else {\\n            return dp[i][j] = false;\\n        }\\n    }\\npublic:\\n    string longestPalindrome(string s) {\\n        int n = s.size();\\n        int startIndex = 0; int maxlen = 0;\\n        vector<vector<bool>> dp(n, vector<bool>(n, false));\\n        for(int g=0; g<n; g++){\\n            for(int i=0, j=g; j<n; i++, j++){\\n                solve(dp, i, j, s);\\n                if(dp[i][j] == true){\\n                    if(j-i+1 > maxlen){\\n                        startIndex = i;\\n                        maxlen = j-i+1;\\n                    }\\n                }\\n            }\\n        }\\n        return s.substr(startIndex, maxlen);\\n    }\\n};\\n\\n```\\n\\n***IF YOU LIKE THE SOLUTION THEN PLEASE UPVOTE MY SOLUTION BECAUSE IT GIVES ME MOTIVATION TO REGULARLY POST THE SOLUTION.***\\n\\n![WhatsApp Image 2023-02-10 at 19.01.02.jpeg](https://assets.leetcode.com/users/images/0a95fea4-64f4-4502-82aa-41db6d77c05c_1676054939.8270252.jpeg)",
                "solutionTags": [
                    "C++",
                    "String",
                    "Dynamic Programming"
                ],
                "code": "```\\n/*\\n\\n    Time Complexity : O(N^3), Here three nested loop creates the time complexity. Where N is the size of the\\n    string(s).\\n\\n    Space Complexity : O(1), Constant space.\\n\\n    Solved using string(Three Nested Loop). Brute Force Approach.\\n\\n    Note : this may give TLE.\\n\\n*/\\n\\n\\n/***************************************** Approach 1 *****************************************/\\n\\nclass Solution {\\nprivate: \\n    bool check(string &s, int i, int j){\\n        while(i<j){\\n            if(s[i] != s[j]){\\n                return false;\\n            }\\n            i++;\\n            j--;\\n        }\\n        return true;\\n    }            \\npublic:\\n    string longestPalindrome(string s) {\\n        int n = s.size();\\n        int starting_index = 0;\\n        int max_len = 0;\\n        for(int i=0; i<n; i++){\\n            for(int j=i; j<n; j++){\\n                if(check(s, i, j)){\\n                    if(j-i+1 > max_len){\\n                        max_len = j-i+1;\\n                        starting_index = i;\\n                    }\\n                }\\n            }\\n        }\\n        return s.substr(starting_index, max_len);\\n    }\\n}; \\n\\n\\n\\n\\n\\n\\n/*\\n\\n    Time Complexity : O(N^2), Here Two nested loop creates the time complexity. Where N is the size of the\\n    string(s).\\n\\n    Space Complexity : O(N^2*N), vector(substring) space.\\n\\n    Solved using string(TwoNested Loop). Brute Force Approach.\\n\\n    Note : this may give TLE.\\n\\n*/\\n\\n\\n/***************************************** Approach 2 *****************************************/\\n\\nclass Solution { \\nprivate: \\n    bool check(string &s, int i, int j){\\n        while(i<j){\\n            if(s[i] != s[j]){\\n                return false;\\n            }\\n            i++;\\n            j--;\\n        }\\n        return true;\\n    }\\npublic:\\n    string longestPalindrome(string s) {\\n        int n = s.size();\\n        vector<string> substring;\\n        for(int i=0; i<n; i++){\\n            string temp = \"\";\\n            for(int j=i; j<n; j++){\\n                temp += s[j];\\n                substring.push_back(temp);\\n            }\\n        }\\n        int max_len = 0;\\n        string finalans = substring[0];\\n        int m = substring.size();\\n        for(int i=0; i<m; i++){\\n            int s = substring[i].size();\\n            if(check(substring[i], 0, s-1)){\\n                if(s > max_len){\\n                    max_len = s;\\n                    finalans = substring[i];\\n                }\\n            }       \\n        }\\n        return finalans;\\n    }\\n};\\n\\n\\n\\n\\n\\n\\n/*\\n\\n    Time Complexity : O(N^2), The time complexity of the above code is O(N^2) because we are traversing over all\\n    the substrings and then checking each substring if it is a palindrome or not. There are N^2 substrings and\\n    checking a substring takes O(1) time, so total time complexity is O(N^2).\\n\\n    Space Complexity : (N^2), The space complexity of the above code is O(N^2) because we are using the dp array\\n    in which we are storing whether a substring is a palindrome or not.\\n\\n    Solved using Dynamic Programming Approach(tabulation). Optimized Approach.\\n\\n*/\\n\\n\\n/***************************************** Approach 3 *****************************************/\\n\\nclass Solution {\\nprivate: \\n    bool solve(vector<vector<bool>> &dp, int i, int j, string &s){\\n        if(i == j){\\n            return dp[i][j] = true;\\n        }\\n        if(j-i == 1){\\n            if(s[i] == s[j]){\\n                return dp[i][j] = true;\\n            }\\n            else{\\n                return dp[i][j] = false;\\n            }\\n        }\\n        if(s[i] == s[j] && dp[i+1][j-1] == true){\\n            return dp[i][j] = true;\\n        } else {\\n            return dp[i][j] = false;\\n        }\\n    }\\npublic:\\n    string longestPalindrome(string s) {\\n        int n = s.size();\\n        int startIndex = 0; int maxlen = 0;\\n        vector<vector<bool>> dp(n, vector<bool>(n, false));\\n        for(int g=0; g<n; g++){\\n            for(int i=0, j=g; j<n; i++, j++){\\n                solve(dp, i, j, s);\\n                if(dp[i][j] == true){\\n                    if(j-i+1 > maxlen){\\n                        startIndex = i;\\n                        maxlen = j-i+1;\\n                    }\\n                }\\n            }\\n        }\\n        return s.substr(startIndex, maxlen);\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 844586,
                "title": "very-easy-to-understand-well-commented-2-approaches-thinking-process",
                "content": "**Subscribe to my youtube channel for tech related content:** [here](https://www.youtube.com/c/VishalRajput_1)\\n\\n```\\n// https://leetcode.com/problems/longest-palindromic-substring/\\n\\n/*\\nSolution 1: Brute Force Approach (Give TLE)\\n\\nGenerate all substring and check it is palindrome or not.\\nIf it is palindrome then check it is longest or not.\\n\\nTime Complexity - O(N^3),  O(N^2) to generate all substring and O(N) to check it is palindrome or not.\\nSpace complexity - O(1).\\n*/\\n\\nclass Solution\\n{\\npublic:\\n    bool isPalindrome(string s)\\n    {\\n        int i = 0, j = s.size() - 1;\\n\\n        while (i < j)\\n        {\\n            if (s[i++] != s[j--])\\n                return false;\\n        }\\n        return true;\\n    }\\n\\n    string longestPalindrome(string s)\\n    {\\n        int n = s.size();\\n        if (n == 0)\\n            return \"\";\\n\\n        if (n == 1)\\n            return s;\\n\\n        string result = \"\";\\n        for (int i = 0; i < n - 1; i++)\\n        {\\n            for (int j = 1; j <= n - i; j++)\\n            {\\n                if (isPalindrome(s.substr(i, j)))\\n                {\\n                    if (result.size() < j)\\n                        result = s.substr(i, j);\\n                }\\n            }\\n        }\\n        return result;\\n    }\\n};\\n\\n/*\\nAbove Solution Give TLE....\\n\\nHow Can we optimise our code?\\n\\nGot it in above solution, we do unnecessary recompution while validating palindomes.\\nFor example : if we know string \"aba\" is palindrome then \"cabac\" must be palindrome as left and right are equal.\\n\\nSolution 2: Using DP\\n\\nP(i, j) == P(i+1, j-1) && s[i] == s[j];\\n\\nBase cases :\\n\\n//One character\\nP(i, i) = true;\\n\\n//Two character\\nP(i, i+1) = s[i] == s[i+1];\\n\\nTime Complexity - O(N^2), Space Complexity - O(N^2) (caching all substring)\\n*/\\n\\nclass Solution\\n{\\npublic:\\n    string longestPalindrome(string s)\\n    {\\n        int n = s.size();\\n        if (n == 0)\\n            return \"\";\\n\\n        // dp[i][j] will be \\'true\\' if the string from index i to j is a palindrome.\\n        bool dp[n][n];\\n\\n        //Initialize with false\\n\\n        memset(dp, 0, sizeof(dp));\\n\\n        //Every Single character is palindrome\\n        for (int i = 0; i < n; i++)\\n            dp[i][i] = true;\\n\\n        string ans = \"\";\\n        ans += s[0];\\n\\n        for (int i = n - 1; i >= 0; i--)\\n        {\\n            for (int j = i + 1; j < n; j++)\\n            {\\n                if (s[i] == s[j])\\n                {\\n                    //If it is of two character OR if its susbtring is palindrome.\\n                    if (j - i == 1 || dp[i + 1][j - 1])\\n                    {\\n                        //Then it will also a palindrome substring\\n                        dp[i][j] = true;\\n\\n                        //Check for Longest Palindrome substring\\n                        if (ans.size() < j - i + 1)\\n                            ans = s.substr(i, j - i + 1);\\n                    }\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```\\n\\n**If you like the solution. Please Upvote :)**",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\n// https://leetcode.com/problems/longest-palindromic-substring/\\n\\n/*\\nSolution 1: Brute Force Approach (Give TLE)\\n\\nGenerate all substring and check it is palindrome or not.\\nIf it is palindrome then check it is longest or not.\\n\\nTime Complexity - O(N^3),  O(N^2) to generate all substring and O(N) to check it is palindrome or not.\\nSpace complexity - O(1).\\n*/\\n\\nclass Solution\\n{\\npublic:\\n    bool isPalindrome(string s)\\n    {\\n        int i = 0, j = s.size() - 1;\\n\\n        while (i < j)\\n        {\\n            if (s[i++] != s[j--])\\n                return false;\\n        }\\n        return true;\\n    }\\n\\n    string longestPalindrome(string s)\\n    {\\n        int n = s.size();\\n        if (n == 0)\\n            return \"\";\\n\\n        if (n == 1)\\n            return s;\\n\\n        string result = \"\";\\n        for (int i = 0; i < n - 1; i++)\\n        {\\n            for (int j = 1; j <= n - i; j++)\\n            {\\n                if (isPalindrome(s.substr(i, j)))\\n                {\\n                    if (result.size() < j)\\n                        result = s.substr(i, j);\\n                }\\n            }\\n        }\\n        return result;\\n    }\\n};\\n\\n/*\\nAbove Solution Give TLE....\\n\\nHow Can we optimise our code?\\n\\nGot it in above solution, we do unnecessary recompution while validating palindomes.\\nFor example : if we know string \"aba\" is palindrome then \"cabac\" must be palindrome as left and right are equal.\\n\\nSolution 2: Using DP\\n\\nP(i, j) == P(i+1, j-1) && s[i] == s[j];\\n\\nBase cases :\\n\\n//One character\\nP(i, i) = true;\\n\\n//Two character\\nP(i, i+1) = s[i] == s[i+1];\\n\\nTime Complexity - O(N^2), Space Complexity - O(N^2) (caching all substring)\\n*/\\n\\nclass Solution\\n{\\npublic:\\n    string longestPalindrome(string s)\\n    {\\n        int n = s.size();\\n        if (n == 0)\\n            return \"\";\\n\\n        // dp[i][j] will be \\'true\\' if the string from index i to j is a palindrome.\\n        bool dp[n][n];\\n\\n        //Initialize with false\\n\\n        memset(dp, 0, sizeof(dp));\\n\\n        //Every Single character is palindrome\\n        for (int i = 0; i < n; i++)\\n            dp[i][i] = true;\\n\\n        string ans = \"\";\\n        ans += s[0];\\n\\n        for (int i = n - 1; i >= 0; i--)\\n        {\\n            for (int j = i + 1; j < n; j++)\\n            {\\n                if (s[i] == s[j])\\n                {\\n                    //If it is of two character OR if its susbtring is palindrome.\\n                    if (j - i == 1 || dp[i + 1][j - 1])\\n                    {\\n                        //Then it will also a palindrome substring\\n                        dp[i][j] = true;\\n\\n                        //Check for Longest Palindrome substring\\n                        if (ans.size() < j - i + 1)\\n                            ans = s.substr(i, j - i + 1);\\n                    }\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2923,
                "title": "simple-c-solution-8ms-13-lines",
                "content": "    string longestPalindrome(string s) {\\n        if (s.empty()) return \"\";\\n        if (s.size() == 1) return s;\\n        int min_start = 0, max_len = 1;\\n        for (int i = 0; i < s.size();) {\\n          if (s.size() - i <= max_len / 2) break;\\n          int j = i, k = i;\\n          while (k < s.size()-1 && s[k+1] == s[k]) ++k; // Skip duplicate characters.\\n          i = k+1;\\n          while (k < s.size()-1 && j > 0 && s[k + 1] == s[j - 1]) { ++k; --j; } // Expand.\\n          int new_len = k - j + 1;\\n          if (new_len > max_len) { min_start = j; max_len = new_len; }\\n        }\\n        return s.substr(min_start, max_len);\\n    }",
                "solutionTags": [],
                "code": "    string longestPalindrome(string s) {\\n        if (s.empty()) return \"\";\\n        if (s.size() == 1) return s;\\n        int min_start = 0, max_len = 1;\\n        for (int i = 0; i < s.size();) {\\n          if (s.size() - i <= max_len / 2) break;\\n          int j = i, k = i;\\n          while (k < s.size()-1 && s[k+1] == s[k]) ++k; // Skip duplicate characters.\\n          i = k+1;\\n          while (k < s.size()-1 && j > 0 && s[k + 1] == s[j - 1]) { ++k; --j; } // Expand.\\n          int new_len = k - j + 1;\\n          if (new_len > max_len) { min_start = j; max_len = new_len; }\\n        }\\n        return s.substr(min_start, max_len);\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 3401644,
                "title": "detailed-recursive-explaination-with-pictures-in-c-java-python-dp-two-pointers",
                "content": "# Approach\\n[![LPS0.png](https://assets.leetcode.com/users/images/8e1ed821-5202-4801-9654-396e22b3f4ff_1681148824.1879745.png)]()\\n\\n\\n\\n\\n\\n>The only tricky thing is that you have to be sure the right substring is returned in `expand()`. The loop ends only after expanding the range by 1 on both sides, so you have to remove those in the final returned string.\\n\\n>Here we basically choose each centre and try expanding from each and every specific node thus we call expand functionas `expand(i,i)` and `expand(i,i+1)` and later we apply two pointers on each node to find the longest palindrome \\n\\n\\n\\n\\n\\n\\n![LPS.png](https://assets.leetcode.com/users/images/775649b0-d6f7-4648-9d87-24d2f5dc4ccf_1681148838.335889.png)\\n\\n\\n\\n\\n\\n> In fact, we could solve it in $$O(n^2)$$ time using only constant space.\\n\\nWe observe that a palindrome mirrors around its center. Therefore, a palindrome can be expanded from its center, and there are only $$2n\\u22121$$  such centers.\\n\\nYou might be asking why there are $$2n - 1$$ but not $$n$$ centers? The reason is the center of a palindrome can be in between two letters. Such palindromes have even number of letters (such as \"abba\") and its center are between the two \\'b\\'s.\\n\\n\\n---\\n\\n# Code\\n\\n```C++ []\\nclass Solution {\\npublic:\\n    string ans = \"\";\\n    void expand(string &s , int left ,int right)\\n    {\\n        while(left >= 0 &&  right < s.size())\\n        {\\n            if(s[left] != s[right])\\n                break;\\n            left--,right++;\\n        }\\n        if(ans.size() < right - left )\\n            ans = s.substr(left + 1 , right - left - 1);\\n    }\\n    string longestPalindrome(string s) {\\n        for(int i = 0 ; i < s.size() ; i++)\\n        {\\n            expand(s , i , i);\\n            expand(s , i , i+1);\\n        }\\n        return ans;\\n    }\\n};\\n```\\n```java []\\nclass Solution {\\n    int maxLen = 0;\\n    int lo = 0;\\n    public String longestPalindrome(String s) {\\n        char[] input = s.toCharArray();\\n        if(s.length() < 2) {\\n            return s;\\n        }\\n        \\n        for(int i = 0; i<input.length; i++) {\\n            expandPalindrome(input, i, i);\\n            expandPalindrome(input, i, i+1);\\n        }\\n        return s.substring(lo, lo+maxLen);\\n    }\\n    \\n    public void expandPalindrome(char[] s, int j, int k) {\\n        while(j >= 0 && k < s.length && s[j] == s[k]) {\\n            j--;\\n            k++;\\n        }\\n        if(maxLen < k - j - 1) {\\n            maxLen = k - j - 1;\\n            lo = j+1;\\n        }\\n    }\\n}\\n```\\n```python []\\nclass Solution:\\n    def longestPalindrome(self, s: str) -> str:\\n        ans=\\'\\'\\n        for i in range(len(s)):\\n            ans=max(ans,expand(s,i,i), expand(s,i,i+1), key=len)\\n        return ans\\n            \\ndef expand(s,i,j):\\n    while i>=0 and j<len(s) and s[i]==s[j]:\\n        i-=1\\n        j+=1\\n    return s[i+1:j]\\n```\\n```c []\\nint maxVal(int a, int b) {\\n    return a > b ? a : b;\\n}\\n\\nint extend(char *s, int start, int end) {\\n    int len = strlen(s);\\n    for(; start >= 0 && end < len; start--, end++) {\\n        if(*(s + start) != *(s + end))\\n            break;\\n    }\\n    return end - start - 1;\\n}\\n\\nchar * longestPalindrome(char * s){\\n    int max = 0, idx = 0, len = strlen(s);\\n    for(int i = 0; i < len; i++) {\\n        int len1 = extend(s, i, i);       /* For even string */\\n        int len2 = extend(s, i, i + 1);   /* For odd string  */\\n        if (max < maxVal(len1, len2)) {\\n            idx = (len1 > len2) ? (i - len1 / 2) : (i - len2 / 2 + 1);\\n            max = maxVal(len1, len2);\\n        }\\n    }\\n    char *res = malloc((max+1) *sizeof(char));\\n    memcpy(res, &s[idx], max);\\n    res[max] = \\'\\\\0\\';\\n    return res;\\n}\\n```\\n---\\n# Complexity\\n> **Time Complexity:** $$O(n^2)$$ as there is two recursion calls which are applied as two pointers so here Complexity would be$$ O(n^2).$$\\n\\n> **Space Complexity:** $$O(n)$$ which is nothing but the storage consumed in this process.\\n\\n---\\n**IF YOU LIKE THE SOLUTION THEN PLEASE UPVOTE MY SOLUTION BECAUSE IT GIVES ME MOTIVATION TO REGULARLY POST THE SOLUTION.**\\n\\n![UPVOTE.jpg](https://assets.leetcode.com/users/images/10486881-da0f-461b-911c-7ddd2e060d99_1681148844.162226.jpeg)\\n\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "Dynamic Programming"
                ],
                "code": "```C++ []\\nclass Solution {\\npublic:\\n    string ans = \"\";\\n    void expand(string &s , int left ,int right)\\n    {\\n        while(left >= 0 &&  right < s.size())\\n        {\\n            if(s[left] != s[right])\\n                break;\\n            left--,right++;\\n        }\\n        if(ans.size() < right - left )\\n            ans = s.substr(left + 1 , right - left - 1);\\n    }\\n    string longestPalindrome(string s) {\\n        for(int i = 0 ; i < s.size() ; i++)\\n        {\\n            expand(s , i , i);\\n            expand(s , i , i+1);\\n        }\\n        return ans;\\n    }\\n};\\n```\n```java []\\nclass Solution {\\n    int maxLen = 0;\\n    int lo = 0;\\n    public String longestPalindrome(String s) {\\n        char[] input = s.toCharArray();\\n        if(s.length() < 2) {\\n            return s;\\n        }\\n        \\n        for(int i = 0; i<input.length; i++) {\\n            expandPalindrome(input, i, i);\\n            expandPalindrome(input, i, i+1);\\n        }\\n        return s.substring(lo, lo+maxLen);\\n    }\\n    \\n    public void expandPalindrome(char[] s, int j, int k) {\\n        while(j >= 0 && k < s.length && s[j] == s[k]) {\\n            j--;\\n            k++;\\n        }\\n        if(maxLen < k - j - 1) {\\n            maxLen = k - j - 1;\\n            lo = j+1;\\n        }\\n    }\\n}\\n```\n```python []\\nclass Solution:\\n    def longestPalindrome(self, s: str) -> str:\\n        ans=\\'\\'\\n        for i in range(len(s)):\\n            ans=max(ans,expand(s,i,i), expand(s,i,i+1), key=len)\\n        return ans\\n            \\ndef expand(s,i,j):\\n    while i>=0 and j<len(s) and s[i]==s[j]:\\n        i-=1\\n        j+=1\\n    return s[i+1:j]\\n```\n```c []\\nint maxVal(int a, int b) {\\n    return a > b ? a : b;\\n}\\n\\nint extend(char *s, int start, int end) {\\n    int len = strlen(s);\\n    for(; start >= 0 && end < len; start--, end++) {\\n        if(*(s + start) != *(s + end))\\n            break;\\n    }\\n    return end - start - 1;\\n}\\n\\nchar * longestPalindrome(char * s){\\n    int max = 0, idx = 0, len = strlen(s);\\n    for(int i = 0; i < len; i++) {\\n        int len1 = extend(s, i, i);       /* For even string */\\n        int len2 = extend(s, i, i + 1);   /* For odd string  */\\n        if (max < maxVal(len1, len2)) {\\n            idx = (len1 > len2) ? (i - len1 / 2) : (i - len2 / 2 + 1);\\n            max = maxVal(len1, len2);\\n        }\\n    }\\n    char *res = malloc((max+1) *sizeof(char));\\n    memcpy(res, &s[idx], max);\\n    res[max] = \\'\\\\0\\';\\n    return res;\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 147548,
                "title": "direct-c-dp",
                "content": "My code is based on the solution Approach3.\\n\\nFirst initialize a matrix P, which is used to store if the substring is palindromic. Now we should fill the block of \"S(i) = S(i)\" and \"S(i) = S(i+1)\", the basic case that **we can\\'t find any substring in it**. Then with this matrix, we can decide if a string is palindromic by if **its substring is palindromic** and if **its start letter equals end letter**.\\n\\nThe image below is a matrix for string \"abbc\". For example, start with the first \"b\" and end with \"c\" tells if substring \"bbc\" is palindromic. What we need to do next is filling the \"??\" block, only half of the matrix is used.\\n![image](https://s3-lc-upload.s3.amazonaws.com/users/rongxiantian/image_1531322500.png)\\n\\nAfter initialization, we can decide if a string is palindromic by its substring and newly added letters, shown below.\\n![image](https://s3-lc-upload.s3.amazonaws.com/users/rongxiantian/image_1531321812.png)\\nIf we want to decide the block pointed by the arrow(\\\\\"abb\\\\\"), we should look up [b,b], which is substring \"b\", and see if (\"a\"==\"b\"). As shown, \"a\"!=\"b\", so \"abb\" is not palindromic. \\n\\nAfter that, it seems like this:\\n![image](https://s3-lc-upload.s3.amazonaws.com/users/rongxiantian/image_1531322028.png)\\n\\nLast, we have got this matrix, but we still need to find which is the longest palindromic substring.\\nMy method is only traversing it, return the longest substring. So the result in this example is \"bb\".\\n```\\nclass Solution {\\npublic:\\n    string longestPalindrome(string s) {\\n        if(s.size()==0) return \"\";\\n        int i = 0, j = 0;\\n        int n = s.size();\\n        //initialize P[n][n], we only need half of P, and initialize it like: (e.g. : s=\"abbc\")\\n        bool P[n][n]={false};\\n        for(int x = 0;x<n;x++){\\n            P[x][x]=true;\\n            if(x==n-1) break;\\n            P[x][x+1] = (s[x]==s[x+1]);\\n        }\\n        //dp \\n        for(int i = n-3; i>=0; --i){\\n            for(int j = i+2;j<n; ++j){\\n                P[i][j] = (P[i+1][j-1] && s[i]==s[j]);     \\n            }\\n        }\\n        //get maxstr result\\n        int max = 0;\\n        string maxstr = \"\";\\n        for(int i=0;i<n;i++){\\n            for(int j=i;j<n;j++){\\n                if(P[i][j]==true and j-i+1>max){\\n                    max = j-i+1;\\n                    maxstr = s.substr(i,j-i+1);\\n                }\\n            }\\n        }\\n        return maxstr;\\n    }\\n};```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    string longestPalindrome(string s) {\\n        if(s.size()==0) return \"\";\\n        int i = 0, j = 0;\\n        int n = s.size();\\n        //initialize P[n][n], we only need half of P, and initialize it like: (e.g. : s=\"abbc\")\\n        bool P[n][n]={false};\\n        for(int x = 0;x<n;x++){\\n            P[x][x]=true;\\n            if(x==n-1) break;\\n            P[x][x+1] = (s[x]==s[x+1]);\\n        }\\n        //dp \\n        for(int i = n-3; i>=0; --i){\\n            for(int j = i+2;j<n; ++j){\\n                P[i][j] = (P[i+1][j-1] && s[i]==s[j]);     \\n            }\\n        }\\n        //get maxstr result\\n        int max = 0;\\n        string maxstr = \"\";\\n        for(int i=0;i<n;i++){\\n            for(int j=i;j<n;j++){\\n                if(P[i][j]==true and j-i+1>max){\\n                    max = j-i+1;\\n                    maxstr = s.substr(i,j-i+1);\\n                }\\n            }\\n        }\\n        return maxstr;\\n    }\\n};```",
                "codeTag": "Java"
            },
            {
                "id": 474664,
                "title": "commented-clean-python-dp-solution",
                "content": "```\\nclass Solution:\\n    def longestPalindrome(self, s: str) -> str:\\n        \\n        n = len(s)\\n        # Form a bottom-up dp 2d array\\n        # dp[i][j] will be \\'true\\' if the string from index i to j is a palindrome. \\n        dp = [[False] * n  for _ in range(n)]\\n        \\n        ans = \\'\\'\\n        # every string with one character is a palindrome\\n        for i in range(n):\\n            dp[i][i] = True\\n            ans = s[i]\\n            \\n        maxLen = 1\\n        for start in range(n-1, -1, -1):\\n            for end in range(start+1, n):             \\n\\t\\t\\t\\t# palindrome condition\\n                if s[start] == s[end]:\\n                    # if it\\'s a two char. string or if the remaining string is a palindrome too\\n                    if end - start == 1 or dp[start+1][end-1]:\\n                        dp[start][end] = True\\n                        if maxLen < end - start + 1:\\n                            maxLen = end - start + 1\\n                            ans = s[start: end+ 1]\\n        \\n        return ans\\n```\\nIf this solution helps you, don\\'t forget to upvote it.",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution:\\n    def longestPalindrome(self, s: str) -> str:\\n        \\n        n = len(s)\\n        # Form a bottom-up dp 2d array\\n        # dp[i][j] will be \\'true\\' if the string from index i to j is a palindrome. \\n        dp = [[False] * n  for _ in range(n)]\\n        \\n        ans = \\'\\'\\n        # every string with one character is a palindrome\\n        for i in range(n):\\n            dp[i][i] = True\\n            ans = s[i]\\n            \\n        maxLen = 1\\n        for start in range(n-1, -1, -1):\\n            for end in range(start+1, n):             \\n\\t\\t\\t\\t# palindrome condition\\n                if s[start] == s[end]:\\n                    # if it\\'s a two char. string or if the remaining string is a palindrome too\\n                    if end - start == 1 or dp[start+1][end-1]:\\n                        dp[start][end] = True\\n                        if maxLen < end - start + 1:\\n                            maxLen = end - start + 1\\n                            ans = s[start: end+ 1]\\n        \\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2925,
                "title": "python-o-n-2-method-with-some-optimization-88ms",
                "content": "Basic thought is simple.  when you increase s by 1 character, you could only increase maxPalindromeLen by 1 or 2, and that new maxPalindrome includes this new character.  Proof: if on adding 1 character, maxPalindromeLen increased by 3 or more, say the new maxPalindromeLen  is Q, and the old maxPalindromeLen  is P, and Q>=P+3. Then it would mean, even without this new character, there would be a palindromic substring ending in the last character, whose length is at least Q-2. Since Q-2 would be >P, this contradicts the condition that P is the maxPalindromeLen without the additional character.\\n\\nSo, it becomes simple, you only need to scan from beginning to the end, adding one character at a time, keeping track of maxPalindromeLen, and for each added character, you check if the substrings ending with this new character, with length P+1 or P+2, are palindromes, and update accordingly.\\n\\nNow, this is O(n^2) as taking substrings and checking palindromicity seem O(n) time.  We can speed up it by realizing that strings are immutable, and there are memory slicing tricks will help to speed these operations up.  comparing string equality with \"==\" is O(1), and using slicing to substring and reverse is  \\u0336a\\u0336l\\u0336s\\u0336o\\u0336 \\u0336O\\u0336(\\u03361\\u0336)\\u0336 \\u0336(\\u0336n\\u0336o\\u0336t\\u0336 \\u0336t\\u0336o\\u0336t\\u0336a\\u0336l\\u0336l\\u0336y\\u0336 \\u0336s\\u0336u\\u0336r\\u0336e\\u0336 \\u0336a\\u0336b\\u0336o\\u0336u\\u0336t\\u0336 \\u0336t\\u0336h\\u0336e\\u0336 \\u0336s\\u0336l\\u0336i\\u0336c\\u0336i\\u0336n\\u0336g\\u0336 \\u0336t\\u0336h\\u0336o\\u0336u\\u0336g\\u0336h\\u0336.\\u0336 \\u0336 \\u0336I\\u0336 \\u0336t\\u0336h\\u0336i\\u0336n\\u0336k\\u0336 \\u0336i\\u0336t\\u0336 \\u0336i\\u0336s\\u0336 \\u0336O\\u0336(\\u03361\\u0336)\\u0336,\\u0336 \\u0336b\\u0336u\\u0336t\\u0336 \\u0336c\\u0336o\\u0336u\\u0336l\\u0336d\\u0336 \\u0336n\\u0336o\\u0336t\\u0336 \\u0336f\\u0336i\\u0336n\\u0336d\\u0336 \\u0336a\\u0336n\\u0336y\\u0336 \\u0336s\\u0336o\\u0336l\\u0336i\\u0336d\\u0336 \\u0336l\\u0336i\\u0336t\\u0336e\\u0336r\\u0336a\\u0336t\\u0336u\\u0336r\\u0336e\\u0336 \\u0336a\\u0336b\\u0336o\\u0336u\\u0336t\\u0336 \\u0336i\\u0336t\\u0336.\\u0336   O(n) (thanks to ChuntaoLu).  But as slicing is optimized by the interpreter's C code, it should run pretty fast.  I'm pretty new to Python.  Would appreciate you would give more insights or further optimization.\\n\\nThus, here is the O(n) method:\\n\\n\\tclass Solution:\\n\\t    # @return a string\\n\\t    def longestPalindrome(self, s):\\n\\t        if len(s)==0:\\n\\t        \\treturn 0\\n\\t        maxLen=1\\n\\t        start=0\\n\\t        for i in xrange(len(s)):\\n\\t        \\tif i-maxLen >=1 and s[i-maxLen-1:i+1]==s[i-maxLen-1:i+1][::-1]:\\n\\t        \\t\\tstart=i-maxLen-1\\n\\t        \\t\\tmaxLen+=2\\n\\t        \\t\\tcontinue\\n\\n\\t        \\tif i-maxLen >=0 and s[i-maxLen:i+1]==s[i-maxLen:i+1][::-1]:\\n\\t        \\t\\tstart=i-maxLen\\n\\t        \\t\\tmaxLen+=1\\n\\t        return s[start:start+maxLen]",
                "solutionTags": [],
                "code": "Basic thought is simple.  when you increase s by 1 character, you could only increase maxPalindromeLen by 1 or 2, and that new maxPalindrome includes this new character.  Proof: if on adding 1 character, maxPalindromeLen increased by 3 or more, say the new maxPalindromeLen  is Q, and the old maxPalindromeLen  is P, and Q>=P+3. Then it would mean, even without this new character, there would be a palindromic substring ending in the last character, whose length is at least Q-2. Since Q-2 would be >P, this contradicts the condition that P is the maxPalindromeLen without the additional character.\\n\\nSo, it becomes simple, you only need to scan from beginning to the end, adding one character at a time, keeping track of maxPalindromeLen, and for each added character, you check if the substrings ending with this new character, with length P+1 or P+2, are palindromes, and update accordingly.\\n\\nNow, this is O(n^2) as taking substrings and checking palindromicity seem O(n) time.  We can speed up it by realizing that strings are immutable, and there are memory slicing tricks will help to speed these operations up.  comparing string equality with \"==\" is O(1), and using slicing to substring and reverse is  \\u0336a\\u0336l\\u0336s\\u0336o\\u0336 \\u0336O\\u0336(\\u03361\\u0336)\\u0336 \\u0336(\\u0336n\\u0336o\\u0336t\\u0336 \\u0336t\\u0336o\\u0336t\\u0336a\\u0336l\\u0336l\\u0336y\\u0336 \\u0336s\\u0336u\\u0336r\\u0336e\\u0336 \\u0336a\\u0336b\\u0336o\\u0336u\\u0336t\\u0336 \\u0336t\\u0336h\\u0336e\\u0336 \\u0336s\\u0336l\\u0336i\\u0336c\\u0336i\\u0336n\\u0336g\\u0336 \\u0336t\\u0336h\\u0336o\\u0336u\\u0336g\\u0336h\\u0336.\\u0336 \\u0336 \\u0336I\\u0336 \\u0336t\\u0336h\\u0336i\\u0336n\\u0336k\\u0336 \\u0336i\\u0336t\\u0336 \\u0336i\\u0336s\\u0336 \\u0336O\\u0336(\\u03361\\u0336)\\u0336,\\u0336 \\u0336b\\u0336u\\u0336t\\u0336 \\u0336c\\u0336o\\u0336u\\u0336l\\u0336d\\u0336 \\u0336n\\u0336o\\u0336t\\u0336 \\u0336f\\u0336i\\u0336n\\u0336d\\u0336 \\u0336a\\u0336n\\u0336y\\u0336 \\u0336s\\u0336o\\u0336l\\u0336i\\u0336d\\u0336 \\u0336l\\u0336i\\u0336t\\u0336e\\u0336r\\u0336a\\u0336t\\u0336u\\u0336r\\u0336e\\u0336 \\u0336a\\u0336b\\u0336o\\u0336u\\u0336t\\u0336 \\u0336i\\u0336t\\u0336.\\u0336   O(n) (thanks to ChuntaoLu).  But as slicing is optimized by the interpreter's C code, it should run pretty fast.  I'm pretty new to Python.  Would appreciate you would give more insights or further optimization.\\n\\nThus, here is the O(n) method:\\n\\n\\tclass Solution:\\n\\t    # @return a string\\n\\t    def longestPalindrome(self, s):\\n\\t        if len(s)==0:\\n\\t        \\treturn 0\\n\\t        maxLen=1\\n\\t        start=0\\n\\t        for i in xrange(len(s)):\\n\\t        \\tif i-maxLen >=1 and s[i-maxLen-1:i+1]==s[i-maxLen-1:i+1][::-1]:\\n\\t        \\t\\tstart=i-maxLen-1\\n\\t        \\t\\tmaxLen+=2\\n\\t        \\t\\tcontinue\\n\\n\\t        \\tif i-maxLen >=0 and s[i-maxLen:i+1]==s[i-maxLen:i+1][::-1]:\\n\\t        \\t\\tstart=i-maxLen\\n\\t        \\t\\tmaxLen+=1\\n\\t        return s[start:start+maxLen]",
                "codeTag": "Java"
            },
            {
                "id": 1125024,
                "title": "detailed-analysis-and-explanation",
                "content": "I had trouble understanding this question, as I am not much good when it comes to DP, and also because no solution offered enough explanation for DP newbies, so here I am going to try my best to explain it in detail.\\n\\n**Question Interpretation:** To solve a question , we first have to understand it! \\nHere we are being asked to calculate longest substring which is a Palindrome(Palindrome is a string which is read same forwards and backwards), among all the Palindromes that exist!!\\n\\n**Intuition:** Now, we can solve this question in two ways that come at first glance:\\n* Use `Brute Force` : Check for every corresponding element in string the longest palindrome possible and do it till the end.\\n* `DP`: Since we are essentially looping over every element in `Brute Force`, maybe we can somehow use the result from our previous iteration to simplify the current one, right?? This gives us a nudge to look for a pattern and hence we go for DP.\\n\\n**Analysis:**\\nLets see both the approaches one by one !!!\\n\\n1.)`Brute Force:` Instead of directly going to code and finding a problem later, lets stop and think about the concept we intend to use here .\\n\\n*Concept:* We will go through **all** possible element in string and find the longest palindrome amongst them.\\n\\n*Review:* To calculate **all** the possible substrings in a string of length `n` ,number of combinations generated are:\\n`1+2+3+4+..........n`=`n(n-1)/2`. \\n`==>` To check all the substrings for Palindrome, we will have to go through **all the `n` characters**\\n`==>` **Total** Combinations: `n*n(n-1)/2`= `O(n^3)`\\n\\n*Conclusion:* Since the time complexity is `O(n^3)`, hence we will not discuss on this approach, and our energy would be better spent looking at `DP` solution .\\n\\n2.)`DP:` Instead of going through all the previous Palindromes again and again, how about we save them somewhere and calculate the new ones based on them, but how do we d that? Lets see it below \\n \\n*Concept:* To check a Palindrome of length ,say `l`,  we just have to check if \\ni.) `s[first character]==s[last character]`\\nii.) `s[first character+1, last charcter -1]` is a Palindrome\\n\\nFor example : say s=\" balab\"\\nNow, to check , if \"s\" is Palindrome or not, we just have to look at\\ni.) `s[first character]==s[last character]` -> b==b -> True\\nii.)`s[first character+1, last charcter -1]` is a Palindrome --> \"aba\" is a Palindrome??\\nTo check for \"aba\", a==a--> True , and \"b\" is a Palindrome(of length 1)\\n==> `s` is a Plaindrome\\n\\n*Review:* We will make a table `dp` containing if the string from `left` to `right` is a Pal. or not, and to do that, we will fill in the table with `1` or `0`.\\nLets look at an example of how the table looks like for `s:\"geeks\"`\\n![image](https://assets.leetcode.com/users/images/cccbc507-96ac-45d8-a3fb-9658fc007fc7_1616569419.1798341.png)\\n\\nFor `s:geeks:` \\n`dp[i][i]`=1, as single letters are always Palindromes\\n`dp[1][2]` : string from starting position 1 to ending position 2 are Pal. or not (since \"ee\" is, hence we fill the table with \"1\") \\nand likewise for others.\\n\\nThis reduces our time from `O(n^3)` to `O(n^2)` as we dont have to check every possible combination now, instead we can directly check the value being 1 or 0.\\n\\n**Code:**\\n```\\nclass Solution {\\npublic:\\n     string longestPalindrome(string s) \\n{   \\n    int len = s.size();\\n    int dp[len][len];\\n    memset(dp,0,sizeof(dp));\\n    int end=1;\\n    int start=0;\\n\\t\\n    for(int i=0;i<len;i++)\\n    {\\n        dp[i][i] = 1;\\n    }\\n    for(int i=0;i<len-1;i++)\\n    {\\n        if(s[i]==s[i+1])\\n        { dp[i][i+1]=1;start=i;end=2;}\\n    }\\n    \\n    for(int j=2;j<len;j++)\\n    {\\n        for(int i=0;i< len-j;i++)\\n        {  \\n            int left=i; //start point\\n            int right = i+j;  //ending point\\n            \\n            if(dp[left+1][right-1]==1 && s[left]==s[right]) \\n            {\\n                dp[left][right]=1; start=i; end=j+1; \\n            }        \\n        }\\n    }\\n   return s.substr(start, end);\\n}\\n};\\n```\\n\\nIf you liked this post, please **UPVOTE** \\nHappy coding :))",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n     string longestPalindrome(string s) \\n{   \\n    int len = s.size();\\n    int dp[len][len];\\n    memset(dp,0,sizeof(dp));\\n    int end=1;\\n    int start=0;\\n\\t\\n    for(int i=0;i<len;i++)\\n    {\\n        dp[i][i] = 1;\\n    }\\n    for(int i=0;i<len-1;i++)\\n    {\\n        if(s[i]==s[i+1])\\n        { dp[i][i+1]=1;start=i;end=2;}\\n    }\\n    \\n    for(int j=2;j<len;j++)\\n    {\\n        for(int i=0;i< len-j;i++)\\n        {  \\n            int left=i; //start point\\n            int right = i+j;  //ending point\\n            \\n            if(dp[left+1][right-1]==1 && s[left]==s[right]) \\n            {\\n                dp[left][right]=1; start=i; end=j+1; \\n            }        \\n        }\\n    }\\n   return s.substr(start, end);\\n}\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3060,
                "title": "ac-relatively-short-and-very-clear-java-solution",
                "content": "**Key idea, every time we move to right, we only need to consider whether using this new character as tail could produce new palindrome string of length (current length +1) or (current length +2)**\\n\\n    public class Solution {\\n        public String longestPalindrome(String s) {\\n            String res = \"\";\\n            int currLength = 0;\\n            for(int i=0;i<s.length();i++){\\n                if(isPalindrome(s,i-currLength-1,i)){\\n                    res = s.substring(i-currLength-1,i+1);\\n                    currLength = currLength+2;\\n                }\\n                else if(isPalindrome(s,i-currLength,i)){\\n                    res = s.substring(i-currLength,i+1);\\n                    currLength = currLength+1;\\n                }\\n            }\\n            return res;\\n        }\\n        \\n        public boolean isPalindrome(String s, int begin, int end){\\n            if(begin<0) return false;\\n            while(begin<end){\\n            \\tif(s.charAt(begin++)!=s.charAt(end--)) return false;\\n            }\\n            return true;\\n        }\\n    }\\n\\nFor friends who are confused about the key idea to check only new palindrome with length = current length +2 or +1, I add some more explanation here.\\n\\n    Example: \"xxxbcbxxxxxa\", (x is random character, not all x are equal) now we \\n              are dealing with the last character 'a'. The current longest palindrome\\n              is \"bcb\" with length 3.\\n    1. check \"xxxxa\" so if it is palindrome we could get a new palindrome of length 5.\\n    2. check \"xxxa\" so if it is palindrome we could get a new palindrome of length 4.\\n    3. do NOT check \"xxa\" or any shorter string since the length of the new string is \\n       no bigger than current longest length.\\n    4. do NOT check \"xxxxxa\" or any longer string because if \"xxxxxa\" is palindrome \\n       then \"xxxx\" got  from cutting off the head and tail is also palindrom. It has \\n       length > 3 which is impossible.'",
                "solutionTags": [],
                "code": "class Solution {\\n        public String longestPalindrome(String s) {\\n            String res = \"\";\\n            int currLength = 0;\\n            for(int i=0;i<s.length();i++){\\n                if(isPalindrome(s,i-currLength-1,i)){\\n                    res = s.substring(i-currLength-1,i+1);\\n                    currLength = currLength+2;\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 650496,
                "title": "all-approaches-code-in-java-including-manacher-s-algorithm-explanation",
                "content": "# Approach 1: Longest Common Substring\\nBased on dynamic programming.\\n```java\\nclass Solution {\\n    public String longestPalindrome(String s) {\\n        int len = s.length();\\n\\n        if (len == 0) {\\n            return \"\";\\n        }\\n\\n        char[] sChars = s.toCharArray();\\n\\n        /*\\n         * length of common string found\\n         * set dp[i][j] to 0 if s[i - 1] != s[j];\\n         */\\n        int[][] dp = new int[2][len + 1];\\n        int currRow = 0;\\n        int maxLen = 0;\\n        int start = 0;\\n\\n        /*\\n         * find longest common string between s and s\\' (reversed s)\\n         * for orginal string, from sChars[0] to sChars[len - 1]\\n         * for reversed view, from sChars[len - 1] to sChars[0];\\n         */\\n        for (int i = 0; i <= len; i++) {\\n            for (int j = len; j >= 0; j--) {\\n                if (i == 0 || j == len) {\\n                    dp[currRow][j] = 0;\\n                } else if (sChars[i - 1] == sChars[j]) {\\n                    dp[currRow][j] = dp[1 - currRow][j + 1] + 1;\\n                    int currLen = dp[currRow][j];\\n\\n                    /*\\n                     * 1. longest common substring length\\n                     * 2. skip those common substrings doesn\\'t \"produced\" by reverse.\\n                     */\\n                    if (i - 1 == j + currLen - 1 && i - currLen == j && currLen > maxLen) {\\n                        start = j;\\n                        maxLen = currLen;\\n                    }\\n                } else {\\n                    dp[currRow][j] = 0;\\n                }\\n            }\\n\\n            // * switch the working row of dp[][] to the next row (i)\\n            currRow = 1 - currRow;\\n        }\\n\\n        return s.substring(start, start + maxLen);\\n    }\\n}\\n```\\n**Space Complexity: O(n)**\\n\\n---\\n\\n# Approach 2: Brute Force (962ms)\\n```java\\nclass Solution {\\n    public String longestPalindrome(String s) {\\n        char[] charArray = s.toCharArray();\\n        int start = 0;\\n        int maxLen = 0;\\n        for (int i = 0; i < charArray.length; i++) {\\n            for (int len = 0; i + len < charArray.length; len++) {\\n                if (isPalindrome(charArray, i, len) && len + 1 > maxLen) {\\n                    maxLen = len + 1;\\n                    start = i;\\n                }\\n            }\\n        }\\n\\n        return s.substring(start, start + maxLen);\\n    }\\n\\n    public boolean isPalindrome(char[] charArray, int start, int len) {\\n        while (len > 0) {\\n            if (charArray[start] != charArray[start + len]) {\\n                return false;\\n            }\\n\\n            start++;\\n            len -= 2;\\n        }\\n\\n        return true;\\n    }\\n}\\n```\\n\\n---\\n# Approach 3: Dynamic Programming\\n![image](https://assets.leetcode.com/users/guangxuli/image_1590367788.png)\\n\\n![image](https://assets.leetcode.com/users/guangxuli/image_1590369367.png)\\n\\n```java\\nclass Solution {\\n    public String longestPalindrome(String s) {\\n        char[] sChars = s.toCharArray();\\n\\n        int m = s.length();\\n\\n        // * dp[i][len + 1] means substring starting from i with length of len;\\n        boolean[][] dp = new boolean[m][2];\\n        int currCol = 0;\\n\\n        int maxLen = 0;\\n        int ans = 0; // record start index of s\\n\\n        for (int len = 0; len < m; len++) {\\n            for (int start = 0; start + len < m; start++) {\\n                int end = start + len;\\n                if (len == 0) {\\n                    dp[start][currCol] = true;\\n                } else if (len == 1) {\\n                    dp[start][currCol] = (sChars[start] == sChars[end]);\\n                } else {\\n                    dp[start][currCol] = (sChars[start] == sChars[end] && dp[start + 1][currCol]);\\n                }\\n\\n                if (dp[start][currCol] && len + 1 > maxLen) {\\n                    ans = start;\\n                    maxLen = len + 1;\\n                }\\n            }\\n\\n            currCol = 1 - currCol;\\n        }\\n\\n        return maxLen == 0 ? \"\" : s.substring(ans, ans + maxLen);\\n    }\\n}\\n```\\n\\n**Space complexity: O(n).** It uses **O(2n)** space to store the table.\\n\\n---\\n# Approach 4: Expand Around Center\\n```java\\nclass Solution {\\n    public String longestPalindrome(String s) {\\n        if (s.length() == 0) {\\n            return \"\";\\n        }\\n\\n        char[] sChars = s.toCharArray();\\n\\n        int start = 0;\\n        int end = 0;\\n\\n        for (int i = 0; i < sChars.length; i++) {\\n            int len = Math.max(expand(sChars, i, i), expand(sChars, i, i + 1));\\n\\n            if (len > end - start + 1) {\\n                start = i - (len - 1) / 2;\\n                end = i + len / 2;\\n            }\\n        }\\n\\n        return s.substring(start, end + 1);\\n    }\\n\\n    public int expand(char[] sChars, int i, int j) {\\n        while (i >= 0 && j < sChars.length && sChars[i] == sChars[j]) {\\n            i--;\\n            j++;\\n        }\\n        return j - i - 1;\\n    }\\n}\\n```\\n\\n---\\n# Approach 5: Manacher\\'s Algorithm\\n## **!!!Based on the solution video on [leetcode-cn.com](https://leetcode-cn.com/problems/longest-palindromic-substring/solution/zui-chang-hui-wen-zi-chuan-by-leetcode-solution/)**\\n## **The copyright belongs to the original author**\\nIn **Approach 4**, we do lots of comparisons which is unnecessary. Manacher\\'s algorithm achieves the time complexity O(n) by skip the unnecessary comparisons.\\n**e.g.**\\n![image](https://assets.leetcode.com/users/guangxuli/image_1590367962.png)\\n\\nFor indice **8** which is **a**, we don\\'t need to do the `expandAroundCenter` since we have learned from indice **2**, that the expand length is 0. And to make it true, the indice **8** and indice **2** should be in the **same palindrome**. Meanwhile they have the **same distance** to the center of the palindrome.\\n\\n***We could divide the problem into several cases.***\\np[i] means the expand length of substring with the center of indice i .\\n`[a, a, b, c, b, a, d] => p[3] = 2`\\n\\n**1. `i + p[mirror] < maxRight`**\\n![image](https://assets.leetcode.com/users/guangxuli/image_1590368349.png)\\n**2. `i + p[mirror] == maxRight`**\\n![image](https://assets.leetcode.com/users/guangxuli/image_1590368448.png)\\n**3. `i + p[mirror] > maxRight`**\\n![image](https://assets.leetcode.com/users/guangxuli/image_1590368458.png)\\n```java\\nif i >= maxRight\\n    expand the substring with the center of i\\nelse if i + p[mirror] < maxRight\\n    p[i] = p[mirror]\\nelse if i + p[mirror] == maxRight\\n    p[i] = p[mirror] = maxRight - i\\n    expand the substring with the center of i, beginning from maxRight\\nelse\\n    p[i] = maxRight - i\\n```\\n\\n**We actually could make the code more concise:**\\n```java\\nif i < maxRight\\n    p[i] = min(p[mirror], maxRight - i)\\n    \\nexpand substring with center of i, beginning from i + p[i]\\n```\\n\\n*The algorithm only solve the string with **odd** size, so we add **\\'#\\'** to the string to make the size of string **always be odd**.*\\n```java\\nclass Solution {\\n    public String longestPalindrome(String s) {\\n\\n        // code line +8 to line +15\\n        int strLen = 2 * s.length() + 3;\\n        char[] sChars = new char[strLen];\\n\\n        /*\\n         * To ignore special cases at the beginning and end of the array\\n         * \"abc\" -> @ # a # b # c # $\\n         * \"\" -> @#$\\n         * \"a\" -> @ # a # $\\n         */\\n        sChars[0] = \\'@\\';\\n        sChars[strLen - 1] = \\'$\\';\\n        int t = 1;\\n        for (char c : s.toCharArray()) {\\n            sChars[t++] = \\'#\\';\\n            sChars[t++] = c;\\n        }\\n        sChars[t] = \\'#\\';\\n\\n        int maxLen = 0;\\n        int start = 0;\\n        int maxRight = 0;\\n        int center = 0;\\n        int[] p = new int[strLen]; // i\\'s radius, which not includes i\\n        for (int i = 1; i < strLen - 1; i++) {\\n            if (i < maxRight) {\\n                p[i] = Math.min(maxRight - i, p[2 * center - i]);\\n            }\\n\\n            // expand center\\n            while (sChars[i + p[i] + 1] == sChars[i - p[i] - 1]) {\\n                p[i]++;\\n            }\\n\\n            // update center and its bound\\n            if (i + p[i] > maxRight) {\\n                center = i;\\n                maxRight = i + p[i];\\n            }\\n\\n            // update ans\\n            if (p[i] > maxLen) {\\n                start = (i - p[i] - 1) / 2;\\n                maxLen = p[i];\\n            }\\n        }\\n\\n        return s.substring(start, start + maxLen);\\n    }\\n}\\n```\\n\\n**Time complexity: O(n)**\\n**Space complexity: O(n)** We need **O(n)** space to form **p[i]**.",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "```java\\nclass Solution {\\n    public String longestPalindrome(String s) {\\n        int len = s.length();\\n\\n        if (len == 0) {\\n            return \"\";\\n        }\\n\\n        char[] sChars = s.toCharArray();\\n\\n        /*\\n         * length of common string found\\n         * set dp[i][j] to 0 if s[i - 1] != s[j];\\n         */\\n        int[][] dp = new int[2][len + 1];\\n        int currRow = 0;\\n        int maxLen = 0;\\n        int start = 0;\\n\\n        /*\\n         * find longest common string between s and s\\' (reversed s)\\n         * for orginal string, from sChars[0] to sChars[len - 1]\\n         * for reversed view, from sChars[len - 1] to sChars[0];\\n         */\\n        for (int i = 0; i <= len; i++) {\\n            for (int j = len; j >= 0; j--) {\\n                if (i == 0 || j == len) {\\n                    dp[currRow][j] = 0;\\n                } else if (sChars[i - 1] == sChars[j]) {\\n                    dp[currRow][j] = dp[1 - currRow][j + 1] + 1;\\n                    int currLen = dp[currRow][j];\\n\\n                    /*\\n                     * 1. longest common substring length\\n                     * 2. skip those common substrings doesn\\'t \"produced\" by reverse.\\n                     */\\n                    if (i - 1 == j + currLen - 1 && i - currLen == j && currLen > maxLen) {\\n                        start = j;\\n                        maxLen = currLen;\\n                    }\\n                } else {\\n                    dp[currRow][j] = 0;\\n                }\\n            }\\n\\n            // * switch the working row of dp[][] to the next row (i)\\n            currRow = 1 - currRow;\\n        }\\n\\n        return s.substring(start, start + maxLen);\\n    }\\n}\\n```\n```java\\nclass Solution {\\n    public String longestPalindrome(String s) {\\n        char[] charArray = s.toCharArray();\\n        int start = 0;\\n        int maxLen = 0;\\n        for (int i = 0; i < charArray.length; i++) {\\n            for (int len = 0; i + len < charArray.length; len++) {\\n                if (isPalindrome(charArray, i, len) && len + 1 > maxLen) {\\n                    maxLen = len + 1;\\n                    start = i;\\n                }\\n            }\\n        }\\n\\n        return s.substring(start, start + maxLen);\\n    }\\n\\n    public boolean isPalindrome(char[] charArray, int start, int len) {\\n        while (len > 0) {\\n            if (charArray[start] != charArray[start + len]) {\\n                return false;\\n            }\\n\\n            start++;\\n            len -= 2;\\n        }\\n\\n        return true;\\n    }\\n}\\n```\n```java\\nclass Solution {\\n    public String longestPalindrome(String s) {\\n        char[] sChars = s.toCharArray();\\n\\n        int m = s.length();\\n\\n        // * dp[i][len + 1] means substring starting from i with length of len;\\n        boolean[][] dp = new boolean[m][2];\\n        int currCol = 0;\\n\\n        int maxLen = 0;\\n        int ans = 0; // record start index of s\\n\\n        for (int len = 0; len < m; len++) {\\n            for (int start = 0; start + len < m; start++) {\\n                int end = start + len;\\n                if (len == 0) {\\n                    dp[start][currCol] = true;\\n                } else if (len == 1) {\\n                    dp[start][currCol] = (sChars[start] == sChars[end]);\\n                } else {\\n                    dp[start][currCol] = (sChars[start] == sChars[end] && dp[start + 1][currCol]);\\n                }\\n\\n                if (dp[start][currCol] && len + 1 > maxLen) {\\n                    ans = start;\\n                    maxLen = len + 1;\\n                }\\n            }\\n\\n            currCol = 1 - currCol;\\n        }\\n\\n        return maxLen == 0 ? \"\" : s.substring(ans, ans + maxLen);\\n    }\\n}\\n```\n```java\\nclass Solution {\\n    public String longestPalindrome(String s) {\\n        if (s.length() == 0) {\\n            return \"\";\\n        }\\n\\n        char[] sChars = s.toCharArray();\\n\\n        int start = 0;\\n        int end = 0;\\n\\n        for (int i = 0; i < sChars.length; i++) {\\n            int len = Math.max(expand(sChars, i, i), expand(sChars, i, i + 1));\\n\\n            if (len > end - start + 1) {\\n                start = i - (len - 1) / 2;\\n                end = i + len / 2;\\n            }\\n        }\\n\\n        return s.substring(start, end + 1);\\n    }\\n\\n    public int expand(char[] sChars, int i, int j) {\\n        while (i >= 0 && j < sChars.length && sChars[i] == sChars[j]) {\\n            i--;\\n            j++;\\n        }\\n        return j - i - 1;\\n    }\\n}\\n```\n```java\\nif i >= maxRight\\n    expand the substring with the center of i\\nelse if i + p[mirror] < maxRight\\n    p[i] = p[mirror]\\nelse if i + p[mirror] == maxRight\\n    p[i] = p[mirror] = maxRight - i\\n    expand the substring with the center of i, beginning from maxRight\\nelse\\n    p[i] = maxRight - i\\n```\n```java\\nif i < maxRight\\n    p[i] = min(p[mirror], maxRight - i)\\n    \\nexpand substring with center of i, beginning from i + p[i]\\n```\n```java\\nclass Solution {\\n    public String longestPalindrome(String s) {\\n\\n        // code line +8 to line +15\\n        int strLen = 2 * s.length() + 3;\\n        char[] sChars = new char[strLen];\\n\\n        /*\\n         * To ignore special cases at the beginning and end of the array\\n         * \"abc\" -> @ # a # b # c # $\\n         * \"\" -> @#$\\n         * \"a\" -> @ # a # $\\n         */\\n        sChars[0] = \\'@\\';\\n        sChars[strLen - 1] = \\'$\\';\\n        int t = 1;\\n        for (char c : s.toCharArray()) {\\n            sChars[t++] = \\'#\\';\\n            sChars[t++] = c;\\n        }\\n        sChars[t] = \\'#\\';\\n\\n        int maxLen = 0;\\n        int start = 0;\\n        int maxRight = 0;\\n        int center = 0;\\n        int[] p = new int[strLen]; // i\\'s radius, which not includes i\\n        for (int i = 1; i < strLen - 1; i++) {\\n            if (i < maxRight) {\\n                p[i] = Math.min(maxRight - i, p[2 * center - i]);\\n            }\\n\\n            // expand center\\n            while (sChars[i + p[i] + 1] == sChars[i - p[i] - 1]) {\\n                p[i]++;\\n            }\\n\\n            // update center and its bound\\n            if (i + p[i] > maxRight) {\\n                center = i;\\n                maxRight = i + p[i];\\n            }\\n\\n            // update ans\\n            if (p[i] > maxLen) {\\n                start = (i - p[i] - 1) / 2;\\n                maxLen = p[i];\\n            }\\n        }\\n\\n        return s.substring(start, start + maxLen);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3337,
                "title": "manacher-algorithm-in-python-o-n",
                "content": "    class Solution:\\n        #Manacher algorithm\\n        #http://en.wikipedia.org/wiki/Longest_palindromic_substring\\n        \\n        def longestPalindrome(self, s):\\n            # Transform S into T.\\n            # For example, S = \"abba\", T = \"^#a#b#b#a#$\".\\n            # ^ and $ signs are sentinels appended to each end to avoid bounds checking\\n            T = '#'.join('^{}$'.format(s))\\n            n = len(T)\\n            P = [0] * n\\n            C = R = 0\\n            for i in range (1, n-1):\\n                P[i] = (R > i) and min(R - i, P[2*C - i]) # equals to i' = C - (i-C)\\n                # Attempt to expand palindrome centered at i\\n                while T[i + 1 + P[i]] == T[i - 1 - P[i]]:\\n                    P[i] += 1\\n        \\n                # If palindrome centered at i expand past R,\\n                # adjust center based on expanded palindrome.\\n                if i + P[i] > R:\\n                    C, R = i, i + P[i]\\n        \\n            # Find the maximum element in P.\\n            maxLen, centerIndex = max((n, i) for i, n in enumerate(P))\\n            return s[(centerIndex  - maxLen)//2: (centerIndex  + maxLen)//2]\\n\\nBased on this  article: http://articles.leetcode.com/2011/11/longest-palindromic-substring-part-ii.html",
                "solutionTags": [
                    "Python"
                ],
                "code": "class Solution:\\n        #Manacher algorithm\\n        #http://en.wikipedia.org/wiki/Longest_palindromic_substring\\n        \\n        def longestPalindrome(self, s):\\n            # Transform S into T.\\n            # For example, S = \"abba\", T = \"^#a#b#b#a#$\".\\n            # ^ and $ signs are sentinels appended to each end to avoid bounds checking\\n            T = '#'.join('^{}",
                "codeTag": "Java"
            },
            {
                "id": 2926,
                "title": "8-line-javascript-solution",
                "content": "**Updated: July 17 2021**\\n\\n```\\nfunction longestPalindrome(s) {\\n  let ll = 0, rr = 0;\\n  \\n  for (let i = 0; i < s.length; i++)\\n    for (let j of [i, i+1])\\n      for (l = i, r = j; s[l] && s[l] === s[r]; l--, r++)\\n        [ll, rr] = (r-l+1) > (rr-ll+1) ? [l, r] : [ll, rr];\\n  \\n  return s.substring(ll, rr+1);\\n}\\n```\\n**With Comment**\\n```\\nfunction longestPalindrome(s) {\\n  // ll: Left index of the longest palindrome.\\n  // rr: Right index of the longest palindrome.\\n  let ll = 0, rr = 0;\\n\\n  // Iterate all palindromes with center indices\\n  // [..., i, ...] or [... i, i+1, ...]\\n  for (let i = 0; i < s.length; i++) {\\n    for (let j of [i, i+1]) {\\n      for (l = i, r = j; s[l] && s[l] === s[r]; l--, r++)\\n\\n        // Found a new palindrome [l, ..., i, j, ..., r]\\n        // Update the ll, rr if the newly found palindrome is longer than the\\n        // existing one.\\n        [ll, rr] = (r-l+1) > (rr-ll+1) ? [l, r] : [ll, rr];\\n    }\\n  }\\n  return s.substring(ll, rr+1);\\n}\\n```\\n",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nfunction longestPalindrome(s) {\\n  let ll = 0, rr = 0;\\n  \\n  for (let i = 0; i < s.length; i++)\\n    for (let j of [i, i+1])\\n      for (l = i, r = j; s[l] && s[l] === s[r]; l--, r++)\\n        [ll, rr] = (r-l+1) > (rr-ll+1) ? [l, r] : [ll, rr];\\n  \\n  return s.substring(ll, rr+1);\\n}\\n```\n```\\nfunction longestPalindrome(s) {\\n  // ll: Left index of the longest palindrome.\\n  // rr: Right index of the longest palindrome.\\n  let ll = 0, rr = 0;\\n\\n  // Iterate all palindromes with center indices\\n  // [..., i, ...] or [... i, i+1, ...]\\n  for (let i = 0; i < s.length; i++) {\\n    for (let j of [i, i+1]) {\\n      for (l = i, r = j; s[l] && s[l] === s[r]; l--, r++)\\n\\n        // Found a new palindrome [l, ..., i, j, ..., r]\\n        // Update the ll, rr if the newly found palindrome is longer than the\\n        // existing one.\\n        [ll, rr] = (r-l+1) > (rr-ll+1) ? [l, r] : [ll, rr];\\n    }\\n  }\\n  return s.substring(ll, rr+1);\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 578435,
                "title": "evolution-from-recursion-to-top-down-dp-to-bottoms-up-dp-easy-understanding-code",
                "content": "#### Recursion\\n\\n```\\nclass Solution {\\n    public String longestPalindrome(String s) {\\n        \\n        int len = s.length();\\n        \\n        int maxLen = 0;\\n        String res = \"\";\\n        \\n        \\n        for (int left = 0; left < len; left++){\\n            for (int right = left; right < len; right++){\\n                \\n             if (s.charAt(left) == s.charAt(right) && isPalin(s,left + 1, right -1)){\\n                if (maxLen < right - left + 1) {\\n                    maxLen = right - left + 1;\\n                    res = s.substring(left, right + 1);\\n                    }\\n                }   \\n            }\\n        }\\n        \\n        return res;\\n    }\\n    \\n    \\n    public boolean isPalin(String s, int left, int right){\\n        \\n        if (left >= right){\\n            return true;\\n        }\\n        \\n        if (s.charAt(left) != s.charAt(right)) {\\n            return false;\\n        }\\n        \\n        if (right - left <= 2){\\n            return true;\\n        }\\n        \\n        return isPalin(s,left + 1, right - 1);\\n        \\n    }\\n    \\n}\\n```\\n\\n#### Top Down\\n```\\nclass Solution {\\n    \\n    Boolean[][] memo ;\\n    \\n    public String longestPalindrome(String s) {\\n        \\n        int len = s.length();\\n        \\n        int maxLen = 0;\\n        String res = \"\";\\n        memo = new Boolean[len][len];\\n        \\n        for (int left = 0; left < len; left++){\\n            for (int right = left; right < len; right++){\\n                \\n             if (s.charAt(left) == s.charAt(right) && isPalin(s,left + 1, right -1)){\\n                if (maxLen < right - left + 1) {\\n                    maxLen = right - left + 1;\\n                    res = s.substring(left, right + 1);\\n                    }\\n                }   \\n            }\\n        }\\n        \\n        return res;\\n    }\\n    \\n    \\n    public boolean isPalin(String s, int left, int right){\\n        \\n        if (left >= right){\\n            return true;\\n        }\\n        \\n        if (memo[left][right] != null){\\n            return memo[left][right] ;\\n        }\\n        \\n        if (s.charAt(left) != s.charAt(right)) {\\n            memo[left][right] = false;\\n            return memo[left][right];\\n        }\\n        \\n        if (right - left <= 2){\\n            memo[left][right] = true;\\n            return memo[left][right];\\n        }\\n        \\n        memo[left][right] = isPalin(s,left + 1, right - 1);\\n        return memo[left][right];\\n        \\n    }\\n    \\n}\\n```\\n\\n#### Bottoms Up DP\\n\\n\\n```\\nclass Solution {\\n    \\n    boolean[][] memo ;\\n    \\n    public String longestPalindrome(String s) {\\n        \\n        int len = s.length();\\n        \\n        int maxLen = 0;\\n        String res = \"\";\\n        memo = new boolean[len][len];\\n        \\n        for (int left = len -1; left >= 0; left--){ // notice this goes backwards\\n            for (int right = left; right < len; right++){\\n                \\n             if (s.charAt(left) == s.charAt(right)){\\n                 \\n                if (right - left <=2){\\n                    memo[left][right] = true;\\n                } else{\\n                    memo[left][right] = memo[left + 1][right - 1]; \\n                }\\n             }\\n    \\n            if (memo[left][right]  && maxLen < right - left + 1) {\\n                maxLen = right - left + 1;\\n                res = s.substring(left, right + 1);\\n                }\\n            }   \\n            \\n        }\\n        \\n        return res;\\n    }\\n    \\n}\\n```\\n\\n\\nWhile converting a Top Down to A Bottoms up solution, it is important to make sure the outermost loop is reversed. \\n\\nDuring the top down, the order of execution is reverse. So to make sure this also happens in bottoms up, it is important to reverse the direction.\\n\\nThis is true for ALL dynamic programming problems.\\n\\nAnother hint is because the main equation has `memo[left][right] = memo[left + 1][right - 1]; `\\n\\nThis means, before `left` can be computed `left+1` must be precomputed. So left goes from `n,n-1,...0`.\\n\\nAlso, before `right` can be computed `right-1` must be precomputed.So right goes `0,1,2....n`.\\n\\nHope it helps.",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n    public String longestPalindrome(String s) {\\n        \\n        int len = s.length();\\n        \\n        int maxLen = 0;\\n        String res = \"\";\\n        \\n        \\n        for (int left = 0; left < len; left++){\\n            for (int right = left; right < len; right++){\\n                \\n             if (s.charAt(left) == s.charAt(right) && isPalin(s,left + 1, right -1)){\\n                if (maxLen < right - left + 1) {\\n                    maxLen = right - left + 1;\\n                    res = s.substring(left, right + 1);\\n                    }\\n                }   \\n            }\\n        }\\n        \\n        return res;\\n    }\\n    \\n    \\n    public boolean isPalin(String s, int left, int right){\\n        \\n        if (left >= right){\\n            return true;\\n        }\\n        \\n        if (s.charAt(left) != s.charAt(right)) {\\n            return false;\\n        }\\n        \\n        if (right - left <= 2){\\n            return true;\\n        }\\n        \\n        return isPalin(s,left + 1, right - 1);\\n        \\n    }\\n    \\n}\\n```\n```\\nclass Solution {\\n    \\n    Boolean[][] memo ;\\n    \\n    public String longestPalindrome(String s) {\\n        \\n        int len = s.length();\\n        \\n        int maxLen = 0;\\n        String res = \"\";\\n        memo = new Boolean[len][len];\\n        \\n        for (int left = 0; left < len; left++){\\n            for (int right = left; right < len; right++){\\n                \\n             if (s.charAt(left) == s.charAt(right) && isPalin(s,left + 1, right -1)){\\n                if (maxLen < right - left + 1) {\\n                    maxLen = right - left + 1;\\n                    res = s.substring(left, right + 1);\\n                    }\\n                }   \\n            }\\n        }\\n        \\n        return res;\\n    }\\n    \\n    \\n    public boolean isPalin(String s, int left, int right){\\n        \\n        if (left >= right){\\n            return true;\\n        }\\n        \\n        if (memo[left][right] != null){\\n            return memo[left][right] ;\\n        }\\n        \\n        if (s.charAt(left) != s.charAt(right)) {\\n            memo[left][right] = false;\\n            return memo[left][right];\\n        }\\n        \\n        if (right - left <= 2){\\n            memo[left][right] = true;\\n            return memo[left][right];\\n        }\\n        \\n        memo[left][right] = isPalin(s,left + 1, right - 1);\\n        return memo[left][right];\\n        \\n    }\\n    \\n}\\n```\n```\\nclass Solution {\\n    \\n    boolean[][] memo ;\\n    \\n    public String longestPalindrome(String s) {\\n        \\n        int len = s.length();\\n        \\n        int maxLen = 0;\\n        String res = \"\";\\n        memo = new boolean[len][len];\\n        \\n        for (int left = len -1; left >= 0; left--){ // notice this goes backwards\\n            for (int right = left; right < len; right++){\\n                \\n             if (s.charAt(left) == s.charAt(right)){\\n                 \\n                if (right - left <=2){\\n                    memo[left][right] = true;\\n                } else{\\n                    memo[left][right] = memo[left + 1][right - 1]; \\n                }\\n             }\\n    \\n            if (memo[left][right]  && maxLen < right - left + 1) {\\n                maxLen = right - left + 1;\\n                res = s.substring(left, right + 1);\\n                }\\n            }   \\n            \\n        }\\n        \\n        return res;\\n    }\\n    \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 468326,
                "title": "clean-python-3-solution-faster-than-85-memory-usage-less-than-100",
                "content": "```\\nclass Solution:\\n    def longestPalindrome(self, s: str) -> str:\\n        p = \\'\\'\\n        for i in range(len(s)):\\n            p1 = self.get_palindrome(s, i, i+1)\\n            p2 = self.get_palindrome(s, i, i)\\n            p = max([p, p1, p2], key=len)\\n        return p\\n    \\n    def get_palindrome(self, s: str, l: int, r: int) -> str:\\n        while l >= 0 and r < len(s) and s[l] == s[r]:\\n            l -= 1\\n            r += 1\\n        return s[l+1:r]\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def longestPalindrome(self, s: str) -> str:\\n        p = \\'\\'\\n        for i in range(len(s)):\\n            p1 = self.get_palindrome(s, i, i+1)\\n            p2 = self.get_palindrome(s, i, i)\\n            p = max([p, p1, p2], key=len)\\n        return p\\n    \\n    def get_palindrome(self, s: str, l: int, r: int) -> str:\\n        while l >= 0 and r < len(s) and s[l] == s[r]:\\n            l -= 1\\n            r += 1\\n        return s[l+1:r]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2929,
                "title": "accepted-4ms-c-solution",
                "content": "    class Solution {\\n    public:\\n        std::string longestPalindrome(std::string s) {\\n            if (s.size() < 2)\\n                return s;\\n            int len = s.size(), max_left = 0, max_len = 1, left, right;\\n            for (int start = 0; start < len && len - start > max_len / 2;) {\\n                left = right = start;\\n                while (right < len - 1 && s[right + 1] == s[right])\\n                    ++right;\\n                start = right + 1;\\n                while (right < len - 1 && left > 0 && s[right + 1] == s[left - 1]) {\\n                    ++right;\\n                    --left;\\n                }\\n                if (max_len < right - left + 1) {\\n                    max_left = left;\\n                    max_len = right - left + 1;\\n                }\\n            }\\n            return s.substr(max_left, max_len);\\n        }\\n    };",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n        std::string longestPalindrome(std::string s) {\\n            if (s.size() < 2)\\n                return s;\\n            int len = s.size(), max_left = 0, max_len = 1, left, right;\\n            for (int start = 0; start < len && len - start > max_len / 2;) {\\n                left = right = start;\\n                while (right < len - 1 && s[right + 1] == s[right])\\n                    ++right;\\n                start = right + 1;\\n                while (right < len - 1 && left > 0 && s[right + 1] == s[left - 1]) {\\n                    ++right;\\n                    --left;\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 121496,
                "title": "python-dp-solution",
                "content": "```\\nclass Solution(object):\\n    def longestPalindrome(self, s):\\n        ans = \\'\\'\\n        max_len = 0\\n        n = len(s)\\n        DP = [[0] * n for _ in xrange(n)]\\n        for i in xrange(n):\\n            DP[i][i] = True\\n            max_len = 1\\n            ans = s[i]\\n        for i in xrange(n-1):\\n            if s[i] == s[i+1]:\\n                DP[i][i+1] = True\\n                ans = s[i:i+2]\\n                max_len = 2\\n        for j in xrange(n):\\n            for i in xrange(0, j-1):\\n                if s[i] == s[j] and DP[i+1][j-1]:\\n                    DP[i][j] = True\\n                    if max_len < j - i + 1:\\n                        ans = s[i:j+1]\\n                        max_len = j - i + 1\\n        return ans\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def longestPalindrome(self, s):\\n        ans = \\'\\'\\n        max_len = 0\\n        n = len(s)\\n        DP = [[0] * n for _ in xrange(n)]\\n        for i in xrange(n):\\n            DP[i][i] = True\\n            max_len = 1\\n            ans = s[i]\\n        for i in xrange(n-1):\\n            if s[i] == s[i+1]:\\n                DP[i][i+1] = True\\n                ans = s[i:i+2]\\n                max_len = 2\\n        for j in xrange(n):\\n            for i in xrange(0, j-1):\\n                if s[i] == s[j] and DP[i+1][j-1]:\\n                    DP[i][j] = True\\n                    if max_len < j - i + 1:\\n                        ans = s[i:j+1]\\n                        max_len = j - i + 1\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 548834,
                "title": "intuitive-javascript-solution-with-expand-around-center",
                "content": "```\\n/**\\n * @param {string} s\\n * @return {string}\\n */\\nvar longestPalindrome = function(s) {\\n    let longest = \\'\\';\\n    const findLongestPalindrome = (str, i, j) => {\\n        while(i >= 0 && j < str.length && str[i] === str[j]) {\\n            i -= 1;\\n            j += 1;\\n        }\\n        // slice the qualified substring from the second last iteration\\n        return str.slice(i + 1, j);\\n    }\\n    for (let i = 0; i < s.length; i++) {\\n        // palindrome can center around 1 or 2 letters\\n        const current1 = findLongestPalindrome(s, i, i);\\n        const current2 = findLongestPalindrome(s, i, i + 1);\\n        const longerPalindrome = \\n              current1.length > current2.length ? current1 : current2;\\n        if (longerPalindrome.length > longest.length) {\\n            longest = longerPalindrome;\\n        } \\n    }\\n    return longest;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {string} s\\n * @return {string}\\n */\\nvar longestPalindrome = function(s) {\\n    let longest = \\'\\';\\n    const findLongestPalindrome = (str, i, j) => {\\n        while(i >= 0 && j < str.length && str[i] === str[j]) {\\n            i -= 1;\\n            j += 1;\\n        }\\n        // slice the qualified substring from the second last iteration\\n        return str.slice(i + 1, j);\\n    }\\n    for (let i = 0; i < s.length; i++) {\\n        // palindrome can center around 1 or 2 letters\\n        const current1 = findLongestPalindrome(s, i, i);\\n        const current2 = findLongestPalindrome(s, i, i + 1);\\n        const longerPalindrome = \\n              current1.length > current2.length ? current1 : current2;\\n        if (longerPalindrome.length > longest.length) {\\n            longest = longerPalindrome;\\n        } \\n    }\\n    return longest;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1024769,
                "title": "python3-3-solutions-expand-from-the-middle-top-down-dp-bottom-up-dp-clean-concise",
                "content": "**\\u2714\\uFE0F Solution 1: Expand from the middle**\\n```python\\nclass Solution:\\n    def longestPalindrome(self, s: str) -> str:\\n        n = len(s)\\n        \\n        def longestPalindrome(l, r):\\n            while l >= 0 and r < n and s[l] == s[r]:\\n                l -= 1\\n                r += 1\\n            l += 1\\n            r -= 1\\n            return r - l + 1, l\\n        \\n        maxLen = 0\\n        startIdx = -1\\n        for i in range(n):\\n            length, start = longestPalindrome(i, i)  # Odd length palindrome, center at s[i]\\n            if maxLen < length:\\n                maxLen = length\\n                startIdx = start\\n                \\n            length, start = longestPalindrome(i, i+1)  # Even length palindrome, center at s[i], s[i+1]\\n            if maxLen < length:\\n                maxLen = length\\n                startIdx = start\\n            \\n        return s[startIdx : startIdx + maxLen]\\n```\\n**Complexity**\\n- Time: `O(N^2)`, where `N <= 1000` is length of string `s`.\\n- Extra Space (without counting output as space): `O(1)`\\n\\n---\\n**\\u274C  Solution 2: Top down DP (Time is too strict!)**\\n```python\\nclass Solution:\\n    def longestPalindrome(self, s: str) -> str:\\n        @lru_cache(None)\\n        def isPalindrome(l, r):\\n            if l >= r: return True\\n            if s[l] != s[r]: return False\\n            return isPalindrome(l + 1, r - 1)\\n\\n        maxLen = startIdx = 0\\n        n = len(s)\\n        for i in range(n):\\n            for j in range(i, n):\\n                if isPalindrome(i, j):\\n                    newLen = j - i + 1\\n                    if newLen > maxLen:\\n                        maxLen = newLen\\n                        startIdx = i\\n\\n        return s[startIdx:startIdx + maxLen]\\n```\\n**Complexity**\\n- Time: `O(N^2)`, where `N <= 1000` is length of string `s`.\\n- Space: `O(N^2)`\\n\\n---\\n**\\u2714\\uFE0F Solution 3: Bottom up DP**\\n```python\\nclass Solution:\\n    def longestPalindrome(self, s: str) -> str:\\n        n = len(s)\\n        dp = [[False] * n for _ in range(n)]\\n\\n        maxLen = startIdx = 0\\n        for i in range(n - 1, -1, -1):\\n            for j in range(i, n):\\n                if i == j:\\n                    dp[i][j] = True\\n                elif s[i] == s[j]:\\n                    dp[i][j] = (i+1 == j) or dp[i + 1][j - 1]\\n\\n                if dp[i][j]:\\n                    newLen = j - i + 1\\n                    if newLen > maxLen:\\n                        maxLen = newLen\\n                        startIdx = i\\n\\n        return s[startIdx:startIdx + maxLen]\\n```\\n**Complexity**\\n- Time: `O(N^2)`, where `N <= 1000` is length of string `s`.\\n- Space: `O(N^2)`",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "```python\\nclass Solution:\\n    def longestPalindrome(self, s: str) -> str:\\n        n = len(s)\\n        \\n        def longestPalindrome(l, r):\\n            while l >= 0 and r < n and s[l] == s[r]:\\n                l -= 1\\n                r += 1\\n            l += 1\\n            r -= 1\\n            return r - l + 1, l\\n        \\n        maxLen = 0\\n        startIdx = -1\\n        for i in range(n):\\n            length, start = longestPalindrome(i, i)  # Odd length palindrome, center at s[i]\\n            if maxLen < length:\\n                maxLen = length\\n                startIdx = start\\n                \\n            length, start = longestPalindrome(i, i+1)  # Even length palindrome, center at s[i], s[i+1]\\n            if maxLen < length:\\n                maxLen = length\\n                startIdx = start\\n            \\n        return s[startIdx : startIdx + maxLen]\\n```\n```python\\nclass Solution:\\n    def longestPalindrome(self, s: str) -> str:\\n        @lru_cache(None)\\n        def isPalindrome(l, r):\\n            if l >= r: return True\\n            if s[l] != s[r]: return False\\n            return isPalindrome(l + 1, r - 1)\\n\\n        maxLen = startIdx = 0\\n        n = len(s)\\n        for i in range(n):\\n            for j in range(i, n):\\n                if isPalindrome(i, j):\\n                    newLen = j - i + 1\\n                    if newLen > maxLen:\\n                        maxLen = newLen\\n                        startIdx = i\\n\\n        return s[startIdx:startIdx + maxLen]\\n```\n```python\\nclass Solution:\\n    def longestPalindrome(self, s: str) -> str:\\n        n = len(s)\\n        dp = [[False] * n for _ in range(n)]\\n\\n        maxLen = startIdx = 0\\n        for i in range(n - 1, -1, -1):\\n            for j in range(i, n):\\n                if i == j:\\n                    dp[i][j] = True\\n                elif s[i] == s[j]:\\n                    dp[i][j] = (i+1 == j) or dp[i + 1][j - 1]\\n\\n                if dp[i][j]:\\n                    newLen = j - i + 1\\n                    if newLen > maxLen:\\n                        maxLen = newLen\\n                        startIdx = i\\n\\n        return s[startIdx:startIdx + maxLen]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2156659,
                "title": "python-easy-o-1-space-approach",
                "content": "The following solution is kinda brute force approach. We expand the string around a given index.\\n> eg: input string : **ababd**\\n\\nLet\\'s say we expand around position `2`. The longest pallindrome that we can from position `2` is `bab`. But if we expand from a single character position, we would always end up with an odd length pallindrome. To find an even length pallindrome, we need to expand around two positions.\\n\\n>eg: input string : **abaabd**\\n\\nLet\\'s say we expand around position `2` and `3`.  The longest pallindrome that we can form from these positions  is `baab`. So we ended up with a longer pallindrome compared to the previous find.\\n\\nWe will use the above logic to find possible even and odd lengthed pallindromes from all positions in the string.\\nBelow is my implementation for the same:\\n```\\nclass Solution:\\n    def longestPalindrome(self, s: str) -> str:\\n        n=len(s)\\n        def expand_pallindrome(i,j):            \\n            while 0<=i<=j<n and s[i]==s[j]:\\n                i-=1\\n                j+=1                            \\n            return (i+1, j)\\n        \\n        res=(0,0)\\n        for i in range(n):\\n            b1 = expand_pallindrome(i,i)\\n            b2 = expand_pallindrome(i,i+1)            \\n            res=max(res, b1, b2,key=lambda x: x[1]-x[0]+1) # find max based on the length of the pallindrome strings.\\n                    \\n        return s[res[0]:res[1]]    \\n```\\n\\nA more concise variation: \\n```\\nclass Solution:\\n    def longestPalindrome(self, s: str) -> str:\\n        n=len(s)\\n        def expand_center(i,j):            \\n            while 0<=i<=j<n and s[i]==s[j]:\\n                i-=1\\n                j+=1                \\n            \\n            return (i+1, j)                \\n        \\n        res=max([expand_center(i,i+offset) for i in range(n) for offset in range(2)], key=lambda x: x[1]-x[0]+1)\\n        \\n        return s[res[0]:res[1]]\\n```\\n\\n**Time - O(n * n)** where `n` is the length of the input string\\n**Space - O(1)**\\n\\n---\\n\\n***Please upvote if you find it useful***",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def longestPalindrome(self, s: str) -> str:\\n        n=len(s)\\n        def expand_pallindrome(i,j):            \\n            while 0<=i<=j<n and s[i]==s[j]:\\n                i-=1\\n                j+=1                            \\n            return (i+1, j)\\n        \\n        res=(0,0)\\n        for i in range(n):\\n            b1 = expand_pallindrome(i,i)\\n            b2 = expand_pallindrome(i,i+1)            \\n            res=max(res, b1, b2,key=lambda x: x[1]-x[0]+1) # find max based on the length of the pallindrome strings.\\n                    \\n        return s[res[0]:res[1]]    \\n```\n```\\nclass Solution:\\n    def longestPalindrome(self, s: str) -> str:\\n        n=len(s)\\n        def expand_center(i,j):            \\n            while 0<=i<=j<n and s[i]==s[j]:\\n                i-=1\\n                j+=1                \\n            \\n            return (i+1, j)                \\n        \\n        res=max([expand_center(i,i+offset) for i in range(n) for offset in range(2)], key=lambda x: x[1]-x[0]+1)\\n        \\n        return s[res[0]:res[1]]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 428331,
                "title": "javascript-dp",
                "content": "Idea comes from optimizing recursive solution by remembering previous result. Let\\'s say we have a 2D array `dp`. In each cell, it indicates whether `range(i, j)` can become a palindrome or not, where  `i`, `j` denotes start and end index of the given string `s`. We can build upon base cases and expand from there:\\n* base case with one character - `dp[i][i] = true` when `i === j`\\n* base case with two characters - `dp[i][i+1] = true` when `s[i] === s[i+1]`\\n* expand case with three or more characters - `dp[i][j] = dp[i+1][j-1] && s[i] === s[j]`\\n\\n```\\nHere\\'s an example of dp with \"babad\" after two base cases\\n\\u250C\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u252C\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u252C\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u252C\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u252C\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u252C\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u252C\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2510\\n\\u2502 (index) \\u2502   0   \\u2502   1   \\u2502   2   \\u2502   3   \\u2502   4   \\u2502   5   \\u2502\\n\\u251C\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u253C\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u253C\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u253C\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u253C\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u253C\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u253C\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2524\\n\\u2502    0    \\u2502 true  \\u2502 false \\u2502 false \\u2502 false \\u2502 false \\u2502 false \\u2502\\n\\u2502    1    \\u2502 false \\u2502 true  \\u2502 false \\u2502 false \\u2502 false \\u2502 false \\u2502\\n\\u2502    2    \\u2502 false \\u2502 false \\u2502 true  \\u2502 false \\u2502 false \\u2502 false \\u2502\\n\\u2502    3    \\u2502 false \\u2502 false \\u2502 false \\u2502 true  \\u2502 false \\u2502 false \\u2502\\n\\u2502    4    \\u2502 false \\u2502 false \\u2502 false \\u2502 false \\u2502 true  \\u2502 false \\u2502\\n\\u2502    5    \\u2502 false \\u2502 false \\u2502 false \\u2502 false \\u2502 false \\u2502 false \\u2502\\n\\u2514\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2534\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2534\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2534\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2534\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2534\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2534\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2518\\n```\\n```\\n// 2D DP\\nvar longestPalindrome = function(s) {\\n    \\n\\tif(s.length <= 1) return s;\\n\\t\\n\\t// construct a 2D array\\n    const dp = [...new Array(s.length + 1)].map(_ => new Array(s.length + 1).fill(false));\\n\\t\\n    let lps = \\'\\';\\n    \\n\\t// base case for one character\\n    for(let i = 0; i < s.length; i++) {\\n        dp[i][i] = true;\\n        lps = s[i];\\n    }\\n    \\n\\t// base case for two characters\\n    for(let i = 0; i < s.length; i++) {\\n        if(s[i] === s[i + 1]) dp[i][i+1] = true;\\n        if(dp[i][i+1]) lps = s.substring(i, i + 2);\\n    }\\n\\n    // expand to three or more characters\\n    for(let i = s.length - 1; i >= 0; i--) {\\n        for(let j = i + 2; j < s.length; j++) {\\n            dp[i][j] = dp[i+1][j-1] && s[i] === s[j];\\n            if(dp[i][j]) lps = lps.length < (j - i + 1) ? s.substring(i, j + 1) : lps;\\n        }\\n    }\\n    \\n    return lps;\\n}\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Dynamic Programming"
                ],
                "code": "```\\nHere\\'s an example of dp with \"babad\" after two base cases\\n\\u250C\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u252C\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u252C\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u252C\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u252C\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u252C\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u252C\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2510\\n\\u2502 (index) \\u2502   0   \\u2502   1   \\u2502   2   \\u2502   3   \\u2502   4   \\u2502   5   \\u2502\\n\\u251C\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u253C\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u253C\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u253C\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u253C\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u253C\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u253C\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2524\\n\\u2502    0    \\u2502 true  \\u2502 false \\u2502 false \\u2502 false \\u2502 false \\u2502 false \\u2502\\n\\u2502    1    \\u2502 false \\u2502 true  \\u2502 false \\u2502 false \\u2502 false \\u2502 false \\u2502\\n\\u2502    2    \\u2502 false \\u2502 false \\u2502 true  \\u2502 false \\u2502 false \\u2502 false \\u2502\\n\\u2502    3    \\u2502 false \\u2502 false \\u2502 false \\u2502 true  \\u2502 false \\u2502 false \\u2502\\n\\u2502    4    \\u2502 false \\u2502 false \\u2502 false \\u2502 false \\u2502 true  \\u2502 false \\u2502\\n\\u2502    5    \\u2502 false \\u2502 false \\u2502 false \\u2502 false \\u2502 false \\u2502 false \\u2502\\n\\u2514\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2534\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2534\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2534\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2534\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2534\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2534\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2518\\n```\n```\\n// 2D DP\\nvar longestPalindrome = function(s) {\\n    \\n\\tif(s.length <= 1) return s;\\n\\t\\n\\t// construct a 2D array\\n    const dp = [...new Array(s.length + 1)].map(_ => new Array(s.length + 1).fill(false));\\n\\t\\n    let lps = \\'\\';\\n    \\n\\t// base case for one character\\n    for(let i = 0; i < s.length; i++) {\\n        dp[i][i] = true;\\n        lps = s[i];\\n    }\\n    \\n\\t// base case for two characters\\n    for(let i = 0; i < s.length; i++) {\\n        if(s[i] === s[i + 1]) dp[i][i+1] = true;\\n        if(dp[i][i+1]) lps = s.substring(i, i + 2);\\n    }\\n\\n    // expand to three or more characters\\n    for(let i = s.length - 1; i >= 0; i--) {\\n        for(let j = i + 2; j < s.length; j++) {\\n            dp[i][j] = dp[i+1][j-1] && s[i] === s[j];\\n            if(dp[i][j]) lps = lps.length < (j - i + 1) ? s.substring(i, j + 1) : lps;\\n        }\\n    }\\n    \\n    return lps;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 812245,
                "title": "simple-c-dp-code-with-comments",
                "content": "```\\nstring longestPalindrome(string s) {\\n        if(s.size() == 0) return \"\";\\n        int n = s.size();\\n        int table[n][n];\\n        memset(table,-1,sizeof(table)); //Initializing table with -1\\n        for (int i = 0; i < n; ++i) \\n            table[i][i] = 1;  //Filling up the table\\n        int maxLen = 1;\\n        int start = 0; \\n        for (int i = 0; i < n - 1; ++i) { //checking for substring of length 2.\\n            if (s[i] == s[i + 1]) { \\n                table[i][i + 1] = 1; \\n                start = i;  //Updating the start\\n                maxLen = 2; \\n            } \\n        }\\n        for(int k=3;k<=n;k++){ //Checking for length greater than 2 and k is length of substring \\n            for(int i=0;i<n - k + 1;i++){\\n                int j = i + k - 1; //Initializing the end Index i.e j = i + k - 1\\n                if(table[i+1][j-1] == 1 && s[i] == s[j]){ //Checking for the conditions i.e checking for sub-string from ith index to jth index.\\n                    table[i][j] = 1;\\n                    if (k > maxLen) { //Updating the maxLen\\n                        start = i;  //Updating the start\\n                        maxLen = k; \\n                    } \\n                }\\n            }\\n        }\\n        return s.substr(start, maxLen);\\n    }\\n```\\n\\n`T.C - O(N^2)`\\n\\n**Do Upvote if you find it Useful.**\\n",
                "solutionTags": [
                    "C++",
                    "C",
                    "String",
                    "Dynamic Programming"
                ],
                "code": "```\\nstring longestPalindrome(string s) {\\n        if(s.size() == 0) return \"\";\\n        int n = s.size();\\n        int table[n][n];\\n        memset(table,-1,sizeof(table)); //Initializing table with -1\\n        for (int i = 0; i < n; ++i) \\n            table[i][i] = 1;  //Filling up the table\\n        int maxLen = 1;\\n        int start = 0; \\n        for (int i = 0; i < n - 1; ++i) { //checking for substring of length 2.\\n            if (s[i] == s[i + 1]) { \\n                table[i][i + 1] = 1; \\n                start = i;  //Updating the start\\n                maxLen = 2; \\n            } \\n        }\\n        for(int k=3;k<=n;k++){ //Checking for length greater than 2 and k is length of substring \\n            for(int i=0;i<n - k + 1;i++){\\n                int j = i + k - 1; //Initializing the end Index i.e j = i + k - 1\\n                if(table[i+1][j-1] == 1 && s[i] == s[j]){ //Checking for the conditions i.e checking for sub-string from ith index to jth index.\\n                    table[i][j] = 1;\\n                    if (k > maxLen) { //Updating the maxLen\\n                        start = i;  //Updating the start\\n                        maxLen = k; \\n                    } \\n                }\\n            }\\n        }\\n        return s.substr(start, maxLen);\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2987,
                "title": "clean-java-solution-using-dp-yet-the-time-complexity-is-o-n-2",
                "content": "    public class Solution {\\n        public String longestPalindrome(String s) {\\n            if(s == null || s.length() == 0) {\\n                return \"\";\\n            }\\n            int len = s.length();\\n            boolean[][] dp = new boolean[len][len];\\n            int start = 0;\\n            int end = 0;\\n            int max = 0;\\n            for(int i = 0; i < s.length(); i++) {\\n                for(int j = 0; j <= i; j++) {\\n                    if(s.charAt(i) == s.charAt(j) && (i - j <= 2 || dp[j+1][i-1])) {\\n                        dp[j][i] = true;\\n                    }\\n                    if(dp[j][i] && max < i - j + 1) {\\n                        max = i - j + 1;\\n                        start = j;\\n                        end = i;\\n                    }\\n                }\\n            }\\n            return s.substring(start, end + 1);\\n        }\\n    }",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "class Solution {\\n        public String longestPalindrome(String s) {\\n            if(s == null || s.length() == 0) {\\n                return \"\";\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2156691,
                "title": "simple-dp-solution-java-explained",
                "content": "### Logic:\\nThe dynamic programmic approach to this question is quite simple actually! For any given substring, we can confirm if it is a palindrome in `O(1)` time if:\\n1. The characters at the ends of the substring are the same.\\n2. If the inner substring is a palindrome.\\n\\nObserve this relationship below:\\n![image](https://assets.leetcode.com/users/images/861e5558-0a38-4d01-bc08-aeb135cb80bd_1655340599.097208.png)\\n\\n___\\n### Algorithm:\\nOur outter loop will represent our length - 1, `len`.\\nOur inner loop will represent our left pointer, `i`.\\nTherefore, our right pointer will be represented by `i+len`. This makes our logic a bit easier:\\n* Our base cases are when `len` is 0 or 1 (i.e. when the length of the substring is of length 1 or 2). In these situations, DP won\\'t work. Thankfully, all we need to check for is whether `s.charAt(i) == s.charAt(i + len)`. \\n* For `len > 1`, we would also need to check whether the inner substring is a palindrome as illustrated above. Therefore, we\\'ll also check if `dp[i+1][i+len-1]` is true.\\n\\nThere are a few ways we could keep track of our longest substring. We could just assign a new substring whenever our current window length is greater than the current string\\'s length. However, assigning a new substring on each update takes `O(n)` time at worst. Therefore, we\\'ll just keep track of the indices of our longest substring using `start` and `end` and we\\'ll only convert this into a substring at the end.\\n\\nAwesome, we now have everything we need to start coding!\\n___\\n### Code:\\nIf you have any questions, suggestions or improvements, feel free to let me know. Thanks for reading!\\n```java\\npublic String longestPalindrome(String s) {\\n\\tint n = s.length(), start = 0, end = 0;\\n\\tboolean[][] dp = new boolean[n][n];\\n\\n\\tfor (int len=0; len<n; len++) {\\n\\t\\tfor (int i=0; i+len<n; i++) {\\n\\t\\t\\tdp[i][i+len] = s.charAt(i) == s.charAt(i+len) && (len < 2 || dp[i+1][i+len-1]);\\n\\t\\t\\tif (dp[i][i+len] && len > end - start) {\\n\\t\\t\\t\\tstart = i;\\n\\t\\t\\t\\tend = i + len;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\n\\treturn s.substring(start, end + 1);\\n}\\n```\\n**Time Complexity:** `O(n^2)`\\n**Space Complexity:** `O(n^2)`\\n> Note: DP is NOT a space-optimal solution. However, I believe the dynamic relationship is quite an important relationship to know when tackling palindrome questions as it quite heavilly applies to questions outside this one. If you use DP in an interview for this question, that should be more than enough to pass the question :)",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "```java\\npublic String longestPalindrome(String s) {\\n\\tint n = s.length(), start = 0, end = 0;\\n\\tboolean[][] dp = new boolean[n][n];\\n\\n\\tfor (int len=0; len<n; len++) {\\n\\t\\tfor (int i=0; i+len<n; i++) {\\n\\t\\t\\tdp[i][i+len] = s.charAt(i) == s.charAt(i+len) && (len < 2 || dp[i+1][i+len-1]);\\n\\t\\t\\tif (dp[i][i+len] && len > end - start) {\\n\\t\\t\\t\\tstart = i;\\n\\t\\t\\t\\tend = i + len;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\n\\treturn s.substring(start, end + 1);\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2671545,
                "title": "c-easy-fast-and-short-code",
                "content": "```\\nclass Solution {\\npublic:\\n    int check(string &s, int L, int R)\\n    {\\n        while(L>=0 and R<s.length() and s[L]==s[R])\\n        {\\n            L--;\\n            R++;\\n        }\\n        return R-L-1;\\n    }\\n    \\n    string longestPalindrome(string s) {\\n        \\n        int ans = 0, st=0;\\n        int n = s.length();\\n        \\n        for(int i = 0;i<n;i++)\\n        {\\n            int len1 = check(s, i,i);\\n            int len2 = check(s, i, i+1);\\n            \\n            int len = max(len1, len2);\\n            \\n            if(len> ans)\\n            {\\n                ans = len;\\n                st = i-(len-1)/2;\\n            }\\n        }\\n        return s.substr(st, ans);\\n    }\\n};\\n```\\n**UPVOTE**",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int check(string &s, int L, int R)\\n    {\\n        while(L>=0 and R<s.length() and s[L]==s[R])\\n        {\\n            L--;\\n            R++;\\n        }\\n        return R-L-1;\\n    }\\n    \\n    string longestPalindrome(string s) {\\n        \\n        int ans = 0, st=0;\\n        int n = s.length();\\n        \\n        for(int i = 0;i<n;i++)\\n        {\\n            int len1 = check(s, i,i);\\n            int len2 = check(s, i, i+1);\\n            \\n            int len = max(len1, len2);\\n            \\n            if(len> ans)\\n            {\\n                ans = len;\\n                st = i-(len-1)/2;\\n            }\\n        }\\n        return s.substr(st, ans);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 354582,
                "title": "java-easy-to-understand-dp-solution-with-comments",
                "content": "```\\npublic class Solution {\\n\\n    public String longestPalindrome(String s) {\\n        if (s.length() == 0) {\\n            return \"\";\\n        }\\n\\t\\t//Dp array for substring palindrome\\n        boolean[][] dp = new boolean[s.length()][s.length()];\\n        int start = 0, end = 0;\\n\\n        for (int i = 0; i < s.length(); ++i) {\\n            for (int j = i; j >= 0; --j) {\\n                boolean startEqEnd = s.charAt(j) == s.charAt(i);\\n\\n                if (i == j) {\\n                    //If the same char: \\'a\\' is palindrome\\n                    dp[i][j] = true;\\n                } else if (i - j == 1) {\\n                    //If length 2: \\'ab\\' is palindrome when \\'a\\' == \\'b\\'\\n                    dp[i][j] = startEqEnd;\\n                } else if (startEqEnd && dp[i - 1][j + 1]) {\\n                    //Otherwise: string is palindrome if s(i) == s(j) and substring s(j + 1, i - 1) is palindrome\\n                    dp[i][j] = true;\\n                }\\n\\n                if (dp[i][j] && i - j > end - start ) {\\n                    end = i;\\n                    start = j;\\n                }\\n            }\\n        }\\n\\n        return s.substring(start, end + 1);\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "```\\npublic class Solution {\\n\\n    public String longestPalindrome(String s) {\\n        if (s.length() == 0) {\\n            return \"\";\\n        }\\n\\t\\t//Dp array for substring palindrome\\n        boolean[][] dp = new boolean[s.length()][s.length()];\\n        int start = 0, end = 0;\\n\\n        for (int i = 0; i < s.length(); ++i) {\\n            for (int j = i; j >= 0; --j) {\\n                boolean startEqEnd = s.charAt(j) == s.charAt(i);\\n\\n                if (i == j) {\\n                    //If the same char: \\'a\\' is palindrome\\n                    dp[i][j] = true;\\n                } else if (i - j == 1) {\\n                    //If length 2: \\'ab\\' is palindrome when \\'a\\' == \\'b\\'\\n                    dp[i][j] = startEqEnd;\\n                } else if (startEqEnd && dp[i - 1][j + 1]) {\\n                    //Otherwise: string is palindrome if s(i) == s(j) and substring s(j + 1, i - 1) is palindrome\\n                    dp[i][j] = true;\\n                }\\n\\n                if (dp[i][j] && i - j > end - start ) {\\n                    end = i;\\n                    start = j;\\n                }\\n            }\\n        }\\n\\n        return s.substring(start, end + 1);\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 873279,
                "title": "c-solutions-expand-around-center-dp-manacher",
                "content": "**C++:**\\n\\n**4 Solutions:**\\n\\n**(1) Expand around center:**\\n\\n```\\nvoid isPalindrome(const string& s,const int& length,int left,int right, int& start, int& maxlen){\\n\\twhile(left>=0 && right<length && s[left]==s[right]) --left,++right;\\n\\tif(maxlen < right-left-1)   maxlen = right-left-1, start = left+1;\\n}\\nstring longestPalindrome(string s) {\\n\\tint n = s.size(),start=0,maxlen=0;\\n\\tif(n<2) return s;\\n\\tfor(int i=0;i<n-1;++i){\\n\\t\\tisPalindrome(s,n,i,i,start,maxlen); //aba\\n\\t\\tisPalindrome(s,n,i,i+1,start,maxlen); //noon\\n\\t}\\n\\treturn s.substr(start,maxlen);\\n}\\n```\\n**(2) Expand around center optimization:**\\n```\\nstring longestPalindrome(string s) {\\n\\tint n = s.size(),start=0,maxlen=0;\\n\\tint left=0,right=0;\\n\\tif(n<2) return s;\\n\\tfor(int i=0;i<n-1;){\\n\\t\\tleft=i, right=i;\\n\\t\\twhile(right<n && s[right]==s[right+1]) ++right;\\n\\t\\ti=right+1;\\n\\t\\twhile(left>=0 && right<n && s[left]==s[right]) --left,++right;\\n\\t\\tif(maxlen < right-left-1)   maxlen = right-left-1, start = left+1;         \\n\\t}\\n\\treturn s.substr(start,maxlen);\\n}\\n```\\n**(3) Dynamic Programming**\\n```\\nstring longestPalindrome(string s) {\\n\\tconst int n = s.size();\\n\\tif(n==0) return \"\";\\n\\tint dp[n][n], maxlen =1 , left=0;// maxlen = 1 when only one word\\n\\tmemset(dp,0,n*n*sizeof(int));\\n\\tfor(int i=0;i<n;++i){\\n\\t\\tdp[i][i] = 1;\\n\\t\\tfor(int j=0;j<i;++j){\\n\\t\\t\\tdp[j][i] = (s[j]==s[i]  && (i-j< 2 || dp[j+1][i-1]));\\n\\t\\t\\tif(dp[j][i] && maxlen < i-j+1){\\n\\t\\t\\t\\tleft = j;\\n\\t\\t\\t\\tmaxlen = i-j+1;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\treturn s.substr(left,maxlen);\\n}\\n```\\n**(4) Manacher\\'s Algo**\\n\\nGraph:\\n\\n`- - - - -  imirror - - - - -  Center - - - - - i - - - - - right - - - - - `\\n\\n```\\nstring longestPalindrome(string s) {\\n\\tstring t =\"#\";//transform s to t\\n\\tfor (int i=0;i<s.size();++i)\\n\\t\\tt+=s[i], t+=\\'#\\';\\n\\tconst int t_len = t.size();\\n\\tint p[t_len]; //array to record longest palindrome length\\n\\tint center=0, right=0;//right index of the longest palindrome\\n\\tint rescenter=0, maxlen=0; //longest palindrome\\'s center and length\\n\\tmemset(p,0,t_len*sizeof(int));\\n\\tfor (int i = 1; i < t_len-1; ++i) {\\n\\t\\tint imirror = 2*center-i; //imirror-center = center-i\\n\\t\\tp[i]=right>i?min(p[imirror], right-i):0;\\n\\t\\twhile(i>p[i] && i+p[i]+1<t_len && t[i+p[i]+1]==t[i-p[i]-1]) //expand palindrome center at i\\n\\t\\t\\t++p[i];\\n\\t\\tif(right<i+p[i])\\n\\t\\t\\tright=i+p[i], center=i;\\n\\t\\tif(maxlen<p[i])\\n\\t\\t\\tmaxlen=p[i], rescenter=i;    \\n\\t}\\n\\treturn s.substr((rescenter-maxlen)/2, maxlen);\\n}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nvoid isPalindrome(const string& s,const int& length,int left,int right, int& start, int& maxlen){\\n\\twhile(left>=0 && right<length && s[left]==s[right]) --left,++right;\\n\\tif(maxlen < right-left-1)   maxlen = right-left-1, start = left+1;\\n}\\nstring longestPalindrome(string s) {\\n\\tint n = s.size(),start=0,maxlen=0;\\n\\tif(n<2) return s;\\n\\tfor(int i=0;i<n-1;++i){\\n\\t\\tisPalindrome(s,n,i,i,start,maxlen); //aba\\n\\t\\tisPalindrome(s,n,i,i+1,start,maxlen); //noon\\n\\t}\\n\\treturn s.substr(start,maxlen);\\n}\\n```\n```\\nstring longestPalindrome(string s) {\\n\\tint n = s.size(),start=0,maxlen=0;\\n\\tint left=0,right=0;\\n\\tif(n<2) return s;\\n\\tfor(int i=0;i<n-1;){\\n\\t\\tleft=i, right=i;\\n\\t\\twhile(right<n && s[right]==s[right+1]) ++right;\\n\\t\\ti=right+1;\\n\\t\\twhile(left>=0 && right<n && s[left]==s[right]) --left,++right;\\n\\t\\tif(maxlen < right-left-1)   maxlen = right-left-1, start = left+1;         \\n\\t}\\n\\treturn s.substr(start,maxlen);\\n}\\n```\n```\\nstring longestPalindrome(string s) {\\n\\tconst int n = s.size();\\n\\tif(n==0) return \"\";\\n\\tint dp[n][n], maxlen =1 , left=0;// maxlen = 1 when only one word\\n\\tmemset(dp,0,n*n*sizeof(int));\\n\\tfor(int i=0;i<n;++i){\\n\\t\\tdp[i][i] = 1;\\n\\t\\tfor(int j=0;j<i;++j){\\n\\t\\t\\tdp[j][i] = (s[j]==s[i]  && (i-j< 2 || dp[j+1][i-1]));\\n\\t\\t\\tif(dp[j][i] && maxlen < i-j+1){\\n\\t\\t\\t\\tleft = j;\\n\\t\\t\\t\\tmaxlen = i-j+1;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\treturn s.substr(left,maxlen);\\n}\\n```\n```\\nstring longestPalindrome(string s) {\\n\\tstring t =\"#\";//transform s to t\\n\\tfor (int i=0;i<s.size();++i)\\n\\t\\tt+=s[i], t+=\\'#\\';\\n\\tconst int t_len = t.size();\\n\\tint p[t_len]; //array to record longest palindrome length\\n\\tint center=0, right=0;//right index of the longest palindrome\\n\\tint rescenter=0, maxlen=0; //longest palindrome\\'s center and length\\n\\tmemset(p,0,t_len*sizeof(int));\\n\\tfor (int i = 1; i < t_len-1; ++i) {\\n\\t\\tint imirror = 2*center-i; //imirror-center = center-i\\n\\t\\tp[i]=right>i?min(p[imirror], right-i):0;\\n\\t\\twhile(i>p[i] && i+p[i]+1<t_len && t[i+p[i]+1]==t[i-p[i]-1]) //expand palindrome center at i\\n\\t\\t\\t++p[i];\\n\\t\\tif(right<i+p[i])\\n\\t\\t\\tright=i+p[i], center=i;\\n\\t\\tif(maxlen<p[i])\\n\\t\\t\\tmaxlen=p[i], rescenter=i;    \\n\\t}\\n\\treturn s.substr((rescenter-maxlen)/2, maxlen);\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 422495,
                "title": "clean-and-minimal-c-solution-4ms-98-40-easy-to-understand-expanding-window",
                "content": "```\\nstring longestPalindrome(string s) {\\n    if (s.size() <= 1) return s;\\n    int maxIdx = 0;\\n    int maxLen = 1;\\n    int i = 0;\\n\\n    while (i < s.size()) {\\n        int start = i;\\n        int end = i;\\n\\n        // expand the window from the end if it\\'s an even palindrome\\n        while (end + 1 < s.size() && s[end] == s[end + 1]) { end++; }\\n        i = end + 1;\\n\\n        // expand the window from both sides until it\\'s not longer a palindrome\\n        while (start - 1 >= 0 && end + 1 < s.size() && s[start - 1] == s[end + 1]) {\\n            start--, end++;\\n        }\\n\\n        int currLen = end - start + 1;\\n        if (currLen > maxLen) {\\n            maxIdx = start;\\n            maxLen = currLen;\\n        }\\n    }\\n\\n    return s.substr(maxIdx, maxLen);\\n}\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nstring longestPalindrome(string s) {\\n    if (s.size() <= 1) return s;\\n    int maxIdx = 0;\\n    int maxLen = 1;\\n    int i = 0;\\n\\n    while (i < s.size()) {\\n        int start = i;\\n        int end = i;\\n\\n        // expand the window from the end if it\\'s an even palindrome\\n        while (end + 1 < s.size() && s[end] == s[end + 1]) { end++; }\\n        i = end + 1;\\n\\n        // expand the window from both sides until it\\'s not longer a palindrome\\n        while (start - 1 >= 0 && end + 1 < s.size() && s[start - 1] == s[end + 1]) {\\n            start--, end++;\\n        }\\n\\n        int currLen = end - start + 1;\\n        if (currLen > maxLen) {\\n            maxIdx = start;\\n            maxLen = currLen;\\n        }\\n    }\\n\\n    return s.substr(maxIdx, maxLen);\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2967,
                "title": "22-line-c-manacher-u2019s-algorithm-o-n-solution",
                "content": "This implements the Manacher's Algorithm, which is illustrated here: http://articles.leetcode.com/2011/11/longest-palindromic-substring-part-ii.html. Although there are nested loops, there is shortcut in computation, so it is still O(n). \\n\\n\\n    class Solution {\\n    public:\\n        string longestPalindrome(string s) \\n        {\\n            string T;// Transform S to T\\n            for(int i=0;i<s.size();i++)\\n                T+=\"#\"+s.substr(i,1);\\n            T.push_back('#');\\n    \\n            vector<int> P(T.size(),0); // Array to record longest palindrome\\n            int center=0,boundary=0,maxLen=0,resCenter=0;\\n            for(int i=1;i<T.size()-1;i++) {\\n                int iMirror=2*center-i; // calc mirror i = center-(i-center)\\n                P[i]=(boundary>i)?min(boundary-i,P[iMirror]):0; // shortcut\\n                while(i-1-P[i]>=0&&i+1+P[i]<=T.size()-1&&T[i+1+P[i]] == T[i-1-P[i]]) // Attempt to expand palindrome centered at i\\n                    P[i]++;\\n                if(i+P[i]>boundary) { // update center and boundary\\n                    center = i;\\n                    boundary = i+P[i];\\n                }\\n                if(P[i]>maxLen) { // update result\\n                    maxLen = P[i];\\n                    resCenter = i;\\n                }    \\n            }\\n            return s.substr((resCenter - maxLen)/2, maxLen);\\n        }\\n    };",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n        string longestPalindrome(string s) \\n        {\\n            string T;// Transform S to T\\n            for(int i=0;i<s.size();i++)\\n                T+=\"#\"+s.substr(i,1);\\n            T.push_back('#');\\n    \\n            vector<int> P(T.size(),0); // Array to record longest palindrome\\n            int center=0,boundary=0,maxLen=0,resCenter=0;\\n            for(int i=1;i<T.size()-1;i++) {\\n                int iMirror=2*center-i; // calc mirror i = center-(i-center)\\n                P[i]=(boundary>i)?min(boundary-i,P[iMirror]):0; // shortcut\\n                while(i-1-P[i]>=0&&i+1+P[i]<=T.size()-1&&T[i+1+P[i]] == T[i-1-P[i]]) // Attempt to expand palindrome centered at i\\n                    P[i]++;\\n                if(i+P[i]>boundary) { // update center and boundary\\n                    center = i;\\n                    boundary = i+P[i];\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 2965,
                "title": "clean-and-simple-java-solution-with-comments",
                "content": "    public String longestPalindrome(String s) {\\n\\tif (s.isEmpty()) {\\n\\t\\treturn null;\\n\\t}\\n \\n\\tif (s.length() == 1) {\\n\\t\\treturn s;\\n\\t}\\n \\n\\tString longest = s.substring(0, 1);\\n\\tfor (int i = 0; i < s.length(); i++) {\\n\\t    \\n\\t\\t// get longest palindrome with center of i\\n\\t\\tString tmp = helper(s, i, i);\\n\\t    \\tif (tmp.length() > longest.length()) {\\n\\t\\t\\tlongest = tmp;\\n\\t    \\t}\\n\\t\\t\\n\\t\\t// get longest palindrome with center of i, i+1\\n\\t\\ttmp = helper(s, i, i + 1);\\n\\t\\t    if (tmp.length() > longest.length()) {\\n\\t\\t\\tlongest = tmp;\\n\\t\\t    }\\n\\t\\t}\\n \\treturn longest;}\\n\\n    public String helper(String s, int begin, int end) {\\n\\t \\n    while (begin >= 0 && end <= s.length() - 1 && s.charAt(begin) == s.charAt(end)) {\\n\\n\\t\\tbegin--;\\n\\n\\t\\tend++;\\n\\n\\t}\\n\\t\\n     return s.substring(begin + 1, end);\\n    }",
                "solutionTags": [
                    "Java",
                    "String"
                ],
                "code": "    public String longestPalindrome(String s) {\\n\\tif (s.isEmpty()) {\\n\\t\\treturn null;\\n\\t}\\n \\n\\tif (s.length() == 1) {\\n\\t\\treturn s;\\n\\t}\\n \\n\\tString longest = s.substring(0, 1);\\n\\tfor (int i = 0; i < s.length(); i++) {\\n\\t    \\n\\t\\t// get longest palindrome with center of i\\n\\t\\tString tmp = helper(s, i, i);\\n\\t    \\tif (tmp.length() > longest.length()) {\\n\\t\\t\\tlongest = tmp;\\n\\t    \\t}\\n\\t\\t\\n\\t\\t// get longest palindrome with center of i, i+1\\n\\t\\ttmp = helper(s, i, i + 1);\\n\\t\\t    if (tmp.length() > longest.length()) {\\n\\t\\t\\tlongest = tmp;\\n\\t\\t    }\\n\\t\\t}\\n \\treturn longest;}\\n\\n    public String helper(String s, int begin, int end) {\\n\\t \\n    while (begin >= 0 && end <= s.length() - 1 && s.charAt(begin) == s.charAt(end)) {\\n\\n\\t\\tbegin--;\\n\\n\\t\\tend++;\\n\\n\\t}\\n\\t\\n     return s.substring(begin + 1, end);\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 119765,
                "title": "python-dp-solution",
                "content": "Python dynamic programming solution. No optimizations.\\n```\\nclass Solution:\\n    def longestPalindrome(self, string):\\n        \"\"\" Dynamic programming algorithm. Based on idea that current\\n        substring(i, j) is a palindrome if substring(i + 1, j - 1) is\\n        a palindrome and Si == Sj, i.e. In other words, if we already know that\\n        current substring is a palindrome we need to add equal characters on both\\n        sides to make a longer palindrome.\\n\\n        Time complexity: O(n ^ 2). Space complexity: O(n ^ 2), where\\n        n is the length of the string.\\n        \"\"\"\\n        # initialize 2-D table for storing results\\n        n = len(string)\\n        results = [[False] * n for i in range(n)]\\n        x, y = 0, 0  # start, end of longest palindromic substring so far\\n\\n        # every 1-letter substring is a palindrome\\n        for i in range(n):\\n            results[i][i] = True\\n\\n        # 2-letter substring(i, j) is a palindrome if string[i] == string[j]\\n        for i in range(n - 1):\\n            if string[i] == string[i + 1]:\\n                results[i][i + 1] = True\\n                # change longest palindrome to the 1st 2-letter palindrome\\n                if not x and not y:\\n                    x, y = i, i + 1\\n\\n        # results[i][j] = True if results[i + 1][j - 1] == True\\n        # and string[i] == string[j]\\n        for k in range(2, n):\\n            for i in range(n - 2):\\n                j = i + k\\n                # break the loop if it exceeds the boundaries of the matrix\\n                if j == n:\\n                    break\\n                # check if current substring is a palindrome\\n                if results[i + 1][j - 1] and string[i] == string[j]:\\n                    results[i][j] = True\\n                    # len(substring(i, j)) > len(substring(x, y))\\n                    # this way we always choose 1st longest palindrome\\n                    if j - i > y - x:\\n                        x, y = i, j\\n\\n        return string[x:y + 1]\\n\\n\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def longestPalindrome(self, string):\\n        \"\"\" Dynamic programming algorithm. Based on idea that current\\n        substring(i, j) is a palindrome if substring(i + 1, j - 1) is\\n        a palindrome and Si == Sj, i.e. In other words, if we already know that\\n        current substring is a palindrome we need to add equal characters on both\\n        sides to make a longer palindrome.\\n\\n        Time complexity: O(n ^ 2). Space complexity: O(n ^ 2), where\\n        n is the length of the string.\\n        \"\"\"\\n        # initialize 2-D table for storing results\\n        n = len(string)\\n        results = [[False] * n for i in range(n)]\\n        x, y = 0, 0  # start, end of longest palindromic substring so far\\n\\n        # every 1-letter substring is a palindrome\\n        for i in range(n):\\n            results[i][i] = True\\n\\n        # 2-letter substring(i, j) is a palindrome if string[i] == string[j]\\n        for i in range(n - 1):\\n            if string[i] == string[i + 1]:\\n                results[i][i + 1] = True\\n                # change longest palindrome to the 1st 2-letter palindrome\\n                if not x and not y:\\n                    x, y = i, i + 1\\n\\n        # results[i][j] = True if results[i + 1][j - 1] == True\\n        # and string[i] == string[j]\\n        for k in range(2, n):\\n            for i in range(n - 2):\\n                j = i + k\\n                # break the loop if it exceeds the boundaries of the matrix\\n                if j == n:\\n                    break\\n                # check if current substring is a palindrome\\n                if results[i + 1][j - 1] and string[i] == string[j]:\\n                    results[i][j] = True\\n                    # len(substring(i, j)) > len(substring(x, y))\\n                    # this way we always choose 1st longest palindrome\\n                    if j - i > y - x:\\n                        x, y = i, j\\n\\n        return string[x:y + 1]\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3003,
                "title": "java-easy-understanding-solution-beats-97",
                "content": "    public String longestPalindrome(String s) {\\n        char[] ca = s.toCharArray();\\n        int rs = 0, re = 0;\\n        int max = 0;\\n        for(int i = 0; i < ca.length; i++) {\\n            if(isPalindrome(ca, i - max - 1, i)) {\\n                rs = i - max - 1; re = i;\\n                max += 2;\\n            } else if(isPalindrome(ca, i - max, i)) {\\n                rs = i - max; re = i;\\n                max += 1;\\n            }\\n        }\\n        return s.substring(rs, re + 1);\\n    }\\n    \\n    private boolean isPalindrome(char[] ca, int s, int e) {\\n        if(s < 0) return false;\\n        \\n        while(s < e) {\\n            if(ca[s++] != ca[e--]) return false;\\n        }\\n        return true;\\n    }",
                "solutionTags": [],
                "code": "    public String longestPalindrome(String s) {\\n        char[] ca = s.toCharArray();\\n        int rs = 0, re = 0;\\n        int max = 0;\\n        for(int i = 0; i < ca.length; i++) {\\n            if(isPalindrome(ca, i - max - 1, i)) {\\n                rs = i - max - 1; re = i;\\n                max += 2;\\n            } else if(isPalindrome(ca, i - max, i)) {\\n                rs = i - max; re = i;\\n                max += 1;\\n            }\\n        }\\n        return s.substring(rs, re + 1);\\n    }\\n    \\n    private boolean isPalindrome(char[] ca, int s, int e) {\\n        if(s < 0) return false;\\n        \\n        while(s < e) {\\n            if(ca[s++] != ca[e--]) return false;\\n        }\\n        return true;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 3497051,
                "title": "c-java-python-javascript-detailed-explanation-easy-solution-3-approaches",
                "content": "# 1. Brute Force Approach\\n\\n# Intuition:\\nThe problem asks to find the longest palindrome in a given string. A palindrome is a string that is the same when read from both ends. For example, \"racecar\" is a palindrome because it is the same when read from left to right and right to left.\\n\\n# Approach:\\n1. We start by iterating through all possible substrings of the given string using two nested loops, i and j, where i represents the starting index and j represents the ending index of the substring.\\n2. For each substring, we check if it is a palindrome or not by using a helper function check(), which takes the starting and ending indices of the substring and returns true if it is a palindrome and false otherwise.\\n3. If the substring is a palindrome, we update the maximum length of palindromic substring seen so far and the starting index of this substring.\\n4. After iterating through all possible substrings, we return the longest palindromic substring.\\n\\n# Complexity:\\n- Time Complexity: The time complexity of the above solution is O(n^3) because we have two nested loops and for each substring, we check whether it\\'s a palindrome or not using another loop. In the worst case, the check function will be called for each substring, which takes O(n) time, making the overall time complexity O(n^3).\\n- Space Complexity: The space complexity of the solution is O(1) because we are not using any additional space apart from a few integer variables to keep track of the longest palindromic substring seen so far.\\n---\\n# C++\\n```\\nclass Solution {\\npublic:\\n    bool check(string &s, int i, int j){\\n        while(i<j){\\n            if(s[i] != s[j]){\\n                return false;\\n            }\\n            i++;\\n            j--;\\n        }\\n        return true;\\n    }            \\n    string longestPalindrome(string s) {\\n        int n = s.size();\\n        int starting_index = 0;\\n        int max_len = 0;\\n        for(int i=0; i<n; i++){\\n            for(int j=i; j<n; j++){\\n                if(check(s, i, j)){\\n                    if(j-i+1 > max_len){\\n                        max_len = j-i+1;\\n                        starting_index = i;\\n                    }\\n                }\\n            }\\n        }\\n        return s.substr(starting_index, max_len);\\n    }\\n}; \\n```\\n\\n---\\n# JAVA\\n```\\nclass Solution {\\n    public boolean check(String s, int i, int j){\\n        while(i<j){\\n            if(s.charAt(i) != s.charAt(j)){\\n                return false;\\n            }\\n            i++;\\n            j--;\\n        }\\n        return true;\\n    }            \\n    public String longestPalindrome(String s) {\\n        int n = s.length();\\n        int starting_index = 0;\\n        int max_len = 0;\\n        for(int i=0; i<n; i++){\\n            for(int j=i; j<n; j++){\\n                if(check(s, i, j)){\\n                    if(j-i+1 > max_len){\\n                        max_len = j-i+1;\\n                        starting_index = i;\\n                    }\\n                }\\n            }\\n        }\\n        return s.substring(starting_index, starting_index+max_len);\\n    }\\n}\\n```\\n---\\n# Python\\n```\\nclass Solution(object):\\n    def check(self, s, i, j):\\n        while i<j:\\n            if s[i] != s[j]:\\n                return False\\n            i += 1\\n            j -= 1\\n        return True\\n    \\n    def longestPalindrome(self, s):\\n        n = len(s)\\n        starting_index = 0\\n        max_len = 0\\n        for i in range(n):\\n            for j in range(i, n):\\n                if self.check(s, i, j):\\n                    if j-i+1 > max_len:\\n                        max_len = j-i+1\\n                        starting_index = i\\n        return s[starting_index:starting_index+max_len]\\n\\n```\\n---\\n# JavaScript\\n```\\nvar check = function(s, i, j) {\\n    while (i < j) {\\n        if (s[i] !== s[j]) {\\n            return false;\\n        }\\n        i++;\\n        j--;\\n    }\\n    return true;\\n}\\n\\nvar longestPalindrome = function(s) {\\n    const n = s.length;\\n    let starting_index = 0;\\n    let max_len = 0;\\n    for (let i = 0; i < n; i++) {\\n        for (let j = i; j < n; j++) {\\n            if (check(s, i, j)) {\\n                if (j - i + 1 > max_len) {\\n                    max_len = j - i + 1;\\n                    starting_index = i;\\n                }\\n            }\\n        }\\n    }\\n    return s.substring(starting_index, starting_index + max_len);\\n}\\n```\\n\\n---\\n# 2. Better Approach\\n# Intuition:\\nA Better approach is to use dynamic programming to solve the problem. We can define a two-dimensional boolean array dp where dp[i][j] represents whether the substring s[i:j+1] is a palindrome or not. We can then fill in the dp array starting with substrings of length 1 and 2, and then use these values to fill in the values for longer substrings. We can keep track of the longest palindrome substring found so far and return it at the end.\\n\\n\\n# Approach:\\n\\n1. Create a two-dimensional boolean array dp of size n x n, where n is the length of the input string s. Initialize all values of dp to false.\\n\\n2. Iterate over the string s and mark all substrings of length 1 as palindromes, i.e., set dp[i][i] to true for all i from 0 to n-1. Also, initialize a string variable ans to the first character of the input string s and a variable maxLength to 1.\\n\\n3. For substrings of length 2 and greater, iterate over all possible substring lengths len from 2 to n. For each length, iterate over all possible starting indices i from 0 to n-len. Calculate the ending index j as j = i + len - 1.\\n\\n4. If s[i] == s[j], then check if the substring s[i+1:j] is a palindrome by checking if dp[i+1][j-1] is true. If it is true or len == 2, then set dp[i][j] to true and update ans and maxLength if the current substring is longer than the current longest palindrome substring.\\n\\n5. After filling in the dp array, return the string variable ans, which contains the longest palindrome substring found.\\n\\n\\n# Complexity:\\n\\n- Time Complexity: O(n^2) where n is the length of the input string. This is because we are filling in a two-dimensional boolean array of size n x n and checking each substring only once.\\n\\n- Space Complexity: O(n^2) where n is the length of the input string. This is because we are using a two-dimensional boolean array of size n x n to store the intermediate results.\\n\\n# C++\\n```\\nclass Solution {\\npublic:\\n    string longestPalindrome(string s) {\\n        int n = s.size();\\n        vector<vector<bool>> dp(n, vector<bool>(n, false));\\n        string ans = \"\";\\n        int maxLength = 0;\\n        \\n        // Base case: all substrings of length 1 are palindromes\\n        for (int i = 0; i < n; i++) {\\n            dp[i][i] = true;\\n            ans = s[i];\\n            maxLength = 1;\\n        }\\n        \\n        // Fill in the dp table for substrings of length 2 and greater\\n        for (int len = 2; len <= n; len++) {\\n            for (int i = 0; i < n-len+1; i++) {\\n                int j = i+len-1;\\n                if (s[i] == s[j]) {\\n                    if (len == 2 || dp[i+1][j-1]) {\\n                        dp[i][j] = true;\\n                        if (len > maxLength) {\\n                            ans = s.substr(i, len);\\n                            maxLength = len;\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```\\n\\n---\\n# Python\\n```\\nclass Solution(object):\\n    def longestPalindrome(self, s):\\n        n = len(s)\\n        dp = [[False for i in range(n)] for j in range(n)]\\n        ans = \"\"\\n        maxLength = 0\\n        \\n        # Base case: all substrings of length 1 are palindromes\\n        for i in range(n):\\n            dp[i][i] = True\\n            ans = s[i]\\n            maxLength = 1\\n        \\n        # Fill in the dp table for substrings of length 2 and greater\\n        for length in range(2, n+1):\\n            for i in range(n-length+1):\\n                j = i+length-1\\n                if s[i] == s[j]:\\n                    if length == 2 or dp[i+1][j-1]:\\n                        dp[i][j] = True\\n                        if length > maxLength:\\n                            ans = s[i:i+length]\\n                            maxLength = length\\n        \\n        return ans\\n\\n```\\n---\\n# JAVA\\n```\\npublic class Solution {\\n    public String longestPalindrome(String s) {\\n        int n = s.length();\\n        boolean[][] dp = new boolean[n][n];\\n        String ans = \"\";\\n        int maxLength = 0;\\n\\n        // Base case: all substrings of length 1 are palindromes\\n        for (int i = 0; i < n; i++) {\\n            dp[i][i] = true;\\n            ans = s.substring(i, i+1);\\n            maxLength = 1;\\n        }\\n\\n        // Fill in the dp table for substrings of length 2 and greater\\n        for (int len = 2; len <= n; len++) {\\n            for (int i = 0; i < n-len+1; i++) {\\n                int j = i+len-1;\\n                if (s.charAt(i) == s.charAt(j)) {\\n                    if (len == 2 || dp[i+1][j-1]) {\\n                        dp[i][j] = true;\\n                        if (len > maxLength) {\\n                            ans = s.substring(i, i+len);\\n                            maxLength = len;\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n\\n        return ans;\\n    }\\n}\\n\\n```\\n\\n---\\n# JavaScript\\n```\\nvar longestPalindrome = function(s) {\\n    var n = s.length;\\n    var dp = Array.from({length: n}, () => Array(n).fill(false));\\n    var ans = \"\";\\n    var maxLength = 0;\\n\\n    // Base case: all substrings of length 1 are palindromes\\n    for (var i = 0; i < n; i++) {\\n        dp[i][i] = true;\\n        ans = s[i];\\n        maxLength = 1;\\n    }\\n\\n    // Fill in the dp table for substrings of length 2 and greater\\n    for (var len = 2; len <= n; len++) {\\n        for (var i = 0; i < n-len+1; i++) {\\n            var j = i+len-1;\\n            if (s[i] == s[j]) {\\n                if (len == 2 || dp[i+1][j-1]) {\\n                    dp[i][j] = true;\\n                    if (len > maxLength) {\\n                        ans = s.substring(i, i+len);\\n                        maxLength = len;\\n                    }\\n                }\\n            }\\n        }\\n    }\\n\\n    return ans;\\n};\\n\\n```\\n\\n---\\n\\n# 3. Optimal Approach\\n# Intuition:\\nThe given code aims to find the longest palindrome in a given string. It uses a two-pointer approach to expand around each center and checks if the characters on both sides are equal. The variable `minstart` keeps track of the starting index of the longest palindrome found so far, and `maxlen` stores its length.\\n\\n# Approach:\\n1. Initialize variables `minstart` and `maxlen` as 0 to keep track of the longest palindrome found so far.\\n2. Iterate over each character in the string using a variable `i`.\\n3. Check if the remaining length from `i` to the end of the string is less than half of the `maxlen`. If it is, there is no possibility of finding a longer palindrome, so we break out of the loop.\\n4. Set `l` and `r` as `i`, representing the left and right pointers of the potential palindrome.\\n5. While `r` is within the string bounds and the character at `r` is equal to the next character, increment `r`.\\n6. Update `i` to be `r + 1` since all the characters from `l` to `r` have been accounted for.\\n7. While `l` is greater than 0 and `r` is within the string bounds, and the characters at `l-1` and `r+1` are equal, decrement `l` and increment `r`.\\n8. Calculate the length of the potential palindrome using `newlen = r - l + 1`.\\n9. If `newlen` is greater than `maxlen`, update `maxlen` with `newlen` and `minstart` with `l`.\\n10. After the loop finishes, return the substring of `s` starting from `minstart` with length `maxlen`, which represents the longest palindrome found in the string.\\n\\n# Complexity:\\n- Time Complexity: The code uses a two-pointer approach to expand around each center, resulting in a linear time complexity of O(n), where n is the length of the string.\\n- Space Complexity: The code uses a constant amount of extra space, resulting in a space complexity of O(1).\\n# C++\\n```\\nclass Solution {\\npublic:\\n    string longestPalindrome(string s) {\\n        int n = s.size();\\n        if (n == 0)\\n            return \"\";\\n        if (n == 1)\\n            return s;\\n        \\n        int minstart = 0, maxlen = 0;\\n        \\n        for (int i = 0; i < n; ) {\\n            if (n - i < maxlen / 2)\\n                break;\\n            \\n            int l = i, r = i;\\n            \\n            // Find the center of the palindrome\\n            while (r < n && s[r] == s[r + 1])\\n                r++;\\n            \\n            // Update the next starting point\\n            i = r + 1;\\n            \\n            // Expand around the center to find the longest palindrome\\n            while (l > 0 && r < n && s[l - 1] == s[r + 1]) {\\n                l--;\\n                r++;\\n            }\\n            \\n            int newlen = r - l + 1;\\n            if (newlen > maxlen) {\\n                maxlen = newlen;\\n                minstart = l;\\n            }\\n        }\\n        \\n        return s.substr(minstart, maxlen);\\n    }\\n};\\n```\\n# JAVA\\n```\\nclass Solution {\\n    public String longestPalindrome(String s) {\\n        int n = s.length();\\n        if (n == 0)\\n            return \"\";\\n        if (n == 1)\\n            return s;\\n        \\n        int minstart = 0, maxlen = 0;\\n        \\n        for (int i = 0; i < n; ) {\\n            if (n - i < maxlen / 2)\\n                break;\\n            \\n            int l = i, r = i;\\n            \\n            // Find the center of the palindrome\\n            while (r < n - 1 && s.charAt(r) == s.charAt(r + 1))\\n                r++;\\n            \\n            // Update the next starting point\\n            i = r + 1;\\n            \\n            // Expand around the center to find the longest palindrome\\n            while (l > 0 && r < n - 1 && s.charAt(l - 1) == s.charAt(r + 1)) {\\n                l--;\\n                r++;\\n            }\\n            \\n            int newlen = r - l + 1;\\n            if (newlen > maxlen) {\\n                maxlen = newlen;\\n                minstart = l;\\n            }\\n        }\\n        \\n        return s.substring(minstart, minstart + maxlen);\\n    }\\n}\\n\\n```\\n# Python\\n```\\nclass Solution(object):\\n    def longestPalindrome(self, s):\\n        n = len(s)\\n        if n == 0:\\n            return \"\"\\n        if n == 1:\\n            return s\\n        \\n        minstart = 0\\n        maxlen = 0\\n        \\n        i = 0\\n        while i < n:\\n            if n - i < maxlen / 2:\\n                break\\n            \\n            l = i\\n            r = i\\n            \\n            # Find the center of the palindrome\\n            while r < n - 1 and s[r] == s[r + 1]:\\n                r += 1\\n            \\n            # Update the next starting point\\n            i = r + 1\\n            \\n            # Expand around the center to find the longest palindrome\\n            while l > 0 and r < n - 1 and s[l - 1] == s[r + 1]:\\n                l -= 1\\n                r += 1\\n            \\n            newlen = r - l + 1\\n            if newlen > maxlen:\\n                maxlen = newlen\\n                minstart = l\\n        \\n        return s[minstart:minstart + maxlen]\\n\\n```\\n# JavaScript\\n```\\nvar longestPalindrome = function(s) {\\n    const n = s.length;\\n    if (n === 0)\\n        return \"\";\\n    if (n === 1)\\n        return s;\\n\\n    let minstart = 0, maxlen = 0;\\n\\n    let i = 0;\\n    while (i < n) {\\n        if (n - i < maxlen / 2)\\n            break;\\n\\n        let l = i, r = i;\\n\\n        // Find the center of the palindrome\\n        while (r < n - 1 && s[r] === s[r + 1])\\n            r++;\\n\\n        // Update the next starting point\\n        i = r + 1;\\n\\n        // Expand around the center to find the longest palindrome\\n        while (l > 0 && r < n - 1 && s[l - 1] === s[r + 1]) {\\n            l--;\\n            r++;\\n        }\\n\\n        const newlen = r - l + 1;\\n        if (newlen > maxlen) {\\n            maxlen = newlen;\\n            minstart = l;\\n        }\\n    }\\n\\n    return s.substring(minstart, minstart + maxlen);\\n}\\n\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "JavaScript",
                    "String"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool check(string &s, int i, int j){\\n        while(i<j){\\n            if(s[i] != s[j]){\\n                return false;\\n            }\\n            i++;\\n            j--;\\n        }\\n        return true;\\n    }            \\n    string longestPalindrome(string s) {\\n        int n = s.size();\\n        int starting_index = 0;\\n        int max_len = 0;\\n        for(int i=0; i<n; i++){\\n            for(int j=i; j<n; j++){\\n                if(check(s, i, j)){\\n                    if(j-i+1 > max_len){\\n                        max_len = j-i+1;\\n                        starting_index = i;\\n                    }\\n                }\\n            }\\n        }\\n        return s.substr(starting_index, max_len);\\n    }\\n}; \\n```\n```\\nclass Solution {\\n    public boolean check(String s, int i, int j){\\n        while(i<j){\\n            if(s.charAt(i) != s.charAt(j)){\\n                return false;\\n            }\\n            i++;\\n            j--;\\n        }\\n        return true;\\n    }            \\n    public String longestPalindrome(String s) {\\n        int n = s.length();\\n        int starting_index = 0;\\n        int max_len = 0;\\n        for(int i=0; i<n; i++){\\n            for(int j=i; j<n; j++){\\n                if(check(s, i, j)){\\n                    if(j-i+1 > max_len){\\n                        max_len = j-i+1;\\n                        starting_index = i;\\n                    }\\n                }\\n            }\\n        }\\n        return s.substring(starting_index, starting_index+max_len);\\n    }\\n}\\n```\n```\\nclass Solution(object):\\n    def check(self, s, i, j):\\n        while i<j:\\n            if s[i] != s[j]:\\n                return False\\n            i += 1\\n            j -= 1\\n        return True\\n    \\n    def longestPalindrome(self, s):\\n        n = len(s)\\n        starting_index = 0\\n        max_len = 0\\n        for i in range(n):\\n            for j in range(i, n):\\n                if self.check(s, i, j):\\n                    if j-i+1 > max_len:\\n                        max_len = j-i+1\\n                        starting_index = i\\n        return s[starting_index:starting_index+max_len]\\n\\n```\n```\\nvar check = function(s, i, j) {\\n    while (i < j) {\\n        if (s[i] !== s[j]) {\\n            return false;\\n        }\\n        i++;\\n        j--;\\n    }\\n    return true;\\n}\\n\\nvar longestPalindrome = function(s) {\\n    const n = s.length;\\n    let starting_index = 0;\\n    let max_len = 0;\\n    for (let i = 0; i < n; i++) {\\n        for (let j = i; j < n; j++) {\\n            if (check(s, i, j)) {\\n                if (j - i + 1 > max_len) {\\n                    max_len = j - i + 1;\\n                    starting_index = i;\\n                }\\n            }\\n        }\\n    }\\n    return s.substring(starting_index, starting_index + max_len);\\n}\\n```\n```\\nclass Solution {\\npublic:\\n    string longestPalindrome(string s) {\\n        int n = s.size();\\n        vector<vector<bool>> dp(n, vector<bool>(n, false));\\n        string ans = \"\";\\n        int maxLength = 0;\\n        \\n        // Base case: all substrings of length 1 are palindromes\\n        for (int i = 0; i < n; i++) {\\n            dp[i][i] = true;\\n            ans = s[i];\\n            maxLength = 1;\\n        }\\n        \\n        // Fill in the dp table for substrings of length 2 and greater\\n        for (int len = 2; len <= n; len++) {\\n            for (int i = 0; i < n-len+1; i++) {\\n                int j = i+len-1;\\n                if (s[i] == s[j]) {\\n                    if (len == 2 || dp[i+1][j-1]) {\\n                        dp[i][j] = true;\\n                        if (len > maxLength) {\\n                            ans = s.substr(i, len);\\n                            maxLength = len;\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```\n```\\nclass Solution(object):\\n    def longestPalindrome(self, s):\\n        n = len(s)\\n        dp = [[False for i in range(n)] for j in range(n)]\\n        ans = \"\"\\n        maxLength = 0\\n        \\n        # Base case: all substrings of length 1 are palindromes\\n        for i in range(n):\\n            dp[i][i] = True\\n            ans = s[i]\\n            maxLength = 1\\n        \\n        # Fill in the dp table for substrings of length 2 and greater\\n        for length in range(2, n+1):\\n            for i in range(n-length+1):\\n                j = i+length-1\\n                if s[i] == s[j]:\\n                    if length == 2 or dp[i+1][j-1]:\\n                        dp[i][j] = True\\n                        if length > maxLength:\\n                            ans = s[i:i+length]\\n                            maxLength = length\\n        \\n        return ans\\n\\n```\n```\\npublic class Solution {\\n    public String longestPalindrome(String s) {\\n        int n = s.length();\\n        boolean[][] dp = new boolean[n][n];\\n        String ans = \"\";\\n        int maxLength = 0;\\n\\n        // Base case: all substrings of length 1 are palindromes\\n        for (int i = 0; i < n; i++) {\\n            dp[i][i] = true;\\n            ans = s.substring(i, i+1);\\n            maxLength = 1;\\n        }\\n\\n        // Fill in the dp table for substrings of length 2 and greater\\n        for (int len = 2; len <= n; len++) {\\n            for (int i = 0; i < n-len+1; i++) {\\n                int j = i+len-1;\\n                if (s.charAt(i) == s.charAt(j)) {\\n                    if (len == 2 || dp[i+1][j-1]) {\\n                        dp[i][j] = true;\\n                        if (len > maxLength) {\\n                            ans = s.substring(i, i+len);\\n                            maxLength = len;\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n\\n        return ans;\\n    }\\n}\\n\\n```\n```\\nvar longestPalindrome = function(s) {\\n    var n = s.length;\\n    var dp = Array.from({length: n}, () => Array(n).fill(false));\\n    var ans = \"\";\\n    var maxLength = 0;\\n\\n    // Base case: all substrings of length 1 are palindromes\\n    for (var i = 0; i < n; i++) {\\n        dp[i][i] = true;\\n        ans = s[i];\\n        maxLength = 1;\\n    }\\n\\n    // Fill in the dp table for substrings of length 2 and greater\\n    for (var len = 2; len <= n; len++) {\\n        for (var i = 0; i < n-len+1; i++) {\\n            var j = i+len-1;\\n            if (s[i] == s[j]) {\\n                if (len == 2 || dp[i+1][j-1]) {\\n                    dp[i][j] = true;\\n                    if (len > maxLength) {\\n                        ans = s.substring(i, i+len);\\n                        maxLength = len;\\n                    }\\n                }\\n            }\\n        }\\n    }\\n\\n    return ans;\\n};\\n\\n```\n```\\nclass Solution {\\npublic:\\n    string longestPalindrome(string s) {\\n        int n = s.size();\\n        if (n == 0)\\n            return \"\";\\n        if (n == 1)\\n            return s;\\n        \\n        int minstart = 0, maxlen = 0;\\n        \\n        for (int i = 0; i < n; ) {\\n            if (n - i < maxlen / 2)\\n                break;\\n            \\n            int l = i, r = i;\\n            \\n            // Find the center of the palindrome\\n            while (r < n && s[r] == s[r + 1])\\n                r++;\\n            \\n            // Update the next starting point\\n            i = r + 1;\\n            \\n            // Expand around the center to find the longest palindrome\\n            while (l > 0 && r < n && s[l - 1] == s[r + 1]) {\\n                l--;\\n                r++;\\n            }\\n            \\n            int newlen = r - l + 1;\\n            if (newlen > maxlen) {\\n                maxlen = newlen;\\n                minstart = l;\\n            }\\n        }\\n        \\n        return s.substr(minstart, maxlen);\\n    }\\n};\\n```\n```\\nclass Solution {\\n    public String longestPalindrome(String s) {\\n        int n = s.length();\\n        if (n == 0)\\n            return \"\";\\n        if (n == 1)\\n            return s;\\n        \\n        int minstart = 0, maxlen = 0;\\n        \\n        for (int i = 0; i < n; ) {\\n            if (n - i < maxlen / 2)\\n                break;\\n            \\n            int l = i, r = i;\\n            \\n            // Find the center of the palindrome\\n            while (r < n - 1 && s.charAt(r) == s.charAt(r + 1))\\n                r++;\\n            \\n            // Update the next starting point\\n            i = r + 1;\\n            \\n            // Expand around the center to find the longest palindrome\\n            while (l > 0 && r < n - 1 && s.charAt(l - 1) == s.charAt(r + 1)) {\\n                l--;\\n                r++;\\n            }\\n            \\n            int newlen = r - l + 1;\\n            if (newlen > maxlen) {\\n                maxlen = newlen;\\n                minstart = l;\\n            }\\n        }\\n        \\n        return s.substring(minstart, minstart + maxlen);\\n    }\\n}\\n\\n```\n```\\nclass Solution(object):\\n    def longestPalindrome(self, s):\\n        n = len(s)\\n        if n == 0:\\n            return \"\"\\n        if n == 1:\\n            return s\\n        \\n        minstart = 0\\n        maxlen = 0\\n        \\n        i = 0\\n        while i < n:\\n            if n - i < maxlen / 2:\\n                break\\n            \\n            l = i\\n            r = i\\n            \\n            # Find the center of the palindrome\\n            while r < n - 1 and s[r] == s[r + 1]:\\n                r += 1\\n            \\n            # Update the next starting point\\n            i = r + 1\\n            \\n            # Expand around the center to find the longest palindrome\\n            while l > 0 and r < n - 1 and s[l - 1] == s[r + 1]:\\n                l -= 1\\n                r += 1\\n            \\n            newlen = r - l + 1\\n            if newlen > maxlen:\\n                maxlen = newlen\\n                minstart = l\\n        \\n        return s[minstart:minstart + maxlen]\\n\\n```\n```\\nvar longestPalindrome = function(s) {\\n    const n = s.length;\\n    if (n === 0)\\n        return \"\";\\n    if (n === 1)\\n        return s;\\n\\n    let minstart = 0, maxlen = 0;\\n\\n    let i = 0;\\n    while (i < n) {\\n        if (n - i < maxlen / 2)\\n            break;\\n\\n        let l = i, r = i;\\n\\n        // Find the center of the palindrome\\n        while (r < n - 1 && s[r] === s[r + 1])\\n            r++;\\n\\n        // Update the next starting point\\n        i = r + 1;\\n\\n        // Expand around the center to find the longest palindrome\\n        while (l > 0 && r < n - 1 && s[l - 1] === s[r + 1]) {\\n            l--;\\n            r++;\\n        }\\n\\n        const newlen = r - l + 1;\\n        if (newlen > maxlen) {\\n            maxlen = newlen;\\n            minstart = l;\\n        }\\n    }\\n\\n    return s.substring(minstart, minstart + maxlen);\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1640332,
                "title": "accepted-solution-for-swift",
                "content": "<blockquote>\\n<b>Disclaimer:</b> By using any content from this post or thread, you release the author(s) from all liability and warranty of any kind. You are free to use the content freely and as you see fit. Any suggestions for improvement are welcome and greatly appreciated! Happy coding!\\n</blockquote>\\n\\n```swift\\nclass Solution {\\n    func longestPalindrome(_ s: String) -> String {\\n        let len = s.count, arr = Array(s)\\n        if len <= 1 { return s }\\n        var lhs = 0, rhs = 0, dp = Array(repeating: Array(repeating: false, count: len), count: len)\\n        for i in 1..<len {\\n            for j in 0..<i where arr[j] == arr[i] && (dp[j+1][i-1] || i - j <= 2) {\\n                dp[j][i] = true\\n                if i - j > rhs - lhs {\\n                    lhs = j\\n                    rhs = i\\n                }\\n            }\\n        }\\n        return String(arr[lhs...rhs])\\n    }\\n}\\n```\\n\\n---\\n\\n<p>\\n<details>\\n<summary>\\n<img src=\"https://git.io/JDblm\" height=\"24\">\\n<b>TEST CASES</b>\\n</summary>\\n\\n<p><pre>\\n<b>Result:</b> Executed 2 tests, with 0 failures (0 unexpected) in 0.008 (0.010) seconds\\n</pre></p>\\n\\n```swift\\nclass Tests {\\n    \\n    private typealias sol = Solution\\n    \\n    static func test0() {\\n        let value = sol().longestPalindrome(\"babad\")\\n        print(value == \"bab\")\\n    }\\n    \\n    static func test1() {\\n        let value = sol().longestPalindrome(\"cbbd\")\\n        print(value == \"bb\")\\n    }\\n}\\n\\nTests.test0()\\nTests.test1()\\n```\\n\\n</details>\\n</p>",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```swift\\nclass Solution {\\n    func longestPalindrome(_ s: String) -> String {\\n        let len = s.count, arr = Array(s)\\n        if len <= 1 { return s }\\n        var lhs = 0, rhs = 0, dp = Array(repeating: Array(repeating: false, count: len), count: len)\\n        for i in 1..<len {\\n            for j in 0..<i where arr[j] == arr[i] && (dp[j+1][i-1] || i - j <= 2) {\\n                dp[j][i] = true\\n                if i - j > rhs - lhs {\\n                    lhs = j\\n                    rhs = i\\n                }\\n            }\\n        }\\n        return String(arr[lhs...rhs])\\n    }\\n}\\n```\n```swift\\nclass Tests {\\n    \\n    private typealias sol = Solution\\n    \\n    static func test0() {\\n        let value = sol().longestPalindrome(\"babad\")\\n        print(value == \"bab\")\\n    }\\n    \\n    static func test1() {\\n        let value = sol().longestPalindrome(\"cbbd\")\\n        print(value == \"bb\")\\n    }\\n}\\n\\nTests.test0()\\nTests.test1()\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1245748,
                "title": "c-clean-top-down",
                "content": "```\\nclass Solution {\\npublic:\\n    string longestPalindrome(string s) {\\n        int memo[1001][1001];\\n        memset(memo, -1, sizeof(memo));\\n        vector<int> answer = {0, 0, 1};\\n        helper(0, s.size() - 1, s, memo, answer);\\n        return s.substr(answer[0], answer[2]);\\n    }\\n    \\n    bool helper(int l, int r, string &s, int memo[][1001], vector<int> &answer) {\\n\\t\\t// Check if [ L ... R ] is already calculated before\\n        if (memo[l][r] != -1) {\\n            return memo[l][r];         \\n        }\\n        \\n\\t\\t// Base case, every single letter or empty string is also a palindrome\\n        if (l >= r) {\\n            return true;\\n        }\\n        \\n        // Possible palindrome beginning\\n        bool found = false;\\n        if (s[l] == s[r]) {\\n            found = true && helper(l + 1, r - 1, s, memo, answer);\\n        }\\n        \\n        // Try other possibilities\\n        helper(l + 1, r , s, memo, answer);\\n        helper(l, r - 1, s, memo, answer);\\n        \\n        // Update longest palindrome position and width\\n        if (found && (r - l + 1) > answer[2]) {\\n            answer = {l, r, (r - l + 1)};\\n        }\\n        \\n        // Memoization\\n        memo[l][r] = found;\\n        \\n        return found;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string longestPalindrome(string s) {\\n        int memo[1001][1001];\\n        memset(memo, -1, sizeof(memo));\\n        vector<int> answer = {0, 0, 1};\\n        helper(0, s.size() - 1, s, memo, answer);\\n        return s.substr(answer[0], answer[2]);\\n    }\\n    \\n    bool helper(int l, int r, string &s, int memo[][1001], vector<int> &answer) {\\n\\t\\t// Check if [ L ... R ] is already calculated before\\n        if (memo[l][r] != -1) {\\n            return memo[l][r];         \\n        }\\n        \\n\\t\\t// Base case, every single letter or empty string is also a palindrome\\n        if (l >= r) {\\n            return true;\\n        }\\n        \\n        // Possible palindrome beginning\\n        bool found = false;\\n        if (s[l] == s[r]) {\\n            found = true && helper(l + 1, r - 1, s, memo, answer);\\n        }\\n        \\n        // Try other possibilities\\n        helper(l + 1, r , s, memo, answer);\\n        helper(l, r - 1, s, memo, answer);\\n        \\n        // Update longest palindrome position and width\\n        if (found && (r - l + 1) > answer[2]) {\\n            answer = {l, r, (r - l + 1)};\\n        }\\n        \\n        // Memoization\\n        memo[l][r] = found;\\n        \\n        return found;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1024308,
                "title": "python-clean-o-n-2-solution-explained",
                "content": "Let us look at possible places of middle of our palindrome and expand to the left and to the right until we either reached on of the ends of symbols are not equal. Also, because we need to return not only length of longest palindromic substring, but substring itself, our `helper` function will return this string.\\n\\nNote also, that there are two different type of palindromes:\\n1. With odd length, we use `helper(k, k)` for them.\\n2. With even length, we use `helper(k, k+1)` for them.\\n\\n**Complexity** There will be `2n - 1` possible centers and `O(n)` comparison for each of them, so final time complexity is `O(n^2)`. Space complexity is `O(n)`\\n\\n**Further discussion** there is also classical dynamic programming for this problem with also `O(n^2)` complexity, however in practice it can work much slower if we do not do optimiaztions: reason that it will be indeed `n^2` operations, whereas on our approach here we do a lot of early stoppings. There is also ofcourse Manacher\\'s algorithm with complexity `O(n)`, which sometimes useful for competitions, and you should have code avaliable somewhere, but which is in my opitions out of scope for middle difficulty problem.\\n\\n```\\nclass Solution:\\n    def longestPalindrome(self, s):\\n        n, ans = len(s), \"\"\\n        def helper(i, j):\\n            while i >= 0 and j < n and s[i] == s[j]:\\n                i, j = i - 1, j + 1\\n            return s[i + 1:j]\\n        \\n        for k in range(n):\\n            ans = max(helper(k, k), helper(k, k + 1), ans, key=len)\\n        return ans\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def longestPalindrome(self, s):\\n        n, ans = len(s), \"\"\\n        def helper(i, j):\\n            while i >= 0 and j < n and s[i] == s[j]:\\n                i, j = i - 1, j + 1\\n            return s[i + 1:j]\\n        \\n        for k in range(n):\\n            ans = max(helper(k, k), helper(k, k + 1), ans, key=len)\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 759291,
                "title": "straight-forward-short-and-clean-python-dp-with-detailed-simple-explanation",
                "content": "The main things to explain here:\\nWe are iterating through our string looking for palindromes, we fill in a dp table with what we find and use it for reference:\\n<table style=\"width:100%\">\\n  <tr>\\n  <th></th>\\n    <th>a</th>\\n    <th>b</th>\\n    <th>a</th>\\n  </tr>\\n  <tr>\\n    <td><b>a</b></td>\\n    <td>t</td>\\n    <td>f</td>\\n\\t<td>t</td>\\n  </tr>\\n  <tr>\\n    <td><b>b</b></td>\\n    <td>0</td>\\n    <td>t</td>\\n\\t<td>f</td>\\n  </tr>\\n    <tr>\\n    <td><b>a</b></td>\\n    <td>0</td>\\n    <td>0</td>\\n\\t<td>t</td>\\n  </tr>\\n</table>\\n\\nWe start our iterations from the bottom (reverse the range - range(n-1, -1, -1)), and build our solution up (bottom up).\\nOur diagonal is always true as it means it\\'s always 1 letter (you could think of the letters as idx\\'s also (0,0), (1,1) etc.). \\nBottom row: is \\'a\\' a pal? True.\\nMiddle row: is \\'b\\' a pal? True, is \\'ba\\' a pal? False.\\nTop row: is \\'a\\' a pal? True, is \\'ab\\' a pal? False, is \\'aba\\' a pal? True.\\n\\n The logic for recording the longest palindromes:\\n*  ((j - i + 1) <= 3 if the length of the str is < 3\\n\\t*  eg. aba i= 0, j = 2, 2 - 0 + 1 = 3, here we dont care about the middle letter, and we know s[i] == s[j].\\n\\t*  eg. ab i= 0, j = 1, 1 - 0 + 1 = 2 this isn\\'t valid? But we already know s[i] != s[j] so wouldn\\'t have made it to this check.\\n*  OR dp[i + 1][j - 1] - the last str before the current was a palindrome.\\n\\nWe store the palindromes we find along with their length in ans and return the str associated with the max len.\\n```\\nclass Solution:\\n    def longestPalindrome(self, s):\\n        \"\"\"\\n        :type s: str\\n        :rtype: str\\n        \"\"\"\\n\\t\\tn = len(s)\\n        if n < 2: return s\\n        dp, ans = [[0]*n for _ in range(n)], {}\\n        for i in range(n-1, -1, -1):\\n            for j in range(i, n):\\n                if s[i] == s[j] and ((j - i + 1) <= 3 or dp[i + 1][j - 1]):\\n                    dp[i][j] = True\\n                    ans[j-i+1] = s[i:j+1]\\n                else:\\n                    dp[i][j] = False\\n        return ans[max(ans)]\\n```\\n\\nA very similar way to approach it:\\n```\\nclass Solution:\\n    def longestPalindrome(self, s: str) -> str:\\n        \\n        if len(s) < 2: \\n            return s[0] if s else \\'\\'\\n        dp = [[False] * len(s) for _ in range(len(s))]\\n        max_seen = 1\\n        mv = s[0]\\n        for i in range(len(s)):\\n            for j in range(i):\\n                if s[i] == s[j] and ((i-j+1) <= 3 or dp[i-1][j+1]):\\n                    dp[i][j] = True\\n                    if i-j+1 >= max_seen:\\n                        max_seen = i-j+1\\n                        mv = s[j:i+1]\\n\\n        return mv\\n```\\nOR\\n```\\nclass Solution:\\n    def longestPalindrome(self, s: str) -> str:\\n        \\n        dp = [[False]*len(s) for _ in range(len(s))]\\n        longest = \\'\\'\\n        \\n        for i in range(len(s)):\\n            for j in range(i+1):\\n                if s[i] == s[j] and ((i+1-j) <= 3 or dp[i-1][j+1]):\\n                    dp[i][j] = True\\n                    if i+1-j > len(longest):\\n                        longest = s[j:i+1]\\n        return longest\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution:\\n    def longestPalindrome(self, s):\\n        \"\"\"\\n        :type s: str\\n        :rtype: str\\n        \"\"\"\\n\\t\\tn = len(s)\\n        if n < 2: return s\\n        dp, ans = [[0]*n for _ in range(n)], {}\\n        for i in range(n-1, -1, -1):\\n            for j in range(i, n):\\n                if s[i] == s[j] and ((j - i + 1) <= 3 or dp[i + 1][j - 1]):\\n                    dp[i][j] = True\\n                    ans[j-i+1] = s[i:j+1]\\n                else:\\n                    dp[i][j] = False\\n        return ans[max(ans)]\\n```\n```\\nclass Solution:\\n    def longestPalindrome(self, s: str) -> str:\\n        \\n        if len(s) < 2: \\n            return s[0] if s else \\'\\'\\n        dp = [[False] * len(s) for _ in range(len(s))]\\n        max_seen = 1\\n        mv = s[0]\\n        for i in range(len(s)):\\n            for j in range(i):\\n                if s[i] == s[j] and ((i-j+1) <= 3 or dp[i-1][j+1]):\\n                    dp[i][j] = True\\n                    if i-j+1 >= max_seen:\\n                        max_seen = i-j+1\\n                        mv = s[j:i+1]\\n\\n        return mv\\n```\n```\\nclass Solution:\\n    def longestPalindrome(self, s: str) -> str:\\n        \\n        dp = [[False]*len(s) for _ in range(len(s))]\\n        longest = \\'\\'\\n        \\n        for i in range(len(s)):\\n            for j in range(i+1):\\n                if s[i] == s[j] and ((i+1-j) <= 3 or dp[i-1][j+1]):\\n                    dp[i][j] = True\\n                    if i+1-j > len(longest):\\n                        longest = s[j:i+1]\\n        return longest\\n```",
                "codeTag": "Java"
            },
            {
                "id": 751188,
                "title": "simple-easy-to-follow-python",
                "content": "This solution is currently at 948 ms for time and  13.7 mb for space (i.e. beats 83% of  run and 92.90% of space among the submissions) as of 07/23/2020. I think I will just stick with this for my interview. I have tried to write good comments. Let me know if you couldn\\'t understand any part of it. \\n\\n```\\nclass Solution:\\n    def longestPalindrome(self, s: str) -> str:\\n        result = \"\"\\n        \\n        for i in range(len(s)):\\n            # this is for odd length palindrome\\n            word1 = self.checkPalindrome(s, i, i)\\n            # this is for even length palindrome\\n            word2 = self.checkPalindrome(s, i, i+1)\\n            \\n            #word1 will be max length word from word1 and word2\\n            word1 = word1 if len(word1) >= len(word2) else word2 \\n            \\n            # compare word1 with our result\\n            result = word1 if len(word1) >= len(result) else result\\n            \\n        return result\\n    \\n    def checkPalindrome(self, s, lo, hi):\\n        # expand as long as \\'lo\\' can grow to the left\\n        # and \\'hi\\' and grow to the right and chracters at those index match\\n        while lo>=0 and hi<len(s) and s[lo]==s[hi]:\\n            lo -= 1\\n            hi += 1\\n        \\n        # return the slice from original string that starts from our last matched index of lo and hi. We don\\'t increament hi because python slice goes up to ending index-1\\n        return s[lo+1:hi]\\n        \\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def longestPalindrome(self, s: str) -> str:\\n        result = \"\"\\n        \\n        for i in range(len(s)):\\n            # this is for odd length palindrome\\n            word1 = self.checkPalindrome(s, i, i)\\n            # this is for even length palindrome\\n            word2 = self.checkPalindrome(s, i, i+1)\\n            \\n            #word1 will be max length word from word1 and word2\\n            word1 = word1 if len(word1) >= len(word2) else word2 \\n            \\n            # compare word1 with our result\\n            result = word1 if len(word1) >= len(result) else result\\n            \\n        return result\\n    \\n    def checkPalindrome(self, s, lo, hi):\\n        # expand as long as \\'lo\\' can grow to the left\\n        # and \\'hi\\' and grow to the right and chracters at those index match\\n        while lo>=0 and hi<len(s) and s[lo]==s[hi]:\\n            lo -= 1\\n            hi += 1\\n        \\n        # return the slice from original string that starts from our last matched index of lo and hi. We don\\'t increament hi because python slice goes up to ending index-1\\n        return s[lo+1:hi]\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 128054,
                "title": "java-beats-98-and-javascript-beats-100-o-n-manacher-s-algorithm-with-detailed-explanation",
                "content": "# Longest Palindromic Substring (LPS)\\n**Problem**\\n\\n* *Given a string s, find the longest palindromic substring in s. You may assume that the maximum length of s is 1000.*\\n\\nThis post explains Manacher\\u2019s Algorithm, a dynamic programming algorithm used to solve LPS problem. Manacher\\u2019s Algorithm reuses results from previous palindromic checks to reduce complexity. Each palindromic checks has an O(1) time complexity, so the total complexity is O(n). The algorithm uses O(n) extra space.\\n\\n**Table of Contents**\\n1. Java Code\\n1. Java Code with inline, detailed explanation\\n1. JavaScript Code\\n1. JavaScript Code with inline, detailed explanation\\n# Java Code\\n```\\n    public String longestPalindrome(String s) {\\n        char[] newStr = new char[s.length() * 2 + 1];\\n        newStr[0] = \\'#\\';\\n        for (int i = 0; i < s.length(); i++) {\\n            newStr[2 * i + 1] = s.charAt(i);\\n            newStr[2 * i + 2] = \\'#\\';\\n        }\\n        int[] dp = new int[newStr.length];\\n        int friendCenter = 0, friendRadius = 0, lpsCenter = 0, lpsRadius = 0;\\n        for (int i = 0; i < newStr.length; i++) {\\n            dp[i] = friendCenter + friendRadius > i ? Math.min(dp[friendCenter * 2 - i], (friendCenter + friendRadius) - i) : 1;\\n            while (i + dp[i] < newStr.length && i - dp[i] >= 0 && newStr[i + dp[i]] == newStr[i - dp[i]]) dp[i]++;\\n            if (friendCenter + friendRadius < i + dp[i]) {\\n                friendCenter = i;\\n                friendRadius = dp[i];\\n            }\\n            if (lpsRadius < dp[i]) {\\n                lpsCenter = i;\\n                lpsRadius = dp[i];\\n            }\\n        }\\n        return s.substring((lpsCenter - lpsRadius + 1) / 2, (lpsCenter + lpsRadius - 1) / 2);\\n    }\\n```\\n# Java Explanation\\n```\\n    public String longestPalindrome(String s) {\\n        /* Preprocess s: insert \\'#\\' between characters, so we don\\'t need to worry about even or odd length palindromes. */\\n        char[] newStr = new char[s.length() * 2 + 1];\\n        newStr[0] = \\'#\\';\\n        for (int i = 0; i < s.length(); i++) {\\n            newStr[2 * i + 1] = s.charAt(i);\\n            newStr[2 * i + 2] = \\'#\\';\\n        }\\n        /* Process newStr */\\n        /* dp[i] is the length of LPS centered at i */\\n        int[] dp = new int[newStr.length];\\n        /**\\n         * For better understanding, here we define \"friend substring\", or \"friend\":\\n         * \"friend substring\" has the largest end-index in all checked substrings that\\n         * are palindromes. We start at friendCenter = 0 and update it in each cycles.\\n         */\\n        int friendCenter = 0, friendRadius = 0, lpsCenter = 0, lpsRadius = 0;\\n        /* j is the symmetry of i with respect to friendCenter */\\n        int j;\\n        for (int i = 0; i < newStr.length; i++) {\\n            /* Calculate dp[i] */\\n            if (friendCenter + friendRadius > i) {\\n                /**\\n                 * This is the most important part of the algorithm.\\n                 * \\n                 * Normally we start from dp[i] = 1 and then try to expand dp[i] by doing brute-force palindromic\\n                 * checks. However, if i is in the range of friend (friendCenter + friendRadius > i), we can expect\\n                 * dp[i] = dp[j] because friend is a palindrome. This only works within the range of friend, so the\\n                 * max value of dp[i] we can trust is (friendEnd - i).\\n                 * \\n                 * Here is an example:\\n                 *\\n                 *     friendStart   j             friendCenter  i     friendEnd                         \\n                 *               |   |             |             |     |\\n                 * String: - - d c b a b c d - - - - - - - d c b a b c ? - - - - - - - -\\n                 *               [--------friend (palindrome)--------]\\n                 *\\n                 * In this example, (friendEnd - i) = 3, so we can only be certain that radius <= 3 part around i\\n                 * is a palindrome (i.e. \"cbabc\" part). We still need to check the character at \"?\".\\n                 */\\n                j = friendCenter - (i - friendCenter);\\n                dp[i] = Math.min(dp[j], (friendCenter + friendRadius) - i);\\n            }\\n            else {\\n                /* Calculate from scratch */\\n                dp[i] = 1;\\n            }\\n            /* Check palindrome and expand dp[i] */\\n            while (i + dp[i] < newStr.length && i - dp[i] >= 0&& newStr[i + dp[i]] == newStr[i - dp[i]])\\n                dp[i]++;\\n            /* Check if i should become the new friend */\\n            if (friendCenter + friendRadius < i + dp[i]) {\\n                friendCenter = i;\\n                friendRadius = dp[i];\\n            }\\n            /* Update longest palindrome */\\n            if (lpsRadius < dp[i]) {\\n                lpsCenter = i;\\n                lpsRadius = dp[i];\\n            }\\n        }\\n        return s.substring((lpsCenter - lpsRadius + 1) / 2, (lpsCenter + lpsRadius - 1) / 2);\\n    }\\n```\\n# JavaScript Code\\n```\\nvar longestPalindrome = function(s) {\\n    var newStr = \"#\" + s.split(\"\").join(\"#\") + \"#\";\\n    var dp = [], friendCenter = 0, friendRadius = 0, lpsCenter = 0, lpsRadius = 0;\\n    for (var i = 0; i < newStr.length; i++) {\\n        dp[i] = friendCenter + friendRadius > i ? Math.min(dp[friendCenter * 2 - i], (friendCenter + friendRadius) - i) : 1;\\n        while (i + dp[i] < newStr.length && i - dp[i] >= 0 && newStr[i + dp[i]] == newStr[i - dp[i]]) dp[i]++;\\n        friendRadius = friendCenter + friendRadius < i + dp[i] ? (function () {friendCenter = i; return dp[i];})() : friendRadius;\\n        lpsRadius = lpsRadius < dp[i] ? (function () {lpsCenter = i; return dp[i];})() : lpsRadius;\\n    }\\n    return s.substring((lpsCenter - lpsRadius + 1) / 2, (lpsCenter + lpsRadius - 1) / 2);\\n};\\n```\\n# JavaScript Explanation\\n```\\nvar longestPalindrome = function(s) {\\n    /* Preprocess s: insert \\'#\\' between characters, so we don\\'t need to worry about even or odd length palindromes. */\\n    var newStr = \"#\";\\n    for (var i = 0; i < s.length; i++) newStr += s.charAt(i) + \"#\";\\n    /* Process newStr */\\n    /* dp[i] is the length of LPS centered at i */\\n    var dp = [];\\n    /**\\n     * For better understanding, here we define \"friend substring\", or \"friend\":\\n     * \"friend substring\" has the largest end-index in all checked substrings that\\n     * are palindromes. We start at friendCenter = 0 and update it in each cycles.\\n     */\\n    var friendCenter = 0, friendRadius = 0, lpsCenter = 0, lpsRadius = 0;\\n    /* j is the symmetry of i with respect to friendCenter */\\n    var j;\\n    for (var i = 0; i < newStr.length; i++) {\\n        /* Calculate dp[i] */\\n        if (friendCenter + friendRadius > i) {\\n            /**\\n             * This is the most important part of the algorithm.\\n             * \\n             * Normally we start from dp[i] = 1 and then try to expand dp[i] by doing brute-force palindromic\\n             * checks. However, if i is in the range of friend (friendCenter + friendRadius > i), we can expect\\n             * dp[i] = dp[j] because friend is a palindrome. This only works within the range of friend, so the\\n             * max dp[i] we can trust = (friendEnd - i).\\n             * \\n             * Here is an example:\\n             *\\n             *     friendStart   j             friendCenter  i     friendEnd                         \\n             *               |   |             |             |     |\\n             * String: - - d c b a b c d - - - - - - - d c b a b c ? - - - - - - - -\\n             *               [--------friend (palindrome)--------]\\n             *\\n             * In this example, (friendEnd - i) = 3, so we can only be certain that radius <= 3 part around i\\n             * is a palindrome (i.e. \"cbabc\" part). We still need to check the character at \"?\".\\n             */\\n            j = friendCenter - (i - friendCenter);\\n            dp[i] = Math.min(dp[j], (friendCenter + friendRadius) - i);\\n        }\\n        else {\\n            /* Calculate from scratch */\\n            dp[i] = 1;\\n        }\\n        /* Check palindrome and expand dp[i] */\\n        while (i + dp[i] < newStr.length && i - dp[i] >= 0 && newStr[i + dp[i]] == newStr[i - dp[i]]) dp[i]++;\\n        /* Check if i should become the new friend */\\n        if (friendCenter + friendRadius < i + dp[i]) {\\n            friendCenter = i;\\n            friendRadius = dp[i];\\n        }\\n        /* Update longest palindromic substring */\\n        if (lpsRadius < dp[i]) {\\n            lpsRadius = dp[i];\\n            lpsCenter = i;\\n        }\\n    }\\n    return s.substring((lpsCenter - lpsRadius + 1) / 2, (lpsCenter + lpsRadius - 1) / 2);\\n};\\n```\\n",
                "solutionTags": [],
                "code": "```\\n    public String longestPalindrome(String s) {\\n        char[] newStr = new char[s.length() * 2 + 1];\\n        newStr[0] = \\'#\\';\\n        for (int i = 0; i < s.length(); i++) {\\n            newStr[2 * i + 1] = s.charAt(i);\\n            newStr[2 * i + 2] = \\'#\\';\\n        }\\n        int[] dp = new int[newStr.length];\\n        int friendCenter = 0, friendRadius = 0, lpsCenter = 0, lpsRadius = 0;\\n        for (int i = 0; i < newStr.length; i++) {\\n            dp[i] = friendCenter + friendRadius > i ? Math.min(dp[friendCenter * 2 - i], (friendCenter + friendRadius) - i) : 1;\\n            while (i + dp[i] < newStr.length && i - dp[i] >= 0 && newStr[i + dp[i]] == newStr[i - dp[i]]) dp[i]++;\\n            if (friendCenter + friendRadius < i + dp[i]) {\\n                friendCenter = i;\\n                friendRadius = dp[i];\\n            }\\n            if (lpsRadius < dp[i]) {\\n                lpsCenter = i;\\n                lpsRadius = dp[i];\\n            }\\n        }\\n        return s.substring((lpsCenter - lpsRadius + 1) / 2, (lpsCenter + lpsRadius - 1) / 2);\\n    }\\n```\n```\\n    public String longestPalindrome(String s) {\\n        /* Preprocess s: insert \\'#\\' between characters, so we don\\'t need to worry about even or odd length palindromes. */\\n        char[] newStr = new char[s.length() * 2 + 1];\\n        newStr[0] = \\'#\\';\\n        for (int i = 0; i < s.length(); i++) {\\n            newStr[2 * i + 1] = s.charAt(i);\\n            newStr[2 * i + 2] = \\'#\\';\\n        }\\n        /* Process newStr */\\n        /* dp[i] is the length of LPS centered at i */\\n        int[] dp = new int[newStr.length];\\n        /**\\n         * For better understanding, here we define \"friend substring\", or \"friend\":\\n         * \"friend substring\" has the largest end-index in all checked substrings that\\n         * are palindromes. We start at friendCenter = 0 and update it in each cycles.\\n         */\\n        int friendCenter = 0, friendRadius = 0, lpsCenter = 0, lpsRadius = 0;\\n        /* j is the symmetry of i with respect to friendCenter */\\n        int j;\\n        for (int i = 0; i < newStr.length; i++) {\\n            /* Calculate dp[i] */\\n            if (friendCenter + friendRadius > i) {\\n                /**\\n                 * This is the most important part of the algorithm.\\n                 * \\n                 * Normally we start from dp[i] = 1 and then try to expand dp[i] by doing brute-force palindromic\\n                 * checks. However, if i is in the range of friend (friendCenter + friendRadius > i), we can expect\\n                 * dp[i] = dp[j] because friend is a palindrome. This only works within the range of friend, so the\\n                 * max value of dp[i] we can trust is (friendEnd - i).\\n                 * \\n                 * Here is an example:\\n                 *\\n                 *     friendStart   j             friendCenter  i     friendEnd                         \\n                 *               |   |             |             |     |\\n                 * String: - - d c b a b c d - - - - - - - d c b a b c ? - - - - - - - -\\n                 *               [--------friend (palindrome)--------]\\n                 *\\n                 * In this example, (friendEnd - i) = 3, so we can only be certain that radius <= 3 part around i\\n                 * is a palindrome (i.e. \"cbabc\" part). We still need to check the character at \"?\".\\n                 */\\n                j = friendCenter - (i - friendCenter);\\n                dp[i] = Math.min(dp[j], (friendCenter + friendRadius) - i);\\n            }\\n            else {\\n                /* Calculate from scratch */\\n                dp[i] = 1;\\n            }\\n            /* Check palindrome and expand dp[i] */\\n            while (i + dp[i] < newStr.length && i - dp[i] >= 0&& newStr[i + dp[i]] == newStr[i - dp[i]])\\n                dp[i]++;\\n            /* Check if i should become the new friend */\\n            if (friendCenter + friendRadius < i + dp[i]) {\\n                friendCenter = i;\\n                friendRadius = dp[i];\\n            }\\n            /* Update longest palindrome */\\n            if (lpsRadius < dp[i]) {\\n                lpsCenter = i;\\n                lpsRadius = dp[i];\\n            }\\n        }\\n        return s.substring((lpsCenter - lpsRadius + 1) / 2, (lpsCenter + lpsRadius - 1) / 2);\\n    }\\n```\n```\\nvar longestPalindrome = function(s) {\\n    var newStr = \"#\" + s.split(\"\").join(\"#\") + \"#\";\\n    var dp = [], friendCenter = 0, friendRadius = 0, lpsCenter = 0, lpsRadius = 0;\\n    for (var i = 0; i < newStr.length; i++) {\\n        dp[i] = friendCenter + friendRadius > i ? Math.min(dp[friendCenter * 2 - i], (friendCenter + friendRadius) - i) : 1;\\n        while (i + dp[i] < newStr.length && i - dp[i] >= 0 && newStr[i + dp[i]] == newStr[i - dp[i]]) dp[i]++;\\n        friendRadius = friendCenter + friendRadius < i + dp[i] ? (function () {friendCenter = i; return dp[i];})() : friendRadius;\\n        lpsRadius = lpsRadius < dp[i] ? (function () {lpsCenter = i; return dp[i];})() : lpsRadius;\\n    }\\n    return s.substring((lpsCenter - lpsRadius + 1) / 2, (lpsCenter + lpsRadius - 1) / 2);\\n};\\n```\n```\\nvar longestPalindrome = function(s) {\\n    /* Preprocess s: insert \\'#\\' between characters, so we don\\'t need to worry about even or odd length palindromes. */\\n    var newStr = \"#\";\\n    for (var i = 0; i < s.length; i++) newStr += s.charAt(i) + \"#\";\\n    /* Process newStr */\\n    /* dp[i] is the length of LPS centered at i */\\n    var dp = [];\\n    /**\\n     * For better understanding, here we define \"friend substring\", or \"friend\":\\n     * \"friend substring\" has the largest end-index in all checked substrings that\\n     * are palindromes. We start at friendCenter = 0 and update it in each cycles.\\n     */\\n    var friendCenter = 0, friendRadius = 0, lpsCenter = 0, lpsRadius = 0;\\n    /* j is the symmetry of i with respect to friendCenter */\\n    var j;\\n    for (var i = 0; i < newStr.length; i++) {\\n        /* Calculate dp[i] */\\n        if (friendCenter + friendRadius > i) {\\n            /**\\n             * This is the most important part of the algorithm.\\n             * \\n             * Normally we start from dp[i] = 1 and then try to expand dp[i] by doing brute-force palindromic\\n             * checks. However, if i is in the range of friend (friendCenter + friendRadius > i), we can expect\\n             * dp[i] = dp[j] because friend is a palindrome. This only works within the range of friend, so the\\n             * max dp[i] we can trust = (friendEnd - i).\\n             * \\n             * Here is an example:\\n             *\\n             *     friendStart   j             friendCenter  i     friendEnd                         \\n             *               |   |             |             |     |\\n             * String: - - d c b a b c d - - - - - - - d c b a b c ? - - - - - - - -\\n             *               [--------friend (palindrome)--------]\\n             *\\n             * In this example, (friendEnd - i) = 3, so we can only be certain that radius <= 3 part around i\\n             * is a palindrome (i.e. \"cbabc\" part). We still need to check the character at \"?\".\\n             */\\n            j = friendCenter - (i - friendCenter);\\n            dp[i] = Math.min(dp[j], (friendCenter + friendRadius) - i);\\n        }\\n        else {\\n            /* Calculate from scratch */\\n            dp[i] = 1;\\n        }\\n        /* Check palindrome and expand dp[i] */\\n        while (i + dp[i] < newStr.length && i - dp[i] >= 0 && newStr[i + dp[i]] == newStr[i - dp[i]]) dp[i]++;\\n        /* Check if i should become the new friend */\\n        if (friendCenter + friendRadius < i + dp[i]) {\\n            friendCenter = i;\\n            friendRadius = dp[i];\\n        }\\n        /* Update longest palindromic substring */\\n        if (lpsRadius < dp[i]) {\\n            lpsRadius = dp[i];\\n            lpsCenter = i;\\n        }\\n    }\\n    return s.substring((lpsCenter - lpsRadius + 1) / 2, (lpsCenter + lpsRadius - 1) / 2);\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 417359,
                "title": "java-dp-solutions-with-illustration-t-t",
                "content": "Reference: [LeetCode](https://leetcode.com/problems/longest-palindromic-substring/)\\nDifficulty: <span class=\"orange\">Medium</span>\\n\\n\\n\\n## Problem\\n\\n> Given a string `s`, find the longest palindromic substring in `s`. You may assume that the maximum length of `s` is `1000`.\\n\\n\\n**Example:** \\n\\n```java\\nInput: \"babad\"\\nOutput: \"bab\"\\nNote: \"aba\" is also a valid answer.\\n\\nInput: \"cbbd\"\\nOutput: \"bb\"\\n```\\n\\n\\n## Analysis\\n\\n### Brute-Force\\n\\nFor each character `i`, we examine all substrings starting from index `i` and check if they are palindromic.\\n\\n```java\\npublic String longestPalindrome(String s) {\\n  if (s == null || s.length() == 0) {\\n    return \"\";\\n  }\\n  int n = s.length();\\n  String maxStr = \"\";\\n  for (int i = 0; i < n; ++i) {\\n    for (int j = i; j < n; ++j) {\\n      if (isValid(s, i, j) == true) {\\n        if (j - i + 1 > maxStr.length()) { // update maxStr\\n          maxStr = s.substring(i, j + 1);\\n        }\\n      }\\n    }\\n  }\\n  return maxStr;\\n}\\n\\nprivate boolean isValid(String s, int lo, int hi) {\\n  int n = hi - lo + 1;\\n  for (int i = 0; i < n / 2; ++i) {\\n    if (s.charAt(lo + i) != s.charAt(hi - i)) {\\n      return false;\\n    }\\n  }\\n  return true;\\n}\\n```\\n\\n**Time:** `O(N^3)`\\n**Space:** `O(1)`\\n\\n\\n\\n### Expansion From the Center\\n\\n\\n\\n```java\\npublic String longestPalindrome(String s) {\\n  if (s == null || s.length() == 0) {\\n    return \"\";\\n  }\\n  int n = s.length();\\n  StringBuilder longest = new StringBuilder();\\n  for (int i = 0; i < n; ++i) {\\n    findPalindrome(s, i, i, longest); // odd\\n    findPalindrome(s, i, i + 1, longest); // even\\n  }\\n  return longest.toString();\\n}\\n  \\nprivate void findPalindrome(String s, int lo, int hi, StringBuilder longest) {\\n  int n = s.length();\\n  StringBuilder sb = new StringBuilder();\\n  while (lo >= 0 && hi < n && s.charAt(lo) == s.charAt(hi)) {\\n    if (lo == hi) {\\n      sb.append(s.charAt(lo));\\n    } else {\\n      sb.insert(0, s.charAt(lo));\\n      sb.append(s.charAt(hi));\\n    }\\n    --lo;\\n    ++hi;\\n  }\\n  if (sb.length() > longest.length()) {\\n    longest.delete(0, longest.length());\\n    longest.append(sb);\\n  }\\n}\\n```\\n\\n**Time:** `O(N^2)`\\n**Space:** `O(N)`\\n\\n\\n\\n\\n### DP\\n\\nBased on the brute-force solution, we can improve on it by avoiding unnecessary re-computation while validating palindromes. Consider the case `ababa`. If we already knew that `bab` is a palindrome, it is obvious that `ababa` must be a palindrome since the two end letters are the same.\\n\\nSo we can define `dp[i][j]` as `true` if the substring `S(i, j)` is a palindrome.\\n\\nThe recurrence is then obvious: `dp[i][j]` = (`dp[i + 1][j - 1]` && `Si == Sj`)\\n\\nThe base cases are: `dp[i][i]` = `true`, `dp[i][i + 1] = (Si == Si+1)`.\\n\\n![](https://bloggg-1254259681.cos.na-siliconvalley.myqcloud.com/10ayv.jpg)\\n\\n**Note:** Determining ranges of `i` and `j` would be easy if you pick a starting point in the graph to get some intuition. For example, in this case `j` starts from `i + 2`.\\n\\n```java\\npublic String longestPalindrome(String s) {\\n  if (s == null || s.length() == 0) {\\n    return \"\";\\n  }\\n  int n = s.length();\\n  boolean[][] dp = generateDP(s);\\n  // Check each substring\\n  int maxLen = 0;\\n  int[] maxIdx = new int[] { 0, 0 };\\n  for (int i = 0; i < n; ++i) {\\n    for (int j = i; j < n; ++j) {\\n      if (dp[i][j] == true) {\\n        if (j - i + 1 > maxLen) {\\n          maxLen = j - i + 1;\\n          maxIdx[0] = i;\\n          maxIdx[1] = j;\\n        }\\n      }\\n    }\\n  }\\n  return s.substring(maxIdx[0], maxIdx[1] + 1);\\n}\\n\\nprivate boolean[][] generateDP(String s) {\\n  int n = s.length();\\n  boolean[][] dp = new boolean[n][n];\\n  // Init\\n  for (int i = 0; i < n; ++i) { // diagonal\\n    dp[i][i] = true;\\n  }\\n  for (int i = 0; i < n - 1; ++i) { // one line below diagonal\\n    dp[i][i + 1] = (s.charAt(i) == s.charAt(i + 1));\\n  }\\n  // DP\\n  for (int i = n - 3; i >= 0; --i) {\\n    for (int j = i + 2; j < n; ++j) {\\n      dp[i][j] = dp[i + 1][j - 1] && s.charAt(i) == s.charAt(j);\\n    }\\n  }\\n  return dp;\\n}\\n```\\n\\n**Time:** `O(N^2)`\\n**Space:** `O(N^2)`\\n",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "```java\\nInput: \"babad\"\\nOutput: \"bab\"\\nNote: \"aba\" is also a valid answer.\\n\\nInput: \"cbbd\"\\nOutput: \"bb\"\\n```\n```java\\npublic String longestPalindrome(String s) {\\n  if (s == null || s.length() == 0) {\\n    return \"\";\\n  }\\n  int n = s.length();\\n  String maxStr = \"\";\\n  for (int i = 0; i < n; ++i) {\\n    for (int j = i; j < n; ++j) {\\n      if (isValid(s, i, j) == true) {\\n        if (j - i + 1 > maxStr.length()) { // update maxStr\\n          maxStr = s.substring(i, j + 1);\\n        }\\n      }\\n    }\\n  }\\n  return maxStr;\\n}\\n\\nprivate boolean isValid(String s, int lo, int hi) {\\n  int n = hi - lo + 1;\\n  for (int i = 0; i < n / 2; ++i) {\\n    if (s.charAt(lo + i) != s.charAt(hi - i)) {\\n      return false;\\n    }\\n  }\\n  return true;\\n}\\n```\n```java\\npublic String longestPalindrome(String s) {\\n  if (s == null || s.length() == 0) {\\n    return \"\";\\n  }\\n  int n = s.length();\\n  StringBuilder longest = new StringBuilder();\\n  for (int i = 0; i < n; ++i) {\\n    findPalindrome(s, i, i, longest); // odd\\n    findPalindrome(s, i, i + 1, longest); // even\\n  }\\n  return longest.toString();\\n}\\n  \\nprivate void findPalindrome(String s, int lo, int hi, StringBuilder longest) {\\n  int n = s.length();\\n  StringBuilder sb = new StringBuilder();\\n  while (lo >= 0 && hi < n && s.charAt(lo) == s.charAt(hi)) {\\n    if (lo == hi) {\\n      sb.append(s.charAt(lo));\\n    } else {\\n      sb.insert(0, s.charAt(lo));\\n      sb.append(s.charAt(hi));\\n    }\\n    --lo;\\n    ++hi;\\n  }\\n  if (sb.length() > longest.length()) {\\n    longest.delete(0, longest.length());\\n    longest.append(sb);\\n  }\\n}\\n```\n```java\\npublic String longestPalindrome(String s) {\\n  if (s == null || s.length() == 0) {\\n    return \"\";\\n  }\\n  int n = s.length();\\n  boolean[][] dp = generateDP(s);\\n  // Check each substring\\n  int maxLen = 0;\\n  int[] maxIdx = new int[] { 0, 0 };\\n  for (int i = 0; i < n; ++i) {\\n    for (int j = i; j < n; ++j) {\\n      if (dp[i][j] == true) {\\n        if (j - i + 1 > maxLen) {\\n          maxLen = j - i + 1;\\n          maxIdx[0] = i;\\n          maxIdx[1] = j;\\n        }\\n      }\\n    }\\n  }\\n  return s.substring(maxIdx[0], maxIdx[1] + 1);\\n}\\n\\nprivate boolean[][] generateDP(String s) {\\n  int n = s.length();\\n  boolean[][] dp = new boolean[n][n];\\n  // Init\\n  for (int i = 0; i < n; ++i) { // diagonal\\n    dp[i][i] = true;\\n  }\\n  for (int i = 0; i < n - 1; ++i) { // one line below diagonal\\n    dp[i][i + 1] = (s.charAt(i) == s.charAt(i + 1));\\n  }\\n  // DP\\n  for (int i = n - 3; i >= 0; --i) {\\n    for (int j = i + 2; j < n; ++j) {\\n      dp[i][j] = dp[i + 1][j - 1] && s.charAt(i) == s.charAt(j);\\n    }\\n  }\\n  return dp;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1801960,
                "title": "java-multiple-approach-with-explanation",
                "content": "## Please upvote if you like the solution\\n\\n```\\nclass Solution {\\n    \\n    /***\\n     *          **************** Approach - 1 ********************\\n     *\\n     *   In this approach we will try to solve it using Dynamic Programming\\n     */\\n\\n\\n    /***\\n     *     We can take an 2D boolean array, where we will be storing from position -> to position whether the string is palindrome or not\\n     *     Both row and column wise we will be keeping the same String like below. But Column wise we want to denote it as END position\\n     *     and Row wise Start position\\n     *\\n     *     Any position will denote the (row, col) starting from position (row number) till position (col number)\\n     *     Like position (1,3) denotes from position 1 to position 3 whether the string is palindrome or not\\n     *\\n     *     So we won\\'t be considering the position below the diagonal line, because for those position\\n     *     row number > col number meaning start is > end meaning those are not valid position.\\n     *\\n     *    Case-1 : For Gap-0, i.e. position [(0,0), (1,1), (2,2)] values are always TRUE.\\n     *             Because start and end position is same. So, it consists of one character only.\\n     *\\n     *    Case-2 : For Gap-1, i.e. position (0,1), (1,2), (2,3) & (3,4) Compare the Start position and End position.\\n     *             Because there are only two characters are there.\\n     *\\n     *    Case-3 : For all rest of the position check the start and end position if true check for middle part of the string.\\n     *             like for position (1,3) check whether the start and end is same or not, meaning character at position 1\\n     *             and position 3 is same or not.\\n     *             If same, check the middle part of the string i.e. check for (start+1) till (End -1) position.\\n     *             in this case we have to check whether the middle part of the String i.e. (2,2) is\\n     *             palindrome or not.\\n     *\\n     *             To check that middle portions result we can check the left diagonal value i.e. for (i,j) check for (i+1 , j -1)\\n     *             i.e. for pos (1,3) check the position (2,2)\\n     *\\n     *\\n     *                          END --->\\n     *               0        1       2         3         4\\n     *               b        a       b         a         d\\n     *     -------------------------------------------------------\\n     *       0  b   T(b)   F(ab)   T(bab)   F(baba)    F(babad)\\n     *\\n     *   S   1  a          T(a)     F(ab)   T(aba)     F(abad)\\n     *   T\\n     *   A   2  b                   T(b)    F(ba)      F(bad)\\n     *   R\\n     *   T   3  a                           T(a)       F(ad)\\n     *\\n     *       4  d                                      T(d)\\n     *\\n     *\\n     *\\n     *\\n     *\\n     */\\n    public String longestPalindrome1(String str) {\\n\\n        boolean[][] dp = new boolean[str.length()][str.length()];\\n        int start = 0, end = 0;\\n\\n        /**\\n         * The loop should be Diagonal wise Starting with gap = 0 till string length\\n         * First loop it should cover [(0,0), (1,1), (2,2), (3,3), (4,4)]\\n         * Second Loop - (0,1), (1,2), (2,3) & (3,4)\\n         *\\n         * Like this diagonally it should travel and solve the problem.\\n         */\\n        for (int gap = 0; gap < str.length(); gap++) {\\n            for (int i = 0, j = gap; j < dp[0].length; i++, j++) {\\n\\n                /**\\n                 *    Case-1 : For Gap-0, i.e. position [(0,0), (1,1), (2,2)] values are always TRUE.\\n                 *             Because start and end position is same. So, it consists of one character only.\\n                 */\\n                if (gap == 0) {\\n                    dp[i][j] = true;\\n                    continue;\\n                }\\n                /**\\n                 *    Case-2 : For Gap-1, i.e. position (0,1), (1,2), (2,3) & (3,4) Compare the Start position and End position.\\n                 *             Because there are only two characters are there.\\n                 */\\n                if (gap == 1 && str.charAt(i) == str.charAt(j)) {\\n                    dp[i][j] = true;\\n                }\\n                /**\\n                 *  Case-3 : For all rest of the position check the start and end position\\n                 *           If true check for middle part of the string i.e. check for (start+1) till (End -1) position.\\n                 *           Which can be obtained from left diagonal value i.e. for (i,j) check for (i+1 , j -1)\\n                 */\\n                else if (str.charAt(i) == str.charAt(j) && dp[i + 1][j - 1] == true) {\\n                    dp[i][j] = true;\\n                }\\n\\n                /**\\n                 * Keeping track of the Start end End position of the Palindromic String.\\n                 * As Gap is increasing we are not doing any comparison with the previous range.\\n                 * With increasing of the Gap value if the substring is palindrome then it will be\\n                 * the bigger substring.\\n                 */\\n                if (dp[i][j]) {\\n                    start = i;\\n                    end = j;\\n                }\\n\\n            }\\n        }\\n\\n        return str.substring(start, end + 1);\\n    }\\n\\n\\n    /***\\n     *                  *****************   Approach - 2   ********************\\n     *\\n     *  The intention is by taking each position as its probable middle position of the substring, we will try to expand the\\n     *  search by both the direction.\\n     *  Like for any position we will try to expand the the value in the both side and validate whether its a palindrome or not.\\n     *     Expand Start   <--   (position)   --> Expand End\\n     */\\n\\n    int start, end, maxLength = Integer.MIN_VALUE;\\n\\n    public String longestPalindrome(String inputStr) {\\n\\n        /**\\n         * Base case :\\n         * If the string is Empty or single character string then return it.\\n         */\\n        if (inputStr.length() < 2) {\\n            return inputStr;\\n        }\\n\\n        for (int index = 0; index < inputStr.length() - 1; index++) {\\n            /**\\n             * we are calling the same function twice because we are not sure\\n             * the substring size will be of even or odd.\\n             *\\n             * If odd then we will be getting a middle point like for the String\\n             * \"abcdcba\" middle will be 3 i.e. character \\'d\\'\\n             *\\n             * but for the even number the middle will be 2 position like for\\n             * the String \"xyzzyx\" middle will be 2 and 3 position\\n             *\\n             */\\n            expandSearch(inputStr, index, index);\\n            expandSearch(inputStr, index, index + 1);\\n        }\\n\\n        return inputStr.substring(start, end);\\n    }\\n\\n    private void expandSearch(String inputStr, int startPosition, int endPosition) {\\n\\n        while (startPosition >= 0 && endPosition < inputStr.length()\\n                && inputStr.charAt(startPosition) == inputStr.charAt(endPosition)) {\\n\\n            startPosition--;\\n            endPosition++;\\n        }\\n\\n        int substringLength = endPosition - startPosition - 1;\\n\\n        /**\\n         * Keeping track of the max SubString length and corresponding start and end\\n         */\\n        if (substringLength > maxLength) {\\n            this.start = startPosition + 1;\\n            end = endPosition;\\n            this.maxLength = substringLength;\\n        }\\n    }\\n    \\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\n    \\n    /***\\n     *          **************** Approach - 1 ********************\\n     *\\n     *   In this approach we will try to solve it using Dynamic Programming\\n     */\\n\\n\\n    /***\\n     *     We can take an 2D boolean array, where we will be storing from position -> to position whether the string is palindrome or not\\n     *     Both row and column wise we will be keeping the same String like below. But Column wise we want to denote it as END position\\n     *     and Row wise Start position\\n     *\\n     *     Any position will denote the (row, col) starting from position (row number) till position (col number)\\n     *     Like position (1,3) denotes from position 1 to position 3 whether the string is palindrome or not\\n     *\\n     *     So we won\\'t be considering the position below the diagonal line, because for those position\\n     *     row number > col number meaning start is > end meaning those are not valid position.\\n     *\\n     *    Case-1 : For Gap-0, i.e. position [(0,0), (1,1), (2,2)] values are always TRUE.\\n     *             Because start and end position is same. So, it consists of one character only.\\n     *\\n     *    Case-2 : For Gap-1, i.e. position (0,1), (1,2), (2,3) & (3,4) Compare the Start position and End position.\\n     *             Because there are only two characters are there.\\n     *\\n     *    Case-3 : For all rest of the position check the start and end position if true check for middle part of the string.\\n     *             like for position (1,3) check whether the start and end is same or not, meaning character at position 1\\n     *             and position 3 is same or not.\\n     *             If same, check the middle part of the string i.e. check for (start+1) till (End -1) position.\\n     *             in this case we have to check whether the middle part of the String i.e. (2,2) is\\n     *             palindrome or not.\\n     *\\n     *             To check that middle portions result we can check the left diagonal value i.e. for (i,j) check for (i+1 , j -1)\\n     *             i.e. for pos (1,3) check the position (2,2)\\n     *\\n     *\\n     *                          END --->\\n     *               0        1       2         3         4\\n     *               b        a       b         a         d\\n     *     -------------------------------------------------------\\n     *       0  b   T(b)   F(ab)   T(bab)   F(baba)    F(babad)\\n     *\\n     *   S   1  a          T(a)     F(ab)   T(aba)     F(abad)\\n     *   T\\n     *   A   2  b                   T(b)    F(ba)      F(bad)\\n     *   R\\n     *   T   3  a                           T(a)       F(ad)\\n     *\\n     *       4  d                                      T(d)\\n     *\\n     *\\n     *\\n     *\\n     *\\n     */\\n    public String longestPalindrome1(String str) {\\n\\n        boolean[][] dp = new boolean[str.length()][str.length()];\\n        int start = 0, end = 0;\\n\\n        /**\\n         * The loop should be Diagonal wise Starting with gap = 0 till string length\\n         * First loop it should cover [(0,0), (1,1), (2,2), (3,3), (4,4)]\\n         * Second Loop - (0,1), (1,2), (2,3) & (3,4)\\n         *\\n         * Like this diagonally it should travel and solve the problem.\\n         */\\n        for (int gap = 0; gap < str.length(); gap++) {\\n            for (int i = 0, j = gap; j < dp[0].length; i++, j++) {\\n\\n                /**\\n                 *    Case-1 : For Gap-0, i.e. position [(0,0), (1,1), (2,2)] values are always TRUE.\\n                 *             Because start and end position is same. So, it consists of one character only.\\n                 */\\n                if (gap == 0) {\\n                    dp[i][j] = true;\\n                    continue;\\n                }\\n                /**\\n                 *    Case-2 : For Gap-1, i.e. position (0,1), (1,2), (2,3) & (3,4) Compare the Start position and End position.\\n                 *             Because there are only two characters are there.\\n                 */\\n                if (gap == 1 && str.charAt(i) == str.charAt(j)) {\\n                    dp[i][j] = true;\\n                }\\n                /**\\n                 *  Case-3 : For all rest of the position check the start and end position\\n                 *           If true check for middle part of the string i.e. check for (start+1) till (End -1) position.\\n                 *           Which can be obtained from left diagonal value i.e. for (i,j) check for (i+1 , j -1)\\n                 */\\n                else if (str.charAt(i) == str.charAt(j) && dp[i + 1][j - 1] == true) {\\n                    dp[i][j] = true;\\n                }\\n\\n                /**\\n                 * Keeping track of the Start end End position of the Palindromic String.\\n                 * As Gap is increasing we are not doing any comparison with the previous range.\\n                 * With increasing of the Gap value if the substring is palindrome then it will be\\n                 * the bigger substring.\\n                 */\\n                if (dp[i][j]) {\\n                    start = i;\\n                    end = j;\\n                }\\n\\n            }\\n        }\\n\\n        return str.substring(start, end + 1);\\n    }\\n\\n\\n    /***\\n     *                  *****************   Approach - 2   ********************\\n     *\\n     *  The intention is by taking each position as its probable middle position of the substring, we will try to expand the\\n     *  search by both the direction.\\n     *  Like for any position we will try to expand the the value in the both side and validate whether its a palindrome or not.\\n     *     Expand Start   <--   (position)   --> Expand End\\n     */\\n\\n    int start, end, maxLength = Integer.MIN_VALUE;\\n\\n    public String longestPalindrome(String inputStr) {\\n\\n        /**\\n         * Base case :\\n         * If the string is Empty or single character string then return it.\\n         */\\n        if (inputStr.length() < 2) {\\n            return inputStr;\\n        }\\n\\n        for (int index = 0; index < inputStr.length() - 1; index++) {\\n            /**\\n             * we are calling the same function twice because we are not sure\\n             * the substring size will be of even or odd.\\n             *\\n             * If odd then we will be getting a middle point like for the String\\n             * \"abcdcba\" middle will be 3 i.e. character \\'d\\'\\n             *\\n             * but for the even number the middle will be 2 position like for\\n             * the String \"xyzzyx\" middle will be 2 and 3 position\\n             *\\n             */\\n            expandSearch(inputStr, index, index);\\n            expandSearch(inputStr, index, index + 1);\\n        }\\n\\n        return inputStr.substring(start, end);\\n    }\\n\\n    private void expandSearch(String inputStr, int startPosition, int endPosition) {\\n\\n        while (startPosition >= 0 && endPosition < inputStr.length()\\n                && inputStr.charAt(startPosition) == inputStr.charAt(endPosition)) {\\n\\n            startPosition--;\\n            endPosition++;\\n        }\\n\\n        int substringLength = endPosition - startPosition - 1;\\n\\n        /**\\n         * Keeping track of the max SubString length and corresponding start and end\\n         */\\n        if (substringLength > maxLength) {\\n            this.start = startPosition + 1;\\n            end = endPosition;\\n            this.maxLength = substringLength;\\n        }\\n    }\\n    \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 618232,
                "title": "approach-1-using-longest-common-substring-concept",
                "content": "I know it\\'s not the best sol. But when I read Qs, the first sol. came into my mind is by using Longest common substring., because i Haven\\'t read Manacher Algorithm yet. And my sol got wrong answer. Same mistake as described in solution. So, here is the approach 1 sol.. Check whenever you got maximum substring whether it is palindrome or not. if yes update it.. otherwise skip it.\\n```\\nclass Solution {\\npublic:\\n    string longestPalindrome(string s) {\\n        int n=s.length();\\n        string s2=s;\\n        reverse(s2.begin(),s2.end());\\n        return LCSS(s,s2,n);\\n    }\\n    string LCSS(string s1, string s2, int n)\\n    {\\n        string ans;\\n        int DP[n+1][n+1],max=0;\\n        for(int i=0; i<=n; ++i)\\n        {\\n            for(int j=0; j<=n; ++j)\\n            {\\n                if(i==0 || j==0)\\n                    DP[i][j]=0;\\n                else if(s1[i-1]==s2[j-1])\\n                {\\n                    DP[i][j]=1+DP[i-1][j-1];\\n                    if(DP[i][j]>max)\\n                    {\\n                        string temp=s1.substr(i-DP[i][j],DP[i][j]);\\n                        string revtemp=temp;\\n                        reverse(revtemp.begin(),revtemp.end());\\n                            if(revtemp==temp)\\n                            {\\n                                max=DP[i][j];\\n                                ans=temp;\\n                            }\\n                    }\\n                }\\n                else\\n                    DP[i][j]=0;\\n                \\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string longestPalindrome(string s) {\\n        int n=s.length();\\n        string s2=s;\\n        reverse(s2.begin(),s2.end());\\n        return LCSS(s,s2,n);\\n    }\\n    string LCSS(string s1, string s2, int n)\\n    {\\n        string ans;\\n        int DP[n+1][n+1],max=0;\\n        for(int i=0; i<=n; ++i)\\n        {\\n            for(int j=0; j<=n; ++j)\\n            {\\n                if(i==0 || j==0)\\n                    DP[i][j]=0;\\n                else if(s1[i-1]==s2[j-1])\\n                {\\n                    DP[i][j]=1+DP[i-1][j-1];\\n                    if(DP[i][j]>max)\\n                    {\\n                        string temp=s1.substr(i-DP[i][j],DP[i][j]);\\n                        string revtemp=temp;\\n                        reverse(revtemp.begin(),revtemp.end());\\n                            if(revtemp==temp)\\n                            {\\n                                max=DP[i][j];\\n                                ans=temp;\\n                            }\\n                    }\\n                }\\n                else\\n                    DP[i][j]=0;\\n                \\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 337068,
                "title": "c-0ms-clean-code-based-on-expanding-window",
                "content": "C++ 0ms beats 100%\\n\\n```\\nclass Solution {\\npublic:\\n    string longestPalindrome(string s) {\\n        \\n        // edge cases\\n        if(s.length() == 0 || s.length() == 1) return s;\\n        \\n        // to hold max len and its starting index\\n        int maxLenBeginIndex = 0;\\n        int maxLen = 1;\\n        \\n        int mid = 0;\\n        while(mid < s.length()){\\n            \\n            // calculating middle window\\n            \\n            int midBegin = mid;\\n            int midEnd = mid;\\n            \\n            // handling even length palindromes; the middlemost chars will trivially match in even length case\\n            // so expand the middle window as long as possible\\n            while( midEnd + 1 < s.length() && s[midEnd] == s[midEnd + 1]){ midEnd++ ; }\\n            \\n            // for next iteration\\n            mid = midEnd + 1;\\n            \\n            // starting comparison in left and right windows\\n            \\n            // in case of odd len palindrome; both start from mid;\\n            // in case of even; midBegin and midEnd handles it all\\n            int leftWindow = midBegin;\\n            int rightWindow = midEnd;\\n            \\n            // expand the windows left and right simultaneously\\n            while(leftWindow - 1 >= 0 && rightWindow + 1 < s.length() && s[leftWindow - 1] == s[rightWindow + 1]){\\n                    leftWindow--;\\n                    rightWindow++;\\n            }\\n            \\n            // update maxLen is currLen > maxLen\\n            int currLen = rightWindow - leftWindow + 1;\\n            if( currLen  > maxLen ){\\n                maxLenBeginIndex = leftWindow;\\n                maxLen = currLen;\\n            }\\n        }\\n        \\n        return s.substr(maxLenBeginIndex, maxLen);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string longestPalindrome(string s) {\\n        \\n        // edge cases\\n        if(s.length() == 0 || s.length() == 1) return s;\\n        \\n        // to hold max len and its starting index\\n        int maxLenBeginIndex = 0;\\n        int maxLen = 1;\\n        \\n        int mid = 0;\\n        while(mid < s.length()){\\n            \\n            // calculating middle window\\n            \\n            int midBegin = mid;\\n            int midEnd = mid;\\n            \\n            // handling even length palindromes; the middlemost chars will trivially match in even length case\\n            // so expand the middle window as long as possible\\n            while( midEnd + 1 < s.length() && s[midEnd] == s[midEnd + 1]){ midEnd++ ; }\\n            \\n            // for next iteration\\n            mid = midEnd + 1;\\n            \\n            // starting comparison in left and right windows\\n            \\n            // in case of odd len palindrome; both start from mid;\\n            // in case of even; midBegin and midEnd handles it all\\n            int leftWindow = midBegin;\\n            int rightWindow = midEnd;\\n            \\n            // expand the windows left and right simultaneously\\n            while(leftWindow - 1 >= 0 && rightWindow + 1 < s.length() && s[leftWindow - 1] == s[rightWindow + 1]){\\n                    leftWindow--;\\n                    rightWindow++;\\n            }\\n            \\n            // update maxLen is currLen > maxLen\\n            int currLen = rightWindow - leftWindow + 1;\\n            if( currLen  > maxLen ){\\n                maxLenBeginIndex = leftWindow;\\n                maxLen = currLen;\\n            }\\n        }\\n        \\n        return s.substr(maxLenBeginIndex, maxLen);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2156669,
                "title": "c-dynamic-and-brute",
                "content": "**UPVOTE IF HELPFuuL**\\n\\nDYNAMIC APPROACH\\n\\n**PALINDROME in DP**->If its first and last elements are same and the substring after excluding the first and last character is a palindrome.\\n* Hence we can now reduce a bigger problem to smaller problem whose answer may be previously known.\\n\\n* Use a matrix where ```dp[ i ] [ j ]``` represents substring from ith pos to jth pos.\\n* All single characters are palindromes, thus substring with a length 1 are substring by default.\\n* substrings of length 2 are *palin* if both characters are same.\\n* \\nAnd for rest of lengths use the sub problem.\\n\\nNow we need longest so the palindromic substring with longest length is the substring.\\n\\n**BRUTE FORECE**\\n```\\nstring longestPalindrome(string s) {\\n\\n        int n=s.size();\\n        int res=1, start=0;\\n        string ans;\\n        \\n        for(int i=0; i<n; i++)\\n        {\\n            int l=i-1;\\n            int r=i+1;\\n            \\n            while(l>=0 && s[i]==s[l])\\n            {\\n                l--;\\n            }\\n            while(r<n && s[i]==s[r])\\n            {\\n                r++;\\n            }\\n            while(l>=0 && r<n && s[l]==s[r])\\n            {\\n                l--;\\n                r++;\\n            }\\n            int length=(r-1)-(l+1)+1;  \\n            if(length>res)\\n            {\\n                res=length;\\n                start=l+1;\\n            }\\n        }\\n        ans=s.substr(start,res);\\n        return ans;\\n}\\n```\\n\\n**DYNAMIC APPROACH**\\n```\\nclass Solution {\\n\\tpublic:\\n   \\tstring longestPalindrome(string s) {   \\n\\t    int n = s.size();\\n    \\tint dp[n][n];\\n    \\t\\n\\t    memset(dp,0,sizeof(dp));\\n    \\tint end=1;\\n    \\tint strt=0;\\n\\t\\n\\t    for(int i=0;i<n;i++){\\n\\t        dp[i][i] = 1;\\n    \\t}\\n\\t    for(int i=0;i<n-1;i++){\\n\\t        if(s[i]==s[i+1]){\\n    \\t    \\tdp[i][i+1]=1;\\n        \\t\\tstrt=i;end=2;\\n       \\t\\t}\\n\\t    }\\n    \\tfor(int j=2;j<n;j++){\\n\\t        for(int i=0;i< n-j;i++){  \\n           \\t\\tint lft=i;\\n            \\tint rght = i+j;\\n        \\t    \\n    \\t        if(dp[lft+1][rght-1]==1 && s[lft]==s[rght]) \\n\\t            {\\n                \\tdp[lft][rght]=1; strt=i; end=j+1; \\n            \\t}        \\n        \\t}\\n    \\t}\\n    return s.substr(strt, end);\\n\\t}\\n};\\n```\\n![image](https://assets.leetcode.com/users/images/198452f0-bf71-403a-b5c8-ca932253ad55_1655339990.8810625.jpeg)\\n",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```dp[ i ] [ j ]```\n```\\nstring longestPalindrome(string s) {\\n\\n        int n=s.size();\\n        int res=1, start=0;\\n        string ans;\\n        \\n        for(int i=0; i<n; i++)\\n        {\\n            int l=i-1;\\n            int r=i+1;\\n            \\n            while(l>=0 && s[i]==s[l])\\n            {\\n                l--;\\n            }\\n            while(r<n && s[i]==s[r])\\n            {\\n                r++;\\n            }\\n            while(l>=0 && r<n && s[l]==s[r])\\n            {\\n                l--;\\n                r++;\\n            }\\n            int length=(r-1)-(l+1)+1;  \\n            if(length>res)\\n            {\\n                res=length;\\n                start=l+1;\\n            }\\n        }\\n        ans=s.substr(start,res);\\n        return ans;\\n}\\n```\n```\\nclass Solution {\\n\\tpublic:\\n   \\tstring longestPalindrome(string s) {   \\n\\t    int n = s.size();\\n    \\tint dp[n][n];\\n    \\t\\n\\t    memset(dp,0,sizeof(dp));\\n    \\tint end=1;\\n    \\tint strt=0;\\n\\t\\n\\t    for(int i=0;i<n;i++){\\n\\t        dp[i][i] = 1;\\n    \\t}\\n\\t    for(int i=0;i<n-1;i++){\\n\\t        if(s[i]==s[i+1]){\\n    \\t    \\tdp[i][i+1]=1;\\n        \\t\\tstrt=i;end=2;\\n       \\t\\t}\\n\\t    }\\n    \\tfor(int j=2;j<n;j++){\\n\\t        for(int i=0;i< n-j;i++){  \\n           \\t\\tint lft=i;\\n            \\tint rght = i+j;\\n        \\t    \\n    \\t        if(dp[lft+1][rght-1]==1 && s[lft]==s[rght]) \\n\\t            {\\n                \\tdp[lft][rght]=1; strt=i; end=j+1; \\n            \\t}        \\n        \\t}\\n    \\t}\\n    return s.substr(strt, end);\\n\\t}\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 236623,
                "title": "python-expand-around-center-with-explanation",
                "content": "```python\\ndef expand_and_count(s, start, end):\\n    while start >= 0 and end <= len(s) - 1 and s[start] == s[end]:\\n        start -= 1\\n        end += 1\\n        \\n    # The indices used for the below substring are:\\n    # start + 1: because we kept decreasing start by 1 before breaking the loop\\n    # end: because we kept increasing end by 1 before breaking the loop\\n    # and python substring excludes the end index\\n    return s[start + 1 : end]\\n\\nclass Solution(object):\\n    def longestPalindrome(self, s):\\n        \"\"\"\\n        :type s: str\\n        :rtype: str\\n        \"\"\"\\n        longest = \\'\\'\\n        \\n        for i in range(len(s)):\\n            # If palindrom starts with same index and expands\\n            # on both sides, it has odd number of letters\\n            odd = expand_and_count(s, i, i)\\n            # If palindrom starts with consecutive indices and expands\\n            # on both sides, it has even number of letters\\n            even = expand_and_count(s, i, i + 1)\\n            \\n            longer = \\'\\'\\n            \\n            if len(even) > len(odd):\\n                longer = even\\n            else:\\n                longer = odd\\n                \\n            if len(longer) > len(longest):\\n                longest = longer\\n                \\n        return longest\\n```",
                "solutionTags": [],
                "code": "```python\\ndef expand_and_count(s, start, end):\\n    while start >= 0 and end <= len(s) - 1 and s[start] == s[end]:\\n        start -= 1\\n        end += 1\\n        \\n    # The indices used for the below substring are:\\n    # start + 1: because we kept decreasing start by 1 before breaking the loop\\n    # end: because we kept increasing end by 1 before breaking the loop\\n    # and python substring excludes the end index\\n    return s[start + 1 : end]\\n\\nclass Solution(object):\\n    def longestPalindrome(self, s):\\n        \"\"\"\\n        :type s: str\\n        :rtype: str\\n        \"\"\"\\n        longest = \\'\\'\\n        \\n        for i in range(len(s)):\\n            # If palindrom starts with same index and expands\\n            # on both sides, it has odd number of letters\\n            odd = expand_and_count(s, i, i)\\n            # If palindrom starts with consecutive indices and expands\\n            # on both sides, it has even number of letters\\n            even = expand_and_count(s, i, i + 1)\\n            \\n            longer = \\'\\'\\n            \\n            if len(even) > len(odd):\\n                longer = even\\n            else:\\n                longer = odd\\n                \\n            if len(longer) > len(longest):\\n                longest = longer\\n                \\n        return longest\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1310663,
                "title": "easy-to-understand-dp-solution-in-c",
                "content": "```\\nclass Solution {\\npublic:\\n    string longestPalindrome(string s) {\\n        int n=s.size();\\n        string res=\"\";\\n        int leni=1,lenj=1,i,j;\\n        int dp[n+1][n+1];\\n        for(i=0;i<n+1;i++)\\n        {\\n            dp[0][i]=1;\\n            dp[1][i]=1;\\n        }\\n        for(i=2;i<=n;i++)\\n        {\\n            for(j=i;j<=n;j++)\\n            {\\n                if(s[j-1]==s[j-i]&&dp[i-2][j-1]==1)\\n                    dp[i][j]=1,leni=i,lenj=j;\\n                else\\n                    dp[i][j]=0;\\n            }\\n        }\\n        for(i=lenj-leni;i<lenj;i++)\\n            res.push_back(s[i]);\\n        \\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    string longestPalindrome(string s) {\\n        int n=s.size();\\n        string res=\"\";\\n        int leni=1,lenj=1,i,j;\\n        int dp[n+1][n+1];\\n        for(i=0;i<n+1;i++)\\n        {\\n            dp[0][i]=1;\\n            dp[1][i]=1;\\n        }\\n        for(i=2;i<=n;i++)\\n        {\\n            for(j=i;j<=n;j++)\\n            {\\n                if(s[j-1]==s[j-i]&&dp[i-2][j-1]==1)\\n                    dp[i][j]=1,leni=i,lenj=j;\\n                else\\n                    dp[i][j]=0;\\n            }\\n        }\\n        for(i=lenj-leni;i<lenj;i++)\\n            res.push_back(s[i]);\\n        \\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1687940,
                "title": "simple-dp-solution-based-on-aditya-verma-s-video",
                "content": "```\\nclass Solution {\\npublic:\\n    string longestPalindrome(string s) {\\n        string s1=s;\\n        reverse(s.begin(),s.end());\\n        string ans;\\n       int n=s.size();\\n        int res=0;\\n      int dp[n+1][n+1];\\n        for(int i=0;i<=n;i++){\\n            for(int j=0;j<=n;j++){\\n                if(i==0||j==0)\\n                    dp[i][j]=0;\\n               else if(s[i-1]==s1[j-1]){\\n                    dp[i][j]=dp[i-1][j-1]+1;\\n                   \\n                   \\n                }\\n                else\\n                    dp[i][j]=0;\\n                \\n                 if(dp[i][j]>res)\\n                    {\\n                        string temp=s.substr(i-dp[i][j],dp[i][j]);\\n                        string rev=temp;\\n                        reverse(rev.begin(),rev.end());\\n                        if(temp==rev){    //check if common substring is palindromic or not\\n                             ans=temp;\\n                        res=dp[i][j];\\n                        }\\n                           \\n                    }\\n            }\\n            \\n        }\\n        return ans;\\n    }\\n};\\n```\\n// if you like the solution plz upvote",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string longestPalindrome(string s) {\\n        string s1=s;\\n        reverse(s.begin(),s.end());\\n        string ans;\\n       int n=s.size();\\n        int res=0;\\n      int dp[n+1][n+1];\\n        for(int i=0;i<=n;i++){\\n            for(int j=0;j<=n;j++){\\n                if(i==0||j==0)\\n                    dp[i][j]=0;\\n               else if(s[i-1]==s1[j-1]){\\n                    dp[i][j]=dp[i-1][j-1]+1;\\n                   \\n                   \\n                }\\n                else\\n                    dp[i][j]=0;\\n                \\n                 if(dp[i][j]>res)\\n                    {\\n                        string temp=s.substr(i-dp[i][j],dp[i][j]);\\n                        string rev=temp;\\n                        reverse(rev.begin(),rev.end());\\n                        if(temp==rev){    //check if common substring is palindromic or not\\n                             ans=temp;\\n                        res=dp[i][j];\\n                        }\\n                           \\n                    }\\n            }\\n            \\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1057629,
                "title": "python-super-simple-easy-understanding-solution-o-n-2",
                "content": "\\tclass Solution:\\n\\t\\tdef longestPalindrome(self, s: str) -> str:\\n\\t\\t\\tres = \"\"\\n\\t\\t\\tlength = len(s)\\n\\t\\t\\tdef helper(left: int, right: int):\\n\\t\\t\\t\\twhile left >= 0 and right < length and s[left] == s[right]:\\n\\t\\t\\t\\t\\tleft -= 1\\n\\t\\t\\t\\t\\tright += 1\\n\\t\\t\\t\\t\\t\\n\\t\\t\\t\\treturn s[left + 1 : right]\\n\\t\\t\\t\\n\\t\\t\\t\\n\\t\\t\\tfor index in range(len(s)):\\n\\t\\t\\t\\tres = max(helper(index, index), helper(index, index + 1), res, key = len)\\n\\t\\t\\t\\t\\n\\t\\t\\treturn res",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "\\tclass Solution:\\n\\t\\tdef longestPalindrome(self, s: str) -> str:\\n\\t\\t\\tres = \"\"\\n\\t\\t\\tlength = len(s)\\n\\t\\t\\tdef helper(left: int, right: int):\\n\\t\\t\\t\\twhile left >= 0 and right < length and s[left] == s[right]:\\n\\t\\t\\t\\t\\tleft -= 1\\n\\t\\t\\t\\t\\tright += 1\\n\\t\\t\\t\\t\\t\\n\\t\\t\\t\\treturn s[left + 1 : right]\\n\\t\\t\\t\\n\\t\\t\\t\\n\\t\\t\\tfor index in range(len(s)):\\n\\t\\t\\t\\tres = max(helper(index, index), helper(index, index + 1), res, key = len)\\n\\t\\t\\t\\t\\n\\t\\t\\treturn res",
                "codeTag": "Java"
            },
            {
                "id": 2157990,
                "title": "c-2-approaches-two-pointers-dp-simple-efficinet-solution-dlc-june-day-16",
                "content": "**Approach-1:** Use 2 pointers approach. \\nFor odd length palindromic substring, we start from same index and check for near characters\\nFor even length palindromic substring, start from adjacent index and check for near characters.\\n\\n**Time Complexity: O(2N^2)\\nSpace Complexity: O(1)**\\n\\n**Code:**\\n```\\nclass Solution {\\npublic:\\n    string longestPalindrome(string s) \\n    {\\n        int lenMax = 0;\\n        string res;\\n        \\n        for(int i=0; i<s.length(); i++)\\n        {\\n            string odd = pali_subs(s, i, i); //start from same index for odd length palindrome\\n            long_subs(odd, res, lenMax);\\n            string even = pali_subs(s, i, i+1); //start from adjacent index for even length palindrome\\n            long_subs(even, res, lenMax);\\n        }\\n        return res;\\n    }\\n\\t\\n\\tstring pali_subs(string &s, int L, int R)\\n    {\\n        int n=s.size();\\n        while(L>=0 && R<n) //iterate until L and R cross the boundary\\n        {\\n            if(s[L]!=s[R]) break;\\n            L--;\\n            R++;\\n        }\\n        return s.substr(L+1, R-1-L); //return palindromic substring\\n    }\\n    \\n    void long_subs(string &new_s, string &res, int &lenMax)\\n    {\\n        if(new_s.size()>lenMax) //if \\n        {\\n            res = new_s;\\n            lenMax = new_s.size();\\n        }\\n    }\\n};\\n```\\n**Please upvote if it helps \\u2764\\uFE0F\\uD83D\\uDE0A**\\n\\n**Approach-2:** Use DP and mark already covered small sub-string is palindromic or not and use it for other longer sub-string\\n\\n**Time Complexity: O(N^2)\\nSpace Complexity: O(n^2)**\\n\\n**Code:**\\n```\\nclass Solution \\n{\\npublic:\\n    string longestPalindrome(string s) \\n    {\\n        int n=s.size(); \\n        \\n        //dp[i][j] will be false if substring s[i..j] is not palindrome, Else true\\n        vector<vector<bool>> dp(n, vector<bool> (n,false));\\n        \\n        //All substrings of length 1 are palindromes\\n        for(int i=0; i<n; i++) dp[i][i]=true;\\n        \\n        int start=0, lenMax=1;\\n        \\n        // check for sub-string of length 2.\\n        for(int i=0; i<n-1; i++) \\n        {\\n            if(s[i]==s[i+1])\\n            {\\n                dp[i][i+1] = true;\\n                start = i;\\n                lenMax = 2;\\n            }\\n        }\\n        \\n        // Check for sub-string of length greater than 2.\\n        for(int k=3; k<=n; k++)  // k is length of substring\\n        {\\n            for(int i=0; i<n-k+1; i++) // Fix the starting index\\n            {\\n                int j=i+k-1; // Get the ending index of substring from starting index i and length k\\n                \\n                // checking for sub-string from ith index to jth index if s[i+1] to s[j-1] is a palindrome\\n                if(dp[i+1][j-1]==true && s[i]==s[j])\\n                {\\n                    dp[i][j] = true;\\n                    \\n                    if(k>lenMax)\\n                    {\\n                        lenMax = k;\\n                        start=i;\\n                    }\\n                }\\n            }\\n        }\\n        \\n        return s.substr(start, lenMax); //print sub-string from start to lenMax\\n    }\\n};\\n```\\n\\n**Please upvote if it helps \\u2764\\uFE0F\\uD83D\\uDE0A**",
                "solutionTags": [
                    "C++",
                    "C",
                    "Two Pointers",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string longestPalindrome(string s) \\n    {\\n        int lenMax = 0;\\n        string res;\\n        \\n        for(int i=0; i<s.length(); i++)\\n        {\\n            string odd = pali_subs(s, i, i); //start from same index for odd length palindrome\\n            long_subs(odd, res, lenMax);\\n            string even = pali_subs(s, i, i+1); //start from adjacent index for even length palindrome\\n            long_subs(even, res, lenMax);\\n        }\\n        return res;\\n    }\\n\\t\\n\\tstring pali_subs(string &s, int L, int R)\\n    {\\n        int n=s.size();\\n        while(L>=0 && R<n) //iterate until L and R cross the boundary\\n        {\\n            if(s[L]!=s[R]) break;\\n            L--;\\n            R++;\\n        }\\n        return s.substr(L+1, R-1-L); //return palindromic substring\\n    }\\n    \\n    void long_subs(string &new_s, string &res, int &lenMax)\\n    {\\n        if(new_s.size()>lenMax) //if \\n        {\\n            res = new_s;\\n            lenMax = new_s.size();\\n        }\\n    }\\n};\\n```\n```\\nclass Solution \\n{\\npublic:\\n    string longestPalindrome(string s) \\n    {\\n        int n=s.size(); \\n        \\n        //dp[i][j] will be false if substring s[i..j] is not palindrome, Else true\\n        vector<vector<bool>> dp(n, vector<bool> (n,false));\\n        \\n        //All substrings of length 1 are palindromes\\n        for(int i=0; i<n; i++) dp[i][i]=true;\\n        \\n        int start=0, lenMax=1;\\n        \\n        // check for sub-string of length 2.\\n        for(int i=0; i<n-1; i++) \\n        {\\n            if(s[i]==s[i+1])\\n            {\\n                dp[i][i+1] = true;\\n                start = i;\\n                lenMax = 2;\\n            }\\n        }\\n        \\n        // Check for sub-string of length greater than 2.\\n        for(int k=3; k<=n; k++)  // k is length of substring\\n        {\\n            for(int i=0; i<n-k+1; i++) // Fix the starting index\\n            {\\n                int j=i+k-1; // Get the ending index of substring from starting index i and length k\\n                \\n                // checking for sub-string from ith index to jth index if s[i+1] to s[j-1] is a palindrome\\n                if(dp[i+1][j-1]==true && s[i]==s[j])\\n                {\\n                    dp[i][j] = true;\\n                    \\n                    if(k>lenMax)\\n                    {\\n                        lenMax = k;\\n                        start=i;\\n                    }\\n                }\\n            }\\n        }\\n        \\n        return s.substr(start, lenMax); //print sub-string from start to lenMax\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1381108,
                "title": "c-solution-for-5-longest-palindromic-substring-using-dp",
                "content": "```\\nclass Solution {\\npublic:\\n    string longest_common_substring(string str1, string str2) \\n    {   \\n        int s1 = str1.size(); int s2 = str2.size();\\n        int dp[s1+1][s2+1];\\n        string res ; int max = 0 ;\\n\\n        for(int i=0; i<=s1; i++)\\n        {\\n            for(int j=0; j<=s2; j++)\\n            {   if(i==0 || j==0){ dp[i][j] = 0;}\\n             \\n                else if(str1[i-1] == str2[j-1])\\n                {\\n                    dp[i][j] = 1 + dp[i-1][j-1];\\n                    \\n                    if(dp[i][j]>max)\\n                    {\\n                        string temp = str1.substr(i-dp[i][j], dp[i][j]) ;\\n                        \\n                        string revtemp = string(temp.rbegin(),temp.rend());\\n                        if(revtemp==temp)\\n                        {\\n                            max = dp[i][j] ;\\n                            res = temp ;\\n                        }\\n                    }\\n                }\\n                else\\n                { dp[i][j] = 0 ; }\\n            }\\n        }\\n\\n        return res;\\n    }\\n    string longestPalindrome(string s)\\n    {\\n        string srev = string(s.rbegin(),s.rend());\\n        return longest_common_substring(s, srev); \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string longest_common_substring(string str1, string str2) \\n    {   \\n        int s1 = str1.size(); int s2 = str2.size();\\n        int dp[s1+1][s2+1];\\n        string res ; int max = 0 ;\\n\\n        for(int i=0; i<=s1; i++)\\n        {\\n            for(int j=0; j<=s2; j++)\\n            {   if(i==0 || j==0){ dp[i][j] = 0;}\\n             \\n                else if(str1[i-1] == str2[j-1])\\n                {\\n                    dp[i][j] = 1 + dp[i-1][j-1];\\n                    \\n                    if(dp[i][j]>max)\\n                    {\\n                        string temp = str1.substr(i-dp[i][j], dp[i][j]) ;\\n                        \\n                        string revtemp = string(temp.rbegin(),temp.rend());\\n                        if(revtemp==temp)\\n                        {\\n                            max = dp[i][j] ;\\n                            res = temp ;\\n                        }\\n                    }\\n                }\\n                else\\n                { dp[i][j] = 0 ; }\\n            }\\n        }\\n\\n        return res;\\n    }\\n    string longestPalindrome(string s)\\n    {\\n        string srev = string(s.rbegin(),s.rend());\\n        return longest_common_substring(s, srev); \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1137306,
                "title": "2-explained-solutions-for-your-coding-interview",
                "content": "First Solution - Brute Force:\\nbasically trying every possible substring in the string:\\n\\n```\\nvar longestPalindrome = function (s) {\\n  for (let j = s.length - 1; j >= 0; j--) {\\n    let i = 0,\\n      k = j;\\n    while (k < s.length) {\\n      let substr = s.substring(i, k + 1);\\n      if (isPalindrome(substr)) return substr;\\n      i++, k++;\\n    }\\n  }\\n  return \"\";\\n};\\n\\nfunction isPalindrome(str) {\\n  let l = 0,\\n    r = str.length - 1;\\n  while (l < r) {\\n    if (str[l] !== str[r]) return false;\\n    l++, r--;\\n  }\\n  return true;\\n}\\n```\\n\\nSecond Solution - Optimized:\\nFor each char in str, consider it were the middle, then try to expand the substring as long as left and right sides are equal\\n\\n```\\nvar longestPalindrome = function (s) {\\n      let res = \\'\\';\\n      for(let i = 0; i < s.length; i++){\\n          // Odd - if there is only 1 char in the middle, like \\'bob\\'\\n          let lOdd = i, rOdd = i;\\n          expandAroundCenter(lOdd, rOdd)\\n          //Even - 2 chars in the middle, like \\'kbbk\\'\\n          let lEven = i, rEven = i + 1;\\n          expandAroundCenter(lEven, rEven);\\n      }\\n    // helper\\n      function expandAroundCenter(left, right){\\n        while(left >= 0 && right < s.length && s[left] === s[right]){\\n          let subStr = s.substring(left, right + 1);\\n          if(subStr.length > res.length){\\n            res = subStr;\\n          }\\n          left--;\\n          right++;\\n        }\\n      }\\n      return res;\\n};\\n  ```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar longestPalindrome = function (s) {\\n  for (let j = s.length - 1; j >= 0; j--) {\\n    let i = 0,\\n      k = j;\\n    while (k < s.length) {\\n      let substr = s.substring(i, k + 1);\\n      if (isPalindrome(substr)) return substr;\\n      i++, k++;\\n    }\\n  }\\n  return \"\";\\n};\\n\\nfunction isPalindrome(str) {\\n  let l = 0,\\n    r = str.length - 1;\\n  while (l < r) {\\n    if (str[l] !== str[r]) return false;\\n    l++, r--;\\n  }\\n  return true;\\n}\\n```\n```\\nvar longestPalindrome = function (s) {\\n      let res = \\'\\';\\n      for(let i = 0; i < s.length; i++){\\n          // Odd - if there is only 1 char in the middle, like \\'bob\\'\\n          let lOdd = i, rOdd = i;\\n          expandAroundCenter(lOdd, rOdd)\\n          //Even - 2 chars in the middle, like \\'kbbk\\'\\n          let lEven = i, rEven = i + 1;\\n          expandAroundCenter(lEven, rEven);\\n      }\\n    // helper\\n      function expandAroundCenter(left, right){\\n        while(left >= 0 && right < s.length && s[left] === s[right]){\\n          let subStr = s.substring(left, right + 1);\\n          if(subStr.length > res.length){\\n            res = subStr;\\n          }\\n          left--;\\n          right++;\\n        }\\n      }\\n      return res;\\n};\\n  ```",
                "codeTag": "Unknown"
            },
            {
                "id": 801301,
                "title": "java-easy-to-understand-expand-from-mid-to-end",
                "content": "**Please upvote if helpful!!**\\n\\n```\\nclass Solution {\\n   public String longestPalindrome(String s) {\\n\\n        if (s.length() <= 1) return s;\\n\\n        String result = \"\";\\n        for (int i = 0; i < s.length(); i++) {\\n\\n            String odd = expandRange(s, i, i);\\n\\n            if (odd.length() > result.length()) {\\n                result = odd;\\n            }\\n\\n            String even = expandRange(s, i, i + 1);\\n\\n            if (even.length() > result.length()) {\\n                result = even;\\n            }\\n        }\\n\\n        return result;\\n    }\\n\\n\\n    private String expandRange(String s, int left, int right) {\\n\\n        String string = s;\\n        while (left >= 0 && right < s.length() && s.charAt(left) == s.charAt(right)) {\\n            left--;\\n            right++;\\n        }\\n        return string.substring(left + 1, right); //left + 1 because after 0 the left will be -1 and the substring method begin index is inclusive.\\n        // we need not do to right + 1 because right will point  to s.length when it reaches end of string and the substring method end index is exclusive.\\n\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n   public String longestPalindrome(String s) {\\n\\n        if (s.length() <= 1) return s;\\n\\n        String result = \"\";\\n        for (int i = 0; i < s.length(); i++) {\\n\\n            String odd = expandRange(s, i, i);\\n\\n            if (odd.length() > result.length()) {\\n                result = odd;\\n            }\\n\\n            String even = expandRange(s, i, i + 1);\\n\\n            if (even.length() > result.length()) {\\n                result = even;\\n            }\\n        }\\n\\n        return result;\\n    }\\n\\n\\n    private String expandRange(String s, int left, int right) {\\n\\n        String string = s;\\n        while (left >= 0 && right < s.length() && s.charAt(left) == s.charAt(right)) {\\n            left--;\\n            right++;\\n        }\\n        return string.substring(left + 1, right); //left + 1 because after 0 the left will be -1 and the substring method begin index is inclusive.\\n        // we need not do to right + 1 because right will point  to s.length when it reaches end of string and the substring method end index is exclusive.\\n\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 288371,
                "title": "python-solution-by-using-dynamic-programming",
                "content": "```python\\nclass Solution(object):\\n    def longestPalindrome(self, s):\\n        \"\"\"\\n        :type s: str\\n        :rtype: str\\n        \"\"\"\\n        #1. create a 2D array, size is len(s) * len(s)\\n        dp = [[False]*len(s) for _ in range(len(s))]\\n        \\n        #2. initial lcs related char index\\n        lcsStartIndex = 0\\n        lcsEndIndex = 0\\n        \\n        #3. dp algo\\n        \"\"\"\\n            a b a\\n            0 1 2\\n        a 0 T X X\\n        b 1 F T X\\n        a 2 T F T\\n        \"\"\"\\n        for i in range(len(s)):\\n            #what we need is only the left bottom part\\n            start = i\\n            end = i\\n            while start >= 0:\\n                #case1. if sub-string is \\'a\\'\\n                if start == end:\\n                    dp[start][end] = True\\n                #case2. if sub-string is \\'ab\\'\\n                #We need this case because start + 1 may larger than end - 1 if using case3 directly\\n                elif start + 1 == end:\\n                    dp[start][end] = s[start] == s[end]\\n                #case3. if sub-string is \\'aba\\' \\'abac\\' ..etc, i.e. len(sub) >= 3\\n                else:\\n                    dp[start][end] = dp[start+1][end-1] and (s[start] == s[end])\\n            \\n                #if dp[start][end] is palidromic, check is it longer than current solution\\n                if dp[start][end] and (end - start + 1) > (lcsEndIndex - lcsStartIndex + 1):\\n                    lcsStartIndex = start\\n                    lcsEndIndex = end\\n                \\n                start = start - 1\\n        \\n        return s[lcsStartIndex:lcsEndIndex+1]\\n```",
                "solutionTags": [
                    "Python",
                    "Dynamic Programming"
                ],
                "code": "```python\\nclass Solution(object):\\n    def longestPalindrome(self, s):\\n        \"\"\"\\n        :type s: str\\n        :rtype: str\\n        \"\"\"\\n        #1. create a 2D array, size is len(s) * len(s)\\n        dp = [[False]*len(s) for _ in range(len(s))]\\n        \\n        #2. initial lcs related char index\\n        lcsStartIndex = 0\\n        lcsEndIndex = 0\\n        \\n        #3. dp algo\\n        \"\"\"\\n            a b a\\n            0 1 2\\n        a 0 T X X\\n        b 1 F T X\\n        a 2 T F T\\n        \"\"\"\\n        for i in range(len(s)):\\n            #what we need is only the left bottom part\\n            start = i\\n            end = i\\n            while start >= 0:\\n                #case1. if sub-string is \\'a\\'\\n                if start == end:\\n                    dp[start][end] = True\\n                #case2. if sub-string is \\'ab\\'\\n                #We need this case because start + 1 may larger than end - 1 if using case3 directly\\n                elif start + 1 == end:\\n                    dp[start][end] = s[start] == s[end]\\n                #case3. if sub-string is \\'aba\\' \\'abac\\' ..etc, i.e. len(sub) >= 3\\n                else:\\n                    dp[start][end] = dp[start+1][end-1] and (s[start] == s[end])\\n            \\n                #if dp[start][end] is palidromic, check is it longer than current solution\\n                if dp[start][end] and (end - start + 1) > (lcsEndIndex - lcsStartIndex + 1):\\n                    lcsStartIndex = start\\n                    lcsEndIndex = end\\n                \\n                start = start - 1\\n        \\n        return s[lcsStartIndex:lcsEndIndex+1]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1110760,
                "title": "clean-python-not-fastest",
                "content": "```python\\nclass Solution:    \\n    def isPalindrome(self, s: str) -> bool:\\n        return s == s[::-1]\\n    \\n    def longestPalindrome(self, s: str) -> str:\\n        # so I want to create frames of different lengths\\n        # that will move along a string\\n        # so if string is abba\\n        # the first frame is abba\\n        # the second iteration be: abb, bba\\n        # third iteration be: ab, bb, ba\\n        # we start with widest frame, because we are after longest\\n        # palindromic substring\\n        # right off the bat check if the input itself is a non empty palindromic string\\n        if not s:\\n            raise Exception(\"You werent supposed to be null\")\\n            \\n        if self.isPalindrome(s):\\n            return s\\n                \\n        for i in range(len(s), 0, -1):\\n            for j in range(0, len(s)-i+1): \\n                candidate = s[j:j+i]\\n                if self.isPalindrome(candidate):\\n                    return candidate\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```python\\nclass Solution:    \\n    def isPalindrome(self, s: str) -> bool:\\n        return s == s[::-1]\\n    \\n    def longestPalindrome(self, s: str) -> str:\\n        # so I want to create frames of different lengths\\n        # that will move along a string\\n        # so if string is abba\\n        # the first frame is abba\\n        # the second iteration be: abb, bba\\n        # third iteration be: ab, bb, ba\\n        # we start with widest frame, because we are after longest\\n        # palindromic substring\\n        # right off the bat check if the input itself is a non empty palindromic string\\n        if not s:\\n            raise Exception(\"You werent supposed to be null\")\\n            \\n        if self.isPalindrome(s):\\n            return s\\n                \\n        for i in range(len(s), 0, -1):\\n            for j in range(0, len(s)-i+1): \\n                candidate = s[j:j+i]\\n                if self.isPalindrome(candidate):\\n                    return candidate\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3308,
                "title": "easy-java-solution-with-o-1-space-and-o-n-2-time",
                "content": "The basic idea is to traverse all the palindromes with its pivot range from the first char of string s to the last char of string s (consider both even length and odd length situation). Use StringBuilder to minimize the space complexity. Here is the code, feast yourself:\\n\\n    public class Solution {\\n    StringBuilder longest = new StringBuilder(\"\");\\n    \\n    public String longestPalindrome(String s) {\\n        if (s.length() <= 1) return s;\\n        \\n        for (int i = 0; i < s.length(); i++) {\\n            expand(s, longest, i, i); //odd\\n            expand(s, longest, i, i + 1); //even\\n        }\\n        \\n        return longest.toString();\\n    }\\n    \\n    private void expand(String s, StringBuilder longest, int i, int j) {\\n        while (i >= 0 && j < s.length()) {\\n            if (s.charAt(i) == s.charAt(j)) {\\n                if (j - i + 1 > longest.length()) {\\n                    longest.delete(0, longest.length());\\n                    longest.append(s.substring(i, j + 1));\\n                }\\n                i--;\\n                j++;\\n            }\\n            else\\n                break;\\n        }\\n    }\\n}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    StringBuilder longest = new StringBuilder(\"\");\\n    \\n    public String longestPalindrome(String s) {\\n        if (s.length() <= 1) return s;\\n        \\n        for (int i = 0; i < s.length(); i++) {\\n            expand(s, longest, i, i); //odd\\n            expand(s, longest, i, i + 1); //even\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2881157,
                "title": "js-easy-solution",
                "content": "```\\nvar longestPalindrome = function(s) {\\n    let res = \"\";\\n    let max = 0;\\n\\n    for(let i = 0; i < s.length; i++){\\n        for(let j = 0; j <= 1; j++){\\n            let l = i;\\n            let r = i + j;\\n\\n            while(l >= 0 && r < s.length && s[l] === s[r]){\\n                let len = r - l + 1;\\n                if(len > max){\\n                    res = s.substring(l, r + 1);\\n                    max = len;\\n                }\\n                l--;\\n                r++;\\n            }\\n        }\\n    }\\n    return res;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar longestPalindrome = function(s) {\\n    let res = \"\";\\n    let max = 0;\\n\\n    for(let i = 0; i < s.length; i++){\\n        for(let j = 0; j <= 1; j++){\\n            let l = i;\\n            let r = i + j;\\n\\n            while(l >= 0 && r < s.length && s[l] === s[r]){\\n                let len = r - l + 1;\\n                if(len > max){\\n                    res = s.substring(l, r + 1);\\n                    max = len;\\n                }\\n                l--;\\n                r++;\\n            }\\n        }\\n    }\\n    return res;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1317343,
                "title": "easy-c-solution-using-dp",
                "content": "```\\nclass Solution \\n{\\npublic:\\n    string longestPalindrome(string s)\\n    {\\n        int n=s.length(),start=0,len=0,dp[n][n];\\n        memset(dp,false,sizeof(dp));\\n        for(int i=0;i<n;i++)\\n        {\\n            dp[i][i]=true;\\n            len=1;\\n            start=i;\\n        }\\n        for(int i=0;i<n-1;i++)\\n        {\\n            if(s[i]==s[i+1])\\n            {\\n                dp[i][i+1]=true;\\n                start=i;\\n                len=2;\\n            }\\n        }\\n        for(int k=3;k<=n;k++)\\n        {\\n            for(int i=0;i<=n-k;i++)\\n            {\\n                int j=i+k-1;\\n                if(s[i]==s[j] && dp[i+1][j-1])\\n                {\\n                    dp[i][j]=true;\\n                    start=i;\\n                    len=max(len,k);\\n                }\\n            }\\n        }\\n        return s.substr(start,len);\\n    }\\n};\\n```\\n***Please upvote if you have got any help from my code. Thank you.***",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution \\n{\\npublic:\\n    string longestPalindrome(string s)\\n    {\\n        int n=s.length(),start=0,len=0,dp[n][n];\\n        memset(dp,false,sizeof(dp));\\n        for(int i=0;i<n;i++)\\n        {\\n            dp[i][i]=true;\\n            len=1;\\n            start=i;\\n        }\\n        for(int i=0;i<n-1;i++)\\n        {\\n            if(s[i]==s[i+1])\\n            {\\n                dp[i][i+1]=true;\\n                start=i;\\n                len=2;\\n            }\\n        }\\n        for(int k=3;k<=n;k++)\\n        {\\n            for(int i=0;i<=n-k;i++)\\n            {\\n                int j=i+k-1;\\n                if(s[i]==s[j] && dp[i+1][j-1])\\n                {\\n                    dp[i][j]=true;\\n                    start=i;\\n                    len=max(len,k);\\n                }\\n            }\\n        }\\n        return s.substr(start,len);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 241980,
                "title": "concise-c-solution",
                "content": "This is my concise C solution. Please comment your thought\\n```\\nchar* longestPalindrome(char* s) {\\n    char *start, *end;\\n    char *p = s, *subStart = s;\\n    int maxLen = 1;\\n    while(*p){\\n        start = p; end = p;\\n        \\n        while(*(end+1) && *(end+1) == *end){\\n            end++; // skip duplicates\\n        }\\n        p = end + 1;\\n        \\n        while(*(end + 1) && (start > s) && *(end + 1) == *(start - 1)){\\n            start--;\\n            end++;\\n        }\\n        if(end - start + 1 > maxLen){\\n            maxLen = end - start + 1;\\n            subStart = start;\\n        }\\n    }\\n    \\n    char *rst = (char *) calloc(maxLen + 1, sizeof(char));\\n    strncpy(rst, subStart, maxLen);\\n    return rst;\\n}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nchar* longestPalindrome(char* s) {\\n    char *start, *end;\\n    char *p = s, *subStart = s;\\n    int maxLen = 1;\\n    while(*p){\\n        start = p; end = p;\\n        \\n        while(*(end+1) && *(end+1) == *end){\\n            end++; // skip duplicates\\n        }\\n        p = end + 1;\\n        \\n        while(*(end + 1) && (start > s) && *(end + 1) == *(start - 1)){\\n            start--;\\n            end++;\\n        }\\n        if(end - start + 1 > maxLen){\\n            maxLen = end - start + 1;\\n            subStart = start;\\n        }\\n    }\\n    \\n    char *rst = (char *) calloc(maxLen + 1, sizeof(char));\\n    strncpy(rst, subStart, maxLen);\\n    return rst;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 408930,
                "title": "java-simple-and-concise-solution-with-detailed-explanation",
                "content": "```\\n\\t\\t// core logic: with one character and 2 characters as center, find the palindrome for each case, and whenever you encounter the longest palindrome, update it\\n        // two cases are needed to handle the odd and even cases separately\\n        private static String longestPalindrome(String s) {\\n            if (s == null || s.length() <= 1 || s.equals(\"\")) {\\n                return s;\\n            }\\n    \\n            String longest = s.substring(0, 1);\\n            for (int i = 0; i < s.length(); i++) {\\n                String temp = palindromeHelper(s, i, i);  // odd length\\n                if (temp.length() > longest.length()) {\\n                    longest = temp;\\n                }\\n    \\n                temp = palindromeHelper(s, i, i + 1);  // even length\\n                if (temp.length() > longest.length()) {\\n                    longest = temp;\\n                }\\n            }\\n            return longest;\\n        }\\n    \\n        // given a string and the CENTER(S) of the palindrome (i and i+1), find the longest possible palindrome\\n        // from center, go left and right till characters are same and return the longest palindromic substring\\n        private static String palindromeHelper(String string, int begin, int end) {\\n            while (begin >= 0 && end < string.length() && string.charAt(begin) == string.charAt(end)) {\\n                begin--;\\n                end++;\\n            }\\n            return string.substring(begin + 1, end);\\n        }\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n\\t\\t// core logic: with one character and 2 characters as center, find the palindrome for each case, and whenever you encounter the longest palindrome, update it\\n        // two cases are needed to handle the odd and even cases separately\\n        private static String longestPalindrome(String s) {\\n            if (s == null || s.length() <= 1 || s.equals(\"\")) {\\n                return s;\\n            }\\n    \\n            String longest = s.substring(0, 1);\\n            for (int i = 0; i < s.length(); i++) {\\n                String temp = palindromeHelper(s, i, i);  // odd length\\n                if (temp.length() > longest.length()) {\\n                    longest = temp;\\n                }\\n    \\n                temp = palindromeHelper(s, i, i + 1);  // even length\\n                if (temp.length() > longest.length()) {\\n                    longest = temp;\\n                }\\n            }\\n            return longest;\\n        }\\n    \\n        // given a string and the CENTER(S) of the palindrome (i and i+1), find the longest possible palindrome\\n        // from center, go left and right till characters are same and return the longest palindromic substring\\n        private static String palindromeHelper(String string, int begin, int end) {\\n            while (begin >= 0 && end < string.length() && string.charAt(begin) == string.charAt(end)) {\\n                begin--;\\n                end++;\\n            }\\n            return string.substring(begin + 1, end);\\n        }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3190,
                "title": "11-line-python-solution-112ms",
                "content": "Just a Python version of this brilliant [C++ solution][1]. `while k < lenS - 1 and s[k] == s[k + 1]: k += 1` is very efficient and can handle both odd-length (`abbba`) and even-length (`abbbba`).\\n\\n    def longestPalindrome(self, s):\\n        lenS = len(s)\\n        if lenS <= 1: return s\\n        minStart, maxLen, i = 0, 1, 0\\n        while i < lenS:\\n            if lenS - i <= maxLen / 2: break\\n            j, k = i, i\\n            while k < lenS - 1 and s[k] == s[k + 1]: k += 1\\n            i = k + 1\\n            while k < lenS - 1 and j and s[k + 1] == s[j - 1]:  k, j = k + 1, j - 1\\n            if k - j + 1 > maxLen: minStart, maxLen = j, k - j + 1\\n        return s[minStart: minStart + maxLen]\\n\\n\\n  [1]: https://leetcode.com/discuss/32204/simple-c-solution-8ms-13-lines",
                "solutionTags": [
                    "Python"
                ],
                "code": "Just a Python version of this brilliant [C++ solution][1]. `while k < lenS - 1 and s[k] == s[k + 1]: k += 1` is very efficient and can handle both odd-length (`abbba`) and even-length (`abbbba`).\\n\\n    def longestPalindrome(self, s):\\n        lenS = len(s)\\n        if lenS <= 1: return s\\n        minStart, maxLen, i = 0, 1, 0\\n        while i < lenS:\\n            if lenS - i <= maxLen / 2: break\\n            j, k = i, i\\n            while k < lenS - 1 and s[k] == s[k + 1]: k += 1\\n            i = k + 1\\n            while k < lenS - 1 and j and s[k + 1] == s[j - 1]:  k, j = k + 1, j - 1\\n            if k - j + 1 > maxLen: minStart, maxLen = j, k - j + 1\\n        return s[minStart: minStart + maxLen]\\n\\n\\n  [1]: https://leetcode.com/discuss/32204/simple-c-solution-8ms-13-lines",
                "codeTag": "Python3"
            },
            {
                "id": 1262830,
                "title": "2-simple-c-approaches-dp-and-2-pointer-with-explanation",
                "content": "**Please upvote this post to motivate me in my quest of documenting leetcode solutions.**\\n```\\n// M-1 DP\\n// TC = SC = O(n^2)\\nclass Solution {\\npublic:\\n    string longestPalindrome(string s) {\\n        int n = s.length();\\n        if(n==1) return s;\\n        vector<vector<bool>> dp(n, vector<bool>(n, false));\\n        // max length of the pallindromic substring\\n        int max_length = 0;\\n        // starting index of the max length pallindromic substring\\n        int start_index = 0;\\n        for(int i = 0; i < n; i++)\\n        {\\n            dp[i][i] = true;\\n        }\\n        // check sub-strings of size 2\\n        for(int i = 0; i < n - 1; i++)\\n        {\\n            if(s[i] == s[i+1])\\n            {\\n                dp[i][i+1] = true;\\n                max_length = 2;\\n                start_index = i;\\n            }\\n        }\\n        // check sub-strings of size > 2\\n        // here k denotes the size of the sub-strings i.e. from 3 to n\\n        for(int k = 3; k <= n; k++)\\n        {\\n            for(int i = 0; i <= n - k; i++)\\n            {\\n                // i and j points to the starting & ending indices of the substring of size k\\n                int j = i + k - 1;\\n                if(s[i] == s[j] && dp[i+1][j-1] == true)\\n                {\\n                    dp[i][j] = true;\\n                    max_length = max(k, max_length);\\n                    start_index = i;\\n                }\\n            }\\n        }\\n        string ans = \"\";\\n        // if there is no pallindromic substring present of size >= 2 \\n        if(max_length == 0)\\n        {\\n            ans += s[0];\\n            return ans;\\n        }\\n        for(int i = start_index; i < start_index + max_length; i++)\\n        {\\n            ans += s[i];\\n        }\\n        return ans;\\n    }\\n};\\n\\n// M-2 \\n// TC = O(n^2) SC = O(1)\\nclass Solution {\\npublic:\\n    string longestPalindrome(string s) {\\n        int n = s.length();\\n        if(n==1) return s;\\n        string ans = \"\";\\n        // low and high points to the starting & ending indices of the pallindromic substrings \\n        int low, high;\\n        // starting index of the max length pallindromic substring\\n        int start_index;\\n        // max length of the pallindromic substring\\n        int max_length = 0;\\n        for(int i = 1; i < n; i++)\\n        {\\n            // for odd length substrings\\n            // choose i as epicenter and move left and right checking the string is pallindrome or not\\n            low = i - 1;\\n            high = i + 1;\\n            while(low >= 0 && high < n && s[low] == s[high])\\n            {\\n                if(max_length < high - low + 1)\\n                {\\n                    max_length = high - low + 1;\\n                    start_index = low;\\n                }\\n                --low;\\n                ++high;\\n            }\\n            // for even length substrings\\n            // choose i-1 and i as epicenters and move left and right checking the string is pallindrome or not\\n            low = i - 1;\\n            high = i;\\n            while(low >= 0 && high < n && s[low] == s[high])\\n            {\\n                if(max_length < high - low + 1)\\n                {\\n                    max_length = high - low + 1;\\n                    start_index = low;\\n                }\\n                --low;\\n                ++high;\\n            }\\n        }\\n        // if there is no pallindromic substring present of size >= 2 \\n        if(max_length == 0)\\n        {\\n            ans += s[0];\\n            return ans;\\n        }\\n        for(int i = start_index; i < start_index + max_length; i++)\\n        {\\n            ans += s[i];\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Two Pointers",
                    "Dynamic Programming"
                ],
                "code": "```\\n// M-1 DP\\n// TC = SC = O(n^2)\\nclass Solution {\\npublic:\\n    string longestPalindrome(string s) {\\n        int n = s.length();\\n        if(n==1) return s;\\n        vector<vector<bool>> dp(n, vector<bool>(n, false));\\n        // max length of the pallindromic substring\\n        int max_length = 0;\\n        // starting index of the max length pallindromic substring\\n        int start_index = 0;\\n        for(int i = 0; i < n; i++)\\n        {\\n            dp[i][i] = true;\\n        }\\n        // check sub-strings of size 2\\n        for(int i = 0; i < n - 1; i++)\\n        {\\n            if(s[i] == s[i+1])\\n            {\\n                dp[i][i+1] = true;\\n                max_length = 2;\\n                start_index = i;\\n            }\\n        }\\n        // check sub-strings of size > 2\\n        // here k denotes the size of the sub-strings i.e. from 3 to n\\n        for(int k = 3; k <= n; k++)\\n        {\\n            for(int i = 0; i <= n - k; i++)\\n            {\\n                // i and j points to the starting & ending indices of the substring of size k\\n                int j = i + k - 1;\\n                if(s[i] == s[j] && dp[i+1][j-1] == true)\\n                {\\n                    dp[i][j] = true;\\n                    max_length = max(k, max_length);\\n                    start_index = i;\\n                }\\n            }\\n        }\\n        string ans = \"\";\\n        // if there is no pallindromic substring present of size >= 2 \\n        if(max_length == 0)\\n        {\\n            ans += s[0];\\n            return ans;\\n        }\\n        for(int i = start_index; i < start_index + max_length; i++)\\n        {\\n            ans += s[i];\\n        }\\n        return ans;\\n    }\\n};\\n\\n// M-2 \\n// TC = O(n^2) SC = O(1)\\nclass Solution {\\npublic:\\n    string longestPalindrome(string s) {\\n        int n = s.length();\\n        if(n==1) return s;\\n        string ans = \"\";\\n        // low and high points to the starting & ending indices of the pallindromic substrings \\n        int low, high;\\n        // starting index of the max length pallindromic substring\\n        int start_index;\\n        // max length of the pallindromic substring\\n        int max_length = 0;\\n        for(int i = 1; i < n; i++)\\n        {\\n            // for odd length substrings\\n            // choose i as epicenter and move left and right checking the string is pallindrome or not\\n            low = i - 1;\\n            high = i + 1;\\n            while(low >= 0 && high < n && s[low] == s[high])\\n            {\\n                if(max_length < high - low + 1)\\n                {\\n                    max_length = high - low + 1;\\n                    start_index = low;\\n                }\\n                --low;\\n                ++high;\\n            }\\n            // for even length substrings\\n            // choose i-1 and i as epicenters and move left and right checking the string is pallindrome or not\\n            low = i - 1;\\n            high = i;\\n            while(low >= 0 && high < n && s[low] == s[high])\\n            {\\n                if(max_length < high - low + 1)\\n                {\\n                    max_length = high - low + 1;\\n                    start_index = low;\\n                }\\n                --low;\\n                ++high;\\n            }\\n        }\\n        // if there is no pallindromic substring present of size >= 2 \\n        if(max_length == 0)\\n        {\\n            ans += s[0];\\n            return ans;\\n        }\\n        for(int i = start_index; i < start_index + max_length; i++)\\n        {\\n            ans += s[i];\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1888698,
                "title": "100-fastest-typescript-solution",
                "content": "```\\nfunction longestPalindrome(s: string): string {\\n  if (!s || s.length <= 1) { return s }\\n  let longestPalindrome = s.substring(0, 1)\\n\\n  for (let i = 0; i < s.length; i++) {\\n    [expand(s, i, i), expand(s, i, i + 1)].forEach((maybeLongest) => {\\n      if (maybeLongest.length > longestPalindrome.length) {\\n          longestPalindrome = maybeLongest\\n      }\\n    })\\n  }\\n\\n  return longestPalindrome\\n}\\n\\nfunction expand(s: string, begin: number, end: number): string {\\n  while (begin >= 0 && end <= s.length - 1 && s[begin] === s[end]) {\\n    begin--\\n    end++\\n  }\\n\\n  return s.substring(begin + 1, end)\\n}\\n```\\n\\nLet me know in comments if you have any doubts. I will be happy to answer.\\n\\nPlease upvote if you found the solution useful.",
                "solutionTags": [
                    "JavaScript",
                    "TypeScript"
                ],
                "code": "```\\nfunction longestPalindrome(s: string): string {\\n  if (!s || s.length <= 1) { return s }\\n  let longestPalindrome = s.substring(0, 1)\\n\\n  for (let i = 0; i < s.length; i++) {\\n    [expand(s, i, i), expand(s, i, i + 1)].forEach((maybeLongest) => {\\n      if (maybeLongest.length > longestPalindrome.length) {\\n          longestPalindrome = maybeLongest\\n      }\\n    })\\n  }\\n\\n  return longestPalindrome\\n}\\n\\nfunction expand(s: string, begin: number, end: number): string {\\n  while (begin >= 0 && end <= s.length - 1 && s[begin] === s[end]) {\\n    begin--\\n    end++\\n  }\\n\\n  return s.substring(begin + 1, end)\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1416561,
                "title": "simple-javascript-solution",
                "content": "```\\nvar longestPalindrome = function(s) {\\n    let longest = \\'\\';\\n    \\n    for (let i=0; i<s.length; i++){\\n        expandCheck(i, i);\\n        expandCheck(i, i+1);\\n    }\\n    \\n    function expandCheck(l, r){\\n        while (l>=0 && r<s.length && s[l]===s[r]){\\n            if (r-l+1 > longest.length){\\n                longest = s.slice(l, r+1);\\n            }\\n            l--;\\n            r++;\\n        }\\n    }\\n    \\n    return longest;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar longestPalindrome = function(s) {\\n    let longest = \\'\\';\\n    \\n    for (let i=0; i<s.length; i++){\\n        expandCheck(i, i);\\n        expandCheck(i, i+1);\\n    }\\n    \\n    function expandCheck(l, r){\\n        while (l>=0 && r<s.length && s[l]===s[r]){\\n            if (r-l+1 > longest.length){\\n                longest = s.slice(l, r+1);\\n            }\\n            l--;\\n            r++;\\n        }\\n    }\\n    \\n    return longest;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 262528,
                "title": "longest-palindromic-substring-c-clean-solution",
                "content": "```\\npublic class Solution {\\n    public string LongestPalindrome(string s) {\\n        int maxLength = 0, startIndex = 0;\\n        for (int i = 0; i < s.Length; i++) {\\n            int start = i, end = i;\\n            while(end < s.Length-1 && s[start] == s[end+1])\\n                end++;\\n            \\n            while(end < s.Length-1 && start > 0 && s[start-1] == s[end+1]) {\\n                start--; \\n                end++;\\n            }\\n            if(maxLength < end - start + 1) {\\n                maxLength = end - start + 1;\\n                startIndex = start;\\n            }\\n        }\\n        return s.Substring(startIndex, maxLength);\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution {\\n    public string LongestPalindrome(string s) {\\n        int maxLength = 0, startIndex = 0;\\n        for (int i = 0; i < s.Length; i++) {\\n            int start = i, end = i;\\n            while(end < s.Length-1 && s[start] == s[end+1])\\n                end++;\\n            \\n            while(end < s.Length-1 && start > 0 && s[start-1] == s[end+1]) {\\n                start--; \\n                end++;\\n            }\\n            if(maxLength < end - start + 1) {\\n                maxLength = end - start + 1;\\n                startIndex = start;\\n            }\\n        }\\n        return s.Substring(startIndex, maxLength);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 162231,
                "title": "go-solution",
                "content": "```\\nfunc longestPalindrome(s string) string {\\n    var max string\\n    for i := 0; i < len(s); i++ {\\n        max = maxPalindrome(s, i, i, max)\\n        max = maxPalindrome(s, i, i+1, max)\\n    }\\n    return max\\n}\\n\\nfunc maxPalindrome(s string, i, j int, max string) string {\\n    var sub string\\n    for i >= 0 && j < len(s) && s[i] == s[j] {\\n        sub = s[i:j+1]\\n        i--\\n        j++\\n    }\\n    if len(max) < len(sub) {\\n        return sub\\n    }\\n    return max\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nfunc longestPalindrome(s string) string {\\n    var max string\\n    for i := 0; i < len(s); i++ {\\n        max = maxPalindrome(s, i, i, max)\\n        max = maxPalindrome(s, i, i+1, max)\\n    }\\n    return max\\n}\\n\\nfunc maxPalindrome(s string, i, j int, max string) string {\\n    var sub string\\n    for i >= 0 && j < len(s) && s[i] == s[j] {\\n        sub = s[i:j+1]\\n        i--\\n        j++\\n    }\\n    if len(max) < len(sub) {\\n        return sub\\n    }\\n    return max\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3851503,
                "title": "c-dp-o-n-2",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nUsing bottom-up approach and The main idea behind this is to divide string into smaller palindromic substrings and build up the solution iteratively from smaller palindromes to larger ones.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. Initializing variables `start` with 0 (Starting index of the longest palindromic substring) and `longlen` with 1, which will contain the length of longest palindromic substring.\\n2. Initially, All substrings of length 1 are palindromic so mark them true.\\n3. then, check Check for substrings of length 2, if `ith` and `i+1th` matches then update `start` with i and `longlen` will be 2.\\n4. Now, Check for substrings of length 3 or more. in this we\\'ll check if the substring from `i` to `j` is a palindrome where `j` is ending index of current substring. \\n5. and then if substring is palindrome then update maxLength`longlen` n `start`.\\n6. Finally, return the string starting from `start`th index till length of `longlen` from Original string , which will contain the longest palindromic substring in the input string.\\n\\n# Complexity\\n- Time complexity:\\ncode uses two nested loops to iterate.\\nO(n^2).\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\ncode uses a 2D boolean table dp of size n x n.\\ntherefore, O(n^2).\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n//bottom-up approach\\nclass Solution {\\npublic:\\n    string longestPalindrome(string s) {\\n        int n = s.size();\\n        int start = 0; // Starting index of the longest palindromic substring\\n        int longlen = 1; // Length of the longest palindromic substring (initialize to 1, as each character is a palindrome by itself)\\n        \\n        // Create a table to store the results of subproblems\\n        vector<vector<bool>> t(n, vector<bool>(n, false));\\n        \\n        // All substrings of length 1 are palindromic\\n        for (int i = 0; i < n; i++)\\n            t[i][i] = true;\\n        \\n        // Check for substrings of length 2\\n        for (int i = 0; i < n - 1; i++) \\n        {\\n            if (s[i] == s[i + 1])\\n            {\\n                t[i][i+1] = true;\\n                start = i;\\n                longlen = 2;\\n            }\\n        }\\n        \\n        // Check for substrings of length 3 or more\\n        for (int l = 3; l <= n; l++) \\n        {\\n            for (int i = 0; i < n - l + 1; i++) \\n            {\\n                int j = i + l - 1; // Ending index of the current substring\\n                // Check if the substring from i to j is a palindrome\\n                if (s[i] == s[j] && t[i + 1][j - 1]) \\n                {\\n                    t[i][j] = true;\\n                    if (l > longlen) \\n                    {\\n                        longlen = l;\\n                        start = i;\\n                    }\\n                }\\n            }\\n        }\\n        \\n        //Extract the longest palindromic substring from original string\\n        return s.substr(start, longlen);\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++",
                    "String",
                    "Dynamic Programming"
                ],
                "code": "```\\n//bottom-up approach\\nclass Solution {\\npublic:\\n    string longestPalindrome(string s) {\\n        int n = s.size();\\n        int start = 0; // Starting index of the longest palindromic substring\\n        int longlen = 1; // Length of the longest palindromic substring (initialize to 1, as each character is a palindrome by itself)\\n        \\n        // Create a table to store the results of subproblems\\n        vector<vector<bool>> t(n, vector<bool>(n, false));\\n        \\n        // All substrings of length 1 are palindromic\\n        for (int i = 0; i < n; i++)\\n            t[i][i] = true;\\n        \\n        // Check for substrings of length 2\\n        for (int i = 0; i < n - 1; i++) \\n        {\\n            if (s[i] == s[i + 1])\\n            {\\n                t[i][i+1] = true;\\n                start = i;\\n                longlen = 2;\\n            }\\n        }\\n        \\n        // Check for substrings of length 3 or more\\n        for (int l = 3; l <= n; l++) \\n        {\\n            for (int i = 0; i < n - l + 1; i++) \\n            {\\n                int j = i + l - 1; // Ending index of the current substring\\n                // Check if the substring from i to j is a palindrome\\n                if (s[i] == s[j] && t[i + 1][j - 1]) \\n                {\\n                    t[i][j] = true;\\n                    if (l > longlen) \\n                    {\\n                        longlen = l;\\n                        start = i;\\n                    }\\n                }\\n            }\\n        }\\n        \\n        //Extract the longest palindromic substring from original string\\n        return s.substr(start, longlen);\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1738430,
                "title": "c-solution-using-2-loops-o-n-time-complexity",
                "content": "> **If you\\u2019re interested in coding you can join my Discord Server, link in the comment section. Also if you find any mistake please let me know. Thank you!\\u2764\\uFE0F**\\n> \\n\\n---\\n\\n## Explanation:\\n\\n### Solution 01\\n\\n- Here the palindrome could have odd or even length.\\n- For odd length, there must be a central element. For even the elements will be side by side.\\n- So we calculate both cases for all elements:\\n    - **For odd**: we took left & right as same elements(central) **`l = i, r = i`**\\n    - if elements in both indexes are the same we\\u2019ll increase `r` & decrease `l` by 1.\\n    - when we find both are not same, we\\u2019ll calculate the length **`length = r-l-1`**\\n    - if the length is greater than mx, then we\\u2019ll store start and end point of this length.\\n    - **For even**: same approach, just here we\\u2019ll take l & r next to each other. **`l = i, r = i+1`**\\n- Return substring from start to max length.\\n- **Time complexity:** O(n^2).\\n\\n---\\n\\n## Code:\\n\\n```cpp\\n//Solution 01:\\n****class Solution {\\npublic:\\n    string longestPalindrome(string s) {\\n        int n = s.size();\\n        int start = 0, end = 0, mx = INT_MIN;\\n        \\n        if(n<=1) return s;\\n        \\n        for(int i=0; i<n-1; i++){\\n            int l = i, r = i;\\n            while(l >= 0 && r < n && s[l]==s[r]){\\n                l--; r++;\\n            }\\n            int length = r-l-1;\\n            if(length > mx){\\n                mx = length;\\n                start = l+1;\\n                end = r-1;\\n            }\\n        }\\n        \\n        for(int i=0; i<n-1; i++){\\n            int l = i, r = i+1;\\n            while(l >= 0 && r < n && s[l]==s[r]){\\n                l--; r++;\\n            }\\n            int length = r-l-1;\\n            if(length > mx){\\n                mx = length;\\n                start = l+1;\\n                end = r-1;\\n            }\\n        }\\n        \\n        return s.substr(start, mx);\\n    }\\n};\\n```\\n\\n---\\n\\n> **Please upvote this solution**\\n>",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```cpp\\n//Solution 01:\\n****class Solution {\\npublic:\\n    string longestPalindrome(string s) {\\n        int n = s.size();\\n        int start = 0, end = 0, mx = INT_MIN;\\n        \\n        if(n<=1) return s;\\n        \\n        for(int i=0; i<n-1; i++){\\n            int l = i, r = i;\\n            while(l >= 0 && r < n && s[l]==s[r]){\\n                l--; r++;\\n            }\\n            int length = r-l-1;\\n            if(length > mx){\\n                mx = length;\\n                start = l+1;\\n                end = r-1;\\n            }\\n        }\\n        \\n        for(int i=0; i<n-1; i++){\\n            int l = i, r = i+1;\\n            while(l >= 0 && r < n && s[l]==s[r]){\\n                l--; r++;\\n            }\\n            int length = r-l-1;\\n            if(length > mx){\\n                mx = length;\\n                start = l+1;\\n                end = r-1;\\n            }\\n        }\\n        \\n        return s.substr(start, mx);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1539190,
                "title": "java-tc-o-n-2-sc-o-1-two-optimized-solutions-with-early-exit-condition",
                "content": "**In this solution using a 1D array to track the resultant string\\'s start point and length**\\n\\n```java\\n/**\\n * Optimized Solution for continuous repeating characters.\\n * Expand Palindrome around center.\\n *\\n * Time Complexity: O(N^2)\\n *\\n * Space Complexity: O(1)\\n *\\n * N = Length of the input string s.\\n */\\nclass Solution {\\n    public String longestPalindrome(String s) {\\n        if (s == null) {\\n            throw new IllegalArgumentException(\"Input is null\");\\n        }\\n\\n        int len = s.length();\\n        if (len <= 1) {\\n            return s;\\n        }\\n\\n        int[] maxStartOffset = new int[] { 0, 1 };\\n        int i = 0;\\n\\t\\t\\n        while (i < len) {\\n            int start = i++;\\n\\t\\t\\t// Finding the continuous repeating characters\\n            // We can optimize by finding all such chars and treat them as the palindrome\\n            // center for the next expandPalindrome call.\\n            while (i < len && s.charAt(i) == s.charAt(start)) {\\n                i++;\\n            }\\n            // Expanding palindrome around the center defined by [start, i-1]\\n            expandPalindrome(s, start - 1, i, maxStartOffset);\\n\\n            // Early Exit Condition\\n            // Remaining Characters = len - i - 1\\n            // Longest palindrome possible using remaining chars = (len - i - 1) * 2\\n            // We can safely exit if current maxStartOffset[1] >= (len - i - 1) * 2\\n            if (maxStartOffset[1] >= (len - i - 1) * 2) {\\n                break;\\n            }\\n        }\\n\\n        return s.substring(maxStartOffset[0], maxStartOffset[0] + maxStartOffset[1]);\\n    }\\n\\n    private void expandPalindrome(String s, int left, int right, int[] maxStartOffset) {\\n        while (left >= 0 && right < s.length() && s.charAt(left) == s.charAt(right)) {\\n            left--;\\n            right++;\\n        }\\n        if (right - left - 1 > maxStartOffset[1]) {\\n            maxStartOffset[0] = left + 1;\\n            maxStartOffset[1] = right - left - 1;\\n        }\\n    }\\n}\\n```\\n\\n---\\n**In this solution helper returning the length of the palindrome. We are NOT using a 1D array to track the result string**\\n\\n```java\\n/**\\n * Optimized Solution for continuous repeating characters.\\n * Expand Palindrome around center.\\n * Helper function returns the length of the palindrome.\\n *\\n * Time Complexity: O(N^2)\\n *\\n * Space Complexity: O(1)\\n *\\n * N = Length of the input string s.\\n */\\nclass Solution {\\n    public String longestPalindrome(String s) {\\n        if (s == null) {\\n            throw new IllegalArgumentException(\"Input is null\");\\n        }\\n\\n        int len = s.length();\\n        if (len <= 1) {\\n            return s;\\n        }\\n\\n        int maxStart = 0;\\n        int maxLen = 0;\\n\\n        int i = 0;\\n        while (i < len) {\\n            int start = i++;\\n\\t\\t\\t// Finding the continuous repeating characters\\n            // We can optimize by finding all such chars and treat them as the palindrome\\n            // center for the next expandPalindrome call.\\n            while (i < len && s.charAt(i) == s.charAt(start)) {\\n                i++;\\n            }\\n            // Expanding palindrome around the center defined by [start, i-1]\\n            int newLen = expandPalindrome(s, start - 1, i);\\n\\t\\t\\t\\n            if (newLen > maxLen) {\\n                maxLen = newLen;\\n                // Center of the palindrome: (start + i - 1) / 2\\n                // Subtracting half of newLen from center to get the start index.\\n                maxStart = (start + i - 1) / 2 - (newLen - 1) / 2;\\n            }\\n\\n            // Early Exit Condition\\n            // Remaining Characters = len - i - 1\\n            // Longest palindrome possible using remaining chars = (len - i - 1) * 2\\n            // We can safely exit if current maxLen >= (len - i - 1) * 2\\n            if (maxLen >= (len - i - 1) * 2) {\\n                break;\\n            }\\n        }\\n\\n        return s.substring(maxStart, maxStart + maxLen);\\n    }\\n\\n    private int expandPalindrome(String s, int left, int right) {\\n        while (left >= 0 && right < s.length() && s.charAt(left) == s.charAt(right)) {\\n            left--;\\n            right++;\\n        }\\n        return right - left - 1;\\n    }\\n}\\n```\\n\\n---\\n\\nSolutions to other Palindrome questions on LeetCode:\\n- [9. Palindrome Number](https://leetcode.com/problems/palindrome-number/discuss/1527951/Java-or-TC:-O((log10-N)2)-or-SC:-O(1)-or-Optimal-Reverse-Half-and-Compare)\\n- [125. Valid Palindrome](https://leetcode.com/problems/valid-palindrome/discuss/1496675/Java-or-TC:-O(N)-or-SC:-O(1)-or-One-Pass-Solution-using-two-pointers)\\n- [266. Palindrome Permutation](https://leetcode.com/problems/palindrome-permutation/discuss/1527941/Java-or-TC:-O(N)-or-SC:-O(N)-or-Early-Exit-and-Space-Optimized-HashSet-solution)\\n- [267. Palindrome Permutation II](https://leetcode.com/problems/palindrome-permutation-ii/discuss/1527948/Java-or-TC:-O(N*(N2)!)-or-SC:-O(N)-or-Optimal-Backtracking-using-CountMap)\\n- [647. Palindromic Substrings](https://leetcode.com/problems/palindromic-substrings/discuss/1539193/Java-or-TC:-O(N2)-or-SC:-O(1)-or-Optimized-solution-for-continuous-repeating-chars)\\n",
                "solutionTags": [
                    "Java",
                    "String"
                ],
                "code": "```java\\n/**\\n * Optimized Solution for continuous repeating characters.\\n * Expand Palindrome around center.\\n *\\n * Time Complexity: O(N^2)\\n *\\n * Space Complexity: O(1)\\n *\\n * N = Length of the input string s.\\n */\\nclass Solution {\\n    public String longestPalindrome(String s) {\\n        if (s == null) {\\n            throw new IllegalArgumentException(\"Input is null\");\\n        }\\n\\n        int len = s.length();\\n        if (len <= 1) {\\n            return s;\\n        }\\n\\n        int[] maxStartOffset = new int[] { 0, 1 };\\n        int i = 0;\\n\\t\\t\\n        while (i < len) {\\n            int start = i++;\\n\\t\\t\\t// Finding the continuous repeating characters\\n            // We can optimize by finding all such chars and treat them as the palindrome\\n            // center for the next expandPalindrome call.\\n            while (i < len && s.charAt(i) == s.charAt(start)) {\\n                i++;\\n            }\\n            // Expanding palindrome around the center defined by [start, i-1]\\n            expandPalindrome(s, start - 1, i, maxStartOffset);\\n\\n            // Early Exit Condition\\n            // Remaining Characters = len - i - 1\\n            // Longest palindrome possible using remaining chars = (len - i - 1) * 2\\n            // We can safely exit if current maxStartOffset[1] >= (len - i - 1) * 2\\n            if (maxStartOffset[1] >= (len - i - 1) * 2) {\\n                break;\\n            }\\n        }\\n\\n        return s.substring(maxStartOffset[0], maxStartOffset[0] + maxStartOffset[1]);\\n    }\\n\\n    private void expandPalindrome(String s, int left, int right, int[] maxStartOffset) {\\n        while (left >= 0 && right < s.length() && s.charAt(left) == s.charAt(right)) {\\n            left--;\\n            right++;\\n        }\\n        if (right - left - 1 > maxStartOffset[1]) {\\n            maxStartOffset[0] = left + 1;\\n            maxStartOffset[1] = right - left - 1;\\n        }\\n    }\\n}\\n```\n```java\\n/**\\n * Optimized Solution for continuous repeating characters.\\n * Expand Palindrome around center.\\n * Helper function returns the length of the palindrome.\\n *\\n * Time Complexity: O(N^2)\\n *\\n * Space Complexity: O(1)\\n *\\n * N = Length of the input string s.\\n */\\nclass Solution {\\n    public String longestPalindrome(String s) {\\n        if (s == null) {\\n            throw new IllegalArgumentException(\"Input is null\");\\n        }\\n\\n        int len = s.length();\\n        if (len <= 1) {\\n            return s;\\n        }\\n\\n        int maxStart = 0;\\n        int maxLen = 0;\\n\\n        int i = 0;\\n        while (i < len) {\\n            int start = i++;\\n\\t\\t\\t// Finding the continuous repeating characters\\n            // We can optimize by finding all such chars and treat them as the palindrome\\n            // center for the next expandPalindrome call.\\n            while (i < len && s.charAt(i) == s.charAt(start)) {\\n                i++;\\n            }\\n            // Expanding palindrome around the center defined by [start, i-1]\\n            int newLen = expandPalindrome(s, start - 1, i);\\n\\t\\t\\t\\n            if (newLen > maxLen) {\\n                maxLen = newLen;\\n                // Center of the palindrome: (start + i - 1) / 2\\n                // Subtracting half of newLen from center to get the start index.\\n                maxStart = (start + i - 1) / 2 - (newLen - 1) / 2;\\n            }\\n\\n            // Early Exit Condition\\n            // Remaining Characters = len - i - 1\\n            // Longest palindrome possible using remaining chars = (len - i - 1) * 2\\n            // We can safely exit if current maxLen >= (len - i - 1) * 2\\n            if (maxLen >= (len - i - 1) * 2) {\\n                break;\\n            }\\n        }\\n\\n        return s.substring(maxStart, maxStart + maxLen);\\n    }\\n\\n    private int expandPalindrome(String s, int left, int right) {\\n        while (left >= 0 && right < s.length() && s.charAt(left) == s.charAt(right)) {\\n            left--;\\n            right++;\\n        }\\n        return right - left - 1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1283151,
                "title": "c-easy-to-understand-o-nxn-time-complexity-fast-and-efficient-solution",
                "content": "***Please upvote to motivate me in my quest of documenting all leetcode solutions. HAPPY CODING:)\\nAny suggestions and improvements are always welcome***\\n\\n**Time complexity O(nxn)       Space complexity O(1)**\\n```\\nclass Solution {\\npublic:\\n    string longestPalindrome(string s) {\\n        string str;\\n        int len=0;\\n        int start=0;\\n   for(int i=0;i<s.length();i++)\\n   {\\n       int len1=expandFromCenter(s,i,i);\\n       int len2=expandFromCenter(s,i,i+1);\\n       \\n       if(len<max(len1,len2))\\n       {\\n           len=max(len1,len2);\\n           start=i-(len-1)/2;\\n       }  \\n   }\\n     return s.substr(start,len);   \\n   }\\n    int expandFromCenter(string &s,int left,int right)\\n    {\\n        if(s.length()<1||left>right)\\n         return 0;\\n        while(left>=0&&right<s.length()&&s[left]==s[right])\\n        {\\n            left--;\\n            right++;\\n        } \\n        return right-left-1;\\n    }\\n};",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "class Solution {\\npublic:\\n    string longestPalindrome(string s) {\\n        string str;\\n        int len=0;\\n        int start=0;\\n   for(int i=0;i<s.length();i++)\\n   {\\n       int len1=expandFromCenter(s,i,i);\\n       int len2=expandFromCenter(s,i,i+1);\\n       \\n       if(len<max(len1,len2))\\n       {\\n           len=max(len1,len2);\\n           start=i-(len-1)/2;\\n       }",
                "codeTag": "Java"
            },
            {
                "id": 1122735,
                "title": "lcs-improved-with-reversing-and-finding-palindrome-c-doc",
                "content": "**Introdution:** We will reverse and find the longest plaindrome. I am writing this solution to help anyone who is willing to find how this solution works.\\n\\n**Prerequisite:** Longest Common Subsequence Algorithm[DP]. Here is an easy to understand video of LCS:  https://www.youtube.com/watch?v=sSno9rV8Rhg\\n\\n**What about the reverse copy flaw?** OK so this is why you are here. Let\\'s take a lot of examples here.\\n\\n1. s = \"abacdfgdcaba\" and s\\' = \"abacdgfdcaba\". So in this our code will find an answer as \"abacd\" which is correct by LCS point of view but wrong from what we want to do. Lets see.\\n2. So in the reverse string, the starting \\'a\\' in the substring is at index 1(indexing is 1 oriented). Let\\'s find out what it\\'s index was in the original string which is s. OK it\\'s index was 12.\\n3. So in the reverse string, the ending \\'d\\' in the substring is at index 5. Let\\'s find out what it\\'s index was in the original string which is s. OK it\\'s idnex was 8.\\n4. So we see that we are comparing a string which is 8->12(in original of reverse) with a string which is 1->5(in original). If it were a valid substring, it should be on the same index.\\n5. Think this, can it be like \"abcghhcba\" and the substring be \"abc\". No because that is not at the same spot so how it\\'s reverse matters. We want to see the in-place reverse string. Get it? \"aba\" is \"aba\" cool but \"abc\" is not. It\\'s reverse exist which is somewhere but it cannot be a candidate for the plaindrome.\\n6. This situation arrises because of the reverse and LCS. LCS just cares about finding common anywhere. We want common at the same index for it to be a plaindrome.\\n\\n**Let\\'s take a genuine example and clear this**\\n\\n1. s=\"abb\" s\\'=\"bba\". I took it simple but it doesn\\'t matter. \\n2. So our code find \"bb\" as a substring.\\n3. So the start of the first \\'b\\' in the reverse string is 1. The index of it in the original string was 3\\n4. So the start of the second \\'b\\' in the reverse string is 2. The index of it in the original string was 2\\n5. So we are comparing a string of 2->3 with our original string also from 3->2 so this means that this is a genuine solution.\\n6. It\\'s just like \"abcbg\", (substring is \"bab\") then first b is at index 2 and last b is at index 4 then reverse would be \"gbcba\" the first b is at index 4 and the last at 2. They interchange position but index(start and end) don\\'t change.  If they change, there is somthing fishy.\\n\\n**Code:** \\n\\n```\\nclass Solution {\\npublic:\\n    string longestPalindrome(string s) {\\n        int start = -1; //This is the start of the substring in s(the starting index from 0)\\n        int end = -1; //This is the end of the substring in s(the ending index from 0)\\n        int ans = 0; //This is the length of the longest palindrome\\n        /*\\n        If string is \"abcbr\" then start = 1 and end = 3 and longest palindrome is bcb\\n        */\\n        string srev = string(s.rbegin(),s.rend()); //We reverse the given string and store it\\n        /*\\n        1. Let\\'s create the LCS array. \\n        2. In this array, arr[index1][index2] tells us what is the length of the longest subarray\\n           till index1-1 in string s and index2-1 in string srev.\\n        3. The indexing in this dp array is done 1 based so in string \"abcs\", the index 0 element \\n           which is \\'a\\' is actually represented by 1 because we need 0 index to store the initial values\\n           which is 0 for all row and all columns of 0 index. This is explained in the video above by \\n           Abdul Bari Sir.\\n        */\\n        int arr[s.size()+1][s.size()+1];\\n        for(int i=0;i<=s.size();i++) {\\n            //So the outer loop which is i is representing the original string which is: s\\n            for(int j=0;j<=s.size();j++) {\\n                //The inner loop which is j is representing the original string which is: srev\\n                \\n                /*\\n                1. If the index is 0 which actually signifies the empty string or taking no value till now\\n                   in the string, we make it 0. Because no string means clearly no value.\\n                2. In this, if the current values in the 2 string are not equal we make the current item\\n                   to be 0 because we need substring and it has to be continuous.\\n                */\\n                if((i==0 || j==0) || (s[i-1]!=srev[j-1])) arr[i][j] = 0; \\n                \\n                else{  //If the values are equal that is s[i-1]==srev[j-1]\\n                    arr[i][j]=arr[i-1][j-1]+1; //Lets add one to the value till previous\\n                    /*\\n                    1. OK so here is where the original error correction starts.\\n                    2. What is there exists a copy and get matched?\\n                    3. Then we have to see just 1 thing, if the index of the reversed string matched the index of the unreverse string.\\n                    4. I have explained it above.\\n                    5. ob = original begin\\n                    6. oe = original end\\n                    7. revbo = reverse begin original\\n                    8. reveo = revree end original\\n                    */\\n                    int ob = i-arr[i][j]; \\n                    int oe = i-1;\\n                    int revbo = s.size()-(j-arr[i][j])-1;\\n                    int reveo = s.size()-(j-1)-1;\\n                    /*\\n                    1. So if the string is not a coincidence and is a genuine answer, that is, ob == reveo and oe == revbo, lets check\\n                       if this substring is the longest by comparing its size.\\n                    2. If its genuine and longer than what we have so far, let\\'s take it.\\n                    3. Mark the end and start so that we can construct this string at the end as we need string not the size.\\n                    */\\n                    if(ob == reveo && oe == revbo && arr[i][j] > ans){ \\n                        ans = arr[i][j];\\n                        start = i-arr[i][j];\\n                        end = i-1;\\n                    }\\n                }\\n            }\\n        }\\n        if(start == -1){ start=0; end=0; } //So if there was nothing then a single character is the longest substring\\n        /*\\n        1. Making a variable temp and finding all the value of the string from the index we stored.\\n        */\\n        string temp = \"\";\\n        for(int i=start;i<=end;i++) temp+=s[i];\\n        /*\\n        1. Return this string and we are done\\n        */\\n        return temp;\\n    }\\n};\\n```\\n\\n**PS:** \\n1. Some of the people may thing that let\\'s create an array of string and just add values and so but lemme tell you that it will give you TLE in cpp. Because simply you are doing a lot of string operations. For anyone interested I am giving the code of the string array as well, looks simple but string operations are heavy. \\n```\\nclass Solution {\\npublic:\\n    string longestPalindrome(string s) {\\n        string ans = \"\";\\n        string srev = string(s.rbegin(),s.rend());\\n        string arr[s.size()+1][s.size()+1];\\n        for(int i=0;i<=s.size();i++) {\\n            for(int j=0;j<=s.size();j++) {\\n                if((i==0 || j==0) || (s[i-1]!=srev[j-1])) arr[i][j] = \"\";\\n                else{ \\n                    arr[i][j]=arr[i-1][j-1]+s[i-1];\\n                    int ob = i-arr[i][j].size();\\n                    int oe = i-1;\\n                    int revbo = s.size()-(j-arr[i][j].size())-1;\\n                    int reveo = s.size()-(j-1)-1;\\n                    if(ob == reveo && oe == revbo && arr[i][j].size() > ans.size()) ans = arr[i][j]; \\n                }\\n            }\\n        }\\n        if(ans == \"\" && s != \"\") ans=s[0];\\n        return ans;\\n    }\\n};\\n```\\n2. I know there can be optimisations but I tried to make it verbose instead of short and professional. \\n3. Thank you if you make it till here. I really appreciate it.",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    string longestPalindrome(string s) {\\n        int start = -1; //This is the start of the substring in s(the starting index from 0)\\n        int end = -1; //This is the end of the substring in s(the ending index from 0)\\n        int ans = 0; //This is the length of the longest palindrome\\n        /*\\n        If string is \"abcbr\" then start = 1 and end = 3 and longest palindrome is bcb\\n        */\\n        string srev = string(s.rbegin(),s.rend()); //We reverse the given string and store it\\n        /*\\n        1. Let\\'s create the LCS array. \\n        2. In this array, arr[index1][index2] tells us what is the length of the longest subarray\\n           till index1-1 in string s and index2-1 in string srev.\\n        3. The indexing in this dp array is done 1 based so in string \"abcs\", the index 0 element \\n           which is \\'a\\' is actually represented by 1 because we need 0 index to store the initial values\\n           which is 0 for all row and all columns of 0 index. This is explained in the video above by \\n           Abdul Bari Sir.\\n        */\\n        int arr[s.size()+1][s.size()+1];\\n        for(int i=0;i<=s.size();i++) {\\n            //So the outer loop which is i is representing the original string which is: s\\n            for(int j=0;j<=s.size();j++) {\\n                //The inner loop which is j is representing the original string which is: srev\\n                \\n                /*\\n                1. If the index is 0 which actually signifies the empty string or taking no value till now\\n                   in the string, we make it 0. Because no string means clearly no value.\\n                2. In this, if the current values in the 2 string are not equal we make the current item\\n                   to be 0 because we need substring and it has to be continuous.\\n                */\\n                if((i==0 || j==0) || (s[i-1]!=srev[j-1])) arr[i][j] = 0; \\n                \\n                else{  //If the values are equal that is s[i-1]==srev[j-1]\\n                    arr[i][j]=arr[i-1][j-1]+1; //Lets add one to the value till previous\\n                    /*\\n                    1. OK so here is where the original error correction starts.\\n                    2. What is there exists a copy and get matched?\\n                    3. Then we have to see just 1 thing, if the index of the reversed string matched the index of the unreverse string.\\n                    4. I have explained it above.\\n                    5. ob = original begin\\n                    6. oe = original end\\n                    7. revbo = reverse begin original\\n                    8. reveo = revree end original\\n                    */\\n                    int ob = i-arr[i][j]; \\n                    int oe = i-1;\\n                    int revbo = s.size()-(j-arr[i][j])-1;\\n                    int reveo = s.size()-(j-1)-1;\\n                    /*\\n                    1. So if the string is not a coincidence and is a genuine answer, that is, ob == reveo and oe == revbo, lets check\\n                       if this substring is the longest by comparing its size.\\n                    2. If its genuine and longer than what we have so far, let\\'s take it.\\n                    3. Mark the end and start so that we can construct this string at the end as we need string not the size.\\n                    */\\n                    if(ob == reveo && oe == revbo && arr[i][j] > ans){ \\n                        ans = arr[i][j];\\n                        start = i-arr[i][j];\\n                        end = i-1;\\n                    }\\n                }\\n            }\\n        }\\n        if(start == -1){ start=0; end=0; } //So if there was nothing then a single character is the longest substring\\n        /*\\n        1. Making a variable temp and finding all the value of the string from the index we stored.\\n        */\\n        string temp = \"\";\\n        for(int i=start;i<=end;i++) temp+=s[i];\\n        /*\\n        1. Return this string and we are done\\n        */\\n        return temp;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    string longestPalindrome(string s) {\\n        string ans = \"\";\\n        string srev = string(s.rbegin(),s.rend());\\n        string arr[s.size()+1][s.size()+1];\\n        for(int i=0;i<=s.size();i++) {\\n            for(int j=0;j<=s.size();j++) {\\n                if((i==0 || j==0) || (s[i-1]!=srev[j-1])) arr[i][j] = \"\";\\n                else{ \\n                    arr[i][j]=arr[i-1][j-1]+s[i-1];\\n                    int ob = i-arr[i][j].size();\\n                    int oe = i-1;\\n                    int revbo = s.size()-(j-arr[i][j].size())-1;\\n                    int reveo = s.size()-(j-1)-1;\\n                    if(ob == reveo && oe == revbo && arr[i][j].size() > ans.size()) ans = arr[i][j]; \\n                }\\n            }\\n        }\\n        if(ans == \"\" && s != \"\") ans=s[0];\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 678400,
                "title": "ac-python-dp-o-n-space-manacher",
                "content": "Dynamic Programming, O(n) Space\\n```\\ndef longestPalindrome(self, s: str) -> str:\\n\\tif not s: return s\\n\\tn, l, r = len(s), 0, 0\\n\\tdp = [[True]*n, [False]*n]    # dp[0]: old letters palindromes, dp[1]: even letters palindromes\\n\\tfor i in range(n-1):\\n\\t\\tif s[i] == s[i+1]:\\n\\t\\t\\tdp[1][i] = True\\n\\t\\t\\tl, r = i, i+1                        \\n\\tfor m in range(2, n):         # m letters palindromes\\n\\t\\tfor i in range(n-m):\\n\\t\\t\\tj = i+m\\n\\t\\t\\tx, k = m%2, i+m//2\\n\\t\\t\\tdp[x][k] = dp[x][k] and s[i] == s[j]\\n\\t\\t\\tif dp[x][k] and j-i > r-l:\\n\\t\\t\\t\\tl, r = i, j\\n\\treturn s[l:r+1]\\n```\\nDynamic Programming, O(n^2) Space\\n```\\ndef longestPalindrome(self, s: str) -> str:\\n\\tif not s: return s\\n\\tn, l, r = len(s), 0, 0\\n\\tdp = [[False]*n for _ in range(n)]\\n\\tdp[-1][-1] = True\\n\\tfor i in range(n-1):\\n\\t\\tdp[i][i] = True\\n\\t\\tif s[i] == s[i+1]:\\n\\t\\t\\tdp[i][i+1] = True\\n\\t\\t\\tl, r = i, i+1                        \\n\\tfor m in range(2, n):\\n\\t\\tfor i in range(n-m):\\n\\t\\t\\tj = i+m\\n\\t\\t\\tdp[i][j] = dp[i+1][j-1] and s[i] == s[j]\\n\\t\\t\\tif dp[i][j] and j-i > r-l:\\n\\t\\t\\t\\tl, r = i, j\\n\\treturn s[l:r+1]\\n```\\nCenter Expansion, O(1) Space\\n```\\ndef longestPalindrome(self, s: str) -> str:\\n\\tdef check(l, r):\\n\\t\\twhile 0 <= l and r < n and s[l] == s[r]: \\n\\t\\t\\tl -= 1\\n\\t\\t\\tr += 1\\n\\t\\treturn l, r\\n\\n\\tn, L, R = len(s), 0, 0\\n\\tfor i in range(2*n-1):\\n\\t\\tif i%2: l, r = check((i-1)//2, (i+1)//2)\\n\\t\\telse: l, r = check(i//2, i//2)\\n\\t\\tif r-l > R-L: L, R = l, r                \\n\\treturn s[L+1:R]\\n```\\nCenter Expansion, most efficient one except Manacher by my own test\\n```\\ndef longestPalindrome(self, s: str) -> str:\\n\\tt = \\'^#\\'+\\'#\\'.join(s)+\\'#$\\'\\n\\tc = r = 0                             # center and radius\\n\\tfor i in range(1,len(t)-1):\\n\\t\\tj = 1 if t[i] == \\'#\\' else 2       # skip \\'#\\' and check letters only\\n\\t\\twhile  t[i-j] == t[i+j]: j += 2\\n\\t\\tif j > r: c, r = i, j\\n\\treturn s[(c-r+1)//2:(c+r-1)//2]\\n```\\n Manacher\\'s algorithm\\n```\\ndef longestPalindrome(self, s: str) -> str:               \\n\\tt = \\'^#\\'+\\'#\\'.join(s)+\\'#$\\'\\n\\tn = len(t)\\n\\tp = [0]*n\\n\\tc = r = cm = rm = 0\\n\\tfor i in range (1, n-1):\\n\\t\\tp[i] = min(r-i, p[2*c-i]) if r > i else 0\\n\\t\\twhile t[i-p[i]-1] == t[i+p[i]+1]: p[i] += 1\\n\\t\\tif p[i]+i > r: c, r = i, p[i]+i\\n\\t\\tif p[i] > rm: cm, rm = i, p[i]\\n\\treturn s[(cm-rm)//2:(cm+rm)//2]\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Dynamic Programming"
                ],
                "code": "```\\ndef longestPalindrome(self, s: str) -> str:\\n\\tif not s: return s\\n\\tn, l, r = len(s), 0, 0\\n\\tdp = [[True]*n, [False]*n]    # dp[0]: old letters palindromes, dp[1]: even letters palindromes\\n\\tfor i in range(n-1):\\n\\t\\tif s[i] == s[i+1]:\\n\\t\\t\\tdp[1][i] = True\\n\\t\\t\\tl, r = i, i+1                        \\n\\tfor m in range(2, n):         # m letters palindromes\\n\\t\\tfor i in range(n-m):\\n\\t\\t\\tj = i+m\\n\\t\\t\\tx, k = m%2, i+m//2\\n\\t\\t\\tdp[x][k] = dp[x][k] and s[i] == s[j]\\n\\t\\t\\tif dp[x][k] and j-i > r-l:\\n\\t\\t\\t\\tl, r = i, j\\n\\treturn s[l:r+1]\\n```\n```\\ndef longestPalindrome(self, s: str) -> str:\\n\\tif not s: return s\\n\\tn, l, r = len(s), 0, 0\\n\\tdp = [[False]*n for _ in range(n)]\\n\\tdp[-1][-1] = True\\n\\tfor i in range(n-1):\\n\\t\\tdp[i][i] = True\\n\\t\\tif s[i] == s[i+1]:\\n\\t\\t\\tdp[i][i+1] = True\\n\\t\\t\\tl, r = i, i+1                        \\n\\tfor m in range(2, n):\\n\\t\\tfor i in range(n-m):\\n\\t\\t\\tj = i+m\\n\\t\\t\\tdp[i][j] = dp[i+1][j-1] and s[i] == s[j]\\n\\t\\t\\tif dp[i][j] and j-i > r-l:\\n\\t\\t\\t\\tl, r = i, j\\n\\treturn s[l:r+1]\\n```\n```\\ndef longestPalindrome(self, s: str) -> str:\\n\\tdef check(l, r):\\n\\t\\twhile 0 <= l and r < n and s[l] == s[r]: \\n\\t\\t\\tl -= 1\\n\\t\\t\\tr += 1\\n\\t\\treturn l, r\\n\\n\\tn, L, R = len(s), 0, 0\\n\\tfor i in range(2*n-1):\\n\\t\\tif i%2: l, r = check((i-1)//2, (i+1)//2)\\n\\t\\telse: l, r = check(i//2, i//2)\\n\\t\\tif r-l > R-L: L, R = l, r                \\n\\treturn s[L+1:R]\\n```\n```\\ndef longestPalindrome(self, s: str) -> str:\\n\\tt = \\'^#\\'+\\'#\\'.join(s)+\\'#$\\'\\n\\tc = r = 0                             # center and radius\\n\\tfor i in range(1,len(t)-1):\\n\\t\\tj = 1 if t[i] == \\'#\\' else 2       # skip \\'#\\' and check letters only\\n\\t\\twhile  t[i-j] == t[i+j]: j += 2\\n\\t\\tif j > r: c, r = i, j\\n\\treturn s[(c-r+1)//2:(c+r-1)//2]\\n```\n```\\ndef longestPalindrome(self, s: str) -> str:               \\n\\tt = \\'^#\\'+\\'#\\'.join(s)+\\'#$\\'\\n\\tn = len(t)\\n\\tp = [0]*n\\n\\tc = r = cm = rm = 0\\n\\tfor i in range (1, n-1):\\n\\t\\tp[i] = min(r-i, p[2*c-i]) if r > i else 0\\n\\t\\twhile t[i-p[i]-1] == t[i+p[i]+1]: p[i] += 1\\n\\t\\tif p[i]+i > r: c, r = i, p[i]+i\\n\\t\\tif p[i] > rm: cm, rm = i, p[i]\\n\\treturn s[(cm-rm)//2:(cm+rm)//2]\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 410963,
                "title": "python-beats-93-solution-with-illustrations",
                "content": "l = left bound\\nr = right bound\\n```\\n    def longestPalindrome(self, s: str) -> str:\\n        if len(s) < 2:\\n            return s\\n        start = 0\\n        maxLen = 1\\n        i = 0\\n\\n        while i < len(s):\\n            l = i\\n            r = i\\n            while r < len(s) - 1 and s[r] == s[r+1]:\\n                r += 1\\n            i = r + 1\\n            while r < len(s)-1 and l > 0 and s[r+1] == s[l-1]:\\n                l -= 1\\n                r += 1\\n            if maxLen < r - l + 1:\\n                start = l\\n                maxLen = r - l + 1\\n        return s[start: start + maxLen]\\n```\\n\\nIllustration of the idea:\\n```\\nFirst cycle:\\n// 0 1 2 3 4 5\\n// c b a a b c\\n// i\\u2192i             i = r + 1 = 0 + 1\\n// l               l-1 < 0, nothing to compare so we go to the next cycle\\n// r               r+1\\n\\nSecond cycle:\\n// 0 1 2 3 4 5\\n// c b a a b c\\n//   i\\u2192i             i = r + 1 = 1 + 1 = 2\\n// l                 l-1 = 0\\n//     r             r+1 = 2\\n// \\n// Comparing:\\n// c _ a             c!=a, nothing happend. Going next\\n\\nThird cycle (interesting part):\\n// 0 1 2 3 4 5\\n// c b a a b c\\n//     i\\u2192i\\u2192i         i = r + 1 = 3 + 1 = 4\\n//   l               l-1 = 1\\n//     r\\u2192r\\u2192r         because of s[r] == s[r+1], eg a == a, we increment r+=1. Final r = (r + 1) + 1 = 2 + 1 + 1 = 4\\n//\\n// Comparing:\\n// b _ b             b == b, then: l -= 1, r += 1\\n//\\n// c b a a b c\\n// l\\u2190                l -= 1\\n//          \\u2192r       r += 1\\n// Comparing:\\n// c _ c             c == c\\n\\nResult: cbaabc\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\n    def longestPalindrome(self, s: str) -> str:\\n        if len(s) < 2:\\n            return s\\n        start = 0\\n        maxLen = 1\\n        i = 0\\n\\n        while i < len(s):\\n            l = i\\n            r = i\\n            while r < len(s) - 1 and s[r] == s[r+1]:\\n                r += 1\\n            i = r + 1\\n            while r < len(s)-1 and l > 0 and s[r+1] == s[l-1]:\\n                l -= 1\\n                r += 1\\n            if maxLen < r - l + 1:\\n                start = l\\n                maxLen = r - l + 1\\n        return s[start: start + maxLen]\\n```\n```\\nFirst cycle:\\n// 0 1 2 3 4 5\\n// c b a a b c\\n// i\\u2192i             i = r + 1 = 0 + 1\\n// l               l-1 < 0, nothing to compare so we go to the next cycle\\n// r               r+1\\n\\nSecond cycle:\\n// 0 1 2 3 4 5\\n// c b a a b c\\n//   i\\u2192i             i = r + 1 = 1 + 1 = 2\\n// l                 l-1 = 0\\n//     r             r+1 = 2\\n// \\n// Comparing:\\n// c _ a             c!=a, nothing happend. Going next\\n\\nThird cycle (interesting part):\\n// 0 1 2 3 4 5\\n// c b a a b c\\n//     i\\u2192i\\u2192i         i = r + 1 = 3 + 1 = 4\\n//   l               l-1 = 1\\n//     r\\u2192r\\u2192r         because of s[r] == s[r+1], eg a == a, we increment r+=1. Final r = (r + 1) + 1 = 2 + 1 + 1 = 4\\n//\\n// Comparing:\\n// b _ b             b == b, then: l -= 1, r += 1\\n//\\n// c b a a b c\\n// l\\u2190                l -= 1\\n//          \\u2192r       r += 1\\n// Comparing:\\n// c _ c             c == c\\n\\nResult: cbaabc\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 110368,
                "title": "accepted-c-easy-to-understand-solution-with-explanation",
                "content": "```\\n    public class Solution \\n    {\\n        private int startIndex;\\n        private int length;\\n\\n        public string LongestPalindrome(string s)\\n        {            \\n            for (int i = 0; i < s.Length; i++)\\n            {                \\n                //For odd length.\\n                this.ExtendPallindrome(s, i, i);\\n\\n                //For even length.\\n                this.ExtendPallindrome(s, i, i + 1);\\n            }\\n\\n            return s.Substring(this.startIndex, this.length);\\n        }\\n\\n        private void ExtendPallindrome(string s, int start, int end)\\n        {\\n            while (start >= 0 && end < s.Length && s[start] == s[end])\\n            {\\n                start--;\\n                end++;\\n            }\\n\\n            //When calculating newLength;\\n            //we will have to compensate for one reduction in start and one increment in end;\\n            //because of the while loop above.           \\n            // ~ end - start -1\\n            int newLength = ((end - 1) - (start + 1)) + 1;\\n\\n            if (this.length < newLength)\\n            {\\n                //When calculating startIndex; we will have to compensate for the reduction in start.\\n                this.startIndex = start + 1;\\n                this.length = newLength;\\n            }            \\n        }\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    public class Solution \\n    {\\n        private int startIndex;\\n        private int length;\\n\\n        public string LongestPalindrome(string s)\\n        {            \\n            for (int i = 0; i < s.Length; i++)\\n            {                \\n                //For odd length.\\n                this.ExtendPallindrome(s, i, i);\\n\\n                //For even length.\\n                this.ExtendPallindrome(s, i, i + 1);\\n            }\\n\\n            return s.Substring(this.startIndex, this.length);\\n        }\\n\\n        private void ExtendPallindrome(string s, int start, int end)\\n        {\\n            while (start >= 0 && end < s.Length && s[start] == s[end])\\n            {\\n                start--;\\n                end++;\\n            }\\n\\n            //When calculating newLength;\\n            //we will have to compensate for one reduction in start and one increment in end;\\n            //because of the while loop above.           \\n            // ~ end - start -1\\n            int newLength = ((end - 1) - (start + 1)) + 1;\\n\\n            if (this.length < newLength)\\n            {\\n                //When calculating startIndex; we will have to compensate for the reduction in start.\\n                this.startIndex = start + 1;\\n                this.length = newLength;\\n            }            \\n        }\\n    }\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2715886,
                "title": "java-very-easy-to-understand",
                "content": "```\\nclass Solution {\\n    public String longestPalindrome(String s) {\\n        int start=0;\\n        int end=0;\\n        int low,high;\\n        int n=s.length();\\n        for(int i=0;i<n;i++)\\n        {\\n            // even length\\n            low=i;\\n            high=i+1;\\n            \\n            while(low>=0 && high<n && s.charAt(low)==s.charAt(high))\\n            {\\n                if((end-start)<(high-low))\\n                {\\n                    start=low;\\n                    end=high;\\n                }\\n                low--;\\n                high++;\\n            }\\n            \\n            // Odd length\\n            \\n            low=i;\\n            high=i+2;\\n            while(low>=0 && high<n && s.charAt(low)==s.charAt(high))\\n            {\\n                if((end-start)<(high-low))\\n                {\\n                    start=low;\\n                    end=high;\\n                }\\n                low--;\\n                high++;\\n            }\\n        }\\n        return s.substring(start,end+1);\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public String longestPalindrome(String s) {\\n        int start=0;\\n        int end=0;\\n        int low,high;\\n        int n=s.length();\\n        for(int i=0;i<n;i++)\\n        {\\n            // even length\\n            low=i;\\n            high=i+1;\\n            \\n            while(low>=0 && high<n && s.charAt(low)==s.charAt(high))\\n            {\\n                if((end-start)<(high-low))\\n                {\\n                    start=low;\\n                    end=high;\\n                }\\n                low--;\\n                high++;\\n            }\\n            \\n            // Odd length\\n            \\n            low=i;\\n            high=i+2;\\n            while(low>=0 && high<n && s.charAt(low)==s.charAt(high))\\n            {\\n                if((end-start)<(high-low))\\n                {\\n                    start=low;\\n                    end=high;\\n                }\\n                low--;\\n                high++;\\n            }\\n        }\\n        return s.substring(start,end+1);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 653617,
                "title": "using-recursion-and-memoization-top-down-approach",
                "content": "```\\nclass Solution {\\n    \\n    int max = Integer.MIN_VALUE;\\n    String ans = \"\";\\n    \\n    boolean recur(String s, int i, int j, int[][] dp){\\n        \\n        if(i>j) {   \\n            return true;\\n        }\\n        if(i==j) {\\n            dp[i][j] = 1;\\n            if(j-i+1 > max){\\n                max = j-i+1;\\n                ans = s.substring(i, j+1);\\n            }\\n            \\n            return true;\\n        }\\n        \\n        if(dp[i][j] != -1) return dp[i][j]==0?false:true;\\n        \\n        \\n        \\n        if(s.charAt(i)==s.charAt(j) && recur(s, i+1, j-1, dp)){\\n            \\n            dp[i][j] = 1;\\n            if(j-i+1 > max){\\n                max = j-i+1;\\n                ans = s.substring(i, j+1);\\n            }\\n            \\n        }\\n        else{\\n            dp[i][j] = 0;\\n            recur(s, i+1, j, dp);\\n            recur(s, i, j-1, dp);\\n\\n        }\\n        \\n        return dp[i][j]==0?false:true;\\n        \\n        \\n    }\\n    \\n    \\n    \\n    public String longestPalindrome(String s) {\\n        \\n        \\n        int n = s.length();\\n        \\n        int[][] dp = new int[n+1][n+1];\\n        \\n        for(int i=0;i<=n;i++){\\n            Arrays.fill(dp[i], -1);\\n        }\\n        recur(s, 0, n-1, dp);\\n        \\n        return ans;\\n        \\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    \\n    int max = Integer.MIN_VALUE;\\n    String ans = \"\";\\n    \\n    boolean recur(String s, int i, int j, int[][] dp){\\n        \\n        if(i>j) {   \\n            return true;\\n        }\\n        if(i==j) {\\n            dp[i][j] = 1;\\n            if(j-i+1 > max){\\n                max = j-i+1;\\n                ans = s.substring(i, j+1);\\n            }\\n            \\n            return true;\\n        }\\n        \\n        if(dp[i][j] != -1) return dp[i][j]==0?false:true;\\n        \\n        \\n        \\n        if(s.charAt(i)==s.charAt(j) && recur(s, i+1, j-1, dp)){\\n            \\n            dp[i][j] = 1;\\n            if(j-i+1 > max){\\n                max = j-i+1;\\n                ans = s.substring(i, j+1);\\n            }\\n            \\n        }\\n        else{\\n            dp[i][j] = 0;\\n            recur(s, i+1, j, dp);\\n            recur(s, i, j-1, dp);\\n\\n        }\\n        \\n        return dp[i][j]==0?false:true;\\n        \\n        \\n    }\\n    \\n    \\n    \\n    public String longestPalindrome(String s) {\\n        \\n        \\n        int n = s.length();\\n        \\n        int[][] dp = new int[n+1][n+1];\\n        \\n        for(int i=0;i<=n;i++){\\n            Arrays.fill(dp[i], -1);\\n        }\\n        recur(s, 0, n-1, dp);\\n        \\n        return ans;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 110375,
                "title": "java-dp-solution-with-optimization-in-space-from-o-n-2-to-o-n-time-o-n-2-with-very-clear-explanations",
                "content": "**The original DP solution: time O(n^2), space O(n^2)**\\nsome comments:\\n* The outer for-loop's index i goes from n-1 to 0, and the inner for-loop's index j goes from i to n-1, the making i occurs before j, thus we use `dp[i][j]` to represent if the substring `s(i,j)` is a palindrome.\\n* to check if substring `s(i,j)` is a palindrome, we first make sure the two characters at `s(i)` and `s(j)` equal, then there are two cases to consider:\\n    * if `j - i < 3`, which means that the substring's length is less than 3 (e.g. \"aba\", \"ab\", \"a\"), then `s(i,j)` is a palindrome.\\n    * if the \"inner\" substring `s(i+1, j-1)`, without the two characters at `s(i)` and `s(j)` is a palindrome, or `dp[i+1][j-1]`, then `s(i,j)` is a palindrome.\\n    * when j = 0, j - i is always less than 3, so we never have an index out of bound exception for `dp[i+1][j-1]`\\n* Then we check if `dp[i][j]` is true, or if `s(i,j)` is a palindrome, and compare its length with the length of the temporary result, and update the result with the longer one.\\n```\\npublic String longestPalindrome(String s) {\\n        int n = s.length();\\n        String result = \"\";\\n        boolean[][] dp = new boolean[n][n];\\n        \\n        // i goes from n - 1 to 0, j goes from i to n - 1, to make sure i occurs before j\\n        for (int i = n - 1; i >= 0; i--) {\\n            for (int j = i; j < n; j++) {\\n                dp[i][j] = s.charAt(i) == s.charAt(j) && (j - i < 3 || dp[i+1][j-1]);\\n                // if dp[i][j] is true\\uff0cupdate result\\n                if(dp[i][j] && (result.equals(\"\") || j - i + 1 > result.length())) {\\n                    result = s.substring(i, j+1); // j+1 not j, since substring includes j\\n                }\\n            }\\n        }\\n        return result;\\n    }\\n```\\nMy thoughs on optimization of space complexity:\\n\\nWe only use `dp[i+1][j-1]` to update `dp[i][j]`. We could try reducing the 2D array to 1D array.\\nSince the outer for loop is `for (int i = n - 1; i >= 0; i--)` (the index i has a decreasing order), we could notice that we only need to maintain a 1D array for index j, or using `dp[j-1]` to update dp[j]. To do so, we need the inner for loop's index j to also go backward from n-1 to i. In this way, **when we use `dp[j-1]` to update `dp[j]`, `dp[j-1]` is actually the same as 2D array's `dp[i+1][j-1]`, where i+1 is from the last for loop. The reason for index j's decreasing order is to make sure we do not modify the value of `dp[j-1]` before we use `dp[j-1]` to update `dp[j]`.**\\n\\n**The optimized DP solution: time O(n^2), space O(n)**\\n```java\\npublic static String longestPalindrome(String s) {\\n        int n = s.length();\\n        String result = \"\";\\n        boolean[] dp = new boolean[n];\\n\\n        for (int i = n - 1; i >= 0; i--) {\\n            for (int j = n - 1; j >= i; j--) { // decreasing order\\n                // dp[j-1] is the same as dp[i+1][i-1]\\n               // since both dp[j-1] and dp[i+1][j-1] are from the last iteration of the outer loop\\n                dp[j] = s.charAt(i) == s.charAt(j) && (j - i < 3 || dp[j-1]);\\n                if(dp[j] && (result.equals(\"\") || j - i + 1 > result.length())) {\\n                    result = s.substring(i, j+1);\\n                }\\n            }\\n        }\\n        return result;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\npublic String longestPalindrome(String s) {\\n        int n = s.length();\\n        String result = \"\";\\n        boolean[][] dp = new boolean[n][n];\\n        \\n        // i goes from n - 1 to 0, j goes from i to n - 1, to make sure i occurs before j\\n        for (int i = n - 1; i >= 0; i--) {\\n            for (int j = i; j < n; j++) {\\n                dp[i][j] = s.charAt(i) == s.charAt(j) && (j - i < 3 || dp[i+1][j-1]);\\n                // if dp[i][j] is true\\uff0cupdate result\\n                if(dp[i][j] && (result.equals(\"\") || j - i + 1 > result.length())) {\\n                    result = s.substring(i, j+1); // j+1 not j, since substring includes j\\n                }\\n            }\\n        }\\n        return result;\\n    }\\n```\n```java\\npublic static String longestPalindrome(String s) {\\n        int n = s.length();\\n        String result = \"\";\\n        boolean[] dp = new boolean[n];\\n\\n        for (int i = n - 1; i >= 0; i--) {\\n            for (int j = n - 1; j >= i; j--) { // decreasing order\\n                // dp[j-1] is the same as dp[i+1][i-1]\\n               // since both dp[j-1] and dp[i+1][j-1] are from the last iteration of the outer loop\\n                dp[j] = s.charAt(i) == s.charAt(j) && (j - i < 3 || dp[j-1]);\\n                if(dp[j] && (result.equals(\"\") || j - i + 1 > result.length())) {\\n                    result = s.substring(i, j+1);\\n                }\\n            }\\n        }\\n        return result;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4001583,
                "title": "simple-and-best-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n# Expand around Center Approach\\nUse each character of input as middle, and expand both side to find the palindrome.\\nKeep track of length and starting index of longest palindrome found.\\n\\n# Upvote if it helped \\uD83D\\uDE0A\\n\\n# Approach\\n\\n1. Initialize two variables: `start` to keep track of the starting index of the longest palindrome found so far, and `max` to keep track of its length. Initially, both are set to 0.\\n\\n2. Check the length of the input string `s`. If it has a length less than 2, return it immediately as it\\'s already a palindrome (or an empty string).\\n\\n3. Convert the input string `s` into a character array `chars` to make it easier to manipulate.\\n\\n4. Iterate through each character in the string using a for loop. For each character at index `i`, do the following:\\n\\n   - **Find odd-length palindromes**: Call the `findPalindrome` function with the current character as both the left and right center (i.e., `findPalindrome(chars, i, i)`). This function will expand outwards from this center to find the longest palindrome centered at this character.\\n\\n   - **Find even-length palindromes**: Call the `findPalindrome` function with the current character and the next character as the left and right centers (i.e., `findPalindrome(chars, i, i+1)`). This covers the case of even-length palindromes.\\n\\n5. The `findPalindrome` function takes a character array `chars` and two indices `j` and `k` as input. It uses these indices to expand outwards from the center and checks if the characters at `j` and `k` are equal. If they are equal, it means a longer palindrome is found, so it expands further by incrementing `k` and decrementing `j`. This process continues until the characters at `j` and `k` are no longer equal or until `j` becomes negative or `k` goes beyond the length of the string.\\n\\n6. Inside the `findPalindrome` function, if a palindrome longer than the previously recorded maximum is found, it updates the `max` variable with the new length and the `start` variable with the new starting index of the longest palindrome.\\n\\n7. After iterating through the entire string and calling `findPalindrome` for all possible centers, the `start` and `max` variables will hold the starting index and length of the longest palindromic substring in the input string.\\n\\n8. Finally, use the `start` and `max` values to extract the longest palindromic substring from the original input string `s` and return it.\\n# Example\\n\\n**Example Input String**: \"babad\"\\n\\n1. character array: `chars = [\\'b\\', \\'a\\', \\'b\\', \\'a\\', \\'d\\']`.\\n\\n2. Iterate through the characters in the string:\\n\\n   - **Iteration 1 (i = 0, char = \\'b\\')**:\\n\\n     - Find odd-length palindrome by calling `findPalindrome(chars, 0, 0)`. The center is \\'b\\'.\\n\\n       - Expand outwards: \\'b\\' == \\'b\\'.\\n\\n       - Continue expanding: \\'a\\' != \\'d\\'. Stop.\\n\\n     - Find even-length palindrome by calling `findPalindrome(chars, 0, 1)`. The centers are \\'b\\' and \\'a\\'.\\n\\n       - Expand outwards: \\'b\\' != \\'a\\'. Stop.\\n\\n   - **Iteration 2 (i = 1, char = \\'a\\')**:\\n\\n     - Find odd-length palindrome by calling `findPalindrome(chars, 1, 1)`. The center is \\'a\\'.\\n\\n       - Expand outwards: \\'a\\' == \\'a\\'.\\n\\n       - Continue expanding: \\'b\\' != \\'d\\'. Stop.\\n\\n     - Find even-length palindrome by calling `findPalindrome(chars, 1, 2)`. The centers are \\'a\\' and \\'b\\'.\\n\\n       - Expand outwards: \\'a\\' != \\'b\\'. Stop.\\n\\n   - **Iteration 3 (i = 2, char = \\'b\\')**:\\n\\n     - Find odd-length palindrome by calling `findPalindrome(chars, 2, 2)`. The center is \\'b\\'.\\n\\n       - Expand outwards: \\'b\\' == \\'b\\'.\\n\\n       - Continue expanding: \\'a\\' == \\'a\\'.\\n\\n       - Continue expanding: \\'b\\' != \\'d\\'. Stop.\\n\\n     - Find even-length palindrome by calling `findPalindrome(chars, 2, 3)`. The centers are \\'b\\' and \\'a\\'.\\n\\n       - Expand outwards: \\'b\\' != \\'a\\'. Stop.\\n\\n   - **Iteration 4 (i = 3, char = \\'a\\')**:\\n\\n     - Find odd-length palindrome by calling `findPalindrome(chars, 3, 3)`. The center is \\'a\\'.\\n\\n       - Expand outwards: \\'a\\' == \\'a\\'.\\n\\n       - Continue expanding: \\'b\\' != \\'d\\'. Stop.\\n\\n     - Find even-length palindrome by calling `findPalindrome(chars, 3, 4)`. The centers are \\'a\\' and \\'d\\'.\\n\\n       - Expand outwards: \\'a\\' != \\'d\\'. Stop.\\n\\n   - **Iteration 5 (i = 4, char = \\'d\\')**:\\n\\n     - Find odd-length palindrome by calling `findPalindrome(chars, 4, 4)`. The center is \\'d\\'.\\n\\n       - Expand outwards: \\'d\\' == \\'d\\'.\\n\\n       - No more characters to expand. Stop.\\n\\n     - Find even-length palindrome by calling `findPalindrome(chars, 4, 5)`. The centers are \\'d\\' and out of bounds.\\n\\n       - Out of bounds, so stop.\\n\\n3. After completing the iterations, the `max` variable holds the length of the longest palindrome found (3), and the `start` variable holds the starting index of that palindrome (1).\\n\\n4. Return the substring of the input string using `start` and `max`, which is \"bab\". This is the longest palindromic substring.\\n\\nSo, in this example, the algorithm correctly identifies \"bab\" as the longest palindromic substring, which is both odd and even in length. The algorithm efficiently explores all possible centers to find palindromes and keeps track of the longest one encountered.\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n*n)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n# Code\\n```\\nclass Solution {\\n    int start = 0; // Initialize the start index for the longest palindrome.\\n    int max = 0;   // Initialize the length of the longest palindrome.\\n\\n    public String longestPalindrome(String s) {\\n        if(s.length() < 2)\\n            return s; \\n\\n        char[] chars = s.toCharArray();\\n\\n        for(int i = 0; i < chars.length; i++){\\n            // Find odd length palindrome\\n            findPalindrome(chars, i, i); // current character as the center of the palindrome\\n\\n            // Find even length palindrome\\n            findPalindrome(chars, i, i+1); // current character and the next character as the centers of the palindrome.\\n        }\\n        \\n        // Return the longest palindromic substring by using the start and max indices.\\n        return s.substring(start, start + max);\\n    }\\n\\n    private void findPalindrome(char[] chars, int j, int k){\\n        // Expand the palindrome by checking characters at indices j and k.\\n        while( j >= 0 && k < chars.length && chars[j] == chars[k]){\\n            j--;\\n            k++;\\n        }\\n        \\n        // Check if the current palindrome length is greater than the previously recorded maximum.\\n        if(max < k - j - 1){\\n            max = k - j - 1;   // Update the length of the longest palindrome.\\n            start = j + 1;     // Update the start index of the longest palindrome.\\n        }\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Two Pointers",
                    "String"
                ],
                "code": "```\\nclass Solution {\\n    int start = 0; // Initialize the start index for the longest palindrome.\\n    int max = 0;   // Initialize the length of the longest palindrome.\\n\\n    public String longestPalindrome(String s) {\\n        if(s.length() < 2)\\n            return s; \\n\\n        char[] chars = s.toCharArray();\\n\\n        for(int i = 0; i < chars.length; i++){\\n            // Find odd length palindrome\\n            findPalindrome(chars, i, i); // current character as the center of the palindrome\\n\\n            // Find even length palindrome\\n            findPalindrome(chars, i, i+1); // current character and the next character as the centers of the palindrome.\\n        }\\n        \\n        // Return the longest palindromic substring by using the start and max indices.\\n        return s.substring(start, start + max);\\n    }\\n\\n    private void findPalindrome(char[] chars, int j, int k){\\n        // Expand the palindrome by checking characters at indices j and k.\\n        while( j >= 0 && k < chars.length && chars[j] == chars[k]){\\n            j--;\\n            k++;\\n        }\\n        \\n        // Check if the current palindrome length is greater than the previously recorded maximum.\\n        if(max < k - j - 1){\\n            max = k - j - 1;   // Update the length of the longest palindrome.\\n            start = j + 1;     // Update the start index of the longest palindrome.\\n        }\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3779484,
                "title": "java-solution-using-2-pointers-without-dp",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\n    public String longestPalindrome(String s) {\\n       int start = 0, end = 0;\\n       for(int i = 0; i < s.length(); i ++) {\\n           char c = s.charAt(i);\\n           int left = i;\\n           int right = i;\\n           while(left >= 0 && s.charAt(left) == c) left --;\\n           while(right < s.length() && s.charAt(right) == c) right ++;\\n           while(left >= 0 && right < s.length()) {\\n               if(s.charAt(left) != s.charAt(right)) break;\\n               left --;\\n               right ++;\\n           }\\n           left += 1;\\n           if(end - start < right - left) {\\n               start = left;\\n               end = right;\\n           }\\n       } \\n       return s.substring(start, end);\\n    }\\n}\\n```\\n# PLEASE UPVOTE IF IT WAS HELPFULL",
                "solutionTags": [
                    "Java",
                    "Two Pointers",
                    "String"
                ],
                "code": "```\\nclass Solution {\\n    public String longestPalindrome(String s) {\\n       int start = 0, end = 0;\\n       for(int i = 0; i < s.length(); i ++) {\\n           char c = s.charAt(i);\\n           int left = i;\\n           int right = i;\\n           while(left >= 0 && s.charAt(left) == c) left --;\\n           while(right < s.length() && s.charAt(right) == c) right ++;\\n           while(left >= 0 && right < s.length()) {\\n               if(s.charAt(left) != s.charAt(right)) break;\\n               left --;\\n               right ++;\\n           }\\n           left += 1;\\n           if(end - start < right - left) {\\n               start = left;\\n               end = right;\\n           }\\n       } \\n       return s.substring(start, end);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2156653,
                "title": "python-dynamic-and-brute",
                "content": "**UPVOTE IF HELPFuuL**\\n\\nDYNAMIC APPROACH\\n\\n**PALINDROME in DP**->If its first and last elements are same and the substring after excluding the first and last character is a palindrome.\\n* Hence we can now reduce a bigger problem to smaller problem whose answer may be previously known.\\n\\n* Use a matrix where ```dp[ i ] [ j ]``` represents substring from ith pos to jth pos.\\n* All single characters are palindromes, thus substring with a length 1 are substring by default.\\n* substrings of length 2 are *palin* if both characters are same.\\n* \\nAnd for rest of lengths use the sub problem.\\n\\nNow we need longest so the palindromic substring with longest length is the substring.\\n\\n**BRUTE FORECE**\\n```\\nclass Solution:\\n   \\n    def longestPalindrome(self, s: str) -> str:\\n        res=s[0]\\n        nn=len(res)\\n        n=len(s)\\n        for i in range(1,n-1):\\n            \\n            kk=s[i]\\n            z=1\\n            while ((i-z)>=0) and ((i+z)<n) and (s[i-z]==s[i+z]):\\n                kk=s[i-z]+kk+s[i-z]\\n                z+=1\\n            \\n            if len(kk)>nn:\\n                res=kk\\n                nn=len(res)\\n        for i in range(0,n-1):\\n            if s[i]==s[i+1]:\\n                \\n                kk=s[i]+s[i+1]\\n                z=1\\n                while ((i-z)>=0) and ((i+z+1)<n) and (s[i-z]==s[i+z+1]):\\n                    kk=s[i-z]+kk+s[i-z]\\n                    z+=1\\n                if len(kk)>nn:\\n                    res=kk\\n                    nn=len(res)\\n        return res\\n```\\n\\n**UPVOTE IF HELPFuuL**\\n\\n**DYNAMIC APPROACH**\\n\\n```\\nclass Solution:\\n   def longestPalindrome(self, s):\\n        res = \\'\\'\\n        dp = [[0]*len(s) for i in range(len(s))]\\n        \\n        for i in range(len(s)):\\n            dp[i][i] = True\\n            res = s[i]\\n\\t\\t\\t\\n        for i in range(len(s)-1,-1,-1):\\n            for j in range(i+1,len(s)):  \\n                \\n                if s[i] == s[j]:\\n                    if j-i ==1 or dp[i+1][j-1] is True:\\n                        dp[i][j] = True\\n                        \\n                        if len(res) < len(s[i:j+1]):\\n                            res = s[i:j+1]\\n                \\n        return res\\n```\\n![image](https://assets.leetcode.com/users/images/0007f2ce-d76f-46e8-b520-794d74ca5506_1655338899.7001777.jpeg)\\n",
                "solutionTags": [
                    "Python3",
                    "Dynamic Programming"
                ],
                "code": "```dp[ i ] [ j ]```\n```\\nclass Solution:\\n   \\n    def longestPalindrome(self, s: str) -> str:\\n        res=s[0]\\n        nn=len(res)\\n        n=len(s)\\n        for i in range(1,n-1):\\n            \\n            kk=s[i]\\n            z=1\\n            while ((i-z)>=0) and ((i+z)<n) and (s[i-z]==s[i+z]):\\n                kk=s[i-z]+kk+s[i-z]\\n                z+=1\\n            \\n            if len(kk)>nn:\\n                res=kk\\n                nn=len(res)\\n        for i in range(0,n-1):\\n            if s[i]==s[i+1]:\\n                \\n                kk=s[i]+s[i+1]\\n                z=1\\n                while ((i-z)>=0) and ((i+z+1)<n) and (s[i-z]==s[i+z+1]):\\n                    kk=s[i-z]+kk+s[i-z]\\n                    z+=1\\n                if len(kk)>nn:\\n                    res=kk\\n                    nn=len(res)\\n        return res\\n```\n```\\nclass Solution:\\n   def longestPalindrome(self, s):\\n        res = \\'\\'\\n        dp = [[0]*len(s) for i in range(len(s))]\\n        \\n        for i in range(len(s)):\\n            dp[i][i] = True\\n            res = s[i]\\n\\t\\t\\t\\n        for i in range(len(s)-1,-1,-1):\\n            for j in range(i+1,len(s)):  \\n                \\n                if s[i] == s[j]:\\n                    if j-i ==1 or dp[i+1][j-1] is True:\\n                        dp[i][j] = True\\n                        \\n                        if len(res) < len(s[i:j+1]):\\n                            res = s[i:j+1]\\n                \\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2156645,
                "title": "java-dynamic-and-brute",
                "content": "**UPVOTE IF HELPFuuL**\\n\\n\\nDYNAMIC APPROACH\\n\\n**PALINDROME in DP**->If its first and last elements are same and the substring after excluding the first and last character is a palindrome.\\n* Hence we can now reduce a bigger problem to smaller problem whose answer may be previously known.\\n\\n* Use a matrix where ```dp[ i ] [ j ]``` represents substring from ith pos to jth pos.\\n* All single characters are palindromes, thus substring with a length 1 are substring by default.\\n* substrings of length 2 are *palin* if both characters are same.\\n* \\nAnd for rest of lengths use the sub problem.\\n\\nNow we need longest so the palindromic substring with longest length is the substring.\\n\\n**BRUTE FORCE**\\n```\\npublic class Solution \\n{\\n\\tprivate int lo, result;\\n\\n\\tpublic String longestPalindrome(String s) {\\n\\t\\tint len = s.length();\\n\\t\\tif (len < 2)\\n\\t\\t\\treturn s;\\n\\t\\n\\t    for (int i = 0; i < len-1; i++) {\\n    \\t \\tsolve(s, i, i);\\n     \\t\\tsolve(s, i, i+1);\\n\\t    }\\n    \\treturn s.substring(lo, lo + result);\\n\\t}\\n\\n\\tprivate void solve(String s, int j, int k) {\\n\\t\\twhile (j >= 0 && k < s.length() && s.charAt(j) == s.charAt(k)) {\\n\\t\\t\\tj--;\\n\\t\\t\\tk++;\\n\\t\\t}\\n\\t\\tif (result < k - j - 1) {\\n\\t\\t\\tlo = j + 1;\\n\\t\\t\\tresult = k - j - 1;\\n\\t\\t}\\n\\t}\\n}\\n```\\n**UPVOTE IF HELPFuuL**\\n\\n**DYNAMIC APPROACH**\\n\\n```\\npublic class Solution \\n{\\n\\tpublic String longestPalindrome(String s) {\\n    \\tint n = s.length();\\n    \\tString res = null;\\n    \\n    \\tboolean[][] dp = new boolean[n][n];\\n    \\n  \\t    for (int i = n - 1; i >= 0; i--) {\\n        \\tfor (int j = i; j < n; j++) {\\n        \\t\\tdp[i][j] = s.charAt(i) == s.charAt(j) && (j - i < 3 || dp[i + 1][j - 1]);\\n            \\n      \\t\\t\\tif (dp[i][j] && (res == null || j - i + 1 > res.length())) {\\n        \\t\\t\\tres = s.substring(i, j + 1);\\n    \\t\\t\\t}\\n    \\t\\t}\\n\\t\\t}\\n    \\n  \\t\\treturn res;\\n\\t}\\n}\\n```\\n![image](https://assets.leetcode.com/users/images/8f6a9e7e-d3c7-4609-8809-cc35b600da80_1655338676.7202148.jpeg)\\n",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "```dp[ i ] [ j ]```\n```\\npublic class Solution \\n{\\n\\tprivate int lo, result;\\n\\n\\tpublic String longestPalindrome(String s) {\\n\\t\\tint len = s.length();\\n\\t\\tif (len < 2)\\n\\t\\t\\treturn s;\\n\\t\\n\\t    for (int i = 0; i < len-1; i++) {\\n    \\t \\tsolve(s, i, i);\\n     \\t\\tsolve(s, i, i+1);\\n\\t    }\\n    \\treturn s.substring(lo, lo + result);\\n\\t}\\n\\n\\tprivate void solve(String s, int j, int k) {\\n\\t\\twhile (j >= 0 && k < s.length() && s.charAt(j) == s.charAt(k)) {\\n\\t\\t\\tj--;\\n\\t\\t\\tk++;\\n\\t\\t}\\n\\t\\tif (result < k - j - 1) {\\n\\t\\t\\tlo = j + 1;\\n\\t\\t\\tresult = k - j - 1;\\n\\t\\t}\\n\\t}\\n}\\n```\n```\\npublic class Solution \\n{\\n\\tpublic String longestPalindrome(String s) {\\n    \\tint n = s.length();\\n    \\tString res = null;\\n    \\n    \\tboolean[][] dp = new boolean[n][n];\\n    \\n  \\t    for (int i = n - 1; i >= 0; i--) {\\n        \\tfor (int j = i; j < n; j++) {\\n        \\t\\tdp[i][j] = s.charAt(i) == s.charAt(j) && (j - i < 3 || dp[i + 1][j - 1]);\\n            \\n      \\t\\t\\tif (dp[i][j] && (res == null || j - i + 1 > res.length())) {\\n        \\t\\t\\tres = s.substring(i, j + 1);\\n    \\t\\t\\t}\\n    \\t\\t}\\n\\t\\t}\\n    \\n  \\t\\treturn res;\\n\\t}\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1056859,
                "title": "recursion-a-few-dp-variants",
                "content": "1. recursion, O(2^n)\\n```\\nclass Solution {\\n    public String longestPalindrome(String s) {\\n        return longRecur(s,0,s.length()-1);\\n    }\\n    \\n    String longRecur(String str,int s,int e) \\n        if(s==e) return String.valueOf(str.charAt(s)); //base\\n        if(s>e) return \"\";\\n        \\n        //case 1\\n        if(str.charAt(s) == str.charAt(e)) {\\n            String both = longRecur(str,s+1,e-1);\\n            if(both.length() ==  e-1-(s+1)+1) //check if the remaining string is also a palindrome\\n                return str.charAt(s) + both + str.charAt(e);\\n        }\\n        \\n        //case2\\n        String left = longRecur(str,s+1,e);\\n        String right = longRecur(str,s,e-1);\\n        if(left.length() > right.length()) return left;\\n        else return right;\\n    }\\n}\\n```\\n\\n2. recursion + memo =  top-down dp (I\\'m adding this as requested)\\n```\\nclass Solution {\\n    \\n    public String longestPalindrome(String s) {\\n        return longRecur(s,0,s.length()-1, new String[s.length()][s.length()]);\\n    }\\n    \\n    private String longRecur(String str,int s,int e, String[][] memo) {\\n        //base\\n        if(s==e) return String.valueOf(str.charAt(s)); \\n        if(s>e) return \"\";\\n        \\n        if(memo[s][e]!=null) return memo[s][e];\\n    \\n        //case 1\\n        if(str.charAt(s) == str.charAt(e)) {\\n            String both = longRecur(str,s+1,e-1,memo);\\n            if(both.length() ==  e-1-(s+1)+1) { //check if the remaining string is also a palindrome\\n                String ret = str.charAt(s) + both + str.charAt(e);\\n                memo[s][e] = ret;\\n                return ret;\\n            }\\n        }\\n        \\n        //case2\\n        String left = longRecur(str,s+1,e,memo);\\n        String right = longRecur(str,s,e-1,memo);\\n    \\n        if(left.length() > right.length()) {\\n            memo[s][e] = left;\\n            return left;\\n        } else {\\n            memo[s][e] = right;\\n            return right;\\n        }\\n    }\\n}\\n```\\n\\nthere could be a few bottom-up dp variants.\\n\\n\\n\\n3. dp, using String[][] longestPalindrome\\n\\twe can directly store strings into the matrix. \\n\\tit\\'s a direct conversion of the recursion solution above.\\n\\ttime O(n^2), space O(n^2) \\n\\tbut then since it\\'s directly handling strings it\\'s relatively slower than other dp variants below.\\n\\n```\\nclass Solution {\\n    \\n    public String longestPalindrome(String str) {\\n        \\n        int n = str.length();\\n        String[][] dp = new String[n][n]; //longestPalindrome\\n\\n\\t\\t//init the matrix\\n        for(int i =0;i<n;i++) \\n            for(int j=0;j<n;j++) \\n               dp[i][j] =\"\";\\n         \\n        //base\\n        for(int i=0;i<n;i++) \\n            dp[i][i] = String.valueOf(str.charAt(i));\\n        \\n        //fill in the upper right half\\n        for(int s=n-1; s>=0; s--)  {\\n            for(int e = s+1; e<n; e++) {\\n                if(str.charAt(s) == str.charAt(e)) {\\n                  String both = dp[s+1][e-1];\\n                    if( both.length() ==  e-1-(s+1)+1) {\\n                        dp[s][e] = str.charAt(s) + both + str.charAt(e);\\n                        continue;\\n                    }\\n                }\\n    \\n                String left = dp[s+1][e];\\n                String right = dp[s][e-1];\\n                if(left.length() > right.length()) dp[s][e] = left;\\n                else dp[s][e] = right;\\n            }\\n        }\\n        return dp[0][n-1]; \\n    }\\n} \\n```\\n\\n4. dp, using int[][] maxLength (i.e. the length of the longest palindrome)\\ninstead of handling strings directly, we can just keep track of maxLen and return the substring at the end.\\ntime O(n^2), space O(n^2) \\n\\n```\\nclass Solution {\\n    \\n    public String longestPalindrome(String str) {\\n        \\n        int n = str.length();\\n        int[][] dp = new int[n][n]; //means the length of the longest palindrom of str.substring(i,j+1)\\n        for(int i=0;i<n;i++)//base\\n            dp[i][i] = 1;\\n        int maxLen=1, maxStart =0;\\n\\n        for(int s = n-1;s>=0;s--) {\\n            for(int e=s+1;e<n;e++) {\\n                \\n                if(str.charAt(s) ==str.charAt(e)) {\\n                    if(dp[s+1][e-1] == e-1 -(s+1)+1) {\\n                        dp[s][e] = dp[s+1][e-1] +2;\\n                        int len = e-s+1;\\n                        if(maxLen<len) {\\n                            maxLen = len;\\n                            maxStart = s;\\n                        } \\n                        continue;\\n                    }\\n                }\\n                 \\n                int left = dp[s+1][e];\\n                int right = dp[s][e-1];\\n                dp[s][e] = Math.max(left,right);\\n            }\\n        }\\n        return str.substring(maxStart,maxStart+maxLen);\\n    }\\n} \\n```\\n\\n\\n5. dp, using boolean[][] isPalindrome\\nit\\'s the simplest form\\ntime O(n^2), space O(n^2) \\n\\n```\\nclass Solution {\\n    \\n    public String longestPalindrome(String str) {\\n        \\n        int n = str.length();\\n        boolean[][] dp = new boolean[n][n];  //means if str.substring(i,j+1) is palindrome. \\n        int maxLen=1,maxStart=0;\\n        //base\\n        for(int i=0;i<n;i++)\\n            dp[i][i] = true;\\n \\n        for(int s = n-1;s>=0;s--) {\\n            for(int e=s+1;e<n;e++) {   \\n                if(str.charAt(s) ==str.charAt(e)) {\\n                    if(dp[s+1][e-1] || e-1-(s+1)+1==0 ) { // e-1-(s+1)+1==0 means smaller_str.length()==0\\n                        dp[s][e] = true;\\n                        int len = e-s+1;\\n                        if(maxLen<len) {\\n                           maxLen = len;\\n                           maxStart =s;\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n        return str.substring(maxStart,maxStart+maxLen);\\n    }\\n} \\n```\\nnote that \\nboolean[][] isPalindrome above  is the dp of the following \\n```\\n\\n  boolean isPalindrome(String str, int s, int e) {\\n\\t    while(s<=e){\\n\\t\\t\\tif(str.charAt(s)!=str.charAt(e)) return false;\\n\\t\\t\\ts++;\\n\\t\\t\\te--;\\n\\t\\t}\\n\\t\\treturn true;\\n  }\\n```\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public String longestPalindrome(String s) {\\n        return longRecur(s,0,s.length()-1);\\n    }\\n    \\n    String longRecur(String str,int s,int e) \\n        if(s==e) return String.valueOf(str.charAt(s)); //base\\n        if(s>e) return \"\";\\n        \\n        //case 1\\n        if(str.charAt(s) == str.charAt(e)) {\\n            String both = longRecur(str,s+1,e-1);\\n            if(both.length() ==  e-1-(s+1)+1) //check if the remaining string is also a palindrome\\n                return str.charAt(s) + both + str.charAt(e);\\n        }\\n        \\n        //case2\\n        String left = longRecur(str,s+1,e);\\n        String right = longRecur(str,s,e-1);\\n        if(left.length() > right.length()) return left;\\n        else return right;\\n    }\\n}\\n```\n```\\nclass Solution {\\n    \\n    public String longestPalindrome(String s) {\\n        return longRecur(s,0,s.length()-1, new String[s.length()][s.length()]);\\n    }\\n    \\n    private String longRecur(String str,int s,int e, String[][] memo) {\\n        //base\\n        if(s==e) return String.valueOf(str.charAt(s)); \\n        if(s>e) return \"\";\\n        \\n        if(memo[s][e]!=null) return memo[s][e];\\n    \\n        //case 1\\n        if(str.charAt(s) == str.charAt(e)) {\\n            String both = longRecur(str,s+1,e-1,memo);\\n            if(both.length() ==  e-1-(s+1)+1) { //check if the remaining string is also a palindrome\\n                String ret = str.charAt(s) + both + str.charAt(e);\\n                memo[s][e] = ret;\\n                return ret;\\n            }\\n        }\\n        \\n        //case2\\n        String left = longRecur(str,s+1,e,memo);\\n        String right = longRecur(str,s,e-1,memo);\\n    \\n        if(left.length() > right.length()) {\\n            memo[s][e] = left;\\n            return left;\\n        } else {\\n            memo[s][e] = right;\\n            return right;\\n        }\\n    }\\n}\\n```\n```\\nclass Solution {\\n    \\n    public String longestPalindrome(String str) {\\n        \\n        int n = str.length();\\n        String[][] dp = new String[n][n]; //longestPalindrome\\n\\n\\t\\t//init the matrix\\n        for(int i =0;i<n;i++) \\n            for(int j=0;j<n;j++) \\n               dp[i][j] =\"\";\\n         \\n        //base\\n        for(int i=0;i<n;i++) \\n            dp[i][i] = String.valueOf(str.charAt(i));\\n        \\n        //fill in the upper right half\\n        for(int s=n-1; s>=0; s--)  {\\n            for(int e = s+1; e<n; e++) {\\n                if(str.charAt(s) == str.charAt(e)) {\\n                  String both = dp[s+1][e-1];\\n                    if( both.length() ==  e-1-(s+1)+1) {\\n                        dp[s][e] = str.charAt(s) + both + str.charAt(e);\\n                        continue;\\n                    }\\n                }\\n    \\n                String left = dp[s+1][e];\\n                String right = dp[s][e-1];\\n                if(left.length() > right.length()) dp[s][e] = left;\\n                else dp[s][e] = right;\\n            }\\n        }\\n        return dp[0][n-1]; \\n    }\\n} \\n```\n```\\nclass Solution {\\n    \\n    public String longestPalindrome(String str) {\\n        \\n        int n = str.length();\\n        int[][] dp = new int[n][n]; //means the length of the longest palindrom of str.substring(i,j+1)\\n        for(int i=0;i<n;i++)//base\\n            dp[i][i] = 1;\\n        int maxLen=1, maxStart =0;\\n\\n        for(int s = n-1;s>=0;s--) {\\n            for(int e=s+1;e<n;e++) {\\n                \\n                if(str.charAt(s) ==str.charAt(e)) {\\n                    if(dp[s+1][e-1] == e-1 -(s+1)+1) {\\n                        dp[s][e] = dp[s+1][e-1] +2;\\n                        int len = e-s+1;\\n                        if(maxLen<len) {\\n                            maxLen = len;\\n                            maxStart = s;\\n                        } \\n                        continue;\\n                    }\\n                }\\n                 \\n                int left = dp[s+1][e];\\n                int right = dp[s][e-1];\\n                dp[s][e] = Math.max(left,right);\\n            }\\n        }\\n        return str.substring(maxStart,maxStart+maxLen);\\n    }\\n} \\n```\n```\\nclass Solution {\\n    \\n    public String longestPalindrome(String str) {\\n        \\n        int n = str.length();\\n        boolean[][] dp = new boolean[n][n];  //means if str.substring(i,j+1) is palindrome. \\n        int maxLen=1,maxStart=0;\\n        //base\\n        for(int i=0;i<n;i++)\\n            dp[i][i] = true;\\n \\n        for(int s = n-1;s>=0;s--) {\\n            for(int e=s+1;e<n;e++) {   \\n                if(str.charAt(s) ==str.charAt(e)) {\\n                    if(dp[s+1][e-1] || e-1-(s+1)+1==0 ) { // e-1-(s+1)+1==0 means smaller_str.length()==0\\n                        dp[s][e] = true;\\n                        int len = e-s+1;\\n                        if(maxLen<len) {\\n                           maxLen = len;\\n                           maxStart =s;\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n        return str.substring(maxStart,maxStart+maxLen);\\n    }\\n} \\n```\n```\\n\\n  boolean isPalindrome(String str, int s, int e) {\\n\\t    while(s<=e){\\n\\t\\t\\tif(str.charAt(s)!=str.charAt(e)) return false;\\n\\t\\t\\ts++;\\n\\t\\t\\te--;\\n\\t\\t}\\n\\t\\treturn true;\\n  }\\n```",
                "codeTag": "Java"
            },
            {
                "id": 880368,
                "title": "fast-and-simple-solution-on-swift-95-speed-95-memory",
                "content": "Fast and simple solution.\\n\\n`Your runtime beats 95.90 % of swift submissions.`\\n`Your memory usage beats 95.58 % of swift submissions.`\\n\\nHow to define if the string is palindrome?\\n\\n**Brief description:**\\nFrom some point in the middle of the string let\\'s start cheking if the two next chars from the left and right are equal.\\nIf they are equal then continue checking next two chars:\\n\\n```\\n// odd palindrome  - \"cabac\"\\n// even palindrome - \"cabbac\"\\n\\n// odd  fcbaBadca      even  adSBAABSfd\\n//         -x-                   x-\\n//        --x--                 -x--\\n//       ---x---               --x---\\n```\\n\\nThat\\'s how we can find a palindrome at any point of the string.\\n\\n**Then:**\\nCheck until next two side chars are different(1) or we go out of the string size(2).\\nStore palindrom start and finish indexes.\\nIn case of (1) move to another starting point and continue to search a bigger palindrome.\\nIn cease of (2) end of the search.\\n\\n**Result:**\\nOutput found string.\\n\\n**Solution:**\\n\\n```\\nclass Solution {\\n\\t// Store input string as array.\\n    private var array: [Character]!\\n\\n\\t// Store biggest palindrome info.\\n    private var maxSize = 0\\n    private var bestStart = 0\\n    private var bestFinish = 0\\n\\n    func longestPalindrome(_ s: String) -> String {\\n        array = Array(s) // Make an aray out of the input string.\\n        guard array.count > 1 else { return s } // Check edge case.\\n\\t\\t\\n\\t\\t// Let\\'s start from the middle of the string,\\n\\t\\t//   since it\\'s the best place for a big palindrome.\\n        let middle = Int(array.count / 2)\\n\\t\\t\\n\\t\\t// And continue to search in two directions: to the left and right side:\\n\\t\\t//                           start \\n\\t\\t//                  <-L        |          R->\\n\\t\\t// \"dfjhasdliudfhnasudkhcfaiehncfnusejagxfkuyseagjfuygaefgvaskuyfc\"\\n        var lStart = middle\\n        var rStart = middle + 1\\n\\t\\t\\n\\t\\t// Check if we should continue our search.\\n        while worthCheck(from: lStart) {\\n            check(lStart)  // Check left direction.\\n            lStart -= 1    // Make a step to the left.\\n            check(rStart)  // Check right direcion.\\n            rStart += 1    // Make step to the right.\\n        }\\n        return String(array[bestStart...bestFinish]) // Output the result.\\n    }\\n\\n    /// Is it possible to find a bigger palindrome in the array starting from `index` point?\\n    private func worthCheck(from index: Int) -> Bool {\\n        guard 0 <= index else { return false } // out of array\\n\\t\\t\\n\\t\\t// If we 2 chars from the string edge then max palindrom \\n\\t\\t//   we can found is size 5\\n\\t\\t//   but if we already have found palindrome with size 7\\n\\t\\t//   then it\\'s not worth to spend time on this search any more.\\n\\t\\t\\n\\t\\t// char count from start of the string\\n        let charCount = index + 1\\n        let maxPotentialSizeOfPalindrome = charCount * 2 + 1\\n\\t\\t// check if there space for big enough palindrome.\\n        return maxPotentialSizeOfPalindrome > maxSize\\n    }\\n\\n    private func check(_ startIndex: Int) {\\n\\t\\t// let\\'s search odd and even palindromes\\n        check(startIndex, odd: false) // like \"abba\"\\n        check(startIndex, odd: true)  // like \"aba\"\\n    }\\n\\n    private func check(_ startIndex: Int, odd: Bool) {\\n\\t\\t// Search progression example\\n\\t\\t//   s - start point\\n\\t\\t//   l - left index, start of potential palindrome\\n\\t\\t//   r - right index, end of potential palindrome\\n\\t\\t\\n        // odd  fcbaBadca      even  adSBAABSfd\\n        //         lsr                   sr\\n        //        l-s-r                 ls-r\\n        //       l--s--r               l-s--r\\n\\n        var offset = 1\\n        let oddity = (odd ? 0 : 1) // Shift `lhs` index one step to the left to find `even` palindrome.\\n        repeat {\\n\\t\\t    // Calc left and right indexes.\\n            let lhs = startIndex - offset + oddity\\n            let rhs = startIndex + offset\\n\\t\\t\\t\\n            guard 0 <= lhs, rhs < array.count,   // Check if we are still in the array.\\n                  array[lhs] == array[rhs]       // Check if side chars are equal.\\n            else { break }                       // If this is not a palindrome then break the search.\\n\\t\\t\\t\\n\\t\\t\\t// Let\\'s check if we\\'ve found a biggest palindrome then before and store it.\\n            let lenght = rhs - lhs\\n            if lenght > maxSize {\\n                maxSize = lenght\\n                bestStart = lhs\\n                bestFinish = rhs\\n            }\\n\\t\\t\\t// Increase offset for left and right index and repeat.\\n\\t\\t\\toffset += 1\\n        } while true\\n    }\\n}\\n```\\n\\nThanks for reading and please feel free to comment.",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\n// odd palindrome  - \"cabac\"\\n// even palindrome - \"cabbac\"\\n\\n// odd  fcbaBadca      even  adSBAABSfd\\n//         -x-                   x-\\n//        --x--                 -x--\\n//       ---x---               --x---\\n```\n```\\nclass Solution {\\n\\t// Store input string as array.\\n    private var array: [Character]!\\n\\n\\t// Store biggest palindrome info.\\n    private var maxSize = 0\\n    private var bestStart = 0\\n    private var bestFinish = 0\\n\\n    func longestPalindrome(_ s: String) -> String {\\n        array = Array(s) // Make an aray out of the input string.\\n        guard array.count > 1 else { return s } // Check edge case.\\n\\t\\t\\n\\t\\t// Let\\'s start from the middle of the string,\\n\\t\\t//   since it\\'s the best place for a big palindrome.\\n        let middle = Int(array.count / 2)\\n\\t\\t\\n\\t\\t// And continue to search in two directions: to the left and right side:\\n\\t\\t//                           start \\n\\t\\t//                  <-L        |          R->\\n\\t\\t// \"dfjhasdliudfhnasudkhcfaiehncfnusejagxfkuyseagjfuygaefgvaskuyfc\"\\n        var lStart = middle\\n        var rStart = middle + 1\\n\\t\\t\\n\\t\\t// Check if we should continue our search.\\n        while worthCheck(from: lStart) {\\n            check(lStart)  // Check left direction.\\n            lStart -= 1    // Make a step to the left.\\n            check(rStart)  // Check right direcion.\\n            rStart += 1    // Make step to the right.\\n        }\\n        return String(array[bestStart...bestFinish]) // Output the result.\\n    }\\n\\n    /// Is it possible to find a bigger palindrome in the array starting from `index` point?\\n    private func worthCheck(from index: Int) -> Bool {\\n        guard 0 <= index else { return false } // out of array\\n\\t\\t\\n\\t\\t// If we 2 chars from the string edge then max palindrom \\n\\t\\t//   we can found is size 5\\n\\t\\t//   but if we already have found palindrome with size 7\\n\\t\\t//   then it\\'s not worth to spend time on this search any more.\\n\\t\\t\\n\\t\\t// char count from start of the string\\n        let charCount = index + 1\\n        let maxPotentialSizeOfPalindrome = charCount * 2 + 1\\n\\t\\t// check if there space for big enough palindrome.\\n        return maxPotentialSizeOfPalindrome > maxSize\\n    }\\n\\n    private func check(_ startIndex: Int) {\\n\\t\\t// let\\'s search odd and even palindromes\\n        check(startIndex, odd: false) // like \"abba\"\\n        check(startIndex, odd: true)  // like \"aba\"\\n    }\\n\\n    private func check(_ startIndex: Int, odd: Bool) {\\n\\t\\t// Search progression example\\n\\t\\t//   s - start point\\n\\t\\t//   l - left index, start of potential palindrome\\n\\t\\t//   r - right index, end of potential palindrome\\n\\t\\t\\n        // odd  fcbaBadca      even  adSBAABSfd\\n        //         lsr                   sr\\n        //        l-s-r                 ls-r\\n        //       l--s--r               l-s--r\\n\\n        var offset = 1\\n        let oddity = (odd ? 0 : 1) // Shift `lhs` index one step to the left to find `even` palindrome.\\n        repeat {\\n\\t\\t    // Calc left and right indexes.\\n            let lhs = startIndex - offset + oddity\\n            let rhs = startIndex + offset\\n\\t\\t\\t\\n            guard 0 <= lhs, rhs < array.count,   // Check if we are still in the array.\\n                  array[lhs] == array[rhs]       // Check if side chars are equal.\\n            else { break }                       // If this is not a palindrome then break the search.\\n\\t\\t\\t\\n\\t\\t\\t// Let\\'s check if we\\'ve found a biggest palindrome then before and store it.\\n            let lenght = rhs - lhs\\n            if lenght > maxSize {\\n                maxSize = lenght\\n                bestStart = lhs\\n                bestFinish = rhs\\n            }\\n\\t\\t\\t// Increase offset for left and right index and repeat.\\n\\t\\t\\toffset += 1\\n        } while true\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 643461,
                "title": "java-dp-solution-with-clear-explanation",
                "content": "```\\nclass Solution {\\n    // Dynanmic programming solution\\n    // Time complexity O(n^2) denotes 2 the nested for loops, rest of the operations inside the forloop is just O(1)\\n    // Space complexity is O(n^2) for the table initialization\\n    // \\n    public String longestPalindrome(String s) {\\n        // base case\\n        if(s.length() == 0){\\n            return s;\\n        }\\n        \\n        \\n        // intialize a 2d table, which stores if substring of ij is a palindrome\\n        int n = s.length();\\n        boolean table[][] = new boolean[n][n];\\n        \\n        // All substrings of length 1 is palindromes\\n        int maxLength = 1;\\n        for(int i = 0; i < n; ++i) {\\n            table[i][i] = true;\\n        }\\n        \\n        // check for substrings of length 2, duplicates in this case;\\n        int start = 0;\\n        for(int i = 0; i < n - 1; i++) {\\n            if(s.charAt(i) == s.charAt(i+1)) {\\n                table[i][i+1] = true;\\n                // the start index of the longest palidrome, because there might be mutiple solution, we just keep the start index of the last longest palidrome\\n                start = i;\\n                maxLength = 2;\\n            }\\n        }\\n        \\n        // check for substrings greater than 2;\\n        for(int length = 3; length <= n; length++) {\\n            \\n            // aaaaa and we are looking for substring length 3, then the max possible index is 2, as we refer index 2 3 4;\\n            for(int i = 0; i < n -length + 1; i++) {\\n                // get the end index of the substring\\n                int j = i + length - 1;\\n                // since the table is populated for index 3 we first check if the substring(i+1, j-1) is a palindome and then if character i == chracter j;\\n                if(table[i+1][j-1] == true && s.charAt(i) == s.charAt(j)) {\\n                    table[i][j] = true;\\n                    \\n                    // we want to update maxlength to k because k is the longest palidrome \\n                    if(length > maxLength) {\\n                        maxLength = length;\\n                        start = i;\\n                    }\\n                }\\n            }\\n        }\\n        \\n        return s.substring(start, start + maxLength);\\n    }\\n\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\n    // Dynanmic programming solution\\n    // Time complexity O(n^2) denotes 2 the nested for loops, rest of the operations inside the forloop is just O(1)\\n    // Space complexity is O(n^2) for the table initialization\\n    // \\n    public String longestPalindrome(String s) {\\n        // base case\\n        if(s.length() == 0){\\n            return s;\\n        }\\n        \\n        \\n        // intialize a 2d table, which stores if substring of ij is a palindrome\\n        int n = s.length();\\n        boolean table[][] = new boolean[n][n];\\n        \\n        // All substrings of length 1 is palindromes\\n        int maxLength = 1;\\n        for(int i = 0; i < n; ++i) {\\n            table[i][i] = true;\\n        }\\n        \\n        // check for substrings of length 2, duplicates in this case;\\n        int start = 0;\\n        for(int i = 0; i < n - 1; i++) {\\n            if(s.charAt(i) == s.charAt(i+1)) {\\n                table[i][i+1] = true;\\n                // the start index of the longest palidrome, because there might be mutiple solution, we just keep the start index of the last longest palidrome\\n                start = i;\\n                maxLength = 2;\\n            }\\n        }\\n        \\n        // check for substrings greater than 2;\\n        for(int length = 3; length <= n; length++) {\\n            \\n            // aaaaa and we are looking for substring length 3, then the max possible index is 2, as we refer index 2 3 4;\\n            for(int i = 0; i < n -length + 1; i++) {\\n                // get the end index of the substring\\n                int j = i + length - 1;\\n                // since the table is populated for index 3 we first check if the substring(i+1, j-1) is a palindome and then if character i == chracter j;\\n                if(table[i+1][j-1] == true && s.charAt(i) == s.charAt(j)) {\\n                    table[i][j] = true;\\n                    \\n                    // we want to update maxlength to k because k is the longest palidrome \\n                    if(length > maxLength) {\\n                        maxLength = length;\\n                        start = i;\\n                    }\\n                }\\n            }\\n        }\\n        \\n        return s.substring(start, start + maxLength);\\n    }\\n\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 406383,
                "title": "swift-dp-solution-easy-to-understand",
                "content": "```\\nfunc longestPalindrome(_ s: String) -> String {\\n\\tguard s.count > 1 else {\\n\\t\\treturn s\\n\\t}\\n\\n\\tlet s = Array(s)\\n\\n\\tvar isPalindrome = Array(repeating: Array(repeating: false, count: s.count), count: s.count)\\n\\n\\tvar left = 0\\n\\tvar right = 0\\n\\n\\tfor j in 1..<s.count {\\n\\t\\tfor i in 0..<j {\\n\\n\\t\\t\\t// Rules\\n\\t\\t\\t// 1. If s[i] == s[j] and the length of the word is 2 or less then its a palindrome\\n\\t\\t\\t// 2. If s[i] == s[j] and the inner word is a palindrome then s[i...j] is a palindrome\\n\\t\\t\\tif s[i] == s[j] && (isPalindrome[i + 1][j - 1] || j - i <= 2) {\\n\\t\\t\\t\\tisPalindrome[i][j] = true\\n\\t\\t\\t\\tif j - i > right - left {\\n\\t\\t\\t\\t\\tleft = i\\n\\t\\t\\t\\t\\tright = j\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\n\\treturn String(s[left...right])\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nfunc longestPalindrome(_ s: String) -> String {\\n\\tguard s.count > 1 else {\\n\\t\\treturn s\\n\\t}\\n\\n\\tlet s = Array(s)\\n\\n\\tvar isPalindrome = Array(repeating: Array(repeating: false, count: s.count), count: s.count)\\n\\n\\tvar left = 0\\n\\tvar right = 0\\n\\n\\tfor j in 1..<s.count {\\n\\t\\tfor i in 0..<j {\\n\\n\\t\\t\\t// Rules\\n\\t\\t\\t// 1. If s[i] == s[j] and the length of the word is 2 or less then its a palindrome\\n\\t\\t\\t// 2. If s[i] == s[j] and the inner word is a palindrome then s[i...j] is a palindrome\\n\\t\\t\\tif s[i] == s[j] && (isPalindrome[i + 1][j - 1] || j - i <= 2) {\\n\\t\\t\\t\\tisPalindrome[i][j] = true\\n\\t\\t\\t\\tif j - i > right - left {\\n\\t\\t\\t\\t\\tleft = i\\n\\t\\t\\t\\t\\tright = j\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\n\\treturn String(s[left...right])\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 197753,
                "title": "easy-and-simple-c-4ms-no-special-case",
                "content": "No need to be complicated.\\nSame solution for all situations.\\n\\n```\\nclass Solution {\\npublic:\\n    string longestPalindrome(string s) {\\n        int maxlen = -1, start = 0;\\n        for(int i = 0;i < s.size();++i) {\\n            int left = i, right = i;\\n            while(s[right+1] == s[left]) {//Skip same char in the middle\\n                right++;\\n                i++;\\n            }\\n            while(left -1 >= 0 && right + 1 < s.size() && s[right+1] == s[left-1]) {//Handle expand\\n                left--;\\n                right++;\\n            }\\n            if(right-left+1 > maxlen) {//record max pos\\n                maxlen = right-left+1;\\n                start = left;\\n            }\\n        }\\n        return s.substr(start, maxlen);\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    string longestPalindrome(string s) {\\n        int maxlen = -1, start = 0;\\n        for(int i = 0;i < s.size();++i) {\\n            int left = i, right = i;\\n            while(s[right+1] == s[left]) {//Skip same char in the middle\\n                right++;\\n                i++;\\n            }\\n            while(left -1 >= 0 && right + 1 < s.size() && s[right+1] == s[left-1]) {//Handle expand\\n                left--;\\n                right++;\\n            }\\n            if(right-left+1 > maxlen) {//record max pos\\n                maxlen = right-left+1;\\n                start = left;\\n            }\\n        }\\n        return s.substr(start, maxlen);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3098,
                "title": "my-simple-c-solution",
                "content": "    class Solution {\\n    public:\\n    string longestPalindrome(string s) {\\n        if(s.length()==0||s.length()==1)return s;\\n        string max=\"\"+s[0];\\n        for(int i=0;i< s.length()-1; i++){\\n            string first=helper(s, i, i);\\n            if(first.length() > max.length())max=first;\\n            \\n            string second=helper(s, i, i+1);\\n            if(second.length() > max.length())max=second;\\n        }\\n        return max;\\n    }\\n    \\n    string helper(string s, int left, int right){\\n        while(left >=0 && right <s.length() && s[right]==s[left]){\\n            left--;\\n            right++;\\n        }\\n        return s.substr(left+1, right-1-left);\\n        \\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n    string longestPalindrome(string s) {\\n        if(s.length()==0||s.length()==1)return s;\\n        string max=\"\"+s[0];\\n        for(int i=0;i< s.length()-1; i++){\\n            string first=helper(s, i, i);\\n            if(first.length() > max.length())max=first;\\n            \\n            string second=helper(s, i, i+1);\\n            if(second.length() > max.length())max=second;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 3245,
                "title": "c-o-n-n-time-constant-space-and-o-n-manacher-s-algorithm",
                "content": "    \\n    string longestPalindrome(string s) {\\n        const int size_s = s.size();\\n        int max_s = 0, max_l = 0;\\n        for (int i = 0; i < size_s;) {\\n            int start = i, end = i;\\n            while (end + 1 < size_s && s[end] == s[end+1]) end++;\\n            i = end + 1;\\n            while (start - 1 >= 0 && end + 1 < size_s && s[start-1] == s[end+1]) {\\n                start--;\\n                end++;\\n            }\\n            if (end - start + 1 > max_l) {\\n                max_l = end - start + 1;\\n                max_s = start;\\n            }\\n        }\\n        return s.substr(max_s, max_l);\\n    }\\n\\n  // Manacher's Algorithm\\n\\n        string longestPalindrome(string s) {\\n        if (s.empty()) return \"\";\\n        string prep = \"#\";\\n        for (auto ch : s) { prep += ch; prep += \"#\";}\\n        const int size_p = prep.size();\\n        vector<int> dp(size_p, 0);\\n        int center = 0, bCur = 0;\\n        for (int i = 0; i < size_p; i++) {\\n            int mirror = center - (i - center);\\n            dp[i] = bCur <= i ? 0 : min(bCur - i, dp[mirror]);\\n            int start = i - dp[i], end = i + dp[i];\\n            while (start - 1 >= 0 && end + 1 < size_p && prep[start - 1] == prep[end + 1]) {\\n                --start;\\n                ++end; \\n                ++dp[i];\\n            }\\n            if (i + dp[i] > bCur) {\\n                bCur = i + dp[i];\\n                center = i;\\n            }\\n        }\\n        center = max_element(dp.begin(), dp.end()) - dp.begin();\\n        return s.substr((center - dp[center])/2, dp[center]);\\n    }",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming"
                ],
                "code": "    \\n    string longestPalindrome(string s) {\\n        const int size_s = s.size();\\n        int max_s = 0, max_l = 0;\\n        for (int i = 0; i < size_s;) {\\n            int start = i, end = i;\\n            while (end + 1 < size_s && s[end] == s[end+1]) end++;\\n            i = end + 1;\\n            while (start - 1 >= 0 && end + 1 < size_s && s[start-1] == s[end+1]) {\\n                start--;\\n                end++;\\n            }\\n            if (end - start + 1 > max_l) {\\n                max_l = end - start + 1;\\n                max_s = start;\\n            }\\n        }\\n        return s.substr(max_s, max_l);\\n    }\\n\\n  // Manacher's Algorithm\\n\\n        string longestPalindrome(string s) {\\n        if (s.empty()) return \"\";\\n        string prep = \"#\";\\n        for (auto ch : s) { prep += ch; prep += \"#\";}\\n        const int size_p = prep.size();\\n        vector<int> dp(size_p, 0);\\n        int center = 0, bCur = 0;\\n        for (int i = 0; i < size_p; i++) {\\n            int mirror = center - (i - center);\\n            dp[i] = bCur <= i ? 0 : min(bCur - i, dp[mirror]);\\n            int start = i - dp[i], end = i + dp[i];\\n            while (start - 1 >= 0 && end + 1 < size_p && prep[start - 1] == prep[end + 1]) {\\n                --start;\\n                ++end; \\n                ++dp[i];\\n            }\\n            if (i + dp[i] > bCur) {\\n                bCur = i + dp[i];\\n                center = i;\\n            }\\n        }\\n        center = max_element(dp.begin(), dp.end()) - dp.begin();\\n        return s.substr((center - dp[center])/2, dp[center]);\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 2157014,
                "title": "python-2-approaches-with-explanation",
                "content": "### Introduction\\n\\nGiven a string `s`, we want to find the longest substring in `s` that is a palindrome.\\nWe can define a palindrome to be the following: **a string with a centre position (which may or may not point to a character in the string) that has a substring `sub` on its left and the reversed substring `sub[::-1]` on its right**. Some examples are shown below:\\n\\n```text\\nOdd-length palindromes (spaced out for clarity)\\n    \"a b c d e d c b a\"   \"r a c e c a r\"\\n             ^                   ^\\n\\nEven-length palindromes (spaced out for clarity)\\n    \" a b c d d b c a\"   \"t o o t\"\\n             ^               ^\\n```\\n\\n---\\n\\n### Approach 1\\n\\nBased on the definition above, we can try to find these centre positions in substrings of `s`, since these centre positions will eventually lead us to find the longest palindromic substring. One way is to space out `s` as we did above and check each index. As we noted above, if the index points to a character, then the resulting palindrome is odd-length; if the index points to a space, then the resulting palindrome is even-length.\\n\\nWe can optimise this approach by performing both odd-length and even-length checks on the same index as we iterate through them. At index `i`, **we first assert that `s[i]` is a palindrome of length 1, and iteratively check its adjacent characters for equality until we hit the end(s) of `s`**.\\n\\n```text\\ns = \"abcdedcba\"\\n                      i = 0                 i = 1                 i = 2                 i = 3                 i = 4\\n               \"a b c d e d c b a\"   \"a b c d e d c b a\"   \"a b c d e d c b a\"   \"a b c d e d c b a\"   \"a b c d e d c b a\"\\n                ^                     # ^ #                   # ^ #                   # ^ #             ^ ^ ^ ^ ^ ^ ^ ^ ^\\npalindromes:           \"a\"                   \"b\"                   \"c\"                   \"d\"               \"abcdedcba\"\\n```\\n\\nChecking for even-length palindromes is slightly tricker; **at index `i`, we assert that the (nonexistent) index between `i-1` and `i` is a palindrome of length 0, and we perform the same iteration as described above**.\\n\\n```text\\ns = \"toot\"\\n                 i = 0       i = 1       i = 2\\n               \"t o o t\"   \"t o o t\"   \"t o o t\"\\n               ^            #^#         ^ ^^^ ^\\npalindromes:      \"\"          \"\"        \"toot\"\\n```\\n\\nAfter checking for the longest odd-length and even-length palindromes at index `i`, we store the longest found palindrome to be returned.\\n\\n```python\\nclass Solution:\\n    def longestPalindrome(self, s: str) -> str:\\n        \"\"\"\\n        Consider each character in s as the centre of a palindrome.\\n        Check for the longest possible odd-length and even-length palindrome; store the longest palindrome\\n        \"\"\"\\n        # res is the starting index of the longest palindrome\\n        # len_res is the length of the longest palindrome\\n        # len_s is the length of the given string\\n        res, len_res, len_s = 0, 0, len(s)\\n        for i in range(len_s):\\n            # check for palindromes with odd number of characters centred around s[i]\\n            # i.e., s[i] -> s[i-1:i+2] -> s[i-2:i+3] -> ...\\n            # odd is the starting index of the current palindrome with odd number of characters\\n            # len_odd is the length of the current palindrome with odd number of characters\\n            odd, len_odd = i, 1\\n            for j in range(min(i, len_s-i-1)):   # checking indexes [0, i) and [i+1, len_s); take the smaller range\\n                if s[i-j-1] != s[i+j+1]:         # if the two characters adjacent to the ends of the current palindrome are not equal,\\n                    break                        #   a longer palindrome does not exist; break out of the loop\\n                odd, len_odd = odd-1, len_odd+2  # else, a longer palindrome exists; update odd and len_odd to point to that palindrome\\n            # check for palindromes with even number of characters centred around s[i-1:i+1]\\n            # i.e., s[i-1:i+1] -> s[i-2:i+2] -> s[i-3:i+3] -> ...\\n            # even is the starting index of the current palindrome with even number of characters\\n            # len_even is the length of the current palindrome with even number of characters\\n            even, len_even = i, 0\\n            for j in range(min(i, len_s-i)):         # checking indexes [0, i) and [i, len_s); take the smaller range\\n                if s[i-j-1] != s[i+j]:               # if the two characters adjacent to the ends of the current palindrome are not equal,\\n                    break                            #   a longer palindrome does not exist; break out of the loop\\n                even, len_even = even-1, len_even+2  # else, a longer palindrome exists; update even and len_even to point to that palindrome\\n            # update res and len_res to point to the longest palindrome found so far\\n            len_res, res = max((len_res, res), (len_odd, odd), (len_even, even))\\n        return s[res:res+len_res]\\n```\\n\\n**TC: O(n<sup>2</sup>)**; in the worst case, we are iterating through the entirety of `s` in the inner for loop.\\n**SC: O(1)**; no additional data structures used.\\n\\n---\\n\\n### Approach 2: Manacher\\'s algorithm\\n\\nI happened to chance upon [this post](https://leetcode.com/problems/longest-palindromic-substring/discuss/2156882/Manacher\\'s-algorithm) that implemented the [Manacher\\'s algorithm](https://en.wikipedia.org/wiki/Longest_palindromic_substring#Manacher\\'s_algorithm), which basically makes use of DP to compute if there is a palindrome at each index.\\n\\nUnfortunately, there\\'s not much explanation I can give since I do not understand the approach too well yet. If you can explain it to me, please let me know in the comments :)\\n\\n```python\\nclass Solution:\\n    def longestPalindrome(self, s: str) -> str:\\n        \"\"\"\\n        Manacher\\'s Algorithm for longest palindromic substrings (LPS)\\n        \"\"\"\\n        # Transform S into T\\n        # For example, S = \"abba\", T = \"^#a#b#b#a#$\"\\n        # ^ and $ signs are sentinels appended to each end to avoid bounds checking\\n        T = \\'#\\'.join(\\'^{}$\\'.format(s))\\n        n = len(T)\\n        P = [0]*n\\n        C = R = 0\\n        for i in range (1, n-1):\\n            P[i] = (R > i) and min(R-i, P[2*C-i]) # equals to i\\' = C - (i-C)\\n            # Attempt to expand palindrome centered at i\\n            while T[i+1+P[i]] == T[i-1-P[i]]:\\n                P[i] += 1\\n            # If palindrome centered at i expand past R,\\n            # adjust center based on expanded palindrome\\n            if i+P[i] > R:\\n                C, R = i, i+P[i]\\n        # Find the maximum element in P\\n        maxLen, centerIndex = max((n, i) for i, n in enumerate(P))\\n        return s[(centerIndex-maxLen)//2: (centerIndex+maxLen)//2]\\n```\\n\\n**TC: O(n)**; please read the article linked above for explanation.\\n**SC: O(n)**; DP array used.\\n\\n---\\n\\nPlease upvote if this has helped you! Appreciate any comments as well :)",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```text\\nOdd-length palindromes (spaced out for clarity)\\n    \"a b c d e d c b a\"   \"r a c e c a r\"\\n             ^                   ^\\n\\nEven-length palindromes (spaced out for clarity)\\n    \" a b c d d b c a\"   \"t o o t\"\\n             ^               ^\\n```\n```text\\ns = \"abcdedcba\"\\n                      i = 0                 i = 1                 i = 2                 i = 3                 i = 4\\n               \"a b c d e d c b a\"   \"a b c d e d c b a\"   \"a b c d e d c b a\"   \"a b c d e d c b a\"   \"a b c d e d c b a\"\\n                ^                     # ^ #                   # ^ #                   # ^ #             ^ ^ ^ ^ ^ ^ ^ ^ ^\\npalindromes:           \"a\"                   \"b\"                   \"c\"                   \"d\"               \"abcdedcba\"\\n```\n```text\\ns = \"toot\"\\n                 i = 0       i = 1       i = 2\\n               \"t o o t\"   \"t o o t\"   \"t o o t\"\\n               ^            #^#         ^ ^^^ ^\\npalindromes:      \"\"          \"\"        \"toot\"\\n```\n```python\\nclass Solution:\\n    def longestPalindrome(self, s: str) -> str:\\n        \"\"\"\\n        Consider each character in s as the centre of a palindrome.\\n        Check for the longest possible odd-length and even-length palindrome; store the longest palindrome\\n        \"\"\"\\n        # res is the starting index of the longest palindrome\\n        # len_res is the length of the longest palindrome\\n        # len_s is the length of the given string\\n        res, len_res, len_s = 0, 0, len(s)\\n        for i in range(len_s):\\n            # check for palindromes with odd number of characters centred around s[i]\\n            # i.e., s[i] -> s[i-1:i+2] -> s[i-2:i+3] -> ...\\n            # odd is the starting index of the current palindrome with odd number of characters\\n            # len_odd is the length of the current palindrome with odd number of characters\\n            odd, len_odd = i, 1\\n            for j in range(min(i, len_s-i-1)):   # checking indexes [0, i) and [i+1, len_s); take the smaller range\\n                if s[i-j-1] != s[i+j+1]:         # if the two characters adjacent to the ends of the current palindrome are not equal,\\n                    break                        #   a longer palindrome does not exist; break out of the loop\\n                odd, len_odd = odd-1, len_odd+2  # else, a longer palindrome exists; update odd and len_odd to point to that palindrome\\n            # check for palindromes with even number of characters centred around s[i-1:i+1]\\n            # i.e., s[i-1:i+1] -> s[i-2:i+2] -> s[i-3:i+3] -> ...\\n            # even is the starting index of the current palindrome with even number of characters\\n            # len_even is the length of the current palindrome with even number of characters\\n            even, len_even = i, 0\\n            for j in range(min(i, len_s-i)):         # checking indexes [0, i) and [i, len_s); take the smaller range\\n                if s[i-j-1] != s[i+j]:               # if the two characters adjacent to the ends of the current palindrome are not equal,\\n                    break                            #   a longer palindrome does not exist; break out of the loop\\n                even, len_even = even-1, len_even+2  # else, a longer palindrome exists; update even and len_even to point to that palindrome\\n            # update res and len_res to point to the longest palindrome found so far\\n            len_res, res = max((len_res, res), (len_odd, odd), (len_even, even))\\n        return s[res:res+len_res]\\n```\n```python\\nclass Solution:\\n    def longestPalindrome(self, s: str) -> str:\\n        \"\"\"\\n        Manacher\\'s Algorithm for longest palindromic substrings (LPS)\\n        \"\"\"\\n        # Transform S into T\\n        # For example, S = \"abba\", T = \"^#a#b#b#a#$\"\\n        # ^ and $ signs are sentinels appended to each end to avoid bounds checking\\n        T = \\'#\\'.join(\\'^{}$\\'.format(s))\\n        n = len(T)\\n        P = [0]*n\\n        C = R = 0\\n        for i in range (1, n-1):\\n            P[i] = (R > i) and min(R-i, P[2*C-i]) # equals to i\\' = C - (i-C)\\n            # Attempt to expand palindrome centered at i\\n            while T[i+1+P[i]] == T[i-1-P[i]]:\\n                P[i] += 1\\n            # If palindrome centered at i expand past R,\\n            # adjust center based on expanded palindrome\\n            if i+P[i] > R:\\n                C, R = i, i+P[i]\\n        # Find the maximum element in P\\n        maxLen, centerIndex = max((n, i) for i, n in enumerate(P))\\n        return s[(centerIndex-maxLen)//2: (centerIndex+maxLen)//2]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1541249,
                "title": "o-n-using-an-eertree",
                "content": "Solve this problem using a Palindrome Tree, aka an EERTREE! An EERTREE works a lot like a Trie and despite being very obscure and recent, it\\'s quite elegant to solve this problem.\\n\\nSince for a string of length N there are only up to N distinct palindromes, we can represent each one as a node in a Tree.\\n\\nTaking advantage of a palindrome\\'s recursive structure, we create dictionary links to show that one palindrome is just another palindrome with 1 letter concatenated on both sides.  For example, if we had some node that represents the palindrome `\\'aba\\'` and another palindrome `\\'babab\\'`, then we could show that:\\n\\n`aba ----b----> babab`\\n\\nMore formally, the palindrome `X` has an edge labeled `c` to palindrome `Y` when `Y = cXc`.\\n\\nIn addition, you also have one suffix link for each node, which point to it\\'s longest proper suffix that is a palindrome. In other words, `ababa` would point to `aba` because that is the longest proper suffix that is also a palindrome. This is useful because if I am considering the longest palindrome ending at position `i`, I can just find the longest palindrome ending at position `i-1` and descend down the suffix links until I find a palindrome that has a `S[i]` right before it.\\n\\nFor example, let\\'s say I had the string `xabacabac` and I am trying to find the longest palindrome ending at the last character. If I know the longest palindrome ending at the character before it is `abacaba` then I just have to check the first palindrome `X` that matches `cXc`.\\n\\n`x[abacaba]c` has `x` right before it which is not equal to `c`, so I go to it\\'s next longest palindromic suffix `aba`\\n\\n`xabac[aba]c` has `c` right before it which is equal to `c` so we have found the palindrome `c[aba]c = cabac`\\n\\nAs for the initialization of our EERTREE, we have 2 nodes to handle the 1 letter and 2 letter palindrome case.\\nThere is the empty string `E` of length 0, such that `cEc = cc`\\nThere is the empty string `I` of length -1, such that `cIc = c`\\n\\nHere\\'s the paper on it:\\nhttps://arxiv.org/abs/1506.04862\\n\\nHere\\'s a helpful medium article on learning the basics of it:\\nhttps://medium.com/@alessiopiergiacomi/eertree-or-palindromic-tree-82453e75025b\\n\\n```\\nclass Node:\\n    def __init__(self, len, sfx = None):\\n        self.len = len\\n        self.sfx = sfx\\n        self.next = {}\\n        \\nclass Solution:\\n    def longestPalindrome(self, s: str) -> str:\\n        curr = empty = Node(0, Node(-1))\\n        ans_len = ans_idx = 0\\n        for i, c in enumerate(s):\\n            while i <= curr.len or s[i-1-curr.len] != c:\\n                curr = curr.sfx\\n            if c in curr.next:\\n                curr = curr.next[c]\\n                continue\\n            node = curr.next[c] = Node(curr.len+2, empty)\\n            if node.len > ans_len:\\n                ans_len, ans_idx = node.len, i-node.len+1\\n            if node.len > 1:\\n                curr = curr.sfx\\n                while i <= curr.len or s[i-1-curr.len] != c:\\n                    curr = curr.sfx\\n                node.sfx = curr.next[c]\\n            curr = node\\n        return s[ans_idx:ans_idx+ans_len]\\n```",
                "solutionTags": [
                    "Python3",
                    "Tree"
                ],
                "code": "```\\nclass Node:\\n    def __init__(self, len, sfx = None):\\n        self.len = len\\n        self.sfx = sfx\\n        self.next = {}\\n        \\nclass Solution:\\n    def longestPalindrome(self, s: str) -> str:\\n        curr = empty = Node(0, Node(-1))\\n        ans_len = ans_idx = 0\\n        for i, c in enumerate(s):\\n            while i <= curr.len or s[i-1-curr.len] != c:\\n                curr = curr.sfx\\n            if c in curr.next:\\n                curr = curr.next[c]\\n                continue\\n            node = curr.next[c] = Node(curr.len+2, empty)\\n            if node.len > ans_len:\\n                ans_len, ans_idx = node.len, i-node.len+1\\n            if node.len > 1:\\n                curr = curr.sfx\\n                while i <= curr.len or s[i-1-curr.len] != c:\\n                    curr = curr.sfx\\n                node.sfx = curr.next[c]\\n            curr = node\\n        return s[ans_idx:ans_idx+ans_len]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1243668,
                "title": "longest-palindromic-substring",
                "content": "```\\nclass Solution:\\n    def longestPalindrome(self, s: str) -> str:\\n        n = len(s)\\n        res = s[0]\\n        for i in range(1, n):\\n            # even palindrome check\\n\\t\\t\\t# example --> \\'abba\\' -> mid = right \\'b\\', left = left \\'b\\'. starting from these two positions\\n\\t\\t\\t# now keep stretching until the characters dont match. \\n\\t\\t\\t# finally check if the string got is max\\n            mid = i\\n            left = i-1\\n            while mid < n and left >=0 and s[mid] == s[left]:\\n                mid += 1\\n                left -= 1\\n            res = max(res, s[left+1:mid], key=lambda x: len(x))\\n            # odd palindrome check\\n\\t\\t\\t# example --> cabad, if i points to b, then left points to left \\'a\\' or i-1\\n\\t\\t\\t# and right points to right \\'a\\' or i+1.\\n\\t\\t\\t# now stretch until the characters dont match and find max\\n            left = i-1\\n            right = i+1\\n            while left >=0 and right < n and s[left] == s[right]:\\n                left -= 1\\n                right += 1\\n            res = max(res, s[left+1:right], key=lambda x: len(x))\\n        return res\\n            \\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def longestPalindrome(self, s: str) -> str:\\n        n = len(s)\\n        res = s[0]\\n        for i in range(1, n):\\n            # even palindrome check\\n\\t\\t\\t# example --> \\'abba\\' -> mid = right \\'b\\', left = left \\'b\\'. starting from these two positions\\n\\t\\t\\t# now keep stretching until the characters dont match. \\n\\t\\t\\t# finally check if the string got is max\\n            mid = i\\n            left = i-1\\n            while mid < n and left >=0 and s[mid] == s[left]:\\n                mid += 1\\n                left -= 1\\n            res = max(res, s[left+1:mid], key=lambda x: len(x))\\n            # odd palindrome check\\n\\t\\t\\t# example --> cabad, if i points to b, then left points to left \\'a\\' or i-1\\n\\t\\t\\t# and right points to right \\'a\\' or i+1.\\n\\t\\t\\t# now stretch until the characters dont match and find max\\n            left = i-1\\n            right = i+1\\n            while left >=0 and right < n and s[left] == s[right]:\\n                left -= 1\\n                right += 1\\n            res = max(res, s[left+1:right], key=lambda x: len(x))\\n        return res\\n            \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1124502,
                "title": "faster-than-92-45-12ms-memory-less-than-95-26-o-n-2-longest-palindromic-substring",
                "content": "Dear All,\\n\\nPlease find below my best solution of Longest Palindromic Substring. \\nHere we have O(n^2) Time Complexity and no extra memory required except several variables.\\nSolution contains comments with some test cases for your better understanding of algorithm.\\n```\\nclass Solution \\n{\\nprivate:\\n    int getPalindromLength(string& s, int left, int right)\\n    {\\n        // Move left and right bounds only while they within string size and characters of both are equal\\n        while( left >= 0 && right < s.length() && s[left] == s[right] )\\n        {\\n            --left;\\n            ++right;\\n        }\\n        // Return length between left and right bounds\\n        return right - left - 1;\\n    }\\npublic:\\n    string longestPalindrome(string s) \\n    {   \\n        // In case string contain only one character - this is a Palindrome\\n        if(s.length() == 1) { return s; }\\n        \\n        // Left and right bounds - between them Palindrom located\\n        int leftIndex, rightIndex;\\n        leftIndex = rightIndex = 0;\\n        \\n        // Imagine that each character is a middle of Palindrome and checking neighbors to find max length\\n        for(int i = 0; i < s.length(); ++i )\\n        {\\n            // Count length for current index\\n            int currentLength = getPalindromLength(s, i, i);\\n            // Count length for current-next index - required for pair characters( example: \"aa\", \"baa\", \"baac\" )\\n            int pairLength = getPalindromLength(s, i, i+1);\\n            // Take current max length between previous two\\n            int maxLength = currentLength >= pairLength ? currentLength : pairLength;\\n            // Only if maxLength more than previous found length - update left and right bounds\\n            if ( maxLength > rightIndex - leftIndex )\\n            {\\n                // Left bound - from current index(because it\\'s middle of Palindrome) deduct (found length - 1) / 2\\n                // TestCase1: current index 3, length = 5. 3 - (5-1)/2 = 3 - 2 = 1. Since 3 is a middle, left bound should be two positions back\\n                // TestCase2: current index 6, length = 4. 6 - (4-1)/2 = 6 - 1 = 5. Since 6 is a middle, left bound should be one positions back\\n                leftIndex = i - (maxLength - 1) / 2;\\n                // Right bound - to current index(because it\\'s middle of Palindrome) add found length / 2\\n                // TestCase1: current index 3, length = 5. 3 + 5/2 = 3 + 2 = 5. Since 3 is a middle, right bound should be two positions ahead\\n                // TestCase2: current index 6, length = 4. 6 + 4/2 = 6 + 2 = 8. Since 6 is a middle, right bound should be two positions ahead\\n                rightIndex = i + maxLength / 2;\\n                // TestCase1: leftIndex = 1, rightIndex = 5. Between those bounds Palindrome located\\n                // TestCase2: leftIndex = 5, rightIndex = 8. Between those bounds Palindrome located\\n            }\\n        }\\n        \\n        // Return Palindrome. substr first parameter indicates from which position starts, second parameter indicates how many characters take\\n        // TestCase1: substr(1, 5) - from index 1 take 5 characters\\n        // TestCase2: substr(5, 4) - from index 5 take 4 characters\\n        return s.substr(leftIndex, rightIndex - leftIndex + 1);\\n    }\\n};\\n```\\n\\nPlease find below my first brute force solution with terrible Time and Space complexity but very easy to understand and probably will help you to have clear picture how issue can be solved. As in previous code containes comments for your better understanding.\\n```\\nclass Solution \\n{\\npublic:\\n    string longestPalindrome(string s) \\n    {   \\n        if(s.length() == 1) { return s; }\\n        // Result string\\n        string palindrome = \"\";\\n        \\n        // Loop by left bound\\n        for(int left = 0; left < s.length(); ++left)\\n        {\\n            // Loop by right bound - from the end of string till face same character as at left bound index\\n            for(int right = s.length() - 1; right > left; --right )\\n            {\\n                // Continue only if characters at current left and right are equal AND current palindrome less then possible next\\n                if( s[left] == s[right] && ( right - left + 1 > palindrome.length() ) )\\n                {\\n                    // Put substring from left to right - second parameter shows how many character should be takken\\n                    string tempPalindrome = s.substr(left, right - left + 1);\\n                    // Create reversed string from substring. rbegin() - reverse iterator and indicates to last character, rend() - indicates to first.\\n                    string reversed(tempPalindrome.rbegin(), tempPalindrome.rend());\\n                    // If substring and reversed string of substring is equal - substring is a polindome\\n                    if(tempPalindrome == reversed)\\n                    {\\n                        palindrome = tempPalindrome;\\n                    }\\n                }\\n            }\\n        }\\n        \\n        // If Palindromes haven\\'t found yet - return first character\\n        if(palindrome.length() == 0) { palindrome = s[0]; }\\n        return palindrome;\\n        \\n    }\\n};\\n```\\n\\nIf we will compare two solution we will see huge time and space difference:\\nBest solution:\\nRuntime: 12 ms\\nMemory Usage: 6.9 MB\\n\\nBrute force solution:\\nRuntime: 1616 ms\\nMemory Usage: 637.5 MB\\n\\nThis once again proves the importance of choosing an efficient algorithm =)\\n\\nIf you know how to improve the code(Besides Manacher\\'s Algorithm) - please let me know I will be very grateful.\\nIf you like solution please vote - I will be pleased.\\n\\nThanks and have a good day.\\n\\nBest Regards, Yevhen.",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution \\n{\\nprivate:\\n    int getPalindromLength(string& s, int left, int right)\\n    {\\n        // Move left and right bounds only while they within string size and characters of both are equal\\n        while( left >= 0 && right < s.length() && s[left] == s[right] )\\n        {\\n            --left;\\n            ++right;\\n        }\\n        // Return length between left and right bounds\\n        return right - left - 1;\\n    }\\npublic:\\n    string longestPalindrome(string s) \\n    {   \\n        // In case string contain only one character - this is a Palindrome\\n        if(s.length() == 1) { return s; }\\n        \\n        // Left and right bounds - between them Palindrom located\\n        int leftIndex, rightIndex;\\n        leftIndex = rightIndex = 0;\\n        \\n        // Imagine that each character is a middle of Palindrome and checking neighbors to find max length\\n        for(int i = 0; i < s.length(); ++i )\\n        {\\n            // Count length for current index\\n            int currentLength = getPalindromLength(s, i, i);\\n            // Count length for current-next index - required for pair characters( example: \"aa\", \"baa\", \"baac\" )\\n            int pairLength = getPalindromLength(s, i, i+1);\\n            // Take current max length between previous two\\n            int maxLength = currentLength >= pairLength ? currentLength : pairLength;\\n            // Only if maxLength more than previous found length - update left and right bounds\\n            if ( maxLength > rightIndex - leftIndex )\\n            {\\n                // Left bound - from current index(because it\\'s middle of Palindrome) deduct (found length - 1) / 2\\n                // TestCase1: current index 3, length = 5. 3 - (5-1)/2 = 3 - 2 = 1. Since 3 is a middle, left bound should be two positions back\\n                // TestCase2: current index 6, length = 4. 6 - (4-1)/2 = 6 - 1 = 5. Since 6 is a middle, left bound should be one positions back\\n                leftIndex = i - (maxLength - 1) / 2;\\n                // Right bound - to current index(because it\\'s middle of Palindrome) add found length / 2\\n                // TestCase1: current index 3, length = 5. 3 + 5/2 = 3 + 2 = 5. Since 3 is a middle, right bound should be two positions ahead\\n                // TestCase2: current index 6, length = 4. 6 + 4/2 = 6 + 2 = 8. Since 6 is a middle, right bound should be two positions ahead\\n                rightIndex = i + maxLength / 2;\\n                // TestCase1: leftIndex = 1, rightIndex = 5. Between those bounds Palindrome located\\n                // TestCase2: leftIndex = 5, rightIndex = 8. Between those bounds Palindrome located\\n            }\\n        }\\n        \\n        // Return Palindrome. substr first parameter indicates from which position starts, second parameter indicates how many characters take\\n        // TestCase1: substr(1, 5) - from index 1 take 5 characters\\n        // TestCase2: substr(5, 4) - from index 5 take 4 characters\\n        return s.substr(leftIndex, rightIndex - leftIndex + 1);\\n    }\\n};\\n```\n```\\nclass Solution \\n{\\npublic:\\n    string longestPalindrome(string s) \\n    {   \\n        if(s.length() == 1) { return s; }\\n        // Result string\\n        string palindrome = \"\";\\n        \\n        // Loop by left bound\\n        for(int left = 0; left < s.length(); ++left)\\n        {\\n            // Loop by right bound - from the end of string till face same character as at left bound index\\n            for(int right = s.length() - 1; right > left; --right )\\n            {\\n                // Continue only if characters at current left and right are equal AND current palindrome less then possible next\\n                if( s[left] == s[right] && ( right - left + 1 > palindrome.length() ) )\\n                {\\n                    // Put substring from left to right - second parameter shows how many character should be takken\\n                    string tempPalindrome = s.substr(left, right - left + 1);\\n                    // Create reversed string from substring. rbegin() - reverse iterator and indicates to last character, rend() - indicates to first.\\n                    string reversed(tempPalindrome.rbegin(), tempPalindrome.rend());\\n                    // If substring and reversed string of substring is equal - substring is a polindome\\n                    if(tempPalindrome == reversed)\\n                    {\\n                        palindrome = tempPalindrome;\\n                    }\\n                }\\n            }\\n        }\\n        \\n        // If Palindromes haven\\'t found yet - return first character\\n        if(palindrome.length() == 0) { palindrome = s[0]; }\\n        return palindrome;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 753169,
                "title": "evolve-from-brute-force-to-dp",
                "content": "1. Brute force O(n^3). Iterate from long substring to short substring and terminate on first palindrome. For length i, the start index includes until n-i. Ex, for length n, we start at 0.\\n```\\n\\tpublic String longestPalindrome(String s) {\\n        int n=s.length();\\n        for(int i=n;i>0;i--) \\n\\t\\t\\tfor(int j=0;j<=n-i;j++) \\n\\t\\t\\t\\tif(isPal(j,i+j-1,s)) \\n\\t\\t\\t\\t\\treturn s.substring(j,j+i); \\n        return \"\";\\n    }\\n    private boolean isPal(int i, int j, String s) {\\n        if(i>=j) return true;\\n        return s.charAt(i)==s.charAt(j)&&isPal(i+1,j-1,s);\\n    }\\n```\\n2. Memoization O(n^2). There are n^2 substrings. It takes O(n^2) for isPal() to check palindrome and cache it for all substrings. mem[][] should be filled in the middle of the for loop. Then isPal becomes constant. There are n^2 calls to isPal.\\n```\\n\\tpublic String longestPalindrome(String s) {\\n        int n=s.length();\\n        Boolean[][] mem=new Boolean[n][n];\\n        for(int i=n;i>0;i--) for(int j=0;j<=n-i;j++) if(isPal(j,i+j-1,s,mem)) return s.substring(j,j+i); \\n        return \"\";\\n    }\\n    private boolean isPal(int i, int j, String s, Boolean[][] mem) {\\n        if(i>=j) return true;\\n        if(mem[i][j]!=null) return mem[i][j];\\n        return mem[i][j]=s.charAt(i)==s.charAt(j)&&isPal(i+1,j-1,s,mem);\\n    }\\n```\\n3. dp O(n^2)\\n```\\n\\tpublic String longestPalindrome(String s) {\\n        int n=s.length(),len=1,start=0;\\n        boolean[][] isPal=new boolean[n][n];\\n        for(int i=0;i<n;i++) isPal[i][i]=true;\\n        for(int l=2;l<=n;l++) \\n            for(int i=0;i<=n-l;i++) {\\n                int j=i+l-1;\\n                isPal[i][j]=s.charAt(i)==s.charAt(j)&&(l<3||isPal[i+1][j-1]); \\n                if(l>len&&isPal[i][j]) {\\n                    len=l;\\n                    start=i;\\n                }\\n            }\\n        return s.substring(start,start+len);\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n\\tpublic String longestPalindrome(String s) {\\n        int n=s.length();\\n        for(int i=n;i>0;i--) \\n\\t\\t\\tfor(int j=0;j<=n-i;j++) \\n\\t\\t\\t\\tif(isPal(j,i+j-1,s)) \\n\\t\\t\\t\\t\\treturn s.substring(j,j+i); \\n        return \"\";\\n    }\\n    private boolean isPal(int i, int j, String s) {\\n        if(i>=j) return true;\\n        return s.charAt(i)==s.charAt(j)&&isPal(i+1,j-1,s);\\n    }\\n```\n```\\n\\tpublic String longestPalindrome(String s) {\\n        int n=s.length();\\n        Boolean[][] mem=new Boolean[n][n];\\n        for(int i=n;i>0;i--) for(int j=0;j<=n-i;j++) if(isPal(j,i+j-1,s,mem)) return s.substring(j,j+i); \\n        return \"\";\\n    }\\n    private boolean isPal(int i, int j, String s, Boolean[][] mem) {\\n        if(i>=j) return true;\\n        if(mem[i][j]!=null) return mem[i][j];\\n        return mem[i][j]=s.charAt(i)==s.charAt(j)&&isPal(i+1,j-1,s,mem);\\n    }\\n```\n```\\n\\tpublic String longestPalindrome(String s) {\\n        int n=s.length(),len=1,start=0;\\n        boolean[][] isPal=new boolean[n][n];\\n        for(int i=0;i<n;i++) isPal[i][i]=true;\\n        for(int l=2;l<=n;l++) \\n            for(int i=0;i<=n-l;i++) {\\n                int j=i+l-1;\\n                isPal[i][j]=s.charAt(i)==s.charAt(j)&&(l<3||isPal[i+1][j-1]); \\n                if(l>len&&isPal[i][j]) {\\n                    len=l;\\n                    start=i;\\n                }\\n            }\\n        return s.substring(start,start+len);\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 614215,
                "title": "0ms-solution-in-go",
                "content": "```\\nfunc longestPalindrome(s string) string {\\n\\tll := len(s)\\n\\tif ll == 0 {\\n\\t\\treturn \"\"\\n\\t}\\n\\n\\tvar l, r, pl, pr int\\n\\tfor r < ll {\\n\\t\\t// gobble up dup chars\\n\\t\\tfor r+1 < ll && s[l] == s[r+1] {\\n\\t\\t\\tr++\\n\\t\\t}\\n\\t\\t// find size of this palindrome\\n\\t\\tfor l-1 >= 0 && r+1 < ll && s[l-1] == s[r+1] {\\n\\t\\t\\tl--\\n\\t\\t\\tr++\\n\\t\\t}\\n\\t\\tif r-l > pr-pl {\\n\\t\\t\\tpl, pr = l, r\\n\\t\\t}\\n\\t\\t// reset to next mid point\\n\\t\\tl = (l+r)/2 + 1\\n\\t\\tr = l\\n\\t}\\n\\treturn s[pl : pr+1]\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc longestPalindrome(s string) string {\\n\\tll := len(s)\\n\\tif ll == 0 {\\n\\t\\treturn \"\"\\n\\t}\\n\\n\\tvar l, r, pl, pr int\\n\\tfor r < ll {\\n\\t\\t// gobble up dup chars\\n\\t\\tfor r+1 < ll && s[l] == s[r+1] {\\n\\t\\t\\tr++\\n\\t\\t}\\n\\t\\t// find size of this palindrome\\n\\t\\tfor l-1 >= 0 && r+1 < ll && s[l-1] == s[r+1] {\\n\\t\\t\\tl--\\n\\t\\t\\tr++\\n\\t\\t}\\n\\t\\tif r-l > pr-pl {\\n\\t\\t\\tpl, pr = l, r\\n\\t\\t}\\n\\t\\t// reset to next mid point\\n\\t\\tl = (l+r)/2 + 1\\n\\t\\tr = l\\n\\t}\\n\\treturn s[pl : pr+1]\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 571191,
                "title": "javascript-98-faster",
                "content": "## Solution 1\\n```javascript\\nvar longestPalindrome = function(s) {\\n    let maxSub = \\'\\';\\n    \\n    const bubbleFromCenter = (left, right) => {\\n        while(left >= 0 && right < s.length && s[left] === s[right]) {\\n            left--;\\n            right++;\\n        }\\n        return s.slice(left+1, right)\\n    }\\n    \\n    for(let i = 0; i < s.length; i++) {\\n        const sub1 = bubbleFromCenter(i, i);\\n        const sub2 = bubbleFromCenter(i, i+1);\\n        const sub = sub1.length > sub2.length ? sub1 : sub2\\n        if(sub.length > maxSub.length) {\\n            maxSub = sub\\n        }\\n    }\\n    return maxSub\\n};\\n```\\n\\n## Solution 2: Cleaned up\\n```javascript\\nvar longestPalindrome = function(s) {\\n    let maxPal = \\'\\';\\n    \\n    for(let i = 0; i < s.length; i++) {\\n        bubble(i, i); // odd palindrome\\n        bubble(i, i+1); // even palindrome\\n    }\\n    \\n    function bubble(left, right) {\\n\\n        while(left >= 0 && s[left] === s[right]) {\\n            left--;\\n            right++;\\n        }\\n        left++;\\n        right--;\\n        \\n        if(maxPal.length < right-left+1) {\\n            maxPal = s.slice(left, right+1)\\n        }\\n    }\\n    return maxPal;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```javascript\\nvar longestPalindrome = function(s) {\\n    let maxSub = \\'\\';\\n    \\n    const bubbleFromCenter = (left, right) => {\\n        while(left >= 0 && right < s.length && s[left] === s[right]) {\\n            left--;\\n            right++;\\n        }\\n        return s.slice(left+1, right)\\n    }\\n    \\n    for(let i = 0; i < s.length; i++) {\\n        const sub1 = bubbleFromCenter(i, i);\\n        const sub2 = bubbleFromCenter(i, i+1);\\n        const sub = sub1.length > sub2.length ? sub1 : sub2\\n        if(sub.length > maxSub.length) {\\n            maxSub = sub\\n        }\\n    }\\n    return maxSub\\n};\\n```\n```javascript\\nvar longestPalindrome = function(s) {\\n    let maxPal = \\'\\';\\n    \\n    for(let i = 0; i < s.length; i++) {\\n        bubble(i, i); // odd palindrome\\n        bubble(i, i+1); // even palindrome\\n    }\\n    \\n    function bubble(left, right) {\\n\\n        while(left >= 0 && s[left] === s[right]) {\\n            left--;\\n            right++;\\n        }\\n        left++;\\n        right--;\\n        \\n        if(maxPal.length < right-left+1) {\\n            maxPal = s.slice(left, right+1)\\n        }\\n    }\\n    return maxPal;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 309720,
                "title": "python-dp",
                "content": "```\\nclass Solution(object):\\n    def longestPalindrome(self, s):\\n        \"\"\"\\n        :type s: str\\n        :rtype: str\\n        \"\"\"\\n        if not s or len(s) == 0:\\n            return \\'\\'\\n        \\n        n = len(s)\\n        dp = [[False for i in range(n)] for j in range(n)]\\n        for i in range(n):\\n            dp[i][i] = True\\n        ans = s[0:1]\\n        for i in range(n):\\n            for j in range(i-1, -1, -1):\\n                if s[i] == s[j] and (i-j<2 or dp[j+1][i-1]):\\n                    dp[j][i] = True\\n                    if i - j + 1 > len(ans):\\n                        ans = s[j:i+1]\\n        return ans\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def longestPalindrome(self, s):\\n        \"\"\"\\n        :type s: str\\n        :rtype: str\\n        \"\"\"\\n        if not s or len(s) == 0:\\n            return \\'\\'\\n        \\n        n = len(s)\\n        dp = [[False for i in range(n)] for j in range(n)]\\n        for i in range(n):\\n            dp[i][i] = True\\n        ans = s[0:1]\\n        for i in range(n):\\n            for j in range(i-1, -1, -1):\\n                if s[i] == s[j] and (i-j<2 or dp[j+1][i-1]):\\n                    dp[j][i] = True\\n                    if i - j + 1 > len(ans):\\n                        ans = s[j:i+1]\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 157861,
                "title": "python3-dp-solution-with-lots-of-comments",
                "content": "Not the most efficient algorithm to this problem, but great for understanding dynamic programming concepts :)\\n`        \\n        # Edge case: Given empty string\\n       str_len = len(s)\\n\\t\\t\\t if str_len == 0:\\n            return \"\"\\n                \\n        # Initialize DP table (dimensions: str_len x str_len)\\n        memo = [[0 for i in range(str_len)] for j in range(str_len)]\\n        \\n        start = 0 # Starting index of the longest palindrome\\n        max_len = 1 # Length of the longest palindrome\\n        \\n        # Fill DP table for single char palindromes\\n        for i in range(str_len):\\n            memo[i][i] = True\\n            \\n        # Fill DP table for 2 char long palindromes\\n        for i in range(str_len - 1):\\n            j = i + 1\\n            if s[i] == s[j]:\\n                memo[i][j] = True\\n                start = i\\n                max_len = 2\\n            else:\\n                memo[i][j] = False\\n        \\n        \\n        # Fill DP table for palindromes of every other length\\n        # starting from 3\\n        length = 3\\n        while length <= str_len:\\n            for i in range(str_len - 2):\\n                j = i + (length - 1)\\n                if j < str_len: # if calculated j is a valid value\\n                    if s[i] == s[j] and memo[i+1][j-1]:\\n                        memo[i][j] = True\\n                        start = i\\n                        max_len = length\\n                    else:\\n                        memo[i][j] = False\\n            length += 1\\n        \\n        solution = s[start: start + max_len]\\n        \\n        return solution\\n`",
                "solutionTags": [],
                "code": "Not the most efficient algorithm to this problem, but great for understanding dynamic programming concepts :)\\n`        \\n        # Edge case: Given empty string\\n       str_len = len(s)\\n\\t\\t\\t if str_len == 0:\\n            return \"\"\\n                \\n        # Initialize DP table (dimensions: str_len x str_len)\\n        memo = [[0 for i in range(str_len)] for j in range(str_len)]\\n        \\n        start = 0 # Starting index of the longest palindrome\\n        max_len = 1 # Length of the longest palindrome\\n        \\n        # Fill DP table for single char palindromes\\n        for i in range(str_len):\\n            memo[i][i] = True\\n            \\n        # Fill DP table for 2 char long palindromes\\n        for i in range(str_len - 1):\\n            j = i + 1\\n            if s[i] == s[j]:\\n                memo[i][j] = True\\n                start = i\\n                max_len = 2\\n            else:\\n                memo[i][j] = False\\n        \\n        \\n        # Fill DP table for palindromes of every other length\\n        # starting from 3\\n        length = 3\\n        while length <= str_len:\\n            for i in range(str_len - 2):\\n                j = i + (length - 1)\\n                if j < str_len: # if calculated j is a valid value\\n                    if s[i] == s[j] and memo[i+1][j-1]:\\n                        memo[i][j] = True\\n                        start = i\\n                        max_len = length\\n                    else:\\n                        memo[i][j] = False\\n            length += 1\\n        \\n        solution = s[start: start + max_len]\\n        \\n        return solution\\n`",
                "codeTag": "Unknown"
            },
            {
                "id": 3109163,
                "title": "easily-understandable-solution-beats-90-83",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n   \\npublic:\\n    string longestPalindrome(string s) {\\n         if(s.length()<=1){\\n        return s;\\n    }\\n        int max_length=1;\\n        int n=s.length();\\n        int st=0, en=0;\\n        for(int i=0;i<n-1;i++){\\n            int l=i ,r=i;\\n            while(l>=0 && r<n){\\n                if(s[l]==s[r]){\\n                    l--;r++;\\n                }else{break;}\\n                    \\n            }\\n            int len=r-l-1;\\n            if(len>max_length){\\n                max_length=len;\\n                st=l+1;\\n                en=r-1;   \\n            }\\n        }\\n        for(int i=0;i<n-1;i++){\\n            int l=i ,r=i+1;\\n            while(l>=0 && r<n){\\n                if(s[l]==s[r]){\\n                    l--;r++;\\n                }else{break;}\\n                    \\n            }\\n            int len=r-l-1;\\n            if(len>max_length){\\n                max_length=len;\\n                st=l+1;\\n                en=r-1;            \\n            }\\n        }\\n        cout<<st<<\" \"<<en<<\" \"<<max_length;\\n        return s.substr(st,max_length);\\n    }\\n};\\n```\\nPlease upvote to motivate me to write more solutions",
                "solutionTags": [
                    "C++",
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n   \\npublic:\\n    string longestPalindrome(string s) {\\n         if(s.length()<=1){\\n        return s;\\n    }\\n        int max_length=1;\\n        int n=s.length();\\n        int st=0, en=0;\\n        for(int i=0;i<n-1;i++){\\n            int l=i ,r=i;\\n            while(l>=0 && r<n){\\n                if(s[l]==s[r]){\\n                    l--;r++;\\n                }else{break;}\\n                    \\n            }\\n            int len=r-l-1;\\n            if(len>max_length){\\n                max_length=len;\\n                st=l+1;\\n                en=r-1;   \\n            }\\n        }\\n        for(int i=0;i<n-1;i++){\\n            int l=i ,r=i+1;\\n            while(l>=0 && r<n){\\n                if(s[l]==s[r]){\\n                    l--;r++;\\n                }else{break;}\\n                    \\n            }\\n            int len=r-l-1;\\n            if(len>max_length){\\n                max_length=len;\\n                st=l+1;\\n                en=r-1;            \\n            }\\n        }\\n        cout<<st<<\" \"<<en<<\" \"<<max_length;\\n        return s.substr(st,max_length);\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 1566634,
                "title": "ruby-solution-that-times-out-but-i-don-t-care",
                "content": "Heres my solution. It times out but more and more I believe leetcode is just not for ruby. The only ruby solution I saw on here that passes is so unreadable it makes my eyebsalls bleed which, I feel, defeats the purpose of using ruby.\\n```\\ndef longest_palindrome(s)\\n    return s if palindrome?(s)\\n    \\n    s.size.downto(1).each do |x|\\n        (0..s.size-x).each do |q|\\n            str = s[q..q+x-1]\\n            return str if palindrome?(str)\\n        end\\n    end    \\nend\\n\\ndef palindrome?(s)\\n    return s.reverse == s\\nend\\n```",
                "solutionTags": [
                    "Ruby"
                ],
                "code": "```\\ndef longest_palindrome(s)\\n    return s if palindrome?(s)\\n    \\n    s.size.downto(1).each do |x|\\n        (0..s.size-x).each do |q|\\n            str = s[q..q+x-1]\\n            return str if palindrome?(str)\\n        end\\n    end    \\nend\\n\\ndef palindrome?(s)\\n    return s.reverse == s\\nend\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1338509,
                "title": "python-two-pointer-easy2understand-solution",
                "content": "\\n    def longestPalindrome(self, s: str) -> str:\\n        # init res\\n        res = \"\"\\n        \\n        for i in range(len(s)):\\n            \\n            # odd -> helper, update\\n            tmp = self.helper(i, i, s)\\n            if len(res) < len(tmp):\\n                res = tmp\\n                \\n            # even -> helper, update\\n            tmp = self.helper(i, i + 1, s)\\n            if len(res) < len(tmp):\\n                res = tmp\\n        \\n        # return res\\n        return res\\n        \\n    def helper(self, l, r, s):\\n        \\n        # if inbound and palindrome, move left left and right right\\n        while (l >= 0 and r < len(s) and s[l] == s[r]):\\n            l -= 1\\n            r += 1\\n            \\n        # return \\n        return s[l + 1: r]",
                "solutionTags": [
                    "Python",
                    "Two Pointers"
                ],
                "code": "\\n    def longestPalindrome(self, s: str) -> str:\\n        # init res\\n        res = \"\"\\n        \\n        for i in range(len(s)):\\n            \\n            # odd -> helper, update\\n            tmp = self.helper(i, i, s)\\n            if len(res) < len(tmp):\\n                res = tmp\\n                \\n            # even -> helper, update\\n            tmp = self.helper(i, i + 1, s)\\n            if len(res) < len(tmp):\\n                res = tmp\\n        \\n        # return res\\n        return res\\n        \\n    def helper(self, l, r, s):\\n        \\n        # if inbound and palindrome, move left left and right right\\n        while (l >= 0 and r < len(s) and s[l] == s[r]):\\n            l -= 1\\n            r += 1\\n            \\n        # return \\n        return s[l + 1: r]",
                "codeTag": "Python3"
            },
            {
                "id": 1177813,
                "title": "python-solution",
                "content": "```\\n\\ttemp = \\'\\'\\n\\tmaxp = \\'\\'\\n\\n\\tfor i in range(len(s)):\\n\\t\\ttemp += s[i]\\n\\t\\tfor j in range(len(temp)):\\n\\t\\t\\tif temp[j] == s[i] and s[j:i+1] == s[j:i+1][::-1] and len(s[j:i+1]) > len(maxp):\\n\\t\\t\\t\\tmaxp = s[j:i+1]\\n\\t\\t\\t\\tbreak\\n\\n\\treturn maxp\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\n\\ttemp = \\'\\'\\n\\tmaxp = \\'\\'\\n\\n\\tfor i in range(len(s)):\\n\\t\\ttemp += s[i]\\n\\t\\tfor j in range(len(temp)):\\n\\t\\t\\tif temp[j] == s[i] and s[j:i+1] == s[j:i+1][::-1] and len(s[j:i+1]) > len(maxp):\\n\\t\\t\\t\\tmaxp = s[j:i+1]\\n\\t\\t\\t\\tbreak\\n\\n\\treturn maxp\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 291864,
                "title": "js-solution",
                "content": "Leetcode - Longest palindromic substring\\n(1) for each 1 unit or 2 units, we expand\\n(2) we judge whether the expanded two chars are the same\\n(3) if the expanded chars are the same, we expand again\\n(4) else we calculate the length by (right - left - 1), and compare it with the current max\\n\\n```\\n\\n\\nvar longestPalindrome = function(s) {\\n    var str = \\'\\';\\n    for (let i = 0; i < s.length; i++) {\\n        for (let j = 0; j < 2; j++) {\\n            var left = i;\\n            var right = left + j;\\n            while (s[left] && s[left] === s[right]) {\\n                left--;\\n                right++;\\n            }\\n            if (right - left - 1 > str.length) {\\n                str = s.slice(left + 1, right);\\n            }\\n        }\\n    }\\n    return str;\\n};\\n\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n\\n\\nvar longestPalindrome = function(s) {\\n    var str = \\'\\';\\n    for (let i = 0; i < s.length; i++) {\\n        for (let j = 0; j < 2; j++) {\\n            var left = i;\\n            var right = left + j;\\n            while (s[left] && s[left] === s[right]) {\\n                left--;\\n                right++;\\n            }\\n            if (right - left - 1 > str.length) {\\n                str = s.slice(left + 1, right);\\n            }\\n        }\\n    }\\n    return str;\\n};\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2781660,
                "title": "two-pointer-approach-java-solution",
                "content": "```\\nclass Solution {\\n    public String longestPalindrome(String s) {\\n        //Approach : treat each character as mid of the palindromic string and check if its left and right character are same or not if they are same then decrement left and increment right and after checking it for each charater determine maximum length which is maximum length of palindromic string \\n        // To get palindromic substring return substring from start to start + maximum length\\n        int n = s.length();\\n        if(n <= 1) return s;\\n        int maxLen = 1;\\n        int start = 0;\\n        //for odd length \\n        for(int i=0;i<n;i++){\\n            int l = i;\\n            int r = i;\\n            while(l >= 0 && r < n && s.charAt(l) == s.charAt(r)){\\n                l--;\\n                r++;\\n            }\\n            int len = r-l-1;\\n            if(len > maxLen){\\n                maxLen = len;\\n                start = l+1;\\n            }\\n        }\\n        //for Even length \\n        for(int i=0;i<n;i++){\\n            int l = i;\\n            int r = i+1;\\n            while(l >= 0 && r<n && s.charAt(l) == s.charAt(r)){\\n                l--;\\n                r++;\\n            }\\n            int len = r-l-1;\\n            if(len > maxLen){\\n                maxLen = len;\\n                start = l+1;\\n            }\\n        }\\n        return s.substring(start,start+maxLen);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public String longestPalindrome(String s) {\\n        //Approach : treat each character as mid of the palindromic string and check if its left and right character are same or not if they are same then decrement left and increment right and after checking it for each charater determine maximum length which is maximum length of palindromic string \\n        // To get palindromic substring return substring from start to start + maximum length\\n        int n = s.length();\\n        if(n <= 1) return s;\\n        int maxLen = 1;\\n        int start = 0;\\n        //for odd length \\n        for(int i=0;i<n;i++){\\n            int l = i;\\n            int r = i;\\n            while(l >= 0 && r < n && s.charAt(l) == s.charAt(r)){\\n                l--;\\n                r++;\\n            }\\n            int len = r-l-1;\\n            if(len > maxLen){\\n                maxLen = len;\\n                start = l+1;\\n            }\\n        }\\n        //for Even length \\n        for(int i=0;i<n;i++){\\n            int l = i;\\n            int r = i+1;\\n            while(l >= 0 && r<n && s.charAt(l) == s.charAt(r)){\\n                l--;\\n                r++;\\n            }\\n            int len = r-l-1;\\n            if(len > maxLen){\\n                maxLen = len;\\n                start = l+1;\\n            }\\n        }\\n        return s.substring(start,start+maxLen);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2157058,
                "title": "c-easy-to-understand-explained-have-a-look",
                "content": "**Dekho for every possible substring we will check for the pallindrome and the largest substring will be our ans...**\\n\\n\\nclass Solution {\\npublic:\\n      \\n\\t  // dp vector for memoization\\n      vector<vector<int>>dp;\\n    \\n\\t//function to check for pallindrome\\n    int ispalli(string &s,int i,int j)\\n    {\\n      if(i>=j)\\n      {\\n          return 1;\\n      }\\n        if(dp[i][j]!=-1)\\n        {\\n            return dp[i][j];\\n        }\\n        if(s[i]==s[j])\\n        {\\n            return dp[i][j]=ispalli(s,i+1,j-1);\\n        }\\n        return dp[i][j]= 0;\\n    }\\n    string longestPalindrome(string  s) {\\n        int n=s.length();\\n        int mx=0;\\n        string ans; // storing ans\\n\\t\\t//resizing our dp\\n        dp.resize(n,vector<int>(n,-1));\\n        for(int i=0;i<n;++i)\\n        {\\n            for(int j=i;j<n;++j)\\n            { \\n\\t\\t\\t//if string from i to j is  a pallindrome and its length is max so then just store it as ans\\n\\t\\t\\t\\n                if(ispalli(s,i,j))\\n                {\\n                    if(j-i+1>mx)\\n                    {\\n                        mx=j-i+1;\\n                        ans=s.substr(i,j-i+1);\\n                    }\\n                }\\n            }\\n        }\\n        return ans; //just return the ans\\n    }\\n};\\n**Kindly Upvote if it helped**",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Recursion"
                ],
                "code": "class Solution {\\npublic:\\n      \\n\\t  // dp vector for memoization\\n      vector<vector<int>>dp;\\n    \\n\\t//function to check for pallindrome\\n    int ispalli(string &s,int i,int j)\\n    {\\n      if(i>=j)\\n      {\\n          return 1;\\n      }",
                "codeTag": "Java"
            },
            {
                "id": 1596345,
                "title": "c-solution-from-center-to-outwards",
                "content": "```\\npublic class Solution {\\n    public string LongestPalindrome(string s) {\\n        if(s==\"\" || s.Length<=1)\\n            return s;\\n        int length = 0, start = 0;\\n        for(int i=0; i<s.Length; i++)\\n        {\\n            int evenLength = PalindromeLength(s, i, i+1);\\n            int oddLength = PalindromeLength(s, i, i);\\n            int currentLength = Math.Max(evenLength, oddLength);\\n            \\n            if(currentLength>length)\\n            {\\n                length = currentLength;\\n                start = i-(length-1)/2;\\n            }\\n        }\\n        \\n        return s.Substring(start, length);\\n    }\\n    \\n    private int PalindromeLength(string s, int left, int right){\\n        while(left>=0 && right<s.Length && s[left] == s[right])\\n        {\\n            left--;\\n            right++;\\n        }\\n        return right-left-1; // (right+1) - (left-1) - 1\\n    }\\n}\\n```\\n\\nRuntime: 88 ms, faster than 89.71% of C# online submissions for Longest Palindromic Substring.\\nMemory Usage: 37.4 MB, less than 47.93% of C# online submissions for Longest Palindromic Substring.",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    public string LongestPalindrome(string s) {\\n        if(s==\"\" || s.Length<=1)\\n            return s;\\n        int length = 0, start = 0;\\n        for(int i=0; i<s.Length; i++)\\n        {\\n            int evenLength = PalindromeLength(s, i, i+1);\\n            int oddLength = PalindromeLength(s, i, i);\\n            int currentLength = Math.Max(evenLength, oddLength);\\n            \\n            if(currentLength>length)\\n            {\\n                length = currentLength;\\n                start = i-(length-1)/2;\\n            }\\n        }\\n        \\n        return s.Substring(start, length);\\n    }\\n    \\n    private int PalindromeLength(string s, int left, int right){\\n        while(left>=0 && right<s.Length && s[left] == s[right])\\n        {\\n            left--;\\n            right++;\\n        }\\n        return right-left-1; // (right+1) - (left-1) - 1\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 915789,
                "title": "dp-java-easy-to-understand-explain-with-visualization-and-share-my-notes",
                "content": "I don\\'t think the explaination in the solution is easy to understand so I created this graph. I\\'m using **Approach 3: Dynamic Programming** in the solution board btw. Hope this helps you understand the approach and my code below.\\n\\nOnly those in pink are from `dp[i][j] = dp[i+1][j-1]`. Others are corner cases that we need to consider (which makes it hard since there are SO MANY).\\n\\n![image](https://assets.leetcode.com/users/images/09d6ade5-323a-4bef-abad-444cf5b7640b_1604022898.182215.png)\\n\\n\\n```\\nclass Solution {\\n    public String longestPalindrome(String s) {\\n        int n = s.length();\\n        if (n < 2) return s;\\n            \\n        int maxLength = 1;\\n        int start = 0;\\n        char[] charArray = s.toCharArray();\\n        boolean[][] dp = new boolean[n][n];\\n        \\n        for (int i = 0; i < n; i++) {\\n            dp[i][i] = true;\\n        }\\n        \\n        for (int j = 1; j < n; j++) {\\n            for (int i = 0; i < j; i++) {\\n                if (charArray[i] == charArray[j]) {\\n                    if (j - i < 3) {\\n                        dp[i][j] = true;\\n                    } else {\\n                        dp[i][j] = dp[i+1][j-1];\\n                    }\\n                } else {\\n                    dp[i][j] = false;\\n                }\\n                \\n                if (dp[i][j]) {\\n                    if (maxLength < j-i+1) {\\n                        maxLength = j-i+1;\\n                        start = i;\\n                    }\\n                }\\n            }\\n\\n        }\\n        return s.substring(start, start+maxLength);\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public String longestPalindrome(String s) {\\n        int n = s.length();\\n        if (n < 2) return s;\\n            \\n        int maxLength = 1;\\n        int start = 0;\\n        char[] charArray = s.toCharArray();\\n        boolean[][] dp = new boolean[n][n];\\n        \\n        for (int i = 0; i < n; i++) {\\n            dp[i][i] = true;\\n        }\\n        \\n        for (int j = 1; j < n; j++) {\\n            for (int i = 0; i < j; i++) {\\n                if (charArray[i] == charArray[j]) {\\n                    if (j - i < 3) {\\n                        dp[i][j] = true;\\n                    } else {\\n                        dp[i][j] = dp[i+1][j-1];\\n                    }\\n                } else {\\n                    dp[i][j] = false;\\n                }\\n                \\n                if (dp[i][j]) {\\n                    if (maxLength < j-i+1) {\\n                        maxLength = j-i+1;\\n                        start = i;\\n                    }\\n                }\\n            }\\n\\n        }\\n        return s.substring(start, start+maxLength);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 476222,
                "title": "simple-c-solution-using-bottom-up-dp-detailed-explanation",
                "content": "```\\n/*\\n    https://leetcode.com/problems/longest-palindromic-substring/submissions/\\n    \\n    Using Tabular approach for finding all palindromic substrings. Then using that info\\n    find the longest palindrome.\\n    TC: O(N^2)\\n    SC: O(N^2)\\n*/\\nclass Solution {\\npublic:\\n    string longestPalindrome(string s) {\\n        if(s.size() == 0)\\n            return \"\";\\n        \\n        const int N = s.size();\\n        // dp(i, j): indicates if string[i:j] is palindromic or not\\n        vector<vector<bool> > dp(N, vector<bool>(N, false));\\n        int max_len = 0, start = 0;\\n        \\n        // each single char is a palindrome\\n        for(int i = 0; i < N; i++)\\n            dp[i][i] = true;\\n        // A single character is always a palindrome,\\n        // so we take the first as the longest palindrome initially\\n        max_len = 1, start = 0;\\n        \\n        for(int l = 1; l < N; l++) {\\n            for(int i = 0; i < N - l; i++) {\\n                int j = i + l;\\n                // when there are only 2 chars, just check the first and last chars\\n                if(j - i + 1 == 2)\\n                    dp[i][j] = s[i] == s[j];\\n                else {\\n                    // current s[i:j] can only be palindromic iff\\n                    // first and last chars are same and the substring s[i+1:j-1]\\n                    // is also palindromic\\n                    dp[i][j] = (s[i] == s[j] && dp[i+1][j-1]) == true;\\n                }\\n                // update max length\\n                if(dp[i][j] && (j - i + 1) > max_len) \\n                    max_len = j - i + 1, start = i;\\n            }\\n        }\\n        \\n        return s.substr(start, max_len);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\n/*\\n    https://leetcode.com/problems/longest-palindromic-substring/submissions/\\n    \\n    Using Tabular approach for finding all palindromic substrings. Then using that info\\n    find the longest palindrome.\\n    TC: O(N^2)\\n    SC: O(N^2)\\n*/\\nclass Solution {\\npublic:\\n    string longestPalindrome(string s) {\\n        if(s.size() == 0)\\n            return \"\";\\n        \\n        const int N = s.size();\\n        // dp(i, j): indicates if string[i:j] is palindromic or not\\n        vector<vector<bool> > dp(N, vector<bool>(N, false));\\n        int max_len = 0, start = 0;\\n        \\n        // each single char is a palindrome\\n        for(int i = 0; i < N; i++)\\n            dp[i][i] = true;\\n        // A single character is always a palindrome,\\n        // so we take the first as the longest palindrome initially\\n        max_len = 1, start = 0;\\n        \\n        for(int l = 1; l < N; l++) {\\n            for(int i = 0; i < N - l; i++) {\\n                int j = i + l;\\n                // when there are only 2 chars, just check the first and last chars\\n                if(j - i + 1 == 2)\\n                    dp[i][j] = s[i] == s[j];\\n                else {\\n                    // current s[i:j] can only be palindromic iff\\n                    // first and last chars are same and the substring s[i+1:j-1]\\n                    // is also palindromic\\n                    dp[i][j] = (s[i] == s[j] && dp[i+1][j-1]) == true;\\n                }\\n                // update max length\\n                if(dp[i][j] && (j - i + 1) > max_len) \\n                    max_len = j - i + 1, start = i;\\n            }\\n        }\\n        \\n        return s.substr(start, max_len);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 467258,
                "title": "straight-forward-solution-with-slice-windows",
                "content": "Not the fastest at 52ms but low memory profile 1.9Mb.\\n```\\n    pub fn longest_palindrome(s: String) -> String {\\n        let mut window_size = s.len();\\n        while window_size > 0 {\\n             match s.as_bytes()\\n                    .windows(window_size)\\n                    .find(|slice| { let iter = slice.iter();\\n                                        iter.clone().eq(iter.clone().rev()) // cloning iterators is cheap\\n                                }\\n                        ) {\\n                             Some(slice) => return String::from_utf8(slice.to_vec()).unwrap_or(\"\".to_string()),\\n                             None => window_size -= 1, // if no slice window of this size is a palindrome, try the next smallest window size\\n                        }\\n        }\\n        \"\".to_string() // if no slice is found or if len was zero, return empty string\\n    }\\n\\t```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\n    pub fn longest_palindrome(s: String) -> String {\\n        let mut window_size = s.len();\\n        while window_size > 0 {\\n             match s.as_bytes()\\n                    .windows(window_size)\\n                    .find(|slice| { let iter = slice.iter();\\n                                        iter.clone().eq(iter.clone().rev()) // cloning iterators is cheap\\n                                }\\n                        ) {\\n                             Some(slice) => return String::from_utf8(slice.to_vec()).unwrap_or(\"\".to_string()),\\n                             None => window_size -= 1, // if no slice window of this size is a palindrome, try the next smallest window size\\n                        }\\n        }\\n        \"\".to_string() // if no slice is found or if len was zero, return empty string\\n    }\\n\\t```",
                "codeTag": "Unknown"
            },
            {
                "id": 368409,
                "title": "solution-in-python-3-six-lines-o-n-2-speed-o-1-space-with-explanation-beats-90",
                "content": "_Explanation:_\\n\\nThis method uses an expand around center approach. The program iterates through each central point of a potential palindrome. moving left to right in the original input string. It then expands outward (left and right) from the center point and checks if the two characters match. This is done by moving _a_ to the left by one and moving _b_ to the right by one. It keeps doing this until they don\\'t match (i.e. ```s[a] == s[b]``` fails to be true) or either end of the input string is reached. This expansion of the palindrome from its center outward occurs inside of the while loop. Once the while loop exits, we have expanded as far as we could and the length of the palindrome is equal to (b - a - 1). The length of this palindrome is then compared to the current maximum length achieved, stored in M. If it is longer than M, (b - a - 1) becomes the new M (i.e. M = b - a - 1) and the leftmost index of this longest palindrome is stored in x (i.e. x = a + 1).\\n\\nPerhaps the most important (and most challenging) part of the program occurs in the structure of the inner for loop: ```for a,b in [(i,i),(i,i+1)]``` This part may take a little explanation to fully understand. A palindrome can be centered in one of two places. The palindrome _dad_ is centered on one of its letters, specifcally the letter _a_. If you had to pick two indices to describe where the palindrome _dad_ is centered you would say that it was centered at the indices 1 and 1, since 1 is the index of _a_. In general such palindromes (palindromes with an odd number of elements) are centered at (_i_,_i_) for some index _i_. The other type of palindrome, _abba_ is centered in between two identical letters, specifcally it is centered between the letters _b_ and _b_. If you had to pick two indices to describe where the palindrome _abba_ is centered you would say that it was centered at the indices 1 and 2, since 1 and 2 are the indices of the central two _b_\\'s. In general such palindromes (palindromes with an even number of elements) are centered at (_i_,_i+1_) for some index _i_. To correctly look at all the palindrome substrings, for each index _i_ in the for loop we have to consider both centeral pivoting points. This is why the inner for loop iterates through both (_i_,_i_) and (_i_,_i+1_).\\n\\nThe program ends by returning the longest palindrome. This is done by splicing it based on the leftmost index (i.e.  x) of where the palindrome starts and the maximum recorded length (i.e. M).\\n\\n_Glossary of Variables:_\\nL = length of original input string\\nM = length of current longest palindromic substring\\nx = leftmost (starting) index of current longest palindromic substring\\na = number of units left of center of palindrome\\nb = number of units right of center of palindrome\\n```\\nclass Solution:\\n    def longestPalindrome(self, s: str) -> str:\\n\\t    L, M, x = len(s), 0, 0\\n\\t    for i in range(L):\\n\\t    \\tfor a,b in [(i,i),(i,i+1)]:\\n\\t    \\t\\twhile a >= 0 and b < L and s[a] == s[b]: a -= 1; b += 1\\n\\t    \\t\\tif b - a - 1 > M: M, x = b - a - 1, a + 1\\n\\t    return s[x:x+M]\\n\\t\\t\\n\\n- Junaid Mansuri\\n(LeetCode ID)@hotmail.com",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```s[a] == s[b]```\n```for a,b in [(i,i),(i,i+1)]```",
                "codeTag": "Unknown"
            },
            {
                "id": 174086,
                "title": "swift-solution-100-passed",
                "content": "We iterate over the string and use two pointers from the leftmost to the rightmost. Both pointers move further inward and comparisons occur. Currently the method below does every combination possible and determines if the current string index is a palindrome. If so, we store the inital place of the palindrome as well as the end. If not a palindrome, we clear the temp and continue the loop.  \\n\\n```\\n\\nclass Solution {\\n    func longestPalindrome(_ s: String) -> String {\\n\\t\\t\\n    /*If Empty or equal to one we return*/\\n        if(s.count == 0){return \"\"} \\n        if(s.count == 1){return s}\\n\\t\\t\\t\\t\\n\\t/*Start and End represent the palindrome with the longest length. */\\n        var start = 0, end = start, stringArray = Array(s), max = 0\\n\\t\\t\\t\\t\\n        for i in 0..<s.count{\\n\\t\\t\\t\\t\\n\\t/*Left and Right  pointers move inward (Sandwich principle).*/\\n            var left = i, right = s.count-1, tempStart = left, tempEnd = right\\n\\t\\t\\t\\t\\t\\t\\n            while(left<right){\\n\\t/*If values at the Left and Right index are equal then we temporarily store index if greater than max*/\\n                if(stringArray[left] == stringArray[right]){\\n                    if((right - left) > max){\\n                        max = (right - left)\\n                        tempStart = left\\n                        tempEnd = right\\n                    }\\n                    left+=1\\n                    right-=1\\n                }\\n                else{//Reset temp variables and the current max\\n                    left = i\\n                    right = tempEnd - 1\\n                    tempStart = left\\n                    tempEnd = right\\n                    max = 0\\n                }\\n            }\\n            if((tempEnd - tempStart) > (end - start)){//Store temp variables and continue loop\\n                end = tempEnd\\n                start = tempStart\\n            }\\n        }\\n        return (String(stringArray[start...end]).count > 1) ? String(stringArray[start...end]) : String(s.first!)\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\n\\nclass Solution {\\n    func longestPalindrome(_ s: String) -> String {\\n\\t\\t\\n    /*If Empty or equal to one we return*/\\n        if(s.count == 0){return \"\"} \\n        if(s.count == 1){return s}\\n\\t\\t\\t\\t\\n\\t/*Start and End represent the palindrome with the longest length. */\\n        var start = 0, end = start, stringArray = Array(s), max = 0\\n\\t\\t\\t\\t\\n        for i in 0..<s.count{\\n\\t\\t\\t\\t\\n\\t/*Left and Right  pointers move inward (Sandwich principle).*/\\n            var left = i, right = s.count-1, tempStart = left, tempEnd = right\\n\\t\\t\\t\\t\\t\\t\\n            while(left<right){\\n\\t/*If values at the Left and Right index are equal then we temporarily store index if greater than max*/\\n                if(stringArray[left] == stringArray[right]){\\n                    if((right - left) > max){\\n                        max = (right - left)\\n                        tempStart = left\\n                        tempEnd = right\\n                    }\\n                    left+=1\\n                    right-=1\\n                }\\n                else{//Reset temp variables and the current max\\n                    left = i\\n                    right = tempEnd - 1\\n                    tempStart = left\\n                    tempEnd = right\\n                    max = 0\\n                }\\n            }\\n            if((tempEnd - tempStart) > (end - start)){//Store temp variables and continue loop\\n                end = tempEnd\\n                start = tempStart\\n            }\\n        }\\n        return (String(stringArray[start...end]).count > 1) ? String(stringArray[start...end]) : String(s.first!)\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3216,
                "title": "sharing-my-8ms-c-solution",
                "content": "    class Solution {\\n    public:\\n        string longestPalindrome(string s) {\\n            int n = s.length(), i;\\n            if(n<2)\\n                return s;\\n                \\n            int leftMost=0, rightMost=0;\\n            i = 0;\\n            int start, end;\\n            while(i<n)\\n            {\\n                start = i;\\n                end = i;\\n                i++;\\n                while(i<n && s[i]==s[start])\\n                {\\n                    i++;\\n                }\\n                end = i-1;\\n                \\n                while(start-1>=0 && end+1<n && s[start-1]==s[end+1])\\n                {\\n                    start--;\\n                    end++;\\n                }\\n                \\n                if(rightMost-leftMost <= end-start)\\n                {\\n                    leftMost = start;\\n                    rightMost = end;\\n                }\\n            }\\n            \\n            return s.substr(leftMost, rightMost-leftMost+1);\\n        }\\n    };",
                "solutionTags": [
                    "C++"
                ],
                "code": "class Solution {\\n    public:\\n        string longestPalindrome(string s) {\\n            int n = s.length(), i;\\n            if(n<2)\\n                return s;\\n                \\n            int leftMost=0, rightMost=0;\\n            i = 0;\\n            int start, end;\\n            while(i<n)\\n            {\\n                start = i;\\n                end = i;\\n                i++;\\n                while(i<n && s[i]==s[start])\\n                {\\n                    i++;\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 3225,
                "title": "be-careful-of-substring-function-java-o-n-2-may-got-tle",
                "content": "My TLE code:\\n\\n    public String longestPalindrome(String s) {\\n        if(s == null || s.length() <= 1) {\\n            return s;\\n        }\\n        int len = s.length();\\n        String subString = \"\";\\n        // palindrome[i][j] : substring(i,j) is palindrome or not?\\n        boolean[][] palindrome = new boolean[len][len];\\n        // calculate palindrome[][]\\n        for(int i=0;i<len;i++) {\\n            palindrome[i][i] = true;\\n        }\\n        for(int i=1;i<len;i++) {\\n            if(s.charAt(i-1) == s.charAt(i)) {\\n                palindrome[i-1][i] = true;\\n                subString = s.substring(i-1, i+1);\\n            }\\n        }\\n        for(int k=2;k<len;k++) {\\n            for(int i=0;i+k<len;i++) {\\n                int j = i+k;\\n                if(s.charAt(i) == s.charAt(j) && palindrome[i+1][j-1]) {\\n                    palindrome[i][j] = true;\\n                    subString = s.substring(i, j+1);\\n                }\\n            }\\n        }\\n        return subString;\\n    }\\n\\nI find that substring is time-consuming.\\nSo My Accepted code is here:\\n\\n    public String longestPalindrome(String s) {\\n        if(s == null || s.length() <= 1) {\\n            return s;\\n        }\\n        int len = s.length();\\n        int start = 0, end = 0;\\n        // palindrome[i][j] : substring(i,j) is palindrome or not?\\n        boolean[][] palindrome = new boolean[len][len];\\n        // length = 1\\n        for(int i=0;i<len;i++) {\\n            palindrome[i][i] = true;\\n        }\\n        // length = 2\\n        for(int i=1;i<len;i++) {\\n            if(s.charAt(i-1) == s.charAt(i)) {\\n                palindrome[i-1][i] = true;\\n                start = i-1; end = i+1;\\n            }\\n        }\\n        // length = k (k=2..len)\\n        for(int k=2;k<len;k++) {\\n            for(int i=0;i+k<len;i++) {\\n                int j = i+k;\\n                if(s.charAt(i) == s.charAt(j) && palindrome[i+1][j-1]) {\\n                    palindrome[i][j] = true;\\n                    start = i; end = j+1;\\n                }\\n            }\\n        }\\n        return s.substring(start, end);\\n    }\\n\\nI hope I can help you!",
                "solutionTags": [],
                "code": "My TLE code:\\n\\n    public String longestPalindrome(String s) {\\n        if(s == null || s.length() <= 1) {\\n            return s;\\n        }\\n        int len = s.length();\\n        String subString = \"\";\\n        // palindrome[i][j] : substring(i,j) is palindrome or not?\\n        boolean[][] palindrome = new boolean[len][len];\\n        // calculate palindrome[][]\\n        for(int i=0;i<len;i++) {\\n            palindrome[i][i] = true;\\n        }\\n        for(int i=1;i<len;i++) {\\n            if(s.charAt(i-1) == s.charAt(i)) {\\n                palindrome[i-1][i] = true;\\n                subString = s.substring(i-1, i+1);\\n            }\\n        }\\n        for(int k=2;k<len;k++) {\\n            for(int i=0;i+k<len;i++) {\\n                int j = i+k;\\n                if(s.charAt(i) == s.charAt(j) && palindrome[i+1][j-1]) {\\n                    palindrome[i][j] = true;\\n                    subString = s.substring(i, j+1);\\n                }\\n            }\\n        }\\n        return subString;\\n    }\\n\\nI find that substring is time-consuming.\\nSo My Accepted code is here:\\n\\n    public String longestPalindrome(String s) {\\n        if(s == null || s.length() <= 1) {\\n            return s;\\n        }\\n        int len = s.length();\\n        int start = 0, end = 0;\\n        // palindrome[i][j] : substring(i,j) is palindrome or not?\\n        boolean[][] palindrome = new boolean[len][len];\\n        // length = 1\\n        for(int i=0;i<len;i++) {\\n            palindrome[i][i] = true;\\n        }\\n        // length = 2\\n        for(int i=1;i<len;i++) {\\n            if(s.charAt(i-1) == s.charAt(i)) {\\n                palindrome[i-1][i] = true;\\n                start = i-1; end = i+1;\\n            }\\n        }\\n        // length = k (k=2..len)\\n        for(int k=2;k<len;k++) {\\n            for(int i=0;i+k<len;i++) {\\n                int j = i+k;\\n                if(s.charAt(i) == s.charAt(j) && palindrome[i+1][j-1]) {\\n                    palindrome[i][j] = true;\\n                    start = i; end = j+1;\\n                }\\n            }\\n        }\\n        return s.substring(start, end);\\n    }\\n\\nI hope I can help you!",
                "codeTag": "Unknown"
            },
            {
                "id": 3239,
                "title": "a-very-brief-o-n-time-o-1-space-solution-ac",
                "content": " suppose\\n       \\n      string(i,l) is a substring of s where i is the start index and l is the length \\n\\n      S(n) is the longest palindrome for substring of s with indice from 0 to n\\n\\nif S(n-1) = string(i,l)\\n\\nthen S(n) =\\n \\n1. string(n-l, l+1) if string(n-l, l+1) is palindrome\\n2. string(n-l-1, l+2) if string(n-l-1, l+2) is palindrome\\n3. S(n) otherwise\\n\\n\\n----------\\n\\n\\n        int i = 0;\\n        int l = 0;\\n        int n = s.length();\\n        for(int j=0;j<n;j++){\\n            if(isPalindrome(s, j-l, j)){\\n                i = j-l;\\n                l = l+1;\\n            }else if(j-l-1>=0 && isPalindrome(s, j-l-1, j)){\\n                i = j-l-1;\\n                l = l+2;\\n            }\\n        }\\n            \\n        return new String(s.getBytes(), i, l)\\n\\n\\n\\n      \\n\\n;",
                "solutionTags": [
                    "Java"
                ],
                "code": " suppose\\n       \\n      string(i,l) is a substring of s where i is the start index and l is the length \\n\\n      S(n) is the longest palindrome for substring of s with indice from 0 to n\\n\\nif S(n-1) = string(i,l)\\n\\nthen S(n) =\\n \\n1. string(n-l, l+1) if string(n-l, l+1) is palindrome\\n2. string(n-l-1, l+2) if string(n-l-1, l+2) is palindrome\\n3. S(n) otherwise\\n\\n\\n----------\\n\\n\\n        int i = 0;\\n        int l = 0;\\n        int n = s.length();\\n        for(int j=0;j<n;j++){\\n            if(isPalindrome(s, j-l, j)){\\n                i = j-l;\\n                l = l+1;\\n            }else if(j-l-1>=0 && isPalindrome(s, j-l-1, j)){\\n                i = j-l-1;\\n                l = l+2;\\n            }\\n        }\\n            \\n        return new String(s.getBytes(), i, l)\\n\\n\\n\\n      \\n\\n;",
                "codeTag": "Unknown"
            },
            {
                "id": 3852152,
                "title": "dp-lps-template-friendly",
                "content": "# Intuition\\n\\n\\n# Approach\\n- for a string s of length greater than 2 to be palindrome there are two conditons:\\n    1. s[start]=s[end]\\n    2. substring(start+1,end-1) should also be a palindrome\\n\\n- for example, string s=ababa\\ns[start]=a \\ns[end]=a\\nsubstring from start+1 to end-1 i.e. bab is also palindrome.\\nSo string s is plaindrome.\\n\\n- Create a 2d vector to store whether from index i to j of string is palindrome or not.\\n- Here i and j represent start and end index of string respectively.\\n- Base cases:\\nsubstring string of length 1 is always a palindrome so mark dp[i][j]=1 for j-i==0(length 1).\\nthe above condition only work if the length is greater than 2 so also precalculate for substring of length 2 whether it is palindrome or not.\\n- Now start filling 2d vector column wise for substring of length 3 or more with the two palindrome conditions.Colmum wise because for substring (0,4) one need (1,3) hence column wise.\\n- Now find the maximum length substring from 2d vector.\\n\\n\\n\\n \\n\\n# Complexity\\n- Time complexity:\\nO(n^2)\\n\\n- Space complexity:\\nO(n^2)\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string longestPalindrome(string s) {\\n        int n=s.size();\\n        vector<vector<int>>dp(n,vector<int>(n,0));\\n\\n        //base case\\n        for(int i=0;i<n;i++)\\n        {\\n            for(int j=0;j<n;j++)\\n            {\\n                if((j-i)==0||(j-i)==1)//substr of length 1 or 2\\n                {\\n                    if(s[i]==s[j])\\n                    {\\n                        dp[i][j]=1;\\n                    }\\n                    else\\n                    {\\n                        dp[i][j]=0;\\n                    }\\n                }\\n            }\\n        }\\n\\n        // to be a palindrom conditions\\n        //s[i]==s[j]\\n        //substr(i+1,j-1) is also palindrome\\n\\n\\n\\n        //fill it column wise\\n        for(int j=0;j<n;j++)\\n        {\\n            for(int i=0;i<n;i++)\\n            {\\n                if((j-i)>1)//substr of length 2 or more //upper triangle only bcz i <j\\n                {\\n                    if(s[i]==s[j]&&dp[i+1][j-1]==1)\\n                    {\\n                        dp[i][j]=1;\\n                    }\\n                    else\\n                    {\\n                        dp[i][j]=0;\\n                    }\\n                }\\n            }\\n        }\\n\\n        int start=0;\\n        int maxi=1;\\n        for(int i=0;i<n;i++)\\n        {\\n            for(int j=0;j<n;j++)\\n            {\\n                if(dp[i][j]==1)\\n                {\\n                    if(maxi<=j-i+1)\\n                    {\\n                        maxi=j-i+1;\\n                        start=i;\\n                    }\\n                }\\n            }\\n        }\\n        return s.substr(start,maxi);        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string longestPalindrome(string s) {\\n        int n=s.size();\\n        vector<vector<int>>dp(n,vector<int>(n,0));\\n\\n        //base case\\n        for(int i=0;i<n;i++)\\n        {\\n            for(int j=0;j<n;j++)\\n            {\\n                if((j-i)==0||(j-i)==1)//substr of length 1 or 2\\n                {\\n                    if(s[i]==s[j])\\n                    {\\n                        dp[i][j]=1;\\n                    }\\n                    else\\n                    {\\n                        dp[i][j]=0;\\n                    }\\n                }\\n            }\\n        }\\n\\n        // to be a palindrom conditions\\n        //s[i]==s[j]\\n        //substr(i+1,j-1) is also palindrome\\n\\n\\n\\n        //fill it column wise\\n        for(int j=0;j<n;j++)\\n        {\\n            for(int i=0;i<n;i++)\\n            {\\n                if((j-i)>1)//substr of length 2 or more //upper triangle only bcz i <j\\n                {\\n                    if(s[i]==s[j]&&dp[i+1][j-1]==1)\\n                    {\\n                        dp[i][j]=1;\\n                    }\\n                    else\\n                    {\\n                        dp[i][j]=0;\\n                    }\\n                }\\n            }\\n        }\\n\\n        int start=0;\\n        int maxi=1;\\n        for(int i=0;i<n;i++)\\n        {\\n            for(int j=0;j<n;j++)\\n            {\\n                if(dp[i][j]==1)\\n                {\\n                    if(maxi<=j-i+1)\\n                    {\\n                        maxi=j-i+1;\\n                        start=i;\\n                    }\\n                }\\n            }\\n        }\\n        return s.substr(start,maxi);        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3339551,
                "title": "simple-and-easy-solution-in-java",
                "content": "##### For odd length palindromes, the basic idea is to fix the center of the palindrome and expand outwards until the palindrome is no longer valid. Here is an algorithmic approach:\\n\\n1. Initialize two pointers, left and right, to the center of the string.\\n2. While the characters at indices left and right are equal, increment left and decrement right.\\n3. The length of the longest palindrome centered at the current index is 2 * (center - left) - 1.\\n4. Keep track of the maximum length palindrome and its center.\\n\\n##### For even length palindromes, the basic idea is to fix the two centers of the palindrome and expand outwards until the palindrome is no longer valid. Here is an algorithmic approach:\\n\\n1. Initialize two pointers, left and right, to the center of the string.\\n2. While the characters at indices left and right are equal, increment left and decrement right.\\n3. The length of the longest palindrome centered at the current index is 2 * (center - left) - 1.\\n4. Keep track of the maximum length palindrome and its center.\\n5. Initialize two pointers, left and right, to the center of the string and its right neighbor.\\n6. While the characters at indices left and right are equal, increment left and decrement right.\\n7. The length of the longest palindrome centered at the current index is 2 * (center - left) - 1.\\n8. Keep track of the maximum length palindrome and its center.\\n##### By combining these two approaches, we can find the longest palindromic substring in a given string. The time complexity of this algorithm is O(n^2) since we need to check each possible center of the palindrome. However, there are more efficient algorithms such as Manacher\\'s algorithm that can solve this problem in O(n) time complexity.\\n\\n# Code\\n```\\nclass Solution {\\n    public String longestPalindrome(String str) {\\n        int s=0, e=0;\\n        for(int i=0; i<str.length(); i++){\\n            int odd=pal(str,i,i);\\n            int even=pal(str,i,i+1);\\n            int len=Math.max(odd,even);\\n\\n            if(len>e-s){\\n                s=i-(len-1)/2;\\n                e=i+len/2;\\n            }\\n        }\\n        return str.substring(s,e+1);\\n    }\\n\\n    public int pal(String str, int s, int e){\\n        while(s>=0 && e<str.length() && str.charAt(s)==str.charAt(e)){\\n            s--;\\n            e++;\\n        }\\n        return e-s-1;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public String longestPalindrome(String str) {\\n        int s=0, e=0;\\n        for(int i=0; i<str.length(); i++){\\n            int odd=pal(str,i,i);\\n            int even=pal(str,i,i+1);\\n            int len=Math.max(odd,even);\\n\\n            if(len>e-s){\\n                s=i-(len-1)/2;\\n                e=i+len/2;\\n            }\\n        }\\n        return str.substring(s,e+1);\\n    }\\n\\n    public int pal(String str, int s, int e){\\n        while(s>=0 && e<str.length() && str.charAt(s)==str.charAt(e)){\\n            s--;\\n            e++;\\n        }\\n        return e-s-1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2142969,
                "title": "dynamic-programming-solution-with-comments-c-o-n-2",
                "content": "```\\n// For more clarrification on this approach use the video link : https://www.youtube.com/watch?v=UflHuQj6MVA\\n// I used that video for learning and is not my youtube video neither I am promoting any channel.\\n\\nclass Solution {\\npublic:\\n    string longestPalindrome(string s) {\\n        \\n        \\n        // DP soln\\n        int n = s.length();\\n        \\n        \\n        // If string length is 1 then return string itself.\\n        if(n == 1)\\n            return s;\\n        \\n        // Matrix of size nxn whose rows represents start indx and col represents end indx of any substring.\\n        vector<vector<int>> dp(n,vector<int>(n,0));\\n        \\n        \\n        // This arr of size 2 will keep record of i, j index of longest palindrome substring.\\n        int arr[2] = {-1,-1};\\n        \\n        \\n        // Mark all diagonal elements in matrix as 1. Bcoz single substr of length 1 itself is palindrome\\n        for(int i=0;i<n;i++)\\n            dp[i][i] = 1;\\n        \\n        \\n        // Mark all 2 length substr as 1 if their both characters are equal.\\n        for(int i=0;i<n-1;i++)\\n        {\\n            if(s[i] == s[i+1])\\n            {\\n                arr[0] = i;\\n                arr[1] = i+1;\\n                dp[i][i+1] = 1;\\n            }\\n        }\\n        \\n        \\n        int diff = 2;\\n        \\n        // Traverse diagonally in each iteration.\\n        while(diff < n)\\n        {\\n            for(int i=0,j=i+diff;j<n;i++,j++)\\n            {\\n                if(s[i] == s[j] && dp[i+1][j-1] == 1)\\n                {\\n                    dp[i][j] = 1;\\n                    if(j-i > arr[1]-arr[0])\\n                    {\\n                        arr[0] = i;\\n                        arr[1] = j;\\n                    }\\n                }\\n            }\\n            diff++;\\n        }\\n            \\n        \\n        // If index is -1 in arr, it means no palindrome found so return any single length string. Here I returned first character of given string.\\n        if(arr[0] == -1)\\n            return s.substr(0,1);\\n        \\n        \\n        // Otherwise return substring between i and j index values stored in arr.\\n        return s.substr(arr[0],arr[1]-arr[0]+1);\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming"
                ],
                "code": "```\\n// For more clarrification on this approach use the video link : https://www.youtube.com/watch?v=UflHuQj6MVA\\n// I used that video for learning and is not my youtube video neither I am promoting any channel.\\n\\nclass Solution {\\npublic:\\n    string longestPalindrome(string s) {\\n        \\n        \\n        // DP soln\\n        int n = s.length();\\n        \\n        \\n        // If string length is 1 then return string itself.\\n        if(n == 1)\\n            return s;\\n        \\n        // Matrix of size nxn whose rows represents start indx and col represents end indx of any substring.\\n        vector<vector<int>> dp(n,vector<int>(n,0));\\n        \\n        \\n        // This arr of size 2 will keep record of i, j index of longest palindrome substring.\\n        int arr[2] = {-1,-1};\\n        \\n        \\n        // Mark all diagonal elements in matrix as 1. Bcoz single substr of length 1 itself is palindrome\\n        for(int i=0;i<n;i++)\\n            dp[i][i] = 1;\\n        \\n        \\n        // Mark all 2 length substr as 1 if their both characters are equal.\\n        for(int i=0;i<n-1;i++)\\n        {\\n            if(s[i] == s[i+1])\\n            {\\n                arr[0] = i;\\n                arr[1] = i+1;\\n                dp[i][i+1] = 1;\\n            }\\n        }\\n        \\n        \\n        int diff = 2;\\n        \\n        // Traverse diagonally in each iteration.\\n        while(diff < n)\\n        {\\n            for(int i=0,j=i+diff;j<n;i++,j++)\\n            {\\n                if(s[i] == s[j] && dp[i+1][j-1] == 1)\\n                {\\n                    dp[i][j] = 1;\\n                    if(j-i > arr[1]-arr[0])\\n                    {\\n                        arr[0] = i;\\n                        arr[1] = j;\\n                    }\\n                }\\n            }\\n            diff++;\\n        }\\n            \\n        \\n        // If index is -1 in arr, it means no palindrome found so return any single length string. Here I returned first character of given string.\\n        if(arr[0] == -1)\\n            return s.substr(0,1);\\n        \\n        \\n        // Otherwise return substring between i and j index values stored in arr.\\n        return s.substr(arr[0],arr[1]-arr[0]+1);\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1926046,
                "title": "easy-c-o-n-2-time-and-o-1-space-explained",
                "content": "### Approach:\\n\\nThe algorithm below is very simple and easy to understand. The idea is to ***fix a center and expand in both directions*** to get longer palindromes and keep track of the start and end position of longest palindrome seen so far.\\n\\n**Time Complexity :** Outer loop runs for n times and we have two inner loops which run for n times. \\n              ` n*(n+n)=>O(n^2)`\\n\\t\\t\\t  \\n**Space Cpmplexity :**  O(1)\\n\\n***l*** : This points to the left most index of pallindrom string.\\n***h*** : This points to the right most index of pallindrom string.\\n\\n***start*** : This points to the starting position of current maximum length pallindromic string.\\n***end*** : This points to the end position of current maximum length pallindromic string.\\n\\n\\n\\n```\\nstring longestPalindrome(string s) {\\n        int start=0;\\n        int end=0;\\n        int n=s.size();\\n        for(int i=1;i<n;i++)\\n        {\\n\\t\\t\\n\\t\\t    // for even length palindroms\\n            int l=i-1;           \\n            int h=i;\\n            while(l>=0 && h<n && s[l]==s[h])   //if both left and right is same then expand the length by of pallindrom by moving l and h accordingly\\n            {\\n                if(end-start < h-l )           // if current length of pallindrom is greater than previous the update sart and end accordingly\\n                {\\n                    start=l;\\n                    end=h;\\n                }\\n                l--;\\n                h++;\\n            }\\n            \\n\\t\\t\\t//for odd length palindroms\\n            l=i-1;\\n            h=i+1;\\n            while(l>=0 && h<n && s[l]==s[h])\\n            {\\n                if(end-start < h-l )\\n                {\\n                    start=l;\\n                    end=h;\\n                }\\n                l--;\\n                h++;\\n            }\\n        }\\n        \\n        string ans=\"\";\\n        for(int i=start;i<=end;i++)\\n            ans+=s[i];\\n        \\n        return ans;\\n    }\\n```\\n\\nDo ***Upvote***, if it helped. **:)**",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nstring longestPalindrome(string s) {\\n        int start=0;\\n        int end=0;\\n        int n=s.size();\\n        for(int i=1;i<n;i++)\\n        {\\n\\t\\t\\n\\t\\t    // for even length palindroms\\n            int l=i-1;           \\n            int h=i;\\n            while(l>=0 && h<n && s[l]==s[h])   //if both left and right is same then expand the length by of pallindrom by moving l and h accordingly\\n            {\\n                if(end-start < h-l )           // if current length of pallindrom is greater than previous the update sart and end accordingly\\n                {\\n                    start=l;\\n                    end=h;\\n                }\\n                l--;\\n                h++;\\n            }\\n            \\n\\t\\t\\t//for odd length palindroms\\n            l=i-1;\\n            h=i+1;\\n            while(l>=0 && h<n && s[l]==s[h])\\n            {\\n                if(end-start < h-l )\\n                {\\n                    start=l;\\n                    end=h;\\n                }\\n                l--;\\n                h++;\\n            }\\n        }\\n        \\n        string ans=\"\";\\n        for(int i=start;i<=end;i++)\\n            ans+=s[i];\\n        \\n        return ans;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1777358,
                "title": "cpp-dynamic-programming-recursive-approach-and-memoization",
                "content": "**Iterative**\\n```\\nclass Solution {\\npublic:\\n    string longestPalindrome(string s) {\\n        \\n        int n=s.length();\\n        vector<vector<int>> dp(n,vector<int>(n,-1));\\n        int maxLen=1;\\n        int start=0;\\n        \\n        for(int i=0;i<n-1;i++){\\n            dp[i][i]=1;\\n            dp[i][i+1]=(s[i]==s[i+1]);\\n            if(dp[i][i+1] and maxLen==1){\\n                maxLen=2;\\n                start=i;\\n            }\\n        }\\n        // Fill details diagonaly\\n\\t\\t// Make 2d matrix of NxN and then think yourself how can you make use of previous answers\\n        dp[n-1][n-1]=1;\\n        for(int k=2;k<n;k++){ \\n                int i=0,j=k;\\n                while(i<n-k and j<n){\\n                        dp[i][j]=(s[i]==s[j] and dp[i+1][j-1]);\\n                        int len=j-i+1;\\n                        if(dp[i][j] and len>maxLen){\\n                            maxLen=len;\\n                            start=i;\\n                        }\\n                    i++,j++;\\n                }   \\n            }\\n        \\n        return s.substr(start,maxLen);\\n        \\n    }\\n};\\n/*\\nPlease upvote if you like it.\\n*/\\n```\\n\\n**Recursive**\\n```\\n class Solution {\\npublic:\\n    vector<vector<int>> dp;\\n    int ans=1;\\n    int start=0;\\n    string str;\\n    bool lps(int i,int j){\\n        if(i>j) return false;\\n        if(i==j){\\n            return dp[i][j]=1;\\n        }\\n        \\n        if(dp[i][j]!=-1) return dp[i][j];\\n        \\n        if(str[i]==str[j] and (i==j-1 or lps(i+1,j-1))){\\n            dp[i][j]=1;\\n            int len=j-i+1;\\n            if(len>ans){\\n                ans=len;\\n                start=i;\\n            }\\n        }\\n        \\n        lps(i,j-1);\\n        lps(i+1,j);\\n        if(dp[i][j]==-1) dp[i][j]=0;\\n        return dp[i][j];\\n    }\\n    string longestPalindrome(string s) {\\n        int n=s.length();\\n        str=s;\\n        dp.resize(n+1,vector<int>(n+1,-1));\\n        lps(0,s.length()-1);\\n        return s.substr(start,ans);\\n    }\\n};\\n```",
                "solutionTags": [
                    "Dynamic Programming",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string longestPalindrome(string s) {\\n        \\n        int n=s.length();\\n        vector<vector<int>> dp(n,vector<int>(n,-1));\\n        int maxLen=1;\\n        int start=0;\\n        \\n        for(int i=0;i<n-1;i++){\\n            dp[i][i]=1;\\n            dp[i][i+1]=(s[i]==s[i+1]);\\n            if(dp[i][i+1] and maxLen==1){\\n                maxLen=2;\\n                start=i;\\n            }\\n        }\\n        // Fill details diagonaly\\n\\t\\t// Make 2d matrix of NxN and then think yourself how can you make use of previous answers\\n        dp[n-1][n-1]=1;\\n        for(int k=2;k<n;k++){ \\n                int i=0,j=k;\\n                while(i<n-k and j<n){\\n                        dp[i][j]=(s[i]==s[j] and dp[i+1][j-1]);\\n                        int len=j-i+1;\\n                        if(dp[i][j] and len>maxLen){\\n                            maxLen=len;\\n                            start=i;\\n                        }\\n                    i++,j++;\\n                }   \\n            }\\n        \\n        return s.substr(start,maxLen);\\n        \\n    }\\n};\\n/*\\nPlease upvote if you like it.\\n*/\\n```\n```\\n class Solution {\\npublic:\\n    vector<vector<int>> dp;\\n    int ans=1;\\n    int start=0;\\n    string str;\\n    bool lps(int i,int j){\\n        if(i>j) return false;\\n        if(i==j){\\n            return dp[i][j]=1;\\n        }\\n        \\n        if(dp[i][j]!=-1) return dp[i][j];\\n        \\n        if(str[i]==str[j] and (i==j-1 or lps(i+1,j-1))){\\n            dp[i][j]=1;\\n            int len=j-i+1;\\n            if(len>ans){\\n                ans=len;\\n                start=i;\\n            }\\n        }\\n        \\n        lps(i,j-1);\\n        lps(i+1,j);\\n        if(dp[i][j]==-1) dp[i][j]=0;\\n        return dp[i][j];\\n    }\\n    string longestPalindrome(string s) {\\n        int n=s.length();\\n        str=s;\\n        dp.resize(n+1,vector<int>(n+1,-1));\\n        lps(0,s.length()-1);\\n        return s.substr(start,ans);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 830244,
                "title": "c-solution-better-than-90-time-and-99-8-space-complexity",
                "content": "The strings \\'aa\\' and \\'aba\\' are palindomes. The main idea is to find all palidromes with the length 2 and 3. When we find a palidrome, the algorythm goes to the left and to the right in the same time.  \\nWe should reuse already calculated palindrome. So if **s[left - 1] != s[right + 1]** it\\'s not a palindrome. \\nExpample: \\n\\ns = \\'camppmdt\\'\\n\\nFirst we find `pp` as palindrome. That we check `s[left - 1] == s[right + 1]` yes, so the palindrome is `mppm`, than we decrise `left` and increase `rigth` pointers and check again. `a != d` so we stop searching and goes farther. In this moment, the longest palindrom is `mppm`\\n\\n\\n\\n```\\n\\n public string LongestPalindrome(string s)\\n        {\\n            if (s.Length < 2) return s;\\n\\n            (int start, int end) longest = (0, 0);\\n            \\n            for (var i = 0; i < s.Length - 1; i++)\\n            {\\n                if (s[i] == s[i + 1])\\n                {\\n                    var res = LongestPalindrome(s, i, i + 1);\\n                    longest = res.end - res.start > longest.end - longest.start ? res : longest;\\n                }\\n\\n                if (i + 2 < s.Length && s[i] == s[i + 2])\\n                {\\n                    var res = LongestPalindrome(s, i, i + 2);\\n                    longest = res.end - res.start > longest.end - longest.start ? res : longest;\\n                }\\n            }\\n\\n            return (longest.start == 0 && longest.end == 0) ? \\n                s[0].ToString() : \\n                s.Substring(longest.start, longest.end - longest.start + 1);\\n        }\\n\\n        private (int start, int end) LongestPalindrome(string s, int start, int end)\\n        { \\n            while (start >= 0 && end < s.Length && s[start] == s[end])\\n            {\\n                start--;\\n                end++;\\n            }\\n\\n            return (start + 1, end - 1);\\n        }\\n```",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "```\\n\\n public string LongestPalindrome(string s)\\n        {\\n            if (s.Length < 2) return s;\\n\\n            (int start, int end) longest = (0, 0);\\n            \\n            for (var i = 0; i < s.Length - 1; i++)\\n            {\\n                if (s[i] == s[i + 1])\\n                {\\n                    var res = LongestPalindrome(s, i, i + 1);\\n                    longest = res.end - res.start > longest.end - longest.start ? res : longest;\\n                }\\n\\n                if (i + 2 < s.Length && s[i] == s[i + 2])\\n                {\\n                    var res = LongestPalindrome(s, i, i + 2);\\n                    longest = res.end - res.start > longest.end - longest.start ? res : longest;\\n                }\\n            }\\n\\n            return (longest.start == 0 && longest.end == 0) ? \\n                s[0].ToString() : \\n                s.Substring(longest.start, longest.end - longest.start + 1);\\n        }\\n\\n        private (int start, int end) LongestPalindrome(string s, int start, int end)\\n        { \\n            while (start >= 0 && end < s.Length && s[start] == s[end])\\n            {\\n                start--;\\n                end++;\\n            }\\n\\n            return (start + 1, end - 1);\\n        }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 536012,
                "title": "java-dp-solution",
                "content": "```\\nclass Solution {\\n    public String longestPalindrome(String s) {\\n        String ans = \"\";\\n        if(s.length() == 0) return ans;\\n        int n = s.length(), start = 0, end = 0, maxLen = 0;\\n        boolean[][] DP = new boolean[n][n];\\n        for(int i = n - 1; i >= 0; i--) {\\n            for(int j = i; j < n; j++) {\\n                DP[i][j] = s.charAt(i) == s.charAt(j) && (j - i < 3 || DP[i+1][j-1]);\\n                if(DP[i][j] && (j - i > end - start)) {\\n                    start = i;\\n                    end = j;\\n                }  \\n            }\\n        }\\n        return s.substring(start, end+1);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\n    public String longestPalindrome(String s) {\\n        String ans = \"\";\\n        if(s.length() == 0) return ans;\\n        int n = s.length(), start = 0, end = 0, maxLen = 0;\\n        boolean[][] DP = new boolean[n][n];\\n        for(int i = n - 1; i >= 0; i--) {\\n            for(int j = i; j < n; j++) {\\n                DP[i][j] = s.charAt(i) == s.charAt(j) && (j - i < 3 || DP[i+1][j-1]);\\n                if(DP[i][j] && (j - i > end - start)) {\\n                    start = i;\\n                    end = j;\\n                }  \\n            }\\n        }\\n        return s.substring(start, end+1);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 181376,
                "title": "c-dp-simple",
                "content": "```\\nstring longestPalindrome(string s) {\\n        int l = s.size();\\n        int max = INT_MIN;\\n        int end = 0, start = 0;\\n        vector<vector<bool>> dp(l, vector<bool>(l));\\n        for (int i = l-1; i >= 0; i--) {\\n            for (int j = i; j < l; j++) {\\n                dp[i][j] = (s[i] == s[j]) && (j-i <= 1 || dp[i+1][j-1]);\\n                if (dp[i][j] && (j - i) > max) {\\n                    start = i;\\n                    end = j;\\n                    max = j-i;\\n                }\\n            }\\n        }\\n        return s.substr(start, max+1);\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\nstring longestPalindrome(string s) {\\n        int l = s.size();\\n        int max = INT_MIN;\\n        int end = 0, start = 0;\\n        vector<vector<bool>> dp(l, vector<bool>(l));\\n        for (int i = l-1; i >= 0; i--) {\\n            for (int j = i; j < l; j++) {\\n                dp[i][j] = (s[i] == s[j]) && (j-i <= 1 || dp[i+1][j-1]);\\n                if (dp[i][j] && (j - i) > max) {\\n                    start = i;\\n                    end = j;\\n                    max = j-i;\\n                }\\n            }\\n        }\\n        return s.substr(start, max+1);\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 164362,
                "title": "javascript-simple-solution",
                "content": "```\\nvar longestPalindrome = function(s) {\\n    let res = \"\";\\n    let cur = \"\";\\n    for(let i = 0; i < s.length; i ++){\\n        for(let j = i; j < i + 2; j ++){\\n            let left = i;\\n            let right = j;\\n            while(s[left] && s[left] === s[right]){\\n                cur = s.substring(left, right + 1);\\n                if(cur.length > res.length) res = cur;\\n                left --;\\n                right ++;\\n            }\\n        }\\n    }\\n    return res;\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nvar longestPalindrome = function(s) {\\n    let res = \"\";\\n    let cur = \"\";\\n    for(let i = 0; i < s.length; i ++){\\n        for(let j = i; j < i + 2; j ++){\\n            let left = i;\\n            let right = j;\\n            while(s[left] && s[left] === s[right]){\\n                cur = s.substring(left, right + 1);\\n                if(cur.length > res.length) res = cur;\\n                left --;\\n                right ++;\\n            }\\n        }\\n    }\\n    return res;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3057,
                "title": "beat-100-java-solution-and-easy-to-understand",
                "content": "    public String longestPalindrome(String s) {\\n        if(s==null){\\n            return \"\";\\n        }\\n       char[] arr = s.toCharArray();\\n\\t\\t  int max = 0;\\n\\t\\t  int maxi = 0;\\n\\t\\t  int maxj = 0;\\n\\t\\t  \\n\\t\\t  for(int i = 0; i< arr.length;){\\n\\t\\t\\t  int i1 = getFarestSameElementIndex(arr,i);\\n\\t\\t\\t  int dist = getDistance(arr,i,i1);\\n\\t\\t\\t  int index1 = i-dist;\\n\\t\\t\\t  int index2 = i1 + dist;\\n\\t\\t\\t  int l = index2 - index1;\\n\\t\\t\\t  if(l>max){\\n\\t\\t\\t          max = l;\\n\\t\\t\\t\\t  maxi = index1;\\n\\t\\t\\t\\t  maxj = index2;\\n\\t\\t\\t  }\\n\\t\\t\\t  i = i1+1;\\n\\t\\t  }\\n\\t\\t  \\n\\t\\t  return s.substring(maxi, maxj+1);\\n    }\\n    \\n    private int getDistance(char[] arr,int index1,int index2){\\n\\t\\tint i1 = index1-1;\\n\\t\\tint i2 = index2+1;\\n\\t\\tint dist = 0;\\n\\t\\twhile(i1>=0&&i2<arr.length){\\n\\t\\t\\tif(arr[i1]==arr[i2]){\\n\\t\\t\\t\\tdist++;\\n\\t\\t\\t}else{\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\t}\\n\\t\\t\\ti1--;i2++;\\n\\t\\t}\\n\\t\\treturn dist;\\n\\t}\\n\\t\\n\\tprivate int getFarestSameElementIndex(char[] arr, int index){\\n\\t\\tfor(int i = index+1;i<arr.length;i++){\\n\\t\\t\\tif(arr[i]!=arr[index]){\\n\\t\\t\\t\\treturn i-1;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn arr.length-1;\\n\\t}",
                "solutionTags": [],
                "code": "    public String longestPalindrome(String s) {\\n        if(s==null){\\n            return \"\";\\n        }\\n       char[] arr = s.toCharArray();\\n\\t\\t  int max = 0;\\n\\t\\t  int maxi = 0;\\n\\t\\t  int maxj = 0;\\n\\t\\t  \\n\\t\\t  for(int i = 0; i< arr.length;){\\n\\t\\t\\t  int i1 = getFarestSameElementIndex(arr,i);\\n\\t\\t\\t  int dist = getDistance(arr,i,i1);\\n\\t\\t\\t  int index1 = i-dist;\\n\\t\\t\\t  int index2 = i1 + dist;\\n\\t\\t\\t  int l = index2 - index1;\\n\\t\\t\\t  if(l>max){\\n\\t\\t\\t          max = l;\\n\\t\\t\\t\\t  maxi = index1;\\n\\t\\t\\t\\t  maxj = index2;\\n\\t\\t\\t  }\\n\\t\\t\\t  i = i1+1;\\n\\t\\t  }\\n\\t\\t  \\n\\t\\t  return s.substring(maxi, maxj+1);\\n    }\\n    \\n    private int getDistance(char[] arr,int index1,int index2){\\n\\t\\tint i1 = index1-1;\\n\\t\\tint i2 = index2+1;\\n\\t\\tint dist = 0;\\n\\t\\twhile(i1>=0&&i2<arr.length){\\n\\t\\t\\tif(arr[i1]==arr[i2]){\\n\\t\\t\\t\\tdist++;\\n\\t\\t\\t}else{\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\t}\\n\\t\\t\\ti1--;i2++;\\n\\t\\t}\\n\\t\\treturn dist;\\n\\t}\\n\\t\\n\\tprivate int getFarestSameElementIndex(char[] arr, int index){\\n\\t\\tfor(int i = index+1;i<arr.length;i++){\\n\\t\\t\\tif(arr[i]!=arr[index]){\\n\\t\\t\\t\\treturn i-1;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn arr.length-1;\\n\\t}",
                "codeTag": "Unknown"
            },
            {
                "id": 3862201,
                "title": "python3-easy-solution-beats-93-73-in-runtime",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n![image.png](https://assets.leetcode.com/users/images/dee0375c-f843-4849-a8e8-3fcc91fceee8_1691143738.456786.png)\\n\\nPlease  Upvote!!!!!!!!\\n# Code\\n```\\nclass Solution:\\n    def longestPalindrome(self, s: str) -> str:\\n        longest = \"\"\\n        for i in range(len(s)):\\n            left = i;right = i\\n            while left >= 0 and right < len(s) and s[left] == s[right]:left -= 1;right += 1\\n            palindrome = s[left+1:right]\\n            if len(palindrome) > len(longest):longest = palindrome\\n            left = i;right = i+1\\n            while left >= 0 and right < len(s) and s[left] == s[right]:left -= 1;right += 1\\n            palindrome = s[left+1:right]  \\n            if len(palindrome) > len(longest):longest = palindrome\\n        return longest\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def longestPalindrome(self, s: str) -> str:\\n        longest = \"\"\\n        for i in range(len(s)):\\n            left = i;right = i\\n            while left >= 0 and right < len(s) and s[left] == s[right]:left -= 1;right += 1\\n            palindrome = s[left+1:right]\\n            if len(palindrome) > len(longest):longest = palindrome\\n            left = i;right = i+1\\n            while left >= 0 and right < len(s) and s[left] == s[right]:left -= 1;right += 1\\n            palindrome = s[left+1:right]  \\n            if len(palindrome) > len(longest):longest = palindrome\\n        return longest\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2594234,
                "title": "accepted-solution-using-1-loops-o-n-time-complexity",
                "content": "**Read the approach below to understand the logic!**\\n\\n***Please upvote if you like it!!!***\\n\\n**Approach :-**\\n\\n* Here the palindrome could have odd or even length.\\n* For odd length, there must be a central element. For even the elements will be side by side.\\n* So we calculate both cases for all elements:\\n\\t* For odd: we took left & right as same elements(central) l = i, r = i\\n\\t* if elements in both indexes are the same we\\u2019ll increase r & decrease l by 1.\\n\\t* when we find both are not same, we\\u2019ll calculate the length length = r-l-1\\n\\t* if the length is greater than mx, then we\\u2019ll store start and end point of this length.\\n\\t* For even: same approach, just here we\\u2019ll take l & r next to each other. l = i, r = i+1\\n* Return substring from start to max length.\\n\\n**~Time complexity: O(n^2).**\\n**~Time complexity: O(1).**\\n\\n**Code**\\n```\\nclass Solution {\\npublic:\\n    string longestPalindrome(string s) {\\n        int n=s.length();\\n        int mx=1;\\n        int start=0;\\n        for(int i=1;i<=n;i++){\\n            //Check for even string\\n            int l=i-1;\\n            int r=i;\\n            while(l>=0 && r<n && s[l]==s[r]){\\n                if(r-l+1>mx){\\n                    mx=r-l+1;\\n                    start=l;\\n                }\\n                l--;\\n                r++;\\n            }\\n            //Check for odd string\\n            l=i-1;\\n            r=i+1;\\n            while(l>=0 && r<n && s[l]==s[r]){\\n                if(r-l+1>mx){\\n                    mx=r-l+1;\\n                    start=l;\\n                }\\n                l--;\\n                r++;\\n            }\\n        }\\n        return s.substr(start,mx);\\n    }\\n};\\n```\\n\\n",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string longestPalindrome(string s) {\\n        int n=s.length();\\n        int mx=1;\\n        int start=0;\\n        for(int i=1;i<=n;i++){\\n            //Check for even string\\n            int l=i-1;\\n            int r=i;\\n            while(l>=0 && r<n && s[l]==s[r]){\\n                if(r-l+1>mx){\\n                    mx=r-l+1;\\n                    start=l;\\n                }\\n                l--;\\n                r++;\\n            }\\n            //Check for odd string\\n            l=i-1;\\n            r=i+1;\\n            while(l>=0 && r<n && s[l]==s[r]){\\n                if(r-l+1>mx){\\n                    mx=r-l+1;\\n                    start=l;\\n                }\\n                l--;\\n                r++;\\n            }\\n        }\\n        return s.substr(start,mx);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2019757,
                "title": "java-memoization-tabulation-both",
                "content": "*Please Upvote this post, if it\\'s help you...!!*\\n**Memoiziation Code:-**\\n```\\nclass Solution {\\n    \\n    public String longestPalindrome(String str) {\\n        int n = str.length();\\n        int [][] dp = new int[n][n];\\n        for(int [] d : dp){\\n            Arrays.fill(d, -1);\\n        }\\n        longestPalindromeSubstring_memo(str, 0, n-1, dp);\\n        return str.substring(stIdx, stIdx + max);\\n    }\\n    \\n    private int max = 0;\\n    private int stIdx = 0;\\n    public int longestPalindromeSubstring_memo(String s, int i, int j, int [][] dp){\\n        if(i >= j){\\n            dp[i][j] = i == j ? 1 : 0;\\n            if(dp[i][j] > max){\\n                max = dp[i][j];\\n                stIdx = i;\\n            }\\n            return dp[i][j];\\n        } \\n\\n        if(dp[i][j] != -1) return dp[i][j];\\n        int a = longestPalindromeSubstring_memo(s, i+1, j-1, dp);\\n        int b = longestPalindromeSubstring_memo(s, i+1, j, dp);\\n        int c = longestPalindromeSubstring_memo(s, i, j-1, dp);\\n\\n        if(s.charAt(i) == s.charAt(j)){\\n            if(i + 1 == j) {    // jab \"ee\" same hai lakin i+1, j-1 pe to 0 hoga to\\n                //  iswale case me kabhi 2 print hi nhi hoga\\n                dp[i][j] = 2;\\n            } else{\\n                dp[i][j] = a > 0 ? a + 2 : 0;\\n            }\\n\\n            if(dp[i][j] > max){\\n                max = dp[i][j];\\n                stIdx = i;\\n            }\\n            return dp[i][j];\\n        } else{\\n            return dp[i][j] = 0;\\n        }\\n    }\\n}\\n```\\n\\n**Tabulation Code:-**\\n```\\npublic String longestPlaindromicSubstring_tabu(String s) {\\n        int n = s.length(), len = 0;\\n        int[][] dp = new int[n][n];\\n        int count = 0;\\n        int I = 0;\\n        for (int gap = 0; gap < n; gap++) {\\n            for (int i = 0, j = gap; j < n; i++, j++) {\\n                if (gap == 0){\\n                    dp[i][j] = 1;\\n                    count++;\\n                }\\n\\n                else if (gap == 1 && s.charAt(i) == s.charAt(j)){\\n                    dp[i][j] = 2;\\n                    count++;\\n                }\\n                else {\\n                    if(s.charAt(i) == s.charAt(j) && dp[i + 1][j - 1] > 0){\\n                        dp[i][j] = dp[i+1][j-1] + 2;\\n                        count++;\\n                    } else {\\n                        dp[i][j] = 0;\\n                    }\\n                }\\n\\n                if(dp[i][j] > len){\\n                    len = dp[i][j];\\n                    I = i;\\n                }\\n            }\\n        }\\n        String str = s.substring(I, I + len);\\n        return str;\\n    }\\n```",
                "solutionTags": [
                    "Java",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\n    \\n    public String longestPalindrome(String str) {\\n        int n = str.length();\\n        int [][] dp = new int[n][n];\\n        for(int [] d : dp){\\n            Arrays.fill(d, -1);\\n        }\\n        longestPalindromeSubstring_memo(str, 0, n-1, dp);\\n        return str.substring(stIdx, stIdx + max);\\n    }\\n    \\n    private int max = 0;\\n    private int stIdx = 0;\\n    public int longestPalindromeSubstring_memo(String s, int i, int j, int [][] dp){\\n        if(i >= j){\\n            dp[i][j] = i == j ? 1 : 0;\\n            if(dp[i][j] > max){\\n                max = dp[i][j];\\n                stIdx = i;\\n            }\\n            return dp[i][j];\\n        } \\n\\n        if(dp[i][j] != -1) return dp[i][j];\\n        int a = longestPalindromeSubstring_memo(s, i+1, j-1, dp);\\n        int b = longestPalindromeSubstring_memo(s, i+1, j, dp);\\n        int c = longestPalindromeSubstring_memo(s, i, j-1, dp);\\n\\n        if(s.charAt(i) == s.charAt(j)){\\n            if(i + 1 == j) {    // jab \"ee\" same hai lakin i+1, j-1 pe to 0 hoga to\\n                //  iswale case me kabhi 2 print hi nhi hoga\\n                dp[i][j] = 2;\\n            } else{\\n                dp[i][j] = a > 0 ? a + 2 : 0;\\n            }\\n\\n            if(dp[i][j] > max){\\n                max = dp[i][j];\\n                stIdx = i;\\n            }\\n            return dp[i][j];\\n        } else{\\n            return dp[i][j] = 0;\\n        }\\n    }\\n}\\n```\n```\\npublic String longestPlaindromicSubstring_tabu(String s) {\\n        int n = s.length(), len = 0;\\n        int[][] dp = new int[n][n];\\n        int count = 0;\\n        int I = 0;\\n        for (int gap = 0; gap < n; gap++) {\\n            for (int i = 0, j = gap; j < n; i++, j++) {\\n                if (gap == 0){\\n                    dp[i][j] = 1;\\n                    count++;\\n                }\\n\\n                else if (gap == 1 && s.charAt(i) == s.charAt(j)){\\n                    dp[i][j] = 2;\\n                    count++;\\n                }\\n                else {\\n                    if(s.charAt(i) == s.charAt(j) && dp[i + 1][j - 1] > 0){\\n                        dp[i][j] = dp[i+1][j-1] + 2;\\n                        count++;\\n                    } else {\\n                        dp[i][j] = 0;\\n                    }\\n                }\\n\\n                if(dp[i][j] > len){\\n                    len = dp[i][j];\\n                    I = i;\\n                }\\n            }\\n        }\\n        String str = s.substring(I, I + len);\\n        return str;\\n    }\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1779328,
                "title": "csharp-88-ms-faster-than-91-77-clean-code",
                "content": "1. To search the Longest Palindromic Substring, traverses the string one time with For loop \\n2. For Every character try expanding both side (Left and right)with while loop until you get the palindrome.\\n3. Once found new palindrome with grater length, just override the previous palindrome in maxLengthStr variable.\\n4. first while loop is for searching Odd Palindrome Ex. \"aba\"\\n5. We will now search the Palindrome in case of even length Ex. \"bb\"\\n6. Both while loop has same code and that can be extracted in some other reusable function. For easy readability of code I have written like this.\\n7. At last return the maxLengthStr which would be containing Longest Palindromic Sub-string.\\n\\n```\\n\\n public static string LongestPalindrome(string s)\\n {\\n            int maxLength = 1;\\n            var maxLengthStr=\"\";\\n\\n            for (int i = 0; i < s.Length; i++)\\n            {\\n                //Odd Palindrom\\n                int L = i; int R = i;\\n                while (L>=0 && R<s.Length && s[L]== s[R])\\n                {\\n                    if (R - L + 1 > maxLength)\\n\\t\\t\\t\\t\\t{\\n                        maxLength = R - L + 1;\\n                        maxLengthStr = s.Substring(L, R - L + 1);\\n                    }\\n                    L--;\\n                    R++;\\n                }\\n\\n                //Even Palindrom\\n                L = i; R = i+1;\\n                while (L >= 0 && R < s.Length && s[L] == s[R])\\n                {\\n                    if (R - L + 1 > maxLength)\\n                    {\\n                        maxLength = R - L + 1;\\n                        maxLengthStr = s.Substring(L, R - L + 1);\\n                    }\\n                    L--;\\n                    R++;\\n                }\\n\\n            }\\n            return maxLengthStr;\\n }\\n```",
                "solutionTags": [
                    "C#",
                    "String"
                ],
                "code": "```\\n\\n public static string LongestPalindrome(string s)\\n {\\n            int maxLength = 1;\\n            var maxLengthStr=\"\";\\n\\n            for (int i = 0; i < s.Length; i++)\\n            {\\n                //Odd Palindrom\\n                int L = i; int R = i;\\n                while (L>=0 && R<s.Length && s[L]== s[R])\\n                {\\n                    if (R - L + 1 > maxLength)\\n\\t\\t\\t\\t\\t{\\n                        maxLength = R - L + 1;\\n                        maxLengthStr = s.Substring(L, R - L + 1);\\n                    }\\n                    L--;\\n                    R++;\\n                }\\n\\n                //Even Palindrom\\n                L = i; R = i+1;\\n                while (L >= 0 && R < s.Length && s[L] == s[R])\\n                {\\n                    if (R - L + 1 > maxLength)\\n                    {\\n                        maxLength = R - L + 1;\\n                        maxLengthStr = s.Substring(L, R - L + 1);\\n                    }\\n                    L--;\\n                    R++;\\n                }\\n\\n            }\\n            return maxLengthStr;\\n }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1743060,
                "title": "python-dp",
                "content": "**Runtime: 60 ms, faster than 99.88% of Python3 online submissions for Longest Palindromic Substring.**\\n`Approach 4` from solution is more general. However, due to the support of slice notation in python, slicing out a new string is fairly light weight and simply. So, instead of assuming every character in string is a middle point, tracking the maximum window size and expand backward is more efficient.\\n```\\nclass Solution:\\n    def longestPalindrome(self, s: str) -> str:\\n        if s == s[::-1]: return s\\n        \\n        start, size = 0, 1\\n        for i in range(1, len(s)):\\n            l, r = i - size, i + 1\\n            s1, s2 = s[l-1:r], s[l:r]\\n            \\n            if l - 1 >= 0 and s1 == s1[::-1]:\\n                start, size = l - 1, size + 2\\n            elif s2 == s2[::-1]:\\n                start, size = l, size + 1\\n                \\n        return s[start:start+size]\\n```",
                "solutionTags": [
                    "Python",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution:\\n    def longestPalindrome(self, s: str) -> str:\\n        if s == s[::-1]: return s\\n        \\n        start, size = 0, 1\\n        for i in range(1, len(s)):\\n            l, r = i - size, i + 1\\n            s1, s2 = s[l-1:r], s[l:r]\\n            \\n            if l - 1 >= 0 and s1 == s1[::-1]:\\n                start, size = l - 1, size + 2\\n            elif s2 == s2[::-1]:\\n                start, size = l, size + 1\\n                \\n        return s[start:start+size]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1525967,
                "title": "o-n-2-time-and-o-1-space-python-solution-with-comments",
                "content": "This solution is inspired (same idea) from [@oldCodingFarmer solution](https://leetcode.com/problems/longest-palindromic-substring/discuss/2954/Python-easy-to-understand-solution-with-comments-(from-middle-to-two-ends).)\\n```\\n\\nclass Solution(object):\\n    def longestPalindrome(self, s):\\n        \"\"\"\\n        :type s: str\\n        :rtype: str\\n        \"\"\"\\n        \\n        #In this function l and r are the middle indecees, as palindrome is created from the middle, we expand from inner (middle) to outer\\n\\t\\t\\n        def helper(l, r):\\n            while l >= 0 and r < len(s) and s[l] == s[r]:\\n                l -= 1; r += 1\\n            return s[l+1:r] # l+1 because we take the previous sliceas when we exit the while loop it will no longer be palindromic\\n\\n        res = \"\"\\n        for i in range(len(s)):\\n            odd = helper(i, i) # odd case, like \"aba\"\\n            even = helper(i, i+1) # even case, like \"abba\"\\n            res=max(odd,res,even,key=lambda x: len(x)) #compare between odd,even and res according to the max length\\n\\n        return res\\n\\n```\\n",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\n\\nclass Solution(object):\\n    def longestPalindrome(self, s):\\n        \"\"\"\\n        :type s: str\\n        :rtype: str\\n        \"\"\"\\n        \\n        #In this function l and r are the middle indecees, as palindrome is created from the middle, we expand from inner (middle) to outer\\n\\t\\t\\n        def helper(l, r):\\n            while l >= 0 and r < len(s) and s[l] == s[r]:\\n                l -= 1; r += 1\\n            return s[l+1:r] # l+1 because we take the previous sliceas when we exit the while loop it will no longer be palindromic\\n\\n        res = \"\"\\n        for i in range(len(s)):\\n            odd = helper(i, i) # odd case, like \"aba\"\\n            even = helper(i, i+1) # even case, like \"abba\"\\n            res=max(odd,res,even,key=lambda x: len(x)) #compare between odd,even and res according to the max length\\n\\n        return res\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1439171,
                "title": "c-longest-palindromic-substring-tabulation",
                "content": "```cpp\\nclass Solution {\\npublic:\\n    string longestPalindrome(string s) {\\n        int n = s.size();\\n        int dp[n][n];\\n        memset(dp, 0, sizeof dp);\\n        \\n        int len = 0, start = 0;\\n        for (int g = 0; g < n; ++g) {\\n            for (int i = 0, j = g; j < n; ++i, ++j) {\\n                if (g == 0) dp[i][j] = true;\\n                else if (g == 1) dp[i][j] = s[i] == s[j];\\n                else dp[i][j] = s[i] == s[j] && dp[i + 1][j - 1];\\n                \\n                if (dp[i][j]) {\\n                    len = g + 1;\\n                    start = i;\\n                }\\n            }\\n        }\\n        \\n        return s.substr(start, len);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```cpp\\nclass Solution {\\npublic:\\n    string longestPalindrome(string s) {\\n        int n = s.size();\\n        int dp[n][n];\\n        memset(dp, 0, sizeof dp);\\n        \\n        int len = 0, start = 0;\\n        for (int g = 0; g < n; ++g) {\\n            for (int i = 0, j = g; j < n; ++i, ++j) {\\n                if (g == 0) dp[i][j] = true;\\n                else if (g == 1) dp[i][j] = s[i] == s[j];\\n                else dp[i][j] = s[i] == s[j] && dp[i + 1][j - 1];\\n                \\n                if (dp[i][j]) {\\n                    len = g + 1;\\n                    start = i;\\n                }\\n            }\\n        }\\n        \\n        return s.substr(start, len);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 635659,
                "title": "the-art-of-dynamic-programming",
                "content": "[\\uD83C\\uDFA8 The ART of Dynamic Programming:](https://leetcode.com/discuss/general-discussion/712010/The-ART-of-Dynamic-Programming-An-Intuitive-Approach%3A-from-Apprentice-to-Master) we can use a \"best ending here\" at each `j`<sup>th</sup> ending index for each `i..j` candidate.  We start `i` and `j` as adjacent indices and expand `i` to-the-left (ie. away from `j`) one index as a time attempting to expand upon existing palindromes for the subproblem of `i..j`, ie. `i + 1..j - 1`.\\n\\nSo the base cases for each ending `j`<sup>th</sup> index is a diagonal line:\\n\\n```\\nN = 4\\n\\ndp = [[1,0,0,0],\\n      [0,1,0,0],\\n      [0,0,1,0],\\n      [0,0,0,1]]\\n```\\n\\nAnd the recurrence relation starts with `i` and `j` as adjacent indices and `i` iterates to-the-left in an attempt to expand existing palindromes ending at `j`:\\n\\n```\\nN = 4\\n\\ndp = [[j,0,0,0],\\n   \\uD83D\\uDC48 [i,j,0,0],\\n   \\uD83D\\uDC48 [i,i,j,0],\\n   \\uD83D\\uDC48 [i,i,i,j]]\\n```\\n\\n\\n---\\n\\n*Kotlin*\\n```\\nclass Solution {\\n    fun longestPalindrome(s: String): String {\\n        var N = s.length\\n        var dp = Array(N) { BooleanArray(N) { false } }\\n        for (i in 0 until N)\\n            dp[i][i] = true\\n        var best = \"${s[0]}\"\\n        for (j in 1 until N) {\\n            for (i in j - 1 downTo 0) {\\n                if (s[i] == s[j] && (i + 1 == j || dp[i + 1][j - 1])) {\\n                    dp[i][j] = true\\n                    if (best.length < j - i + 1)\\n                        best = s.substring(i, j + 1)\\n                }\\n            }\\n        }\\n        return best\\n    }\\n}\\n```\\n\\n*Javascript*\\n```\\nlet longestPalindrome = s => {\\n    let N = s.length;\\n    let dp = [...Array(N)].map(_ => Array(N).fill(0));\\n    let best = s[0];\\n    for (let i = 0; i < N; ++i)\\n        dp[i][i] = 1;\\n    for (let j = 1; j < N; ++j) {\\n        for (let i = j - 1; 0 <= i; --i) {\\n            if (s[i] == s[j] && (i + 1 == j || dp[i + 1][j - 1])) {\\n                dp[i][j] = 1;\\n                if (best.length < j - i + 1)\\n                    best = s.substring(i, j + 1);\\n            }\\n        }\\n    }\\n    return best;\\n};\\n```\\n\\n*Python3*\\n```\\nclass Solution:\\n    def longestPalindrome(self, s: str) -> str:\\n        N = len(s)\\n        dp = [[False] * N for _ in range(N)]\\n        for i in range(N):\\n            dp[i][i] = True\\n        best = f\\'{s[0]}\\'\\n        for j in range(1, N):\\n            for i in range(j - 1, -1, -1):\\n                if s[i] == s[j] and (i + 1 == j or dp[i + 1][j - 1]):\\n                    dp[i][j] = True\\n                    if len(best) < j - i + 1:\\n                        best = s[i:j + 1]\\n        return best\\n```\\n\\n*Rust*\\n```\\ntype VC = Vec<char>;\\nimpl Solution {\\n    pub fn longest_palindrome(s: String) -> String {\\n        let N = s.len();\\n        let s: VC = s.chars().collect();\\n        let mut dp = vec![vec![false; N]; N];\\n        for i in 0..N {\\n            dp[i][i] = true;\\n        }\\n        let mut best: VC = vec![s[0]];\\n        for j in 1..N {\\n            for i in 0..j {\\n                dp[i][j] = s[i] == s[j] && (i + 1 == j || dp[i + 1][j - 1]);\\n                if dp[i][j] && best.len() < j - i + 1 {\\n                    best = s[i..=j].to_vec().into_iter().collect();\\n                }\\n            }\\n        }\\n        best.into_iter().collect()\\n    }\\n}\\n```\\n\\n*C++*\\n```\\nclass Solution {\\npublic:\\n    using VI = vector<int>;\\n    using VVI = vector<VI>;\\n    string longestPalindrome(string s) {\\n        int N = s.size();\\n        VVI dp(N, VI(N));\\n        for (auto i{ 0 }; i < N; ++i)\\n            dp[i][i] = 1;\\n        auto best = string(1, s[0]);\\n        for (auto j{ 1 }; j < N; ++j) {\\n            for (auto i{ j - 1 }; 0 <= i; --i) {\\n                if (s[i] == s[j] && (i + 1 == j || dp[i + 1][j - 1])) {\\n                    dp[i][j] = 1;\\n                    if (best.size() < j - i + 1)\\n                        best = s.substr(i, j - i + 1);\\n                }\\n            }\\n        }\\n        return best;\\n    }\\n};\\n```\\n\\n---\\n\\n**May 17<sup>th</sup>, 2020:**\\n\\n**Top-Down: TLE**\\n\\nReduce `s` from the outside-in, starting with the outter-most indexes `i = 0` and `j = N - 1`.  We have 3 use-cases to consider for finding the maximum palindrome for each substring of `s[i..j]`:\\n\\n* **Case 1:** the sub-problem without the character at index `i`\\n* **Case 2:** the sub-problem without the character at index `j`\\n* **Case 3:** the sub-problem without the character at index `i` and `j`\\n\\n**Base Case:** when i and j are the same index or adjacent indices (ie. `j - i < 2`)\\n\\n**Note:** Even with a memo this top-down solution will TLE.\\n\\n*Javascript*\\n```\\nlet longestPalindrome = s => {\\n    let N = s.length;\\n    if (!N) return \\'\\';\\n    let ans = s[0];\\n    let best = (i, j) => {\\n        if (ans.length < j - i + 1)      // +1 for i..j inclusive\\n            ans = s.substring(i, j + 1); // +1 for i..j inclusive \\uD83C\\uDFAF\\n    };\\n    let go = (i = 0, j = N - 1) => {\\n        if (j - i < 2) {\\n            if (s[i] == s[j]) {\\n                best(i, j);\\n                return true;\\n            }\\n            return false;\\n        }\\n        go(i + 1, j);           // case 1: the sub-problem without the character at index i\\n        go(i, j - 1);           // case 2: the sub-problem without the character at index j\\n        if (go(i + 1, j - 1)) { // case 3: the sub-problem without the character at index i and j\\n            if (s[i] == s[j]) {\\n                best(i, j);\\n                return true;\\n            }\\n        }\\n        return false;\\n    };\\n    go();\\n    return ans;\\n};\\n```\\n\\n*C++*\\n```\\nclass Solution {\\npublic:\\n\\tstring longestPalindrome(string s) {\\n\\t\\tint N = s.size();\\n\\t\\tif (!N) return {};\\n\\t\\tstring ans{ s[0] };\\n\\t\\tgo(ans, s, 0, N - 1);\\n\\t\\treturn ans;\\n\\t}\\nprivate:\\n\\tbool go(string& ans, string& s, int i, int j) {\\n\\t\\tauto best = [&](auto i, auto j) {\\n\\t\\t\\tif (ans.size() < j - i + 1)        // +1 for i..j inclusive\\n\\t\\t\\t\\tans = s.substr(i, j - i + 1);  // +1 for i..j inclusive \\uD83C\\uDFAF\\n\\t\\t};\\n\\t\\tif (j - i < 2) {\\n\\t\\t\\tif (s[i] == s[j]) {\\n\\t\\t\\t\\tbest(i, j);\\n\\t\\t\\t\\treturn true;\\n\\t\\t\\t}\\n\\t\\t\\treturn false;\\n\\t\\t}\\n\\t\\tgo(ans, s, i + 1, j);           // case 1: the sub-problem without the character at index i\\n\\t\\tgo(ans, s, i, j - 1);           // case 2: the sub-problem without the character at index j\\n\\t\\tif (go(ans, s, i + 1, j - 1)) { // case 3: the sub-problem without the character at index i and j\\n\\t\\t\\tif (s[i] == s[j]) {\\n\\t\\t\\t\\tbest(i, j);\\n\\t\\t\\t\\treturn true;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn false;\\n\\t}\\n};\\n```\\n\\n---\\n\\n**Bottom-Up DP: AC**\\n\\nSame dynamic programming idea as above, but flipped upside-down.  Start with the base cases (ie. palindromes of length 0 or 1) and generate larger palindromes based on the previously found palindromes.\\n\\nLet `dp[i][j]` be true if and only if there exists a palindrome from `s[i..j]` inclusive.\\n\\n* **Recurrence Relation:** `dp[i][j] = s[i] == s[j] && dp[i + 1][j - 1]`\\n\\nThis means that `s[i..j]` is a palindrome if the outter-most indices `i`,`j` contain the same character (ie. `s[i] == s[j]`) and the middle portion of `s` in-between the outter-most indices `i`,`j` is a palindrome.\\n\\n* **Base Case:** when i and j are the same index or adjacent indices (ie. `j - i < 2`)\\n\\n*Javascript*\\n```\\nlet longestPalindrome = s => {\\n    let N = s.length;\\n    if (!N) return \\'\\';\\n    let ans = s[0];\\n    let dp = [...Array(N)].map(row => Array(N).fill(false));\\n    for (let j = 1; j < N; ++j) {\\n        for (let i = j; i >= 0; --i) {\\n            dp[i][j] = s[i] == s[j] && (j - i < 2 || dp[i + 1][j - 1]);\\n            if (dp[i][j] && ans.length < j - i + 1)\\n                ans = s.substring(i, j + 1); // +1 for i..j inclusive \\uD83C\\uDFAF\\n        }\\n    }\\n    return ans;\\n};\\n```\\n\\n*C++*\\n```\\nclass Solution {\\npublic:\\n    using VI = vector<int>;\\n    using VVI = vector<VI>;\\n    string longestPalindrome(string s) {\\n        int N = s.size();\\n        if (!N) return {};\\n        VVI dp(N, VI(N));\\n        string ans{ s[0] };\\n        for (auto j{ 1 }; j < N; ++j) {\\n            for (auto i{ j }; i >= 0; --i) {\\n                dp[i][j] = s[i] == s[j] && (j - i < 2 || dp[i + 1][j - 1]);\\n                if (dp[i][j] && ans.size() < j - i + 1)\\n                    ans = s.substr(i, j - i + 1); // +1 for i..j inclusive \\uD83C\\uDFAF\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```\\n\\n---\\n\\n**Brute Force: AC**\\n\\nIteratively expand palindromes from their middle outwards.  There are 2 use cases to consider:\\n\\n* **Case 1:** odd length palindromes have a single middle index `i`\\n* **Case 2:** even length palindromes have two middle indexes `i` and `i + 1`\\n\\n*Javascript*\\n```\\nlet longestPalindrome = (s, ans = \\'\\') => {\\n    let N = s.length;\\n    if (!N) return ans;\\n    ans = s[0];\\n    let expand = (i, j) => {\\n        for (; 0 <= i && j < N && s[i] == s[j]; --i, ++j)\\n            if (ans.length < j - i + 1)\\n                ans = s.substring(i, j + 1); // +1 for i..j inclusive \\uD83C\\uDFAF\\n    };\\n    for (let i = 0; i + 1 < N; ++i)\\n        expand(i, i),     // case 1: odd length palindrome\\n        expand(i, i + 1); // case 2: even length palindrome\\n    return ans;\\n};\\n```\\n\\n*C++*\\n```\\nclass Solution {\\npublic:\\n    string longestPalindrome(string s, string ans = {}) {\\n        int N = s.size();\\n        if (!N) return {};\\n        ans = s[0];\\n        auto expand = [&](auto i, auto j) {\\n            for (; 0 <= i && j < N && s[i] == s[j]; --i, ++j)\\n                if (ans.size() < j - i + 1)\\n                    ans = s.substr(i, j - i + 1); // +1 for i..j inclusive \\uD83C\\uDFAF\\n        };\\n        for (auto i{ 0 }; i + 1 < N; ++i)\\n            expand(i, i),     // case 1: odd length palindrome\\n            expand(i, i + 1); // case 2: even length palindrome\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "```\\nN = 4\\n\\ndp = [[1,0,0,0],\\n      [0,1,0,0],\\n      [0,0,1,0],\\n      [0,0,0,1]]\\n```\n```\\nN = 4\\n\\ndp = [[j,0,0,0],\\n   \\uD83D\\uDC48 [i,j,0,0],\\n   \\uD83D\\uDC48 [i,i,j,0],\\n   \\uD83D\\uDC48 [i,i,i,j]]\\n```\n```\\nclass Solution {\\n    fun longestPalindrome(s: String): String {\\n        var N = s.length\\n        var dp = Array(N) { BooleanArray(N) { false } }\\n        for (i in 0 until N)\\n            dp[i][i] = true\\n        var best = \"${s[0]}\"\\n        for (j in 1 until N) {\\n            for (i in j - 1 downTo 0) {\\n                if (s[i] == s[j] && (i + 1 == j || dp[i + 1][j - 1])) {\\n                    dp[i][j] = true\\n                    if (best.length < j - i + 1)\\n                        best = s.substring(i, j + 1)\\n                }\\n            }\\n        }\\n        return best\\n    }\\n}\\n```\n```\\nlet longestPalindrome = s => {\\n    let N = s.length;\\n    let dp = [...Array(N)].map(_ => Array(N).fill(0));\\n    let best = s[0];\\n    for (let i = 0; i < N; ++i)\\n        dp[i][i] = 1;\\n    for (let j = 1; j < N; ++j) {\\n        for (let i = j - 1; 0 <= i; --i) {\\n            if (s[i] == s[j] && (i + 1 == j || dp[i + 1][j - 1])) {\\n                dp[i][j] = 1;\\n                if (best.length < j - i + 1)\\n                    best = s.substring(i, j + 1);\\n            }\\n        }\\n    }\\n    return best;\\n};\\n```\n```\\nclass Solution:\\n    def longestPalindrome(self, s: str) -> str:\\n        N = len(s)\\n        dp = [[False] * N for _ in range(N)]\\n        for i in range(N):\\n            dp[i][i] = True\\n        best = f\\'{s[0]}\\'\\n        for j in range(1, N):\\n            for i in range(j - 1, -1, -1):\\n                if s[i] == s[j] and (i + 1 == j or dp[i + 1][j - 1]):\\n                    dp[i][j] = True\\n                    if len(best) < j - i + 1:\\n                        best = s[i:j + 1]\\n        return best\\n```\n```\\ntype VC = Vec<char>;\\nimpl Solution {\\n    pub fn longest_palindrome(s: String) -> String {\\n        let N = s.len();\\n        let s: VC = s.chars().collect();\\n        let mut dp = vec![vec![false; N]; N];\\n        for i in 0..N {\\n            dp[i][i] = true;\\n        }\\n        let mut best: VC = vec![s[0]];\\n        for j in 1..N {\\n            for i in 0..j {\\n                dp[i][j] = s[i] == s[j] && (i + 1 == j || dp[i + 1][j - 1]);\\n                if dp[i][j] && best.len() < j - i + 1 {\\n                    best = s[i..=j].to_vec().into_iter().collect();\\n                }\\n            }\\n        }\\n        best.into_iter().collect()\\n    }\\n}\\n```\n```\\nclass Solution {\\npublic:\\n    using VI = vector<int>;\\n    using VVI = vector<VI>;\\n    string longestPalindrome(string s) {\\n        int N = s.size();\\n        VVI dp(N, VI(N));\\n        for (auto i{ 0 }; i < N; ++i)\\n            dp[i][i] = 1;\\n        auto best = string(1, s[0]);\\n        for (auto j{ 1 }; j < N; ++j) {\\n            for (auto i{ j - 1 }; 0 <= i; --i) {\\n                if (s[i] == s[j] && (i + 1 == j || dp[i + 1][j - 1])) {\\n                    dp[i][j] = 1;\\n                    if (best.size() < j - i + 1)\\n                        best = s.substr(i, j - i + 1);\\n                }\\n            }\\n        }\\n        return best;\\n    }\\n};\\n```\n```\\nlet longestPalindrome = s => {\\n    let N = s.length;\\n    if (!N) return \\'\\';\\n    let ans = s[0];\\n    let best = (i, j) => {\\n        if (ans.length < j - i + 1)      // +1 for i..j inclusive\\n            ans = s.substring(i, j + 1); // +1 for i..j inclusive \\uD83C\\uDFAF\\n    };\\n    let go = (i = 0, j = N - 1) => {\\n        if (j - i < 2) {\\n            if (s[i] == s[j]) {\\n                best(i, j);\\n                return true;\\n            }\\n            return false;\\n        }\\n        go(i + 1, j);           // case 1: the sub-problem without the character at index i\\n        go(i, j - 1);           // case 2: the sub-problem without the character at index j\\n        if (go(i + 1, j - 1)) { // case 3: the sub-problem without the character at index i and j\\n            if (s[i] == s[j]) {\\n                best(i, j);\\n                return true;\\n            }\\n        }\\n        return false;\\n    };\\n    go();\\n    return ans;\\n};\\n```\n```\\nclass Solution {\\npublic:\\n\\tstring longestPalindrome(string s) {\\n\\t\\tint N = s.size();\\n\\t\\tif (!N) return {};\\n\\t\\tstring ans{ s[0] };\\n\\t\\tgo(ans, s, 0, N - 1);\\n\\t\\treturn ans;\\n\\t}\\nprivate:\\n\\tbool go(string& ans, string& s, int i, int j) {\\n\\t\\tauto best = [&](auto i, auto j) {\\n\\t\\t\\tif (ans.size() < j - i + 1)        // +1 for i..j inclusive\\n\\t\\t\\t\\tans = s.substr(i, j - i + 1);  // +1 for i..j inclusive \\uD83C\\uDFAF\\n\\t\\t};\\n\\t\\tif (j - i < 2) {\\n\\t\\t\\tif (s[i] == s[j]) {\\n\\t\\t\\t\\tbest(i, j);\\n\\t\\t\\t\\treturn true;\\n\\t\\t\\t}\\n\\t\\t\\treturn false;\\n\\t\\t}\\n\\t\\tgo(ans, s, i + 1, j);           // case 1: the sub-problem without the character at index i\\n\\t\\tgo(ans, s, i, j - 1);           // case 2: the sub-problem without the character at index j\\n\\t\\tif (go(ans, s, i + 1, j - 1)) { // case 3: the sub-problem without the character at index i and j\\n\\t\\t\\tif (s[i] == s[j]) {\\n\\t\\t\\t\\tbest(i, j);\\n\\t\\t\\t\\treturn true;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn false;\\n\\t}\\n};\\n```\n```\\nlet longestPalindrome = s => {\\n    let N = s.length;\\n    if (!N) return \\'\\';\\n    let ans = s[0];\\n    let dp = [...Array(N)].map(row => Array(N).fill(false));\\n    for (let j = 1; j < N; ++j) {\\n        for (let i = j; i >= 0; --i) {\\n            dp[i][j] = s[i] == s[j] && (j - i < 2 || dp[i + 1][j - 1]);\\n            if (dp[i][j] && ans.length < j - i + 1)\\n                ans = s.substring(i, j + 1); // +1 for i..j inclusive \\uD83C\\uDFAF\\n        }\\n    }\\n    return ans;\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    using VI = vector<int>;\\n    using VVI = vector<VI>;\\n    string longestPalindrome(string s) {\\n        int N = s.size();\\n        if (!N) return {};\\n        VVI dp(N, VI(N));\\n        string ans{ s[0] };\\n        for (auto j{ 1 }; j < N; ++j) {\\n            for (auto i{ j }; i >= 0; --i) {\\n                dp[i][j] = s[i] == s[j] && (j - i < 2 || dp[i + 1][j - 1]);\\n                if (dp[i][j] && ans.size() < j - i + 1)\\n                    ans = s.substr(i, j - i + 1); // +1 for i..j inclusive \\uD83C\\uDFAF\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```\n```\\nlet longestPalindrome = (s, ans = \\'\\') => {\\n    let N = s.length;\\n    if (!N) return ans;\\n    ans = s[0];\\n    let expand = (i, j) => {\\n        for (; 0 <= i && j < N && s[i] == s[j]; --i, ++j)\\n            if (ans.length < j - i + 1)\\n                ans = s.substring(i, j + 1); // +1 for i..j inclusive \\uD83C\\uDFAF\\n    };\\n    for (let i = 0; i + 1 < N; ++i)\\n        expand(i, i),     // case 1: odd length palindrome\\n        expand(i, i + 1); // case 2: even length palindrome\\n    return ans;\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    string longestPalindrome(string s, string ans = {}) {\\n        int N = s.size();\\n        if (!N) return {};\\n        ans = s[0];\\n        auto expand = [&](auto i, auto j) {\\n            for (; 0 <= i && j < N && s[i] == s[j]; --i, ++j)\\n                if (ans.size() < j - i + 1)\\n                    ans = s.substr(i, j - i + 1); // +1 for i..j inclusive \\uD83C\\uDFAF\\n        };\\n        for (auto i{ 0 }; i + 1 < N; ++i)\\n            expand(i, i),     // case 1: odd length palindrome\\n            expand(i, i + 1); // case 2: even length palindrome\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2983,
                "title": "anyone-pass-the-test-in-python",
                "content": "When I use  Java, it just runs fine and passes the tests. \\nBut when I use the same algorithm in Python, it timesout every time.\\nGot any idea?\\n\\npython code :\\n\\n    def longestPalindrome(self, s):\\n            if len(s) == 0:\\n                return 0\\n            n = len(s)\\n            dp = [[False for i in xrange(n)] for j in xrange(n)]\\n            start = 0\\n            longest_len = 0\\n            for i in xrange(n):\\n                dp[i][i] = True\\n    \\n            for length in xrange(2,n+1):\\n                for i in xrange(0, n-length+1):\\n                    j = i+length-1\\n                    if s[i] == s[j] and (dp[i+1][j-1] or i+1>j-1):\\n                        dp[i][j] = True\\n                        if length > longest_len:\\n                            longest_len = length\\n                            start = i\\n            return s[start:longest_len+1]\\n\\njava code:\\n\\n    public String longestPalindrome(String s) {\\n            if(s==null||s.length()==1) return s;\\n            char[] str = s.toCharArray();\\n            boolean[][] bPald = new boolean[s.length()][s.length()];\\n            int start =0,end,maxLength=Integer.MIN_VALUE;\\n            for(int i=0;i<s.length();i++){\\n                bPald[i][i]=true;\\n            }\\n            for(int i=2;i<=s.length();i++){\\n                for(int j=0;j<s.length()-i+1;j++){\\n                    end = j+i-1;\\n                    if((str[j]==str[end]&&(bPald[j+1][end-1]||(j+1>end-1)))){\\n                        bPald[j][end]=true;\\n                        if(i>maxLength){\\n                            start=j;\\n                            maxLength = i;\\n                        }\\n                    }\\n                }\\n            }\\n            return s.substring(start,start+maxLength);\\n        }",
                "solutionTags": [],
                "code": "When I use  Java, it just runs fine and passes the tests. \\nBut when I use the same algorithm in Python, it timesout every time.\\nGot any idea?\\n\\npython code :\\n\\n    def longestPalindrome(self, s):\\n            if len(s) == 0:\\n                return 0\\n            n = len(s)\\n            dp = [[False for i in xrange(n)] for j in xrange(n)]\\n            start = 0\\n            longest_len = 0\\n            for i in xrange(n):\\n                dp[i][i] = True\\n    \\n            for length in xrange(2,n+1):\\n                for i in xrange(0, n-length+1):\\n                    j = i+length-1\\n                    if s[i] == s[j] and (dp[i+1][j-1] or i+1>j-1):\\n                        dp[i][j] = True\\n                        if length > longest_len:\\n                            longest_len = length\\n                            start = i\\n            return s[start:longest_len+1]\\n\\njava code:\\n\\n    public String longestPalindrome(String s) {\\n            if(s==null||s.length()==1) return s;\\n            char[] str = s.toCharArray();\\n            boolean[][] bPald = new boolean[s.length()][s.length()];\\n            int start =0,end,maxLength=Integer.MIN_VALUE;\\n            for(int i=0;i<s.length();i++){\\n                bPald[i][i]=true;\\n            }\\n            for(int i=2;i<=s.length();i++){\\n                for(int j=0;j<s.length()-i+1;j++){\\n                    end = j+i-1;\\n                    if((str[j]==str[end]&&(bPald[j+1][end-1]||(j+1>end-1)))){\\n                        bPald[j][end]=true;\\n                        if(i>maxLength){\\n                            start=j;\\n                            maxLength = i;\\n                        }\\n                    }\\n                }\\n            }\\n            return s.substring(start,start+maxLength);\\n        }",
                "codeTag": "Python3"
            },
            {
                "id": 3086,
                "title": "clear-c-solution",
                "content": "    string longestPalindrome(string s) {\\n    \\tif (s.size() == 0 || s.size() == 1)\\n    \\t\\treturn s;\\n    \\tint start = 0, maxlen = 1;\\n        for(int i=0; i<s.size(); i++){\\n            int j=i, k=i;\\n            while(k<s.size()-1 && s[k] == s[k+1])\\n                k++;\\n            while(j>0 && k<s.size()-1 && s[j-1] == s[k+1]){\\n                k++;\\n                j--;\\n            }\\n            if(k-j+1 > maxlen){\\n                maxlen = k-j+1;\\n                start = j;\\n            }\\n        }\\n        return s.substr(start, maxlen);\\n    }",
                "solutionTags": [],
                "code": "    string longestPalindrome(string s) {\\n    \\tif (s.size() == 0 || s.size() == 1)\\n    \\t\\treturn s;\\n    \\tint start = 0, maxlen = 1;\\n        for(int i=0; i<s.size(); i++){\\n            int j=i, k=i;\\n            while(k<s.size()-1 && s[k] == s[k+1])\\n                k++;\\n            while(j>0 && k<s.size()-1 && s[j-1] == s[k+1]){\\n                k++;\\n                j--;\\n            }\\n            if(k-j+1 > maxlen){\\n                maxlen = k-j+1;\\n                start = j;\\n            }\\n        }\\n        return s.substr(start, maxlen);\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 3329,
                "title": "share-an-o-n-solution",
                "content": "    class Solution{\\n    public:\\n\\tstring longestPalindrome(string s){\\n\\t\\tint size=s.size(),i;\\n\\t\\tchar *t=new char[2*size+2],*q=t;\\n\\t\\tint *p=new int[2*size+1],mx=0,id=0,MAX=0,center=0;\\n\\t\\tfor(*q='#',i=0;i<size;++i,*++q='#')*++q=s[i];\\n\\n\\t\\tfor(*++q=0,p[0]=i=1;t[i];i++) {\\n\\t\\t\\tp[i]=mx>i?min(p[2*id-i],mx-i):1;\\n\\t\\t\\twhile(i+p[i]<=2*size+1 && t[i+p[i]]==t[i-p[i]])p[i]++;\\n\\t\\t\\tif(i+p[i]>mx)mx=i+p[i],id=i;\\n\\t\\t\\tif(p[i]>MAX)MAX=p[i],center=i;\\n\\t\\t}\\n\\t\\tdelete(p),delete(t);\\n\\t\\treturn s.substr((center-MAX+1)/2,MAX-1);\\n\\t}\\n    };\\n\\nImplement of the Manacher's algorithm, O(n) complexity, just 12ms!",
                "solutionTags": [],
                "code": "class Solution{\\n    public:\\n\\tstring longestPalindrome(string s){\\n\\t\\tint size=s.size(),i;\\n\\t\\tchar *t=new char[2*size+2],*q=t;\\n\\t\\tint *p=new int[2*size+1],mx=0,id=0,MAX=0,center=0;\\n\\t\\tfor(*q='#',i=0;i<size;++i,*++q='#')*++q=s[i];\\n\\n\\t\\tfor(*++q=0,p[0]=i=1;t[i];i++) {\\n\\t\\t\\tp[i]=mx>i?min(p[2*id-i],mx-i):1;\\n\\t\\t\\twhile(i+p[i]<=2*size+1 && t[i+p[i]]==t[i-p[i]])p[i]++;\\n\\t\\t\\tif(i+p[i]>mx)mx=i+p[i],id=i;\\n\\t\\t\\tif(p[i]>MAX)MAX=p[i],center=i;\\n\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 3230,
                "title": "memory-limit-exceeded",
                "content": "I used DP to solve this problem. \\np[i][j] indicates whether sub string s[i...j] is a palindrome.\\nTo claim the two dimensional vector p[len][len], if I use \\n\\n    vector<vector<int> > p(len, vector<int>(len, 0));  \\n\\nIt will prompt \"Memory Limit Exceeded\"\\n\\nHowever, following works\\n\\n     int p[len][len];  \\n     memset(p, 0, len*len*sizeof(int));\\nCan anyone tell me the difference of the two? Many thanks in advance.",
                "solutionTags": [],
                "code": "I used DP to solve this problem. \\np[i][j] indicates whether sub string s[i...j] is a palindrome.\\nTo claim the two dimensional vector p[len][len], if I use \\n\\n    vector<vector<int> > p(len, vector<int>(len, 0));  \\n\\nIt will prompt \"Memory Limit Exceeded\"\\n\\nHowever, following works\\n\\n     int p[len][len];  \\n     memset(p, 0, len*len*sizeof(int));\\nCan anyone tell me the difference of the two? Many thanks in advance.",
                "codeTag": "Unknown"
            },
            {
                "id": 4094197,
                "title": "video-visualization-of-expand-from-centers-solution",
                "content": "https://youtu.be/E-tmN1OM9aA\\n\\nA brute force solution would first require generating every possible substring, which runs in O(n<sup>2</sup>) time.  Then, <i>for each</i> of those substrings, we have to check if they are a palindrome.  Since palindromes read the same forwards and backwards, we know that they have to be mirrored across the center.  So one way of testing for palindromes is to start in the middle of the string and work outwards, checking at each step to see if the characters are equal.  Since each palindrome check runs in O(n), the overall algorithm ends up running in O(n<sup>3</sup>) time.\\n\\nInstead, we can reduce this to O(n<sup>2</sup>) time by eliminating some redundant steps.  This is because we can find the longest palindromic substring for <i>all</i> substrings that have the <i>same</i> center in a single O(n) pass.  For example, if the string is `abcdedcfa`, and since we know that `e` is a palindrome by itself, then when we test `ded`, we don\\'t need to start from the center again.  We can only test the outer characters, the `d`.  And when we test `cdedc`, then since we know `ded` is a palindrome, again, we don\\'t need to start from the middle again.   We can just confirm that the `c`\\'s match up.\\n\\nNow if we expanded one more character, we would see that `b` does NOT equal `f`.  Not only does this mean that this substring is not a palindrome, it also means that all other longer palindromes centered on `e` won\\'t be palindromes either, so we don\\'t need to test the other substrings and we can just exit early.\\n\\nSo now the question is, how many different centers can a string have?  If the length of the substring is odd, then the center could be any of the characters.  If the length of the substring is even, then the center could lie <i>between</i> any two characters.  So in total, there are 2n - 1 centers (please see the video for a visualization of this).\\n\\nSo if visiting each center is O(n) and each palindrome check is O(n), then the algorithm now runs in O(n<sup>2</sup>) time.\\n\\n# Code\\n```\\nclass Solution:\\n    def longestPalindrome(self, s):\\n        def expand(l, r):\\n            while l >= 0 and r < len(s) and s[l] == s[r]:\\n                l -= 1\\n                r += 1\\n            return s[l+1:r]\\n\\n        result = \"\"\\n        for i in range(len(s)):\\n            sub1 = expand(i, i)\\n            if len(sub1) > len(result):\\n                result = sub1\\n            sub2 = expand(i, i+1)\\n            if len(sub2) > len(result):\\n                result = sub2\\n        return result\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "String",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution:\\n    def longestPalindrome(self, s):\\n        def expand(l, r):\\n            while l >= 0 and r < len(s) and s[l] == s[r]:\\n                l -= 1\\n                r += 1\\n            return s[l+1:r]\\n\\n        result = \"\"\\n        for i in range(len(s)):\\n            sub1 = expand(i, i)\\n            if len(sub1) > len(result):\\n                result = sub1\\n            sub2 = expand(i, i+1)\\n            if len(sub2) > len(result):\\n                result = sub2\\n        return result\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3985939,
                "title": "best-solution-on-leetcode",
                "content": "# **PLEASE UPVOTE MY SOLUTION IG YOU LIKE IT**\\n# **CONNECT WITH ME**\\n# **[https://www.linkedin.com/in/pratay-nandy-9ba57b229/]()**\\n# **[https://www.instagram.com/pratay_nandy/]()**\\n# Approach\\nInitialize start and maxLen variables to keep track of the starting index and maximum length of the palindromic substring found.\\n\\nLoop through each character c in the string s (from index 0 to n-1), treating it as the potential center of a palindrome.\\n\\nFor each center c, expand around it to find the longest palindromic substring. Check for both odd-length and even-length palindromes:\\n\\na. Odd-length palindrome: Expand around c by moving the left pointer left towards the left and the right pointer right towards the right, while checking if the characters at s[left] and s[right] are the same.\\n\\nb. Even-length palindrome: Expand around the center between c and c+1 by moving the left pointer left towards the left and the right pointer right towards the right, while checking if the characters at s[left] and s[right] are the same.\\n\\nCalculate the length of the palindrome found using right - left - 1.\\n\\nCompare the length of the current palindrome with the maxLen. If it\\'s greater, update maxLen and calculate the new start index of the longest palindrome.\\n\\nAfter iterating through all possible centers, use the start and maxLen to extract the longest palindromic substring using s.substr(start, maxLen).\\n\\nReturn the longest palindromic substring.\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:0(n*n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:0(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string longestPalindrome(string s) {\\n        int n = s.size();\\n        int start = 0, maxLen = 0;\\n\\n        for (int i = 0; i < n; i++) {\\n            // Check for odd length palindromes centered at i\\n            int len1 = expandAroundCenter(s, i, i);\\n            // Check for even length palindromes centered between i and i+1\\n            int len2 = expandAroundCenter(s, i, i + 1);\\n\\n            int len = max(len1, len2);\\n            if (len > maxLen) {\\n                maxLen = len;\\n                // Calculate starting index based on palindrome length\\n                start = i - (len - 1) / 2;\\n            }\\n        }\\n\\n        return s.substr(start, maxLen);\\n    }\\n\\nprivate:\\n    int expandAroundCenter(const string& s, int left, int right) {\\n        while (left >= 0 && right < s.size() && s[left] == s[right]) {\\n            left--;\\n            right++;\\n        }\\n        // Return the length of the palindrome found\\n        return right - left - 1;\\n    }\\n};\\n\\n```\\n\\n# Approach\\nint n = s.size();: This calculates the length of the input string s.\\n\\nstring ans; int maxi=0;: Initialize variables ans to store the longest palindromic substring found so far and maxi to store its length.\\n\\nvector<vector<int>> dp(n, vector<int>(n, 0));: Initialize a 2D vector dp of size n x n with all elements initially set to 0. The element dp[i][j] will store information about whether the substring from index i to index j is a palindrome and its length.\\n\\nThe nested loops using variables diff, i, and j iterate over different possible substrings of s.\\n\\ndiff represents the difference between j and i, indicating the length of the current substring being considered.\\n\\ni and j represent the starting and ending indices of the current substring under consideration.\\n\\nInside the loops, the code checks three cases to determine if the current substring is a palindrome:\\n\\nIf i and j are the same (i.e., single character), then the substring is a palindrome of length 1, so dp[i][j] is set to 1.\\n\\nIf the difference between j and i is 1 and the characters at these positions are the same, then the substring is a palindrome of length 2, so dp[i][j] is set to 2.\\n\\nFor other cases, the code checks if the characters at positions i and j are the same and if the substring within these positions (i+1 to j-1) is a palindrome. If both conditions are met, dp[i][j] is set to dp[i+1][j-1] + 2, indicating that the current substring is a palindrome of length dp[i+1][j-1] + 2.\\n\\nAfter updating dp[i][j], the code checks if the substring from index i to j is a palindrome (i.e., dp[i][j] is not 0) and if its length is greater than the current maxi. If both conditions are met, it updates maxi and sets ans to the substring using s.substr(i, maxi).\\n\\nFinally, the function returns the longest palindromic substring ans.\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:0(n*n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:0(n*n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string longestPalindrome(string s) {\\n        int n = s.size();\\n        string ans;\\n        int maxi=0;\\n        vector<vector<int>>dp(n,vector<int>(n,0));\\n        for(int diff=0;diff<n;diff++)\\n        {\\n            for(int i =0,j=i+diff;j<n;i++,j++)\\n            {\\n                if(i==j)\\n                {\\n                    // single letter is always a palindrome\\n                    dp[i][j]=1;\\n                }\\n                else if(diff==1)\\n                {\\n                    // if true then store 2 else 0 \\n                    dp[i][j]=(s[i]==s[j])?2:0;\\n                }\\n                else\\n                {\\n                    if(s[i]==s[j] && dp[i+1][j-1]!=0)\\n                    {\\n                        dp[i][j]=dp[i+1][j-1]+2;\\n                    }\\n                }\\n                if(dp[i][j] && j-i+1>maxi)\\n                {\\n                    maxi=j-i+1;\\n                    ans=s.substr(i,maxi);\\n                }\\n            }\\n        }\\n    return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "String",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string longestPalindrome(string s) {\\n        int n = s.size();\\n        int start = 0, maxLen = 0;\\n\\n        for (int i = 0; i < n; i++) {\\n            // Check for odd length palindromes centered at i\\n            int len1 = expandAroundCenter(s, i, i);\\n            // Check for even length palindromes centered between i and i+1\\n            int len2 = expandAroundCenter(s, i, i + 1);\\n\\n            int len = max(len1, len2);\\n            if (len > maxLen) {\\n                maxLen = len;\\n                // Calculate starting index based on palindrome length\\n                start = i - (len - 1) / 2;\\n            }\\n        }\\n\\n        return s.substr(start, maxLen);\\n    }\\n\\nprivate:\\n    int expandAroundCenter(const string& s, int left, int right) {\\n        while (left >= 0 && right < s.size() && s[left] == s[right]) {\\n            left--;\\n            right++;\\n        }\\n        // Return the length of the palindrome found\\n        return right - left - 1;\\n    }\\n};\\n\\n```\n```\\nclass Solution {\\npublic:\\n    string longestPalindrome(string s) {\\n        int n = s.size();\\n        string ans;\\n        int maxi=0;\\n        vector<vector<int>>dp(n,vector<int>(n,0));\\n        for(int diff=0;diff<n;diff++)\\n        {\\n            for(int i =0,j=i+diff;j<n;i++,j++)\\n            {\\n                if(i==j)\\n                {\\n                    // single letter is always a palindrome\\n                    dp[i][j]=1;\\n                }\\n                else if(diff==1)\\n                {\\n                    // if true then store 2 else 0 \\n                    dp[i][j]=(s[i]==s[j])?2:0;\\n                }\\n                else\\n                {\\n                    if(s[i]==s[j] && dp[i+1][j-1]!=0)\\n                    {\\n                        dp[i][j]=dp[i+1][j-1]+2;\\n                    }\\n                }\\n                if(dp[i][j] && j-i+1>maxi)\\n                {\\n                    maxi=j-i+1;\\n                    ans=s.substr(i,maxi);\\n                }\\n            }\\n        }\\n    return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3911431,
                "title": "python-beats-99-expanding-around-centers-approach-explained",
                "content": "# Intuition: Expanding Around Centers\\n\\nThe idea behind this approach is to consider every character in the string as a potential center of a palindrome and then expand around that center to find the longest palindromic substring.\\n\\nThere are two cases to consider for the center: \\n- One where the palindrome has an odd length (centered at a single character)\\n\\n![Image 002.png](https://assets.leetcode.com/users/images/ea3dbc12-fa80-4416-a2c4-413af3ecb415_1692270331.4220665.png)\\n\\n- Other where the palindrome has an even length (centered between two characters). \\n\\n![Image 001.png](https://assets.leetcode.com/users/images/30f5580c-2251-403f-90dd-606ee0f3b4d4_1692270361.2039485.png)\\n\\nBy considering both cases, the algorithm effectively explores all possible palindromic substrings.\\n\\n# Approach\\n1. The expandAroundCenter function is defined within the main function. This helper function takes two parameters, left and right, which represent the potential center indices of the palindrome being expanded. It tries to expand the palindrome by moving left to the left and right to the right while the characters at these indices are the same.\\n\\n1. The main function initializes an empty string longest to keep track of the longest palindromic substring found so far.\\n\\n1. It iterates through the characters of the input string s using a for loop. For each character at index i, it considers two possible cases for the center of the palindrome:\\n\\n1. Odd-length palindrome: The center is the character at index i.\\nEven-length palindrome: The center is between the characters at indices i and i + 1.\\n1. For each center, the expandAroundCenter function is called to find the longest palindromic substring that can be formed by expanding from that center.\\n\\n1. The lengths of the obtained palindromic substrings (palindrome1 and palindrome2) are compared with the length of the current longest palindromic substring. If the length of a newly found palindrome is greater, the longest is updated with that palindrome.\\n\\nFinally, the function returns the longest palindromic substring.\\n\\n# Complexity\\n- Time complexity:\\nThe main loop runs for each character in the string, and for each character, the expandAroundCenter function takes linear time to expand the palindrome. Hence, the total time complexity is O(N^2), where N is the length of the input string.\\n\\n- Space complexity:\\nThe space complexity is O(1) as no additional data structures are used that grow with the input size.\\n\\n# Code\\n```\\nclass Solution(object):\\n    def longestPalindrome(self, s):\\n        def expandAroundCenter(left, right):\\n            while left >= 0 and right < len(s) and s[left] == s[right]:\\n                left -= 1\\n                right += 1\\n            return s[left + 1:right]\\n\\n        longest = \"\"\\n        for i in range(len(s)):\\n            # Odd length palindrome\\n            palindrome1 = expandAroundCenter(i, i)\\n            # Even length palindrome\\n            palindrome2 = expandAroundCenter(i, i + 1)\\n\\n            if len(palindrome1) > len(longest):\\n                longest = palindrome1\\n            if len(palindrome2) > len(longest):\\n                longest = palindrome2\\n\\n        return longest\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Two Pointers",
                    "String",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution(object):\\n    def longestPalindrome(self, s):\\n        def expandAroundCenter(left, right):\\n            while left >= 0 and right < len(s) and s[left] == s[right]:\\n                left -= 1\\n                right += 1\\n            return s[left + 1:right]\\n\\n        longest = \"\"\\n        for i in range(len(s)):\\n            # Odd length palindrome\\n            palindrome1 = expandAroundCenter(i, i)\\n            # Even length palindrome\\n            palindrome2 = expandAroundCenter(i, i + 1)\\n\\n            if len(palindrome1) > len(longest):\\n                longest = palindrome1\\n            if len(palindrome2) > len(longest):\\n                longest = palindrome2\\n\\n        return longest\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3274605,
                "title": "java-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nSolved using DP.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n^2)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(s^2)\\n\\n# Code\\n```\\nclass Solution {\\n    public String longestPalindrome(String s) {\\n        boolean dp[][]=new boolean[s.length()][s.length()];\\n\\t\\tint a=0;\\n\\t\\tint b=0;\\n\\t\\tfor(int gap=0;gap<s.length();gap++) {\\n\\t\\t\\tfor(int i=0,j=gap;j<s.length();i++,j++) {\\n\\t\\t\\t\\tif(gap==0) {\\n\\t\\t\\t\\t\\tdp[i][j]=true;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\telse if(gap==1) {\\n\\t\\t\\t\\t\\tif(s.charAt(i)==s.charAt(j)) {\\n\\t\\t\\t\\t\\t\\tdp[i][j]=true;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\telse {\\n\\t\\t\\t\\t\\t\\tdp[i][j]=false;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\telse {\\n\\t\\t\\t\\t\\tif(s.charAt(i)==s.charAt(j) && dp[i+1][j-1]==true) {\\n\\t\\t\\t\\t\\t\\tdp[i][j]=true;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\telse {\\n\\t\\t\\t\\t\\t\\tdp[i][j]=false;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tif(dp[i][j]) {\\n\\t\\t\\t\\t\\ta=i;\\n\\t\\t\\t\\t\\tb=j;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn s.substring(a,b+1);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public String longestPalindrome(String s) {\\n        boolean dp[][]=new boolean[s.length()][s.length()];\\n\\t\\tint a=0;\\n\\t\\tint b=0;\\n\\t\\tfor(int gap=0;gap<s.length();gap++) {\\n\\t\\t\\tfor(int i=0,j=gap;j<s.length();i++,j++) {\\n\\t\\t\\t\\tif(gap==0) {\\n\\t\\t\\t\\t\\tdp[i][j]=true;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\telse if(gap==1) {\\n\\t\\t\\t\\t\\tif(s.charAt(i)==s.charAt(j)) {\\n\\t\\t\\t\\t\\t\\tdp[i][j]=true;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\telse {\\n\\t\\t\\t\\t\\t\\tdp[i][j]=false;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\telse {\\n\\t\\t\\t\\t\\tif(s.charAt(i)==s.charAt(j) && dp[i+1][j-1]==true) {\\n\\t\\t\\t\\t\\t\\tdp[i][j]=true;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\telse {\\n\\t\\t\\t\\t\\t\\tdp[i][j]=false;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tif(dp[i][j]) {\\n\\t\\t\\t\\t\\ta=i;\\n\\t\\t\\t\\t\\tb=j;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn s.substring(a,b+1);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2718979,
                "title": "python-solution-readable-code-with-thorough-explanation",
                "content": "# Intuition\\nIt took me a while to understand the solutions that other people were offering and the reason was simple, it\\'s because they all have terrible coding practices. Code should be easily read regardless of the space and time efficiency. \\n\\nSo this wasn\\'t necessarily my intuition and I tweaked what I saw in a way that I could and hopefully you understand. The idea is to expand outwards from any given index and determine if those sets of indices create a palindrome.\\n\\n\\n# Approach\\nThe explanation for this is pretty simple. We start at index = 0 and iterate through all values until n. At each index we call the function expandOutwards that will check the values to the left and right of the provided indices. It will continue to do so until the longest palindrome within the given range is found. \\n\\nIf you\\'re wondering why we call expandOutwards twice, look at the difference in values passed. A palindrome can have an even or odd set of values, so if we only account for scenarios where only one occurs, we will only get half the answer. \\n\\n\\n# Complexity\\n- Time complexity:\\nThe worst case time complexity is O(n^2). As we may need to check all values in a string everytime. You could probably visual this with an input like \"aaaaaaaaa\", where all values are always equal, so it checks everything. Notice that our program needs to check a string n^2 that can be easily confirmed as a palindrome, possible room for improvement. \\n\\n- Space complexity:\\nThis one can be tricky, but our space complexity is O(n) worst case. Pay close attention to the variable temp, i and k. They are all allocated within a local space that iterates for at most n times. Because each iteration needs a new area in memory, the space each requires directly correlates to the size of the input. In reality the space complexity is closer to 5n, but we remove the constant and just say n. \\n\\n# Notes: \\nIf you have any questions or ways to improve this code, please discuss it below. Hopefully this helps someone. Best regards.\\n\\n# Code\\n```\\nclass Solution:\\n    def longestPalindrome(self, s: str) -> str:\\n        \\n        n = len(s) # Length of the input\\n\\n        if n == 1:\\n            return s\\n\\n        def expandOutwards(start, end):\\n\\n            i = start\\n            k = end\\n\\n            if s[i] != s[k]:\\n                return \"\"\\n\\n            while(i-1 >= 0 and k+1 < n and s[i-1] == s[k+1]): \\n                i-=1\\n                k+=1\\n\\n            return s[i:k+1]\\n\\n        pal1 = \"\"\\n        pal2 = \"\"\\n        longPal = \"\"\\n\\n        for i in range(0, n-1):\\n\\n            pal1 = expandOutwards(i, i)\\n            pal2 = expandOutwards(i, i+1)\\n\\n            # Conditional assignment statement\\n            temp = pal1 if len(pal1) > len(pal2) else pal2\\n\\n            if len(temp) > len(longPal):\\n                longPal = temp\\n        \\n        return longPal\\n\\n                \\n            \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def longestPalindrome(self, s: str) -> str:\\n        \\n        n = len(s) # Length of the input\\n\\n        if n == 1:\\n            return s\\n\\n        def expandOutwards(start, end):\\n\\n            i = start\\n            k = end\\n\\n            if s[i] != s[k]:\\n                return \"\"\\n\\n            while(i-1 >= 0 and k+1 < n and s[i-1] == s[k+1]): \\n                i-=1\\n                k+=1\\n\\n            return s[i:k+1]\\n\\n        pal1 = \"\"\\n        pal2 = \"\"\\n        longPal = \"\"\\n\\n        for i in range(0, n-1):\\n\\n            pal1 = expandOutwards(i, i)\\n            pal2 = expandOutwards(i, i+1)\\n\\n            # Conditional assignment statement\\n            temp = pal1 if len(pal1) > len(pal2) else pal2\\n\\n            if len(temp) > len(longPal):\\n                longPal = temp\\n        \\n        return longPal\\n\\n                \\n            \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2628442,
                "title": "simple-recursive-memoization-code",
                "content": "class Solution {\\npublic:\\n\\n    int solve(const string &s,vector<vector<int>> &dp, int i, int j){\\n        \\n        if(i==j || i>j) return 1;   \\n        if(dp[i][j]!=-1)return dp[i][j];\\n        \\n        if(s[i]==s[j]) dp[i][j]=solve(s,dp,i+1,j-1);\\n        else dp[i][j]=0;\\n        \\n        solve(s,dp,i+1,j);\\n        solve(s,dp,i,j-1);\\n      \\n        return dp[i][j];  \\n    }\\n    \\n    string longestPalindrome(string s) {\\n        \\n        int n=s.length();\\n        vector<vector<int>> dp(n+1,vector<int>(n+1,-1));\\n\\n        solve(s,dp,0,n-1);\\n        int x=0,y=0;\\n        \\n        for(int i=0; i<=n; i++)\\n            for(int j=i+1; j<=n; j++)\\n                if(dp[i][j]==1 && j-i>y-x) x=i,y=j;\\n        \\n        return s.substr(x,y-x+1);\\n    }\\n};",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "class Solution {\\npublic:\\n\\n    int solve(const string &s,vector<vector<int>> &dp, int i, int j){\\n        \\n        if(i==j || i>j) return 1;   \\n        if(dp[i][j]!=-1)return dp[i][j];\\n        \\n        if(s[i]==s[j]) dp[i][j]=solve(s,dp,i+1,j-1);\\n        else dp[i][j]=0;\\n        \\n        solve(s,dp,i+1,j);\\n        solve(s,dp,i,j-1);\\n      \\n        return dp[i][j];  \\n    }",
                "codeTag": "Java"
            },
            {
                "id": 2176873,
                "title": "go-o-n-2-with-hashmap",
                "content": "```\\nfunc longestPalindrome(s string) string {\\n    if len(s) < 2 {return s}\\n    \\n    res := fmt.Sprintf(\"%c\", s[0])\\n    \\n    var isPalindromic func(string) bool\\n    isPalindromic = func(str string) bool {\\n        if len(str) < 2 {return true}\\n        \\n        l, r := 0, len(str) - 1\\n        \\n        for l < r {\\n            if str[l] != str[r] {\\n                return false\\n            }\\n            \\n            l++\\n            r--\\n        }\\n        \\n        return true\\n    }\\n    \\n    m := make(map[byte][]int)\\n    \\n    for i := 0; i < len(s); i++ {\\n        m[s[i]] = append(m[s[i]], i)\\n        \\n        if len(m[s[i]]) > 1 {\\n            for _, val := range m[s[i]] {\\n                if i != val && isPalindromic(s[val:i+1]) {\\n                    if i - val + 1 > len(res) {\\n                        res = s[val:i+1]\\n                    }\\n                }\\n            }\\n        }\\n    }\\n    \\n    return res\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc longestPalindrome(s string) string {\\n    if len(s) < 2 {return s}\\n    \\n    res := fmt.Sprintf(\"%c\", s[0])\\n    \\n    var isPalindromic func(string) bool\\n    isPalindromic = func(str string) bool {\\n        if len(str) < 2 {return true}\\n        \\n        l, r := 0, len(str) - 1\\n        \\n        for l < r {\\n            if str[l] != str[r] {\\n                return false\\n            }\\n            \\n            l++\\n            r--\\n        }\\n        \\n        return true\\n    }\\n    \\n    m := make(map[byte][]int)\\n    \\n    for i := 0; i < len(s); i++ {\\n        m[s[i]] = append(m[s[i]], i)\\n        \\n        if len(m[s[i]]) > 1 {\\n            for _, val := range m[s[i]] {\\n                if i != val && isPalindromic(s[val:i+1]) {\\n                    if i - val + 1 > len(res) {\\n                        res = s[val:i+1]\\n                    }\\n                }\\n            }\\n        }\\n    }\\n    \\n    return res\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2169666,
                "title": "easy-c-solution-dp",
                "content": "```\\nclass Solution {\\npublic:\\n    string longestPalindrome(string s) {\\n        int n = s.size();\\n        vector<vector<bool>> dp(s.size(), vector<bool>(n, false));\\n        int ans=0, start;\\n        for(int i=0; i<n; ++i)\\n            for(int j=0; j+i<n; ++j){\\n                if(i==0)    dp[j][j+i] = true;\\n                else if(i==1 and s[j]==s[j+i]) dp[j][j+i] = true;\\n                else if(i>1 and s[j]==s[j+i] and dp[j+1][j+i-1]) dp[j][j+i] = true;\\n                if(dp[j][j+i])  ans = i, start=j;\\n            }\\n        return s.substr(start,ans+1);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string longestPalindrome(string s) {\\n        int n = s.size();\\n        vector<vector<bool>> dp(s.size(), vector<bool>(n, false));\\n        int ans=0, start;\\n        for(int i=0; i<n; ++i)\\n            for(int j=0; j+i<n; ++j){\\n                if(i==0)    dp[j][j+i] = true;\\n                else if(i==1 and s[j]==s[j+i]) dp[j][j+i] = true;\\n                else if(i>1 and s[j]==s[j+i] and dp[j+1][j+i-1]) dp[j][j+i] = true;\\n                if(dp[j][j+i])  ans = i, start=j;\\n            }\\n        return s.substr(start,ans+1);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2157123,
                "title": "longest-palindrome-map-different-approach",
                "content": "Hi All,\\n\\nThere are many dp solution for this problem, but I want to try without using dp so I went for Map implementation.\\n\\nBasic idea behind map implementation is any string of size one is a palindrome and a string can be palindrome only if has any previous occurance, so store the indexes of all the previous occurances in a map and check for palindrome.\\n\\n1. we can iterate through the given string once \\n2. read each charecter one by one and see if it has any previous occurance\\n3. if its not first occurance check if the substring is returning as palindrome\\n4. check the maximum length size and return the substring which has maximum length.\\n\\nKindly upvote if this is helpful or like my effort.. Happy learning..\\n\\n```\\npublic String longestPalindrome(String s) {\\n        int max = 0;\\n        String res = \"\";\\n        TreeMap<Character, List<Integer>> map = new TreeMap<>();\\n        for(int j=0; j<s.length(); j++){\\n        \\tchar ch = s.charAt(j);\\n        \\tList<Integer> list = new ArrayList<Integer>();\\n        \\tif(map.containsKey(ch)){\\n        \\t\\tlist.addAll(map.get(ch));\\n        \\t}\\n        \\tlist.add(j);\\n        \\tfor(int i:list){\\n        \\t\\tif(isPalindrome(s.substring(i, j+1))){\\n        \\t\\t\\tif(max<j-i+1){\\n        \\t\\t\\t\\tmax = j-i+1;\\n        \\t\\t\\t\\tres = s.substring(i, j+1);\\n        \\t\\t\\t}\\n        \\t\\t}\\n        \\t}\\n        \\tmap.put(ch, list);\\n        }\\n        return res;\\n    }\\n    \\n\\tprivate boolean isPalindrome(String ori) {\\n\\t\\tif(ori.length()==1)\\n\\t\\t\\treturn true;\\n\\t\\tfor(int i=0; i<ori.length()/2; i++)\\n\\t\\t\\tif(ori.charAt(i)!=ori.charAt(ori.length()-1-i))\\n\\t\\t\\t\\treturn false;\\n\\t\\treturn true;\\n\\t}",
                "solutionTags": [
                    "Java"
                ],
                "code": "Hi All,\\n\\nThere are many dp solution for this problem, but I want to try without using dp so I went for Map implementation.\\n\\nBasic idea behind map implementation is any string of size one is a palindrome and a string can be palindrome only if has any previous occurance, so store the indexes of all the previous occurances in a map and check for palindrome.\\n\\n1. we can iterate through the given string once \\n2. read each charecter one by one and see if it has any previous occurance\\n3. if its not first occurance check if the substring is returning as palindrome\\n4. check the maximum length size and return the substring which has maximum length.\\n\\nKindly upvote if this is helpful or like my effort.. Happy learning..\\n\\n```\\npublic String longestPalindrome(String s) {\\n        int max = 0;\\n        String res = \"\";\\n        TreeMap<Character, List<Integer>> map = new TreeMap<>();\\n        for(int j=0; j<s.length(); j++){\\n        \\tchar ch = s.charAt(j);\\n        \\tList<Integer> list = new ArrayList<Integer>();\\n        \\tif(map.containsKey(ch)){\\n        \\t\\tlist.addAll(map.get(ch));\\n        \\t}\\n        \\tlist.add(j);\\n        \\tfor(int i:list){\\n        \\t\\tif(isPalindrome(s.substring(i, j+1))){\\n        \\t\\t\\tif(max<j-i+1){\\n        \\t\\t\\t\\tmax = j-i+1;\\n        \\t\\t\\t\\tres = s.substring(i, j+1);\\n        \\t\\t\\t}\\n        \\t\\t}\\n        \\t}\\n        \\tmap.put(ch, list);\\n        }\\n        return res;\\n    }\\n    \\n\\tprivate boolean isPalindrome(String ori) {\\n\\t\\tif(ori.length()==1)\\n\\t\\t\\treturn true;\\n\\t\\tfor(int i=0; i<ori.length()/2; i++)\\n\\t\\t\\tif(ori.charAt(i)!=ori.charAt(ori.length()-1-i))\\n\\t\\t\\t\\treturn false;\\n\\t\\treturn true;\\n\\t}",
                "codeTag": "Unknown"
            },
            {
                "id": 1934817,
                "title": "manacher-s-algorithm-with-detailed-explanation-examples-derived-from-expanding-from-indices",
                "content": "The Idea of Manacher\\'s Algorithm is basically the same as expanding from each index but with memoization optimization .\\n\\nThus let\\'s first understand the unoptimized solution - expanding from each index.\\n# Expanding from each index\\n\\n## Step 1 - Insert bogus characters\\n\\nThe reason for inserting bogus characters is that we can cover both even and odd substring length with the same expanding algorithm to determine if current substring is palindromic.\\n\\n![image](https://assets.leetcode.com/users/images/90711e7d-ca57-4c81-8863-b8c1bf0cd9f0_1649640805.6467702.png)\\n\\n```\\n    // Step1 insert bogus character\\n    var buffer bytes.Buffer\\n    buffer.WriteByte(\\'*\\')\\n    for i := 0 ;i < len(s);i ++ {\\n        buffer.WriteByte(s[i])\\n        buffer.WriteByte(\\'*\\')\\n    }\\n    sp := buffer.String()\\n    /***\\n    with bugos characters inserted, we only have to conver the case of expanding from a single point\\n    This is because when expanding from \"*\" we are covering the even length case eg, \"a*b\"\\n    \\n    babad => *b*a*b*a*d*\\n    cbbd => *c*b*b*d*\\n    \\n    ***/\\n```\\n\\n## Step2 - Expanding from each index and look for palindromic substring\\n\\n* loop through our new string(with bogus)\\n* expand around each index to find the maximum radius  from that index.\\n* record the starting index and the radius if the radius is better than previous best radius.\\n\\n![image](https://assets.leetcode.com/users/images/7b607ef7-a679-416a-805e-a89061ffb9b1_1649641583.4892864.png)\\n\\n```\\n\\tcenter := 0\\n    radius := 0\\n    for center < len(sp) {\\n        for center-radius-1 >= 0 && center+radius+1 < len(sp){\\n            if sp[center-radius-1] == sp[center+radius+1] {\\n                radius++  \\n            } else {\\n                break\\n            }\\n        }\\n\\t\\t\\n        if radius >= max {\\n            max = radius\\n            maxIdx = center\\n        }\\n\\t\\t\\n        center++\\n        radius = 0\\n    }\\n```\\n---\\n## Step 3 - Construct our answer\\n#### Notice we use *i += 2*  when advancing the index to skip all \"*\" in the substring\\n```\\n\\tss := sp[maxIdx-max: maxIdx+max+1]\\n    buffer.Reset()\\n    for i := 1 ; i < len(ss); i+=2 {\\n        buffer.WriteByte(ss[i])\\n    }\\n\\t\\n    return buffer.String()\\n```\\n---\\n# Optimize with Cache\\n## Caching Previous Answers\\nInstead of simply replacing *maxIdx* and *maxRadius* each time, we will cache the *radius* of each index in a int array\\n\\nThis is a bit inefficient compare to our previous step 2, because we need to loop through our cache to find the maxIndex and maxRadius,\\nand we are using more space. But, it\\'s worth it, we will see why it is the case in the next step.\\n```\\n  \\n    dp := make([]int, len(sp))\\n    center := 0\\n    radius := 0\\n    for center < len(sp) {\\n        for center-radius-1 >= 0 && center+radius+1 < len(sp){\\n            if sp[center-radius-1] == sp[center+radius+1] {\\n                radius++  \\n            } else {\\n                break\\n            }\\n        }\\n        dp[center] = radius\\n        center++\\n        radius = 0\\n\\t}\\n\\tmax := 0\\n    maxIdx := 0\\n    for i := 0 ; i< len(dp); i++ {\\n        if dp[i] > max {\\n           max = dp[i]\\n           maxIdx = i\\n        }\\n    }\\n```\\n\\n\\n## Utilizing Previous Radius to Save Computation \\nAfter we successfully process some index (expand around i) and for this index we have a positive radius (meaning we have a palindromic substring) , we can easily determine (in some cases) the next few radius starting from *i +1* ending at *i + radius*\\n\\nLet\\'s consider this situation:\\n![image](https://assets.leetcode.com/users/images/70ff2759-b05f-4e92-8be9-ec2d2be0905d_1649643430.1442566.png)\\n\\nNotice how index 4 and 6, index 3 and 7 are mirrored.\\n![image](https://assets.leetcode.com/users/images/dc4618ab-f72e-4a91-935f-3fbb62821f1b_1649643704.2999575.png)\\n\\nThe question here is, can we determine index 6\\'s radius by utilizing index 4\\'s radius?\\nAnd can we get index 7\\'s radius by utilizing index 3\\'s radius?\\n\\nThe answer is yes. We need to consider three cases;\\n\\n----\\n\\n#### Let\\'s first consider index 6 with \\'a\\'\\n\\nAt index 4, we have radius of 0, that means the longest palindromic substring expanding from index 4 is \"a\" by its self\\n\\nAnd more importantly, the entire substring is contained by the palindromic substring starting from 3 ending at 7\\n\\n![image](https://assets.leetcode.com/users/images/0af9820e-49d4-4e3e-b8d3-081094ba9ce8_1649699043.7512739.png)\\n\\n\\nThus, with a bit more thinking we come to the conclusion, for some index i coming after center and before upperbound (inclusive), if the mirrored index of i has radius of R, and i + R <= upperBound, then Radius at i is equal to i\\'s mirror\\'s Radius.\\n\\n\\n----\\n\\n### Then consider index 7 with \\'c\\'\\n\\nAt index 3, we have the mirror of index 7.\\nIndex 3 expands to a palindromic substring with radius 3\\n![image](https://assets.leetcode.com/users/images/2c04b252-0733-41a1-8a2c-42df9f682f6a_1649644566.4374194.png)\\n\\nSince index 3 is the center of a palindromic string with radius 3\\nThus, the substring starting at 0 ending at 2, should be the mirror image of substring starting at 4 ending at 6\\n\\nIf index 7 is the center of a palindromic string with radius 3\\nThen, index 8 to 10 should be the mirror image of index 0 to 2\\n\\n\\n---\\n\\n### BUT \\nif that\\'s the cause, the Palindromic string centered at 5 should have a Radius of 5 instead what we actually have a Radius of 2.\\n\\n![image](https://assets.leetcode.com/users/images/1d5484be-5804-45d8-ad8b-6effce841355_1649644951.216274.png)\\n\\n\\n\\n![image](https://assets.leetcode.com/users/images/6b563c12-c4ce-49ab-8aa7-011f2852d3ad_1649699355.075187.png)\\n\\nWith further analysis we can come to the conclusion: for index i coming after the center and before the upperbound,\\nif the mirrored index has a radius that is greater than the distance from i to upperbound, then index i expands to a Palindromic string with radius *upperbound - i*\\n\\n----\\n### Therefore \\n\\nWhen  radius of mirror index does not equal to upperbound - i, we can get the Radius of Index i by looking at the Radius of Index i\\'s mirror.\\n\\npseudo code\\n```\\nif (RadiusOf(mirrorI) != upperBound - i) {\\n\\tRadiusOf(i) = MinOf( RadiusOf(mirrorI), upperBound - i)\\n}\\n```\\n\\n\\n### Finally we have the last case to consider\\n\\nWhen distance from i to upperbound is equal to the radius of the mirrored index of i, we can\\'t have a determinant answer for radius of i.\\n\\nConsider this example:\\n![image](https://assets.leetcode.com/users/images/d4d58735-3edb-4233-a195-94ee9a24f9ed_1649645497.2187436.png)\\n\\n\\nNotice the mirroed C has a radius of 1, which equals to the distance between the latter C and the upper bound.\\nIn this case, we can\\'t decide the Radius of the latter C.\\n\\n![image](https://assets.leetcode.com/users/images/1b788514-3be4-4aff-b8b8-087757ce6ae1_1649645788.2858694.png)\\n\\nThus in this case, we need to expand from the latter C to find out its Radius.\\nGood news is that we don\\'t have to start from Radius 0, we can simply start from Mirrored Radius or the distance between C and upperbound.\\n\\n---\\n\\n## Some Math\\n\\n![image](https://assets.leetcode.com/users/images/346ced13-8389-47a8-a008-1804a0aca792_1649646536.4637523.png)\\n\\n----\\nfor case 1 and 2, we just need to find MinOf( mmr, mirroredRadius), then increment center by 1, set radius to 0\\nfor case 3, we should increment the center index and let the radius = mmr\\n```\\n\\t    oldCenter, oldRadius := center,radius\\n        upperBound := oldCenter + oldRadius\\n        \\n        center++\\n        radius = 0\\n        for center <= upperBound {\\n            mirror := 2*oldCenter - center\\n            mmr := upperBound - center\\n            \\n            if dp[mirror] == mmr {\\n                radius = mmr\\n                break\\n            } \\n            \\n            dp[center] = minOf(dp[mirror], mmr)\\n            center++\\n        }\\n```\\n\\n## Conclusion\\nThe full solution (You can probably optimize this solution even more)\\n```\\nfunc longestPalindrome(s string) string {\\n    // Step 1\\n    var buffer bytes.Buffer\\n    buffer.WriteByte(\\'*\\')\\n    for i := 0 ;i < len(s);i ++ {\\n        buffer.WriteByte(s[i])\\n        buffer.WriteByte(\\'*\\')\\n    }\\n    sp := buffer.String()\\n    \\n    // Step2\\n    dp := make([]int, len(sp))\\n    center := 0\\n    radius := 0\\n    for center < len(sp) {\\n        for center-radius-1 >= 0 && center+radius+1 < len(sp){\\n            if sp[center-radius-1] == sp[center+radius+1] {\\n                radius++  \\n            } else {\\n                break\\n            }\\n        }\\n        dp[center] = radius\\n        \\n        oldCenter, oldRadius := center,radius\\n        upperBound := oldCenter+oldRadius\\n        \\n        center++\\n        radius = 0\\n        for center <= upperBound {\\n            mirror := 2*oldCenter - center\\n            mmr := upperBound - center\\n            \\n            if dp[mirror] == mmr {\\n                radius = mmr\\n                break\\n            } \\n            \\n            dp[center] = minOf(dp[mirror], mmr)\\n            center++\\n        }\\n    }\\n\\t\\n\\t//Step 3\\n    \\n    max := 0\\n    maxIdx := 0\\n    for i := 0 ; i< len(dp); i++ {\\n        if dp[i] > max {\\n            max = dp[i]\\n            maxIdx = i\\n        }\\n    }\\n    ss := sp[maxIdx-max: maxIdx+max+1]\\n    buffer.Reset()\\n    for i := 1 ; i < len(ss); i+=2 {\\n        buffer.WriteByte(ss[i])\\n    }\\n    return buffer.String()\\n}\\n\\nfunc minOf(a,b int) int {\\n    if a < b {\\n        return a\\n    }\\n    return b\\n}\\n```",
                "solutionTags": [
                    "Go",
                    "Dynamic Programming"
                ],
                "code": "```\\n    // Step1 insert bogus character\\n    var buffer bytes.Buffer\\n    buffer.WriteByte(\\'*\\')\\n    for i := 0 ;i < len(s);i ++ {\\n        buffer.WriteByte(s[i])\\n        buffer.WriteByte(\\'*\\')\\n    }\\n    sp := buffer.String()\\n    /***\\n    with bugos characters inserted, we only have to conver the case of expanding from a single point\\n    This is because when expanding from \"*\" we are covering the even length case eg, \"a*b\"\\n    \\n    babad => *b*a*b*a*d*\\n    cbbd => *c*b*b*d*\\n    \\n    ***/\\n```\n```\\n\\tcenter := 0\\n    radius := 0\\n    for center < len(sp) {\\n        for center-radius-1 >= 0 && center+radius+1 < len(sp){\\n            if sp[center-radius-1] == sp[center+radius+1] {\\n                radius++  \\n            } else {\\n                break\\n            }\\n        }\\n\\t\\t\\n        if radius >= max {\\n            max = radius\\n            maxIdx = center\\n        }\\n\\t\\t\\n        center++\\n        radius = 0\\n    }\\n```\n```\\n\\tss := sp[maxIdx-max: maxIdx+max+1]\\n    buffer.Reset()\\n    for i := 1 ; i < len(ss); i+=2 {\\n        buffer.WriteByte(ss[i])\\n    }\\n\\t\\n    return buffer.String()\\n```\n```\\n  \\n    dp := make([]int, len(sp))\\n    center := 0\\n    radius := 0\\n    for center < len(sp) {\\n        for center-radius-1 >= 0 && center+radius+1 < len(sp){\\n            if sp[center-radius-1] == sp[center+radius+1] {\\n                radius++  \\n            } else {\\n                break\\n            }\\n        }\\n        dp[center] = radius\\n        center++\\n        radius = 0\\n\\t}\\n\\tmax := 0\\n    maxIdx := 0\\n    for i := 0 ; i< len(dp); i++ {\\n        if dp[i] > max {\\n           max = dp[i]\\n           maxIdx = i\\n        }\\n    }\\n```\n```\\nif (RadiusOf(mirrorI) != upperBound - i) {\\n\\tRadiusOf(i) = MinOf( RadiusOf(mirrorI), upperBound - i)\\n}\\n```\n```\\n\\t    oldCenter, oldRadius := center,radius\\n        upperBound := oldCenter + oldRadius\\n        \\n        center++\\n        radius = 0\\n        for center <= upperBound {\\n            mirror := 2*oldCenter - center\\n            mmr := upperBound - center\\n            \\n            if dp[mirror] == mmr {\\n                radius = mmr\\n                break\\n            } \\n            \\n            dp[center] = minOf(dp[mirror], mmr)\\n            center++\\n        }\\n```\n```\\nfunc longestPalindrome(s string) string {\\n    // Step 1\\n    var buffer bytes.Buffer\\n    buffer.WriteByte(\\'*\\')\\n    for i := 0 ;i < len(s);i ++ {\\n        buffer.WriteByte(s[i])\\n        buffer.WriteByte(\\'*\\')\\n    }\\n    sp := buffer.String()\\n    \\n    // Step2\\n    dp := make([]int, len(sp))\\n    center := 0\\n    radius := 0\\n    for center < len(sp) {\\n        for center-radius-1 >= 0 && center+radius+1 < len(sp){\\n            if sp[center-radius-1] == sp[center+radius+1] {\\n                radius++  \\n            } else {\\n                break\\n            }\\n        }\\n        dp[center] = radius\\n        \\n        oldCenter, oldRadius := center,radius\\n        upperBound := oldCenter+oldRadius\\n        \\n        center++\\n        radius = 0\\n        for center <= upperBound {\\n            mirror := 2*oldCenter - center\\n            mmr := upperBound - center\\n            \\n            if dp[mirror] == mmr {\\n                radius = mmr\\n                break\\n            } \\n            \\n            dp[center] = minOf(dp[mirror], mmr)\\n            center++\\n        }\\n    }\\n\\t\\n\\t//Step 3\\n    \\n    max := 0\\n    maxIdx := 0\\n    for i := 0 ; i< len(dp); i++ {\\n        if dp[i] > max {\\n            max = dp[i]\\n            maxIdx = i\\n        }\\n    }\\n    ss := sp[maxIdx-max: maxIdx+max+1]\\n    buffer.Reset()\\n    for i := 1 ; i < len(ss); i+=2 {\\n        buffer.WriteByte(ss[i])\\n    }\\n    return buffer.String()\\n}\\n\\nfunc minOf(a,b int) int {\\n    if a < b {\\n        return a\\n    }\\n    return b\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1485213,
                "title": "swift-solution",
                "content": "```\\nclass Solution {\\n    func longestPalindrome(_ s: String) -> String {\\n        var result = \"\"\\n        for index in 0 ..< s.count {\\n            let temp = getLongestPalindrome(i: index, s: s)\\n            if temp.count > result.count {\\n                result = temp\\n            }\\n        }\\n        return result\\n    }\\n\\n    func getLongestPalindrome(i: Int, s: String) -> String {\\n        var left = i\\n        var right = i\\n        let charArr = Array(s)\\n\\n        while (left - 1 >= 0 && charArr[left] == charArr[left - 1]) {\\n            left -= 1\\n        }\\n\\n        while (right + 1 < charArr.count && charArr[right] == charArr[right + 1]) {\\n            right += 1\\n        }\\n\\n        while (left - 1 >= 0 && right + 1 < charArr.count && charArr[left - 1] == charArr[right + 1]) {\\n            left -= 1\\n            right += 1\\n        }\\n\\n        return String(charArr[left ... right])\\n    }\\n}\\n```",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nclass Solution {\\n    func longestPalindrome(_ s: String) -> String {\\n        var result = \"\"\\n        for index in 0 ..< s.count {\\n            let temp = getLongestPalindrome(i: index, s: s)\\n            if temp.count > result.count {\\n                result = temp\\n            }\\n        }\\n        return result\\n    }\\n\\n    func getLongestPalindrome(i: Int, s: String) -> String {\\n        var left = i\\n        var right = i\\n        let charArr = Array(s)\\n\\n        while (left - 1 >= 0 && charArr[left] == charArr[left - 1]) {\\n            left -= 1\\n        }\\n\\n        while (right + 1 < charArr.count && charArr[right] == charArr[right + 1]) {\\n            right += 1\\n        }\\n\\n        while (left - 1 >= 0 && right + 1 < charArr.count && charArr[left - 1] == charArr[right + 1]) {\\n            left -= 1\\n            right += 1\\n        }\\n\\n        return String(charArr[left ... right])\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1224561,
                "title": "dynamic-programming-python-c-commented-solution",
                "content": "python\\n```\\nclass Solution:\\n    def longestPalindrome(self, s: str) -> str:\\n        # Dynamic Programming\\n        n = len(s)\\n        # Default to pick the first element if no palindrom found longer than 1\\n        longest, begin = 1, 0\\n        dp = [[None] * n for _ in range(n)]\\n        # All charactors itself is a palindrom:\\\\\\n        for i in range(n):\\n            dp[i][i] = True\\n        # Try all possible substring lengths\\n        for length in range(2, n + 1):\\n            # Try all starting point\\n            for start in range(n):\\n                # Get ending index\\n                end = start + length - 1\\n                # Check if end index is larger than the total length\\n                if end >= n:\\n                    break\\n                # s[start : end] will only be palindrom is the first and the last element is the same\\n                if s[start] != s[end]:\\n                    dp[start][end] = False\\n                else:\\n                    # s[start : end] will be a palendrom if [start + 1 : end - 1] is a panlindrom\\n                    if length <= 2:\\n                        dp[start][end] = True\\n                    else:\\n                        dp[start][end] = dp[start + 1][end - 1]\\n                # If s[start : end] is palindrom, compare the length with max length\\n                if dp[start][end]:\\n                    if length > longest:\\n                        longest = length\\n                        begin = start\\n        return s[begin : begin + longest]\\n```\\n\\nc\\n```\\nchar * longestPalindrome(char * s){\\n    // Dynamic Programming\\n    int n = strlen(s);\\n    // Default the begin and longest so that we can pick the first element if no palindrom longer than 1 charactor can be found\\n    int begin = 0;\\n    int longest = 1;\\n    // dp array\\n    bool dp[n][n];\\n    memset( dp, false, n*n*sizeof(bool) );\\n    \\n    // Base case: only one charactor\\n    for (int i = 0; i < n; i++)\\n    {\\n        dp[i][i] = true;\\n    }\\n    \\n    // Sub questions: substring with length of x\\n    for (int length = 2; length <= n; length++)\\n    {\\n        // Sub questions: substring with starting index of x\\n        for (int start = 0; start < n; start++)\\n        {\\n            int end = start + length - 1;\\n            // No need to check if end is out of bound\\n            if (end >= n)\\n            {\\n                break;\\n            }\\n            \\n            // Palindrom only exist when start and end are the same\\n            if (s[start] != s[end])\\n            {\\n                dp[start][end] = false;\\n            }\\n            else\\n            {\\n                // When length is 1 or 2, no need to check if it contains any palindrom substring\\n                if (length <= 2)\\n                {\\n                    dp[start][end] = true;\\n                }\\n                // Check if one index smaller at the beginning and the end is a palindrom substring\\n                else\\n                {\\n                    dp[start][end] = dp[start+1][end-1];\\n                }\\n            }\\n            // Check it the current substing is a palindrom\\n            if (dp[start][end])\\n            {\\n                // Compare the current substring with the longest\\n                if (length > longest)\\n                {\\n                    longest = length;\\n                    begin = start;\\n                }\\n            }\\n        }\\n    }\\n    // Get target substring\\n    char *result = malloc(n+1);\\n    strncpy(result, s+begin, longest);\\n    // Set the last index as ending char so that result is a string.\\n    result[longest] = 0;\\n    return result;\\n    \\n}\\n```",
                "solutionTags": [
                    "Python",
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution:\\n    def longestPalindrome(self, s: str) -> str:\\n        # Dynamic Programming\\n        n = len(s)\\n        # Default to pick the first element if no palindrom found longer than 1\\n        longest, begin = 1, 0\\n        dp = [[None] * n for _ in range(n)]\\n        # All charactors itself is a palindrom:\\\\\\n        for i in range(n):\\n            dp[i][i] = True\\n        # Try all possible substring lengths\\n        for length in range(2, n + 1):\\n            # Try all starting point\\n            for start in range(n):\\n                # Get ending index\\n                end = start + length - 1\\n                # Check if end index is larger than the total length\\n                if end >= n:\\n                    break\\n                # s[start : end] will only be palindrom is the first and the last element is the same\\n                if s[start] != s[end]:\\n                    dp[start][end] = False\\n                else:\\n                    # s[start : end] will be a palendrom if [start + 1 : end - 1] is a panlindrom\\n                    if length <= 2:\\n                        dp[start][end] = True\\n                    else:\\n                        dp[start][end] = dp[start + 1][end - 1]\\n                # If s[start : end] is palindrom, compare the length with max length\\n                if dp[start][end]:\\n                    if length > longest:\\n                        longest = length\\n                        begin = start\\n        return s[begin : begin + longest]\\n```\n```\\nchar * longestPalindrome(char * s){\\n    // Dynamic Programming\\n    int n = strlen(s);\\n    // Default the begin and longest so that we can pick the first element if no palindrom longer than 1 charactor can be found\\n    int begin = 0;\\n    int longest = 1;\\n    // dp array\\n    bool dp[n][n];\\n    memset( dp, false, n*n*sizeof(bool) );\\n    \\n    // Base case: only one charactor\\n    for (int i = 0; i < n; i++)\\n    {\\n        dp[i][i] = true;\\n    }\\n    \\n    // Sub questions: substring with length of x\\n    for (int length = 2; length <= n; length++)\\n    {\\n        // Sub questions: substring with starting index of x\\n        for (int start = 0; start < n; start++)\\n        {\\n            int end = start + length - 1;\\n            // No need to check if end is out of bound\\n            if (end >= n)\\n            {\\n                break;\\n            }\\n            \\n            // Palindrom only exist when start and end are the same\\n            if (s[start] != s[end])\\n            {\\n                dp[start][end] = false;\\n            }\\n            else\\n            {\\n                // When length is 1 or 2, no need to check if it contains any palindrom substring\\n                if (length <= 2)\\n                {\\n                    dp[start][end] = true;\\n                }\\n                // Check if one index smaller at the beginning and the end is a palindrom substring\\n                else\\n                {\\n                    dp[start][end] = dp[start+1][end-1];\\n                }\\n            }\\n            // Check it the current substing is a palindrom\\n            if (dp[start][end])\\n            {\\n                // Compare the current substring with the longest\\n                if (length > longest)\\n                {\\n                    longest = length;\\n                    begin = start;\\n                }\\n            }\\n        }\\n    }\\n    // Get target substring\\n    char *result = malloc(n+1);\\n    strncpy(result, s+begin, longest);\\n    // Set the last index as ending char so that result is a string.\\n    result[longest] = 0;\\n    return result;\\n    \\n}\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1671198,
                "content": [
                    {
                        "username": "ZenMasterV",
                        "content": "Seems like too many of the  coding wunderkinds here lack basic reading comprehension skills \\n\" Please don\\'t post any solutions in this discussion tab\"\\nIt\\'s almost the rule to find the exact opposite for the discussion of every question. I don\\'t want to see your damned solution!"
                    },
                    {
                        "username": "NeroXIII",
                        "content": "[@charonme](/charonme) name does not check out :((("
                    },
                    {
                        "username": "192731",
                        "content": "and if they do?"
                    },
                    {
                        "username": "plevi1995",
                        "content": "Excellent comment"
                    },
                    {
                        "username": "khan60939",
                        "content": "Can anyone tell how DP is being used here? "
                    },
                    {
                        "username": "sandagolcea",
                        "content": "[@charonme](/charonme) my thinking exactly, but at least they should create a flag to help us moderate and move solutions to the correct tab. Would only need a stack overflow moderation-like system: one person flags, another person receives a queue of flagged comments and confirms the tagging.. oh well"
                    },
                    {
                        "username": "charonme",
                        "content": "maybe people get confused by the official leetcode comment which says: \"If you\\'d like to share a detailed solution to the problem, please create a new post in the discuss section\"\\nMaybe some time ago they didn\\'t have a separate solutions section and only recently changed it, but left some of the old solutions in the discussion section and didn\\'t fix the automated comment worting?"
                    },
                    {
                        "username": "klanjewar037",
                        "content": "hehe"
                    },
                    {
                        "username": "sanemdeepak",
                        "content": "For input \"ac\" test case is expecting \"a\" as output, how is just \"a\" a palindromic string?"
                    },
                    {
                        "username": "ayushiidevpura",
                        "content": "because when we read \"a\" from forward it results in \"a\" and at the same time when we read \"a\" from backward it is still \"a\""
                    },
                    {
                        "username": "beyzigo",
                        "content": "Because if you read the string \"a\" backwards it will still be \"a\""
                    },
                    {
                        "username": "tsafackghokeng",
                        "content": "[@Chouhan_Gourav](/Chouhan_Gourav) the test case said \"ac\" not \"a\". is \"ac\" palindromic? for \"a\" i understand"
                    },
                    {
                        "username": "CODEWITHABHINAV",
                        "content": "you have to submit the first string as your answer read more about this question on gFg\\n"
                    },
                    {
                        "username": "_BREEZE_",
                        "content": "any string is palindrome if we read it same from front and from back\\nin single character we read it same from front and back"
                    },
                    {
                        "username": "oinrup",
                        "content": "yes thats my question too"
                    },
                    {
                        "username": "yldemon",
                        "content": "Any character in the string by itself is a palindromic substring. So in the case where there is no palindromic substring with length > 1, you can return any character."
                    },
                    {
                        "username": "Chouhan_Gourav",
                        "content": "Whenever you come accross such contradiction, just google the definition, any. Any string is called is pallindromic if the reverse of the string is equal to the original string. Reverse of \\'a\\' is \\'a\\'. Hope you get this."
                    },
                    {
                        "username": "947876275",
                        "content": "This post is for learner wanna practice DP.\\nThe basic idea is, if we wanna say \"aba\" is palindromic, then we need to firstly confirm that \"b\" is palindromic, then we also need to check if \"a\"(the first a) = \"a\" (the second a).\\n\\nM is a 2-d array which stores boolean values.\\nM[i][j] indicates if string[i.....j] is palindromic.\\nSo base cases are:\\nM[i][i] is true.\\nM[i][i + 1] = (s[i] == s[i + 1]);\\nrecurrence relation is :\\nM[i][j] = (s[i] == s[j] AND M[i + 1][j - 1]);\\nFor the implementation of recurrence relation, one idea is you can loop through all possible symmetry axis. For each of the axis, you expand at both RHS and LHS simultaneously. This method promises that when you are determining value in M[i][j], M[i + 1][j - 1] must have the correct value.\\nFinal answer can be found from all M[i][j] == 1 with largest (j - i)."
                    },
                    {
                        "username": "Msey",
                        "content": "thank you, cat brother"
                    },
                    {
                        "username": "user0558y",
                        "content": "I understand the solution but I don't understand why it needs any storage at all or why it needs to be a DP solution.\n\nThe condition `(s[i] == s[j] AND M[i + 1][j - 1])` requires you to memorise if `M[i+1][j-1]` is true, that's easy to understand. However, if you expand each possible axis at the same time, i.e. 1st iteration (s[i+1], s[j-1]), 2nd iteration `s[i+2], s[j-2]`, ... It is guaranteed that M[i+1][j-1] is always true and hence can be dropped, and you should break the loop when it is not true.\n\nIn summary, you don't need to memorise anything at all and you just need to check `s[i] == s[j]` while expanding in both directions at the same time, unless I have misunderstood anything? Here is an implementation of your algorithm but without storage: https://leetcode.com/problems/longest-palindromic-substring/submissions/868540120/"
                    },
                    {
                        "username": "taras",
                        "content": "Thank you! this is a beautiful explanation, though I\\'m not sure what exactly you mean by expanding both on LHS and RHS. In my implementation it\\'s enough to compute all diagonals of  the upper right triangle of the dp matrix."
                    },
                    {
                        "username": "klu_2100031593",
                        "content": "super explanation"
                    },
                    {
                        "username": "napoleon",
                        "content": "My Solution Is Naive, It Cost O(n^2), Is there Any Solution faster?"
                    },
                    {
                        "username": "leocampos",
                        "content": "[@tylerprill-rhdc](/tylerprill-rhdc) So, what I did was:\nStated in my mind the Brute Force approach - create every possible substring and test each one to see if is a palindrome and find the longest.\n\nOf course this would be ridiculously slow, so let's improve it.\nI also mentally stated that a palindrome has a recursive aspect -> if single char, or two equal chars, or charX + palindrome + charX\nSo I created a isPalindrome recursive method that checked it delegating to itself extracting the borders.\n\nSince a palindrome must start and end with the same char, in my traverse of the string, I started storing the position of each character Map<Character, List< Integer>>, so I would just go back to the previous found Char and check if from there to the current pointer I would have a Palindrome.\n\nThen I stopped doing this for every possible palindrome, I then started doing only for the ones that COULD be longer than the already found longest palindrome. That accelerated a lot.\n\nIn the almost last step, I added memoization. Remember that a palindrome is like a sandwich, with the external chars being equal and the meat being another palindrome? So I stored the found palindromes using their start and and positions. So I could check if that had already being checked and if so, either return true or false directly.\n\nThe final step was to convert the recursive function to an iterative function to save some memory used by the call stack.\nMaybe there are better implementations, just sharing my thought process."
                    },
                    {
                        "username": "tylerprill-rhdc",
                        "content": "[@tylerprill-rhdc](/tylerprill-rhdc) Two pointer based solution is also a really good solve here"
                    },
                    {
                        "username": "tylerprill-rhdc",
                        "content": "This could be done in a single pass algorithm, but will inherently check character indices multiple times based on the nature of the problem. (basically, iterate through each, then bubble out from each index)"
                    },
                    {
                        "username": "neetika",
                        "content": "From the leetcode blog, one of the methods of solving this is:\\n\\nA common mistake:\\nSome people will be tempted to come up with a quick solution, which is unfortunately flawed (however can be corrected easily):\\n\\nReverse S and become S\\u2019. Find the longest common substring between S and S\\u2019, which must also be the longest palindromic substring.\\nThis seemed to work, let\\u2019s see some examples below.\\n\\nFor example,\\nS = \\u201ccaba\\u201d, S\\u2019 = \\u201cabac\\u201d.\\nThe longest common substring between S and S\\u2019 is \\u201caba\\u201d, which is the answer.\\n\\nLet\\u2019s try another example:\\nS = \\u201cabacdfgdcaba\\u201d, S\\u2019 = \\u201cabacdgfdcaba\\u201d.\\nThe longest common substring between S and S\\u2019 is \\u201cabacd\\u201d. Clearly, this is not a valid palindrome.\\n\\n**We could see that the longest common substring method fails when there exists a reversed copy of a non-palindromic substring in some other part of S. To rectify this, each time we find a longest common substring candidate, we check if the substring\\u2019s indices are the same as the reversed substring\\u2019s original indices. If it is, then we attempt to update the longest palindrome found so far; if not, we skip this and find the next candidate.**\\n\\nIs this part correct? \\n\\nexample string: abcxycba\\nreverse string:  abcxycba\\n\\nThe substring indices are same as reversed string original indices and yet it is not a palindrome?"
                    },
                    {
                        "username": "HRVY_SNOWDEN",
                        "content": "cool sirr:)\\n"
                    },
                    {
                        "username": "dhtmlkitchen",
                        "content": "WRONG.\\n\\nabcxycba reversed is abcyxcba."
                    },
                    {
                        "username": "travisl12",
                        "content": "After I solved this problem I thought it\\'d be interesting to see how it worked in realtime.\\n\\nhttps://codepen.io/TravisL12/pen/pogvweg"
                    },
                    {
                        "username": "user3907vj",
                        "content": "thanks for the \"nanananananana\" from all the small things ;)"
                    },
                    {
                        "username": "zapataast",
                        "content": "u are crazy"
                    },
                    {
                        "username": "sondq98",
                        "content": "very intuitive"
                    },
                    {
                        "username": "Tathagat017",
                        "content": "thank you\\n"
                    },
                    {
                        "username": "mikler",
                        "content": "So I think I finally understood logic of test creators. \\nEven if you write a classical DP or memorization solution for this one you will timeout on latest tests.\\nI think they consider it edge cases. Because if you add one simple line it will pass! OMG. \\nI have leet code for this. Instead of solving problems I spend hours optimizing the constants.\\n\\nif s == s[::-1]: return s"
                    },
                    {
                        "username": "Vectorido",
                        "content": "Don\\'t work already. Time limit at 141 test even with that construction."
                    },
                    {
                        "username": "deepalithakur17",
                        "content": "It will only work in python."
                    },
                    {
                        "username": "ishogbon",
                        "content": "Its memoization, not memorization "
                    },
                    {
                        "username": "84danie",
                        "content": "I submitted my solution, and received a Time Limit Exceeded on this test case:\\n\\n\"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaabcaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"\\n\\nSo I copied and pasted the TC into a custom test case, and started to think about what I could tweak. However, I ended up accidentally hitting Run Code, but instead of getting a Time Limit Exceeded result, it passed:\\n\\n![0_1479079812693_upload-4af9e94c-2e53-4915-acf6-782780c7bf8b](/uploads/files/1479079813717-upload-4af9e94c-2e53-4915-acf6-782780c7bf8b.png) \\n\\nIs this supposed to happen and I just need to make my code more efficient, or is this a bug? \\n![0_1479079956817_upload-1ef15826-d6e6-4bde-9c06-eb597c5c8d0e](/uploads/files/1479079957639-upload-1ef15826-d6e6-4bde-9c06-eb597c5c8d0e.png)"
                    },
                    {
                        "username": "RitikaSahay",
                        "content": "Same thing happened with me. Is there a solution for it?\\n"
                    },
                    {
                        "username": "danicruz0415",
                        "content": "It\\'s happened to me a couple of times. My theory is that the time limit is given for the whole list of test cases. Thus, you can have your test pass, but it will still time limit exceed because it wont get to calculate all the test cases before the time runs out. I cannot confirm this but I think its true because with a very unoptimized solution I got time limit exceeded very early in the test cases (for another problem), after some optimizations I got it much later (like getting to the last tests) which themselves were around the same size, so if the time limit was set per test it would not make sense to fail in a similarly long test-case just that is much later in the test list. (I think the same would apply to memory limit exceeded)"
                    },
                    {
                        "username": "him_Sarma619",
                        "content": "The exact same situation happened with me in one problem... it was a DP problem too... I was getting a Memory Limit Exceeded error with the memoized solution but it was running fine in the Run Code button."
                    },
                    {
                        "username": "Hubro",
                        "content": "I\\'m getting \"Time Limit Exceeded\" with 141/141 testcases passed and \"Last Executed Input\" is:\\n\\n```\\ns =\\n```\\n\\nDid I break it?"
                    },
                    {
                        "username": "karan_dhiman",
                        "content": "same issue"
                    },
                    {
                        "username": "BLANK-Zora",
                        "content": "exactly bro this shit is recked , like it is giving tests outside the constraints , how am i suppose to include such things in the code"
                    },
                    {
                        "username": "arunprep5",
                        "content": "same issue. java"
                    },
                    {
                        "username": "blasphelmy",
                        "content": "[@tuancoltech](/tuancoltech) it worked when i rewrote the code in c# instead of c++"
                    },
                    {
                        "username": "tuancoltech",
                        "content": "[@blasphelmy](/blasphelmy) [@Tomas Sandven](/Hubro) Did you guys find out why? I got the same issue."
                    },
                    {
                        "username": "blasphelmy",
                        "content": "i got that too. im not sure whats going on given that the constraint for input is between 1 and 1000"
                    },
                    {
                        "username": "Vinitajain",
                        "content": "Hi All,\\nI have a test case which is failing, but I feel the testcase result is incorrect.Please refer the screenshot below.\\n![image](https://assets.leetcode.com/users/images/e9e42efb-63d5-4cfa-b420-f1926674f6dc_1654838015.8394327.png)\\n\\nThe longest palindromic substring is \"aaca\" but the test case result is \"aca\". Anyone else faced this problem?"
                    },
                    {
                        "username": "OthSO",
                        "content": "[@mohdansah10](/mohdansah10) \\nthey are separated in the input with \"bd\" so it is not a valid answer "
                    },
                    {
                        "username": "mohdansah10",
                        "content": "I\\'m getting same error, but different case:\\nInput\\ns =\\n\"aacabdkacaa\"\\n\\nOutput\\n\"aacakacaa\"\\nExpected\\n\"aca\"\\n\\nBut mine is Palindrome"
                    },
                    {
                        "username": "hasmithraa",
                        "content": "the expected is correct because aaca can\\'t be a palindrome only \\'aacaa\\' can be a palindrome which is not there in your case"
                    },
                    {
                        "username": "Amish_Singh",
                        "content": "how are you considering \"aaca\" as a palindromic substring, \"aca\" is a palindrome and it is the longest"
                    },
                    {
                        "username": "Shaik_Aman_Sayer",
                        "content": "dude you really came up with the solution "
                    },
                    {
                        "username": "AryaAditya3609",
                        "content": "how is \"aaca\" and \"acaa\" same ???\\nWhile \"aca\" is palindrome because both \"aca\" and reverse of it \"aca\" is same !!"
                    },
                    {
                        "username": "alexandra-pickle",
                        "content": "\"aaca\" is not a palindrome"
                    },
                    {
                        "username": "bugHackerLoop",
                        "content": "I followed the approach leant by Aditya Verma DP lectures and encountered the same test case failing. Does the logic where I reverse the string and calculate the longest common substring doesn\\'t work here? I know it works for longest palindromic subsequence but here it fails for such test cases .. why is it so?"
                    },
                    {
                        "username": "mductran",
                        "content": "how is \\'aaca\\' a palindrome? when read backward it\\'s \\'acaa\\' so it\\'s not the same reading forward."
                    },
                    {
                        "username": "jnsudhir",
                        "content": "Check my solution, it was able to clear test case \"aaca\". Explained code in comments.\\n\\nhttps://leetcode.com/problems/longest-palindromic-substring/solutions/3091016/longest-palindromic-substring-using-javascript-beats-94-82-in-runtime-explained/?orderBy=most_votes"
                    },
                    {
                        "username": "nikhileshratna",
                        "content": "aaca is not palindrome"
                    },
                    {
                        "username": "sunshine77",
                        "content": "hey, iam getting the same error, i have seen ansewrs where they have totally changed the algorithm, how did u solve this by tweaking the same algoirhtm"
                    },
                    {
                        "username": "bhupendrabc71",
                        "content": "how come \"aaca\" is palindrome. it should be \"aca\""
                    },
                    {
                        "username": "just11blocks",
                        "content": "aaca is not a palindrome...aacaa and aca are."
                    },
                    {
                        "username": "odi1n",
                        "content": "I also encountered this problem"
                    },
                    {
                        "username": "vamsi2302",
                        "content": "I think you get it by now!\\n"
                    }
                ]
            },
            {
                "id": 1565544,
                "content": [
                    {
                        "username": "ZenMasterV",
                        "content": "Seems like too many of the  coding wunderkinds here lack basic reading comprehension skills \\n\" Please don\\'t post any solutions in this discussion tab\"\\nIt\\'s almost the rule to find the exact opposite for the discussion of every question. I don\\'t want to see your damned solution!"
                    },
                    {
                        "username": "NeroXIII",
                        "content": "[@charonme](/charonme) name does not check out :((("
                    },
                    {
                        "username": "192731",
                        "content": "and if they do?"
                    },
                    {
                        "username": "plevi1995",
                        "content": "Excellent comment"
                    },
                    {
                        "username": "khan60939",
                        "content": "Can anyone tell how DP is being used here? "
                    },
                    {
                        "username": "sandagolcea",
                        "content": "[@charonme](/charonme) my thinking exactly, but at least they should create a flag to help us moderate and move solutions to the correct tab. Would only need a stack overflow moderation-like system: one person flags, another person receives a queue of flagged comments and confirms the tagging.. oh well"
                    },
                    {
                        "username": "charonme",
                        "content": "maybe people get confused by the official leetcode comment which says: \"If you\\'d like to share a detailed solution to the problem, please create a new post in the discuss section\"\\nMaybe some time ago they didn\\'t have a separate solutions section and only recently changed it, but left some of the old solutions in the discussion section and didn\\'t fix the automated comment worting?"
                    },
                    {
                        "username": "klanjewar037",
                        "content": "hehe"
                    },
                    {
                        "username": "sanemdeepak",
                        "content": "For input \"ac\" test case is expecting \"a\" as output, how is just \"a\" a palindromic string?"
                    },
                    {
                        "username": "ayushiidevpura",
                        "content": "because when we read \"a\" from forward it results in \"a\" and at the same time when we read \"a\" from backward it is still \"a\""
                    },
                    {
                        "username": "beyzigo",
                        "content": "Because if you read the string \"a\" backwards it will still be \"a\""
                    },
                    {
                        "username": "tsafackghokeng",
                        "content": "[@Chouhan_Gourav](/Chouhan_Gourav) the test case said \"ac\" not \"a\". is \"ac\" palindromic? for \"a\" i understand"
                    },
                    {
                        "username": "CODEWITHABHINAV",
                        "content": "you have to submit the first string as your answer read more about this question on gFg\\n"
                    },
                    {
                        "username": "_BREEZE_",
                        "content": "any string is palindrome if we read it same from front and from back\\nin single character we read it same from front and back"
                    },
                    {
                        "username": "oinrup",
                        "content": "yes thats my question too"
                    },
                    {
                        "username": "yldemon",
                        "content": "Any character in the string by itself is a palindromic substring. So in the case where there is no palindromic substring with length > 1, you can return any character."
                    },
                    {
                        "username": "Chouhan_Gourav",
                        "content": "Whenever you come accross such contradiction, just google the definition, any. Any string is called is pallindromic if the reverse of the string is equal to the original string. Reverse of \\'a\\' is \\'a\\'. Hope you get this."
                    },
                    {
                        "username": "947876275",
                        "content": "This post is for learner wanna practice DP.\\nThe basic idea is, if we wanna say \"aba\" is palindromic, then we need to firstly confirm that \"b\" is palindromic, then we also need to check if \"a\"(the first a) = \"a\" (the second a).\\n\\nM is a 2-d array which stores boolean values.\\nM[i][j] indicates if string[i.....j] is palindromic.\\nSo base cases are:\\nM[i][i] is true.\\nM[i][i + 1] = (s[i] == s[i + 1]);\\nrecurrence relation is :\\nM[i][j] = (s[i] == s[j] AND M[i + 1][j - 1]);\\nFor the implementation of recurrence relation, one idea is you can loop through all possible symmetry axis. For each of the axis, you expand at both RHS and LHS simultaneously. This method promises that when you are determining value in M[i][j], M[i + 1][j - 1] must have the correct value.\\nFinal answer can be found from all M[i][j] == 1 with largest (j - i)."
                    },
                    {
                        "username": "Msey",
                        "content": "thank you, cat brother"
                    },
                    {
                        "username": "user0558y",
                        "content": "I understand the solution but I don't understand why it needs any storage at all or why it needs to be a DP solution.\n\nThe condition `(s[i] == s[j] AND M[i + 1][j - 1])` requires you to memorise if `M[i+1][j-1]` is true, that's easy to understand. However, if you expand each possible axis at the same time, i.e. 1st iteration (s[i+1], s[j-1]), 2nd iteration `s[i+2], s[j-2]`, ... It is guaranteed that M[i+1][j-1] is always true and hence can be dropped, and you should break the loop when it is not true.\n\nIn summary, you don't need to memorise anything at all and you just need to check `s[i] == s[j]` while expanding in both directions at the same time, unless I have misunderstood anything? Here is an implementation of your algorithm but without storage: https://leetcode.com/problems/longest-palindromic-substring/submissions/868540120/"
                    },
                    {
                        "username": "taras",
                        "content": "Thank you! this is a beautiful explanation, though I\\'m not sure what exactly you mean by expanding both on LHS and RHS. In my implementation it\\'s enough to compute all diagonals of  the upper right triangle of the dp matrix."
                    },
                    {
                        "username": "klu_2100031593",
                        "content": "super explanation"
                    },
                    {
                        "username": "napoleon",
                        "content": "My Solution Is Naive, It Cost O(n^2), Is there Any Solution faster?"
                    },
                    {
                        "username": "leocampos",
                        "content": "[@tylerprill-rhdc](/tylerprill-rhdc) So, what I did was:\nStated in my mind the Brute Force approach - create every possible substring and test each one to see if is a palindrome and find the longest.\n\nOf course this would be ridiculously slow, so let's improve it.\nI also mentally stated that a palindrome has a recursive aspect -> if single char, or two equal chars, or charX + palindrome + charX\nSo I created a isPalindrome recursive method that checked it delegating to itself extracting the borders.\n\nSince a palindrome must start and end with the same char, in my traverse of the string, I started storing the position of each character Map<Character, List< Integer>>, so I would just go back to the previous found Char and check if from there to the current pointer I would have a Palindrome.\n\nThen I stopped doing this for every possible palindrome, I then started doing only for the ones that COULD be longer than the already found longest palindrome. That accelerated a lot.\n\nIn the almost last step, I added memoization. Remember that a palindrome is like a sandwich, with the external chars being equal and the meat being another palindrome? So I stored the found palindromes using their start and and positions. So I could check if that had already being checked and if so, either return true or false directly.\n\nThe final step was to convert the recursive function to an iterative function to save some memory used by the call stack.\nMaybe there are better implementations, just sharing my thought process."
                    },
                    {
                        "username": "tylerprill-rhdc",
                        "content": "[@tylerprill-rhdc](/tylerprill-rhdc) Two pointer based solution is also a really good solve here"
                    },
                    {
                        "username": "tylerprill-rhdc",
                        "content": "This could be done in a single pass algorithm, but will inherently check character indices multiple times based on the nature of the problem. (basically, iterate through each, then bubble out from each index)"
                    },
                    {
                        "username": "neetika",
                        "content": "From the leetcode blog, one of the methods of solving this is:\\n\\nA common mistake:\\nSome people will be tempted to come up with a quick solution, which is unfortunately flawed (however can be corrected easily):\\n\\nReverse S and become S\\u2019. Find the longest common substring between S and S\\u2019, which must also be the longest palindromic substring.\\nThis seemed to work, let\\u2019s see some examples below.\\n\\nFor example,\\nS = \\u201ccaba\\u201d, S\\u2019 = \\u201cabac\\u201d.\\nThe longest common substring between S and S\\u2019 is \\u201caba\\u201d, which is the answer.\\n\\nLet\\u2019s try another example:\\nS = \\u201cabacdfgdcaba\\u201d, S\\u2019 = \\u201cabacdgfdcaba\\u201d.\\nThe longest common substring between S and S\\u2019 is \\u201cabacd\\u201d. Clearly, this is not a valid palindrome.\\n\\n**We could see that the longest common substring method fails when there exists a reversed copy of a non-palindromic substring in some other part of S. To rectify this, each time we find a longest common substring candidate, we check if the substring\\u2019s indices are the same as the reversed substring\\u2019s original indices. If it is, then we attempt to update the longest palindrome found so far; if not, we skip this and find the next candidate.**\\n\\nIs this part correct? \\n\\nexample string: abcxycba\\nreverse string:  abcxycba\\n\\nThe substring indices are same as reversed string original indices and yet it is not a palindrome?"
                    },
                    {
                        "username": "HRVY_SNOWDEN",
                        "content": "cool sirr:)\\n"
                    },
                    {
                        "username": "dhtmlkitchen",
                        "content": "WRONG.\\n\\nabcxycba reversed is abcyxcba."
                    },
                    {
                        "username": "travisl12",
                        "content": "After I solved this problem I thought it\\'d be interesting to see how it worked in realtime.\\n\\nhttps://codepen.io/TravisL12/pen/pogvweg"
                    },
                    {
                        "username": "user3907vj",
                        "content": "thanks for the \"nanananananana\" from all the small things ;)"
                    },
                    {
                        "username": "zapataast",
                        "content": "u are crazy"
                    },
                    {
                        "username": "sondq98",
                        "content": "very intuitive"
                    },
                    {
                        "username": "Tathagat017",
                        "content": "thank you\\n"
                    },
                    {
                        "username": "mikler",
                        "content": "So I think I finally understood logic of test creators. \\nEven if you write a classical DP or memorization solution for this one you will timeout on latest tests.\\nI think they consider it edge cases. Because if you add one simple line it will pass! OMG. \\nI have leet code for this. Instead of solving problems I spend hours optimizing the constants.\\n\\nif s == s[::-1]: return s"
                    },
                    {
                        "username": "Vectorido",
                        "content": "Don\\'t work already. Time limit at 141 test even with that construction."
                    },
                    {
                        "username": "deepalithakur17",
                        "content": "It will only work in python."
                    },
                    {
                        "username": "ishogbon",
                        "content": "Its memoization, not memorization "
                    },
                    {
                        "username": "84danie",
                        "content": "I submitted my solution, and received a Time Limit Exceeded on this test case:\\n\\n\"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaabcaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"\\n\\nSo I copied and pasted the TC into a custom test case, and started to think about what I could tweak. However, I ended up accidentally hitting Run Code, but instead of getting a Time Limit Exceeded result, it passed:\\n\\n![0_1479079812693_upload-4af9e94c-2e53-4915-acf6-782780c7bf8b](/uploads/files/1479079813717-upload-4af9e94c-2e53-4915-acf6-782780c7bf8b.png) \\n\\nIs this supposed to happen and I just need to make my code more efficient, or is this a bug? \\n![0_1479079956817_upload-1ef15826-d6e6-4bde-9c06-eb597c5c8d0e](/uploads/files/1479079957639-upload-1ef15826-d6e6-4bde-9c06-eb597c5c8d0e.png)"
                    },
                    {
                        "username": "RitikaSahay",
                        "content": "Same thing happened with me. Is there a solution for it?\\n"
                    },
                    {
                        "username": "danicruz0415",
                        "content": "It\\'s happened to me a couple of times. My theory is that the time limit is given for the whole list of test cases. Thus, you can have your test pass, but it will still time limit exceed because it wont get to calculate all the test cases before the time runs out. I cannot confirm this but I think its true because with a very unoptimized solution I got time limit exceeded very early in the test cases (for another problem), after some optimizations I got it much later (like getting to the last tests) which themselves were around the same size, so if the time limit was set per test it would not make sense to fail in a similarly long test-case just that is much later in the test list. (I think the same would apply to memory limit exceeded)"
                    },
                    {
                        "username": "him_Sarma619",
                        "content": "The exact same situation happened with me in one problem... it was a DP problem too... I was getting a Memory Limit Exceeded error with the memoized solution but it was running fine in the Run Code button."
                    },
                    {
                        "username": "Hubro",
                        "content": "I\\'m getting \"Time Limit Exceeded\" with 141/141 testcases passed and \"Last Executed Input\" is:\\n\\n```\\ns =\\n```\\n\\nDid I break it?"
                    },
                    {
                        "username": "karan_dhiman",
                        "content": "same issue"
                    },
                    {
                        "username": "BLANK-Zora",
                        "content": "exactly bro this shit is recked , like it is giving tests outside the constraints , how am i suppose to include such things in the code"
                    },
                    {
                        "username": "arunprep5",
                        "content": "same issue. java"
                    },
                    {
                        "username": "blasphelmy",
                        "content": "[@tuancoltech](/tuancoltech) it worked when i rewrote the code in c# instead of c++"
                    },
                    {
                        "username": "tuancoltech",
                        "content": "[@blasphelmy](/blasphelmy) [@Tomas Sandven](/Hubro) Did you guys find out why? I got the same issue."
                    },
                    {
                        "username": "blasphelmy",
                        "content": "i got that too. im not sure whats going on given that the constraint for input is between 1 and 1000"
                    },
                    {
                        "username": "Vinitajain",
                        "content": "Hi All,\\nI have a test case which is failing, but I feel the testcase result is incorrect.Please refer the screenshot below.\\n![image](https://assets.leetcode.com/users/images/e9e42efb-63d5-4cfa-b420-f1926674f6dc_1654838015.8394327.png)\\n\\nThe longest palindromic substring is \"aaca\" but the test case result is \"aca\". Anyone else faced this problem?"
                    },
                    {
                        "username": "OthSO",
                        "content": "[@mohdansah10](/mohdansah10) \\nthey are separated in the input with \"bd\" so it is not a valid answer "
                    },
                    {
                        "username": "mohdansah10",
                        "content": "I\\'m getting same error, but different case:\\nInput\\ns =\\n\"aacabdkacaa\"\\n\\nOutput\\n\"aacakacaa\"\\nExpected\\n\"aca\"\\n\\nBut mine is Palindrome"
                    },
                    {
                        "username": "hasmithraa",
                        "content": "the expected is correct because aaca can\\'t be a palindrome only \\'aacaa\\' can be a palindrome which is not there in your case"
                    },
                    {
                        "username": "Amish_Singh",
                        "content": "how are you considering \"aaca\" as a palindromic substring, \"aca\" is a palindrome and it is the longest"
                    },
                    {
                        "username": "Shaik_Aman_Sayer",
                        "content": "dude you really came up with the solution "
                    },
                    {
                        "username": "AryaAditya3609",
                        "content": "how is \"aaca\" and \"acaa\" same ???\\nWhile \"aca\" is palindrome because both \"aca\" and reverse of it \"aca\" is same !!"
                    },
                    {
                        "username": "alexandra-pickle",
                        "content": "\"aaca\" is not a palindrome"
                    },
                    {
                        "username": "bugHackerLoop",
                        "content": "I followed the approach leant by Aditya Verma DP lectures and encountered the same test case failing. Does the logic where I reverse the string and calculate the longest common substring doesn\\'t work here? I know it works for longest palindromic subsequence but here it fails for such test cases .. why is it so?"
                    },
                    {
                        "username": "mductran",
                        "content": "how is \\'aaca\\' a palindrome? when read backward it\\'s \\'acaa\\' so it\\'s not the same reading forward."
                    },
                    {
                        "username": "jnsudhir",
                        "content": "Check my solution, it was able to clear test case \"aaca\". Explained code in comments.\\n\\nhttps://leetcode.com/problems/longest-palindromic-substring/solutions/3091016/longest-palindromic-substring-using-javascript-beats-94-82-in-runtime-explained/?orderBy=most_votes"
                    },
                    {
                        "username": "nikhileshratna",
                        "content": "aaca is not palindrome"
                    },
                    {
                        "username": "sunshine77",
                        "content": "hey, iam getting the same error, i have seen ansewrs where they have totally changed the algorithm, how did u solve this by tweaking the same algoirhtm"
                    },
                    {
                        "username": "bhupendrabc71",
                        "content": "how come \"aaca\" is palindrome. it should be \"aca\""
                    },
                    {
                        "username": "just11blocks",
                        "content": "aaca is not a palindrome...aacaa and aca are."
                    },
                    {
                        "username": "odi1n",
                        "content": "I also encountered this problem"
                    },
                    {
                        "username": "vamsi2302",
                        "content": "I think you get it by now!\\n"
                    }
                ]
            },
            {
                "id": 1569251,
                "content": [
                    {
                        "username": "ZenMasterV",
                        "content": "Seems like too many of the  coding wunderkinds here lack basic reading comprehension skills \\n\" Please don\\'t post any solutions in this discussion tab\"\\nIt\\'s almost the rule to find the exact opposite for the discussion of every question. I don\\'t want to see your damned solution!"
                    },
                    {
                        "username": "NeroXIII",
                        "content": "[@charonme](/charonme) name does not check out :((("
                    },
                    {
                        "username": "192731",
                        "content": "and if they do?"
                    },
                    {
                        "username": "plevi1995",
                        "content": "Excellent comment"
                    },
                    {
                        "username": "khan60939",
                        "content": "Can anyone tell how DP is being used here? "
                    },
                    {
                        "username": "sandagolcea",
                        "content": "[@charonme](/charonme) my thinking exactly, but at least they should create a flag to help us moderate and move solutions to the correct tab. Would only need a stack overflow moderation-like system: one person flags, another person receives a queue of flagged comments and confirms the tagging.. oh well"
                    },
                    {
                        "username": "charonme",
                        "content": "maybe people get confused by the official leetcode comment which says: \"If you\\'d like to share a detailed solution to the problem, please create a new post in the discuss section\"\\nMaybe some time ago they didn\\'t have a separate solutions section and only recently changed it, but left some of the old solutions in the discussion section and didn\\'t fix the automated comment worting?"
                    },
                    {
                        "username": "klanjewar037",
                        "content": "hehe"
                    },
                    {
                        "username": "sanemdeepak",
                        "content": "For input \"ac\" test case is expecting \"a\" as output, how is just \"a\" a palindromic string?"
                    },
                    {
                        "username": "ayushiidevpura",
                        "content": "because when we read \"a\" from forward it results in \"a\" and at the same time when we read \"a\" from backward it is still \"a\""
                    },
                    {
                        "username": "beyzigo",
                        "content": "Because if you read the string \"a\" backwards it will still be \"a\""
                    },
                    {
                        "username": "tsafackghokeng",
                        "content": "[@Chouhan_Gourav](/Chouhan_Gourav) the test case said \"ac\" not \"a\". is \"ac\" palindromic? for \"a\" i understand"
                    },
                    {
                        "username": "CODEWITHABHINAV",
                        "content": "you have to submit the first string as your answer read more about this question on gFg\\n"
                    },
                    {
                        "username": "_BREEZE_",
                        "content": "any string is palindrome if we read it same from front and from back\\nin single character we read it same from front and back"
                    },
                    {
                        "username": "oinrup",
                        "content": "yes thats my question too"
                    },
                    {
                        "username": "yldemon",
                        "content": "Any character in the string by itself is a palindromic substring. So in the case where there is no palindromic substring with length > 1, you can return any character."
                    },
                    {
                        "username": "Chouhan_Gourav",
                        "content": "Whenever you come accross such contradiction, just google the definition, any. Any string is called is pallindromic if the reverse of the string is equal to the original string. Reverse of \\'a\\' is \\'a\\'. Hope you get this."
                    },
                    {
                        "username": "947876275",
                        "content": "This post is for learner wanna practice DP.\\nThe basic idea is, if we wanna say \"aba\" is palindromic, then we need to firstly confirm that \"b\" is palindromic, then we also need to check if \"a\"(the first a) = \"a\" (the second a).\\n\\nM is a 2-d array which stores boolean values.\\nM[i][j] indicates if string[i.....j] is palindromic.\\nSo base cases are:\\nM[i][i] is true.\\nM[i][i + 1] = (s[i] == s[i + 1]);\\nrecurrence relation is :\\nM[i][j] = (s[i] == s[j] AND M[i + 1][j - 1]);\\nFor the implementation of recurrence relation, one idea is you can loop through all possible symmetry axis. For each of the axis, you expand at both RHS and LHS simultaneously. This method promises that when you are determining value in M[i][j], M[i + 1][j - 1] must have the correct value.\\nFinal answer can be found from all M[i][j] == 1 with largest (j - i)."
                    },
                    {
                        "username": "Msey",
                        "content": "thank you, cat brother"
                    },
                    {
                        "username": "user0558y",
                        "content": "I understand the solution but I don't understand why it needs any storage at all or why it needs to be a DP solution.\n\nThe condition `(s[i] == s[j] AND M[i + 1][j - 1])` requires you to memorise if `M[i+1][j-1]` is true, that's easy to understand. However, if you expand each possible axis at the same time, i.e. 1st iteration (s[i+1], s[j-1]), 2nd iteration `s[i+2], s[j-2]`, ... It is guaranteed that M[i+1][j-1] is always true and hence can be dropped, and you should break the loop when it is not true.\n\nIn summary, you don't need to memorise anything at all and you just need to check `s[i] == s[j]` while expanding in both directions at the same time, unless I have misunderstood anything? Here is an implementation of your algorithm but without storage: https://leetcode.com/problems/longest-palindromic-substring/submissions/868540120/"
                    },
                    {
                        "username": "taras",
                        "content": "Thank you! this is a beautiful explanation, though I\\'m not sure what exactly you mean by expanding both on LHS and RHS. In my implementation it\\'s enough to compute all diagonals of  the upper right triangle of the dp matrix."
                    },
                    {
                        "username": "klu_2100031593",
                        "content": "super explanation"
                    },
                    {
                        "username": "napoleon",
                        "content": "My Solution Is Naive, It Cost O(n^2), Is there Any Solution faster?"
                    },
                    {
                        "username": "leocampos",
                        "content": "[@tylerprill-rhdc](/tylerprill-rhdc) So, what I did was:\nStated in my mind the Brute Force approach - create every possible substring and test each one to see if is a palindrome and find the longest.\n\nOf course this would be ridiculously slow, so let's improve it.\nI also mentally stated that a palindrome has a recursive aspect -> if single char, or two equal chars, or charX + palindrome + charX\nSo I created a isPalindrome recursive method that checked it delegating to itself extracting the borders.\n\nSince a palindrome must start and end with the same char, in my traverse of the string, I started storing the position of each character Map<Character, List< Integer>>, so I would just go back to the previous found Char and check if from there to the current pointer I would have a Palindrome.\n\nThen I stopped doing this for every possible palindrome, I then started doing only for the ones that COULD be longer than the already found longest palindrome. That accelerated a lot.\n\nIn the almost last step, I added memoization. Remember that a palindrome is like a sandwich, with the external chars being equal and the meat being another palindrome? So I stored the found palindromes using their start and and positions. So I could check if that had already being checked and if so, either return true or false directly.\n\nThe final step was to convert the recursive function to an iterative function to save some memory used by the call stack.\nMaybe there are better implementations, just sharing my thought process."
                    },
                    {
                        "username": "tylerprill-rhdc",
                        "content": "[@tylerprill-rhdc](/tylerprill-rhdc) Two pointer based solution is also a really good solve here"
                    },
                    {
                        "username": "tylerprill-rhdc",
                        "content": "This could be done in a single pass algorithm, but will inherently check character indices multiple times based on the nature of the problem. (basically, iterate through each, then bubble out from each index)"
                    },
                    {
                        "username": "neetika",
                        "content": "From the leetcode blog, one of the methods of solving this is:\\n\\nA common mistake:\\nSome people will be tempted to come up with a quick solution, which is unfortunately flawed (however can be corrected easily):\\n\\nReverse S and become S\\u2019. Find the longest common substring between S and S\\u2019, which must also be the longest palindromic substring.\\nThis seemed to work, let\\u2019s see some examples below.\\n\\nFor example,\\nS = \\u201ccaba\\u201d, S\\u2019 = \\u201cabac\\u201d.\\nThe longest common substring between S and S\\u2019 is \\u201caba\\u201d, which is the answer.\\n\\nLet\\u2019s try another example:\\nS = \\u201cabacdfgdcaba\\u201d, S\\u2019 = \\u201cabacdgfdcaba\\u201d.\\nThe longest common substring between S and S\\u2019 is \\u201cabacd\\u201d. Clearly, this is not a valid palindrome.\\n\\n**We could see that the longest common substring method fails when there exists a reversed copy of a non-palindromic substring in some other part of S. To rectify this, each time we find a longest common substring candidate, we check if the substring\\u2019s indices are the same as the reversed substring\\u2019s original indices. If it is, then we attempt to update the longest palindrome found so far; if not, we skip this and find the next candidate.**\\n\\nIs this part correct? \\n\\nexample string: abcxycba\\nreverse string:  abcxycba\\n\\nThe substring indices are same as reversed string original indices and yet it is not a palindrome?"
                    },
                    {
                        "username": "HRVY_SNOWDEN",
                        "content": "cool sirr:)\\n"
                    },
                    {
                        "username": "dhtmlkitchen",
                        "content": "WRONG.\\n\\nabcxycba reversed is abcyxcba."
                    },
                    {
                        "username": "travisl12",
                        "content": "After I solved this problem I thought it\\'d be interesting to see how it worked in realtime.\\n\\nhttps://codepen.io/TravisL12/pen/pogvweg"
                    },
                    {
                        "username": "user3907vj",
                        "content": "thanks for the \"nanananananana\" from all the small things ;)"
                    },
                    {
                        "username": "zapataast",
                        "content": "u are crazy"
                    },
                    {
                        "username": "sondq98",
                        "content": "very intuitive"
                    },
                    {
                        "username": "Tathagat017",
                        "content": "thank you\\n"
                    },
                    {
                        "username": "mikler",
                        "content": "So I think I finally understood logic of test creators. \\nEven if you write a classical DP or memorization solution for this one you will timeout on latest tests.\\nI think they consider it edge cases. Because if you add one simple line it will pass! OMG. \\nI have leet code for this. Instead of solving problems I spend hours optimizing the constants.\\n\\nif s == s[::-1]: return s"
                    },
                    {
                        "username": "Vectorido",
                        "content": "Don\\'t work already. Time limit at 141 test even with that construction."
                    },
                    {
                        "username": "deepalithakur17",
                        "content": "It will only work in python."
                    },
                    {
                        "username": "ishogbon",
                        "content": "Its memoization, not memorization "
                    },
                    {
                        "username": "84danie",
                        "content": "I submitted my solution, and received a Time Limit Exceeded on this test case:\\n\\n\"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaabcaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"\\n\\nSo I copied and pasted the TC into a custom test case, and started to think about what I could tweak. However, I ended up accidentally hitting Run Code, but instead of getting a Time Limit Exceeded result, it passed:\\n\\n![0_1479079812693_upload-4af9e94c-2e53-4915-acf6-782780c7bf8b](/uploads/files/1479079813717-upload-4af9e94c-2e53-4915-acf6-782780c7bf8b.png) \\n\\nIs this supposed to happen and I just need to make my code more efficient, or is this a bug? \\n![0_1479079956817_upload-1ef15826-d6e6-4bde-9c06-eb597c5c8d0e](/uploads/files/1479079957639-upload-1ef15826-d6e6-4bde-9c06-eb597c5c8d0e.png)"
                    },
                    {
                        "username": "RitikaSahay",
                        "content": "Same thing happened with me. Is there a solution for it?\\n"
                    },
                    {
                        "username": "danicruz0415",
                        "content": "It\\'s happened to me a couple of times. My theory is that the time limit is given for the whole list of test cases. Thus, you can have your test pass, but it will still time limit exceed because it wont get to calculate all the test cases before the time runs out. I cannot confirm this but I think its true because with a very unoptimized solution I got time limit exceeded very early in the test cases (for another problem), after some optimizations I got it much later (like getting to the last tests) which themselves were around the same size, so if the time limit was set per test it would not make sense to fail in a similarly long test-case just that is much later in the test list. (I think the same would apply to memory limit exceeded)"
                    },
                    {
                        "username": "him_Sarma619",
                        "content": "The exact same situation happened with me in one problem... it was a DP problem too... I was getting a Memory Limit Exceeded error with the memoized solution but it was running fine in the Run Code button."
                    },
                    {
                        "username": "Hubro",
                        "content": "I\\'m getting \"Time Limit Exceeded\" with 141/141 testcases passed and \"Last Executed Input\" is:\\n\\n```\\ns =\\n```\\n\\nDid I break it?"
                    },
                    {
                        "username": "karan_dhiman",
                        "content": "same issue"
                    },
                    {
                        "username": "BLANK-Zora",
                        "content": "exactly bro this shit is recked , like it is giving tests outside the constraints , how am i suppose to include such things in the code"
                    },
                    {
                        "username": "arunprep5",
                        "content": "same issue. java"
                    },
                    {
                        "username": "blasphelmy",
                        "content": "[@tuancoltech](/tuancoltech) it worked when i rewrote the code in c# instead of c++"
                    },
                    {
                        "username": "tuancoltech",
                        "content": "[@blasphelmy](/blasphelmy) [@Tomas Sandven](/Hubro) Did you guys find out why? I got the same issue."
                    },
                    {
                        "username": "blasphelmy",
                        "content": "i got that too. im not sure whats going on given that the constraint for input is between 1 and 1000"
                    },
                    {
                        "username": "Vinitajain",
                        "content": "Hi All,\\nI have a test case which is failing, but I feel the testcase result is incorrect.Please refer the screenshot below.\\n![image](https://assets.leetcode.com/users/images/e9e42efb-63d5-4cfa-b420-f1926674f6dc_1654838015.8394327.png)\\n\\nThe longest palindromic substring is \"aaca\" but the test case result is \"aca\". Anyone else faced this problem?"
                    },
                    {
                        "username": "OthSO",
                        "content": "[@mohdansah10](/mohdansah10) \\nthey are separated in the input with \"bd\" so it is not a valid answer "
                    },
                    {
                        "username": "mohdansah10",
                        "content": "I\\'m getting same error, but different case:\\nInput\\ns =\\n\"aacabdkacaa\"\\n\\nOutput\\n\"aacakacaa\"\\nExpected\\n\"aca\"\\n\\nBut mine is Palindrome"
                    },
                    {
                        "username": "hasmithraa",
                        "content": "the expected is correct because aaca can\\'t be a palindrome only \\'aacaa\\' can be a palindrome which is not there in your case"
                    },
                    {
                        "username": "Amish_Singh",
                        "content": "how are you considering \"aaca\" as a palindromic substring, \"aca\" is a palindrome and it is the longest"
                    },
                    {
                        "username": "Shaik_Aman_Sayer",
                        "content": "dude you really came up with the solution "
                    },
                    {
                        "username": "AryaAditya3609",
                        "content": "how is \"aaca\" and \"acaa\" same ???\\nWhile \"aca\" is palindrome because both \"aca\" and reverse of it \"aca\" is same !!"
                    },
                    {
                        "username": "alexandra-pickle",
                        "content": "\"aaca\" is not a palindrome"
                    },
                    {
                        "username": "bugHackerLoop",
                        "content": "I followed the approach leant by Aditya Verma DP lectures and encountered the same test case failing. Does the logic where I reverse the string and calculate the longest common substring doesn\\'t work here? I know it works for longest palindromic subsequence but here it fails for such test cases .. why is it so?"
                    },
                    {
                        "username": "mductran",
                        "content": "how is \\'aaca\\' a palindrome? when read backward it\\'s \\'acaa\\' so it\\'s not the same reading forward."
                    },
                    {
                        "username": "jnsudhir",
                        "content": "Check my solution, it was able to clear test case \"aaca\". Explained code in comments.\\n\\nhttps://leetcode.com/problems/longest-palindromic-substring/solutions/3091016/longest-palindromic-substring-using-javascript-beats-94-82-in-runtime-explained/?orderBy=most_votes"
                    },
                    {
                        "username": "nikhileshratna",
                        "content": "aaca is not palindrome"
                    },
                    {
                        "username": "sunshine77",
                        "content": "hey, iam getting the same error, i have seen ansewrs where they have totally changed the algorithm, how did u solve this by tweaking the same algoirhtm"
                    },
                    {
                        "username": "bhupendrabc71",
                        "content": "how come \"aaca\" is palindrome. it should be \"aca\""
                    },
                    {
                        "username": "just11blocks",
                        "content": "aaca is not a palindrome...aacaa and aca are."
                    },
                    {
                        "username": "odi1n",
                        "content": "I also encountered this problem"
                    },
                    {
                        "username": "vamsi2302",
                        "content": "I think you get it by now!\\n"
                    }
                ]
            },
            {
                "id": 1566232,
                "content": [
                    {
                        "username": "ZenMasterV",
                        "content": "Seems like too many of the  coding wunderkinds here lack basic reading comprehension skills \\n\" Please don\\'t post any solutions in this discussion tab\"\\nIt\\'s almost the rule to find the exact opposite for the discussion of every question. I don\\'t want to see your damned solution!"
                    },
                    {
                        "username": "NeroXIII",
                        "content": "[@charonme](/charonme) name does not check out :((("
                    },
                    {
                        "username": "192731",
                        "content": "and if they do?"
                    },
                    {
                        "username": "plevi1995",
                        "content": "Excellent comment"
                    },
                    {
                        "username": "khan60939",
                        "content": "Can anyone tell how DP is being used here? "
                    },
                    {
                        "username": "sandagolcea",
                        "content": "[@charonme](/charonme) my thinking exactly, but at least they should create a flag to help us moderate and move solutions to the correct tab. Would only need a stack overflow moderation-like system: one person flags, another person receives a queue of flagged comments and confirms the tagging.. oh well"
                    },
                    {
                        "username": "charonme",
                        "content": "maybe people get confused by the official leetcode comment which says: \"If you\\'d like to share a detailed solution to the problem, please create a new post in the discuss section\"\\nMaybe some time ago they didn\\'t have a separate solutions section and only recently changed it, but left some of the old solutions in the discussion section and didn\\'t fix the automated comment worting?"
                    },
                    {
                        "username": "klanjewar037",
                        "content": "hehe"
                    },
                    {
                        "username": "sanemdeepak",
                        "content": "For input \"ac\" test case is expecting \"a\" as output, how is just \"a\" a palindromic string?"
                    },
                    {
                        "username": "ayushiidevpura",
                        "content": "because when we read \"a\" from forward it results in \"a\" and at the same time when we read \"a\" from backward it is still \"a\""
                    },
                    {
                        "username": "beyzigo",
                        "content": "Because if you read the string \"a\" backwards it will still be \"a\""
                    },
                    {
                        "username": "tsafackghokeng",
                        "content": "[@Chouhan_Gourav](/Chouhan_Gourav) the test case said \"ac\" not \"a\". is \"ac\" palindromic? for \"a\" i understand"
                    },
                    {
                        "username": "CODEWITHABHINAV",
                        "content": "you have to submit the first string as your answer read more about this question on gFg\\n"
                    },
                    {
                        "username": "_BREEZE_",
                        "content": "any string is palindrome if we read it same from front and from back\\nin single character we read it same from front and back"
                    },
                    {
                        "username": "oinrup",
                        "content": "yes thats my question too"
                    },
                    {
                        "username": "yldemon",
                        "content": "Any character in the string by itself is a palindromic substring. So in the case where there is no palindromic substring with length > 1, you can return any character."
                    },
                    {
                        "username": "Chouhan_Gourav",
                        "content": "Whenever you come accross such contradiction, just google the definition, any. Any string is called is pallindromic if the reverse of the string is equal to the original string. Reverse of \\'a\\' is \\'a\\'. Hope you get this."
                    },
                    {
                        "username": "947876275",
                        "content": "This post is for learner wanna practice DP.\\nThe basic idea is, if we wanna say \"aba\" is palindromic, then we need to firstly confirm that \"b\" is palindromic, then we also need to check if \"a\"(the first a) = \"a\" (the second a).\\n\\nM is a 2-d array which stores boolean values.\\nM[i][j] indicates if string[i.....j] is palindromic.\\nSo base cases are:\\nM[i][i] is true.\\nM[i][i + 1] = (s[i] == s[i + 1]);\\nrecurrence relation is :\\nM[i][j] = (s[i] == s[j] AND M[i + 1][j - 1]);\\nFor the implementation of recurrence relation, one idea is you can loop through all possible symmetry axis. For each of the axis, you expand at both RHS and LHS simultaneously. This method promises that when you are determining value in M[i][j], M[i + 1][j - 1] must have the correct value.\\nFinal answer can be found from all M[i][j] == 1 with largest (j - i)."
                    },
                    {
                        "username": "Msey",
                        "content": "thank you, cat brother"
                    },
                    {
                        "username": "user0558y",
                        "content": "I understand the solution but I don't understand why it needs any storage at all or why it needs to be a DP solution.\n\nThe condition `(s[i] == s[j] AND M[i + 1][j - 1])` requires you to memorise if `M[i+1][j-1]` is true, that's easy to understand. However, if you expand each possible axis at the same time, i.e. 1st iteration (s[i+1], s[j-1]), 2nd iteration `s[i+2], s[j-2]`, ... It is guaranteed that M[i+1][j-1] is always true and hence can be dropped, and you should break the loop when it is not true.\n\nIn summary, you don't need to memorise anything at all and you just need to check `s[i] == s[j]` while expanding in both directions at the same time, unless I have misunderstood anything? Here is an implementation of your algorithm but without storage: https://leetcode.com/problems/longest-palindromic-substring/submissions/868540120/"
                    },
                    {
                        "username": "taras",
                        "content": "Thank you! this is a beautiful explanation, though I\\'m not sure what exactly you mean by expanding both on LHS and RHS. In my implementation it\\'s enough to compute all diagonals of  the upper right triangle of the dp matrix."
                    },
                    {
                        "username": "klu_2100031593",
                        "content": "super explanation"
                    },
                    {
                        "username": "napoleon",
                        "content": "My Solution Is Naive, It Cost O(n^2), Is there Any Solution faster?"
                    },
                    {
                        "username": "leocampos",
                        "content": "[@tylerprill-rhdc](/tylerprill-rhdc) So, what I did was:\nStated in my mind the Brute Force approach - create every possible substring and test each one to see if is a palindrome and find the longest.\n\nOf course this would be ridiculously slow, so let's improve it.\nI also mentally stated that a palindrome has a recursive aspect -> if single char, or two equal chars, or charX + palindrome + charX\nSo I created a isPalindrome recursive method that checked it delegating to itself extracting the borders.\n\nSince a palindrome must start and end with the same char, in my traverse of the string, I started storing the position of each character Map<Character, List< Integer>>, so I would just go back to the previous found Char and check if from there to the current pointer I would have a Palindrome.\n\nThen I stopped doing this for every possible palindrome, I then started doing only for the ones that COULD be longer than the already found longest palindrome. That accelerated a lot.\n\nIn the almost last step, I added memoization. Remember that a palindrome is like a sandwich, with the external chars being equal and the meat being another palindrome? So I stored the found palindromes using their start and and positions. So I could check if that had already being checked and if so, either return true or false directly.\n\nThe final step was to convert the recursive function to an iterative function to save some memory used by the call stack.\nMaybe there are better implementations, just sharing my thought process."
                    },
                    {
                        "username": "tylerprill-rhdc",
                        "content": "[@tylerprill-rhdc](/tylerprill-rhdc) Two pointer based solution is also a really good solve here"
                    },
                    {
                        "username": "tylerprill-rhdc",
                        "content": "This could be done in a single pass algorithm, but will inherently check character indices multiple times based on the nature of the problem. (basically, iterate through each, then bubble out from each index)"
                    },
                    {
                        "username": "neetika",
                        "content": "From the leetcode blog, one of the methods of solving this is:\\n\\nA common mistake:\\nSome people will be tempted to come up with a quick solution, which is unfortunately flawed (however can be corrected easily):\\n\\nReverse S and become S\\u2019. Find the longest common substring between S and S\\u2019, which must also be the longest palindromic substring.\\nThis seemed to work, let\\u2019s see some examples below.\\n\\nFor example,\\nS = \\u201ccaba\\u201d, S\\u2019 = \\u201cabac\\u201d.\\nThe longest common substring between S and S\\u2019 is \\u201caba\\u201d, which is the answer.\\n\\nLet\\u2019s try another example:\\nS = \\u201cabacdfgdcaba\\u201d, S\\u2019 = \\u201cabacdgfdcaba\\u201d.\\nThe longest common substring between S and S\\u2019 is \\u201cabacd\\u201d. Clearly, this is not a valid palindrome.\\n\\n**We could see that the longest common substring method fails when there exists a reversed copy of a non-palindromic substring in some other part of S. To rectify this, each time we find a longest common substring candidate, we check if the substring\\u2019s indices are the same as the reversed substring\\u2019s original indices. If it is, then we attempt to update the longest palindrome found so far; if not, we skip this and find the next candidate.**\\n\\nIs this part correct? \\n\\nexample string: abcxycba\\nreverse string:  abcxycba\\n\\nThe substring indices are same as reversed string original indices and yet it is not a palindrome?"
                    },
                    {
                        "username": "HRVY_SNOWDEN",
                        "content": "cool sirr:)\\n"
                    },
                    {
                        "username": "dhtmlkitchen",
                        "content": "WRONG.\\n\\nabcxycba reversed is abcyxcba."
                    },
                    {
                        "username": "travisl12",
                        "content": "After I solved this problem I thought it\\'d be interesting to see how it worked in realtime.\\n\\nhttps://codepen.io/TravisL12/pen/pogvweg"
                    },
                    {
                        "username": "user3907vj",
                        "content": "thanks for the \"nanananananana\" from all the small things ;)"
                    },
                    {
                        "username": "zapataast",
                        "content": "u are crazy"
                    },
                    {
                        "username": "sondq98",
                        "content": "very intuitive"
                    },
                    {
                        "username": "Tathagat017",
                        "content": "thank you\\n"
                    },
                    {
                        "username": "mikler",
                        "content": "So I think I finally understood logic of test creators. \\nEven if you write a classical DP or memorization solution for this one you will timeout on latest tests.\\nI think they consider it edge cases. Because if you add one simple line it will pass! OMG. \\nI have leet code for this. Instead of solving problems I spend hours optimizing the constants.\\n\\nif s == s[::-1]: return s"
                    },
                    {
                        "username": "Vectorido",
                        "content": "Don\\'t work already. Time limit at 141 test even with that construction."
                    },
                    {
                        "username": "deepalithakur17",
                        "content": "It will only work in python."
                    },
                    {
                        "username": "ishogbon",
                        "content": "Its memoization, not memorization "
                    },
                    {
                        "username": "84danie",
                        "content": "I submitted my solution, and received a Time Limit Exceeded on this test case:\\n\\n\"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaabcaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"\\n\\nSo I copied and pasted the TC into a custom test case, and started to think about what I could tweak. However, I ended up accidentally hitting Run Code, but instead of getting a Time Limit Exceeded result, it passed:\\n\\n![0_1479079812693_upload-4af9e94c-2e53-4915-acf6-782780c7bf8b](/uploads/files/1479079813717-upload-4af9e94c-2e53-4915-acf6-782780c7bf8b.png) \\n\\nIs this supposed to happen and I just need to make my code more efficient, or is this a bug? \\n![0_1479079956817_upload-1ef15826-d6e6-4bde-9c06-eb597c5c8d0e](/uploads/files/1479079957639-upload-1ef15826-d6e6-4bde-9c06-eb597c5c8d0e.png)"
                    },
                    {
                        "username": "RitikaSahay",
                        "content": "Same thing happened with me. Is there a solution for it?\\n"
                    },
                    {
                        "username": "danicruz0415",
                        "content": "It\\'s happened to me a couple of times. My theory is that the time limit is given for the whole list of test cases. Thus, you can have your test pass, but it will still time limit exceed because it wont get to calculate all the test cases before the time runs out. I cannot confirm this but I think its true because with a very unoptimized solution I got time limit exceeded very early in the test cases (for another problem), after some optimizations I got it much later (like getting to the last tests) which themselves were around the same size, so if the time limit was set per test it would not make sense to fail in a similarly long test-case just that is much later in the test list. (I think the same would apply to memory limit exceeded)"
                    },
                    {
                        "username": "him_Sarma619",
                        "content": "The exact same situation happened with me in one problem... it was a DP problem too... I was getting a Memory Limit Exceeded error with the memoized solution but it was running fine in the Run Code button."
                    },
                    {
                        "username": "Hubro",
                        "content": "I\\'m getting \"Time Limit Exceeded\" with 141/141 testcases passed and \"Last Executed Input\" is:\\n\\n```\\ns =\\n```\\n\\nDid I break it?"
                    },
                    {
                        "username": "karan_dhiman",
                        "content": "same issue"
                    },
                    {
                        "username": "BLANK-Zora",
                        "content": "exactly bro this shit is recked , like it is giving tests outside the constraints , how am i suppose to include such things in the code"
                    },
                    {
                        "username": "arunprep5",
                        "content": "same issue. java"
                    },
                    {
                        "username": "blasphelmy",
                        "content": "[@tuancoltech](/tuancoltech) it worked when i rewrote the code in c# instead of c++"
                    },
                    {
                        "username": "tuancoltech",
                        "content": "[@blasphelmy](/blasphelmy) [@Tomas Sandven](/Hubro) Did you guys find out why? I got the same issue."
                    },
                    {
                        "username": "blasphelmy",
                        "content": "i got that too. im not sure whats going on given that the constraint for input is between 1 and 1000"
                    },
                    {
                        "username": "Vinitajain",
                        "content": "Hi All,\\nI have a test case which is failing, but I feel the testcase result is incorrect.Please refer the screenshot below.\\n![image](https://assets.leetcode.com/users/images/e9e42efb-63d5-4cfa-b420-f1926674f6dc_1654838015.8394327.png)\\n\\nThe longest palindromic substring is \"aaca\" but the test case result is \"aca\". Anyone else faced this problem?"
                    },
                    {
                        "username": "OthSO",
                        "content": "[@mohdansah10](/mohdansah10) \\nthey are separated in the input with \"bd\" so it is not a valid answer "
                    },
                    {
                        "username": "mohdansah10",
                        "content": "I\\'m getting same error, but different case:\\nInput\\ns =\\n\"aacabdkacaa\"\\n\\nOutput\\n\"aacakacaa\"\\nExpected\\n\"aca\"\\n\\nBut mine is Palindrome"
                    },
                    {
                        "username": "hasmithraa",
                        "content": "the expected is correct because aaca can\\'t be a palindrome only \\'aacaa\\' can be a palindrome which is not there in your case"
                    },
                    {
                        "username": "Amish_Singh",
                        "content": "how are you considering \"aaca\" as a palindromic substring, \"aca\" is a palindrome and it is the longest"
                    },
                    {
                        "username": "Shaik_Aman_Sayer",
                        "content": "dude you really came up with the solution "
                    },
                    {
                        "username": "AryaAditya3609",
                        "content": "how is \"aaca\" and \"acaa\" same ???\\nWhile \"aca\" is palindrome because both \"aca\" and reverse of it \"aca\" is same !!"
                    },
                    {
                        "username": "alexandra-pickle",
                        "content": "\"aaca\" is not a palindrome"
                    },
                    {
                        "username": "bugHackerLoop",
                        "content": "I followed the approach leant by Aditya Verma DP lectures and encountered the same test case failing. Does the logic where I reverse the string and calculate the longest common substring doesn\\'t work here? I know it works for longest palindromic subsequence but here it fails for such test cases .. why is it so?"
                    },
                    {
                        "username": "mductran",
                        "content": "how is \\'aaca\\' a palindrome? when read backward it\\'s \\'acaa\\' so it\\'s not the same reading forward."
                    },
                    {
                        "username": "jnsudhir",
                        "content": "Check my solution, it was able to clear test case \"aaca\". Explained code in comments.\\n\\nhttps://leetcode.com/problems/longest-palindromic-substring/solutions/3091016/longest-palindromic-substring-using-javascript-beats-94-82-in-runtime-explained/?orderBy=most_votes"
                    },
                    {
                        "username": "nikhileshratna",
                        "content": "aaca is not palindrome"
                    },
                    {
                        "username": "sunshine77",
                        "content": "hey, iam getting the same error, i have seen ansewrs where they have totally changed the algorithm, how did u solve this by tweaking the same algoirhtm"
                    },
                    {
                        "username": "bhupendrabc71",
                        "content": "how come \"aaca\" is palindrome. it should be \"aca\""
                    },
                    {
                        "username": "just11blocks",
                        "content": "aaca is not a palindrome...aacaa and aca are."
                    },
                    {
                        "username": "odi1n",
                        "content": "I also encountered this problem"
                    },
                    {
                        "username": "vamsi2302",
                        "content": "I think you get it by now!\\n"
                    }
                ]
            },
            {
                "id": 1568804,
                "content": [
                    {
                        "username": "ZenMasterV",
                        "content": "Seems like too many of the  coding wunderkinds here lack basic reading comprehension skills \\n\" Please don\\'t post any solutions in this discussion tab\"\\nIt\\'s almost the rule to find the exact opposite for the discussion of every question. I don\\'t want to see your damned solution!"
                    },
                    {
                        "username": "NeroXIII",
                        "content": "[@charonme](/charonme) name does not check out :((("
                    },
                    {
                        "username": "192731",
                        "content": "and if they do?"
                    },
                    {
                        "username": "plevi1995",
                        "content": "Excellent comment"
                    },
                    {
                        "username": "khan60939",
                        "content": "Can anyone tell how DP is being used here? "
                    },
                    {
                        "username": "sandagolcea",
                        "content": "[@charonme](/charonme) my thinking exactly, but at least they should create a flag to help us moderate and move solutions to the correct tab. Would only need a stack overflow moderation-like system: one person flags, another person receives a queue of flagged comments and confirms the tagging.. oh well"
                    },
                    {
                        "username": "charonme",
                        "content": "maybe people get confused by the official leetcode comment which says: \"If you\\'d like to share a detailed solution to the problem, please create a new post in the discuss section\"\\nMaybe some time ago they didn\\'t have a separate solutions section and only recently changed it, but left some of the old solutions in the discussion section and didn\\'t fix the automated comment worting?"
                    },
                    {
                        "username": "klanjewar037",
                        "content": "hehe"
                    },
                    {
                        "username": "sanemdeepak",
                        "content": "For input \"ac\" test case is expecting \"a\" as output, how is just \"a\" a palindromic string?"
                    },
                    {
                        "username": "ayushiidevpura",
                        "content": "because when we read \"a\" from forward it results in \"a\" and at the same time when we read \"a\" from backward it is still \"a\""
                    },
                    {
                        "username": "beyzigo",
                        "content": "Because if you read the string \"a\" backwards it will still be \"a\""
                    },
                    {
                        "username": "tsafackghokeng",
                        "content": "[@Chouhan_Gourav](/Chouhan_Gourav) the test case said \"ac\" not \"a\". is \"ac\" palindromic? for \"a\" i understand"
                    },
                    {
                        "username": "CODEWITHABHINAV",
                        "content": "you have to submit the first string as your answer read more about this question on gFg\\n"
                    },
                    {
                        "username": "_BREEZE_",
                        "content": "any string is palindrome if we read it same from front and from back\\nin single character we read it same from front and back"
                    },
                    {
                        "username": "oinrup",
                        "content": "yes thats my question too"
                    },
                    {
                        "username": "yldemon",
                        "content": "Any character in the string by itself is a palindromic substring. So in the case where there is no palindromic substring with length > 1, you can return any character."
                    },
                    {
                        "username": "Chouhan_Gourav",
                        "content": "Whenever you come accross such contradiction, just google the definition, any. Any string is called is pallindromic if the reverse of the string is equal to the original string. Reverse of \\'a\\' is \\'a\\'. Hope you get this."
                    },
                    {
                        "username": "947876275",
                        "content": "This post is for learner wanna practice DP.\\nThe basic idea is, if we wanna say \"aba\" is palindromic, then we need to firstly confirm that \"b\" is palindromic, then we also need to check if \"a\"(the first a) = \"a\" (the second a).\\n\\nM is a 2-d array which stores boolean values.\\nM[i][j] indicates if string[i.....j] is palindromic.\\nSo base cases are:\\nM[i][i] is true.\\nM[i][i + 1] = (s[i] == s[i + 1]);\\nrecurrence relation is :\\nM[i][j] = (s[i] == s[j] AND M[i + 1][j - 1]);\\nFor the implementation of recurrence relation, one idea is you can loop through all possible symmetry axis. For each of the axis, you expand at both RHS and LHS simultaneously. This method promises that when you are determining value in M[i][j], M[i + 1][j - 1] must have the correct value.\\nFinal answer can be found from all M[i][j] == 1 with largest (j - i)."
                    },
                    {
                        "username": "Msey",
                        "content": "thank you, cat brother"
                    },
                    {
                        "username": "user0558y",
                        "content": "I understand the solution but I don't understand why it needs any storage at all or why it needs to be a DP solution.\n\nThe condition `(s[i] == s[j] AND M[i + 1][j - 1])` requires you to memorise if `M[i+1][j-1]` is true, that's easy to understand. However, if you expand each possible axis at the same time, i.e. 1st iteration (s[i+1], s[j-1]), 2nd iteration `s[i+2], s[j-2]`, ... It is guaranteed that M[i+1][j-1] is always true and hence can be dropped, and you should break the loop when it is not true.\n\nIn summary, you don't need to memorise anything at all and you just need to check `s[i] == s[j]` while expanding in both directions at the same time, unless I have misunderstood anything? Here is an implementation of your algorithm but without storage: https://leetcode.com/problems/longest-palindromic-substring/submissions/868540120/"
                    },
                    {
                        "username": "taras",
                        "content": "Thank you! this is a beautiful explanation, though I\\'m not sure what exactly you mean by expanding both on LHS and RHS. In my implementation it\\'s enough to compute all diagonals of  the upper right triangle of the dp matrix."
                    },
                    {
                        "username": "klu_2100031593",
                        "content": "super explanation"
                    },
                    {
                        "username": "napoleon",
                        "content": "My Solution Is Naive, It Cost O(n^2), Is there Any Solution faster?"
                    },
                    {
                        "username": "leocampos",
                        "content": "[@tylerprill-rhdc](/tylerprill-rhdc) So, what I did was:\nStated in my mind the Brute Force approach - create every possible substring and test each one to see if is a palindrome and find the longest.\n\nOf course this would be ridiculously slow, so let's improve it.\nI also mentally stated that a palindrome has a recursive aspect -> if single char, or two equal chars, or charX + palindrome + charX\nSo I created a isPalindrome recursive method that checked it delegating to itself extracting the borders.\n\nSince a palindrome must start and end with the same char, in my traverse of the string, I started storing the position of each character Map<Character, List< Integer>>, so I would just go back to the previous found Char and check if from there to the current pointer I would have a Palindrome.\n\nThen I stopped doing this for every possible palindrome, I then started doing only for the ones that COULD be longer than the already found longest palindrome. That accelerated a lot.\n\nIn the almost last step, I added memoization. Remember that a palindrome is like a sandwich, with the external chars being equal and the meat being another palindrome? So I stored the found palindromes using their start and and positions. So I could check if that had already being checked and if so, either return true or false directly.\n\nThe final step was to convert the recursive function to an iterative function to save some memory used by the call stack.\nMaybe there are better implementations, just sharing my thought process."
                    },
                    {
                        "username": "tylerprill-rhdc",
                        "content": "[@tylerprill-rhdc](/tylerprill-rhdc) Two pointer based solution is also a really good solve here"
                    },
                    {
                        "username": "tylerprill-rhdc",
                        "content": "This could be done in a single pass algorithm, but will inherently check character indices multiple times based on the nature of the problem. (basically, iterate through each, then bubble out from each index)"
                    },
                    {
                        "username": "neetika",
                        "content": "From the leetcode blog, one of the methods of solving this is:\\n\\nA common mistake:\\nSome people will be tempted to come up with a quick solution, which is unfortunately flawed (however can be corrected easily):\\n\\nReverse S and become S\\u2019. Find the longest common substring between S and S\\u2019, which must also be the longest palindromic substring.\\nThis seemed to work, let\\u2019s see some examples below.\\n\\nFor example,\\nS = \\u201ccaba\\u201d, S\\u2019 = \\u201cabac\\u201d.\\nThe longest common substring between S and S\\u2019 is \\u201caba\\u201d, which is the answer.\\n\\nLet\\u2019s try another example:\\nS = \\u201cabacdfgdcaba\\u201d, S\\u2019 = \\u201cabacdgfdcaba\\u201d.\\nThe longest common substring between S and S\\u2019 is \\u201cabacd\\u201d. Clearly, this is not a valid palindrome.\\n\\n**We could see that the longest common substring method fails when there exists a reversed copy of a non-palindromic substring in some other part of S. To rectify this, each time we find a longest common substring candidate, we check if the substring\\u2019s indices are the same as the reversed substring\\u2019s original indices. If it is, then we attempt to update the longest palindrome found so far; if not, we skip this and find the next candidate.**\\n\\nIs this part correct? \\n\\nexample string: abcxycba\\nreverse string:  abcxycba\\n\\nThe substring indices are same as reversed string original indices and yet it is not a palindrome?"
                    },
                    {
                        "username": "HRVY_SNOWDEN",
                        "content": "cool sirr:)\\n"
                    },
                    {
                        "username": "dhtmlkitchen",
                        "content": "WRONG.\\n\\nabcxycba reversed is abcyxcba."
                    },
                    {
                        "username": "travisl12",
                        "content": "After I solved this problem I thought it\\'d be interesting to see how it worked in realtime.\\n\\nhttps://codepen.io/TravisL12/pen/pogvweg"
                    },
                    {
                        "username": "user3907vj",
                        "content": "thanks for the \"nanananananana\" from all the small things ;)"
                    },
                    {
                        "username": "zapataast",
                        "content": "u are crazy"
                    },
                    {
                        "username": "sondq98",
                        "content": "very intuitive"
                    },
                    {
                        "username": "Tathagat017",
                        "content": "thank you\\n"
                    },
                    {
                        "username": "mikler",
                        "content": "So I think I finally understood logic of test creators. \\nEven if you write a classical DP or memorization solution for this one you will timeout on latest tests.\\nI think they consider it edge cases. Because if you add one simple line it will pass! OMG. \\nI have leet code for this. Instead of solving problems I spend hours optimizing the constants.\\n\\nif s == s[::-1]: return s"
                    },
                    {
                        "username": "Vectorido",
                        "content": "Don\\'t work already. Time limit at 141 test even with that construction."
                    },
                    {
                        "username": "deepalithakur17",
                        "content": "It will only work in python."
                    },
                    {
                        "username": "ishogbon",
                        "content": "Its memoization, not memorization "
                    },
                    {
                        "username": "84danie",
                        "content": "I submitted my solution, and received a Time Limit Exceeded on this test case:\\n\\n\"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaabcaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"\\n\\nSo I copied and pasted the TC into a custom test case, and started to think about what I could tweak. However, I ended up accidentally hitting Run Code, but instead of getting a Time Limit Exceeded result, it passed:\\n\\n![0_1479079812693_upload-4af9e94c-2e53-4915-acf6-782780c7bf8b](/uploads/files/1479079813717-upload-4af9e94c-2e53-4915-acf6-782780c7bf8b.png) \\n\\nIs this supposed to happen and I just need to make my code more efficient, or is this a bug? \\n![0_1479079956817_upload-1ef15826-d6e6-4bde-9c06-eb597c5c8d0e](/uploads/files/1479079957639-upload-1ef15826-d6e6-4bde-9c06-eb597c5c8d0e.png)"
                    },
                    {
                        "username": "RitikaSahay",
                        "content": "Same thing happened with me. Is there a solution for it?\\n"
                    },
                    {
                        "username": "danicruz0415",
                        "content": "It\\'s happened to me a couple of times. My theory is that the time limit is given for the whole list of test cases. Thus, you can have your test pass, but it will still time limit exceed because it wont get to calculate all the test cases before the time runs out. I cannot confirm this but I think its true because with a very unoptimized solution I got time limit exceeded very early in the test cases (for another problem), after some optimizations I got it much later (like getting to the last tests) which themselves were around the same size, so if the time limit was set per test it would not make sense to fail in a similarly long test-case just that is much later in the test list. (I think the same would apply to memory limit exceeded)"
                    },
                    {
                        "username": "him_Sarma619",
                        "content": "The exact same situation happened with me in one problem... it was a DP problem too... I was getting a Memory Limit Exceeded error with the memoized solution but it was running fine in the Run Code button."
                    },
                    {
                        "username": "Hubro",
                        "content": "I\\'m getting \"Time Limit Exceeded\" with 141/141 testcases passed and \"Last Executed Input\" is:\\n\\n```\\ns =\\n```\\n\\nDid I break it?"
                    },
                    {
                        "username": "karan_dhiman",
                        "content": "same issue"
                    },
                    {
                        "username": "BLANK-Zora",
                        "content": "exactly bro this shit is recked , like it is giving tests outside the constraints , how am i suppose to include such things in the code"
                    },
                    {
                        "username": "arunprep5",
                        "content": "same issue. java"
                    },
                    {
                        "username": "blasphelmy",
                        "content": "[@tuancoltech](/tuancoltech) it worked when i rewrote the code in c# instead of c++"
                    },
                    {
                        "username": "tuancoltech",
                        "content": "[@blasphelmy](/blasphelmy) [@Tomas Sandven](/Hubro) Did you guys find out why? I got the same issue."
                    },
                    {
                        "username": "blasphelmy",
                        "content": "i got that too. im not sure whats going on given that the constraint for input is between 1 and 1000"
                    },
                    {
                        "username": "Vinitajain",
                        "content": "Hi All,\\nI have a test case which is failing, but I feel the testcase result is incorrect.Please refer the screenshot below.\\n![image](https://assets.leetcode.com/users/images/e9e42efb-63d5-4cfa-b420-f1926674f6dc_1654838015.8394327.png)\\n\\nThe longest palindromic substring is \"aaca\" but the test case result is \"aca\". Anyone else faced this problem?"
                    },
                    {
                        "username": "OthSO",
                        "content": "[@mohdansah10](/mohdansah10) \\nthey are separated in the input with \"bd\" so it is not a valid answer "
                    },
                    {
                        "username": "mohdansah10",
                        "content": "I\\'m getting same error, but different case:\\nInput\\ns =\\n\"aacabdkacaa\"\\n\\nOutput\\n\"aacakacaa\"\\nExpected\\n\"aca\"\\n\\nBut mine is Palindrome"
                    },
                    {
                        "username": "hasmithraa",
                        "content": "the expected is correct because aaca can\\'t be a palindrome only \\'aacaa\\' can be a palindrome which is not there in your case"
                    },
                    {
                        "username": "Amish_Singh",
                        "content": "how are you considering \"aaca\" as a palindromic substring, \"aca\" is a palindrome and it is the longest"
                    },
                    {
                        "username": "Shaik_Aman_Sayer",
                        "content": "dude you really came up with the solution "
                    },
                    {
                        "username": "AryaAditya3609",
                        "content": "how is \"aaca\" and \"acaa\" same ???\\nWhile \"aca\" is palindrome because both \"aca\" and reverse of it \"aca\" is same !!"
                    },
                    {
                        "username": "alexandra-pickle",
                        "content": "\"aaca\" is not a palindrome"
                    },
                    {
                        "username": "bugHackerLoop",
                        "content": "I followed the approach leant by Aditya Verma DP lectures and encountered the same test case failing. Does the logic where I reverse the string and calculate the longest common substring doesn\\'t work here? I know it works for longest palindromic subsequence but here it fails for such test cases .. why is it so?"
                    },
                    {
                        "username": "mductran",
                        "content": "how is \\'aaca\\' a palindrome? when read backward it\\'s \\'acaa\\' so it\\'s not the same reading forward."
                    },
                    {
                        "username": "jnsudhir",
                        "content": "Check my solution, it was able to clear test case \"aaca\". Explained code in comments.\\n\\nhttps://leetcode.com/problems/longest-palindromic-substring/solutions/3091016/longest-palindromic-substring-using-javascript-beats-94-82-in-runtime-explained/?orderBy=most_votes"
                    },
                    {
                        "username": "nikhileshratna",
                        "content": "aaca is not palindrome"
                    },
                    {
                        "username": "sunshine77",
                        "content": "hey, iam getting the same error, i have seen ansewrs where they have totally changed the algorithm, how did u solve this by tweaking the same algoirhtm"
                    },
                    {
                        "username": "bhupendrabc71",
                        "content": "how come \"aaca\" is palindrome. it should be \"aca\""
                    },
                    {
                        "username": "just11blocks",
                        "content": "aaca is not a palindrome...aacaa and aca are."
                    },
                    {
                        "username": "odi1n",
                        "content": "I also encountered this problem"
                    },
                    {
                        "username": "vamsi2302",
                        "content": "I think you get it by now!\\n"
                    }
                ]
            },
            {
                "id": 1573869,
                "content": [
                    {
                        "username": "ZenMasterV",
                        "content": "Seems like too many of the  coding wunderkinds here lack basic reading comprehension skills \\n\" Please don\\'t post any solutions in this discussion tab\"\\nIt\\'s almost the rule to find the exact opposite for the discussion of every question. I don\\'t want to see your damned solution!"
                    },
                    {
                        "username": "NeroXIII",
                        "content": "[@charonme](/charonme) name does not check out :((("
                    },
                    {
                        "username": "192731",
                        "content": "and if they do?"
                    },
                    {
                        "username": "plevi1995",
                        "content": "Excellent comment"
                    },
                    {
                        "username": "khan60939",
                        "content": "Can anyone tell how DP is being used here? "
                    },
                    {
                        "username": "sandagolcea",
                        "content": "[@charonme](/charonme) my thinking exactly, but at least they should create a flag to help us moderate and move solutions to the correct tab. Would only need a stack overflow moderation-like system: one person flags, another person receives a queue of flagged comments and confirms the tagging.. oh well"
                    },
                    {
                        "username": "charonme",
                        "content": "maybe people get confused by the official leetcode comment which says: \"If you\\'d like to share a detailed solution to the problem, please create a new post in the discuss section\"\\nMaybe some time ago they didn\\'t have a separate solutions section and only recently changed it, but left some of the old solutions in the discussion section and didn\\'t fix the automated comment worting?"
                    },
                    {
                        "username": "klanjewar037",
                        "content": "hehe"
                    },
                    {
                        "username": "sanemdeepak",
                        "content": "For input \"ac\" test case is expecting \"a\" as output, how is just \"a\" a palindromic string?"
                    },
                    {
                        "username": "ayushiidevpura",
                        "content": "because when we read \"a\" from forward it results in \"a\" and at the same time when we read \"a\" from backward it is still \"a\""
                    },
                    {
                        "username": "beyzigo",
                        "content": "Because if you read the string \"a\" backwards it will still be \"a\""
                    },
                    {
                        "username": "tsafackghokeng",
                        "content": "[@Chouhan_Gourav](/Chouhan_Gourav) the test case said \"ac\" not \"a\". is \"ac\" palindromic? for \"a\" i understand"
                    },
                    {
                        "username": "CODEWITHABHINAV",
                        "content": "you have to submit the first string as your answer read more about this question on gFg\\n"
                    },
                    {
                        "username": "_BREEZE_",
                        "content": "any string is palindrome if we read it same from front and from back\\nin single character we read it same from front and back"
                    },
                    {
                        "username": "oinrup",
                        "content": "yes thats my question too"
                    },
                    {
                        "username": "yldemon",
                        "content": "Any character in the string by itself is a palindromic substring. So in the case where there is no palindromic substring with length > 1, you can return any character."
                    },
                    {
                        "username": "Chouhan_Gourav",
                        "content": "Whenever you come accross such contradiction, just google the definition, any. Any string is called is pallindromic if the reverse of the string is equal to the original string. Reverse of \\'a\\' is \\'a\\'. Hope you get this."
                    },
                    {
                        "username": "947876275",
                        "content": "This post is for learner wanna practice DP.\\nThe basic idea is, if we wanna say \"aba\" is palindromic, then we need to firstly confirm that \"b\" is palindromic, then we also need to check if \"a\"(the first a) = \"a\" (the second a).\\n\\nM is a 2-d array which stores boolean values.\\nM[i][j] indicates if string[i.....j] is palindromic.\\nSo base cases are:\\nM[i][i] is true.\\nM[i][i + 1] = (s[i] == s[i + 1]);\\nrecurrence relation is :\\nM[i][j] = (s[i] == s[j] AND M[i + 1][j - 1]);\\nFor the implementation of recurrence relation, one idea is you can loop through all possible symmetry axis. For each of the axis, you expand at both RHS and LHS simultaneously. This method promises that when you are determining value in M[i][j], M[i + 1][j - 1] must have the correct value.\\nFinal answer can be found from all M[i][j] == 1 with largest (j - i)."
                    },
                    {
                        "username": "Msey",
                        "content": "thank you, cat brother"
                    },
                    {
                        "username": "user0558y",
                        "content": "I understand the solution but I don't understand why it needs any storage at all or why it needs to be a DP solution.\n\nThe condition `(s[i] == s[j] AND M[i + 1][j - 1])` requires you to memorise if `M[i+1][j-1]` is true, that's easy to understand. However, if you expand each possible axis at the same time, i.e. 1st iteration (s[i+1], s[j-1]), 2nd iteration `s[i+2], s[j-2]`, ... It is guaranteed that M[i+1][j-1] is always true and hence can be dropped, and you should break the loop when it is not true.\n\nIn summary, you don't need to memorise anything at all and you just need to check `s[i] == s[j]` while expanding in both directions at the same time, unless I have misunderstood anything? Here is an implementation of your algorithm but without storage: https://leetcode.com/problems/longest-palindromic-substring/submissions/868540120/"
                    },
                    {
                        "username": "taras",
                        "content": "Thank you! this is a beautiful explanation, though I\\'m not sure what exactly you mean by expanding both on LHS and RHS. In my implementation it\\'s enough to compute all diagonals of  the upper right triangle of the dp matrix."
                    },
                    {
                        "username": "klu_2100031593",
                        "content": "super explanation"
                    },
                    {
                        "username": "napoleon",
                        "content": "My Solution Is Naive, It Cost O(n^2), Is there Any Solution faster?"
                    },
                    {
                        "username": "leocampos",
                        "content": "[@tylerprill-rhdc](/tylerprill-rhdc) So, what I did was:\nStated in my mind the Brute Force approach - create every possible substring and test each one to see if is a palindrome and find the longest.\n\nOf course this would be ridiculously slow, so let's improve it.\nI also mentally stated that a palindrome has a recursive aspect -> if single char, or two equal chars, or charX + palindrome + charX\nSo I created a isPalindrome recursive method that checked it delegating to itself extracting the borders.\n\nSince a palindrome must start and end with the same char, in my traverse of the string, I started storing the position of each character Map<Character, List< Integer>>, so I would just go back to the previous found Char and check if from there to the current pointer I would have a Palindrome.\n\nThen I stopped doing this for every possible palindrome, I then started doing only for the ones that COULD be longer than the already found longest palindrome. That accelerated a lot.\n\nIn the almost last step, I added memoization. Remember that a palindrome is like a sandwich, with the external chars being equal and the meat being another palindrome? So I stored the found palindromes using their start and and positions. So I could check if that had already being checked and if so, either return true or false directly.\n\nThe final step was to convert the recursive function to an iterative function to save some memory used by the call stack.\nMaybe there are better implementations, just sharing my thought process."
                    },
                    {
                        "username": "tylerprill-rhdc",
                        "content": "[@tylerprill-rhdc](/tylerprill-rhdc) Two pointer based solution is also a really good solve here"
                    },
                    {
                        "username": "tylerprill-rhdc",
                        "content": "This could be done in a single pass algorithm, but will inherently check character indices multiple times based on the nature of the problem. (basically, iterate through each, then bubble out from each index)"
                    },
                    {
                        "username": "neetika",
                        "content": "From the leetcode blog, one of the methods of solving this is:\\n\\nA common mistake:\\nSome people will be tempted to come up with a quick solution, which is unfortunately flawed (however can be corrected easily):\\n\\nReverse S and become S\\u2019. Find the longest common substring between S and S\\u2019, which must also be the longest palindromic substring.\\nThis seemed to work, let\\u2019s see some examples below.\\n\\nFor example,\\nS = \\u201ccaba\\u201d, S\\u2019 = \\u201cabac\\u201d.\\nThe longest common substring between S and S\\u2019 is \\u201caba\\u201d, which is the answer.\\n\\nLet\\u2019s try another example:\\nS = \\u201cabacdfgdcaba\\u201d, S\\u2019 = \\u201cabacdgfdcaba\\u201d.\\nThe longest common substring between S and S\\u2019 is \\u201cabacd\\u201d. Clearly, this is not a valid palindrome.\\n\\n**We could see that the longest common substring method fails when there exists a reversed copy of a non-palindromic substring in some other part of S. To rectify this, each time we find a longest common substring candidate, we check if the substring\\u2019s indices are the same as the reversed substring\\u2019s original indices. If it is, then we attempt to update the longest palindrome found so far; if not, we skip this and find the next candidate.**\\n\\nIs this part correct? \\n\\nexample string: abcxycba\\nreverse string:  abcxycba\\n\\nThe substring indices are same as reversed string original indices and yet it is not a palindrome?"
                    },
                    {
                        "username": "HRVY_SNOWDEN",
                        "content": "cool sirr:)\\n"
                    },
                    {
                        "username": "dhtmlkitchen",
                        "content": "WRONG.\\n\\nabcxycba reversed is abcyxcba."
                    },
                    {
                        "username": "travisl12",
                        "content": "After I solved this problem I thought it\\'d be interesting to see how it worked in realtime.\\n\\nhttps://codepen.io/TravisL12/pen/pogvweg"
                    },
                    {
                        "username": "user3907vj",
                        "content": "thanks for the \"nanananananana\" from all the small things ;)"
                    },
                    {
                        "username": "zapataast",
                        "content": "u are crazy"
                    },
                    {
                        "username": "sondq98",
                        "content": "very intuitive"
                    },
                    {
                        "username": "Tathagat017",
                        "content": "thank you\\n"
                    },
                    {
                        "username": "mikler",
                        "content": "So I think I finally understood logic of test creators. \\nEven if you write a classical DP or memorization solution for this one you will timeout on latest tests.\\nI think they consider it edge cases. Because if you add one simple line it will pass! OMG. \\nI have leet code for this. Instead of solving problems I spend hours optimizing the constants.\\n\\nif s == s[::-1]: return s"
                    },
                    {
                        "username": "Vectorido",
                        "content": "Don\\'t work already. Time limit at 141 test even with that construction."
                    },
                    {
                        "username": "deepalithakur17",
                        "content": "It will only work in python."
                    },
                    {
                        "username": "ishogbon",
                        "content": "Its memoization, not memorization "
                    },
                    {
                        "username": "84danie",
                        "content": "I submitted my solution, and received a Time Limit Exceeded on this test case:\\n\\n\"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaabcaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"\\n\\nSo I copied and pasted the TC into a custom test case, and started to think about what I could tweak. However, I ended up accidentally hitting Run Code, but instead of getting a Time Limit Exceeded result, it passed:\\n\\n![0_1479079812693_upload-4af9e94c-2e53-4915-acf6-782780c7bf8b](/uploads/files/1479079813717-upload-4af9e94c-2e53-4915-acf6-782780c7bf8b.png) \\n\\nIs this supposed to happen and I just need to make my code more efficient, or is this a bug? \\n![0_1479079956817_upload-1ef15826-d6e6-4bde-9c06-eb597c5c8d0e](/uploads/files/1479079957639-upload-1ef15826-d6e6-4bde-9c06-eb597c5c8d0e.png)"
                    },
                    {
                        "username": "RitikaSahay",
                        "content": "Same thing happened with me. Is there a solution for it?\\n"
                    },
                    {
                        "username": "danicruz0415",
                        "content": "It\\'s happened to me a couple of times. My theory is that the time limit is given for the whole list of test cases. Thus, you can have your test pass, but it will still time limit exceed because it wont get to calculate all the test cases before the time runs out. I cannot confirm this but I think its true because with a very unoptimized solution I got time limit exceeded very early in the test cases (for another problem), after some optimizations I got it much later (like getting to the last tests) which themselves were around the same size, so if the time limit was set per test it would not make sense to fail in a similarly long test-case just that is much later in the test list. (I think the same would apply to memory limit exceeded)"
                    },
                    {
                        "username": "him_Sarma619",
                        "content": "The exact same situation happened with me in one problem... it was a DP problem too... I was getting a Memory Limit Exceeded error with the memoized solution but it was running fine in the Run Code button."
                    },
                    {
                        "username": "Hubro",
                        "content": "I\\'m getting \"Time Limit Exceeded\" with 141/141 testcases passed and \"Last Executed Input\" is:\\n\\n```\\ns =\\n```\\n\\nDid I break it?"
                    },
                    {
                        "username": "karan_dhiman",
                        "content": "same issue"
                    },
                    {
                        "username": "BLANK-Zora",
                        "content": "exactly bro this shit is recked , like it is giving tests outside the constraints , how am i suppose to include such things in the code"
                    },
                    {
                        "username": "arunprep5",
                        "content": "same issue. java"
                    },
                    {
                        "username": "blasphelmy",
                        "content": "[@tuancoltech](/tuancoltech) it worked when i rewrote the code in c# instead of c++"
                    },
                    {
                        "username": "tuancoltech",
                        "content": "[@blasphelmy](/blasphelmy) [@Tomas Sandven](/Hubro) Did you guys find out why? I got the same issue."
                    },
                    {
                        "username": "blasphelmy",
                        "content": "i got that too. im not sure whats going on given that the constraint for input is between 1 and 1000"
                    },
                    {
                        "username": "Vinitajain",
                        "content": "Hi All,\\nI have a test case which is failing, but I feel the testcase result is incorrect.Please refer the screenshot below.\\n![image](https://assets.leetcode.com/users/images/e9e42efb-63d5-4cfa-b420-f1926674f6dc_1654838015.8394327.png)\\n\\nThe longest palindromic substring is \"aaca\" but the test case result is \"aca\". Anyone else faced this problem?"
                    },
                    {
                        "username": "OthSO",
                        "content": "[@mohdansah10](/mohdansah10) \\nthey are separated in the input with \"bd\" so it is not a valid answer "
                    },
                    {
                        "username": "mohdansah10",
                        "content": "I\\'m getting same error, but different case:\\nInput\\ns =\\n\"aacabdkacaa\"\\n\\nOutput\\n\"aacakacaa\"\\nExpected\\n\"aca\"\\n\\nBut mine is Palindrome"
                    },
                    {
                        "username": "hasmithraa",
                        "content": "the expected is correct because aaca can\\'t be a palindrome only \\'aacaa\\' can be a palindrome which is not there in your case"
                    },
                    {
                        "username": "Amish_Singh",
                        "content": "how are you considering \"aaca\" as a palindromic substring, \"aca\" is a palindrome and it is the longest"
                    },
                    {
                        "username": "Shaik_Aman_Sayer",
                        "content": "dude you really came up with the solution "
                    },
                    {
                        "username": "AryaAditya3609",
                        "content": "how is \"aaca\" and \"acaa\" same ???\\nWhile \"aca\" is palindrome because both \"aca\" and reverse of it \"aca\" is same !!"
                    },
                    {
                        "username": "alexandra-pickle",
                        "content": "\"aaca\" is not a palindrome"
                    },
                    {
                        "username": "bugHackerLoop",
                        "content": "I followed the approach leant by Aditya Verma DP lectures and encountered the same test case failing. Does the logic where I reverse the string and calculate the longest common substring doesn\\'t work here? I know it works for longest palindromic subsequence but here it fails for such test cases .. why is it so?"
                    },
                    {
                        "username": "mductran",
                        "content": "how is \\'aaca\\' a palindrome? when read backward it\\'s \\'acaa\\' so it\\'s not the same reading forward."
                    },
                    {
                        "username": "jnsudhir",
                        "content": "Check my solution, it was able to clear test case \"aaca\". Explained code in comments.\\n\\nhttps://leetcode.com/problems/longest-palindromic-substring/solutions/3091016/longest-palindromic-substring-using-javascript-beats-94-82-in-runtime-explained/?orderBy=most_votes"
                    },
                    {
                        "username": "nikhileshratna",
                        "content": "aaca is not palindrome"
                    },
                    {
                        "username": "sunshine77",
                        "content": "hey, iam getting the same error, i have seen ansewrs where they have totally changed the algorithm, how did u solve this by tweaking the same algoirhtm"
                    },
                    {
                        "username": "bhupendrabc71",
                        "content": "how come \"aaca\" is palindrome. it should be \"aca\""
                    },
                    {
                        "username": "just11blocks",
                        "content": "aaca is not a palindrome...aacaa and aca are."
                    },
                    {
                        "username": "odi1n",
                        "content": "I also encountered this problem"
                    },
                    {
                        "username": "vamsi2302",
                        "content": "I think you get it by now!\\n"
                    }
                ]
            },
            {
                "id": 1568802,
                "content": [
                    {
                        "username": "ZenMasterV",
                        "content": "Seems like too many of the  coding wunderkinds here lack basic reading comprehension skills \\n\" Please don\\'t post any solutions in this discussion tab\"\\nIt\\'s almost the rule to find the exact opposite for the discussion of every question. I don\\'t want to see your damned solution!"
                    },
                    {
                        "username": "NeroXIII",
                        "content": "[@charonme](/charonme) name does not check out :((("
                    },
                    {
                        "username": "192731",
                        "content": "and if they do?"
                    },
                    {
                        "username": "plevi1995",
                        "content": "Excellent comment"
                    },
                    {
                        "username": "khan60939",
                        "content": "Can anyone tell how DP is being used here? "
                    },
                    {
                        "username": "sandagolcea",
                        "content": "[@charonme](/charonme) my thinking exactly, but at least they should create a flag to help us moderate and move solutions to the correct tab. Would only need a stack overflow moderation-like system: one person flags, another person receives a queue of flagged comments and confirms the tagging.. oh well"
                    },
                    {
                        "username": "charonme",
                        "content": "maybe people get confused by the official leetcode comment which says: \"If you\\'d like to share a detailed solution to the problem, please create a new post in the discuss section\"\\nMaybe some time ago they didn\\'t have a separate solutions section and only recently changed it, but left some of the old solutions in the discussion section and didn\\'t fix the automated comment worting?"
                    },
                    {
                        "username": "klanjewar037",
                        "content": "hehe"
                    },
                    {
                        "username": "sanemdeepak",
                        "content": "For input \"ac\" test case is expecting \"a\" as output, how is just \"a\" a palindromic string?"
                    },
                    {
                        "username": "ayushiidevpura",
                        "content": "because when we read \"a\" from forward it results in \"a\" and at the same time when we read \"a\" from backward it is still \"a\""
                    },
                    {
                        "username": "beyzigo",
                        "content": "Because if you read the string \"a\" backwards it will still be \"a\""
                    },
                    {
                        "username": "tsafackghokeng",
                        "content": "[@Chouhan_Gourav](/Chouhan_Gourav) the test case said \"ac\" not \"a\". is \"ac\" palindromic? for \"a\" i understand"
                    },
                    {
                        "username": "CODEWITHABHINAV",
                        "content": "you have to submit the first string as your answer read more about this question on gFg\\n"
                    },
                    {
                        "username": "_BREEZE_",
                        "content": "any string is palindrome if we read it same from front and from back\\nin single character we read it same from front and back"
                    },
                    {
                        "username": "oinrup",
                        "content": "yes thats my question too"
                    },
                    {
                        "username": "yldemon",
                        "content": "Any character in the string by itself is a palindromic substring. So in the case where there is no palindromic substring with length > 1, you can return any character."
                    },
                    {
                        "username": "Chouhan_Gourav",
                        "content": "Whenever you come accross such contradiction, just google the definition, any. Any string is called is pallindromic if the reverse of the string is equal to the original string. Reverse of \\'a\\' is \\'a\\'. Hope you get this."
                    },
                    {
                        "username": "947876275",
                        "content": "This post is for learner wanna practice DP.\\nThe basic idea is, if we wanna say \"aba\" is palindromic, then we need to firstly confirm that \"b\" is palindromic, then we also need to check if \"a\"(the first a) = \"a\" (the second a).\\n\\nM is a 2-d array which stores boolean values.\\nM[i][j] indicates if string[i.....j] is palindromic.\\nSo base cases are:\\nM[i][i] is true.\\nM[i][i + 1] = (s[i] == s[i + 1]);\\nrecurrence relation is :\\nM[i][j] = (s[i] == s[j] AND M[i + 1][j - 1]);\\nFor the implementation of recurrence relation, one idea is you can loop through all possible symmetry axis. For each of the axis, you expand at both RHS and LHS simultaneously. This method promises that when you are determining value in M[i][j], M[i + 1][j - 1] must have the correct value.\\nFinal answer can be found from all M[i][j] == 1 with largest (j - i)."
                    },
                    {
                        "username": "Msey",
                        "content": "thank you, cat brother"
                    },
                    {
                        "username": "user0558y",
                        "content": "I understand the solution but I don't understand why it needs any storage at all or why it needs to be a DP solution.\n\nThe condition `(s[i] == s[j] AND M[i + 1][j - 1])` requires you to memorise if `M[i+1][j-1]` is true, that's easy to understand. However, if you expand each possible axis at the same time, i.e. 1st iteration (s[i+1], s[j-1]), 2nd iteration `s[i+2], s[j-2]`, ... It is guaranteed that M[i+1][j-1] is always true and hence can be dropped, and you should break the loop when it is not true.\n\nIn summary, you don't need to memorise anything at all and you just need to check `s[i] == s[j]` while expanding in both directions at the same time, unless I have misunderstood anything? Here is an implementation of your algorithm but without storage: https://leetcode.com/problems/longest-palindromic-substring/submissions/868540120/"
                    },
                    {
                        "username": "taras",
                        "content": "Thank you! this is a beautiful explanation, though I\\'m not sure what exactly you mean by expanding both on LHS and RHS. In my implementation it\\'s enough to compute all diagonals of  the upper right triangle of the dp matrix."
                    },
                    {
                        "username": "klu_2100031593",
                        "content": "super explanation"
                    },
                    {
                        "username": "napoleon",
                        "content": "My Solution Is Naive, It Cost O(n^2), Is there Any Solution faster?"
                    },
                    {
                        "username": "leocampos",
                        "content": "[@tylerprill-rhdc](/tylerprill-rhdc) So, what I did was:\nStated in my mind the Brute Force approach - create every possible substring and test each one to see if is a palindrome and find the longest.\n\nOf course this would be ridiculously slow, so let's improve it.\nI also mentally stated that a palindrome has a recursive aspect -> if single char, or two equal chars, or charX + palindrome + charX\nSo I created a isPalindrome recursive method that checked it delegating to itself extracting the borders.\n\nSince a palindrome must start and end with the same char, in my traverse of the string, I started storing the position of each character Map<Character, List< Integer>>, so I would just go back to the previous found Char and check if from there to the current pointer I would have a Palindrome.\n\nThen I stopped doing this for every possible palindrome, I then started doing only for the ones that COULD be longer than the already found longest palindrome. That accelerated a lot.\n\nIn the almost last step, I added memoization. Remember that a palindrome is like a sandwich, with the external chars being equal and the meat being another palindrome? So I stored the found palindromes using their start and and positions. So I could check if that had already being checked and if so, either return true or false directly.\n\nThe final step was to convert the recursive function to an iterative function to save some memory used by the call stack.\nMaybe there are better implementations, just sharing my thought process."
                    },
                    {
                        "username": "tylerprill-rhdc",
                        "content": "[@tylerprill-rhdc](/tylerprill-rhdc) Two pointer based solution is also a really good solve here"
                    },
                    {
                        "username": "tylerprill-rhdc",
                        "content": "This could be done in a single pass algorithm, but will inherently check character indices multiple times based on the nature of the problem. (basically, iterate through each, then bubble out from each index)"
                    },
                    {
                        "username": "neetika",
                        "content": "From the leetcode blog, one of the methods of solving this is:\\n\\nA common mistake:\\nSome people will be tempted to come up with a quick solution, which is unfortunately flawed (however can be corrected easily):\\n\\nReverse S and become S\\u2019. Find the longest common substring between S and S\\u2019, which must also be the longest palindromic substring.\\nThis seemed to work, let\\u2019s see some examples below.\\n\\nFor example,\\nS = \\u201ccaba\\u201d, S\\u2019 = \\u201cabac\\u201d.\\nThe longest common substring between S and S\\u2019 is \\u201caba\\u201d, which is the answer.\\n\\nLet\\u2019s try another example:\\nS = \\u201cabacdfgdcaba\\u201d, S\\u2019 = \\u201cabacdgfdcaba\\u201d.\\nThe longest common substring between S and S\\u2019 is \\u201cabacd\\u201d. Clearly, this is not a valid palindrome.\\n\\n**We could see that the longest common substring method fails when there exists a reversed copy of a non-palindromic substring in some other part of S. To rectify this, each time we find a longest common substring candidate, we check if the substring\\u2019s indices are the same as the reversed substring\\u2019s original indices. If it is, then we attempt to update the longest palindrome found so far; if not, we skip this and find the next candidate.**\\n\\nIs this part correct? \\n\\nexample string: abcxycba\\nreverse string:  abcxycba\\n\\nThe substring indices are same as reversed string original indices and yet it is not a palindrome?"
                    },
                    {
                        "username": "HRVY_SNOWDEN",
                        "content": "cool sirr:)\\n"
                    },
                    {
                        "username": "dhtmlkitchen",
                        "content": "WRONG.\\n\\nabcxycba reversed is abcyxcba."
                    },
                    {
                        "username": "travisl12",
                        "content": "After I solved this problem I thought it\\'d be interesting to see how it worked in realtime.\\n\\nhttps://codepen.io/TravisL12/pen/pogvweg"
                    },
                    {
                        "username": "user3907vj",
                        "content": "thanks for the \"nanananananana\" from all the small things ;)"
                    },
                    {
                        "username": "zapataast",
                        "content": "u are crazy"
                    },
                    {
                        "username": "sondq98",
                        "content": "very intuitive"
                    },
                    {
                        "username": "Tathagat017",
                        "content": "thank you\\n"
                    },
                    {
                        "username": "mikler",
                        "content": "So I think I finally understood logic of test creators. \\nEven if you write a classical DP or memorization solution for this one you will timeout on latest tests.\\nI think they consider it edge cases. Because if you add one simple line it will pass! OMG. \\nI have leet code for this. Instead of solving problems I spend hours optimizing the constants.\\n\\nif s == s[::-1]: return s"
                    },
                    {
                        "username": "Vectorido",
                        "content": "Don\\'t work already. Time limit at 141 test even with that construction."
                    },
                    {
                        "username": "deepalithakur17",
                        "content": "It will only work in python."
                    },
                    {
                        "username": "ishogbon",
                        "content": "Its memoization, not memorization "
                    },
                    {
                        "username": "84danie",
                        "content": "I submitted my solution, and received a Time Limit Exceeded on this test case:\\n\\n\"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaabcaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"\\n\\nSo I copied and pasted the TC into a custom test case, and started to think about what I could tweak. However, I ended up accidentally hitting Run Code, but instead of getting a Time Limit Exceeded result, it passed:\\n\\n![0_1479079812693_upload-4af9e94c-2e53-4915-acf6-782780c7bf8b](/uploads/files/1479079813717-upload-4af9e94c-2e53-4915-acf6-782780c7bf8b.png) \\n\\nIs this supposed to happen and I just need to make my code more efficient, or is this a bug? \\n![0_1479079956817_upload-1ef15826-d6e6-4bde-9c06-eb597c5c8d0e](/uploads/files/1479079957639-upload-1ef15826-d6e6-4bde-9c06-eb597c5c8d0e.png)"
                    },
                    {
                        "username": "RitikaSahay",
                        "content": "Same thing happened with me. Is there a solution for it?\\n"
                    },
                    {
                        "username": "danicruz0415",
                        "content": "It\\'s happened to me a couple of times. My theory is that the time limit is given for the whole list of test cases. Thus, you can have your test pass, but it will still time limit exceed because it wont get to calculate all the test cases before the time runs out. I cannot confirm this but I think its true because with a very unoptimized solution I got time limit exceeded very early in the test cases (for another problem), after some optimizations I got it much later (like getting to the last tests) which themselves were around the same size, so if the time limit was set per test it would not make sense to fail in a similarly long test-case just that is much later in the test list. (I think the same would apply to memory limit exceeded)"
                    },
                    {
                        "username": "him_Sarma619",
                        "content": "The exact same situation happened with me in one problem... it was a DP problem too... I was getting a Memory Limit Exceeded error with the memoized solution but it was running fine in the Run Code button."
                    },
                    {
                        "username": "Hubro",
                        "content": "I\\'m getting \"Time Limit Exceeded\" with 141/141 testcases passed and \"Last Executed Input\" is:\\n\\n```\\ns =\\n```\\n\\nDid I break it?"
                    },
                    {
                        "username": "karan_dhiman",
                        "content": "same issue"
                    },
                    {
                        "username": "BLANK-Zora",
                        "content": "exactly bro this shit is recked , like it is giving tests outside the constraints , how am i suppose to include such things in the code"
                    },
                    {
                        "username": "arunprep5",
                        "content": "same issue. java"
                    },
                    {
                        "username": "blasphelmy",
                        "content": "[@tuancoltech](/tuancoltech) it worked when i rewrote the code in c# instead of c++"
                    },
                    {
                        "username": "tuancoltech",
                        "content": "[@blasphelmy](/blasphelmy) [@Tomas Sandven](/Hubro) Did you guys find out why? I got the same issue."
                    },
                    {
                        "username": "blasphelmy",
                        "content": "i got that too. im not sure whats going on given that the constraint for input is between 1 and 1000"
                    },
                    {
                        "username": "Vinitajain",
                        "content": "Hi All,\\nI have a test case which is failing, but I feel the testcase result is incorrect.Please refer the screenshot below.\\n![image](https://assets.leetcode.com/users/images/e9e42efb-63d5-4cfa-b420-f1926674f6dc_1654838015.8394327.png)\\n\\nThe longest palindromic substring is \"aaca\" but the test case result is \"aca\". Anyone else faced this problem?"
                    },
                    {
                        "username": "OthSO",
                        "content": "[@mohdansah10](/mohdansah10) \\nthey are separated in the input with \"bd\" so it is not a valid answer "
                    },
                    {
                        "username": "mohdansah10",
                        "content": "I\\'m getting same error, but different case:\\nInput\\ns =\\n\"aacabdkacaa\"\\n\\nOutput\\n\"aacakacaa\"\\nExpected\\n\"aca\"\\n\\nBut mine is Palindrome"
                    },
                    {
                        "username": "hasmithraa",
                        "content": "the expected is correct because aaca can\\'t be a palindrome only \\'aacaa\\' can be a palindrome which is not there in your case"
                    },
                    {
                        "username": "Amish_Singh",
                        "content": "how are you considering \"aaca\" as a palindromic substring, \"aca\" is a palindrome and it is the longest"
                    },
                    {
                        "username": "Shaik_Aman_Sayer",
                        "content": "dude you really came up with the solution "
                    },
                    {
                        "username": "AryaAditya3609",
                        "content": "how is \"aaca\" and \"acaa\" same ???\\nWhile \"aca\" is palindrome because both \"aca\" and reverse of it \"aca\" is same !!"
                    },
                    {
                        "username": "alexandra-pickle",
                        "content": "\"aaca\" is not a palindrome"
                    },
                    {
                        "username": "bugHackerLoop",
                        "content": "I followed the approach leant by Aditya Verma DP lectures and encountered the same test case failing. Does the logic where I reverse the string and calculate the longest common substring doesn\\'t work here? I know it works for longest palindromic subsequence but here it fails for such test cases .. why is it so?"
                    },
                    {
                        "username": "mductran",
                        "content": "how is \\'aaca\\' a palindrome? when read backward it\\'s \\'acaa\\' so it\\'s not the same reading forward."
                    },
                    {
                        "username": "jnsudhir",
                        "content": "Check my solution, it was able to clear test case \"aaca\". Explained code in comments.\\n\\nhttps://leetcode.com/problems/longest-palindromic-substring/solutions/3091016/longest-palindromic-substring-using-javascript-beats-94-82-in-runtime-explained/?orderBy=most_votes"
                    },
                    {
                        "username": "nikhileshratna",
                        "content": "aaca is not palindrome"
                    },
                    {
                        "username": "sunshine77",
                        "content": "hey, iam getting the same error, i have seen ansewrs where they have totally changed the algorithm, how did u solve this by tweaking the same algoirhtm"
                    },
                    {
                        "username": "bhupendrabc71",
                        "content": "how come \"aaca\" is palindrome. it should be \"aca\""
                    },
                    {
                        "username": "just11blocks",
                        "content": "aaca is not a palindrome...aacaa and aca are."
                    },
                    {
                        "username": "odi1n",
                        "content": "I also encountered this problem"
                    },
                    {
                        "username": "vamsi2302",
                        "content": "I think you get it by now!\\n"
                    }
                ]
            },
            {
                "id": 1570975,
                "content": [
                    {
                        "username": "ZenMasterV",
                        "content": "Seems like too many of the  coding wunderkinds here lack basic reading comprehension skills \\n\" Please don\\'t post any solutions in this discussion tab\"\\nIt\\'s almost the rule to find the exact opposite for the discussion of every question. I don\\'t want to see your damned solution!"
                    },
                    {
                        "username": "NeroXIII",
                        "content": "[@charonme](/charonme) name does not check out :((("
                    },
                    {
                        "username": "192731",
                        "content": "and if they do?"
                    },
                    {
                        "username": "plevi1995",
                        "content": "Excellent comment"
                    },
                    {
                        "username": "khan60939",
                        "content": "Can anyone tell how DP is being used here? "
                    },
                    {
                        "username": "sandagolcea",
                        "content": "[@charonme](/charonme) my thinking exactly, but at least they should create a flag to help us moderate and move solutions to the correct tab. Would only need a stack overflow moderation-like system: one person flags, another person receives a queue of flagged comments and confirms the tagging.. oh well"
                    },
                    {
                        "username": "charonme",
                        "content": "maybe people get confused by the official leetcode comment which says: \"If you\\'d like to share a detailed solution to the problem, please create a new post in the discuss section\"\\nMaybe some time ago they didn\\'t have a separate solutions section and only recently changed it, but left some of the old solutions in the discussion section and didn\\'t fix the automated comment worting?"
                    },
                    {
                        "username": "klanjewar037",
                        "content": "hehe"
                    },
                    {
                        "username": "sanemdeepak",
                        "content": "For input \"ac\" test case is expecting \"a\" as output, how is just \"a\" a palindromic string?"
                    },
                    {
                        "username": "ayushiidevpura",
                        "content": "because when we read \"a\" from forward it results in \"a\" and at the same time when we read \"a\" from backward it is still \"a\""
                    },
                    {
                        "username": "beyzigo",
                        "content": "Because if you read the string \"a\" backwards it will still be \"a\""
                    },
                    {
                        "username": "tsafackghokeng",
                        "content": "[@Chouhan_Gourav](/Chouhan_Gourav) the test case said \"ac\" not \"a\". is \"ac\" palindromic? for \"a\" i understand"
                    },
                    {
                        "username": "CODEWITHABHINAV",
                        "content": "you have to submit the first string as your answer read more about this question on gFg\\n"
                    },
                    {
                        "username": "_BREEZE_",
                        "content": "any string is palindrome if we read it same from front and from back\\nin single character we read it same from front and back"
                    },
                    {
                        "username": "oinrup",
                        "content": "yes thats my question too"
                    },
                    {
                        "username": "yldemon",
                        "content": "Any character in the string by itself is a palindromic substring. So in the case where there is no palindromic substring with length > 1, you can return any character."
                    },
                    {
                        "username": "Chouhan_Gourav",
                        "content": "Whenever you come accross such contradiction, just google the definition, any. Any string is called is pallindromic if the reverse of the string is equal to the original string. Reverse of \\'a\\' is \\'a\\'. Hope you get this."
                    },
                    {
                        "username": "947876275",
                        "content": "This post is for learner wanna practice DP.\\nThe basic idea is, if we wanna say \"aba\" is palindromic, then we need to firstly confirm that \"b\" is palindromic, then we also need to check if \"a\"(the first a) = \"a\" (the second a).\\n\\nM is a 2-d array which stores boolean values.\\nM[i][j] indicates if string[i.....j] is palindromic.\\nSo base cases are:\\nM[i][i] is true.\\nM[i][i + 1] = (s[i] == s[i + 1]);\\nrecurrence relation is :\\nM[i][j] = (s[i] == s[j] AND M[i + 1][j - 1]);\\nFor the implementation of recurrence relation, one idea is you can loop through all possible symmetry axis. For each of the axis, you expand at both RHS and LHS simultaneously. This method promises that when you are determining value in M[i][j], M[i + 1][j - 1] must have the correct value.\\nFinal answer can be found from all M[i][j] == 1 with largest (j - i)."
                    },
                    {
                        "username": "Msey",
                        "content": "thank you, cat brother"
                    },
                    {
                        "username": "user0558y",
                        "content": "I understand the solution but I don't understand why it needs any storage at all or why it needs to be a DP solution.\n\nThe condition `(s[i] == s[j] AND M[i + 1][j - 1])` requires you to memorise if `M[i+1][j-1]` is true, that's easy to understand. However, if you expand each possible axis at the same time, i.e. 1st iteration (s[i+1], s[j-1]), 2nd iteration `s[i+2], s[j-2]`, ... It is guaranteed that M[i+1][j-1] is always true and hence can be dropped, and you should break the loop when it is not true.\n\nIn summary, you don't need to memorise anything at all and you just need to check `s[i] == s[j]` while expanding in both directions at the same time, unless I have misunderstood anything? Here is an implementation of your algorithm but without storage: https://leetcode.com/problems/longest-palindromic-substring/submissions/868540120/"
                    },
                    {
                        "username": "taras",
                        "content": "Thank you! this is a beautiful explanation, though I\\'m not sure what exactly you mean by expanding both on LHS and RHS. In my implementation it\\'s enough to compute all diagonals of  the upper right triangle of the dp matrix."
                    },
                    {
                        "username": "klu_2100031593",
                        "content": "super explanation"
                    },
                    {
                        "username": "napoleon",
                        "content": "My Solution Is Naive, It Cost O(n^2), Is there Any Solution faster?"
                    },
                    {
                        "username": "leocampos",
                        "content": "[@tylerprill-rhdc](/tylerprill-rhdc) So, what I did was:\nStated in my mind the Brute Force approach - create every possible substring and test each one to see if is a palindrome and find the longest.\n\nOf course this would be ridiculously slow, so let's improve it.\nI also mentally stated that a palindrome has a recursive aspect -> if single char, or two equal chars, or charX + palindrome + charX\nSo I created a isPalindrome recursive method that checked it delegating to itself extracting the borders.\n\nSince a palindrome must start and end with the same char, in my traverse of the string, I started storing the position of each character Map<Character, List< Integer>>, so I would just go back to the previous found Char and check if from there to the current pointer I would have a Palindrome.\n\nThen I stopped doing this for every possible palindrome, I then started doing only for the ones that COULD be longer than the already found longest palindrome. That accelerated a lot.\n\nIn the almost last step, I added memoization. Remember that a palindrome is like a sandwich, with the external chars being equal and the meat being another palindrome? So I stored the found palindromes using their start and and positions. So I could check if that had already being checked and if so, either return true or false directly.\n\nThe final step was to convert the recursive function to an iterative function to save some memory used by the call stack.\nMaybe there are better implementations, just sharing my thought process."
                    },
                    {
                        "username": "tylerprill-rhdc",
                        "content": "[@tylerprill-rhdc](/tylerprill-rhdc) Two pointer based solution is also a really good solve here"
                    },
                    {
                        "username": "tylerprill-rhdc",
                        "content": "This could be done in a single pass algorithm, but will inherently check character indices multiple times based on the nature of the problem. (basically, iterate through each, then bubble out from each index)"
                    },
                    {
                        "username": "neetika",
                        "content": "From the leetcode blog, one of the methods of solving this is:\\n\\nA common mistake:\\nSome people will be tempted to come up with a quick solution, which is unfortunately flawed (however can be corrected easily):\\n\\nReverse S and become S\\u2019. Find the longest common substring between S and S\\u2019, which must also be the longest palindromic substring.\\nThis seemed to work, let\\u2019s see some examples below.\\n\\nFor example,\\nS = \\u201ccaba\\u201d, S\\u2019 = \\u201cabac\\u201d.\\nThe longest common substring between S and S\\u2019 is \\u201caba\\u201d, which is the answer.\\n\\nLet\\u2019s try another example:\\nS = \\u201cabacdfgdcaba\\u201d, S\\u2019 = \\u201cabacdgfdcaba\\u201d.\\nThe longest common substring between S and S\\u2019 is \\u201cabacd\\u201d. Clearly, this is not a valid palindrome.\\n\\n**We could see that the longest common substring method fails when there exists a reversed copy of a non-palindromic substring in some other part of S. To rectify this, each time we find a longest common substring candidate, we check if the substring\\u2019s indices are the same as the reversed substring\\u2019s original indices. If it is, then we attempt to update the longest palindrome found so far; if not, we skip this and find the next candidate.**\\n\\nIs this part correct? \\n\\nexample string: abcxycba\\nreverse string:  abcxycba\\n\\nThe substring indices are same as reversed string original indices and yet it is not a palindrome?"
                    },
                    {
                        "username": "HRVY_SNOWDEN",
                        "content": "cool sirr:)\\n"
                    },
                    {
                        "username": "dhtmlkitchen",
                        "content": "WRONG.\\n\\nabcxycba reversed is abcyxcba."
                    },
                    {
                        "username": "travisl12",
                        "content": "After I solved this problem I thought it\\'d be interesting to see how it worked in realtime.\\n\\nhttps://codepen.io/TravisL12/pen/pogvweg"
                    },
                    {
                        "username": "user3907vj",
                        "content": "thanks for the \"nanananananana\" from all the small things ;)"
                    },
                    {
                        "username": "zapataast",
                        "content": "u are crazy"
                    },
                    {
                        "username": "sondq98",
                        "content": "very intuitive"
                    },
                    {
                        "username": "Tathagat017",
                        "content": "thank you\\n"
                    },
                    {
                        "username": "mikler",
                        "content": "So I think I finally understood logic of test creators. \\nEven if you write a classical DP or memorization solution for this one you will timeout on latest tests.\\nI think they consider it edge cases. Because if you add one simple line it will pass! OMG. \\nI have leet code for this. Instead of solving problems I spend hours optimizing the constants.\\n\\nif s == s[::-1]: return s"
                    },
                    {
                        "username": "Vectorido",
                        "content": "Don\\'t work already. Time limit at 141 test even with that construction."
                    },
                    {
                        "username": "deepalithakur17",
                        "content": "It will only work in python."
                    },
                    {
                        "username": "ishogbon",
                        "content": "Its memoization, not memorization "
                    },
                    {
                        "username": "84danie",
                        "content": "I submitted my solution, and received a Time Limit Exceeded on this test case:\\n\\n\"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaabcaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"\\n\\nSo I copied and pasted the TC into a custom test case, and started to think about what I could tweak. However, I ended up accidentally hitting Run Code, but instead of getting a Time Limit Exceeded result, it passed:\\n\\n![0_1479079812693_upload-4af9e94c-2e53-4915-acf6-782780c7bf8b](/uploads/files/1479079813717-upload-4af9e94c-2e53-4915-acf6-782780c7bf8b.png) \\n\\nIs this supposed to happen and I just need to make my code more efficient, or is this a bug? \\n![0_1479079956817_upload-1ef15826-d6e6-4bde-9c06-eb597c5c8d0e](/uploads/files/1479079957639-upload-1ef15826-d6e6-4bde-9c06-eb597c5c8d0e.png)"
                    },
                    {
                        "username": "RitikaSahay",
                        "content": "Same thing happened with me. Is there a solution for it?\\n"
                    },
                    {
                        "username": "danicruz0415",
                        "content": "It\\'s happened to me a couple of times. My theory is that the time limit is given for the whole list of test cases. Thus, you can have your test pass, but it will still time limit exceed because it wont get to calculate all the test cases before the time runs out. I cannot confirm this but I think its true because with a very unoptimized solution I got time limit exceeded very early in the test cases (for another problem), after some optimizations I got it much later (like getting to the last tests) which themselves were around the same size, so if the time limit was set per test it would not make sense to fail in a similarly long test-case just that is much later in the test list. (I think the same would apply to memory limit exceeded)"
                    },
                    {
                        "username": "him_Sarma619",
                        "content": "The exact same situation happened with me in one problem... it was a DP problem too... I was getting a Memory Limit Exceeded error with the memoized solution but it was running fine in the Run Code button."
                    },
                    {
                        "username": "Hubro",
                        "content": "I\\'m getting \"Time Limit Exceeded\" with 141/141 testcases passed and \"Last Executed Input\" is:\\n\\n```\\ns =\\n```\\n\\nDid I break it?"
                    },
                    {
                        "username": "karan_dhiman",
                        "content": "same issue"
                    },
                    {
                        "username": "BLANK-Zora",
                        "content": "exactly bro this shit is recked , like it is giving tests outside the constraints , how am i suppose to include such things in the code"
                    },
                    {
                        "username": "arunprep5",
                        "content": "same issue. java"
                    },
                    {
                        "username": "blasphelmy",
                        "content": "[@tuancoltech](/tuancoltech) it worked when i rewrote the code in c# instead of c++"
                    },
                    {
                        "username": "tuancoltech",
                        "content": "[@blasphelmy](/blasphelmy) [@Tomas Sandven](/Hubro) Did you guys find out why? I got the same issue."
                    },
                    {
                        "username": "blasphelmy",
                        "content": "i got that too. im not sure whats going on given that the constraint for input is between 1 and 1000"
                    },
                    {
                        "username": "Vinitajain",
                        "content": "Hi All,\\nI have a test case which is failing, but I feel the testcase result is incorrect.Please refer the screenshot below.\\n![image](https://assets.leetcode.com/users/images/e9e42efb-63d5-4cfa-b420-f1926674f6dc_1654838015.8394327.png)\\n\\nThe longest palindromic substring is \"aaca\" but the test case result is \"aca\". Anyone else faced this problem?"
                    },
                    {
                        "username": "OthSO",
                        "content": "[@mohdansah10](/mohdansah10) \\nthey are separated in the input with \"bd\" so it is not a valid answer "
                    },
                    {
                        "username": "mohdansah10",
                        "content": "I\\'m getting same error, but different case:\\nInput\\ns =\\n\"aacabdkacaa\"\\n\\nOutput\\n\"aacakacaa\"\\nExpected\\n\"aca\"\\n\\nBut mine is Palindrome"
                    },
                    {
                        "username": "hasmithraa",
                        "content": "the expected is correct because aaca can\\'t be a palindrome only \\'aacaa\\' can be a palindrome which is not there in your case"
                    },
                    {
                        "username": "Amish_Singh",
                        "content": "how are you considering \"aaca\" as a palindromic substring, \"aca\" is a palindrome and it is the longest"
                    },
                    {
                        "username": "Shaik_Aman_Sayer",
                        "content": "dude you really came up with the solution "
                    },
                    {
                        "username": "AryaAditya3609",
                        "content": "how is \"aaca\" and \"acaa\" same ???\\nWhile \"aca\" is palindrome because both \"aca\" and reverse of it \"aca\" is same !!"
                    },
                    {
                        "username": "alexandra-pickle",
                        "content": "\"aaca\" is not a palindrome"
                    },
                    {
                        "username": "bugHackerLoop",
                        "content": "I followed the approach leant by Aditya Verma DP lectures and encountered the same test case failing. Does the logic where I reverse the string and calculate the longest common substring doesn\\'t work here? I know it works for longest palindromic subsequence but here it fails for such test cases .. why is it so?"
                    },
                    {
                        "username": "mductran",
                        "content": "how is \\'aaca\\' a palindrome? when read backward it\\'s \\'acaa\\' so it\\'s not the same reading forward."
                    },
                    {
                        "username": "jnsudhir",
                        "content": "Check my solution, it was able to clear test case \"aaca\". Explained code in comments.\\n\\nhttps://leetcode.com/problems/longest-palindromic-substring/solutions/3091016/longest-palindromic-substring-using-javascript-beats-94-82-in-runtime-explained/?orderBy=most_votes"
                    },
                    {
                        "username": "nikhileshratna",
                        "content": "aaca is not palindrome"
                    },
                    {
                        "username": "sunshine77",
                        "content": "hey, iam getting the same error, i have seen ansewrs where they have totally changed the algorithm, how did u solve this by tweaking the same algoirhtm"
                    },
                    {
                        "username": "bhupendrabc71",
                        "content": "how come \"aaca\" is palindrome. it should be \"aca\""
                    },
                    {
                        "username": "just11blocks",
                        "content": "aaca is not a palindrome...aacaa and aca are."
                    },
                    {
                        "username": "odi1n",
                        "content": "I also encountered this problem"
                    },
                    {
                        "username": "vamsi2302",
                        "content": "I think you get it by now!\\n"
                    }
                ]
            },
            {
                "id": 1873701,
                "content": [
                    {
                        "username": "ZenMasterV",
                        "content": "Seems like too many of the  coding wunderkinds here lack basic reading comprehension skills \\n\" Please don\\'t post any solutions in this discussion tab\"\\nIt\\'s almost the rule to find the exact opposite for the discussion of every question. I don\\'t want to see your damned solution!"
                    },
                    {
                        "username": "NeroXIII",
                        "content": "[@charonme](/charonme) name does not check out :((("
                    },
                    {
                        "username": "192731",
                        "content": "and if they do?"
                    },
                    {
                        "username": "plevi1995",
                        "content": "Excellent comment"
                    },
                    {
                        "username": "khan60939",
                        "content": "Can anyone tell how DP is being used here? "
                    },
                    {
                        "username": "sandagolcea",
                        "content": "[@charonme](/charonme) my thinking exactly, but at least they should create a flag to help us moderate and move solutions to the correct tab. Would only need a stack overflow moderation-like system: one person flags, another person receives a queue of flagged comments and confirms the tagging.. oh well"
                    },
                    {
                        "username": "charonme",
                        "content": "maybe people get confused by the official leetcode comment which says: \"If you\\'d like to share a detailed solution to the problem, please create a new post in the discuss section\"\\nMaybe some time ago they didn\\'t have a separate solutions section and only recently changed it, but left some of the old solutions in the discussion section and didn\\'t fix the automated comment worting?"
                    },
                    {
                        "username": "klanjewar037",
                        "content": "hehe"
                    },
                    {
                        "username": "sanemdeepak",
                        "content": "For input \"ac\" test case is expecting \"a\" as output, how is just \"a\" a palindromic string?"
                    },
                    {
                        "username": "ayushiidevpura",
                        "content": "because when we read \"a\" from forward it results in \"a\" and at the same time when we read \"a\" from backward it is still \"a\""
                    },
                    {
                        "username": "beyzigo",
                        "content": "Because if you read the string \"a\" backwards it will still be \"a\""
                    },
                    {
                        "username": "tsafackghokeng",
                        "content": "[@Chouhan_Gourav](/Chouhan_Gourav) the test case said \"ac\" not \"a\". is \"ac\" palindromic? for \"a\" i understand"
                    },
                    {
                        "username": "CODEWITHABHINAV",
                        "content": "you have to submit the first string as your answer read more about this question on gFg\\n"
                    },
                    {
                        "username": "_BREEZE_",
                        "content": "any string is palindrome if we read it same from front and from back\\nin single character we read it same from front and back"
                    },
                    {
                        "username": "oinrup",
                        "content": "yes thats my question too"
                    },
                    {
                        "username": "yldemon",
                        "content": "Any character in the string by itself is a palindromic substring. So in the case where there is no palindromic substring with length > 1, you can return any character."
                    },
                    {
                        "username": "Chouhan_Gourav",
                        "content": "Whenever you come accross such contradiction, just google the definition, any. Any string is called is pallindromic if the reverse of the string is equal to the original string. Reverse of \\'a\\' is \\'a\\'. Hope you get this."
                    },
                    {
                        "username": "947876275",
                        "content": "This post is for learner wanna practice DP.\\nThe basic idea is, if we wanna say \"aba\" is palindromic, then we need to firstly confirm that \"b\" is palindromic, then we also need to check if \"a\"(the first a) = \"a\" (the second a).\\n\\nM is a 2-d array which stores boolean values.\\nM[i][j] indicates if string[i.....j] is palindromic.\\nSo base cases are:\\nM[i][i] is true.\\nM[i][i + 1] = (s[i] == s[i + 1]);\\nrecurrence relation is :\\nM[i][j] = (s[i] == s[j] AND M[i + 1][j - 1]);\\nFor the implementation of recurrence relation, one idea is you can loop through all possible symmetry axis. For each of the axis, you expand at both RHS and LHS simultaneously. This method promises that when you are determining value in M[i][j], M[i + 1][j - 1] must have the correct value.\\nFinal answer can be found from all M[i][j] == 1 with largest (j - i)."
                    },
                    {
                        "username": "Msey",
                        "content": "thank you, cat brother"
                    },
                    {
                        "username": "user0558y",
                        "content": "I understand the solution but I don't understand why it needs any storage at all or why it needs to be a DP solution.\n\nThe condition `(s[i] == s[j] AND M[i + 1][j - 1])` requires you to memorise if `M[i+1][j-1]` is true, that's easy to understand. However, if you expand each possible axis at the same time, i.e. 1st iteration (s[i+1], s[j-1]), 2nd iteration `s[i+2], s[j-2]`, ... It is guaranteed that M[i+1][j-1] is always true and hence can be dropped, and you should break the loop when it is not true.\n\nIn summary, you don't need to memorise anything at all and you just need to check `s[i] == s[j]` while expanding in both directions at the same time, unless I have misunderstood anything? Here is an implementation of your algorithm but without storage: https://leetcode.com/problems/longest-palindromic-substring/submissions/868540120/"
                    },
                    {
                        "username": "taras",
                        "content": "Thank you! this is a beautiful explanation, though I\\'m not sure what exactly you mean by expanding both on LHS and RHS. In my implementation it\\'s enough to compute all diagonals of  the upper right triangle of the dp matrix."
                    },
                    {
                        "username": "klu_2100031593",
                        "content": "super explanation"
                    },
                    {
                        "username": "napoleon",
                        "content": "My Solution Is Naive, It Cost O(n^2), Is there Any Solution faster?"
                    },
                    {
                        "username": "leocampos",
                        "content": "[@tylerprill-rhdc](/tylerprill-rhdc) So, what I did was:\nStated in my mind the Brute Force approach - create every possible substring and test each one to see if is a palindrome and find the longest.\n\nOf course this would be ridiculously slow, so let's improve it.\nI also mentally stated that a palindrome has a recursive aspect -> if single char, or two equal chars, or charX + palindrome + charX\nSo I created a isPalindrome recursive method that checked it delegating to itself extracting the borders.\n\nSince a palindrome must start and end with the same char, in my traverse of the string, I started storing the position of each character Map<Character, List< Integer>>, so I would just go back to the previous found Char and check if from there to the current pointer I would have a Palindrome.\n\nThen I stopped doing this for every possible palindrome, I then started doing only for the ones that COULD be longer than the already found longest palindrome. That accelerated a lot.\n\nIn the almost last step, I added memoization. Remember that a palindrome is like a sandwich, with the external chars being equal and the meat being another palindrome? So I stored the found palindromes using their start and and positions. So I could check if that had already being checked and if so, either return true or false directly.\n\nThe final step was to convert the recursive function to an iterative function to save some memory used by the call stack.\nMaybe there are better implementations, just sharing my thought process."
                    },
                    {
                        "username": "tylerprill-rhdc",
                        "content": "[@tylerprill-rhdc](/tylerprill-rhdc) Two pointer based solution is also a really good solve here"
                    },
                    {
                        "username": "tylerprill-rhdc",
                        "content": "This could be done in a single pass algorithm, but will inherently check character indices multiple times based on the nature of the problem. (basically, iterate through each, then bubble out from each index)"
                    },
                    {
                        "username": "neetika",
                        "content": "From the leetcode blog, one of the methods of solving this is:\\n\\nA common mistake:\\nSome people will be tempted to come up with a quick solution, which is unfortunately flawed (however can be corrected easily):\\n\\nReverse S and become S\\u2019. Find the longest common substring between S and S\\u2019, which must also be the longest palindromic substring.\\nThis seemed to work, let\\u2019s see some examples below.\\n\\nFor example,\\nS = \\u201ccaba\\u201d, S\\u2019 = \\u201cabac\\u201d.\\nThe longest common substring between S and S\\u2019 is \\u201caba\\u201d, which is the answer.\\n\\nLet\\u2019s try another example:\\nS = \\u201cabacdfgdcaba\\u201d, S\\u2019 = \\u201cabacdgfdcaba\\u201d.\\nThe longest common substring between S and S\\u2019 is \\u201cabacd\\u201d. Clearly, this is not a valid palindrome.\\n\\n**We could see that the longest common substring method fails when there exists a reversed copy of a non-palindromic substring in some other part of S. To rectify this, each time we find a longest common substring candidate, we check if the substring\\u2019s indices are the same as the reversed substring\\u2019s original indices. If it is, then we attempt to update the longest palindrome found so far; if not, we skip this and find the next candidate.**\\n\\nIs this part correct? \\n\\nexample string: abcxycba\\nreverse string:  abcxycba\\n\\nThe substring indices are same as reversed string original indices and yet it is not a palindrome?"
                    },
                    {
                        "username": "HRVY_SNOWDEN",
                        "content": "cool sirr:)\\n"
                    },
                    {
                        "username": "dhtmlkitchen",
                        "content": "WRONG.\\n\\nabcxycba reversed is abcyxcba."
                    },
                    {
                        "username": "travisl12",
                        "content": "After I solved this problem I thought it\\'d be interesting to see how it worked in realtime.\\n\\nhttps://codepen.io/TravisL12/pen/pogvweg"
                    },
                    {
                        "username": "user3907vj",
                        "content": "thanks for the \"nanananananana\" from all the small things ;)"
                    },
                    {
                        "username": "zapataast",
                        "content": "u are crazy"
                    },
                    {
                        "username": "sondq98",
                        "content": "very intuitive"
                    },
                    {
                        "username": "Tathagat017",
                        "content": "thank you\\n"
                    },
                    {
                        "username": "mikler",
                        "content": "So I think I finally understood logic of test creators. \\nEven if you write a classical DP or memorization solution for this one you will timeout on latest tests.\\nI think they consider it edge cases. Because if you add one simple line it will pass! OMG. \\nI have leet code for this. Instead of solving problems I spend hours optimizing the constants.\\n\\nif s == s[::-1]: return s"
                    },
                    {
                        "username": "Vectorido",
                        "content": "Don\\'t work already. Time limit at 141 test even with that construction."
                    },
                    {
                        "username": "deepalithakur17",
                        "content": "It will only work in python."
                    },
                    {
                        "username": "ishogbon",
                        "content": "Its memoization, not memorization "
                    },
                    {
                        "username": "84danie",
                        "content": "I submitted my solution, and received a Time Limit Exceeded on this test case:\\n\\n\"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaabcaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"\\n\\nSo I copied and pasted the TC into a custom test case, and started to think about what I could tweak. However, I ended up accidentally hitting Run Code, but instead of getting a Time Limit Exceeded result, it passed:\\n\\n![0_1479079812693_upload-4af9e94c-2e53-4915-acf6-782780c7bf8b](/uploads/files/1479079813717-upload-4af9e94c-2e53-4915-acf6-782780c7bf8b.png) \\n\\nIs this supposed to happen and I just need to make my code more efficient, or is this a bug? \\n![0_1479079956817_upload-1ef15826-d6e6-4bde-9c06-eb597c5c8d0e](/uploads/files/1479079957639-upload-1ef15826-d6e6-4bde-9c06-eb597c5c8d0e.png)"
                    },
                    {
                        "username": "RitikaSahay",
                        "content": "Same thing happened with me. Is there a solution for it?\\n"
                    },
                    {
                        "username": "danicruz0415",
                        "content": "It\\'s happened to me a couple of times. My theory is that the time limit is given for the whole list of test cases. Thus, you can have your test pass, but it will still time limit exceed because it wont get to calculate all the test cases before the time runs out. I cannot confirm this but I think its true because with a very unoptimized solution I got time limit exceeded very early in the test cases (for another problem), after some optimizations I got it much later (like getting to the last tests) which themselves were around the same size, so if the time limit was set per test it would not make sense to fail in a similarly long test-case just that is much later in the test list. (I think the same would apply to memory limit exceeded)"
                    },
                    {
                        "username": "him_Sarma619",
                        "content": "The exact same situation happened with me in one problem... it was a DP problem too... I was getting a Memory Limit Exceeded error with the memoized solution but it was running fine in the Run Code button."
                    },
                    {
                        "username": "Hubro",
                        "content": "I\\'m getting \"Time Limit Exceeded\" with 141/141 testcases passed and \"Last Executed Input\" is:\\n\\n```\\ns =\\n```\\n\\nDid I break it?"
                    },
                    {
                        "username": "karan_dhiman",
                        "content": "same issue"
                    },
                    {
                        "username": "BLANK-Zora",
                        "content": "exactly bro this shit is recked , like it is giving tests outside the constraints , how am i suppose to include such things in the code"
                    },
                    {
                        "username": "arunprep5",
                        "content": "same issue. java"
                    },
                    {
                        "username": "blasphelmy",
                        "content": "[@tuancoltech](/tuancoltech) it worked when i rewrote the code in c# instead of c++"
                    },
                    {
                        "username": "tuancoltech",
                        "content": "[@blasphelmy](/blasphelmy) [@Tomas Sandven](/Hubro) Did you guys find out why? I got the same issue."
                    },
                    {
                        "username": "blasphelmy",
                        "content": "i got that too. im not sure whats going on given that the constraint for input is between 1 and 1000"
                    },
                    {
                        "username": "Vinitajain",
                        "content": "Hi All,\\nI have a test case which is failing, but I feel the testcase result is incorrect.Please refer the screenshot below.\\n![image](https://assets.leetcode.com/users/images/e9e42efb-63d5-4cfa-b420-f1926674f6dc_1654838015.8394327.png)\\n\\nThe longest palindromic substring is \"aaca\" but the test case result is \"aca\". Anyone else faced this problem?"
                    },
                    {
                        "username": "OthSO",
                        "content": "[@mohdansah10](/mohdansah10) \\nthey are separated in the input with \"bd\" so it is not a valid answer "
                    },
                    {
                        "username": "mohdansah10",
                        "content": "I\\'m getting same error, but different case:\\nInput\\ns =\\n\"aacabdkacaa\"\\n\\nOutput\\n\"aacakacaa\"\\nExpected\\n\"aca\"\\n\\nBut mine is Palindrome"
                    },
                    {
                        "username": "hasmithraa",
                        "content": "the expected is correct because aaca can\\'t be a palindrome only \\'aacaa\\' can be a palindrome which is not there in your case"
                    },
                    {
                        "username": "Amish_Singh",
                        "content": "how are you considering \"aaca\" as a palindromic substring, \"aca\" is a palindrome and it is the longest"
                    },
                    {
                        "username": "Shaik_Aman_Sayer",
                        "content": "dude you really came up with the solution "
                    },
                    {
                        "username": "AryaAditya3609",
                        "content": "how is \"aaca\" and \"acaa\" same ???\\nWhile \"aca\" is palindrome because both \"aca\" and reverse of it \"aca\" is same !!"
                    },
                    {
                        "username": "alexandra-pickle",
                        "content": "\"aaca\" is not a palindrome"
                    },
                    {
                        "username": "bugHackerLoop",
                        "content": "I followed the approach leant by Aditya Verma DP lectures and encountered the same test case failing. Does the logic where I reverse the string and calculate the longest common substring doesn\\'t work here? I know it works for longest palindromic subsequence but here it fails for such test cases .. why is it so?"
                    },
                    {
                        "username": "mductran",
                        "content": "how is \\'aaca\\' a palindrome? when read backward it\\'s \\'acaa\\' so it\\'s not the same reading forward."
                    },
                    {
                        "username": "jnsudhir",
                        "content": "Check my solution, it was able to clear test case \"aaca\". Explained code in comments.\\n\\nhttps://leetcode.com/problems/longest-palindromic-substring/solutions/3091016/longest-palindromic-substring-using-javascript-beats-94-82-in-runtime-explained/?orderBy=most_votes"
                    },
                    {
                        "username": "nikhileshratna",
                        "content": "aaca is not palindrome"
                    },
                    {
                        "username": "sunshine77",
                        "content": "hey, iam getting the same error, i have seen ansewrs where they have totally changed the algorithm, how did u solve this by tweaking the same algoirhtm"
                    },
                    {
                        "username": "bhupendrabc71",
                        "content": "how come \"aaca\" is palindrome. it should be \"aca\""
                    },
                    {
                        "username": "just11blocks",
                        "content": "aaca is not a palindrome...aacaa and aca are."
                    },
                    {
                        "username": "odi1n",
                        "content": "I also encountered this problem"
                    },
                    {
                        "username": "vamsi2302",
                        "content": "I think you get it by now!\\n"
                    }
                ]
            },
            {
                "id": 1576875,
                "content": [
                    {
                        "username": "ZenMasterV",
                        "content": "Seems like too many of the  coding wunderkinds here lack basic reading comprehension skills \\n\" Please don\\'t post any solutions in this discussion tab\"\\nIt\\'s almost the rule to find the exact opposite for the discussion of every question. I don\\'t want to see your damned solution!"
                    },
                    {
                        "username": "NeroXIII",
                        "content": "[@charonme](/charonme) name does not check out :((("
                    },
                    {
                        "username": "192731",
                        "content": "and if they do?"
                    },
                    {
                        "username": "plevi1995",
                        "content": "Excellent comment"
                    },
                    {
                        "username": "khan60939",
                        "content": "Can anyone tell how DP is being used here? "
                    },
                    {
                        "username": "sandagolcea",
                        "content": "[@charonme](/charonme) my thinking exactly, but at least they should create a flag to help us moderate and move solutions to the correct tab. Would only need a stack overflow moderation-like system: one person flags, another person receives a queue of flagged comments and confirms the tagging.. oh well"
                    },
                    {
                        "username": "charonme",
                        "content": "maybe people get confused by the official leetcode comment which says: \"If you\\'d like to share a detailed solution to the problem, please create a new post in the discuss section\"\\nMaybe some time ago they didn\\'t have a separate solutions section and only recently changed it, but left some of the old solutions in the discussion section and didn\\'t fix the automated comment worting?"
                    },
                    {
                        "username": "klanjewar037",
                        "content": "hehe"
                    },
                    {
                        "username": "sanemdeepak",
                        "content": "For input \"ac\" test case is expecting \"a\" as output, how is just \"a\" a palindromic string?"
                    },
                    {
                        "username": "ayushiidevpura",
                        "content": "because when we read \"a\" from forward it results in \"a\" and at the same time when we read \"a\" from backward it is still \"a\""
                    },
                    {
                        "username": "beyzigo",
                        "content": "Because if you read the string \"a\" backwards it will still be \"a\""
                    },
                    {
                        "username": "tsafackghokeng",
                        "content": "[@Chouhan_Gourav](/Chouhan_Gourav) the test case said \"ac\" not \"a\". is \"ac\" palindromic? for \"a\" i understand"
                    },
                    {
                        "username": "CODEWITHABHINAV",
                        "content": "you have to submit the first string as your answer read more about this question on gFg\\n"
                    },
                    {
                        "username": "_BREEZE_",
                        "content": "any string is palindrome if we read it same from front and from back\\nin single character we read it same from front and back"
                    },
                    {
                        "username": "oinrup",
                        "content": "yes thats my question too"
                    },
                    {
                        "username": "yldemon",
                        "content": "Any character in the string by itself is a palindromic substring. So in the case where there is no palindromic substring with length > 1, you can return any character."
                    },
                    {
                        "username": "Chouhan_Gourav",
                        "content": "Whenever you come accross such contradiction, just google the definition, any. Any string is called is pallindromic if the reverse of the string is equal to the original string. Reverse of \\'a\\' is \\'a\\'. Hope you get this."
                    },
                    {
                        "username": "947876275",
                        "content": "This post is for learner wanna practice DP.\\nThe basic idea is, if we wanna say \"aba\" is palindromic, then we need to firstly confirm that \"b\" is palindromic, then we also need to check if \"a\"(the first a) = \"a\" (the second a).\\n\\nM is a 2-d array which stores boolean values.\\nM[i][j] indicates if string[i.....j] is palindromic.\\nSo base cases are:\\nM[i][i] is true.\\nM[i][i + 1] = (s[i] == s[i + 1]);\\nrecurrence relation is :\\nM[i][j] = (s[i] == s[j] AND M[i + 1][j - 1]);\\nFor the implementation of recurrence relation, one idea is you can loop through all possible symmetry axis. For each of the axis, you expand at both RHS and LHS simultaneously. This method promises that when you are determining value in M[i][j], M[i + 1][j - 1] must have the correct value.\\nFinal answer can be found from all M[i][j] == 1 with largest (j - i)."
                    },
                    {
                        "username": "Msey",
                        "content": "thank you, cat brother"
                    },
                    {
                        "username": "user0558y",
                        "content": "I understand the solution but I don't understand why it needs any storage at all or why it needs to be a DP solution.\n\nThe condition `(s[i] == s[j] AND M[i + 1][j - 1])` requires you to memorise if `M[i+1][j-1]` is true, that's easy to understand. However, if you expand each possible axis at the same time, i.e. 1st iteration (s[i+1], s[j-1]), 2nd iteration `s[i+2], s[j-2]`, ... It is guaranteed that M[i+1][j-1] is always true and hence can be dropped, and you should break the loop when it is not true.\n\nIn summary, you don't need to memorise anything at all and you just need to check `s[i] == s[j]` while expanding in both directions at the same time, unless I have misunderstood anything? Here is an implementation of your algorithm but without storage: https://leetcode.com/problems/longest-palindromic-substring/submissions/868540120/"
                    },
                    {
                        "username": "taras",
                        "content": "Thank you! this is a beautiful explanation, though I\\'m not sure what exactly you mean by expanding both on LHS and RHS. In my implementation it\\'s enough to compute all diagonals of  the upper right triangle of the dp matrix."
                    },
                    {
                        "username": "klu_2100031593",
                        "content": "super explanation"
                    },
                    {
                        "username": "napoleon",
                        "content": "My Solution Is Naive, It Cost O(n^2), Is there Any Solution faster?"
                    },
                    {
                        "username": "leocampos",
                        "content": "[@tylerprill-rhdc](/tylerprill-rhdc) So, what I did was:\nStated in my mind the Brute Force approach - create every possible substring and test each one to see if is a palindrome and find the longest.\n\nOf course this would be ridiculously slow, so let's improve it.\nI also mentally stated that a palindrome has a recursive aspect -> if single char, or two equal chars, or charX + palindrome + charX\nSo I created a isPalindrome recursive method that checked it delegating to itself extracting the borders.\n\nSince a palindrome must start and end with the same char, in my traverse of the string, I started storing the position of each character Map<Character, List< Integer>>, so I would just go back to the previous found Char and check if from there to the current pointer I would have a Palindrome.\n\nThen I stopped doing this for every possible palindrome, I then started doing only for the ones that COULD be longer than the already found longest palindrome. That accelerated a lot.\n\nIn the almost last step, I added memoization. Remember that a palindrome is like a sandwich, with the external chars being equal and the meat being another palindrome? So I stored the found palindromes using their start and and positions. So I could check if that had already being checked and if so, either return true or false directly.\n\nThe final step was to convert the recursive function to an iterative function to save some memory used by the call stack.\nMaybe there are better implementations, just sharing my thought process."
                    },
                    {
                        "username": "tylerprill-rhdc",
                        "content": "[@tylerprill-rhdc](/tylerprill-rhdc) Two pointer based solution is also a really good solve here"
                    },
                    {
                        "username": "tylerprill-rhdc",
                        "content": "This could be done in a single pass algorithm, but will inherently check character indices multiple times based on the nature of the problem. (basically, iterate through each, then bubble out from each index)"
                    },
                    {
                        "username": "neetika",
                        "content": "From the leetcode blog, one of the methods of solving this is:\\n\\nA common mistake:\\nSome people will be tempted to come up with a quick solution, which is unfortunately flawed (however can be corrected easily):\\n\\nReverse S and become S\\u2019. Find the longest common substring between S and S\\u2019, which must also be the longest palindromic substring.\\nThis seemed to work, let\\u2019s see some examples below.\\n\\nFor example,\\nS = \\u201ccaba\\u201d, S\\u2019 = \\u201cabac\\u201d.\\nThe longest common substring between S and S\\u2019 is \\u201caba\\u201d, which is the answer.\\n\\nLet\\u2019s try another example:\\nS = \\u201cabacdfgdcaba\\u201d, S\\u2019 = \\u201cabacdgfdcaba\\u201d.\\nThe longest common substring between S and S\\u2019 is \\u201cabacd\\u201d. Clearly, this is not a valid palindrome.\\n\\n**We could see that the longest common substring method fails when there exists a reversed copy of a non-palindromic substring in some other part of S. To rectify this, each time we find a longest common substring candidate, we check if the substring\\u2019s indices are the same as the reversed substring\\u2019s original indices. If it is, then we attempt to update the longest palindrome found so far; if not, we skip this and find the next candidate.**\\n\\nIs this part correct? \\n\\nexample string: abcxycba\\nreverse string:  abcxycba\\n\\nThe substring indices are same as reversed string original indices and yet it is not a palindrome?"
                    },
                    {
                        "username": "HRVY_SNOWDEN",
                        "content": "cool sirr:)\\n"
                    },
                    {
                        "username": "dhtmlkitchen",
                        "content": "WRONG.\\n\\nabcxycba reversed is abcyxcba."
                    },
                    {
                        "username": "travisl12",
                        "content": "After I solved this problem I thought it\\'d be interesting to see how it worked in realtime.\\n\\nhttps://codepen.io/TravisL12/pen/pogvweg"
                    },
                    {
                        "username": "user3907vj",
                        "content": "thanks for the \"nanananananana\" from all the small things ;)"
                    },
                    {
                        "username": "zapataast",
                        "content": "u are crazy"
                    },
                    {
                        "username": "sondq98",
                        "content": "very intuitive"
                    },
                    {
                        "username": "Tathagat017",
                        "content": "thank you\\n"
                    },
                    {
                        "username": "mikler",
                        "content": "So I think I finally understood logic of test creators. \\nEven if you write a classical DP or memorization solution for this one you will timeout on latest tests.\\nI think they consider it edge cases. Because if you add one simple line it will pass! OMG. \\nI have leet code for this. Instead of solving problems I spend hours optimizing the constants.\\n\\nif s == s[::-1]: return s"
                    },
                    {
                        "username": "Vectorido",
                        "content": "Don\\'t work already. Time limit at 141 test even with that construction."
                    },
                    {
                        "username": "deepalithakur17",
                        "content": "It will only work in python."
                    },
                    {
                        "username": "ishogbon",
                        "content": "Its memoization, not memorization "
                    },
                    {
                        "username": "84danie",
                        "content": "I submitted my solution, and received a Time Limit Exceeded on this test case:\\n\\n\"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaabcaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"\\n\\nSo I copied and pasted the TC into a custom test case, and started to think about what I could tweak. However, I ended up accidentally hitting Run Code, but instead of getting a Time Limit Exceeded result, it passed:\\n\\n![0_1479079812693_upload-4af9e94c-2e53-4915-acf6-782780c7bf8b](/uploads/files/1479079813717-upload-4af9e94c-2e53-4915-acf6-782780c7bf8b.png) \\n\\nIs this supposed to happen and I just need to make my code more efficient, or is this a bug? \\n![0_1479079956817_upload-1ef15826-d6e6-4bde-9c06-eb597c5c8d0e](/uploads/files/1479079957639-upload-1ef15826-d6e6-4bde-9c06-eb597c5c8d0e.png)"
                    },
                    {
                        "username": "RitikaSahay",
                        "content": "Same thing happened with me. Is there a solution for it?\\n"
                    },
                    {
                        "username": "danicruz0415",
                        "content": "It\\'s happened to me a couple of times. My theory is that the time limit is given for the whole list of test cases. Thus, you can have your test pass, but it will still time limit exceed because it wont get to calculate all the test cases before the time runs out. I cannot confirm this but I think its true because with a very unoptimized solution I got time limit exceeded very early in the test cases (for another problem), after some optimizations I got it much later (like getting to the last tests) which themselves were around the same size, so if the time limit was set per test it would not make sense to fail in a similarly long test-case just that is much later in the test list. (I think the same would apply to memory limit exceeded)"
                    },
                    {
                        "username": "him_Sarma619",
                        "content": "The exact same situation happened with me in one problem... it was a DP problem too... I was getting a Memory Limit Exceeded error with the memoized solution but it was running fine in the Run Code button."
                    },
                    {
                        "username": "Hubro",
                        "content": "I\\'m getting \"Time Limit Exceeded\" with 141/141 testcases passed and \"Last Executed Input\" is:\\n\\n```\\ns =\\n```\\n\\nDid I break it?"
                    },
                    {
                        "username": "karan_dhiman",
                        "content": "same issue"
                    },
                    {
                        "username": "BLANK-Zora",
                        "content": "exactly bro this shit is recked , like it is giving tests outside the constraints , how am i suppose to include such things in the code"
                    },
                    {
                        "username": "arunprep5",
                        "content": "same issue. java"
                    },
                    {
                        "username": "blasphelmy",
                        "content": "[@tuancoltech](/tuancoltech) it worked when i rewrote the code in c# instead of c++"
                    },
                    {
                        "username": "tuancoltech",
                        "content": "[@blasphelmy](/blasphelmy) [@Tomas Sandven](/Hubro) Did you guys find out why? I got the same issue."
                    },
                    {
                        "username": "blasphelmy",
                        "content": "i got that too. im not sure whats going on given that the constraint for input is between 1 and 1000"
                    },
                    {
                        "username": "Vinitajain",
                        "content": "Hi All,\\nI have a test case which is failing, but I feel the testcase result is incorrect.Please refer the screenshot below.\\n![image](https://assets.leetcode.com/users/images/e9e42efb-63d5-4cfa-b420-f1926674f6dc_1654838015.8394327.png)\\n\\nThe longest palindromic substring is \"aaca\" but the test case result is \"aca\". Anyone else faced this problem?"
                    },
                    {
                        "username": "OthSO",
                        "content": "[@mohdansah10](/mohdansah10) \\nthey are separated in the input with \"bd\" so it is not a valid answer "
                    },
                    {
                        "username": "mohdansah10",
                        "content": "I\\'m getting same error, but different case:\\nInput\\ns =\\n\"aacabdkacaa\"\\n\\nOutput\\n\"aacakacaa\"\\nExpected\\n\"aca\"\\n\\nBut mine is Palindrome"
                    },
                    {
                        "username": "hasmithraa",
                        "content": "the expected is correct because aaca can\\'t be a palindrome only \\'aacaa\\' can be a palindrome which is not there in your case"
                    },
                    {
                        "username": "Amish_Singh",
                        "content": "how are you considering \"aaca\" as a palindromic substring, \"aca\" is a palindrome and it is the longest"
                    },
                    {
                        "username": "Shaik_Aman_Sayer",
                        "content": "dude you really came up with the solution "
                    },
                    {
                        "username": "AryaAditya3609",
                        "content": "how is \"aaca\" and \"acaa\" same ???\\nWhile \"aca\" is palindrome because both \"aca\" and reverse of it \"aca\" is same !!"
                    },
                    {
                        "username": "alexandra-pickle",
                        "content": "\"aaca\" is not a palindrome"
                    },
                    {
                        "username": "bugHackerLoop",
                        "content": "I followed the approach leant by Aditya Verma DP lectures and encountered the same test case failing. Does the logic where I reverse the string and calculate the longest common substring doesn\\'t work here? I know it works for longest palindromic subsequence but here it fails for such test cases .. why is it so?"
                    },
                    {
                        "username": "mductran",
                        "content": "how is \\'aaca\\' a palindrome? when read backward it\\'s \\'acaa\\' so it\\'s not the same reading forward."
                    },
                    {
                        "username": "jnsudhir",
                        "content": "Check my solution, it was able to clear test case \"aaca\". Explained code in comments.\\n\\nhttps://leetcode.com/problems/longest-palindromic-substring/solutions/3091016/longest-palindromic-substring-using-javascript-beats-94-82-in-runtime-explained/?orderBy=most_votes"
                    },
                    {
                        "username": "nikhileshratna",
                        "content": "aaca is not palindrome"
                    },
                    {
                        "username": "sunshine77",
                        "content": "hey, iam getting the same error, i have seen ansewrs where they have totally changed the algorithm, how did u solve this by tweaking the same algoirhtm"
                    },
                    {
                        "username": "bhupendrabc71",
                        "content": "how come \"aaca\" is palindrome. it should be \"aca\""
                    },
                    {
                        "username": "just11blocks",
                        "content": "aaca is not a palindrome...aacaa and aca are."
                    },
                    {
                        "username": "odi1n",
                        "content": "I also encountered this problem"
                    },
                    {
                        "username": "vamsi2302",
                        "content": "I think you get it by now!\\n"
                    }
                ]
            },
            {
                "id": 1671198,
                "content": [
                    {
                        "username": "ZenMasterV",
                        "content": "Seems like too many of the  coding wunderkinds here lack basic reading comprehension skills \\n\" Please don\\'t post any solutions in this discussion tab\"\\nIt\\'s almost the rule to find the exact opposite for the discussion of every question. I don\\'t want to see your damned solution!"
                    },
                    {
                        "username": "NeroXIII",
                        "content": "[@charonme](/charonme) name does not check out :((("
                    },
                    {
                        "username": "192731",
                        "content": "and if they do?"
                    },
                    {
                        "username": "plevi1995",
                        "content": "Excellent comment"
                    },
                    {
                        "username": "khan60939",
                        "content": "Can anyone tell how DP is being used here? "
                    },
                    {
                        "username": "sandagolcea",
                        "content": "[@charonme](/charonme) my thinking exactly, but at least they should create a flag to help us moderate and move solutions to the correct tab. Would only need a stack overflow moderation-like system: one person flags, another person receives a queue of flagged comments and confirms the tagging.. oh well"
                    },
                    {
                        "username": "charonme",
                        "content": "maybe people get confused by the official leetcode comment which says: \"If you\\'d like to share a detailed solution to the problem, please create a new post in the discuss section\"\\nMaybe some time ago they didn\\'t have a separate solutions section and only recently changed it, but left some of the old solutions in the discussion section and didn\\'t fix the automated comment worting?"
                    },
                    {
                        "username": "klanjewar037",
                        "content": "hehe"
                    },
                    {
                        "username": "sanemdeepak",
                        "content": "For input \"ac\" test case is expecting \"a\" as output, how is just \"a\" a palindromic string?"
                    },
                    {
                        "username": "ayushiidevpura",
                        "content": "because when we read \"a\" from forward it results in \"a\" and at the same time when we read \"a\" from backward it is still \"a\""
                    },
                    {
                        "username": "beyzigo",
                        "content": "Because if you read the string \"a\" backwards it will still be \"a\""
                    },
                    {
                        "username": "tsafackghokeng",
                        "content": "[@Chouhan_Gourav](/Chouhan_Gourav) the test case said \"ac\" not \"a\". is \"ac\" palindromic? for \"a\" i understand"
                    },
                    {
                        "username": "CODEWITHABHINAV",
                        "content": "you have to submit the first string as your answer read more about this question on gFg\\n"
                    },
                    {
                        "username": "_BREEZE_",
                        "content": "any string is palindrome if we read it same from front and from back\\nin single character we read it same from front and back"
                    },
                    {
                        "username": "oinrup",
                        "content": "yes thats my question too"
                    },
                    {
                        "username": "yldemon",
                        "content": "Any character in the string by itself is a palindromic substring. So in the case where there is no palindromic substring with length > 1, you can return any character."
                    },
                    {
                        "username": "Chouhan_Gourav",
                        "content": "Whenever you come accross such contradiction, just google the definition, any. Any string is called is pallindromic if the reverse of the string is equal to the original string. Reverse of \\'a\\' is \\'a\\'. Hope you get this."
                    },
                    {
                        "username": "947876275",
                        "content": "This post is for learner wanna practice DP.\\nThe basic idea is, if we wanna say \"aba\" is palindromic, then we need to firstly confirm that \"b\" is palindromic, then we also need to check if \"a\"(the first a) = \"a\" (the second a).\\n\\nM is a 2-d array which stores boolean values.\\nM[i][j] indicates if string[i.....j] is palindromic.\\nSo base cases are:\\nM[i][i] is true.\\nM[i][i + 1] = (s[i] == s[i + 1]);\\nrecurrence relation is :\\nM[i][j] = (s[i] == s[j] AND M[i + 1][j - 1]);\\nFor the implementation of recurrence relation, one idea is you can loop through all possible symmetry axis. For each of the axis, you expand at both RHS and LHS simultaneously. This method promises that when you are determining value in M[i][j], M[i + 1][j - 1] must have the correct value.\\nFinal answer can be found from all M[i][j] == 1 with largest (j - i)."
                    },
                    {
                        "username": "Msey",
                        "content": "thank you, cat brother"
                    },
                    {
                        "username": "user0558y",
                        "content": "I understand the solution but I don't understand why it needs any storage at all or why it needs to be a DP solution.\n\nThe condition `(s[i] == s[j] AND M[i + 1][j - 1])` requires you to memorise if `M[i+1][j-1]` is true, that's easy to understand. However, if you expand each possible axis at the same time, i.e. 1st iteration (s[i+1], s[j-1]), 2nd iteration `s[i+2], s[j-2]`, ... It is guaranteed that M[i+1][j-1] is always true and hence can be dropped, and you should break the loop when it is not true.\n\nIn summary, you don't need to memorise anything at all and you just need to check `s[i] == s[j]` while expanding in both directions at the same time, unless I have misunderstood anything? Here is an implementation of your algorithm but without storage: https://leetcode.com/problems/longest-palindromic-substring/submissions/868540120/"
                    },
                    {
                        "username": "taras",
                        "content": "Thank you! this is a beautiful explanation, though I\\'m not sure what exactly you mean by expanding both on LHS and RHS. In my implementation it\\'s enough to compute all diagonals of  the upper right triangle of the dp matrix."
                    },
                    {
                        "username": "klu_2100031593",
                        "content": "super explanation"
                    },
                    {
                        "username": "napoleon",
                        "content": "My Solution Is Naive, It Cost O(n^2), Is there Any Solution faster?"
                    },
                    {
                        "username": "leocampos",
                        "content": "[@tylerprill-rhdc](/tylerprill-rhdc) So, what I did was:\nStated in my mind the Brute Force approach - create every possible substring and test each one to see if is a palindrome and find the longest.\n\nOf course this would be ridiculously slow, so let's improve it.\nI also mentally stated that a palindrome has a recursive aspect -> if single char, or two equal chars, or charX + palindrome + charX\nSo I created a isPalindrome recursive method that checked it delegating to itself extracting the borders.\n\nSince a palindrome must start and end with the same char, in my traverse of the string, I started storing the position of each character Map<Character, List< Integer>>, so I would just go back to the previous found Char and check if from there to the current pointer I would have a Palindrome.\n\nThen I stopped doing this for every possible palindrome, I then started doing only for the ones that COULD be longer than the already found longest palindrome. That accelerated a lot.\n\nIn the almost last step, I added memoization. Remember that a palindrome is like a sandwich, with the external chars being equal and the meat being another palindrome? So I stored the found palindromes using their start and and positions. So I could check if that had already being checked and if so, either return true or false directly.\n\nThe final step was to convert the recursive function to an iterative function to save some memory used by the call stack.\nMaybe there are better implementations, just sharing my thought process."
                    },
                    {
                        "username": "tylerprill-rhdc",
                        "content": "[@tylerprill-rhdc](/tylerprill-rhdc) Two pointer based solution is also a really good solve here"
                    },
                    {
                        "username": "tylerprill-rhdc",
                        "content": "This could be done in a single pass algorithm, but will inherently check character indices multiple times based on the nature of the problem. (basically, iterate through each, then bubble out from each index)"
                    },
                    {
                        "username": "neetika",
                        "content": "From the leetcode blog, one of the methods of solving this is:\\n\\nA common mistake:\\nSome people will be tempted to come up with a quick solution, which is unfortunately flawed (however can be corrected easily):\\n\\nReverse S and become S\\u2019. Find the longest common substring between S and S\\u2019, which must also be the longest palindromic substring.\\nThis seemed to work, let\\u2019s see some examples below.\\n\\nFor example,\\nS = \\u201ccaba\\u201d, S\\u2019 = \\u201cabac\\u201d.\\nThe longest common substring between S and S\\u2019 is \\u201caba\\u201d, which is the answer.\\n\\nLet\\u2019s try another example:\\nS = \\u201cabacdfgdcaba\\u201d, S\\u2019 = \\u201cabacdgfdcaba\\u201d.\\nThe longest common substring between S and S\\u2019 is \\u201cabacd\\u201d. Clearly, this is not a valid palindrome.\\n\\n**We could see that the longest common substring method fails when there exists a reversed copy of a non-palindromic substring in some other part of S. To rectify this, each time we find a longest common substring candidate, we check if the substring\\u2019s indices are the same as the reversed substring\\u2019s original indices. If it is, then we attempt to update the longest palindrome found so far; if not, we skip this and find the next candidate.**\\n\\nIs this part correct? \\n\\nexample string: abcxycba\\nreverse string:  abcxycba\\n\\nThe substring indices are same as reversed string original indices and yet it is not a palindrome?"
                    },
                    {
                        "username": "HRVY_SNOWDEN",
                        "content": "cool sirr:)\\n"
                    },
                    {
                        "username": "dhtmlkitchen",
                        "content": "WRONG.\\n\\nabcxycba reversed is abcyxcba."
                    },
                    {
                        "username": "travisl12",
                        "content": "After I solved this problem I thought it\\'d be interesting to see how it worked in realtime.\\n\\nhttps://codepen.io/TravisL12/pen/pogvweg"
                    },
                    {
                        "username": "user3907vj",
                        "content": "thanks for the \"nanananananana\" from all the small things ;)"
                    },
                    {
                        "username": "zapataast",
                        "content": "u are crazy"
                    },
                    {
                        "username": "sondq98",
                        "content": "very intuitive"
                    },
                    {
                        "username": "Tathagat017",
                        "content": "thank you\\n"
                    },
                    {
                        "username": "mikler",
                        "content": "So I think I finally understood logic of test creators. \\nEven if you write a classical DP or memorization solution for this one you will timeout on latest tests.\\nI think they consider it edge cases. Because if you add one simple line it will pass! OMG. \\nI have leet code for this. Instead of solving problems I spend hours optimizing the constants.\\n\\nif s == s[::-1]: return s"
                    },
                    {
                        "username": "Vectorido",
                        "content": "Don\\'t work already. Time limit at 141 test even with that construction."
                    },
                    {
                        "username": "deepalithakur17",
                        "content": "It will only work in python."
                    },
                    {
                        "username": "ishogbon",
                        "content": "Its memoization, not memorization "
                    },
                    {
                        "username": "84danie",
                        "content": "I submitted my solution, and received a Time Limit Exceeded on this test case:\\n\\n\"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaabcaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"\\n\\nSo I copied and pasted the TC into a custom test case, and started to think about what I could tweak. However, I ended up accidentally hitting Run Code, but instead of getting a Time Limit Exceeded result, it passed:\\n\\n![0_1479079812693_upload-4af9e94c-2e53-4915-acf6-782780c7bf8b](/uploads/files/1479079813717-upload-4af9e94c-2e53-4915-acf6-782780c7bf8b.png) \\n\\nIs this supposed to happen and I just need to make my code more efficient, or is this a bug? \\n![0_1479079956817_upload-1ef15826-d6e6-4bde-9c06-eb597c5c8d0e](/uploads/files/1479079957639-upload-1ef15826-d6e6-4bde-9c06-eb597c5c8d0e.png)"
                    },
                    {
                        "username": "RitikaSahay",
                        "content": "Same thing happened with me. Is there a solution for it?\\n"
                    },
                    {
                        "username": "danicruz0415",
                        "content": "It\\'s happened to me a couple of times. My theory is that the time limit is given for the whole list of test cases. Thus, you can have your test pass, but it will still time limit exceed because it wont get to calculate all the test cases before the time runs out. I cannot confirm this but I think its true because with a very unoptimized solution I got time limit exceeded very early in the test cases (for another problem), after some optimizations I got it much later (like getting to the last tests) which themselves were around the same size, so if the time limit was set per test it would not make sense to fail in a similarly long test-case just that is much later in the test list. (I think the same would apply to memory limit exceeded)"
                    },
                    {
                        "username": "him_Sarma619",
                        "content": "The exact same situation happened with me in one problem... it was a DP problem too... I was getting a Memory Limit Exceeded error with the memoized solution but it was running fine in the Run Code button."
                    },
                    {
                        "username": "Hubro",
                        "content": "I\\'m getting \"Time Limit Exceeded\" with 141/141 testcases passed and \"Last Executed Input\" is:\\n\\n```\\ns =\\n```\\n\\nDid I break it?"
                    },
                    {
                        "username": "karan_dhiman",
                        "content": "same issue"
                    },
                    {
                        "username": "BLANK-Zora",
                        "content": "exactly bro this shit is recked , like it is giving tests outside the constraints , how am i suppose to include such things in the code"
                    },
                    {
                        "username": "arunprep5",
                        "content": "same issue. java"
                    },
                    {
                        "username": "blasphelmy",
                        "content": "[@tuancoltech](/tuancoltech) it worked when i rewrote the code in c# instead of c++"
                    },
                    {
                        "username": "tuancoltech",
                        "content": "[@blasphelmy](/blasphelmy) [@Tomas Sandven](/Hubro) Did you guys find out why? I got the same issue."
                    },
                    {
                        "username": "blasphelmy",
                        "content": "i got that too. im not sure whats going on given that the constraint for input is between 1 and 1000"
                    },
                    {
                        "username": "Vinitajain",
                        "content": "Hi All,\\nI have a test case which is failing, but I feel the testcase result is incorrect.Please refer the screenshot below.\\n![image](https://assets.leetcode.com/users/images/e9e42efb-63d5-4cfa-b420-f1926674f6dc_1654838015.8394327.png)\\n\\nThe longest palindromic substring is \"aaca\" but the test case result is \"aca\". Anyone else faced this problem?"
                    },
                    {
                        "username": "OthSO",
                        "content": "[@mohdansah10](/mohdansah10) \\nthey are separated in the input with \"bd\" so it is not a valid answer "
                    },
                    {
                        "username": "mohdansah10",
                        "content": "I\\'m getting same error, but different case:\\nInput\\ns =\\n\"aacabdkacaa\"\\n\\nOutput\\n\"aacakacaa\"\\nExpected\\n\"aca\"\\n\\nBut mine is Palindrome"
                    },
                    {
                        "username": "hasmithraa",
                        "content": "the expected is correct because aaca can\\'t be a palindrome only \\'aacaa\\' can be a palindrome which is not there in your case"
                    },
                    {
                        "username": "Amish_Singh",
                        "content": "how are you considering \"aaca\" as a palindromic substring, \"aca\" is a palindrome and it is the longest"
                    },
                    {
                        "username": "Shaik_Aman_Sayer",
                        "content": "dude you really came up with the solution "
                    },
                    {
                        "username": "AryaAditya3609",
                        "content": "how is \"aaca\" and \"acaa\" same ???\\nWhile \"aca\" is palindrome because both \"aca\" and reverse of it \"aca\" is same !!"
                    },
                    {
                        "username": "alexandra-pickle",
                        "content": "\"aaca\" is not a palindrome"
                    },
                    {
                        "username": "bugHackerLoop",
                        "content": "I followed the approach leant by Aditya Verma DP lectures and encountered the same test case failing. Does the logic where I reverse the string and calculate the longest common substring doesn\\'t work here? I know it works for longest palindromic subsequence but here it fails for such test cases .. why is it so?"
                    },
                    {
                        "username": "mductran",
                        "content": "how is \\'aaca\\' a palindrome? when read backward it\\'s \\'acaa\\' so it\\'s not the same reading forward."
                    },
                    {
                        "username": "jnsudhir",
                        "content": "Check my solution, it was able to clear test case \"aaca\". Explained code in comments.\\n\\nhttps://leetcode.com/problems/longest-palindromic-substring/solutions/3091016/longest-palindromic-substring-using-javascript-beats-94-82-in-runtime-explained/?orderBy=most_votes"
                    },
                    {
                        "username": "nikhileshratna",
                        "content": "aaca is not palindrome"
                    },
                    {
                        "username": "sunshine77",
                        "content": "hey, iam getting the same error, i have seen ansewrs where they have totally changed the algorithm, how did u solve this by tweaking the same algoirhtm"
                    },
                    {
                        "username": "bhupendrabc71",
                        "content": "how come \"aaca\" is palindrome. it should be \"aca\""
                    },
                    {
                        "username": "just11blocks",
                        "content": "aaca is not a palindrome...aacaa and aca are."
                    },
                    {
                        "username": "odi1n",
                        "content": "I also encountered this problem"
                    },
                    {
                        "username": "vamsi2302",
                        "content": "I think you get it by now!\\n"
                    }
                ]
            },
            {
                "id": 1565544,
                "content": [
                    {
                        "username": "ZenMasterV",
                        "content": "Seems like too many of the  coding wunderkinds here lack basic reading comprehension skills \\n\" Please don\\'t post any solutions in this discussion tab\"\\nIt\\'s almost the rule to find the exact opposite for the discussion of every question. I don\\'t want to see your damned solution!"
                    },
                    {
                        "username": "NeroXIII",
                        "content": "[@charonme](/charonme) name does not check out :((("
                    },
                    {
                        "username": "192731",
                        "content": "and if they do?"
                    },
                    {
                        "username": "plevi1995",
                        "content": "Excellent comment"
                    },
                    {
                        "username": "khan60939",
                        "content": "Can anyone tell how DP is being used here? "
                    },
                    {
                        "username": "sandagolcea",
                        "content": "[@charonme](/charonme) my thinking exactly, but at least they should create a flag to help us moderate and move solutions to the correct tab. Would only need a stack overflow moderation-like system: one person flags, another person receives a queue of flagged comments and confirms the tagging.. oh well"
                    },
                    {
                        "username": "charonme",
                        "content": "maybe people get confused by the official leetcode comment which says: \"If you\\'d like to share a detailed solution to the problem, please create a new post in the discuss section\"\\nMaybe some time ago they didn\\'t have a separate solutions section and only recently changed it, but left some of the old solutions in the discussion section and didn\\'t fix the automated comment worting?"
                    },
                    {
                        "username": "klanjewar037",
                        "content": "hehe"
                    },
                    {
                        "username": "sanemdeepak",
                        "content": "For input \"ac\" test case is expecting \"a\" as output, how is just \"a\" a palindromic string?"
                    },
                    {
                        "username": "ayushiidevpura",
                        "content": "because when we read \"a\" from forward it results in \"a\" and at the same time when we read \"a\" from backward it is still \"a\""
                    },
                    {
                        "username": "beyzigo",
                        "content": "Because if you read the string \"a\" backwards it will still be \"a\""
                    },
                    {
                        "username": "tsafackghokeng",
                        "content": "[@Chouhan_Gourav](/Chouhan_Gourav) the test case said \"ac\" not \"a\". is \"ac\" palindromic? for \"a\" i understand"
                    },
                    {
                        "username": "CODEWITHABHINAV",
                        "content": "you have to submit the first string as your answer read more about this question on gFg\\n"
                    },
                    {
                        "username": "_BREEZE_",
                        "content": "any string is palindrome if we read it same from front and from back\\nin single character we read it same from front and back"
                    },
                    {
                        "username": "oinrup",
                        "content": "yes thats my question too"
                    },
                    {
                        "username": "yldemon",
                        "content": "Any character in the string by itself is a palindromic substring. So in the case where there is no palindromic substring with length > 1, you can return any character."
                    },
                    {
                        "username": "Chouhan_Gourav",
                        "content": "Whenever you come accross such contradiction, just google the definition, any. Any string is called is pallindromic if the reverse of the string is equal to the original string. Reverse of \\'a\\' is \\'a\\'. Hope you get this."
                    },
                    {
                        "username": "947876275",
                        "content": "This post is for learner wanna practice DP.\\nThe basic idea is, if we wanna say \"aba\" is palindromic, then we need to firstly confirm that \"b\" is palindromic, then we also need to check if \"a\"(the first a) = \"a\" (the second a).\\n\\nM is a 2-d array which stores boolean values.\\nM[i][j] indicates if string[i.....j] is palindromic.\\nSo base cases are:\\nM[i][i] is true.\\nM[i][i + 1] = (s[i] == s[i + 1]);\\nrecurrence relation is :\\nM[i][j] = (s[i] == s[j] AND M[i + 1][j - 1]);\\nFor the implementation of recurrence relation, one idea is you can loop through all possible symmetry axis. For each of the axis, you expand at both RHS and LHS simultaneously. This method promises that when you are determining value in M[i][j], M[i + 1][j - 1] must have the correct value.\\nFinal answer can be found from all M[i][j] == 1 with largest (j - i)."
                    },
                    {
                        "username": "Msey",
                        "content": "thank you, cat brother"
                    },
                    {
                        "username": "user0558y",
                        "content": "I understand the solution but I don't understand why it needs any storage at all or why it needs to be a DP solution.\n\nThe condition `(s[i] == s[j] AND M[i + 1][j - 1])` requires you to memorise if `M[i+1][j-1]` is true, that's easy to understand. However, if you expand each possible axis at the same time, i.e. 1st iteration (s[i+1], s[j-1]), 2nd iteration `s[i+2], s[j-2]`, ... It is guaranteed that M[i+1][j-1] is always true and hence can be dropped, and you should break the loop when it is not true.\n\nIn summary, you don't need to memorise anything at all and you just need to check `s[i] == s[j]` while expanding in both directions at the same time, unless I have misunderstood anything? Here is an implementation of your algorithm but without storage: https://leetcode.com/problems/longest-palindromic-substring/submissions/868540120/"
                    },
                    {
                        "username": "taras",
                        "content": "Thank you! this is a beautiful explanation, though I\\'m not sure what exactly you mean by expanding both on LHS and RHS. In my implementation it\\'s enough to compute all diagonals of  the upper right triangle of the dp matrix."
                    },
                    {
                        "username": "klu_2100031593",
                        "content": "super explanation"
                    },
                    {
                        "username": "napoleon",
                        "content": "My Solution Is Naive, It Cost O(n^2), Is there Any Solution faster?"
                    },
                    {
                        "username": "leocampos",
                        "content": "[@tylerprill-rhdc](/tylerprill-rhdc) So, what I did was:\nStated in my mind the Brute Force approach - create every possible substring and test each one to see if is a palindrome and find the longest.\n\nOf course this would be ridiculously slow, so let's improve it.\nI also mentally stated that a palindrome has a recursive aspect -> if single char, or two equal chars, or charX + palindrome + charX\nSo I created a isPalindrome recursive method that checked it delegating to itself extracting the borders.\n\nSince a palindrome must start and end with the same char, in my traverse of the string, I started storing the position of each character Map<Character, List< Integer>>, so I would just go back to the previous found Char and check if from there to the current pointer I would have a Palindrome.\n\nThen I stopped doing this for every possible palindrome, I then started doing only for the ones that COULD be longer than the already found longest palindrome. That accelerated a lot.\n\nIn the almost last step, I added memoization. Remember that a palindrome is like a sandwich, with the external chars being equal and the meat being another palindrome? So I stored the found palindromes using their start and and positions. So I could check if that had already being checked and if so, either return true or false directly.\n\nThe final step was to convert the recursive function to an iterative function to save some memory used by the call stack.\nMaybe there are better implementations, just sharing my thought process."
                    },
                    {
                        "username": "tylerprill-rhdc",
                        "content": "[@tylerprill-rhdc](/tylerprill-rhdc) Two pointer based solution is also a really good solve here"
                    },
                    {
                        "username": "tylerprill-rhdc",
                        "content": "This could be done in a single pass algorithm, but will inherently check character indices multiple times based on the nature of the problem. (basically, iterate through each, then bubble out from each index)"
                    },
                    {
                        "username": "neetika",
                        "content": "From the leetcode blog, one of the methods of solving this is:\\n\\nA common mistake:\\nSome people will be tempted to come up with a quick solution, which is unfortunately flawed (however can be corrected easily):\\n\\nReverse S and become S\\u2019. Find the longest common substring between S and S\\u2019, which must also be the longest palindromic substring.\\nThis seemed to work, let\\u2019s see some examples below.\\n\\nFor example,\\nS = \\u201ccaba\\u201d, S\\u2019 = \\u201cabac\\u201d.\\nThe longest common substring between S and S\\u2019 is \\u201caba\\u201d, which is the answer.\\n\\nLet\\u2019s try another example:\\nS = \\u201cabacdfgdcaba\\u201d, S\\u2019 = \\u201cabacdgfdcaba\\u201d.\\nThe longest common substring between S and S\\u2019 is \\u201cabacd\\u201d. Clearly, this is not a valid palindrome.\\n\\n**We could see that the longest common substring method fails when there exists a reversed copy of a non-palindromic substring in some other part of S. To rectify this, each time we find a longest common substring candidate, we check if the substring\\u2019s indices are the same as the reversed substring\\u2019s original indices. If it is, then we attempt to update the longest palindrome found so far; if not, we skip this and find the next candidate.**\\n\\nIs this part correct? \\n\\nexample string: abcxycba\\nreverse string:  abcxycba\\n\\nThe substring indices are same as reversed string original indices and yet it is not a palindrome?"
                    },
                    {
                        "username": "HRVY_SNOWDEN",
                        "content": "cool sirr:)\\n"
                    },
                    {
                        "username": "dhtmlkitchen",
                        "content": "WRONG.\\n\\nabcxycba reversed is abcyxcba."
                    },
                    {
                        "username": "travisl12",
                        "content": "After I solved this problem I thought it\\'d be interesting to see how it worked in realtime.\\n\\nhttps://codepen.io/TravisL12/pen/pogvweg"
                    },
                    {
                        "username": "user3907vj",
                        "content": "thanks for the \"nanananananana\" from all the small things ;)"
                    },
                    {
                        "username": "zapataast",
                        "content": "u are crazy"
                    },
                    {
                        "username": "sondq98",
                        "content": "very intuitive"
                    },
                    {
                        "username": "Tathagat017",
                        "content": "thank you\\n"
                    },
                    {
                        "username": "mikler",
                        "content": "So I think I finally understood logic of test creators. \\nEven if you write a classical DP or memorization solution for this one you will timeout on latest tests.\\nI think they consider it edge cases. Because if you add one simple line it will pass! OMG. \\nI have leet code for this. Instead of solving problems I spend hours optimizing the constants.\\n\\nif s == s[::-1]: return s"
                    },
                    {
                        "username": "Vectorido",
                        "content": "Don\\'t work already. Time limit at 141 test even with that construction."
                    },
                    {
                        "username": "deepalithakur17",
                        "content": "It will only work in python."
                    },
                    {
                        "username": "ishogbon",
                        "content": "Its memoization, not memorization "
                    },
                    {
                        "username": "84danie",
                        "content": "I submitted my solution, and received a Time Limit Exceeded on this test case:\\n\\n\"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaabcaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"\\n\\nSo I copied and pasted the TC into a custom test case, and started to think about what I could tweak. However, I ended up accidentally hitting Run Code, but instead of getting a Time Limit Exceeded result, it passed:\\n\\n![0_1479079812693_upload-4af9e94c-2e53-4915-acf6-782780c7bf8b](/uploads/files/1479079813717-upload-4af9e94c-2e53-4915-acf6-782780c7bf8b.png) \\n\\nIs this supposed to happen and I just need to make my code more efficient, or is this a bug? \\n![0_1479079956817_upload-1ef15826-d6e6-4bde-9c06-eb597c5c8d0e](/uploads/files/1479079957639-upload-1ef15826-d6e6-4bde-9c06-eb597c5c8d0e.png)"
                    },
                    {
                        "username": "RitikaSahay",
                        "content": "Same thing happened with me. Is there a solution for it?\\n"
                    },
                    {
                        "username": "danicruz0415",
                        "content": "It\\'s happened to me a couple of times. My theory is that the time limit is given for the whole list of test cases. Thus, you can have your test pass, but it will still time limit exceed because it wont get to calculate all the test cases before the time runs out. I cannot confirm this but I think its true because with a very unoptimized solution I got time limit exceeded very early in the test cases (for another problem), after some optimizations I got it much later (like getting to the last tests) which themselves were around the same size, so if the time limit was set per test it would not make sense to fail in a similarly long test-case just that is much later in the test list. (I think the same would apply to memory limit exceeded)"
                    },
                    {
                        "username": "him_Sarma619",
                        "content": "The exact same situation happened with me in one problem... it was a DP problem too... I was getting a Memory Limit Exceeded error with the memoized solution but it was running fine in the Run Code button."
                    },
                    {
                        "username": "Hubro",
                        "content": "I\\'m getting \"Time Limit Exceeded\" with 141/141 testcases passed and \"Last Executed Input\" is:\\n\\n```\\ns =\\n```\\n\\nDid I break it?"
                    },
                    {
                        "username": "karan_dhiman",
                        "content": "same issue"
                    },
                    {
                        "username": "BLANK-Zora",
                        "content": "exactly bro this shit is recked , like it is giving tests outside the constraints , how am i suppose to include such things in the code"
                    },
                    {
                        "username": "arunprep5",
                        "content": "same issue. java"
                    },
                    {
                        "username": "blasphelmy",
                        "content": "[@tuancoltech](/tuancoltech) it worked when i rewrote the code in c# instead of c++"
                    },
                    {
                        "username": "tuancoltech",
                        "content": "[@blasphelmy](/blasphelmy) [@Tomas Sandven](/Hubro) Did you guys find out why? I got the same issue."
                    },
                    {
                        "username": "blasphelmy",
                        "content": "i got that too. im not sure whats going on given that the constraint for input is between 1 and 1000"
                    },
                    {
                        "username": "Vinitajain",
                        "content": "Hi All,\\nI have a test case which is failing, but I feel the testcase result is incorrect.Please refer the screenshot below.\\n![image](https://assets.leetcode.com/users/images/e9e42efb-63d5-4cfa-b420-f1926674f6dc_1654838015.8394327.png)\\n\\nThe longest palindromic substring is \"aaca\" but the test case result is \"aca\". Anyone else faced this problem?"
                    },
                    {
                        "username": "OthSO",
                        "content": "[@mohdansah10](/mohdansah10) \\nthey are separated in the input with \"bd\" so it is not a valid answer "
                    },
                    {
                        "username": "mohdansah10",
                        "content": "I\\'m getting same error, but different case:\\nInput\\ns =\\n\"aacabdkacaa\"\\n\\nOutput\\n\"aacakacaa\"\\nExpected\\n\"aca\"\\n\\nBut mine is Palindrome"
                    },
                    {
                        "username": "hasmithraa",
                        "content": "the expected is correct because aaca can\\'t be a palindrome only \\'aacaa\\' can be a palindrome which is not there in your case"
                    },
                    {
                        "username": "Amish_Singh",
                        "content": "how are you considering \"aaca\" as a palindromic substring, \"aca\" is a palindrome and it is the longest"
                    },
                    {
                        "username": "Shaik_Aman_Sayer",
                        "content": "dude you really came up with the solution "
                    },
                    {
                        "username": "AryaAditya3609",
                        "content": "how is \"aaca\" and \"acaa\" same ???\\nWhile \"aca\" is palindrome because both \"aca\" and reverse of it \"aca\" is same !!"
                    },
                    {
                        "username": "alexandra-pickle",
                        "content": "\"aaca\" is not a palindrome"
                    },
                    {
                        "username": "bugHackerLoop",
                        "content": "I followed the approach leant by Aditya Verma DP lectures and encountered the same test case failing. Does the logic where I reverse the string and calculate the longest common substring doesn\\'t work here? I know it works for longest palindromic subsequence but here it fails for such test cases .. why is it so?"
                    },
                    {
                        "username": "mductran",
                        "content": "how is \\'aaca\\' a palindrome? when read backward it\\'s \\'acaa\\' so it\\'s not the same reading forward."
                    },
                    {
                        "username": "jnsudhir",
                        "content": "Check my solution, it was able to clear test case \"aaca\". Explained code in comments.\\n\\nhttps://leetcode.com/problems/longest-palindromic-substring/solutions/3091016/longest-palindromic-substring-using-javascript-beats-94-82-in-runtime-explained/?orderBy=most_votes"
                    },
                    {
                        "username": "nikhileshratna",
                        "content": "aaca is not palindrome"
                    },
                    {
                        "username": "sunshine77",
                        "content": "hey, iam getting the same error, i have seen ansewrs where they have totally changed the algorithm, how did u solve this by tweaking the same algoirhtm"
                    },
                    {
                        "username": "bhupendrabc71",
                        "content": "how come \"aaca\" is palindrome. it should be \"aca\""
                    },
                    {
                        "username": "just11blocks",
                        "content": "aaca is not a palindrome...aacaa and aca are."
                    },
                    {
                        "username": "odi1n",
                        "content": "I also encountered this problem"
                    },
                    {
                        "username": "vamsi2302",
                        "content": "I think you get it by now!\\n"
                    }
                ]
            },
            {
                "id": 1569251,
                "content": [
                    {
                        "username": "ZenMasterV",
                        "content": "Seems like too many of the  coding wunderkinds here lack basic reading comprehension skills \\n\" Please don\\'t post any solutions in this discussion tab\"\\nIt\\'s almost the rule to find the exact opposite for the discussion of every question. I don\\'t want to see your damned solution!"
                    },
                    {
                        "username": "NeroXIII",
                        "content": "[@charonme](/charonme) name does not check out :((("
                    },
                    {
                        "username": "192731",
                        "content": "and if they do?"
                    },
                    {
                        "username": "plevi1995",
                        "content": "Excellent comment"
                    },
                    {
                        "username": "khan60939",
                        "content": "Can anyone tell how DP is being used here? "
                    },
                    {
                        "username": "sandagolcea",
                        "content": "[@charonme](/charonme) my thinking exactly, but at least they should create a flag to help us moderate and move solutions to the correct tab. Would only need a stack overflow moderation-like system: one person flags, another person receives a queue of flagged comments and confirms the tagging.. oh well"
                    },
                    {
                        "username": "charonme",
                        "content": "maybe people get confused by the official leetcode comment which says: \"If you\\'d like to share a detailed solution to the problem, please create a new post in the discuss section\"\\nMaybe some time ago they didn\\'t have a separate solutions section and only recently changed it, but left some of the old solutions in the discussion section and didn\\'t fix the automated comment worting?"
                    },
                    {
                        "username": "klanjewar037",
                        "content": "hehe"
                    },
                    {
                        "username": "sanemdeepak",
                        "content": "For input \"ac\" test case is expecting \"a\" as output, how is just \"a\" a palindromic string?"
                    },
                    {
                        "username": "ayushiidevpura",
                        "content": "because when we read \"a\" from forward it results in \"a\" and at the same time when we read \"a\" from backward it is still \"a\""
                    },
                    {
                        "username": "beyzigo",
                        "content": "Because if you read the string \"a\" backwards it will still be \"a\""
                    },
                    {
                        "username": "tsafackghokeng",
                        "content": "[@Chouhan_Gourav](/Chouhan_Gourav) the test case said \"ac\" not \"a\". is \"ac\" palindromic? for \"a\" i understand"
                    },
                    {
                        "username": "CODEWITHABHINAV",
                        "content": "you have to submit the first string as your answer read more about this question on gFg\\n"
                    },
                    {
                        "username": "_BREEZE_",
                        "content": "any string is palindrome if we read it same from front and from back\\nin single character we read it same from front and back"
                    },
                    {
                        "username": "oinrup",
                        "content": "yes thats my question too"
                    },
                    {
                        "username": "yldemon",
                        "content": "Any character in the string by itself is a palindromic substring. So in the case where there is no palindromic substring with length > 1, you can return any character."
                    },
                    {
                        "username": "Chouhan_Gourav",
                        "content": "Whenever you come accross such contradiction, just google the definition, any. Any string is called is pallindromic if the reverse of the string is equal to the original string. Reverse of \\'a\\' is \\'a\\'. Hope you get this."
                    },
                    {
                        "username": "947876275",
                        "content": "This post is for learner wanna practice DP.\\nThe basic idea is, if we wanna say \"aba\" is palindromic, then we need to firstly confirm that \"b\" is palindromic, then we also need to check if \"a\"(the first a) = \"a\" (the second a).\\n\\nM is a 2-d array which stores boolean values.\\nM[i][j] indicates if string[i.....j] is palindromic.\\nSo base cases are:\\nM[i][i] is true.\\nM[i][i + 1] = (s[i] == s[i + 1]);\\nrecurrence relation is :\\nM[i][j] = (s[i] == s[j] AND M[i + 1][j - 1]);\\nFor the implementation of recurrence relation, one idea is you can loop through all possible symmetry axis. For each of the axis, you expand at both RHS and LHS simultaneously. This method promises that when you are determining value in M[i][j], M[i + 1][j - 1] must have the correct value.\\nFinal answer can be found from all M[i][j] == 1 with largest (j - i)."
                    },
                    {
                        "username": "Msey",
                        "content": "thank you, cat brother"
                    },
                    {
                        "username": "user0558y",
                        "content": "I understand the solution but I don't understand why it needs any storage at all or why it needs to be a DP solution.\n\nThe condition `(s[i] == s[j] AND M[i + 1][j - 1])` requires you to memorise if `M[i+1][j-1]` is true, that's easy to understand. However, if you expand each possible axis at the same time, i.e. 1st iteration (s[i+1], s[j-1]), 2nd iteration `s[i+2], s[j-2]`, ... It is guaranteed that M[i+1][j-1] is always true and hence can be dropped, and you should break the loop when it is not true.\n\nIn summary, you don't need to memorise anything at all and you just need to check `s[i] == s[j]` while expanding in both directions at the same time, unless I have misunderstood anything? Here is an implementation of your algorithm but without storage: https://leetcode.com/problems/longest-palindromic-substring/submissions/868540120/"
                    },
                    {
                        "username": "taras",
                        "content": "Thank you! this is a beautiful explanation, though I\\'m not sure what exactly you mean by expanding both on LHS and RHS. In my implementation it\\'s enough to compute all diagonals of  the upper right triangle of the dp matrix."
                    },
                    {
                        "username": "klu_2100031593",
                        "content": "super explanation"
                    },
                    {
                        "username": "napoleon",
                        "content": "My Solution Is Naive, It Cost O(n^2), Is there Any Solution faster?"
                    },
                    {
                        "username": "leocampos",
                        "content": "[@tylerprill-rhdc](/tylerprill-rhdc) So, what I did was:\nStated in my mind the Brute Force approach - create every possible substring and test each one to see if is a palindrome and find the longest.\n\nOf course this would be ridiculously slow, so let's improve it.\nI also mentally stated that a palindrome has a recursive aspect -> if single char, or two equal chars, or charX + palindrome + charX\nSo I created a isPalindrome recursive method that checked it delegating to itself extracting the borders.\n\nSince a palindrome must start and end with the same char, in my traverse of the string, I started storing the position of each character Map<Character, List< Integer>>, so I would just go back to the previous found Char and check if from there to the current pointer I would have a Palindrome.\n\nThen I stopped doing this for every possible palindrome, I then started doing only for the ones that COULD be longer than the already found longest palindrome. That accelerated a lot.\n\nIn the almost last step, I added memoization. Remember that a palindrome is like a sandwich, with the external chars being equal and the meat being another palindrome? So I stored the found palindromes using their start and and positions. So I could check if that had already being checked and if so, either return true or false directly.\n\nThe final step was to convert the recursive function to an iterative function to save some memory used by the call stack.\nMaybe there are better implementations, just sharing my thought process."
                    },
                    {
                        "username": "tylerprill-rhdc",
                        "content": "[@tylerprill-rhdc](/tylerprill-rhdc) Two pointer based solution is also a really good solve here"
                    },
                    {
                        "username": "tylerprill-rhdc",
                        "content": "This could be done in a single pass algorithm, but will inherently check character indices multiple times based on the nature of the problem. (basically, iterate through each, then bubble out from each index)"
                    },
                    {
                        "username": "neetika",
                        "content": "From the leetcode blog, one of the methods of solving this is:\\n\\nA common mistake:\\nSome people will be tempted to come up with a quick solution, which is unfortunately flawed (however can be corrected easily):\\n\\nReverse S and become S\\u2019. Find the longest common substring between S and S\\u2019, which must also be the longest palindromic substring.\\nThis seemed to work, let\\u2019s see some examples below.\\n\\nFor example,\\nS = \\u201ccaba\\u201d, S\\u2019 = \\u201cabac\\u201d.\\nThe longest common substring between S and S\\u2019 is \\u201caba\\u201d, which is the answer.\\n\\nLet\\u2019s try another example:\\nS = \\u201cabacdfgdcaba\\u201d, S\\u2019 = \\u201cabacdgfdcaba\\u201d.\\nThe longest common substring between S and S\\u2019 is \\u201cabacd\\u201d. Clearly, this is not a valid palindrome.\\n\\n**We could see that the longest common substring method fails when there exists a reversed copy of a non-palindromic substring in some other part of S. To rectify this, each time we find a longest common substring candidate, we check if the substring\\u2019s indices are the same as the reversed substring\\u2019s original indices. If it is, then we attempt to update the longest palindrome found so far; if not, we skip this and find the next candidate.**\\n\\nIs this part correct? \\n\\nexample string: abcxycba\\nreverse string:  abcxycba\\n\\nThe substring indices are same as reversed string original indices and yet it is not a palindrome?"
                    },
                    {
                        "username": "HRVY_SNOWDEN",
                        "content": "cool sirr:)\\n"
                    },
                    {
                        "username": "dhtmlkitchen",
                        "content": "WRONG.\\n\\nabcxycba reversed is abcyxcba."
                    },
                    {
                        "username": "travisl12",
                        "content": "After I solved this problem I thought it\\'d be interesting to see how it worked in realtime.\\n\\nhttps://codepen.io/TravisL12/pen/pogvweg"
                    },
                    {
                        "username": "user3907vj",
                        "content": "thanks for the \"nanananananana\" from all the small things ;)"
                    },
                    {
                        "username": "zapataast",
                        "content": "u are crazy"
                    },
                    {
                        "username": "sondq98",
                        "content": "very intuitive"
                    },
                    {
                        "username": "Tathagat017",
                        "content": "thank you\\n"
                    },
                    {
                        "username": "mikler",
                        "content": "So I think I finally understood logic of test creators. \\nEven if you write a classical DP or memorization solution for this one you will timeout on latest tests.\\nI think they consider it edge cases. Because if you add one simple line it will pass! OMG. \\nI have leet code for this. Instead of solving problems I spend hours optimizing the constants.\\n\\nif s == s[::-1]: return s"
                    },
                    {
                        "username": "Vectorido",
                        "content": "Don\\'t work already. Time limit at 141 test even with that construction."
                    },
                    {
                        "username": "deepalithakur17",
                        "content": "It will only work in python."
                    },
                    {
                        "username": "ishogbon",
                        "content": "Its memoization, not memorization "
                    },
                    {
                        "username": "84danie",
                        "content": "I submitted my solution, and received a Time Limit Exceeded on this test case:\\n\\n\"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaabcaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"\\n\\nSo I copied and pasted the TC into a custom test case, and started to think about what I could tweak. However, I ended up accidentally hitting Run Code, but instead of getting a Time Limit Exceeded result, it passed:\\n\\n![0_1479079812693_upload-4af9e94c-2e53-4915-acf6-782780c7bf8b](/uploads/files/1479079813717-upload-4af9e94c-2e53-4915-acf6-782780c7bf8b.png) \\n\\nIs this supposed to happen and I just need to make my code more efficient, or is this a bug? \\n![0_1479079956817_upload-1ef15826-d6e6-4bde-9c06-eb597c5c8d0e](/uploads/files/1479079957639-upload-1ef15826-d6e6-4bde-9c06-eb597c5c8d0e.png)"
                    },
                    {
                        "username": "RitikaSahay",
                        "content": "Same thing happened with me. Is there a solution for it?\\n"
                    },
                    {
                        "username": "danicruz0415",
                        "content": "It\\'s happened to me a couple of times. My theory is that the time limit is given for the whole list of test cases. Thus, you can have your test pass, but it will still time limit exceed because it wont get to calculate all the test cases before the time runs out. I cannot confirm this but I think its true because with a very unoptimized solution I got time limit exceeded very early in the test cases (for another problem), after some optimizations I got it much later (like getting to the last tests) which themselves were around the same size, so if the time limit was set per test it would not make sense to fail in a similarly long test-case just that is much later in the test list. (I think the same would apply to memory limit exceeded)"
                    },
                    {
                        "username": "him_Sarma619",
                        "content": "The exact same situation happened with me in one problem... it was a DP problem too... I was getting a Memory Limit Exceeded error with the memoized solution but it was running fine in the Run Code button."
                    },
                    {
                        "username": "Hubro",
                        "content": "I\\'m getting \"Time Limit Exceeded\" with 141/141 testcases passed and \"Last Executed Input\" is:\\n\\n```\\ns =\\n```\\n\\nDid I break it?"
                    },
                    {
                        "username": "karan_dhiman",
                        "content": "same issue"
                    },
                    {
                        "username": "BLANK-Zora",
                        "content": "exactly bro this shit is recked , like it is giving tests outside the constraints , how am i suppose to include such things in the code"
                    },
                    {
                        "username": "arunprep5",
                        "content": "same issue. java"
                    },
                    {
                        "username": "blasphelmy",
                        "content": "[@tuancoltech](/tuancoltech) it worked when i rewrote the code in c# instead of c++"
                    },
                    {
                        "username": "tuancoltech",
                        "content": "[@blasphelmy](/blasphelmy) [@Tomas Sandven](/Hubro) Did you guys find out why? I got the same issue."
                    },
                    {
                        "username": "blasphelmy",
                        "content": "i got that too. im not sure whats going on given that the constraint for input is between 1 and 1000"
                    },
                    {
                        "username": "Vinitajain",
                        "content": "Hi All,\\nI have a test case which is failing, but I feel the testcase result is incorrect.Please refer the screenshot below.\\n![image](https://assets.leetcode.com/users/images/e9e42efb-63d5-4cfa-b420-f1926674f6dc_1654838015.8394327.png)\\n\\nThe longest palindromic substring is \"aaca\" but the test case result is \"aca\". Anyone else faced this problem?"
                    },
                    {
                        "username": "OthSO",
                        "content": "[@mohdansah10](/mohdansah10) \\nthey are separated in the input with \"bd\" so it is not a valid answer "
                    },
                    {
                        "username": "mohdansah10",
                        "content": "I\\'m getting same error, but different case:\\nInput\\ns =\\n\"aacabdkacaa\"\\n\\nOutput\\n\"aacakacaa\"\\nExpected\\n\"aca\"\\n\\nBut mine is Palindrome"
                    },
                    {
                        "username": "hasmithraa",
                        "content": "the expected is correct because aaca can\\'t be a palindrome only \\'aacaa\\' can be a palindrome which is not there in your case"
                    },
                    {
                        "username": "Amish_Singh",
                        "content": "how are you considering \"aaca\" as a palindromic substring, \"aca\" is a palindrome and it is the longest"
                    },
                    {
                        "username": "Shaik_Aman_Sayer",
                        "content": "dude you really came up with the solution "
                    },
                    {
                        "username": "AryaAditya3609",
                        "content": "how is \"aaca\" and \"acaa\" same ???\\nWhile \"aca\" is palindrome because both \"aca\" and reverse of it \"aca\" is same !!"
                    },
                    {
                        "username": "alexandra-pickle",
                        "content": "\"aaca\" is not a palindrome"
                    },
                    {
                        "username": "bugHackerLoop",
                        "content": "I followed the approach leant by Aditya Verma DP lectures and encountered the same test case failing. Does the logic where I reverse the string and calculate the longest common substring doesn\\'t work here? I know it works for longest palindromic subsequence but here it fails for such test cases .. why is it so?"
                    },
                    {
                        "username": "mductran",
                        "content": "how is \\'aaca\\' a palindrome? when read backward it\\'s \\'acaa\\' so it\\'s not the same reading forward."
                    },
                    {
                        "username": "jnsudhir",
                        "content": "Check my solution, it was able to clear test case \"aaca\". Explained code in comments.\\n\\nhttps://leetcode.com/problems/longest-palindromic-substring/solutions/3091016/longest-palindromic-substring-using-javascript-beats-94-82-in-runtime-explained/?orderBy=most_votes"
                    },
                    {
                        "username": "nikhileshratna",
                        "content": "aaca is not palindrome"
                    },
                    {
                        "username": "sunshine77",
                        "content": "hey, iam getting the same error, i have seen ansewrs where they have totally changed the algorithm, how did u solve this by tweaking the same algoirhtm"
                    },
                    {
                        "username": "bhupendrabc71",
                        "content": "how come \"aaca\" is palindrome. it should be \"aca\""
                    },
                    {
                        "username": "just11blocks",
                        "content": "aaca is not a palindrome...aacaa and aca are."
                    },
                    {
                        "username": "odi1n",
                        "content": "I also encountered this problem"
                    },
                    {
                        "username": "vamsi2302",
                        "content": "I think you get it by now!\\n"
                    }
                ]
            },
            {
                "id": 1566232,
                "content": [
                    {
                        "username": "ZenMasterV",
                        "content": "Seems like too many of the  coding wunderkinds here lack basic reading comprehension skills \\n\" Please don\\'t post any solutions in this discussion tab\"\\nIt\\'s almost the rule to find the exact opposite for the discussion of every question. I don\\'t want to see your damned solution!"
                    },
                    {
                        "username": "NeroXIII",
                        "content": "[@charonme](/charonme) name does not check out :((("
                    },
                    {
                        "username": "192731",
                        "content": "and if they do?"
                    },
                    {
                        "username": "plevi1995",
                        "content": "Excellent comment"
                    },
                    {
                        "username": "khan60939",
                        "content": "Can anyone tell how DP is being used here? "
                    },
                    {
                        "username": "sandagolcea",
                        "content": "[@charonme](/charonme) my thinking exactly, but at least they should create a flag to help us moderate and move solutions to the correct tab. Would only need a stack overflow moderation-like system: one person flags, another person receives a queue of flagged comments and confirms the tagging.. oh well"
                    },
                    {
                        "username": "charonme",
                        "content": "maybe people get confused by the official leetcode comment which says: \"If you\\'d like to share a detailed solution to the problem, please create a new post in the discuss section\"\\nMaybe some time ago they didn\\'t have a separate solutions section and only recently changed it, but left some of the old solutions in the discussion section and didn\\'t fix the automated comment worting?"
                    },
                    {
                        "username": "klanjewar037",
                        "content": "hehe"
                    },
                    {
                        "username": "sanemdeepak",
                        "content": "For input \"ac\" test case is expecting \"a\" as output, how is just \"a\" a palindromic string?"
                    },
                    {
                        "username": "ayushiidevpura",
                        "content": "because when we read \"a\" from forward it results in \"a\" and at the same time when we read \"a\" from backward it is still \"a\""
                    },
                    {
                        "username": "beyzigo",
                        "content": "Because if you read the string \"a\" backwards it will still be \"a\""
                    },
                    {
                        "username": "tsafackghokeng",
                        "content": "[@Chouhan_Gourav](/Chouhan_Gourav) the test case said \"ac\" not \"a\". is \"ac\" palindromic? for \"a\" i understand"
                    },
                    {
                        "username": "CODEWITHABHINAV",
                        "content": "you have to submit the first string as your answer read more about this question on gFg\\n"
                    },
                    {
                        "username": "_BREEZE_",
                        "content": "any string is palindrome if we read it same from front and from back\\nin single character we read it same from front and back"
                    },
                    {
                        "username": "oinrup",
                        "content": "yes thats my question too"
                    },
                    {
                        "username": "yldemon",
                        "content": "Any character in the string by itself is a palindromic substring. So in the case where there is no palindromic substring with length > 1, you can return any character."
                    },
                    {
                        "username": "Chouhan_Gourav",
                        "content": "Whenever you come accross such contradiction, just google the definition, any. Any string is called is pallindromic if the reverse of the string is equal to the original string. Reverse of \\'a\\' is \\'a\\'. Hope you get this."
                    },
                    {
                        "username": "947876275",
                        "content": "This post is for learner wanna practice DP.\\nThe basic idea is, if we wanna say \"aba\" is palindromic, then we need to firstly confirm that \"b\" is palindromic, then we also need to check if \"a\"(the first a) = \"a\" (the second a).\\n\\nM is a 2-d array which stores boolean values.\\nM[i][j] indicates if string[i.....j] is palindromic.\\nSo base cases are:\\nM[i][i] is true.\\nM[i][i + 1] = (s[i] == s[i + 1]);\\nrecurrence relation is :\\nM[i][j] = (s[i] == s[j] AND M[i + 1][j - 1]);\\nFor the implementation of recurrence relation, one idea is you can loop through all possible symmetry axis. For each of the axis, you expand at both RHS and LHS simultaneously. This method promises that when you are determining value in M[i][j], M[i + 1][j - 1] must have the correct value.\\nFinal answer can be found from all M[i][j] == 1 with largest (j - i)."
                    },
                    {
                        "username": "Msey",
                        "content": "thank you, cat brother"
                    },
                    {
                        "username": "user0558y",
                        "content": "I understand the solution but I don't understand why it needs any storage at all or why it needs to be a DP solution.\n\nThe condition `(s[i] == s[j] AND M[i + 1][j - 1])` requires you to memorise if `M[i+1][j-1]` is true, that's easy to understand. However, if you expand each possible axis at the same time, i.e. 1st iteration (s[i+1], s[j-1]), 2nd iteration `s[i+2], s[j-2]`, ... It is guaranteed that M[i+1][j-1] is always true and hence can be dropped, and you should break the loop when it is not true.\n\nIn summary, you don't need to memorise anything at all and you just need to check `s[i] == s[j]` while expanding in both directions at the same time, unless I have misunderstood anything? Here is an implementation of your algorithm but without storage: https://leetcode.com/problems/longest-palindromic-substring/submissions/868540120/"
                    },
                    {
                        "username": "taras",
                        "content": "Thank you! this is a beautiful explanation, though I\\'m not sure what exactly you mean by expanding both on LHS and RHS. In my implementation it\\'s enough to compute all diagonals of  the upper right triangle of the dp matrix."
                    },
                    {
                        "username": "klu_2100031593",
                        "content": "super explanation"
                    },
                    {
                        "username": "napoleon",
                        "content": "My Solution Is Naive, It Cost O(n^2), Is there Any Solution faster?"
                    },
                    {
                        "username": "leocampos",
                        "content": "[@tylerprill-rhdc](/tylerprill-rhdc) So, what I did was:\nStated in my mind the Brute Force approach - create every possible substring and test each one to see if is a palindrome and find the longest.\n\nOf course this would be ridiculously slow, so let's improve it.\nI also mentally stated that a palindrome has a recursive aspect -> if single char, or two equal chars, or charX + palindrome + charX\nSo I created a isPalindrome recursive method that checked it delegating to itself extracting the borders.\n\nSince a palindrome must start and end with the same char, in my traverse of the string, I started storing the position of each character Map<Character, List< Integer>>, so I would just go back to the previous found Char and check if from there to the current pointer I would have a Palindrome.\n\nThen I stopped doing this for every possible palindrome, I then started doing only for the ones that COULD be longer than the already found longest palindrome. That accelerated a lot.\n\nIn the almost last step, I added memoization. Remember that a palindrome is like a sandwich, with the external chars being equal and the meat being another palindrome? So I stored the found palindromes using their start and and positions. So I could check if that had already being checked and if so, either return true or false directly.\n\nThe final step was to convert the recursive function to an iterative function to save some memory used by the call stack.\nMaybe there are better implementations, just sharing my thought process."
                    },
                    {
                        "username": "tylerprill-rhdc",
                        "content": "[@tylerprill-rhdc](/tylerprill-rhdc) Two pointer based solution is also a really good solve here"
                    },
                    {
                        "username": "tylerprill-rhdc",
                        "content": "This could be done in a single pass algorithm, but will inherently check character indices multiple times based on the nature of the problem. (basically, iterate through each, then bubble out from each index)"
                    },
                    {
                        "username": "neetika",
                        "content": "From the leetcode blog, one of the methods of solving this is:\\n\\nA common mistake:\\nSome people will be tempted to come up with a quick solution, which is unfortunately flawed (however can be corrected easily):\\n\\nReverse S and become S\\u2019. Find the longest common substring between S and S\\u2019, which must also be the longest palindromic substring.\\nThis seemed to work, let\\u2019s see some examples below.\\n\\nFor example,\\nS = \\u201ccaba\\u201d, S\\u2019 = \\u201cabac\\u201d.\\nThe longest common substring between S and S\\u2019 is \\u201caba\\u201d, which is the answer.\\n\\nLet\\u2019s try another example:\\nS = \\u201cabacdfgdcaba\\u201d, S\\u2019 = \\u201cabacdgfdcaba\\u201d.\\nThe longest common substring between S and S\\u2019 is \\u201cabacd\\u201d. Clearly, this is not a valid palindrome.\\n\\n**We could see that the longest common substring method fails when there exists a reversed copy of a non-palindromic substring in some other part of S. To rectify this, each time we find a longest common substring candidate, we check if the substring\\u2019s indices are the same as the reversed substring\\u2019s original indices. If it is, then we attempt to update the longest palindrome found so far; if not, we skip this and find the next candidate.**\\n\\nIs this part correct? \\n\\nexample string: abcxycba\\nreverse string:  abcxycba\\n\\nThe substring indices are same as reversed string original indices and yet it is not a palindrome?"
                    },
                    {
                        "username": "HRVY_SNOWDEN",
                        "content": "cool sirr:)\\n"
                    },
                    {
                        "username": "dhtmlkitchen",
                        "content": "WRONG.\\n\\nabcxycba reversed is abcyxcba."
                    },
                    {
                        "username": "travisl12",
                        "content": "After I solved this problem I thought it\\'d be interesting to see how it worked in realtime.\\n\\nhttps://codepen.io/TravisL12/pen/pogvweg"
                    },
                    {
                        "username": "user3907vj",
                        "content": "thanks for the \"nanananananana\" from all the small things ;)"
                    },
                    {
                        "username": "zapataast",
                        "content": "u are crazy"
                    },
                    {
                        "username": "sondq98",
                        "content": "very intuitive"
                    },
                    {
                        "username": "Tathagat017",
                        "content": "thank you\\n"
                    },
                    {
                        "username": "mikler",
                        "content": "So I think I finally understood logic of test creators. \\nEven if you write a classical DP or memorization solution for this one you will timeout on latest tests.\\nI think they consider it edge cases. Because if you add one simple line it will pass! OMG. \\nI have leet code for this. Instead of solving problems I spend hours optimizing the constants.\\n\\nif s == s[::-1]: return s"
                    },
                    {
                        "username": "Vectorido",
                        "content": "Don\\'t work already. Time limit at 141 test even with that construction."
                    },
                    {
                        "username": "deepalithakur17",
                        "content": "It will only work in python."
                    },
                    {
                        "username": "ishogbon",
                        "content": "Its memoization, not memorization "
                    },
                    {
                        "username": "84danie",
                        "content": "I submitted my solution, and received a Time Limit Exceeded on this test case:\\n\\n\"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaabcaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"\\n\\nSo I copied and pasted the TC into a custom test case, and started to think about what I could tweak. However, I ended up accidentally hitting Run Code, but instead of getting a Time Limit Exceeded result, it passed:\\n\\n![0_1479079812693_upload-4af9e94c-2e53-4915-acf6-782780c7bf8b](/uploads/files/1479079813717-upload-4af9e94c-2e53-4915-acf6-782780c7bf8b.png) \\n\\nIs this supposed to happen and I just need to make my code more efficient, or is this a bug? \\n![0_1479079956817_upload-1ef15826-d6e6-4bde-9c06-eb597c5c8d0e](/uploads/files/1479079957639-upload-1ef15826-d6e6-4bde-9c06-eb597c5c8d0e.png)"
                    },
                    {
                        "username": "RitikaSahay",
                        "content": "Same thing happened with me. Is there a solution for it?\\n"
                    },
                    {
                        "username": "danicruz0415",
                        "content": "It\\'s happened to me a couple of times. My theory is that the time limit is given for the whole list of test cases. Thus, you can have your test pass, but it will still time limit exceed because it wont get to calculate all the test cases before the time runs out. I cannot confirm this but I think its true because with a very unoptimized solution I got time limit exceeded very early in the test cases (for another problem), after some optimizations I got it much later (like getting to the last tests) which themselves were around the same size, so if the time limit was set per test it would not make sense to fail in a similarly long test-case just that is much later in the test list. (I think the same would apply to memory limit exceeded)"
                    },
                    {
                        "username": "him_Sarma619",
                        "content": "The exact same situation happened with me in one problem... it was a DP problem too... I was getting a Memory Limit Exceeded error with the memoized solution but it was running fine in the Run Code button."
                    },
                    {
                        "username": "Hubro",
                        "content": "I\\'m getting \"Time Limit Exceeded\" with 141/141 testcases passed and \"Last Executed Input\" is:\\n\\n```\\ns =\\n```\\n\\nDid I break it?"
                    },
                    {
                        "username": "karan_dhiman",
                        "content": "same issue"
                    },
                    {
                        "username": "BLANK-Zora",
                        "content": "exactly bro this shit is recked , like it is giving tests outside the constraints , how am i suppose to include such things in the code"
                    },
                    {
                        "username": "arunprep5",
                        "content": "same issue. java"
                    },
                    {
                        "username": "blasphelmy",
                        "content": "[@tuancoltech](/tuancoltech) it worked when i rewrote the code in c# instead of c++"
                    },
                    {
                        "username": "tuancoltech",
                        "content": "[@blasphelmy](/blasphelmy) [@Tomas Sandven](/Hubro) Did you guys find out why? I got the same issue."
                    },
                    {
                        "username": "blasphelmy",
                        "content": "i got that too. im not sure whats going on given that the constraint for input is between 1 and 1000"
                    },
                    {
                        "username": "Vinitajain",
                        "content": "Hi All,\\nI have a test case which is failing, but I feel the testcase result is incorrect.Please refer the screenshot below.\\n![image](https://assets.leetcode.com/users/images/e9e42efb-63d5-4cfa-b420-f1926674f6dc_1654838015.8394327.png)\\n\\nThe longest palindromic substring is \"aaca\" but the test case result is \"aca\". Anyone else faced this problem?"
                    },
                    {
                        "username": "OthSO",
                        "content": "[@mohdansah10](/mohdansah10) \\nthey are separated in the input with \"bd\" so it is not a valid answer "
                    },
                    {
                        "username": "mohdansah10",
                        "content": "I\\'m getting same error, but different case:\\nInput\\ns =\\n\"aacabdkacaa\"\\n\\nOutput\\n\"aacakacaa\"\\nExpected\\n\"aca\"\\n\\nBut mine is Palindrome"
                    },
                    {
                        "username": "hasmithraa",
                        "content": "the expected is correct because aaca can\\'t be a palindrome only \\'aacaa\\' can be a palindrome which is not there in your case"
                    },
                    {
                        "username": "Amish_Singh",
                        "content": "how are you considering \"aaca\" as a palindromic substring, \"aca\" is a palindrome and it is the longest"
                    },
                    {
                        "username": "Shaik_Aman_Sayer",
                        "content": "dude you really came up with the solution "
                    },
                    {
                        "username": "AryaAditya3609",
                        "content": "how is \"aaca\" and \"acaa\" same ???\\nWhile \"aca\" is palindrome because both \"aca\" and reverse of it \"aca\" is same !!"
                    },
                    {
                        "username": "alexandra-pickle",
                        "content": "\"aaca\" is not a palindrome"
                    },
                    {
                        "username": "bugHackerLoop",
                        "content": "I followed the approach leant by Aditya Verma DP lectures and encountered the same test case failing. Does the logic where I reverse the string and calculate the longest common substring doesn\\'t work here? I know it works for longest palindromic subsequence but here it fails for such test cases .. why is it so?"
                    },
                    {
                        "username": "mductran",
                        "content": "how is \\'aaca\\' a palindrome? when read backward it\\'s \\'acaa\\' so it\\'s not the same reading forward."
                    },
                    {
                        "username": "jnsudhir",
                        "content": "Check my solution, it was able to clear test case \"aaca\". Explained code in comments.\\n\\nhttps://leetcode.com/problems/longest-palindromic-substring/solutions/3091016/longest-palindromic-substring-using-javascript-beats-94-82-in-runtime-explained/?orderBy=most_votes"
                    },
                    {
                        "username": "nikhileshratna",
                        "content": "aaca is not palindrome"
                    },
                    {
                        "username": "sunshine77",
                        "content": "hey, iam getting the same error, i have seen ansewrs where they have totally changed the algorithm, how did u solve this by tweaking the same algoirhtm"
                    },
                    {
                        "username": "bhupendrabc71",
                        "content": "how come \"aaca\" is palindrome. it should be \"aca\""
                    },
                    {
                        "username": "just11blocks",
                        "content": "aaca is not a palindrome...aacaa and aca are."
                    },
                    {
                        "username": "odi1n",
                        "content": "I also encountered this problem"
                    },
                    {
                        "username": "vamsi2302",
                        "content": "I think you get it by now!\\n"
                    }
                ]
            },
            {
                "id": 1568804,
                "content": [
                    {
                        "username": "ZenMasterV",
                        "content": "Seems like too many of the  coding wunderkinds here lack basic reading comprehension skills \\n\" Please don\\'t post any solutions in this discussion tab\"\\nIt\\'s almost the rule to find the exact opposite for the discussion of every question. I don\\'t want to see your damned solution!"
                    },
                    {
                        "username": "NeroXIII",
                        "content": "[@charonme](/charonme) name does not check out :((("
                    },
                    {
                        "username": "192731",
                        "content": "and if they do?"
                    },
                    {
                        "username": "plevi1995",
                        "content": "Excellent comment"
                    },
                    {
                        "username": "khan60939",
                        "content": "Can anyone tell how DP is being used here? "
                    },
                    {
                        "username": "sandagolcea",
                        "content": "[@charonme](/charonme) my thinking exactly, but at least they should create a flag to help us moderate and move solutions to the correct tab. Would only need a stack overflow moderation-like system: one person flags, another person receives a queue of flagged comments and confirms the tagging.. oh well"
                    },
                    {
                        "username": "charonme",
                        "content": "maybe people get confused by the official leetcode comment which says: \"If you\\'d like to share a detailed solution to the problem, please create a new post in the discuss section\"\\nMaybe some time ago they didn\\'t have a separate solutions section and only recently changed it, but left some of the old solutions in the discussion section and didn\\'t fix the automated comment worting?"
                    },
                    {
                        "username": "klanjewar037",
                        "content": "hehe"
                    },
                    {
                        "username": "sanemdeepak",
                        "content": "For input \"ac\" test case is expecting \"a\" as output, how is just \"a\" a palindromic string?"
                    },
                    {
                        "username": "ayushiidevpura",
                        "content": "because when we read \"a\" from forward it results in \"a\" and at the same time when we read \"a\" from backward it is still \"a\""
                    },
                    {
                        "username": "beyzigo",
                        "content": "Because if you read the string \"a\" backwards it will still be \"a\""
                    },
                    {
                        "username": "tsafackghokeng",
                        "content": "[@Chouhan_Gourav](/Chouhan_Gourav) the test case said \"ac\" not \"a\". is \"ac\" palindromic? for \"a\" i understand"
                    },
                    {
                        "username": "CODEWITHABHINAV",
                        "content": "you have to submit the first string as your answer read more about this question on gFg\\n"
                    },
                    {
                        "username": "_BREEZE_",
                        "content": "any string is palindrome if we read it same from front and from back\\nin single character we read it same from front and back"
                    },
                    {
                        "username": "oinrup",
                        "content": "yes thats my question too"
                    },
                    {
                        "username": "yldemon",
                        "content": "Any character in the string by itself is a palindromic substring. So in the case where there is no palindromic substring with length > 1, you can return any character."
                    },
                    {
                        "username": "Chouhan_Gourav",
                        "content": "Whenever you come accross such contradiction, just google the definition, any. Any string is called is pallindromic if the reverse of the string is equal to the original string. Reverse of \\'a\\' is \\'a\\'. Hope you get this."
                    },
                    {
                        "username": "947876275",
                        "content": "This post is for learner wanna practice DP.\\nThe basic idea is, if we wanna say \"aba\" is palindromic, then we need to firstly confirm that \"b\" is palindromic, then we also need to check if \"a\"(the first a) = \"a\" (the second a).\\n\\nM is a 2-d array which stores boolean values.\\nM[i][j] indicates if string[i.....j] is palindromic.\\nSo base cases are:\\nM[i][i] is true.\\nM[i][i + 1] = (s[i] == s[i + 1]);\\nrecurrence relation is :\\nM[i][j] = (s[i] == s[j] AND M[i + 1][j - 1]);\\nFor the implementation of recurrence relation, one idea is you can loop through all possible symmetry axis. For each of the axis, you expand at both RHS and LHS simultaneously. This method promises that when you are determining value in M[i][j], M[i + 1][j - 1] must have the correct value.\\nFinal answer can be found from all M[i][j] == 1 with largest (j - i)."
                    },
                    {
                        "username": "Msey",
                        "content": "thank you, cat brother"
                    },
                    {
                        "username": "user0558y",
                        "content": "I understand the solution but I don't understand why it needs any storage at all or why it needs to be a DP solution.\n\nThe condition `(s[i] == s[j] AND M[i + 1][j - 1])` requires you to memorise if `M[i+1][j-1]` is true, that's easy to understand. However, if you expand each possible axis at the same time, i.e. 1st iteration (s[i+1], s[j-1]), 2nd iteration `s[i+2], s[j-2]`, ... It is guaranteed that M[i+1][j-1] is always true and hence can be dropped, and you should break the loop when it is not true.\n\nIn summary, you don't need to memorise anything at all and you just need to check `s[i] == s[j]` while expanding in both directions at the same time, unless I have misunderstood anything? Here is an implementation of your algorithm but without storage: https://leetcode.com/problems/longest-palindromic-substring/submissions/868540120/"
                    },
                    {
                        "username": "taras",
                        "content": "Thank you! this is a beautiful explanation, though I\\'m not sure what exactly you mean by expanding both on LHS and RHS. In my implementation it\\'s enough to compute all diagonals of  the upper right triangle of the dp matrix."
                    },
                    {
                        "username": "klu_2100031593",
                        "content": "super explanation"
                    },
                    {
                        "username": "napoleon",
                        "content": "My Solution Is Naive, It Cost O(n^2), Is there Any Solution faster?"
                    },
                    {
                        "username": "leocampos",
                        "content": "[@tylerprill-rhdc](/tylerprill-rhdc) So, what I did was:\nStated in my mind the Brute Force approach - create every possible substring and test each one to see if is a palindrome and find the longest.\n\nOf course this would be ridiculously slow, so let's improve it.\nI also mentally stated that a palindrome has a recursive aspect -> if single char, or two equal chars, or charX + palindrome + charX\nSo I created a isPalindrome recursive method that checked it delegating to itself extracting the borders.\n\nSince a palindrome must start and end with the same char, in my traverse of the string, I started storing the position of each character Map<Character, List< Integer>>, so I would just go back to the previous found Char and check if from there to the current pointer I would have a Palindrome.\n\nThen I stopped doing this for every possible palindrome, I then started doing only for the ones that COULD be longer than the already found longest palindrome. That accelerated a lot.\n\nIn the almost last step, I added memoization. Remember that a palindrome is like a sandwich, with the external chars being equal and the meat being another palindrome? So I stored the found palindromes using their start and and positions. So I could check if that had already being checked and if so, either return true or false directly.\n\nThe final step was to convert the recursive function to an iterative function to save some memory used by the call stack.\nMaybe there are better implementations, just sharing my thought process."
                    },
                    {
                        "username": "tylerprill-rhdc",
                        "content": "[@tylerprill-rhdc](/tylerprill-rhdc) Two pointer based solution is also a really good solve here"
                    },
                    {
                        "username": "tylerprill-rhdc",
                        "content": "This could be done in a single pass algorithm, but will inherently check character indices multiple times based on the nature of the problem. (basically, iterate through each, then bubble out from each index)"
                    },
                    {
                        "username": "neetika",
                        "content": "From the leetcode blog, one of the methods of solving this is:\\n\\nA common mistake:\\nSome people will be tempted to come up with a quick solution, which is unfortunately flawed (however can be corrected easily):\\n\\nReverse S and become S\\u2019. Find the longest common substring between S and S\\u2019, which must also be the longest palindromic substring.\\nThis seemed to work, let\\u2019s see some examples below.\\n\\nFor example,\\nS = \\u201ccaba\\u201d, S\\u2019 = \\u201cabac\\u201d.\\nThe longest common substring between S and S\\u2019 is \\u201caba\\u201d, which is the answer.\\n\\nLet\\u2019s try another example:\\nS = \\u201cabacdfgdcaba\\u201d, S\\u2019 = \\u201cabacdgfdcaba\\u201d.\\nThe longest common substring between S and S\\u2019 is \\u201cabacd\\u201d. Clearly, this is not a valid palindrome.\\n\\n**We could see that the longest common substring method fails when there exists a reversed copy of a non-palindromic substring in some other part of S. To rectify this, each time we find a longest common substring candidate, we check if the substring\\u2019s indices are the same as the reversed substring\\u2019s original indices. If it is, then we attempt to update the longest palindrome found so far; if not, we skip this and find the next candidate.**\\n\\nIs this part correct? \\n\\nexample string: abcxycba\\nreverse string:  abcxycba\\n\\nThe substring indices are same as reversed string original indices and yet it is not a palindrome?"
                    },
                    {
                        "username": "HRVY_SNOWDEN",
                        "content": "cool sirr:)\\n"
                    },
                    {
                        "username": "dhtmlkitchen",
                        "content": "WRONG.\\n\\nabcxycba reversed is abcyxcba."
                    },
                    {
                        "username": "travisl12",
                        "content": "After I solved this problem I thought it\\'d be interesting to see how it worked in realtime.\\n\\nhttps://codepen.io/TravisL12/pen/pogvweg"
                    },
                    {
                        "username": "user3907vj",
                        "content": "thanks for the \"nanananananana\" from all the small things ;)"
                    },
                    {
                        "username": "zapataast",
                        "content": "u are crazy"
                    },
                    {
                        "username": "sondq98",
                        "content": "very intuitive"
                    },
                    {
                        "username": "Tathagat017",
                        "content": "thank you\\n"
                    },
                    {
                        "username": "mikler",
                        "content": "So I think I finally understood logic of test creators. \\nEven if you write a classical DP or memorization solution for this one you will timeout on latest tests.\\nI think they consider it edge cases. Because if you add one simple line it will pass! OMG. \\nI have leet code for this. Instead of solving problems I spend hours optimizing the constants.\\n\\nif s == s[::-1]: return s"
                    },
                    {
                        "username": "Vectorido",
                        "content": "Don\\'t work already. Time limit at 141 test even with that construction."
                    },
                    {
                        "username": "deepalithakur17",
                        "content": "It will only work in python."
                    },
                    {
                        "username": "ishogbon",
                        "content": "Its memoization, not memorization "
                    },
                    {
                        "username": "84danie",
                        "content": "I submitted my solution, and received a Time Limit Exceeded on this test case:\\n\\n\"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaabcaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"\\n\\nSo I copied and pasted the TC into a custom test case, and started to think about what I could tweak. However, I ended up accidentally hitting Run Code, but instead of getting a Time Limit Exceeded result, it passed:\\n\\n![0_1479079812693_upload-4af9e94c-2e53-4915-acf6-782780c7bf8b](/uploads/files/1479079813717-upload-4af9e94c-2e53-4915-acf6-782780c7bf8b.png) \\n\\nIs this supposed to happen and I just need to make my code more efficient, or is this a bug? \\n![0_1479079956817_upload-1ef15826-d6e6-4bde-9c06-eb597c5c8d0e](/uploads/files/1479079957639-upload-1ef15826-d6e6-4bde-9c06-eb597c5c8d0e.png)"
                    },
                    {
                        "username": "RitikaSahay",
                        "content": "Same thing happened with me. Is there a solution for it?\\n"
                    },
                    {
                        "username": "danicruz0415",
                        "content": "It\\'s happened to me a couple of times. My theory is that the time limit is given for the whole list of test cases. Thus, you can have your test pass, but it will still time limit exceed because it wont get to calculate all the test cases before the time runs out. I cannot confirm this but I think its true because with a very unoptimized solution I got time limit exceeded very early in the test cases (for another problem), after some optimizations I got it much later (like getting to the last tests) which themselves were around the same size, so if the time limit was set per test it would not make sense to fail in a similarly long test-case just that is much later in the test list. (I think the same would apply to memory limit exceeded)"
                    },
                    {
                        "username": "him_Sarma619",
                        "content": "The exact same situation happened with me in one problem... it was a DP problem too... I was getting a Memory Limit Exceeded error with the memoized solution but it was running fine in the Run Code button."
                    },
                    {
                        "username": "Hubro",
                        "content": "I\\'m getting \"Time Limit Exceeded\" with 141/141 testcases passed and \"Last Executed Input\" is:\\n\\n```\\ns =\\n```\\n\\nDid I break it?"
                    },
                    {
                        "username": "karan_dhiman",
                        "content": "same issue"
                    },
                    {
                        "username": "BLANK-Zora",
                        "content": "exactly bro this shit is recked , like it is giving tests outside the constraints , how am i suppose to include such things in the code"
                    },
                    {
                        "username": "arunprep5",
                        "content": "same issue. java"
                    },
                    {
                        "username": "blasphelmy",
                        "content": "[@tuancoltech](/tuancoltech) it worked when i rewrote the code in c# instead of c++"
                    },
                    {
                        "username": "tuancoltech",
                        "content": "[@blasphelmy](/blasphelmy) [@Tomas Sandven](/Hubro) Did you guys find out why? I got the same issue."
                    },
                    {
                        "username": "blasphelmy",
                        "content": "i got that too. im not sure whats going on given that the constraint for input is between 1 and 1000"
                    },
                    {
                        "username": "Vinitajain",
                        "content": "Hi All,\\nI have a test case which is failing, but I feel the testcase result is incorrect.Please refer the screenshot below.\\n![image](https://assets.leetcode.com/users/images/e9e42efb-63d5-4cfa-b420-f1926674f6dc_1654838015.8394327.png)\\n\\nThe longest palindromic substring is \"aaca\" but the test case result is \"aca\". Anyone else faced this problem?"
                    },
                    {
                        "username": "OthSO",
                        "content": "[@mohdansah10](/mohdansah10) \\nthey are separated in the input with \"bd\" so it is not a valid answer "
                    },
                    {
                        "username": "mohdansah10",
                        "content": "I\\'m getting same error, but different case:\\nInput\\ns =\\n\"aacabdkacaa\"\\n\\nOutput\\n\"aacakacaa\"\\nExpected\\n\"aca\"\\n\\nBut mine is Palindrome"
                    },
                    {
                        "username": "hasmithraa",
                        "content": "the expected is correct because aaca can\\'t be a palindrome only \\'aacaa\\' can be a palindrome which is not there in your case"
                    },
                    {
                        "username": "Amish_Singh",
                        "content": "how are you considering \"aaca\" as a palindromic substring, \"aca\" is a palindrome and it is the longest"
                    },
                    {
                        "username": "Shaik_Aman_Sayer",
                        "content": "dude you really came up with the solution "
                    },
                    {
                        "username": "AryaAditya3609",
                        "content": "how is \"aaca\" and \"acaa\" same ???\\nWhile \"aca\" is palindrome because both \"aca\" and reverse of it \"aca\" is same !!"
                    },
                    {
                        "username": "alexandra-pickle",
                        "content": "\"aaca\" is not a palindrome"
                    },
                    {
                        "username": "bugHackerLoop",
                        "content": "I followed the approach leant by Aditya Verma DP lectures and encountered the same test case failing. Does the logic where I reverse the string and calculate the longest common substring doesn\\'t work here? I know it works for longest palindromic subsequence but here it fails for such test cases .. why is it so?"
                    },
                    {
                        "username": "mductran",
                        "content": "how is \\'aaca\\' a palindrome? when read backward it\\'s \\'acaa\\' so it\\'s not the same reading forward."
                    },
                    {
                        "username": "jnsudhir",
                        "content": "Check my solution, it was able to clear test case \"aaca\". Explained code in comments.\\n\\nhttps://leetcode.com/problems/longest-palindromic-substring/solutions/3091016/longest-palindromic-substring-using-javascript-beats-94-82-in-runtime-explained/?orderBy=most_votes"
                    },
                    {
                        "username": "nikhileshratna",
                        "content": "aaca is not palindrome"
                    },
                    {
                        "username": "sunshine77",
                        "content": "hey, iam getting the same error, i have seen ansewrs where they have totally changed the algorithm, how did u solve this by tweaking the same algoirhtm"
                    },
                    {
                        "username": "bhupendrabc71",
                        "content": "how come \"aaca\" is palindrome. it should be \"aca\""
                    },
                    {
                        "username": "just11blocks",
                        "content": "aaca is not a palindrome...aacaa and aca are."
                    },
                    {
                        "username": "odi1n",
                        "content": "I also encountered this problem"
                    },
                    {
                        "username": "vamsi2302",
                        "content": "I think you get it by now!\\n"
                    }
                ]
            },
            {
                "id": 1573869,
                "content": [
                    {
                        "username": "ZenMasterV",
                        "content": "Seems like too many of the  coding wunderkinds here lack basic reading comprehension skills \\n\" Please don\\'t post any solutions in this discussion tab\"\\nIt\\'s almost the rule to find the exact opposite for the discussion of every question. I don\\'t want to see your damned solution!"
                    },
                    {
                        "username": "NeroXIII",
                        "content": "[@charonme](/charonme) name does not check out :((("
                    },
                    {
                        "username": "192731",
                        "content": "and if they do?"
                    },
                    {
                        "username": "plevi1995",
                        "content": "Excellent comment"
                    },
                    {
                        "username": "khan60939",
                        "content": "Can anyone tell how DP is being used here? "
                    },
                    {
                        "username": "sandagolcea",
                        "content": "[@charonme](/charonme) my thinking exactly, but at least they should create a flag to help us moderate and move solutions to the correct tab. Would only need a stack overflow moderation-like system: one person flags, another person receives a queue of flagged comments and confirms the tagging.. oh well"
                    },
                    {
                        "username": "charonme",
                        "content": "maybe people get confused by the official leetcode comment which says: \"If you\\'d like to share a detailed solution to the problem, please create a new post in the discuss section\"\\nMaybe some time ago they didn\\'t have a separate solutions section and only recently changed it, but left some of the old solutions in the discussion section and didn\\'t fix the automated comment worting?"
                    },
                    {
                        "username": "klanjewar037",
                        "content": "hehe"
                    },
                    {
                        "username": "sanemdeepak",
                        "content": "For input \"ac\" test case is expecting \"a\" as output, how is just \"a\" a palindromic string?"
                    },
                    {
                        "username": "ayushiidevpura",
                        "content": "because when we read \"a\" from forward it results in \"a\" and at the same time when we read \"a\" from backward it is still \"a\""
                    },
                    {
                        "username": "beyzigo",
                        "content": "Because if you read the string \"a\" backwards it will still be \"a\""
                    },
                    {
                        "username": "tsafackghokeng",
                        "content": "[@Chouhan_Gourav](/Chouhan_Gourav) the test case said \"ac\" not \"a\". is \"ac\" palindromic? for \"a\" i understand"
                    },
                    {
                        "username": "CODEWITHABHINAV",
                        "content": "you have to submit the first string as your answer read more about this question on gFg\\n"
                    },
                    {
                        "username": "_BREEZE_",
                        "content": "any string is palindrome if we read it same from front and from back\\nin single character we read it same from front and back"
                    },
                    {
                        "username": "oinrup",
                        "content": "yes thats my question too"
                    },
                    {
                        "username": "yldemon",
                        "content": "Any character in the string by itself is a palindromic substring. So in the case where there is no palindromic substring with length > 1, you can return any character."
                    },
                    {
                        "username": "Chouhan_Gourav",
                        "content": "Whenever you come accross such contradiction, just google the definition, any. Any string is called is pallindromic if the reverse of the string is equal to the original string. Reverse of \\'a\\' is \\'a\\'. Hope you get this."
                    },
                    {
                        "username": "947876275",
                        "content": "This post is for learner wanna practice DP.\\nThe basic idea is, if we wanna say \"aba\" is palindromic, then we need to firstly confirm that \"b\" is palindromic, then we also need to check if \"a\"(the first a) = \"a\" (the second a).\\n\\nM is a 2-d array which stores boolean values.\\nM[i][j] indicates if string[i.....j] is palindromic.\\nSo base cases are:\\nM[i][i] is true.\\nM[i][i + 1] = (s[i] == s[i + 1]);\\nrecurrence relation is :\\nM[i][j] = (s[i] == s[j] AND M[i + 1][j - 1]);\\nFor the implementation of recurrence relation, one idea is you can loop through all possible symmetry axis. For each of the axis, you expand at both RHS and LHS simultaneously. This method promises that when you are determining value in M[i][j], M[i + 1][j - 1] must have the correct value.\\nFinal answer can be found from all M[i][j] == 1 with largest (j - i)."
                    },
                    {
                        "username": "Msey",
                        "content": "thank you, cat brother"
                    },
                    {
                        "username": "user0558y",
                        "content": "I understand the solution but I don't understand why it needs any storage at all or why it needs to be a DP solution.\n\nThe condition `(s[i] == s[j] AND M[i + 1][j - 1])` requires you to memorise if `M[i+1][j-1]` is true, that's easy to understand. However, if you expand each possible axis at the same time, i.e. 1st iteration (s[i+1], s[j-1]), 2nd iteration `s[i+2], s[j-2]`, ... It is guaranteed that M[i+1][j-1] is always true and hence can be dropped, and you should break the loop when it is not true.\n\nIn summary, you don't need to memorise anything at all and you just need to check `s[i] == s[j]` while expanding in both directions at the same time, unless I have misunderstood anything? Here is an implementation of your algorithm but without storage: https://leetcode.com/problems/longest-palindromic-substring/submissions/868540120/"
                    },
                    {
                        "username": "taras",
                        "content": "Thank you! this is a beautiful explanation, though I\\'m not sure what exactly you mean by expanding both on LHS and RHS. In my implementation it\\'s enough to compute all diagonals of  the upper right triangle of the dp matrix."
                    },
                    {
                        "username": "klu_2100031593",
                        "content": "super explanation"
                    },
                    {
                        "username": "napoleon",
                        "content": "My Solution Is Naive, It Cost O(n^2), Is there Any Solution faster?"
                    },
                    {
                        "username": "leocampos",
                        "content": "[@tylerprill-rhdc](/tylerprill-rhdc) So, what I did was:\nStated in my mind the Brute Force approach - create every possible substring and test each one to see if is a palindrome and find the longest.\n\nOf course this would be ridiculously slow, so let's improve it.\nI also mentally stated that a palindrome has a recursive aspect -> if single char, or two equal chars, or charX + palindrome + charX\nSo I created a isPalindrome recursive method that checked it delegating to itself extracting the borders.\n\nSince a palindrome must start and end with the same char, in my traverse of the string, I started storing the position of each character Map<Character, List< Integer>>, so I would just go back to the previous found Char and check if from there to the current pointer I would have a Palindrome.\n\nThen I stopped doing this for every possible palindrome, I then started doing only for the ones that COULD be longer than the already found longest palindrome. That accelerated a lot.\n\nIn the almost last step, I added memoization. Remember that a palindrome is like a sandwich, with the external chars being equal and the meat being another palindrome? So I stored the found palindromes using their start and and positions. So I could check if that had already being checked and if so, either return true or false directly.\n\nThe final step was to convert the recursive function to an iterative function to save some memory used by the call stack.\nMaybe there are better implementations, just sharing my thought process."
                    },
                    {
                        "username": "tylerprill-rhdc",
                        "content": "[@tylerprill-rhdc](/tylerprill-rhdc) Two pointer based solution is also a really good solve here"
                    },
                    {
                        "username": "tylerprill-rhdc",
                        "content": "This could be done in a single pass algorithm, but will inherently check character indices multiple times based on the nature of the problem. (basically, iterate through each, then bubble out from each index)"
                    },
                    {
                        "username": "neetika",
                        "content": "From the leetcode blog, one of the methods of solving this is:\\n\\nA common mistake:\\nSome people will be tempted to come up with a quick solution, which is unfortunately flawed (however can be corrected easily):\\n\\nReverse S and become S\\u2019. Find the longest common substring between S and S\\u2019, which must also be the longest palindromic substring.\\nThis seemed to work, let\\u2019s see some examples below.\\n\\nFor example,\\nS = \\u201ccaba\\u201d, S\\u2019 = \\u201cabac\\u201d.\\nThe longest common substring between S and S\\u2019 is \\u201caba\\u201d, which is the answer.\\n\\nLet\\u2019s try another example:\\nS = \\u201cabacdfgdcaba\\u201d, S\\u2019 = \\u201cabacdgfdcaba\\u201d.\\nThe longest common substring between S and S\\u2019 is \\u201cabacd\\u201d. Clearly, this is not a valid palindrome.\\n\\n**We could see that the longest common substring method fails when there exists a reversed copy of a non-palindromic substring in some other part of S. To rectify this, each time we find a longest common substring candidate, we check if the substring\\u2019s indices are the same as the reversed substring\\u2019s original indices. If it is, then we attempt to update the longest palindrome found so far; if not, we skip this and find the next candidate.**\\n\\nIs this part correct? \\n\\nexample string: abcxycba\\nreverse string:  abcxycba\\n\\nThe substring indices are same as reversed string original indices and yet it is not a palindrome?"
                    },
                    {
                        "username": "HRVY_SNOWDEN",
                        "content": "cool sirr:)\\n"
                    },
                    {
                        "username": "dhtmlkitchen",
                        "content": "WRONG.\\n\\nabcxycba reversed is abcyxcba."
                    },
                    {
                        "username": "travisl12",
                        "content": "After I solved this problem I thought it\\'d be interesting to see how it worked in realtime.\\n\\nhttps://codepen.io/TravisL12/pen/pogvweg"
                    },
                    {
                        "username": "user3907vj",
                        "content": "thanks for the \"nanananananana\" from all the small things ;)"
                    },
                    {
                        "username": "zapataast",
                        "content": "u are crazy"
                    },
                    {
                        "username": "sondq98",
                        "content": "very intuitive"
                    },
                    {
                        "username": "Tathagat017",
                        "content": "thank you\\n"
                    },
                    {
                        "username": "mikler",
                        "content": "So I think I finally understood logic of test creators. \\nEven if you write a classical DP or memorization solution for this one you will timeout on latest tests.\\nI think they consider it edge cases. Because if you add one simple line it will pass! OMG. \\nI have leet code for this. Instead of solving problems I spend hours optimizing the constants.\\n\\nif s == s[::-1]: return s"
                    },
                    {
                        "username": "Vectorido",
                        "content": "Don\\'t work already. Time limit at 141 test even with that construction."
                    },
                    {
                        "username": "deepalithakur17",
                        "content": "It will only work in python."
                    },
                    {
                        "username": "ishogbon",
                        "content": "Its memoization, not memorization "
                    },
                    {
                        "username": "84danie",
                        "content": "I submitted my solution, and received a Time Limit Exceeded on this test case:\\n\\n\"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaabcaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"\\n\\nSo I copied and pasted the TC into a custom test case, and started to think about what I could tweak. However, I ended up accidentally hitting Run Code, but instead of getting a Time Limit Exceeded result, it passed:\\n\\n![0_1479079812693_upload-4af9e94c-2e53-4915-acf6-782780c7bf8b](/uploads/files/1479079813717-upload-4af9e94c-2e53-4915-acf6-782780c7bf8b.png) \\n\\nIs this supposed to happen and I just need to make my code more efficient, or is this a bug? \\n![0_1479079956817_upload-1ef15826-d6e6-4bde-9c06-eb597c5c8d0e](/uploads/files/1479079957639-upload-1ef15826-d6e6-4bde-9c06-eb597c5c8d0e.png)"
                    },
                    {
                        "username": "RitikaSahay",
                        "content": "Same thing happened with me. Is there a solution for it?\\n"
                    },
                    {
                        "username": "danicruz0415",
                        "content": "It\\'s happened to me a couple of times. My theory is that the time limit is given for the whole list of test cases. Thus, you can have your test pass, but it will still time limit exceed because it wont get to calculate all the test cases before the time runs out. I cannot confirm this but I think its true because with a very unoptimized solution I got time limit exceeded very early in the test cases (for another problem), after some optimizations I got it much later (like getting to the last tests) which themselves were around the same size, so if the time limit was set per test it would not make sense to fail in a similarly long test-case just that is much later in the test list. (I think the same would apply to memory limit exceeded)"
                    },
                    {
                        "username": "him_Sarma619",
                        "content": "The exact same situation happened with me in one problem... it was a DP problem too... I was getting a Memory Limit Exceeded error with the memoized solution but it was running fine in the Run Code button."
                    },
                    {
                        "username": "Hubro",
                        "content": "I\\'m getting \"Time Limit Exceeded\" with 141/141 testcases passed and \"Last Executed Input\" is:\\n\\n```\\ns =\\n```\\n\\nDid I break it?"
                    },
                    {
                        "username": "karan_dhiman",
                        "content": "same issue"
                    },
                    {
                        "username": "BLANK-Zora",
                        "content": "exactly bro this shit is recked , like it is giving tests outside the constraints , how am i suppose to include such things in the code"
                    },
                    {
                        "username": "arunprep5",
                        "content": "same issue. java"
                    },
                    {
                        "username": "blasphelmy",
                        "content": "[@tuancoltech](/tuancoltech) it worked when i rewrote the code in c# instead of c++"
                    },
                    {
                        "username": "tuancoltech",
                        "content": "[@blasphelmy](/blasphelmy) [@Tomas Sandven](/Hubro) Did you guys find out why? I got the same issue."
                    },
                    {
                        "username": "blasphelmy",
                        "content": "i got that too. im not sure whats going on given that the constraint for input is between 1 and 1000"
                    },
                    {
                        "username": "Vinitajain",
                        "content": "Hi All,\\nI have a test case which is failing, but I feel the testcase result is incorrect.Please refer the screenshot below.\\n![image](https://assets.leetcode.com/users/images/e9e42efb-63d5-4cfa-b420-f1926674f6dc_1654838015.8394327.png)\\n\\nThe longest palindromic substring is \"aaca\" but the test case result is \"aca\". Anyone else faced this problem?"
                    },
                    {
                        "username": "OthSO",
                        "content": "[@mohdansah10](/mohdansah10) \\nthey are separated in the input with \"bd\" so it is not a valid answer "
                    },
                    {
                        "username": "mohdansah10",
                        "content": "I\\'m getting same error, but different case:\\nInput\\ns =\\n\"aacabdkacaa\"\\n\\nOutput\\n\"aacakacaa\"\\nExpected\\n\"aca\"\\n\\nBut mine is Palindrome"
                    },
                    {
                        "username": "hasmithraa",
                        "content": "the expected is correct because aaca can\\'t be a palindrome only \\'aacaa\\' can be a palindrome which is not there in your case"
                    },
                    {
                        "username": "Amish_Singh",
                        "content": "how are you considering \"aaca\" as a palindromic substring, \"aca\" is a palindrome and it is the longest"
                    },
                    {
                        "username": "Shaik_Aman_Sayer",
                        "content": "dude you really came up with the solution "
                    },
                    {
                        "username": "AryaAditya3609",
                        "content": "how is \"aaca\" and \"acaa\" same ???\\nWhile \"aca\" is palindrome because both \"aca\" and reverse of it \"aca\" is same !!"
                    },
                    {
                        "username": "alexandra-pickle",
                        "content": "\"aaca\" is not a palindrome"
                    },
                    {
                        "username": "bugHackerLoop",
                        "content": "I followed the approach leant by Aditya Verma DP lectures and encountered the same test case failing. Does the logic where I reverse the string and calculate the longest common substring doesn\\'t work here? I know it works for longest palindromic subsequence but here it fails for such test cases .. why is it so?"
                    },
                    {
                        "username": "mductran",
                        "content": "how is \\'aaca\\' a palindrome? when read backward it\\'s \\'acaa\\' so it\\'s not the same reading forward."
                    },
                    {
                        "username": "jnsudhir",
                        "content": "Check my solution, it was able to clear test case \"aaca\". Explained code in comments.\\n\\nhttps://leetcode.com/problems/longest-palindromic-substring/solutions/3091016/longest-palindromic-substring-using-javascript-beats-94-82-in-runtime-explained/?orderBy=most_votes"
                    },
                    {
                        "username": "nikhileshratna",
                        "content": "aaca is not palindrome"
                    },
                    {
                        "username": "sunshine77",
                        "content": "hey, iam getting the same error, i have seen ansewrs where they have totally changed the algorithm, how did u solve this by tweaking the same algoirhtm"
                    },
                    {
                        "username": "bhupendrabc71",
                        "content": "how come \"aaca\" is palindrome. it should be \"aca\""
                    },
                    {
                        "username": "just11blocks",
                        "content": "aaca is not a palindrome...aacaa and aca are."
                    },
                    {
                        "username": "odi1n",
                        "content": "I also encountered this problem"
                    },
                    {
                        "username": "vamsi2302",
                        "content": "I think you get it by now!\\n"
                    }
                ]
            },
            {
                "id": 1568802,
                "content": [
                    {
                        "username": "ZenMasterV",
                        "content": "Seems like too many of the  coding wunderkinds here lack basic reading comprehension skills \\n\" Please don\\'t post any solutions in this discussion tab\"\\nIt\\'s almost the rule to find the exact opposite for the discussion of every question. I don\\'t want to see your damned solution!"
                    },
                    {
                        "username": "NeroXIII",
                        "content": "[@charonme](/charonme) name does not check out :((("
                    },
                    {
                        "username": "192731",
                        "content": "and if they do?"
                    },
                    {
                        "username": "plevi1995",
                        "content": "Excellent comment"
                    },
                    {
                        "username": "khan60939",
                        "content": "Can anyone tell how DP is being used here? "
                    },
                    {
                        "username": "sandagolcea",
                        "content": "[@charonme](/charonme) my thinking exactly, but at least they should create a flag to help us moderate and move solutions to the correct tab. Would only need a stack overflow moderation-like system: one person flags, another person receives a queue of flagged comments and confirms the tagging.. oh well"
                    },
                    {
                        "username": "charonme",
                        "content": "maybe people get confused by the official leetcode comment which says: \"If you\\'d like to share a detailed solution to the problem, please create a new post in the discuss section\"\\nMaybe some time ago they didn\\'t have a separate solutions section and only recently changed it, but left some of the old solutions in the discussion section and didn\\'t fix the automated comment worting?"
                    },
                    {
                        "username": "klanjewar037",
                        "content": "hehe"
                    },
                    {
                        "username": "sanemdeepak",
                        "content": "For input \"ac\" test case is expecting \"a\" as output, how is just \"a\" a palindromic string?"
                    },
                    {
                        "username": "ayushiidevpura",
                        "content": "because when we read \"a\" from forward it results in \"a\" and at the same time when we read \"a\" from backward it is still \"a\""
                    },
                    {
                        "username": "beyzigo",
                        "content": "Because if you read the string \"a\" backwards it will still be \"a\""
                    },
                    {
                        "username": "tsafackghokeng",
                        "content": "[@Chouhan_Gourav](/Chouhan_Gourav) the test case said \"ac\" not \"a\". is \"ac\" palindromic? for \"a\" i understand"
                    },
                    {
                        "username": "CODEWITHABHINAV",
                        "content": "you have to submit the first string as your answer read more about this question on gFg\\n"
                    },
                    {
                        "username": "_BREEZE_",
                        "content": "any string is palindrome if we read it same from front and from back\\nin single character we read it same from front and back"
                    },
                    {
                        "username": "oinrup",
                        "content": "yes thats my question too"
                    },
                    {
                        "username": "yldemon",
                        "content": "Any character in the string by itself is a palindromic substring. So in the case where there is no palindromic substring with length > 1, you can return any character."
                    },
                    {
                        "username": "Chouhan_Gourav",
                        "content": "Whenever you come accross such contradiction, just google the definition, any. Any string is called is pallindromic if the reverse of the string is equal to the original string. Reverse of \\'a\\' is \\'a\\'. Hope you get this."
                    },
                    {
                        "username": "947876275",
                        "content": "This post is for learner wanna practice DP.\\nThe basic idea is, if we wanna say \"aba\" is palindromic, then we need to firstly confirm that \"b\" is palindromic, then we also need to check if \"a\"(the first a) = \"a\" (the second a).\\n\\nM is a 2-d array which stores boolean values.\\nM[i][j] indicates if string[i.....j] is palindromic.\\nSo base cases are:\\nM[i][i] is true.\\nM[i][i + 1] = (s[i] == s[i + 1]);\\nrecurrence relation is :\\nM[i][j] = (s[i] == s[j] AND M[i + 1][j - 1]);\\nFor the implementation of recurrence relation, one idea is you can loop through all possible symmetry axis. For each of the axis, you expand at both RHS and LHS simultaneously. This method promises that when you are determining value in M[i][j], M[i + 1][j - 1] must have the correct value.\\nFinal answer can be found from all M[i][j] == 1 with largest (j - i)."
                    },
                    {
                        "username": "Msey",
                        "content": "thank you, cat brother"
                    },
                    {
                        "username": "user0558y",
                        "content": "I understand the solution but I don't understand why it needs any storage at all or why it needs to be a DP solution.\n\nThe condition `(s[i] == s[j] AND M[i + 1][j - 1])` requires you to memorise if `M[i+1][j-1]` is true, that's easy to understand. However, if you expand each possible axis at the same time, i.e. 1st iteration (s[i+1], s[j-1]), 2nd iteration `s[i+2], s[j-2]`, ... It is guaranteed that M[i+1][j-1] is always true and hence can be dropped, and you should break the loop when it is not true.\n\nIn summary, you don't need to memorise anything at all and you just need to check `s[i] == s[j]` while expanding in both directions at the same time, unless I have misunderstood anything? Here is an implementation of your algorithm but without storage: https://leetcode.com/problems/longest-palindromic-substring/submissions/868540120/"
                    },
                    {
                        "username": "taras",
                        "content": "Thank you! this is a beautiful explanation, though I\\'m not sure what exactly you mean by expanding both on LHS and RHS. In my implementation it\\'s enough to compute all diagonals of  the upper right triangle of the dp matrix."
                    },
                    {
                        "username": "klu_2100031593",
                        "content": "super explanation"
                    },
                    {
                        "username": "napoleon",
                        "content": "My Solution Is Naive, It Cost O(n^2), Is there Any Solution faster?"
                    },
                    {
                        "username": "leocampos",
                        "content": "[@tylerprill-rhdc](/tylerprill-rhdc) So, what I did was:\nStated in my mind the Brute Force approach - create every possible substring and test each one to see if is a palindrome and find the longest.\n\nOf course this would be ridiculously slow, so let's improve it.\nI also mentally stated that a palindrome has a recursive aspect -> if single char, or two equal chars, or charX + palindrome + charX\nSo I created a isPalindrome recursive method that checked it delegating to itself extracting the borders.\n\nSince a palindrome must start and end with the same char, in my traverse of the string, I started storing the position of each character Map<Character, List< Integer>>, so I would just go back to the previous found Char and check if from there to the current pointer I would have a Palindrome.\n\nThen I stopped doing this for every possible palindrome, I then started doing only for the ones that COULD be longer than the already found longest palindrome. That accelerated a lot.\n\nIn the almost last step, I added memoization. Remember that a palindrome is like a sandwich, with the external chars being equal and the meat being another palindrome? So I stored the found palindromes using their start and and positions. So I could check if that had already being checked and if so, either return true or false directly.\n\nThe final step was to convert the recursive function to an iterative function to save some memory used by the call stack.\nMaybe there are better implementations, just sharing my thought process."
                    },
                    {
                        "username": "tylerprill-rhdc",
                        "content": "[@tylerprill-rhdc](/tylerprill-rhdc) Two pointer based solution is also a really good solve here"
                    },
                    {
                        "username": "tylerprill-rhdc",
                        "content": "This could be done in a single pass algorithm, but will inherently check character indices multiple times based on the nature of the problem. (basically, iterate through each, then bubble out from each index)"
                    },
                    {
                        "username": "neetika",
                        "content": "From the leetcode blog, one of the methods of solving this is:\\n\\nA common mistake:\\nSome people will be tempted to come up with a quick solution, which is unfortunately flawed (however can be corrected easily):\\n\\nReverse S and become S\\u2019. Find the longest common substring between S and S\\u2019, which must also be the longest palindromic substring.\\nThis seemed to work, let\\u2019s see some examples below.\\n\\nFor example,\\nS = \\u201ccaba\\u201d, S\\u2019 = \\u201cabac\\u201d.\\nThe longest common substring between S and S\\u2019 is \\u201caba\\u201d, which is the answer.\\n\\nLet\\u2019s try another example:\\nS = \\u201cabacdfgdcaba\\u201d, S\\u2019 = \\u201cabacdgfdcaba\\u201d.\\nThe longest common substring between S and S\\u2019 is \\u201cabacd\\u201d. Clearly, this is not a valid palindrome.\\n\\n**We could see that the longest common substring method fails when there exists a reversed copy of a non-palindromic substring in some other part of S. To rectify this, each time we find a longest common substring candidate, we check if the substring\\u2019s indices are the same as the reversed substring\\u2019s original indices. If it is, then we attempt to update the longest palindrome found so far; if not, we skip this and find the next candidate.**\\n\\nIs this part correct? \\n\\nexample string: abcxycba\\nreverse string:  abcxycba\\n\\nThe substring indices are same as reversed string original indices and yet it is not a palindrome?"
                    },
                    {
                        "username": "HRVY_SNOWDEN",
                        "content": "cool sirr:)\\n"
                    },
                    {
                        "username": "dhtmlkitchen",
                        "content": "WRONG.\\n\\nabcxycba reversed is abcyxcba."
                    },
                    {
                        "username": "travisl12",
                        "content": "After I solved this problem I thought it\\'d be interesting to see how it worked in realtime.\\n\\nhttps://codepen.io/TravisL12/pen/pogvweg"
                    },
                    {
                        "username": "user3907vj",
                        "content": "thanks for the \"nanananananana\" from all the small things ;)"
                    },
                    {
                        "username": "zapataast",
                        "content": "u are crazy"
                    },
                    {
                        "username": "sondq98",
                        "content": "very intuitive"
                    },
                    {
                        "username": "Tathagat017",
                        "content": "thank you\\n"
                    },
                    {
                        "username": "mikler",
                        "content": "So I think I finally understood logic of test creators. \\nEven if you write a classical DP or memorization solution for this one you will timeout on latest tests.\\nI think they consider it edge cases. Because if you add one simple line it will pass! OMG. \\nI have leet code for this. Instead of solving problems I spend hours optimizing the constants.\\n\\nif s == s[::-1]: return s"
                    },
                    {
                        "username": "Vectorido",
                        "content": "Don\\'t work already. Time limit at 141 test even with that construction."
                    },
                    {
                        "username": "deepalithakur17",
                        "content": "It will only work in python."
                    },
                    {
                        "username": "ishogbon",
                        "content": "Its memoization, not memorization "
                    },
                    {
                        "username": "84danie",
                        "content": "I submitted my solution, and received a Time Limit Exceeded on this test case:\\n\\n\"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaabcaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"\\n\\nSo I copied and pasted the TC into a custom test case, and started to think about what I could tweak. However, I ended up accidentally hitting Run Code, but instead of getting a Time Limit Exceeded result, it passed:\\n\\n![0_1479079812693_upload-4af9e94c-2e53-4915-acf6-782780c7bf8b](/uploads/files/1479079813717-upload-4af9e94c-2e53-4915-acf6-782780c7bf8b.png) \\n\\nIs this supposed to happen and I just need to make my code more efficient, or is this a bug? \\n![0_1479079956817_upload-1ef15826-d6e6-4bde-9c06-eb597c5c8d0e](/uploads/files/1479079957639-upload-1ef15826-d6e6-4bde-9c06-eb597c5c8d0e.png)"
                    },
                    {
                        "username": "RitikaSahay",
                        "content": "Same thing happened with me. Is there a solution for it?\\n"
                    },
                    {
                        "username": "danicruz0415",
                        "content": "It\\'s happened to me a couple of times. My theory is that the time limit is given for the whole list of test cases. Thus, you can have your test pass, but it will still time limit exceed because it wont get to calculate all the test cases before the time runs out. I cannot confirm this but I think its true because with a very unoptimized solution I got time limit exceeded very early in the test cases (for another problem), after some optimizations I got it much later (like getting to the last tests) which themselves were around the same size, so if the time limit was set per test it would not make sense to fail in a similarly long test-case just that is much later in the test list. (I think the same would apply to memory limit exceeded)"
                    },
                    {
                        "username": "him_Sarma619",
                        "content": "The exact same situation happened with me in one problem... it was a DP problem too... I was getting a Memory Limit Exceeded error with the memoized solution but it was running fine in the Run Code button."
                    },
                    {
                        "username": "Hubro",
                        "content": "I\\'m getting \"Time Limit Exceeded\" with 141/141 testcases passed and \"Last Executed Input\" is:\\n\\n```\\ns =\\n```\\n\\nDid I break it?"
                    },
                    {
                        "username": "karan_dhiman",
                        "content": "same issue"
                    },
                    {
                        "username": "BLANK-Zora",
                        "content": "exactly bro this shit is recked , like it is giving tests outside the constraints , how am i suppose to include such things in the code"
                    },
                    {
                        "username": "arunprep5",
                        "content": "same issue. java"
                    },
                    {
                        "username": "blasphelmy",
                        "content": "[@tuancoltech](/tuancoltech) it worked when i rewrote the code in c# instead of c++"
                    },
                    {
                        "username": "tuancoltech",
                        "content": "[@blasphelmy](/blasphelmy) [@Tomas Sandven](/Hubro) Did you guys find out why? I got the same issue."
                    },
                    {
                        "username": "blasphelmy",
                        "content": "i got that too. im not sure whats going on given that the constraint for input is between 1 and 1000"
                    },
                    {
                        "username": "Vinitajain",
                        "content": "Hi All,\\nI have a test case which is failing, but I feel the testcase result is incorrect.Please refer the screenshot below.\\n![image](https://assets.leetcode.com/users/images/e9e42efb-63d5-4cfa-b420-f1926674f6dc_1654838015.8394327.png)\\n\\nThe longest palindromic substring is \"aaca\" but the test case result is \"aca\". Anyone else faced this problem?"
                    },
                    {
                        "username": "OthSO",
                        "content": "[@mohdansah10](/mohdansah10) \\nthey are separated in the input with \"bd\" so it is not a valid answer "
                    },
                    {
                        "username": "mohdansah10",
                        "content": "I\\'m getting same error, but different case:\\nInput\\ns =\\n\"aacabdkacaa\"\\n\\nOutput\\n\"aacakacaa\"\\nExpected\\n\"aca\"\\n\\nBut mine is Palindrome"
                    },
                    {
                        "username": "hasmithraa",
                        "content": "the expected is correct because aaca can\\'t be a palindrome only \\'aacaa\\' can be a palindrome which is not there in your case"
                    },
                    {
                        "username": "Amish_Singh",
                        "content": "how are you considering \"aaca\" as a palindromic substring, \"aca\" is a palindrome and it is the longest"
                    },
                    {
                        "username": "Shaik_Aman_Sayer",
                        "content": "dude you really came up with the solution "
                    },
                    {
                        "username": "AryaAditya3609",
                        "content": "how is \"aaca\" and \"acaa\" same ???\\nWhile \"aca\" is palindrome because both \"aca\" and reverse of it \"aca\" is same !!"
                    },
                    {
                        "username": "alexandra-pickle",
                        "content": "\"aaca\" is not a palindrome"
                    },
                    {
                        "username": "bugHackerLoop",
                        "content": "I followed the approach leant by Aditya Verma DP lectures and encountered the same test case failing. Does the logic where I reverse the string and calculate the longest common substring doesn\\'t work here? I know it works for longest palindromic subsequence but here it fails for such test cases .. why is it so?"
                    },
                    {
                        "username": "mductran",
                        "content": "how is \\'aaca\\' a palindrome? when read backward it\\'s \\'acaa\\' so it\\'s not the same reading forward."
                    },
                    {
                        "username": "jnsudhir",
                        "content": "Check my solution, it was able to clear test case \"aaca\". Explained code in comments.\\n\\nhttps://leetcode.com/problems/longest-palindromic-substring/solutions/3091016/longest-palindromic-substring-using-javascript-beats-94-82-in-runtime-explained/?orderBy=most_votes"
                    },
                    {
                        "username": "nikhileshratna",
                        "content": "aaca is not palindrome"
                    },
                    {
                        "username": "sunshine77",
                        "content": "hey, iam getting the same error, i have seen ansewrs where they have totally changed the algorithm, how did u solve this by tweaking the same algoirhtm"
                    },
                    {
                        "username": "bhupendrabc71",
                        "content": "how come \"aaca\" is palindrome. it should be \"aca\""
                    },
                    {
                        "username": "just11blocks",
                        "content": "aaca is not a palindrome...aacaa and aca are."
                    },
                    {
                        "username": "odi1n",
                        "content": "I also encountered this problem"
                    },
                    {
                        "username": "vamsi2302",
                        "content": "I think you get it by now!\\n"
                    }
                ]
            },
            {
                "id": 1570975,
                "content": [
                    {
                        "username": "ZenMasterV",
                        "content": "Seems like too many of the  coding wunderkinds here lack basic reading comprehension skills \\n\" Please don\\'t post any solutions in this discussion tab\"\\nIt\\'s almost the rule to find the exact opposite for the discussion of every question. I don\\'t want to see your damned solution!"
                    },
                    {
                        "username": "NeroXIII",
                        "content": "[@charonme](/charonme) name does not check out :((("
                    },
                    {
                        "username": "192731",
                        "content": "and if they do?"
                    },
                    {
                        "username": "plevi1995",
                        "content": "Excellent comment"
                    },
                    {
                        "username": "khan60939",
                        "content": "Can anyone tell how DP is being used here? "
                    },
                    {
                        "username": "sandagolcea",
                        "content": "[@charonme](/charonme) my thinking exactly, but at least they should create a flag to help us moderate and move solutions to the correct tab. Would only need a stack overflow moderation-like system: one person flags, another person receives a queue of flagged comments and confirms the tagging.. oh well"
                    },
                    {
                        "username": "charonme",
                        "content": "maybe people get confused by the official leetcode comment which says: \"If you\\'d like to share a detailed solution to the problem, please create a new post in the discuss section\"\\nMaybe some time ago they didn\\'t have a separate solutions section and only recently changed it, but left some of the old solutions in the discussion section and didn\\'t fix the automated comment worting?"
                    },
                    {
                        "username": "klanjewar037",
                        "content": "hehe"
                    },
                    {
                        "username": "sanemdeepak",
                        "content": "For input \"ac\" test case is expecting \"a\" as output, how is just \"a\" a palindromic string?"
                    },
                    {
                        "username": "ayushiidevpura",
                        "content": "because when we read \"a\" from forward it results in \"a\" and at the same time when we read \"a\" from backward it is still \"a\""
                    },
                    {
                        "username": "beyzigo",
                        "content": "Because if you read the string \"a\" backwards it will still be \"a\""
                    },
                    {
                        "username": "tsafackghokeng",
                        "content": "[@Chouhan_Gourav](/Chouhan_Gourav) the test case said \"ac\" not \"a\". is \"ac\" palindromic? for \"a\" i understand"
                    },
                    {
                        "username": "CODEWITHABHINAV",
                        "content": "you have to submit the first string as your answer read more about this question on gFg\\n"
                    },
                    {
                        "username": "_BREEZE_",
                        "content": "any string is palindrome if we read it same from front and from back\\nin single character we read it same from front and back"
                    },
                    {
                        "username": "oinrup",
                        "content": "yes thats my question too"
                    },
                    {
                        "username": "yldemon",
                        "content": "Any character in the string by itself is a palindromic substring. So in the case where there is no palindromic substring with length > 1, you can return any character."
                    },
                    {
                        "username": "Chouhan_Gourav",
                        "content": "Whenever you come accross such contradiction, just google the definition, any. Any string is called is pallindromic if the reverse of the string is equal to the original string. Reverse of \\'a\\' is \\'a\\'. Hope you get this."
                    },
                    {
                        "username": "947876275",
                        "content": "This post is for learner wanna practice DP.\\nThe basic idea is, if we wanna say \"aba\" is palindromic, then we need to firstly confirm that \"b\" is palindromic, then we also need to check if \"a\"(the first a) = \"a\" (the second a).\\n\\nM is a 2-d array which stores boolean values.\\nM[i][j] indicates if string[i.....j] is palindromic.\\nSo base cases are:\\nM[i][i] is true.\\nM[i][i + 1] = (s[i] == s[i + 1]);\\nrecurrence relation is :\\nM[i][j] = (s[i] == s[j] AND M[i + 1][j - 1]);\\nFor the implementation of recurrence relation, one idea is you can loop through all possible symmetry axis. For each of the axis, you expand at both RHS and LHS simultaneously. This method promises that when you are determining value in M[i][j], M[i + 1][j - 1] must have the correct value.\\nFinal answer can be found from all M[i][j] == 1 with largest (j - i)."
                    },
                    {
                        "username": "Msey",
                        "content": "thank you, cat brother"
                    },
                    {
                        "username": "user0558y",
                        "content": "I understand the solution but I don't understand why it needs any storage at all or why it needs to be a DP solution.\n\nThe condition `(s[i] == s[j] AND M[i + 1][j - 1])` requires you to memorise if `M[i+1][j-1]` is true, that's easy to understand. However, if you expand each possible axis at the same time, i.e. 1st iteration (s[i+1], s[j-1]), 2nd iteration `s[i+2], s[j-2]`, ... It is guaranteed that M[i+1][j-1] is always true and hence can be dropped, and you should break the loop when it is not true.\n\nIn summary, you don't need to memorise anything at all and you just need to check `s[i] == s[j]` while expanding in both directions at the same time, unless I have misunderstood anything? Here is an implementation of your algorithm but without storage: https://leetcode.com/problems/longest-palindromic-substring/submissions/868540120/"
                    },
                    {
                        "username": "taras",
                        "content": "Thank you! this is a beautiful explanation, though I\\'m not sure what exactly you mean by expanding both on LHS and RHS. In my implementation it\\'s enough to compute all diagonals of  the upper right triangle of the dp matrix."
                    },
                    {
                        "username": "klu_2100031593",
                        "content": "super explanation"
                    },
                    {
                        "username": "napoleon",
                        "content": "My Solution Is Naive, It Cost O(n^2), Is there Any Solution faster?"
                    },
                    {
                        "username": "leocampos",
                        "content": "[@tylerprill-rhdc](/tylerprill-rhdc) So, what I did was:\nStated in my mind the Brute Force approach - create every possible substring and test each one to see if is a palindrome and find the longest.\n\nOf course this would be ridiculously slow, so let's improve it.\nI also mentally stated that a palindrome has a recursive aspect -> if single char, or two equal chars, or charX + palindrome + charX\nSo I created a isPalindrome recursive method that checked it delegating to itself extracting the borders.\n\nSince a palindrome must start and end with the same char, in my traverse of the string, I started storing the position of each character Map<Character, List< Integer>>, so I would just go back to the previous found Char and check if from there to the current pointer I would have a Palindrome.\n\nThen I stopped doing this for every possible palindrome, I then started doing only for the ones that COULD be longer than the already found longest palindrome. That accelerated a lot.\n\nIn the almost last step, I added memoization. Remember that a palindrome is like a sandwich, with the external chars being equal and the meat being another palindrome? So I stored the found palindromes using their start and and positions. So I could check if that had already being checked and if so, either return true or false directly.\n\nThe final step was to convert the recursive function to an iterative function to save some memory used by the call stack.\nMaybe there are better implementations, just sharing my thought process."
                    },
                    {
                        "username": "tylerprill-rhdc",
                        "content": "[@tylerprill-rhdc](/tylerprill-rhdc) Two pointer based solution is also a really good solve here"
                    },
                    {
                        "username": "tylerprill-rhdc",
                        "content": "This could be done in a single pass algorithm, but will inherently check character indices multiple times based on the nature of the problem. (basically, iterate through each, then bubble out from each index)"
                    },
                    {
                        "username": "neetika",
                        "content": "From the leetcode blog, one of the methods of solving this is:\\n\\nA common mistake:\\nSome people will be tempted to come up with a quick solution, which is unfortunately flawed (however can be corrected easily):\\n\\nReverse S and become S\\u2019. Find the longest common substring between S and S\\u2019, which must also be the longest palindromic substring.\\nThis seemed to work, let\\u2019s see some examples below.\\n\\nFor example,\\nS = \\u201ccaba\\u201d, S\\u2019 = \\u201cabac\\u201d.\\nThe longest common substring between S and S\\u2019 is \\u201caba\\u201d, which is the answer.\\n\\nLet\\u2019s try another example:\\nS = \\u201cabacdfgdcaba\\u201d, S\\u2019 = \\u201cabacdgfdcaba\\u201d.\\nThe longest common substring between S and S\\u2019 is \\u201cabacd\\u201d. Clearly, this is not a valid palindrome.\\n\\n**We could see that the longest common substring method fails when there exists a reversed copy of a non-palindromic substring in some other part of S. To rectify this, each time we find a longest common substring candidate, we check if the substring\\u2019s indices are the same as the reversed substring\\u2019s original indices. If it is, then we attempt to update the longest palindrome found so far; if not, we skip this and find the next candidate.**\\n\\nIs this part correct? \\n\\nexample string: abcxycba\\nreverse string:  abcxycba\\n\\nThe substring indices are same as reversed string original indices and yet it is not a palindrome?"
                    },
                    {
                        "username": "HRVY_SNOWDEN",
                        "content": "cool sirr:)\\n"
                    },
                    {
                        "username": "dhtmlkitchen",
                        "content": "WRONG.\\n\\nabcxycba reversed is abcyxcba."
                    },
                    {
                        "username": "travisl12",
                        "content": "After I solved this problem I thought it\\'d be interesting to see how it worked in realtime.\\n\\nhttps://codepen.io/TravisL12/pen/pogvweg"
                    },
                    {
                        "username": "user3907vj",
                        "content": "thanks for the \"nanananananana\" from all the small things ;)"
                    },
                    {
                        "username": "zapataast",
                        "content": "u are crazy"
                    },
                    {
                        "username": "sondq98",
                        "content": "very intuitive"
                    },
                    {
                        "username": "Tathagat017",
                        "content": "thank you\\n"
                    },
                    {
                        "username": "mikler",
                        "content": "So I think I finally understood logic of test creators. \\nEven if you write a classical DP or memorization solution for this one you will timeout on latest tests.\\nI think they consider it edge cases. Because if you add one simple line it will pass! OMG. \\nI have leet code for this. Instead of solving problems I spend hours optimizing the constants.\\n\\nif s == s[::-1]: return s"
                    },
                    {
                        "username": "Vectorido",
                        "content": "Don\\'t work already. Time limit at 141 test even with that construction."
                    },
                    {
                        "username": "deepalithakur17",
                        "content": "It will only work in python."
                    },
                    {
                        "username": "ishogbon",
                        "content": "Its memoization, not memorization "
                    },
                    {
                        "username": "84danie",
                        "content": "I submitted my solution, and received a Time Limit Exceeded on this test case:\\n\\n\"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaabcaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"\\n\\nSo I copied and pasted the TC into a custom test case, and started to think about what I could tweak. However, I ended up accidentally hitting Run Code, but instead of getting a Time Limit Exceeded result, it passed:\\n\\n![0_1479079812693_upload-4af9e94c-2e53-4915-acf6-782780c7bf8b](/uploads/files/1479079813717-upload-4af9e94c-2e53-4915-acf6-782780c7bf8b.png) \\n\\nIs this supposed to happen and I just need to make my code more efficient, or is this a bug? \\n![0_1479079956817_upload-1ef15826-d6e6-4bde-9c06-eb597c5c8d0e](/uploads/files/1479079957639-upload-1ef15826-d6e6-4bde-9c06-eb597c5c8d0e.png)"
                    },
                    {
                        "username": "RitikaSahay",
                        "content": "Same thing happened with me. Is there a solution for it?\\n"
                    },
                    {
                        "username": "danicruz0415",
                        "content": "It\\'s happened to me a couple of times. My theory is that the time limit is given for the whole list of test cases. Thus, you can have your test pass, but it will still time limit exceed because it wont get to calculate all the test cases before the time runs out. I cannot confirm this but I think its true because with a very unoptimized solution I got time limit exceeded very early in the test cases (for another problem), after some optimizations I got it much later (like getting to the last tests) which themselves were around the same size, so if the time limit was set per test it would not make sense to fail in a similarly long test-case just that is much later in the test list. (I think the same would apply to memory limit exceeded)"
                    },
                    {
                        "username": "him_Sarma619",
                        "content": "The exact same situation happened with me in one problem... it was a DP problem too... I was getting a Memory Limit Exceeded error with the memoized solution but it was running fine in the Run Code button."
                    },
                    {
                        "username": "Hubro",
                        "content": "I\\'m getting \"Time Limit Exceeded\" with 141/141 testcases passed and \"Last Executed Input\" is:\\n\\n```\\ns =\\n```\\n\\nDid I break it?"
                    },
                    {
                        "username": "karan_dhiman",
                        "content": "same issue"
                    },
                    {
                        "username": "BLANK-Zora",
                        "content": "exactly bro this shit is recked , like it is giving tests outside the constraints , how am i suppose to include such things in the code"
                    },
                    {
                        "username": "arunprep5",
                        "content": "same issue. java"
                    },
                    {
                        "username": "blasphelmy",
                        "content": "[@tuancoltech](/tuancoltech) it worked when i rewrote the code in c# instead of c++"
                    },
                    {
                        "username": "tuancoltech",
                        "content": "[@blasphelmy](/blasphelmy) [@Tomas Sandven](/Hubro) Did you guys find out why? I got the same issue."
                    },
                    {
                        "username": "blasphelmy",
                        "content": "i got that too. im not sure whats going on given that the constraint for input is between 1 and 1000"
                    },
                    {
                        "username": "Vinitajain",
                        "content": "Hi All,\\nI have a test case which is failing, but I feel the testcase result is incorrect.Please refer the screenshot below.\\n![image](https://assets.leetcode.com/users/images/e9e42efb-63d5-4cfa-b420-f1926674f6dc_1654838015.8394327.png)\\n\\nThe longest palindromic substring is \"aaca\" but the test case result is \"aca\". Anyone else faced this problem?"
                    },
                    {
                        "username": "OthSO",
                        "content": "[@mohdansah10](/mohdansah10) \\nthey are separated in the input with \"bd\" so it is not a valid answer "
                    },
                    {
                        "username": "mohdansah10",
                        "content": "I\\'m getting same error, but different case:\\nInput\\ns =\\n\"aacabdkacaa\"\\n\\nOutput\\n\"aacakacaa\"\\nExpected\\n\"aca\"\\n\\nBut mine is Palindrome"
                    },
                    {
                        "username": "hasmithraa",
                        "content": "the expected is correct because aaca can\\'t be a palindrome only \\'aacaa\\' can be a palindrome which is not there in your case"
                    },
                    {
                        "username": "Amish_Singh",
                        "content": "how are you considering \"aaca\" as a palindromic substring, \"aca\" is a palindrome and it is the longest"
                    },
                    {
                        "username": "Shaik_Aman_Sayer",
                        "content": "dude you really came up with the solution "
                    },
                    {
                        "username": "AryaAditya3609",
                        "content": "how is \"aaca\" and \"acaa\" same ???\\nWhile \"aca\" is palindrome because both \"aca\" and reverse of it \"aca\" is same !!"
                    },
                    {
                        "username": "alexandra-pickle",
                        "content": "\"aaca\" is not a palindrome"
                    },
                    {
                        "username": "bugHackerLoop",
                        "content": "I followed the approach leant by Aditya Verma DP lectures and encountered the same test case failing. Does the logic where I reverse the string and calculate the longest common substring doesn\\'t work here? I know it works for longest palindromic subsequence but here it fails for such test cases .. why is it so?"
                    },
                    {
                        "username": "mductran",
                        "content": "how is \\'aaca\\' a palindrome? when read backward it\\'s \\'acaa\\' so it\\'s not the same reading forward."
                    },
                    {
                        "username": "jnsudhir",
                        "content": "Check my solution, it was able to clear test case \"aaca\". Explained code in comments.\\n\\nhttps://leetcode.com/problems/longest-palindromic-substring/solutions/3091016/longest-palindromic-substring-using-javascript-beats-94-82-in-runtime-explained/?orderBy=most_votes"
                    },
                    {
                        "username": "nikhileshratna",
                        "content": "aaca is not palindrome"
                    },
                    {
                        "username": "sunshine77",
                        "content": "hey, iam getting the same error, i have seen ansewrs where they have totally changed the algorithm, how did u solve this by tweaking the same algoirhtm"
                    },
                    {
                        "username": "bhupendrabc71",
                        "content": "how come \"aaca\" is palindrome. it should be \"aca\""
                    },
                    {
                        "username": "just11blocks",
                        "content": "aaca is not a palindrome...aacaa and aca are."
                    },
                    {
                        "username": "odi1n",
                        "content": "I also encountered this problem"
                    },
                    {
                        "username": "vamsi2302",
                        "content": "I think you get it by now!\\n"
                    }
                ]
            },
            {
                "id": 1873701,
                "content": [
                    {
                        "username": "ZenMasterV",
                        "content": "Seems like too many of the  coding wunderkinds here lack basic reading comprehension skills \\n\" Please don\\'t post any solutions in this discussion tab\"\\nIt\\'s almost the rule to find the exact opposite for the discussion of every question. I don\\'t want to see your damned solution!"
                    },
                    {
                        "username": "NeroXIII",
                        "content": "[@charonme](/charonme) name does not check out :((("
                    },
                    {
                        "username": "192731",
                        "content": "and if they do?"
                    },
                    {
                        "username": "plevi1995",
                        "content": "Excellent comment"
                    },
                    {
                        "username": "khan60939",
                        "content": "Can anyone tell how DP is being used here? "
                    },
                    {
                        "username": "sandagolcea",
                        "content": "[@charonme](/charonme) my thinking exactly, but at least they should create a flag to help us moderate and move solutions to the correct tab. Would only need a stack overflow moderation-like system: one person flags, another person receives a queue of flagged comments and confirms the tagging.. oh well"
                    },
                    {
                        "username": "charonme",
                        "content": "maybe people get confused by the official leetcode comment which says: \"If you\\'d like to share a detailed solution to the problem, please create a new post in the discuss section\"\\nMaybe some time ago they didn\\'t have a separate solutions section and only recently changed it, but left some of the old solutions in the discussion section and didn\\'t fix the automated comment worting?"
                    },
                    {
                        "username": "klanjewar037",
                        "content": "hehe"
                    },
                    {
                        "username": "sanemdeepak",
                        "content": "For input \"ac\" test case is expecting \"a\" as output, how is just \"a\" a palindromic string?"
                    },
                    {
                        "username": "ayushiidevpura",
                        "content": "because when we read \"a\" from forward it results in \"a\" and at the same time when we read \"a\" from backward it is still \"a\""
                    },
                    {
                        "username": "beyzigo",
                        "content": "Because if you read the string \"a\" backwards it will still be \"a\""
                    },
                    {
                        "username": "tsafackghokeng",
                        "content": "[@Chouhan_Gourav](/Chouhan_Gourav) the test case said \"ac\" not \"a\". is \"ac\" palindromic? for \"a\" i understand"
                    },
                    {
                        "username": "CODEWITHABHINAV",
                        "content": "you have to submit the first string as your answer read more about this question on gFg\\n"
                    },
                    {
                        "username": "_BREEZE_",
                        "content": "any string is palindrome if we read it same from front and from back\\nin single character we read it same from front and back"
                    },
                    {
                        "username": "oinrup",
                        "content": "yes thats my question too"
                    },
                    {
                        "username": "yldemon",
                        "content": "Any character in the string by itself is a palindromic substring. So in the case where there is no palindromic substring with length > 1, you can return any character."
                    },
                    {
                        "username": "Chouhan_Gourav",
                        "content": "Whenever you come accross such contradiction, just google the definition, any. Any string is called is pallindromic if the reverse of the string is equal to the original string. Reverse of \\'a\\' is \\'a\\'. Hope you get this."
                    },
                    {
                        "username": "947876275",
                        "content": "This post is for learner wanna practice DP.\\nThe basic idea is, if we wanna say \"aba\" is palindromic, then we need to firstly confirm that \"b\" is palindromic, then we also need to check if \"a\"(the first a) = \"a\" (the second a).\\n\\nM is a 2-d array which stores boolean values.\\nM[i][j] indicates if string[i.....j] is palindromic.\\nSo base cases are:\\nM[i][i] is true.\\nM[i][i + 1] = (s[i] == s[i + 1]);\\nrecurrence relation is :\\nM[i][j] = (s[i] == s[j] AND M[i + 1][j - 1]);\\nFor the implementation of recurrence relation, one idea is you can loop through all possible symmetry axis. For each of the axis, you expand at both RHS and LHS simultaneously. This method promises that when you are determining value in M[i][j], M[i + 1][j - 1] must have the correct value.\\nFinal answer can be found from all M[i][j] == 1 with largest (j - i)."
                    },
                    {
                        "username": "Msey",
                        "content": "thank you, cat brother"
                    },
                    {
                        "username": "user0558y",
                        "content": "I understand the solution but I don't understand why it needs any storage at all or why it needs to be a DP solution.\n\nThe condition `(s[i] == s[j] AND M[i + 1][j - 1])` requires you to memorise if `M[i+1][j-1]` is true, that's easy to understand. However, if you expand each possible axis at the same time, i.e. 1st iteration (s[i+1], s[j-1]), 2nd iteration `s[i+2], s[j-2]`, ... It is guaranteed that M[i+1][j-1] is always true and hence can be dropped, and you should break the loop when it is not true.\n\nIn summary, you don't need to memorise anything at all and you just need to check `s[i] == s[j]` while expanding in both directions at the same time, unless I have misunderstood anything? Here is an implementation of your algorithm but without storage: https://leetcode.com/problems/longest-palindromic-substring/submissions/868540120/"
                    },
                    {
                        "username": "taras",
                        "content": "Thank you! this is a beautiful explanation, though I\\'m not sure what exactly you mean by expanding both on LHS and RHS. In my implementation it\\'s enough to compute all diagonals of  the upper right triangle of the dp matrix."
                    },
                    {
                        "username": "klu_2100031593",
                        "content": "super explanation"
                    },
                    {
                        "username": "napoleon",
                        "content": "My Solution Is Naive, It Cost O(n^2), Is there Any Solution faster?"
                    },
                    {
                        "username": "leocampos",
                        "content": "[@tylerprill-rhdc](/tylerprill-rhdc) So, what I did was:\nStated in my mind the Brute Force approach - create every possible substring and test each one to see if is a palindrome and find the longest.\n\nOf course this would be ridiculously slow, so let's improve it.\nI also mentally stated that a palindrome has a recursive aspect -> if single char, or two equal chars, or charX + palindrome + charX\nSo I created a isPalindrome recursive method that checked it delegating to itself extracting the borders.\n\nSince a palindrome must start and end with the same char, in my traverse of the string, I started storing the position of each character Map<Character, List< Integer>>, so I would just go back to the previous found Char and check if from there to the current pointer I would have a Palindrome.\n\nThen I stopped doing this for every possible palindrome, I then started doing only for the ones that COULD be longer than the already found longest palindrome. That accelerated a lot.\n\nIn the almost last step, I added memoization. Remember that a palindrome is like a sandwich, with the external chars being equal and the meat being another palindrome? So I stored the found palindromes using their start and and positions. So I could check if that had already being checked and if so, either return true or false directly.\n\nThe final step was to convert the recursive function to an iterative function to save some memory used by the call stack.\nMaybe there are better implementations, just sharing my thought process."
                    },
                    {
                        "username": "tylerprill-rhdc",
                        "content": "[@tylerprill-rhdc](/tylerprill-rhdc) Two pointer based solution is also a really good solve here"
                    },
                    {
                        "username": "tylerprill-rhdc",
                        "content": "This could be done in a single pass algorithm, but will inherently check character indices multiple times based on the nature of the problem. (basically, iterate through each, then bubble out from each index)"
                    },
                    {
                        "username": "neetika",
                        "content": "From the leetcode blog, one of the methods of solving this is:\\n\\nA common mistake:\\nSome people will be tempted to come up with a quick solution, which is unfortunately flawed (however can be corrected easily):\\n\\nReverse S and become S\\u2019. Find the longest common substring between S and S\\u2019, which must also be the longest palindromic substring.\\nThis seemed to work, let\\u2019s see some examples below.\\n\\nFor example,\\nS = \\u201ccaba\\u201d, S\\u2019 = \\u201cabac\\u201d.\\nThe longest common substring between S and S\\u2019 is \\u201caba\\u201d, which is the answer.\\n\\nLet\\u2019s try another example:\\nS = \\u201cabacdfgdcaba\\u201d, S\\u2019 = \\u201cabacdgfdcaba\\u201d.\\nThe longest common substring between S and S\\u2019 is \\u201cabacd\\u201d. Clearly, this is not a valid palindrome.\\n\\n**We could see that the longest common substring method fails when there exists a reversed copy of a non-palindromic substring in some other part of S. To rectify this, each time we find a longest common substring candidate, we check if the substring\\u2019s indices are the same as the reversed substring\\u2019s original indices. If it is, then we attempt to update the longest palindrome found so far; if not, we skip this and find the next candidate.**\\n\\nIs this part correct? \\n\\nexample string: abcxycba\\nreverse string:  abcxycba\\n\\nThe substring indices are same as reversed string original indices and yet it is not a palindrome?"
                    },
                    {
                        "username": "HRVY_SNOWDEN",
                        "content": "cool sirr:)\\n"
                    },
                    {
                        "username": "dhtmlkitchen",
                        "content": "WRONG.\\n\\nabcxycba reversed is abcyxcba."
                    },
                    {
                        "username": "travisl12",
                        "content": "After I solved this problem I thought it\\'d be interesting to see how it worked in realtime.\\n\\nhttps://codepen.io/TravisL12/pen/pogvweg"
                    },
                    {
                        "username": "user3907vj",
                        "content": "thanks for the \"nanananananana\" from all the small things ;)"
                    },
                    {
                        "username": "zapataast",
                        "content": "u are crazy"
                    },
                    {
                        "username": "sondq98",
                        "content": "very intuitive"
                    },
                    {
                        "username": "Tathagat017",
                        "content": "thank you\\n"
                    },
                    {
                        "username": "mikler",
                        "content": "So I think I finally understood logic of test creators. \\nEven if you write a classical DP or memorization solution for this one you will timeout on latest tests.\\nI think they consider it edge cases. Because if you add one simple line it will pass! OMG. \\nI have leet code for this. Instead of solving problems I spend hours optimizing the constants.\\n\\nif s == s[::-1]: return s"
                    },
                    {
                        "username": "Vectorido",
                        "content": "Don\\'t work already. Time limit at 141 test even with that construction."
                    },
                    {
                        "username": "deepalithakur17",
                        "content": "It will only work in python."
                    },
                    {
                        "username": "ishogbon",
                        "content": "Its memoization, not memorization "
                    },
                    {
                        "username": "84danie",
                        "content": "I submitted my solution, and received a Time Limit Exceeded on this test case:\\n\\n\"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaabcaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"\\n\\nSo I copied and pasted the TC into a custom test case, and started to think about what I could tweak. However, I ended up accidentally hitting Run Code, but instead of getting a Time Limit Exceeded result, it passed:\\n\\n![0_1479079812693_upload-4af9e94c-2e53-4915-acf6-782780c7bf8b](/uploads/files/1479079813717-upload-4af9e94c-2e53-4915-acf6-782780c7bf8b.png) \\n\\nIs this supposed to happen and I just need to make my code more efficient, or is this a bug? \\n![0_1479079956817_upload-1ef15826-d6e6-4bde-9c06-eb597c5c8d0e](/uploads/files/1479079957639-upload-1ef15826-d6e6-4bde-9c06-eb597c5c8d0e.png)"
                    },
                    {
                        "username": "RitikaSahay",
                        "content": "Same thing happened with me. Is there a solution for it?\\n"
                    },
                    {
                        "username": "danicruz0415",
                        "content": "It\\'s happened to me a couple of times. My theory is that the time limit is given for the whole list of test cases. Thus, you can have your test pass, but it will still time limit exceed because it wont get to calculate all the test cases before the time runs out. I cannot confirm this but I think its true because with a very unoptimized solution I got time limit exceeded very early in the test cases (for another problem), after some optimizations I got it much later (like getting to the last tests) which themselves were around the same size, so if the time limit was set per test it would not make sense to fail in a similarly long test-case just that is much later in the test list. (I think the same would apply to memory limit exceeded)"
                    },
                    {
                        "username": "him_Sarma619",
                        "content": "The exact same situation happened with me in one problem... it was a DP problem too... I was getting a Memory Limit Exceeded error with the memoized solution but it was running fine in the Run Code button."
                    },
                    {
                        "username": "Hubro",
                        "content": "I\\'m getting \"Time Limit Exceeded\" with 141/141 testcases passed and \"Last Executed Input\" is:\\n\\n```\\ns =\\n```\\n\\nDid I break it?"
                    },
                    {
                        "username": "karan_dhiman",
                        "content": "same issue"
                    },
                    {
                        "username": "BLANK-Zora",
                        "content": "exactly bro this shit is recked , like it is giving tests outside the constraints , how am i suppose to include such things in the code"
                    },
                    {
                        "username": "arunprep5",
                        "content": "same issue. java"
                    },
                    {
                        "username": "blasphelmy",
                        "content": "[@tuancoltech](/tuancoltech) it worked when i rewrote the code in c# instead of c++"
                    },
                    {
                        "username": "tuancoltech",
                        "content": "[@blasphelmy](/blasphelmy) [@Tomas Sandven](/Hubro) Did you guys find out why? I got the same issue."
                    },
                    {
                        "username": "blasphelmy",
                        "content": "i got that too. im not sure whats going on given that the constraint for input is between 1 and 1000"
                    },
                    {
                        "username": "Vinitajain",
                        "content": "Hi All,\\nI have a test case which is failing, but I feel the testcase result is incorrect.Please refer the screenshot below.\\n![image](https://assets.leetcode.com/users/images/e9e42efb-63d5-4cfa-b420-f1926674f6dc_1654838015.8394327.png)\\n\\nThe longest palindromic substring is \"aaca\" but the test case result is \"aca\". Anyone else faced this problem?"
                    },
                    {
                        "username": "OthSO",
                        "content": "[@mohdansah10](/mohdansah10) \\nthey are separated in the input with \"bd\" so it is not a valid answer "
                    },
                    {
                        "username": "mohdansah10",
                        "content": "I\\'m getting same error, but different case:\\nInput\\ns =\\n\"aacabdkacaa\"\\n\\nOutput\\n\"aacakacaa\"\\nExpected\\n\"aca\"\\n\\nBut mine is Palindrome"
                    },
                    {
                        "username": "hasmithraa",
                        "content": "the expected is correct because aaca can\\'t be a palindrome only \\'aacaa\\' can be a palindrome which is not there in your case"
                    },
                    {
                        "username": "Amish_Singh",
                        "content": "how are you considering \"aaca\" as a palindromic substring, \"aca\" is a palindrome and it is the longest"
                    },
                    {
                        "username": "Shaik_Aman_Sayer",
                        "content": "dude you really came up with the solution "
                    },
                    {
                        "username": "AryaAditya3609",
                        "content": "how is \"aaca\" and \"acaa\" same ???\\nWhile \"aca\" is palindrome because both \"aca\" and reverse of it \"aca\" is same !!"
                    },
                    {
                        "username": "alexandra-pickle",
                        "content": "\"aaca\" is not a palindrome"
                    },
                    {
                        "username": "bugHackerLoop",
                        "content": "I followed the approach leant by Aditya Verma DP lectures and encountered the same test case failing. Does the logic where I reverse the string and calculate the longest common substring doesn\\'t work here? I know it works for longest palindromic subsequence but here it fails for such test cases .. why is it so?"
                    },
                    {
                        "username": "mductran",
                        "content": "how is \\'aaca\\' a palindrome? when read backward it\\'s \\'acaa\\' so it\\'s not the same reading forward."
                    },
                    {
                        "username": "jnsudhir",
                        "content": "Check my solution, it was able to clear test case \"aaca\". Explained code in comments.\\n\\nhttps://leetcode.com/problems/longest-palindromic-substring/solutions/3091016/longest-palindromic-substring-using-javascript-beats-94-82-in-runtime-explained/?orderBy=most_votes"
                    },
                    {
                        "username": "nikhileshratna",
                        "content": "aaca is not palindrome"
                    },
                    {
                        "username": "sunshine77",
                        "content": "hey, iam getting the same error, i have seen ansewrs where they have totally changed the algorithm, how did u solve this by tweaking the same algoirhtm"
                    },
                    {
                        "username": "bhupendrabc71",
                        "content": "how come \"aaca\" is palindrome. it should be \"aca\""
                    },
                    {
                        "username": "just11blocks",
                        "content": "aaca is not a palindrome...aacaa and aca are."
                    },
                    {
                        "username": "odi1n",
                        "content": "I also encountered this problem"
                    },
                    {
                        "username": "vamsi2302",
                        "content": "I think you get it by now!\\n"
                    }
                ]
            },
            {
                "id": 1576875,
                "content": [
                    {
                        "username": "ZenMasterV",
                        "content": "Seems like too many of the  coding wunderkinds here lack basic reading comprehension skills \\n\" Please don\\'t post any solutions in this discussion tab\"\\nIt\\'s almost the rule to find the exact opposite for the discussion of every question. I don\\'t want to see your damned solution!"
                    },
                    {
                        "username": "NeroXIII",
                        "content": "[@charonme](/charonme) name does not check out :((("
                    },
                    {
                        "username": "192731",
                        "content": "and if they do?"
                    },
                    {
                        "username": "plevi1995",
                        "content": "Excellent comment"
                    },
                    {
                        "username": "khan60939",
                        "content": "Can anyone tell how DP is being used here? "
                    },
                    {
                        "username": "sandagolcea",
                        "content": "[@charonme](/charonme) my thinking exactly, but at least they should create a flag to help us moderate and move solutions to the correct tab. Would only need a stack overflow moderation-like system: one person flags, another person receives a queue of flagged comments and confirms the tagging.. oh well"
                    },
                    {
                        "username": "charonme",
                        "content": "maybe people get confused by the official leetcode comment which says: \"If you\\'d like to share a detailed solution to the problem, please create a new post in the discuss section\"\\nMaybe some time ago they didn\\'t have a separate solutions section and only recently changed it, but left some of the old solutions in the discussion section and didn\\'t fix the automated comment worting?"
                    },
                    {
                        "username": "klanjewar037",
                        "content": "hehe"
                    },
                    {
                        "username": "sanemdeepak",
                        "content": "For input \"ac\" test case is expecting \"a\" as output, how is just \"a\" a palindromic string?"
                    },
                    {
                        "username": "ayushiidevpura",
                        "content": "because when we read \"a\" from forward it results in \"a\" and at the same time when we read \"a\" from backward it is still \"a\""
                    },
                    {
                        "username": "beyzigo",
                        "content": "Because if you read the string \"a\" backwards it will still be \"a\""
                    },
                    {
                        "username": "tsafackghokeng",
                        "content": "[@Chouhan_Gourav](/Chouhan_Gourav) the test case said \"ac\" not \"a\". is \"ac\" palindromic? for \"a\" i understand"
                    },
                    {
                        "username": "CODEWITHABHINAV",
                        "content": "you have to submit the first string as your answer read more about this question on gFg\\n"
                    },
                    {
                        "username": "_BREEZE_",
                        "content": "any string is palindrome if we read it same from front and from back\\nin single character we read it same from front and back"
                    },
                    {
                        "username": "oinrup",
                        "content": "yes thats my question too"
                    },
                    {
                        "username": "yldemon",
                        "content": "Any character in the string by itself is a palindromic substring. So in the case where there is no palindromic substring with length > 1, you can return any character."
                    },
                    {
                        "username": "Chouhan_Gourav",
                        "content": "Whenever you come accross such contradiction, just google the definition, any. Any string is called is pallindromic if the reverse of the string is equal to the original string. Reverse of \\'a\\' is \\'a\\'. Hope you get this."
                    },
                    {
                        "username": "947876275",
                        "content": "This post is for learner wanna practice DP.\\nThe basic idea is, if we wanna say \"aba\" is palindromic, then we need to firstly confirm that \"b\" is palindromic, then we also need to check if \"a\"(the first a) = \"a\" (the second a).\\n\\nM is a 2-d array which stores boolean values.\\nM[i][j] indicates if string[i.....j] is palindromic.\\nSo base cases are:\\nM[i][i] is true.\\nM[i][i + 1] = (s[i] == s[i + 1]);\\nrecurrence relation is :\\nM[i][j] = (s[i] == s[j] AND M[i + 1][j - 1]);\\nFor the implementation of recurrence relation, one idea is you can loop through all possible symmetry axis. For each of the axis, you expand at both RHS and LHS simultaneously. This method promises that when you are determining value in M[i][j], M[i + 1][j - 1] must have the correct value.\\nFinal answer can be found from all M[i][j] == 1 with largest (j - i)."
                    },
                    {
                        "username": "Msey",
                        "content": "thank you, cat brother"
                    },
                    {
                        "username": "user0558y",
                        "content": "I understand the solution but I don't understand why it needs any storage at all or why it needs to be a DP solution.\n\nThe condition `(s[i] == s[j] AND M[i + 1][j - 1])` requires you to memorise if `M[i+1][j-1]` is true, that's easy to understand. However, if you expand each possible axis at the same time, i.e. 1st iteration (s[i+1], s[j-1]), 2nd iteration `s[i+2], s[j-2]`, ... It is guaranteed that M[i+1][j-1] is always true and hence can be dropped, and you should break the loop when it is not true.\n\nIn summary, you don't need to memorise anything at all and you just need to check `s[i] == s[j]` while expanding in both directions at the same time, unless I have misunderstood anything? Here is an implementation of your algorithm but without storage: https://leetcode.com/problems/longest-palindromic-substring/submissions/868540120/"
                    },
                    {
                        "username": "taras",
                        "content": "Thank you! this is a beautiful explanation, though I\\'m not sure what exactly you mean by expanding both on LHS and RHS. In my implementation it\\'s enough to compute all diagonals of  the upper right triangle of the dp matrix."
                    },
                    {
                        "username": "klu_2100031593",
                        "content": "super explanation"
                    },
                    {
                        "username": "napoleon",
                        "content": "My Solution Is Naive, It Cost O(n^2), Is there Any Solution faster?"
                    },
                    {
                        "username": "leocampos",
                        "content": "[@tylerprill-rhdc](/tylerprill-rhdc) So, what I did was:\nStated in my mind the Brute Force approach - create every possible substring and test each one to see if is a palindrome and find the longest.\n\nOf course this would be ridiculously slow, so let's improve it.\nI also mentally stated that a palindrome has a recursive aspect -> if single char, or two equal chars, or charX + palindrome + charX\nSo I created a isPalindrome recursive method that checked it delegating to itself extracting the borders.\n\nSince a palindrome must start and end with the same char, in my traverse of the string, I started storing the position of each character Map<Character, List< Integer>>, so I would just go back to the previous found Char and check if from there to the current pointer I would have a Palindrome.\n\nThen I stopped doing this for every possible palindrome, I then started doing only for the ones that COULD be longer than the already found longest palindrome. That accelerated a lot.\n\nIn the almost last step, I added memoization. Remember that a palindrome is like a sandwich, with the external chars being equal and the meat being another palindrome? So I stored the found palindromes using their start and and positions. So I could check if that had already being checked and if so, either return true or false directly.\n\nThe final step was to convert the recursive function to an iterative function to save some memory used by the call stack.\nMaybe there are better implementations, just sharing my thought process."
                    },
                    {
                        "username": "tylerprill-rhdc",
                        "content": "[@tylerprill-rhdc](/tylerprill-rhdc) Two pointer based solution is also a really good solve here"
                    },
                    {
                        "username": "tylerprill-rhdc",
                        "content": "This could be done in a single pass algorithm, but will inherently check character indices multiple times based on the nature of the problem. (basically, iterate through each, then bubble out from each index)"
                    },
                    {
                        "username": "neetika",
                        "content": "From the leetcode blog, one of the methods of solving this is:\\n\\nA common mistake:\\nSome people will be tempted to come up with a quick solution, which is unfortunately flawed (however can be corrected easily):\\n\\nReverse S and become S\\u2019. Find the longest common substring between S and S\\u2019, which must also be the longest palindromic substring.\\nThis seemed to work, let\\u2019s see some examples below.\\n\\nFor example,\\nS = \\u201ccaba\\u201d, S\\u2019 = \\u201cabac\\u201d.\\nThe longest common substring between S and S\\u2019 is \\u201caba\\u201d, which is the answer.\\n\\nLet\\u2019s try another example:\\nS = \\u201cabacdfgdcaba\\u201d, S\\u2019 = \\u201cabacdgfdcaba\\u201d.\\nThe longest common substring between S and S\\u2019 is \\u201cabacd\\u201d. Clearly, this is not a valid palindrome.\\n\\n**We could see that the longest common substring method fails when there exists a reversed copy of a non-palindromic substring in some other part of S. To rectify this, each time we find a longest common substring candidate, we check if the substring\\u2019s indices are the same as the reversed substring\\u2019s original indices. If it is, then we attempt to update the longest palindrome found so far; if not, we skip this and find the next candidate.**\\n\\nIs this part correct? \\n\\nexample string: abcxycba\\nreverse string:  abcxycba\\n\\nThe substring indices are same as reversed string original indices and yet it is not a palindrome?"
                    },
                    {
                        "username": "HRVY_SNOWDEN",
                        "content": "cool sirr:)\\n"
                    },
                    {
                        "username": "dhtmlkitchen",
                        "content": "WRONG.\\n\\nabcxycba reversed is abcyxcba."
                    },
                    {
                        "username": "travisl12",
                        "content": "After I solved this problem I thought it\\'d be interesting to see how it worked in realtime.\\n\\nhttps://codepen.io/TravisL12/pen/pogvweg"
                    },
                    {
                        "username": "user3907vj",
                        "content": "thanks for the \"nanananananana\" from all the small things ;)"
                    },
                    {
                        "username": "zapataast",
                        "content": "u are crazy"
                    },
                    {
                        "username": "sondq98",
                        "content": "very intuitive"
                    },
                    {
                        "username": "Tathagat017",
                        "content": "thank you\\n"
                    },
                    {
                        "username": "mikler",
                        "content": "So I think I finally understood logic of test creators. \\nEven if you write a classical DP or memorization solution for this one you will timeout on latest tests.\\nI think they consider it edge cases. Because if you add one simple line it will pass! OMG. \\nI have leet code for this. Instead of solving problems I spend hours optimizing the constants.\\n\\nif s == s[::-1]: return s"
                    },
                    {
                        "username": "Vectorido",
                        "content": "Don\\'t work already. Time limit at 141 test even with that construction."
                    },
                    {
                        "username": "deepalithakur17",
                        "content": "It will only work in python."
                    },
                    {
                        "username": "ishogbon",
                        "content": "Its memoization, not memorization "
                    },
                    {
                        "username": "84danie",
                        "content": "I submitted my solution, and received a Time Limit Exceeded on this test case:\\n\\n\"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaabcaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"\\n\\nSo I copied and pasted the TC into a custom test case, and started to think about what I could tweak. However, I ended up accidentally hitting Run Code, but instead of getting a Time Limit Exceeded result, it passed:\\n\\n![0_1479079812693_upload-4af9e94c-2e53-4915-acf6-782780c7bf8b](/uploads/files/1479079813717-upload-4af9e94c-2e53-4915-acf6-782780c7bf8b.png) \\n\\nIs this supposed to happen and I just need to make my code more efficient, or is this a bug? \\n![0_1479079956817_upload-1ef15826-d6e6-4bde-9c06-eb597c5c8d0e](/uploads/files/1479079957639-upload-1ef15826-d6e6-4bde-9c06-eb597c5c8d0e.png)"
                    },
                    {
                        "username": "RitikaSahay",
                        "content": "Same thing happened with me. Is there a solution for it?\\n"
                    },
                    {
                        "username": "danicruz0415",
                        "content": "It\\'s happened to me a couple of times. My theory is that the time limit is given for the whole list of test cases. Thus, you can have your test pass, but it will still time limit exceed because it wont get to calculate all the test cases before the time runs out. I cannot confirm this but I think its true because with a very unoptimized solution I got time limit exceeded very early in the test cases (for another problem), after some optimizations I got it much later (like getting to the last tests) which themselves were around the same size, so if the time limit was set per test it would not make sense to fail in a similarly long test-case just that is much later in the test list. (I think the same would apply to memory limit exceeded)"
                    },
                    {
                        "username": "him_Sarma619",
                        "content": "The exact same situation happened with me in one problem... it was a DP problem too... I was getting a Memory Limit Exceeded error with the memoized solution but it was running fine in the Run Code button."
                    },
                    {
                        "username": "Hubro",
                        "content": "I\\'m getting \"Time Limit Exceeded\" with 141/141 testcases passed and \"Last Executed Input\" is:\\n\\n```\\ns =\\n```\\n\\nDid I break it?"
                    },
                    {
                        "username": "karan_dhiman",
                        "content": "same issue"
                    },
                    {
                        "username": "BLANK-Zora",
                        "content": "exactly bro this shit is recked , like it is giving tests outside the constraints , how am i suppose to include such things in the code"
                    },
                    {
                        "username": "arunprep5",
                        "content": "same issue. java"
                    },
                    {
                        "username": "blasphelmy",
                        "content": "[@tuancoltech](/tuancoltech) it worked when i rewrote the code in c# instead of c++"
                    },
                    {
                        "username": "tuancoltech",
                        "content": "[@blasphelmy](/blasphelmy) [@Tomas Sandven](/Hubro) Did you guys find out why? I got the same issue."
                    },
                    {
                        "username": "blasphelmy",
                        "content": "i got that too. im not sure whats going on given that the constraint for input is between 1 and 1000"
                    },
                    {
                        "username": "Vinitajain",
                        "content": "Hi All,\\nI have a test case which is failing, but I feel the testcase result is incorrect.Please refer the screenshot below.\\n![image](https://assets.leetcode.com/users/images/e9e42efb-63d5-4cfa-b420-f1926674f6dc_1654838015.8394327.png)\\n\\nThe longest palindromic substring is \"aaca\" but the test case result is \"aca\". Anyone else faced this problem?"
                    },
                    {
                        "username": "OthSO",
                        "content": "[@mohdansah10](/mohdansah10) \\nthey are separated in the input with \"bd\" so it is not a valid answer "
                    },
                    {
                        "username": "mohdansah10",
                        "content": "I\\'m getting same error, but different case:\\nInput\\ns =\\n\"aacabdkacaa\"\\n\\nOutput\\n\"aacakacaa\"\\nExpected\\n\"aca\"\\n\\nBut mine is Palindrome"
                    },
                    {
                        "username": "hasmithraa",
                        "content": "the expected is correct because aaca can\\'t be a palindrome only \\'aacaa\\' can be a palindrome which is not there in your case"
                    },
                    {
                        "username": "Amish_Singh",
                        "content": "how are you considering \"aaca\" as a palindromic substring, \"aca\" is a palindrome and it is the longest"
                    },
                    {
                        "username": "Shaik_Aman_Sayer",
                        "content": "dude you really came up with the solution "
                    },
                    {
                        "username": "AryaAditya3609",
                        "content": "how is \"aaca\" and \"acaa\" same ???\\nWhile \"aca\" is palindrome because both \"aca\" and reverse of it \"aca\" is same !!"
                    },
                    {
                        "username": "alexandra-pickle",
                        "content": "\"aaca\" is not a palindrome"
                    },
                    {
                        "username": "bugHackerLoop",
                        "content": "I followed the approach leant by Aditya Verma DP lectures and encountered the same test case failing. Does the logic where I reverse the string and calculate the longest common substring doesn\\'t work here? I know it works for longest palindromic subsequence but here it fails for such test cases .. why is it so?"
                    },
                    {
                        "username": "mductran",
                        "content": "how is \\'aaca\\' a palindrome? when read backward it\\'s \\'acaa\\' so it\\'s not the same reading forward."
                    },
                    {
                        "username": "jnsudhir",
                        "content": "Check my solution, it was able to clear test case \"aaca\". Explained code in comments.\\n\\nhttps://leetcode.com/problems/longest-palindromic-substring/solutions/3091016/longest-palindromic-substring-using-javascript-beats-94-82-in-runtime-explained/?orderBy=most_votes"
                    },
                    {
                        "username": "nikhileshratna",
                        "content": "aaca is not palindrome"
                    },
                    {
                        "username": "sunshine77",
                        "content": "hey, iam getting the same error, i have seen ansewrs where they have totally changed the algorithm, how did u solve this by tweaking the same algoirhtm"
                    },
                    {
                        "username": "bhupendrabc71",
                        "content": "how come \"aaca\" is palindrome. it should be \"aca\""
                    },
                    {
                        "username": "just11blocks",
                        "content": "aaca is not a palindrome...aacaa and aca are."
                    },
                    {
                        "username": "odi1n",
                        "content": "I also encountered this problem"
                    },
                    {
                        "username": "vamsi2302",
                        "content": "I think you get it by now!\\n"
                    }
                ]
            },
            {
                "id": 1568053,
                "content": [
                    {
                        "username": "tarun_kothari",
                        "content": "![image](https://s3-lc-upload.s3.amazonaws.com/users/tarun_kothari/image_1536831337.png)\\nWhile submitting the code it is showing the error for a test case but for the same test case if I try giving input as coustom it is showing correct."
                    },
                    {
                        "username": "showtroylove",
                        "content": "How did you add this image to your comment?"
                    },
                    {
                        "username": "loretta",
                        "content": "What is OJ???"
                    },
                    {
                        "username": "ishita_gupta21",
                        "content": "[@SLazaruss](/SLazaruss) i was about the say the same thing lawd"
                    },
                    {
                        "username": "SLazaruss",
                        "content": "Orange juice"
                    },
                    {
                        "username": "Ashu_91",
                        "content": "Online judge."
                    },
                    {
                        "username": "ClocloDyArx",
                        "content": "Hello,\\nI have finished this exercise but even though I pass all 141/141 tests the Results says \"Time Limit Exceeded\".\\nThe last executed input is empty."
                    },
                    {
                        "username": "swet_rajput",
                        "content": "It took me an hour to solve this even though it\\'s not that difficult but anyhow came to the conclusion that I need to do more practice."
                    },
                    {
                        "username": "2012094",
                        "content": "I face an error while solving the \"5. Longest Palindromic Substring\" problem i.e.\\nTestcase Result\\n\\nTime Limit Exceeded\\n\\nLast Executed Input\\n\\n141/141 testcases passed\\n\\nUse Testcase\\n\\nWhat am I supposed to do ?"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for June, Day 16.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/longest-palindromic-substring/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 5 approaches in the official solution</summary>\n\n  \n**Approach 1:** Longest Common Substring\n\n  \n**Approach 2:** Brute Force\n\n  \n**Approach 3:** Dynamic Programming\n\n  \n**Approach 4:** Expand Around Center\n\n  \n**Approach 5:** Manacher's Algorithm\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "AlgoEngine",
                        "content": "Visualization of \"Expand from Centers\" solution:\n\nhttps://youtu.be/E-tmN1OM9aA"
                    },
                    {
                        "username": "vitalik11087625",
                        "content": "\"000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000..\\n\\nPiece of shit, on submit its doent work, but when i test it myself, its work))))))))))))))))))"
                    },
                    {
                        "username": "NileshKumarGupta",
                        "content": "![image](https://assets.leetcode.com/users/images/d4d76bca-4918-4afc-8fb2-8f24506cab22_1598198725.4986076.png)\\nThe test case shows time limit exceeded but it runs fine locally with 180ms. Why is this error?"
                    },
                    {
                        "username": "amanmaurya8419",
                        "content": "Try to Think with two Pointer Approach because we have to give solution of O(N^2) so normal brute force is not applicable. \\n\\nthink i that way to take element as center and check for left and right of center if left and right element are equal then check for further  else no palindrome found between left and right index"
                    }
                ]
            },
            {
                "id": 1565932,
                "content": [
                    {
                        "username": "tarun_kothari",
                        "content": "![image](https://s3-lc-upload.s3.amazonaws.com/users/tarun_kothari/image_1536831337.png)\\nWhile submitting the code it is showing the error for a test case but for the same test case if I try giving input as coustom it is showing correct."
                    },
                    {
                        "username": "showtroylove",
                        "content": "How did you add this image to your comment?"
                    },
                    {
                        "username": "loretta",
                        "content": "What is OJ???"
                    },
                    {
                        "username": "ishita_gupta21",
                        "content": "[@SLazaruss](/SLazaruss) i was about the say the same thing lawd"
                    },
                    {
                        "username": "SLazaruss",
                        "content": "Orange juice"
                    },
                    {
                        "username": "Ashu_91",
                        "content": "Online judge."
                    },
                    {
                        "username": "ClocloDyArx",
                        "content": "Hello,\\nI have finished this exercise but even though I pass all 141/141 tests the Results says \"Time Limit Exceeded\".\\nThe last executed input is empty."
                    },
                    {
                        "username": "swet_rajput",
                        "content": "It took me an hour to solve this even though it\\'s not that difficult but anyhow came to the conclusion that I need to do more practice."
                    },
                    {
                        "username": "2012094",
                        "content": "I face an error while solving the \"5. Longest Palindromic Substring\" problem i.e.\\nTestcase Result\\n\\nTime Limit Exceeded\\n\\nLast Executed Input\\n\\n141/141 testcases passed\\n\\nUse Testcase\\n\\nWhat am I supposed to do ?"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for June, Day 16.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/longest-palindromic-substring/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 5 approaches in the official solution</summary>\n\n  \n**Approach 1:** Longest Common Substring\n\n  \n**Approach 2:** Brute Force\n\n  \n**Approach 3:** Dynamic Programming\n\n  \n**Approach 4:** Expand Around Center\n\n  \n**Approach 5:** Manacher's Algorithm\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "AlgoEngine",
                        "content": "Visualization of \"Expand from Centers\" solution:\n\nhttps://youtu.be/E-tmN1OM9aA"
                    },
                    {
                        "username": "vitalik11087625",
                        "content": "\"000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000..\\n\\nPiece of shit, on submit its doent work, but when i test it myself, its work))))))))))))))))))"
                    },
                    {
                        "username": "NileshKumarGupta",
                        "content": "![image](https://assets.leetcode.com/users/images/d4d76bca-4918-4afc-8fb2-8f24506cab22_1598198725.4986076.png)\\nThe test case shows time limit exceeded but it runs fine locally with 180ms. Why is this error?"
                    },
                    {
                        "username": "amanmaurya8419",
                        "content": "Try to Think with two Pointer Approach because we have to give solution of O(N^2) so normal brute force is not applicable. \\n\\nthink i that way to take element as center and check for left and right of center if left and right element are equal then check for further  else no palindrome found between left and right index"
                    }
                ]
            },
            {
                "id": 1875226,
                "content": [
                    {
                        "username": "tarun_kothari",
                        "content": "![image](https://s3-lc-upload.s3.amazonaws.com/users/tarun_kothari/image_1536831337.png)\\nWhile submitting the code it is showing the error for a test case but for the same test case if I try giving input as coustom it is showing correct."
                    },
                    {
                        "username": "showtroylove",
                        "content": "How did you add this image to your comment?"
                    },
                    {
                        "username": "loretta",
                        "content": "What is OJ???"
                    },
                    {
                        "username": "ishita_gupta21",
                        "content": "[@SLazaruss](/SLazaruss) i was about the say the same thing lawd"
                    },
                    {
                        "username": "SLazaruss",
                        "content": "Orange juice"
                    },
                    {
                        "username": "Ashu_91",
                        "content": "Online judge."
                    },
                    {
                        "username": "ClocloDyArx",
                        "content": "Hello,\\nI have finished this exercise but even though I pass all 141/141 tests the Results says \"Time Limit Exceeded\".\\nThe last executed input is empty."
                    },
                    {
                        "username": "swet_rajput",
                        "content": "It took me an hour to solve this even though it\\'s not that difficult but anyhow came to the conclusion that I need to do more practice."
                    },
                    {
                        "username": "2012094",
                        "content": "I face an error while solving the \"5. Longest Palindromic Substring\" problem i.e.\\nTestcase Result\\n\\nTime Limit Exceeded\\n\\nLast Executed Input\\n\\n141/141 testcases passed\\n\\nUse Testcase\\n\\nWhat am I supposed to do ?"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for June, Day 16.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/longest-palindromic-substring/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 5 approaches in the official solution</summary>\n\n  \n**Approach 1:** Longest Common Substring\n\n  \n**Approach 2:** Brute Force\n\n  \n**Approach 3:** Dynamic Programming\n\n  \n**Approach 4:** Expand Around Center\n\n  \n**Approach 5:** Manacher's Algorithm\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "AlgoEngine",
                        "content": "Visualization of \"Expand from Centers\" solution:\n\nhttps://youtu.be/E-tmN1OM9aA"
                    },
                    {
                        "username": "vitalik11087625",
                        "content": "\"000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000..\\n\\nPiece of shit, on submit its doent work, but when i test it myself, its work))))))))))))))))))"
                    },
                    {
                        "username": "NileshKumarGupta",
                        "content": "![image](https://assets.leetcode.com/users/images/d4d76bca-4918-4afc-8fb2-8f24506cab22_1598198725.4986076.png)\\nThe test case shows time limit exceeded but it runs fine locally with 180ms. Why is this error?"
                    },
                    {
                        "username": "amanmaurya8419",
                        "content": "Try to Think with two Pointer Approach because we have to give solution of O(N^2) so normal brute force is not applicable. \\n\\nthink i that way to take element as center and check for left and right of center if left and right element are equal then check for further  else no palindrome found between left and right index"
                    }
                ]
            },
            {
                "id": 1670373,
                "content": [
                    {
                        "username": "tarun_kothari",
                        "content": "![image](https://s3-lc-upload.s3.amazonaws.com/users/tarun_kothari/image_1536831337.png)\\nWhile submitting the code it is showing the error for a test case but for the same test case if I try giving input as coustom it is showing correct."
                    },
                    {
                        "username": "showtroylove",
                        "content": "How did you add this image to your comment?"
                    },
                    {
                        "username": "loretta",
                        "content": "What is OJ???"
                    },
                    {
                        "username": "ishita_gupta21",
                        "content": "[@SLazaruss](/SLazaruss) i was about the say the same thing lawd"
                    },
                    {
                        "username": "SLazaruss",
                        "content": "Orange juice"
                    },
                    {
                        "username": "Ashu_91",
                        "content": "Online judge."
                    },
                    {
                        "username": "ClocloDyArx",
                        "content": "Hello,\\nI have finished this exercise but even though I pass all 141/141 tests the Results says \"Time Limit Exceeded\".\\nThe last executed input is empty."
                    },
                    {
                        "username": "swet_rajput",
                        "content": "It took me an hour to solve this even though it\\'s not that difficult but anyhow came to the conclusion that I need to do more practice."
                    },
                    {
                        "username": "2012094",
                        "content": "I face an error while solving the \"5. Longest Palindromic Substring\" problem i.e.\\nTestcase Result\\n\\nTime Limit Exceeded\\n\\nLast Executed Input\\n\\n141/141 testcases passed\\n\\nUse Testcase\\n\\nWhat am I supposed to do ?"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for June, Day 16.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/longest-palindromic-substring/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 5 approaches in the official solution</summary>\n\n  \n**Approach 1:** Longest Common Substring\n\n  \n**Approach 2:** Brute Force\n\n  \n**Approach 3:** Dynamic Programming\n\n  \n**Approach 4:** Expand Around Center\n\n  \n**Approach 5:** Manacher's Algorithm\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "AlgoEngine",
                        "content": "Visualization of \"Expand from Centers\" solution:\n\nhttps://youtu.be/E-tmN1OM9aA"
                    },
                    {
                        "username": "vitalik11087625",
                        "content": "\"000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000..\\n\\nPiece of shit, on submit its doent work, but when i test it myself, its work))))))))))))))))))"
                    },
                    {
                        "username": "NileshKumarGupta",
                        "content": "![image](https://assets.leetcode.com/users/images/d4d76bca-4918-4afc-8fb2-8f24506cab22_1598198725.4986076.png)\\nThe test case shows time limit exceeded but it runs fine locally with 180ms. Why is this error?"
                    },
                    {
                        "username": "amanmaurya8419",
                        "content": "Try to Think with two Pointer Approach because we have to give solution of O(N^2) so normal brute force is not applicable. \\n\\nthink i that way to take element as center and check for left and right of center if left and right element are equal then check for further  else no palindrome found between left and right index"
                    }
                ]
            },
            {
                "id": 1912401,
                "content": [
                    {
                        "username": "tarun_kothari",
                        "content": "![image](https://s3-lc-upload.s3.amazonaws.com/users/tarun_kothari/image_1536831337.png)\\nWhile submitting the code it is showing the error for a test case but for the same test case if I try giving input as coustom it is showing correct."
                    },
                    {
                        "username": "showtroylove",
                        "content": "How did you add this image to your comment?"
                    },
                    {
                        "username": "loretta",
                        "content": "What is OJ???"
                    },
                    {
                        "username": "ishita_gupta21",
                        "content": "[@SLazaruss](/SLazaruss) i was about the say the same thing lawd"
                    },
                    {
                        "username": "SLazaruss",
                        "content": "Orange juice"
                    },
                    {
                        "username": "Ashu_91",
                        "content": "Online judge."
                    },
                    {
                        "username": "ClocloDyArx",
                        "content": "Hello,\\nI have finished this exercise but even though I pass all 141/141 tests the Results says \"Time Limit Exceeded\".\\nThe last executed input is empty."
                    },
                    {
                        "username": "swet_rajput",
                        "content": "It took me an hour to solve this even though it\\'s not that difficult but anyhow came to the conclusion that I need to do more practice."
                    },
                    {
                        "username": "2012094",
                        "content": "I face an error while solving the \"5. Longest Palindromic Substring\" problem i.e.\\nTestcase Result\\n\\nTime Limit Exceeded\\n\\nLast Executed Input\\n\\n141/141 testcases passed\\n\\nUse Testcase\\n\\nWhat am I supposed to do ?"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for June, Day 16.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/longest-palindromic-substring/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 5 approaches in the official solution</summary>\n\n  \n**Approach 1:** Longest Common Substring\n\n  \n**Approach 2:** Brute Force\n\n  \n**Approach 3:** Dynamic Programming\n\n  \n**Approach 4:** Expand Around Center\n\n  \n**Approach 5:** Manacher's Algorithm\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "AlgoEngine",
                        "content": "Visualization of \"Expand from Centers\" solution:\n\nhttps://youtu.be/E-tmN1OM9aA"
                    },
                    {
                        "username": "vitalik11087625",
                        "content": "\"000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000..\\n\\nPiece of shit, on submit its doent work, but when i test it myself, its work))))))))))))))))))"
                    },
                    {
                        "username": "NileshKumarGupta",
                        "content": "![image](https://assets.leetcode.com/users/images/d4d76bca-4918-4afc-8fb2-8f24506cab22_1598198725.4986076.png)\\nThe test case shows time limit exceeded but it runs fine locally with 180ms. Why is this error?"
                    },
                    {
                        "username": "amanmaurya8419",
                        "content": "Try to Think with two Pointer Approach because we have to give solution of O(N^2) so normal brute force is not applicable. \\n\\nthink i that way to take element as center and check for left and right of center if left and right element are equal then check for further  else no palindrome found between left and right index"
                    }
                ]
            },
            {
                "id": 1568779,
                "content": [
                    {
                        "username": "tarun_kothari",
                        "content": "![image](https://s3-lc-upload.s3.amazonaws.com/users/tarun_kothari/image_1536831337.png)\\nWhile submitting the code it is showing the error for a test case but for the same test case if I try giving input as coustom it is showing correct."
                    },
                    {
                        "username": "showtroylove",
                        "content": "How did you add this image to your comment?"
                    },
                    {
                        "username": "loretta",
                        "content": "What is OJ???"
                    },
                    {
                        "username": "ishita_gupta21",
                        "content": "[@SLazaruss](/SLazaruss) i was about the say the same thing lawd"
                    },
                    {
                        "username": "SLazaruss",
                        "content": "Orange juice"
                    },
                    {
                        "username": "Ashu_91",
                        "content": "Online judge."
                    },
                    {
                        "username": "ClocloDyArx",
                        "content": "Hello,\\nI have finished this exercise but even though I pass all 141/141 tests the Results says \"Time Limit Exceeded\".\\nThe last executed input is empty."
                    },
                    {
                        "username": "swet_rajput",
                        "content": "It took me an hour to solve this even though it\\'s not that difficult but anyhow came to the conclusion that I need to do more practice."
                    },
                    {
                        "username": "2012094",
                        "content": "I face an error while solving the \"5. Longest Palindromic Substring\" problem i.e.\\nTestcase Result\\n\\nTime Limit Exceeded\\n\\nLast Executed Input\\n\\n141/141 testcases passed\\n\\nUse Testcase\\n\\nWhat am I supposed to do ?"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for June, Day 16.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/longest-palindromic-substring/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 5 approaches in the official solution</summary>\n\n  \n**Approach 1:** Longest Common Substring\n\n  \n**Approach 2:** Brute Force\n\n  \n**Approach 3:** Dynamic Programming\n\n  \n**Approach 4:** Expand Around Center\n\n  \n**Approach 5:** Manacher's Algorithm\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "AlgoEngine",
                        "content": "Visualization of \"Expand from Centers\" solution:\n\nhttps://youtu.be/E-tmN1OM9aA"
                    },
                    {
                        "username": "vitalik11087625",
                        "content": "\"000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000..\\n\\nPiece of shit, on submit its doent work, but when i test it myself, its work))))))))))))))))))"
                    },
                    {
                        "username": "NileshKumarGupta",
                        "content": "![image](https://assets.leetcode.com/users/images/d4d76bca-4918-4afc-8fb2-8f24506cab22_1598198725.4986076.png)\\nThe test case shows time limit exceeded but it runs fine locally with 180ms. Why is this error?"
                    },
                    {
                        "username": "amanmaurya8419",
                        "content": "Try to Think with two Pointer Approach because we have to give solution of O(N^2) so normal brute force is not applicable. \\n\\nthink i that way to take element as center and check for left and right of center if left and right element are equal then check for further  else no palindrome found between left and right index"
                    }
                ]
            },
            {
                "id": 1932644,
                "content": [
                    {
                        "username": "tarun_kothari",
                        "content": "![image](https://s3-lc-upload.s3.amazonaws.com/users/tarun_kothari/image_1536831337.png)\\nWhile submitting the code it is showing the error for a test case but for the same test case if I try giving input as coustom it is showing correct."
                    },
                    {
                        "username": "showtroylove",
                        "content": "How did you add this image to your comment?"
                    },
                    {
                        "username": "loretta",
                        "content": "What is OJ???"
                    },
                    {
                        "username": "ishita_gupta21",
                        "content": "[@SLazaruss](/SLazaruss) i was about the say the same thing lawd"
                    },
                    {
                        "username": "SLazaruss",
                        "content": "Orange juice"
                    },
                    {
                        "username": "Ashu_91",
                        "content": "Online judge."
                    },
                    {
                        "username": "ClocloDyArx",
                        "content": "Hello,\\nI have finished this exercise but even though I pass all 141/141 tests the Results says \"Time Limit Exceeded\".\\nThe last executed input is empty."
                    },
                    {
                        "username": "swet_rajput",
                        "content": "It took me an hour to solve this even though it\\'s not that difficult but anyhow came to the conclusion that I need to do more practice."
                    },
                    {
                        "username": "2012094",
                        "content": "I face an error while solving the \"5. Longest Palindromic Substring\" problem i.e.\\nTestcase Result\\n\\nTime Limit Exceeded\\n\\nLast Executed Input\\n\\n141/141 testcases passed\\n\\nUse Testcase\\n\\nWhat am I supposed to do ?"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for June, Day 16.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/longest-palindromic-substring/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 5 approaches in the official solution</summary>\n\n  \n**Approach 1:** Longest Common Substring\n\n  \n**Approach 2:** Brute Force\n\n  \n**Approach 3:** Dynamic Programming\n\n  \n**Approach 4:** Expand Around Center\n\n  \n**Approach 5:** Manacher's Algorithm\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "AlgoEngine",
                        "content": "Visualization of \"Expand from Centers\" solution:\n\nhttps://youtu.be/E-tmN1OM9aA"
                    },
                    {
                        "username": "vitalik11087625",
                        "content": "\"000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000..\\n\\nPiece of shit, on submit its doent work, but when i test it myself, its work))))))))))))))))))"
                    },
                    {
                        "username": "NileshKumarGupta",
                        "content": "![image](https://assets.leetcode.com/users/images/d4d76bca-4918-4afc-8fb2-8f24506cab22_1598198725.4986076.png)\\nThe test case shows time limit exceeded but it runs fine locally with 180ms. Why is this error?"
                    },
                    {
                        "username": "amanmaurya8419",
                        "content": "Try to Think with two Pointer Approach because we have to give solution of O(N^2) so normal brute force is not applicable. \\n\\nthink i that way to take element as center and check for left and right of center if left and right element are equal then check for further  else no palindrome found between left and right index"
                    }
                ]
            },
            {
                "id": 1922311,
                "content": [
                    {
                        "username": "tarun_kothari",
                        "content": "![image](https://s3-lc-upload.s3.amazonaws.com/users/tarun_kothari/image_1536831337.png)\\nWhile submitting the code it is showing the error for a test case but for the same test case if I try giving input as coustom it is showing correct."
                    },
                    {
                        "username": "showtroylove",
                        "content": "How did you add this image to your comment?"
                    },
                    {
                        "username": "loretta",
                        "content": "What is OJ???"
                    },
                    {
                        "username": "ishita_gupta21",
                        "content": "[@SLazaruss](/SLazaruss) i was about the say the same thing lawd"
                    },
                    {
                        "username": "SLazaruss",
                        "content": "Orange juice"
                    },
                    {
                        "username": "Ashu_91",
                        "content": "Online judge."
                    },
                    {
                        "username": "ClocloDyArx",
                        "content": "Hello,\\nI have finished this exercise but even though I pass all 141/141 tests the Results says \"Time Limit Exceeded\".\\nThe last executed input is empty."
                    },
                    {
                        "username": "swet_rajput",
                        "content": "It took me an hour to solve this even though it\\'s not that difficult but anyhow came to the conclusion that I need to do more practice."
                    },
                    {
                        "username": "2012094",
                        "content": "I face an error while solving the \"5. Longest Palindromic Substring\" problem i.e.\\nTestcase Result\\n\\nTime Limit Exceeded\\n\\nLast Executed Input\\n\\n141/141 testcases passed\\n\\nUse Testcase\\n\\nWhat am I supposed to do ?"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for June, Day 16.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/longest-palindromic-substring/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 5 approaches in the official solution</summary>\n\n  \n**Approach 1:** Longest Common Substring\n\n  \n**Approach 2:** Brute Force\n\n  \n**Approach 3:** Dynamic Programming\n\n  \n**Approach 4:** Expand Around Center\n\n  \n**Approach 5:** Manacher's Algorithm\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "AlgoEngine",
                        "content": "Visualization of \"Expand from Centers\" solution:\n\nhttps://youtu.be/E-tmN1OM9aA"
                    },
                    {
                        "username": "vitalik11087625",
                        "content": "\"000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000..\\n\\nPiece of shit, on submit its doent work, but when i test it myself, its work))))))))))))))))))"
                    },
                    {
                        "username": "NileshKumarGupta",
                        "content": "![image](https://assets.leetcode.com/users/images/d4d76bca-4918-4afc-8fb2-8f24506cab22_1598198725.4986076.png)\\nThe test case shows time limit exceeded but it runs fine locally with 180ms. Why is this error?"
                    },
                    {
                        "username": "amanmaurya8419",
                        "content": "Try to Think with two Pointer Approach because we have to give solution of O(N^2) so normal brute force is not applicable. \\n\\nthink i that way to take element as center and check for left and right of center if left and right element are equal then check for further  else no palindrome found between left and right index"
                    }
                ]
            },
            {
                "id": 1574268,
                "content": [
                    {
                        "username": "tarun_kothari",
                        "content": "![image](https://s3-lc-upload.s3.amazonaws.com/users/tarun_kothari/image_1536831337.png)\\nWhile submitting the code it is showing the error for a test case but for the same test case if I try giving input as coustom it is showing correct."
                    },
                    {
                        "username": "showtroylove",
                        "content": "How did you add this image to your comment?"
                    },
                    {
                        "username": "loretta",
                        "content": "What is OJ???"
                    },
                    {
                        "username": "ishita_gupta21",
                        "content": "[@SLazaruss](/SLazaruss) i was about the say the same thing lawd"
                    },
                    {
                        "username": "SLazaruss",
                        "content": "Orange juice"
                    },
                    {
                        "username": "Ashu_91",
                        "content": "Online judge."
                    },
                    {
                        "username": "ClocloDyArx",
                        "content": "Hello,\\nI have finished this exercise but even though I pass all 141/141 tests the Results says \"Time Limit Exceeded\".\\nThe last executed input is empty."
                    },
                    {
                        "username": "swet_rajput",
                        "content": "It took me an hour to solve this even though it\\'s not that difficult but anyhow came to the conclusion that I need to do more practice."
                    },
                    {
                        "username": "2012094",
                        "content": "I face an error while solving the \"5. Longest Palindromic Substring\" problem i.e.\\nTestcase Result\\n\\nTime Limit Exceeded\\n\\nLast Executed Input\\n\\n141/141 testcases passed\\n\\nUse Testcase\\n\\nWhat am I supposed to do ?"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for June, Day 16.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/longest-palindromic-substring/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 5 approaches in the official solution</summary>\n\n  \n**Approach 1:** Longest Common Substring\n\n  \n**Approach 2:** Brute Force\n\n  \n**Approach 3:** Dynamic Programming\n\n  \n**Approach 4:** Expand Around Center\n\n  \n**Approach 5:** Manacher's Algorithm\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "AlgoEngine",
                        "content": "Visualization of \"Expand from Centers\" solution:\n\nhttps://youtu.be/E-tmN1OM9aA"
                    },
                    {
                        "username": "vitalik11087625",
                        "content": "\"000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000..\\n\\nPiece of shit, on submit its doent work, but when i test it myself, its work))))))))))))))))))"
                    },
                    {
                        "username": "NileshKumarGupta",
                        "content": "![image](https://assets.leetcode.com/users/images/d4d76bca-4918-4afc-8fb2-8f24506cab22_1598198725.4986076.png)\\nThe test case shows time limit exceeded but it runs fine locally with 180ms. Why is this error?"
                    },
                    {
                        "username": "amanmaurya8419",
                        "content": "Try to Think with two Pointer Approach because we have to give solution of O(N^2) so normal brute force is not applicable. \\n\\nthink i that way to take element as center and check for left and right of center if left and right element are equal then check for further  else no palindrome found between left and right index"
                    }
                ]
            },
            {
                "id": 1894157,
                "content": [
                    {
                        "username": "tarun_kothari",
                        "content": "![image](https://s3-lc-upload.s3.amazonaws.com/users/tarun_kothari/image_1536831337.png)\\nWhile submitting the code it is showing the error for a test case but for the same test case if I try giving input as coustom it is showing correct."
                    },
                    {
                        "username": "showtroylove",
                        "content": "How did you add this image to your comment?"
                    },
                    {
                        "username": "loretta",
                        "content": "What is OJ???"
                    },
                    {
                        "username": "ishita_gupta21",
                        "content": "[@SLazaruss](/SLazaruss) i was about the say the same thing lawd"
                    },
                    {
                        "username": "SLazaruss",
                        "content": "Orange juice"
                    },
                    {
                        "username": "Ashu_91",
                        "content": "Online judge."
                    },
                    {
                        "username": "ClocloDyArx",
                        "content": "Hello,\\nI have finished this exercise but even though I pass all 141/141 tests the Results says \"Time Limit Exceeded\".\\nThe last executed input is empty."
                    },
                    {
                        "username": "swet_rajput",
                        "content": "It took me an hour to solve this even though it\\'s not that difficult but anyhow came to the conclusion that I need to do more practice."
                    },
                    {
                        "username": "2012094",
                        "content": "I face an error while solving the \"5. Longest Palindromic Substring\" problem i.e.\\nTestcase Result\\n\\nTime Limit Exceeded\\n\\nLast Executed Input\\n\\n141/141 testcases passed\\n\\nUse Testcase\\n\\nWhat am I supposed to do ?"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for June, Day 16.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/longest-palindromic-substring/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 5 approaches in the official solution</summary>\n\n  \n**Approach 1:** Longest Common Substring\n\n  \n**Approach 2:** Brute Force\n\n  \n**Approach 3:** Dynamic Programming\n\n  \n**Approach 4:** Expand Around Center\n\n  \n**Approach 5:** Manacher's Algorithm\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "AlgoEngine",
                        "content": "Visualization of \"Expand from Centers\" solution:\n\nhttps://youtu.be/E-tmN1OM9aA"
                    },
                    {
                        "username": "vitalik11087625",
                        "content": "\"000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000..\\n\\nPiece of shit, on submit its doent work, but when i test it myself, its work))))))))))))))))))"
                    },
                    {
                        "username": "NileshKumarGupta",
                        "content": "![image](https://assets.leetcode.com/users/images/d4d76bca-4918-4afc-8fb2-8f24506cab22_1598198725.4986076.png)\\nThe test case shows time limit exceeded but it runs fine locally with 180ms. Why is this error?"
                    },
                    {
                        "username": "amanmaurya8419",
                        "content": "Try to Think with two Pointer Approach because we have to give solution of O(N^2) so normal brute force is not applicable. \\n\\nthink i that way to take element as center and check for left and right of center if left and right element are equal then check for further  else no palindrome found between left and right index"
                    }
                ]
            },
            {
                "id": 1573820,
                "content": [
                    {
                        "username": "dword",
                        "content": "Algorithm A: \"Expand Around Center\" (approach 4 described in the solution).\\nO(n) best case (string contains no palindromes).\\nO(n^2) worst case (string consists of one repeated character).\\n\\nAlgorithm B: modified version of algorithm A that looks ahead to the end of a substring consisting of one repeated character, and expands around the whole substring, avoiding the effort of expanding around each position within the substring.\\nO(n) best case (string consists of one repeated character).\\nO(n^2) worst case (string consists of two alternating characters, like \"ababab\".)\\n\\nAlgorithm C: Manacher\\'s.\\nO(n) best and worst case.\\n\\nImplemented in C++, algorithm A runs in 44 ms, while algorithms B and C both run in 4 ms. Apparently, algorithm A is encountering its worst case but algorithm B is not.\\n\\nSure enough, when tested on \"ab\" repeated 5,000 times, algorithms A and B both run in ~100 ms and algorithm C runs in ~0 ms.\\n\\nSo it appears that in the test cases, there\\'s a long string of one repeated character but no similarly long string of two alternating characters.\\n\\nJust something I find interesting."
                    },
                    {
                        "username": "Ab__23",
                        "content": "I would like to report a bug here that, my solution runs successfully on all except the last testcase. When it shows that test case failed, I looked and found that the test case was empty, I mean such a minor bug in test case checking caused bad effect on my accuracy. Please remove the last test case. :("
                    },
                    {
                        "username": "timewaster69",
                        "content": "agreed. it also directly contradicts the two constraints given in the problem. Even if you were to write a testcase accounting for an empty string it still does not work for some reason."
                    },
                    {
                        "username": "martinvilche98",
                        "content": "\"Time Limit Exceeded\" On Passing solution...\\n\\nHonestly sounds like an excuse to reduce server load."
                    },
                    {
                        "username": "showtroylove",
                        "content": "Key to this task is avoiding string operations in your solution.  It can save you enormous time and avoids the TLE error.  Going one by one or using two loops stripping on char off the front or back doesn\\'t matter.  Reduce it all to int operations and it simplifies the task immensely.  That\\'s my two cents and I\\'m sticking with it. Cheers!"
                    },
                    {
                        "username": "ahtisham225ali",
                        "content": "The Simple Solution to the Problem in python is here https://hecodesit.com/longest-palindromic-substring-solution-python-leetcode/\\n"
                    },
                    {
                        "username": "0Camus0",
                        "content": "Hi, \\n\\nMany Manacher\\u2019s Algorithm implementation threads over the internet, but they always handle the even string case as:\\n\\n\"We just add $ to the string before and after, so baba would be $b$a$b$a$ and now we can have this case working too...\"\\n\\nBut it\\'s kind of defeating the purpose of having a O(n) time complexity, because you are doing another O(n) just to add the $, and then another O(n) to remove the $ for the even case. \\n\\nMaybe there is another Manchester\\'s implementation that doesn\\'t require that tricky \"add $\" in order to work.\\n\\nFor my solution I had two pases, one for the even and one for the odd, but I feel dumb when I see solutions from other people.. still 14 ms."
                    },
                    {
                        "username": "kshitij_sanghvi",
                        "content": "For folks getting a TLE. There are certain optimisations that work which would not work for smaller inputs.\\nIf you think about it logically the constant in dictionary look up is substantially higher that that of a list look up. However, we need to create a list and initialise it. This is where the constant in dictionary look up is traded off by default dict.\\n"
                    },
                    {
                        "username": "office93662",
                        "content": "Could someone help me understand how the time complexity is o(n^3) for the brute force?"
                    },
                    {
                        "username": "annen",
                        "content": "There are O(N^2) sub-strings. Checking whether a string is a palindrome is O(N). So O(N^3)"
                    },
                    {
                        "username": "infoie",
                        "content": "O(n3) runtime, O(1) space \\u2013 Brute force:\\nThe obvious brute force solution is to pick all possible starting and ending positions for a substring, and verify if it is a palindrome. There are a total of such substrings (excluding the trivial solution where a character itself is a palindrome).\\nSince verifying each substring takes O(n) time, the run time complexity is O(n3).\\n![image](https://assets.leetcode.com/users/infoie/image_1576132859.png)\\n\\nO(n2) runtime, O(n) space \\u2013 Dynamic programming:\\nTo improve over the brute force solution from a DP approach, first think how we can avoid unnecessary re-computation in validating palindromes. Consider the case \\u201Cababa\\u201D.\\nIf we already knew that \\u201Cbab\\u201D is a palindrome, it is obvious that \\u201Cababa\\u201D must be a palindrome since the two left and right end letters are the same.\\nStated more formally below:\\n\\tDefine P[ i, j ] \\u2190 true if the substring Si \\u2026 Sj is a palindrome, otherwise false.\\n\\tTherefore,\\n\\tP[ i, j ] \\u2190 ( P[ i+1, j-1 ] and Si = Sj )\\n\\tThe base cases are:\\n\\tP[ i, i ] \\u2190 true\\n\\tP[ i, i+1 ] \\u2190 ( Si = Si+1 )\\nThis yields a straight forward DP solution, which we first initialize the one and two letters palindromes, and work our way up finding all three letters palindromes, and so on\\u2026\\nThis gives us a runtime complexity of O(n2) and uses O(n2) space to store the table.\\n![image](https://assets.leetcode.com/users/infoie/image_1576132896.png)\\n\\nO(n2) runtime, O(1) space \\u2013 Simpler solution:\\nIn fact, we could solve it in O(n2) time using only constant space.\\nWe observe that a palindrome mirrors around its center. Therefore, a palindrome can be expanded from its center, and there are only 2n \\u2013 1 such centers.\\nYou might be asking why there are 2n \\u2013 1 but not n centers? The reason is the center of a palindrome can be in between two letters. Such palindromes have even number of letters (such as \\u201Cabba\\u201D) and its center are between the two \\u2018b\\u2019s.\\nSince expanding a palindrome around its center could take O(n) time, the overall complexity is O(n2).\\n![image](https://assets.leetcode.com/users/infoie/image_1576132950.png)\\n\\nO(n) runtime, O(n) space \\u2013 Manacher\\u2019s algorithm:\\n![image](https://assets.leetcode.com/users/infoie/image_1576132981.png)\\n"
                    },
                    {
                        "username": "luo980",
                        "content": "![alt text]![0_1499137449406_8cb1c4ff-b5a3-46f1-9aeb-eed2e7012534-image.png](/assets/uploads/files/1499137454573-8cb1c4ff-b5a3-46f1-9aeb-eed2e7012534-image-resized.png) \\nHow should i deal with this problem?"
                    }
                ]
            },
            {
                "id": 1971133,
                "content": [
                    {
                        "username": "dword",
                        "content": "Algorithm A: \"Expand Around Center\" (approach 4 described in the solution).\\nO(n) best case (string contains no palindromes).\\nO(n^2) worst case (string consists of one repeated character).\\n\\nAlgorithm B: modified version of algorithm A that looks ahead to the end of a substring consisting of one repeated character, and expands around the whole substring, avoiding the effort of expanding around each position within the substring.\\nO(n) best case (string consists of one repeated character).\\nO(n^2) worst case (string consists of two alternating characters, like \"ababab\".)\\n\\nAlgorithm C: Manacher\\'s.\\nO(n) best and worst case.\\n\\nImplemented in C++, algorithm A runs in 44 ms, while algorithms B and C both run in 4 ms. Apparently, algorithm A is encountering its worst case but algorithm B is not.\\n\\nSure enough, when tested on \"ab\" repeated 5,000 times, algorithms A and B both run in ~100 ms and algorithm C runs in ~0 ms.\\n\\nSo it appears that in the test cases, there\\'s a long string of one repeated character but no similarly long string of two alternating characters.\\n\\nJust something I find interesting."
                    },
                    {
                        "username": "Ab__23",
                        "content": "I would like to report a bug here that, my solution runs successfully on all except the last testcase. When it shows that test case failed, I looked and found that the test case was empty, I mean such a minor bug in test case checking caused bad effect on my accuracy. Please remove the last test case. :("
                    },
                    {
                        "username": "timewaster69",
                        "content": "agreed. it also directly contradicts the two constraints given in the problem. Even if you were to write a testcase accounting for an empty string it still does not work for some reason."
                    },
                    {
                        "username": "martinvilche98",
                        "content": "\"Time Limit Exceeded\" On Passing solution...\\n\\nHonestly sounds like an excuse to reduce server load."
                    },
                    {
                        "username": "showtroylove",
                        "content": "Key to this task is avoiding string operations in your solution.  It can save you enormous time and avoids the TLE error.  Going one by one or using two loops stripping on char off the front or back doesn\\'t matter.  Reduce it all to int operations and it simplifies the task immensely.  That\\'s my two cents and I\\'m sticking with it. Cheers!"
                    },
                    {
                        "username": "ahtisham225ali",
                        "content": "The Simple Solution to the Problem in python is here https://hecodesit.com/longest-palindromic-substring-solution-python-leetcode/\\n"
                    },
                    {
                        "username": "0Camus0",
                        "content": "Hi, \\n\\nMany Manacher\\u2019s Algorithm implementation threads over the internet, but they always handle the even string case as:\\n\\n\"We just add $ to the string before and after, so baba would be $b$a$b$a$ and now we can have this case working too...\"\\n\\nBut it\\'s kind of defeating the purpose of having a O(n) time complexity, because you are doing another O(n) just to add the $, and then another O(n) to remove the $ for the even case. \\n\\nMaybe there is another Manchester\\'s implementation that doesn\\'t require that tricky \"add $\" in order to work.\\n\\nFor my solution I had two pases, one for the even and one for the odd, but I feel dumb when I see solutions from other people.. still 14 ms."
                    },
                    {
                        "username": "kshitij_sanghvi",
                        "content": "For folks getting a TLE. There are certain optimisations that work which would not work for smaller inputs.\\nIf you think about it logically the constant in dictionary look up is substantially higher that that of a list look up. However, we need to create a list and initialise it. This is where the constant in dictionary look up is traded off by default dict.\\n"
                    },
                    {
                        "username": "office93662",
                        "content": "Could someone help me understand how the time complexity is o(n^3) for the brute force?"
                    },
                    {
                        "username": "annen",
                        "content": "There are O(N^2) sub-strings. Checking whether a string is a palindrome is O(N). So O(N^3)"
                    },
                    {
                        "username": "infoie",
                        "content": "O(n3) runtime, O(1) space \\u2013 Brute force:\\nThe obvious brute force solution is to pick all possible starting and ending positions for a substring, and verify if it is a palindrome. There are a total of such substrings (excluding the trivial solution where a character itself is a palindrome).\\nSince verifying each substring takes O(n) time, the run time complexity is O(n3).\\n![image](https://assets.leetcode.com/users/infoie/image_1576132859.png)\\n\\nO(n2) runtime, O(n) space \\u2013 Dynamic programming:\\nTo improve over the brute force solution from a DP approach, first think how we can avoid unnecessary re-computation in validating palindromes. Consider the case \\u201Cababa\\u201D.\\nIf we already knew that \\u201Cbab\\u201D is a palindrome, it is obvious that \\u201Cababa\\u201D must be a palindrome since the two left and right end letters are the same.\\nStated more formally below:\\n\\tDefine P[ i, j ] \\u2190 true if the substring Si \\u2026 Sj is a palindrome, otherwise false.\\n\\tTherefore,\\n\\tP[ i, j ] \\u2190 ( P[ i+1, j-1 ] and Si = Sj )\\n\\tThe base cases are:\\n\\tP[ i, i ] \\u2190 true\\n\\tP[ i, i+1 ] \\u2190 ( Si = Si+1 )\\nThis yields a straight forward DP solution, which we first initialize the one and two letters palindromes, and work our way up finding all three letters palindromes, and so on\\u2026\\nThis gives us a runtime complexity of O(n2) and uses O(n2) space to store the table.\\n![image](https://assets.leetcode.com/users/infoie/image_1576132896.png)\\n\\nO(n2) runtime, O(1) space \\u2013 Simpler solution:\\nIn fact, we could solve it in O(n2) time using only constant space.\\nWe observe that a palindrome mirrors around its center. Therefore, a palindrome can be expanded from its center, and there are only 2n \\u2013 1 such centers.\\nYou might be asking why there are 2n \\u2013 1 but not n centers? The reason is the center of a palindrome can be in between two letters. Such palindromes have even number of letters (such as \\u201Cabba\\u201D) and its center are between the two \\u2018b\\u2019s.\\nSince expanding a palindrome around its center could take O(n) time, the overall complexity is O(n2).\\n![image](https://assets.leetcode.com/users/infoie/image_1576132950.png)\\n\\nO(n) runtime, O(n) space \\u2013 Manacher\\u2019s algorithm:\\n![image](https://assets.leetcode.com/users/infoie/image_1576132981.png)\\n"
                    },
                    {
                        "username": "luo980",
                        "content": "![alt text]![0_1499137449406_8cb1c4ff-b5a3-46f1-9aeb-eed2e7012534-image.png](/assets/uploads/files/1499137454573-8cb1c4ff-b5a3-46f1-9aeb-eed2e7012534-image-resized.png) \\nHow should i deal with this problem?"
                    }
                ]
            },
            {
                "id": 1939934,
                "content": [
                    {
                        "username": "dword",
                        "content": "Algorithm A: \"Expand Around Center\" (approach 4 described in the solution).\\nO(n) best case (string contains no palindromes).\\nO(n^2) worst case (string consists of one repeated character).\\n\\nAlgorithm B: modified version of algorithm A that looks ahead to the end of a substring consisting of one repeated character, and expands around the whole substring, avoiding the effort of expanding around each position within the substring.\\nO(n) best case (string consists of one repeated character).\\nO(n^2) worst case (string consists of two alternating characters, like \"ababab\".)\\n\\nAlgorithm C: Manacher\\'s.\\nO(n) best and worst case.\\n\\nImplemented in C++, algorithm A runs in 44 ms, while algorithms B and C both run in 4 ms. Apparently, algorithm A is encountering its worst case but algorithm B is not.\\n\\nSure enough, when tested on \"ab\" repeated 5,000 times, algorithms A and B both run in ~100 ms and algorithm C runs in ~0 ms.\\n\\nSo it appears that in the test cases, there\\'s a long string of one repeated character but no similarly long string of two alternating characters.\\n\\nJust something I find interesting."
                    },
                    {
                        "username": "Ab__23",
                        "content": "I would like to report a bug here that, my solution runs successfully on all except the last testcase. When it shows that test case failed, I looked and found that the test case was empty, I mean such a minor bug in test case checking caused bad effect on my accuracy. Please remove the last test case. :("
                    },
                    {
                        "username": "timewaster69",
                        "content": "agreed. it also directly contradicts the two constraints given in the problem. Even if you were to write a testcase accounting for an empty string it still does not work for some reason."
                    },
                    {
                        "username": "martinvilche98",
                        "content": "\"Time Limit Exceeded\" On Passing solution...\\n\\nHonestly sounds like an excuse to reduce server load."
                    },
                    {
                        "username": "showtroylove",
                        "content": "Key to this task is avoiding string operations in your solution.  It can save you enormous time and avoids the TLE error.  Going one by one or using two loops stripping on char off the front or back doesn\\'t matter.  Reduce it all to int operations and it simplifies the task immensely.  That\\'s my two cents and I\\'m sticking with it. Cheers!"
                    },
                    {
                        "username": "ahtisham225ali",
                        "content": "The Simple Solution to the Problem in python is here https://hecodesit.com/longest-palindromic-substring-solution-python-leetcode/\\n"
                    },
                    {
                        "username": "0Camus0",
                        "content": "Hi, \\n\\nMany Manacher\\u2019s Algorithm implementation threads over the internet, but they always handle the even string case as:\\n\\n\"We just add $ to the string before and after, so baba would be $b$a$b$a$ and now we can have this case working too...\"\\n\\nBut it\\'s kind of defeating the purpose of having a O(n) time complexity, because you are doing another O(n) just to add the $, and then another O(n) to remove the $ for the even case. \\n\\nMaybe there is another Manchester\\'s implementation that doesn\\'t require that tricky \"add $\" in order to work.\\n\\nFor my solution I had two pases, one for the even and one for the odd, but I feel dumb when I see solutions from other people.. still 14 ms."
                    },
                    {
                        "username": "kshitij_sanghvi",
                        "content": "For folks getting a TLE. There are certain optimisations that work which would not work for smaller inputs.\\nIf you think about it logically the constant in dictionary look up is substantially higher that that of a list look up. However, we need to create a list and initialise it. This is where the constant in dictionary look up is traded off by default dict.\\n"
                    },
                    {
                        "username": "office93662",
                        "content": "Could someone help me understand how the time complexity is o(n^3) for the brute force?"
                    },
                    {
                        "username": "annen",
                        "content": "There are O(N^2) sub-strings. Checking whether a string is a palindrome is O(N). So O(N^3)"
                    },
                    {
                        "username": "infoie",
                        "content": "O(n3) runtime, O(1) space \\u2013 Brute force:\\nThe obvious brute force solution is to pick all possible starting and ending positions for a substring, and verify if it is a palindrome. There are a total of such substrings (excluding the trivial solution where a character itself is a palindrome).\\nSince verifying each substring takes O(n) time, the run time complexity is O(n3).\\n![image](https://assets.leetcode.com/users/infoie/image_1576132859.png)\\n\\nO(n2) runtime, O(n) space \\u2013 Dynamic programming:\\nTo improve over the brute force solution from a DP approach, first think how we can avoid unnecessary re-computation in validating palindromes. Consider the case \\u201Cababa\\u201D.\\nIf we already knew that \\u201Cbab\\u201D is a palindrome, it is obvious that \\u201Cababa\\u201D must be a palindrome since the two left and right end letters are the same.\\nStated more formally below:\\n\\tDefine P[ i, j ] \\u2190 true if the substring Si \\u2026 Sj is a palindrome, otherwise false.\\n\\tTherefore,\\n\\tP[ i, j ] \\u2190 ( P[ i+1, j-1 ] and Si = Sj )\\n\\tThe base cases are:\\n\\tP[ i, i ] \\u2190 true\\n\\tP[ i, i+1 ] \\u2190 ( Si = Si+1 )\\nThis yields a straight forward DP solution, which we first initialize the one and two letters palindromes, and work our way up finding all three letters palindromes, and so on\\u2026\\nThis gives us a runtime complexity of O(n2) and uses O(n2) space to store the table.\\n![image](https://assets.leetcode.com/users/infoie/image_1576132896.png)\\n\\nO(n2) runtime, O(1) space \\u2013 Simpler solution:\\nIn fact, we could solve it in O(n2) time using only constant space.\\nWe observe that a palindrome mirrors around its center. Therefore, a palindrome can be expanded from its center, and there are only 2n \\u2013 1 such centers.\\nYou might be asking why there are 2n \\u2013 1 but not n centers? The reason is the center of a palindrome can be in between two letters. Such palindromes have even number of letters (such as \\u201Cabba\\u201D) and its center are between the two \\u2018b\\u2019s.\\nSince expanding a palindrome around its center could take O(n) time, the overall complexity is O(n2).\\n![image](https://assets.leetcode.com/users/infoie/image_1576132950.png)\\n\\nO(n) runtime, O(n) space \\u2013 Manacher\\u2019s algorithm:\\n![image](https://assets.leetcode.com/users/infoie/image_1576132981.png)\\n"
                    },
                    {
                        "username": "luo980",
                        "content": "![alt text]![0_1499137449406_8cb1c4ff-b5a3-46f1-9aeb-eed2e7012534-image.png](/assets/uploads/files/1499137454573-8cb1c4ff-b5a3-46f1-9aeb-eed2e7012534-image-resized.png) \\nHow should i deal with this problem?"
                    }
                ]
            },
            {
                "id": 1654221,
                "content": [
                    {
                        "username": "dword",
                        "content": "Algorithm A: \"Expand Around Center\" (approach 4 described in the solution).\\nO(n) best case (string contains no palindromes).\\nO(n^2) worst case (string consists of one repeated character).\\n\\nAlgorithm B: modified version of algorithm A that looks ahead to the end of a substring consisting of one repeated character, and expands around the whole substring, avoiding the effort of expanding around each position within the substring.\\nO(n) best case (string consists of one repeated character).\\nO(n^2) worst case (string consists of two alternating characters, like \"ababab\".)\\n\\nAlgorithm C: Manacher\\'s.\\nO(n) best and worst case.\\n\\nImplemented in C++, algorithm A runs in 44 ms, while algorithms B and C both run in 4 ms. Apparently, algorithm A is encountering its worst case but algorithm B is not.\\n\\nSure enough, when tested on \"ab\" repeated 5,000 times, algorithms A and B both run in ~100 ms and algorithm C runs in ~0 ms.\\n\\nSo it appears that in the test cases, there\\'s a long string of one repeated character but no similarly long string of two alternating characters.\\n\\nJust something I find interesting."
                    },
                    {
                        "username": "Ab__23",
                        "content": "I would like to report a bug here that, my solution runs successfully on all except the last testcase. When it shows that test case failed, I looked and found that the test case was empty, I mean such a minor bug in test case checking caused bad effect on my accuracy. Please remove the last test case. :("
                    },
                    {
                        "username": "timewaster69",
                        "content": "agreed. it also directly contradicts the two constraints given in the problem. Even if you were to write a testcase accounting for an empty string it still does not work for some reason."
                    },
                    {
                        "username": "martinvilche98",
                        "content": "\"Time Limit Exceeded\" On Passing solution...\\n\\nHonestly sounds like an excuse to reduce server load."
                    },
                    {
                        "username": "showtroylove",
                        "content": "Key to this task is avoiding string operations in your solution.  It can save you enormous time and avoids the TLE error.  Going one by one or using two loops stripping on char off the front or back doesn\\'t matter.  Reduce it all to int operations and it simplifies the task immensely.  That\\'s my two cents and I\\'m sticking with it. Cheers!"
                    },
                    {
                        "username": "ahtisham225ali",
                        "content": "The Simple Solution to the Problem in python is here https://hecodesit.com/longest-palindromic-substring-solution-python-leetcode/\\n"
                    },
                    {
                        "username": "0Camus0",
                        "content": "Hi, \\n\\nMany Manacher\\u2019s Algorithm implementation threads over the internet, but they always handle the even string case as:\\n\\n\"We just add $ to the string before and after, so baba would be $b$a$b$a$ and now we can have this case working too...\"\\n\\nBut it\\'s kind of defeating the purpose of having a O(n) time complexity, because you are doing another O(n) just to add the $, and then another O(n) to remove the $ for the even case. \\n\\nMaybe there is another Manchester\\'s implementation that doesn\\'t require that tricky \"add $\" in order to work.\\n\\nFor my solution I had two pases, one for the even and one for the odd, but I feel dumb when I see solutions from other people.. still 14 ms."
                    },
                    {
                        "username": "kshitij_sanghvi",
                        "content": "For folks getting a TLE. There are certain optimisations that work which would not work for smaller inputs.\\nIf you think about it logically the constant in dictionary look up is substantially higher that that of a list look up. However, we need to create a list and initialise it. This is where the constant in dictionary look up is traded off by default dict.\\n"
                    },
                    {
                        "username": "office93662",
                        "content": "Could someone help me understand how the time complexity is o(n^3) for the brute force?"
                    },
                    {
                        "username": "annen",
                        "content": "There are O(N^2) sub-strings. Checking whether a string is a palindrome is O(N). So O(N^3)"
                    },
                    {
                        "username": "infoie",
                        "content": "O(n3) runtime, O(1) space \\u2013 Brute force:\\nThe obvious brute force solution is to pick all possible starting and ending positions for a substring, and verify if it is a palindrome. There are a total of such substrings (excluding the trivial solution where a character itself is a palindrome).\\nSince verifying each substring takes O(n) time, the run time complexity is O(n3).\\n![image](https://assets.leetcode.com/users/infoie/image_1576132859.png)\\n\\nO(n2) runtime, O(n) space \\u2013 Dynamic programming:\\nTo improve over the brute force solution from a DP approach, first think how we can avoid unnecessary re-computation in validating palindromes. Consider the case \\u201Cababa\\u201D.\\nIf we already knew that \\u201Cbab\\u201D is a palindrome, it is obvious that \\u201Cababa\\u201D must be a palindrome since the two left and right end letters are the same.\\nStated more formally below:\\n\\tDefine P[ i, j ] \\u2190 true if the substring Si \\u2026 Sj is a palindrome, otherwise false.\\n\\tTherefore,\\n\\tP[ i, j ] \\u2190 ( P[ i+1, j-1 ] and Si = Sj )\\n\\tThe base cases are:\\n\\tP[ i, i ] \\u2190 true\\n\\tP[ i, i+1 ] \\u2190 ( Si = Si+1 )\\nThis yields a straight forward DP solution, which we first initialize the one and two letters palindromes, and work our way up finding all three letters palindromes, and so on\\u2026\\nThis gives us a runtime complexity of O(n2) and uses O(n2) space to store the table.\\n![image](https://assets.leetcode.com/users/infoie/image_1576132896.png)\\n\\nO(n2) runtime, O(1) space \\u2013 Simpler solution:\\nIn fact, we could solve it in O(n2) time using only constant space.\\nWe observe that a palindrome mirrors around its center. Therefore, a palindrome can be expanded from its center, and there are only 2n \\u2013 1 such centers.\\nYou might be asking why there are 2n \\u2013 1 but not n centers? The reason is the center of a palindrome can be in between two letters. Such palindromes have even number of letters (such as \\u201Cabba\\u201D) and its center are between the two \\u2018b\\u2019s.\\nSince expanding a palindrome around its center could take O(n) time, the overall complexity is O(n2).\\n![image](https://assets.leetcode.com/users/infoie/image_1576132950.png)\\n\\nO(n) runtime, O(n) space \\u2013 Manacher\\u2019s algorithm:\\n![image](https://assets.leetcode.com/users/infoie/image_1576132981.png)\\n"
                    },
                    {
                        "username": "luo980",
                        "content": "![alt text]![0_1499137449406_8cb1c4ff-b5a3-46f1-9aeb-eed2e7012534-image.png](/assets/uploads/files/1499137454573-8cb1c4ff-b5a3-46f1-9aeb-eed2e7012534-image-resized.png) \\nHow should i deal with this problem?"
                    }
                ]
            },
            {
                "id": 1570831,
                "content": [
                    {
                        "username": "dword",
                        "content": "Algorithm A: \"Expand Around Center\" (approach 4 described in the solution).\\nO(n) best case (string contains no palindromes).\\nO(n^2) worst case (string consists of one repeated character).\\n\\nAlgorithm B: modified version of algorithm A that looks ahead to the end of a substring consisting of one repeated character, and expands around the whole substring, avoiding the effort of expanding around each position within the substring.\\nO(n) best case (string consists of one repeated character).\\nO(n^2) worst case (string consists of two alternating characters, like \"ababab\".)\\n\\nAlgorithm C: Manacher\\'s.\\nO(n) best and worst case.\\n\\nImplemented in C++, algorithm A runs in 44 ms, while algorithms B and C both run in 4 ms. Apparently, algorithm A is encountering its worst case but algorithm B is not.\\n\\nSure enough, when tested on \"ab\" repeated 5,000 times, algorithms A and B both run in ~100 ms and algorithm C runs in ~0 ms.\\n\\nSo it appears that in the test cases, there\\'s a long string of one repeated character but no similarly long string of two alternating characters.\\n\\nJust something I find interesting."
                    },
                    {
                        "username": "Ab__23",
                        "content": "I would like to report a bug here that, my solution runs successfully on all except the last testcase. When it shows that test case failed, I looked and found that the test case was empty, I mean such a minor bug in test case checking caused bad effect on my accuracy. Please remove the last test case. :("
                    },
                    {
                        "username": "timewaster69",
                        "content": "agreed. it also directly contradicts the two constraints given in the problem. Even if you were to write a testcase accounting for an empty string it still does not work for some reason."
                    },
                    {
                        "username": "martinvilche98",
                        "content": "\"Time Limit Exceeded\" On Passing solution...\\n\\nHonestly sounds like an excuse to reduce server load."
                    },
                    {
                        "username": "showtroylove",
                        "content": "Key to this task is avoiding string operations in your solution.  It can save you enormous time and avoids the TLE error.  Going one by one or using two loops stripping on char off the front or back doesn\\'t matter.  Reduce it all to int operations and it simplifies the task immensely.  That\\'s my two cents and I\\'m sticking with it. Cheers!"
                    },
                    {
                        "username": "ahtisham225ali",
                        "content": "The Simple Solution to the Problem in python is here https://hecodesit.com/longest-palindromic-substring-solution-python-leetcode/\\n"
                    },
                    {
                        "username": "0Camus0",
                        "content": "Hi, \\n\\nMany Manacher\\u2019s Algorithm implementation threads over the internet, but they always handle the even string case as:\\n\\n\"We just add $ to the string before and after, so baba would be $b$a$b$a$ and now we can have this case working too...\"\\n\\nBut it\\'s kind of defeating the purpose of having a O(n) time complexity, because you are doing another O(n) just to add the $, and then another O(n) to remove the $ for the even case. \\n\\nMaybe there is another Manchester\\'s implementation that doesn\\'t require that tricky \"add $\" in order to work.\\n\\nFor my solution I had two pases, one for the even and one for the odd, but I feel dumb when I see solutions from other people.. still 14 ms."
                    },
                    {
                        "username": "kshitij_sanghvi",
                        "content": "For folks getting a TLE. There are certain optimisations that work which would not work for smaller inputs.\\nIf you think about it logically the constant in dictionary look up is substantially higher that that of a list look up. However, we need to create a list and initialise it. This is where the constant in dictionary look up is traded off by default dict.\\n"
                    },
                    {
                        "username": "office93662",
                        "content": "Could someone help me understand how the time complexity is o(n^3) for the brute force?"
                    },
                    {
                        "username": "annen",
                        "content": "There are O(N^2) sub-strings. Checking whether a string is a palindrome is O(N). So O(N^3)"
                    },
                    {
                        "username": "infoie",
                        "content": "O(n3) runtime, O(1) space \\u2013 Brute force:\\nThe obvious brute force solution is to pick all possible starting and ending positions for a substring, and verify if it is a palindrome. There are a total of such substrings (excluding the trivial solution where a character itself is a palindrome).\\nSince verifying each substring takes O(n) time, the run time complexity is O(n3).\\n![image](https://assets.leetcode.com/users/infoie/image_1576132859.png)\\n\\nO(n2) runtime, O(n) space \\u2013 Dynamic programming:\\nTo improve over the brute force solution from a DP approach, first think how we can avoid unnecessary re-computation in validating palindromes. Consider the case \\u201Cababa\\u201D.\\nIf we already knew that \\u201Cbab\\u201D is a palindrome, it is obvious that \\u201Cababa\\u201D must be a palindrome since the two left and right end letters are the same.\\nStated more formally below:\\n\\tDefine P[ i, j ] \\u2190 true if the substring Si \\u2026 Sj is a palindrome, otherwise false.\\n\\tTherefore,\\n\\tP[ i, j ] \\u2190 ( P[ i+1, j-1 ] and Si = Sj )\\n\\tThe base cases are:\\n\\tP[ i, i ] \\u2190 true\\n\\tP[ i, i+1 ] \\u2190 ( Si = Si+1 )\\nThis yields a straight forward DP solution, which we first initialize the one and two letters palindromes, and work our way up finding all three letters palindromes, and so on\\u2026\\nThis gives us a runtime complexity of O(n2) and uses O(n2) space to store the table.\\n![image](https://assets.leetcode.com/users/infoie/image_1576132896.png)\\n\\nO(n2) runtime, O(1) space \\u2013 Simpler solution:\\nIn fact, we could solve it in O(n2) time using only constant space.\\nWe observe that a palindrome mirrors around its center. Therefore, a palindrome can be expanded from its center, and there are only 2n \\u2013 1 such centers.\\nYou might be asking why there are 2n \\u2013 1 but not n centers? The reason is the center of a palindrome can be in between two letters. Such palindromes have even number of letters (such as \\u201Cabba\\u201D) and its center are between the two \\u2018b\\u2019s.\\nSince expanding a palindrome around its center could take O(n) time, the overall complexity is O(n2).\\n![image](https://assets.leetcode.com/users/infoie/image_1576132950.png)\\n\\nO(n) runtime, O(n) space \\u2013 Manacher\\u2019s algorithm:\\n![image](https://assets.leetcode.com/users/infoie/image_1576132981.png)\\n"
                    },
                    {
                        "username": "luo980",
                        "content": "![alt text]![0_1499137449406_8cb1c4ff-b5a3-46f1-9aeb-eed2e7012534-image.png](/assets/uploads/files/1499137454573-8cb1c4ff-b5a3-46f1-9aeb-eed2e7012534-image-resized.png) \\nHow should i deal with this problem?"
                    }
                ]
            },
            {
                "id": 1576462,
                "content": [
                    {
                        "username": "dword",
                        "content": "Algorithm A: \"Expand Around Center\" (approach 4 described in the solution).\\nO(n) best case (string contains no palindromes).\\nO(n^2) worst case (string consists of one repeated character).\\n\\nAlgorithm B: modified version of algorithm A that looks ahead to the end of a substring consisting of one repeated character, and expands around the whole substring, avoiding the effort of expanding around each position within the substring.\\nO(n) best case (string consists of one repeated character).\\nO(n^2) worst case (string consists of two alternating characters, like \"ababab\".)\\n\\nAlgorithm C: Manacher\\'s.\\nO(n) best and worst case.\\n\\nImplemented in C++, algorithm A runs in 44 ms, while algorithms B and C both run in 4 ms. Apparently, algorithm A is encountering its worst case but algorithm B is not.\\n\\nSure enough, when tested on \"ab\" repeated 5,000 times, algorithms A and B both run in ~100 ms and algorithm C runs in ~0 ms.\\n\\nSo it appears that in the test cases, there\\'s a long string of one repeated character but no similarly long string of two alternating characters.\\n\\nJust something I find interesting."
                    },
                    {
                        "username": "Ab__23",
                        "content": "I would like to report a bug here that, my solution runs successfully on all except the last testcase. When it shows that test case failed, I looked and found that the test case was empty, I mean such a minor bug in test case checking caused bad effect on my accuracy. Please remove the last test case. :("
                    },
                    {
                        "username": "timewaster69",
                        "content": "agreed. it also directly contradicts the two constraints given in the problem. Even if you were to write a testcase accounting for an empty string it still does not work for some reason."
                    },
                    {
                        "username": "martinvilche98",
                        "content": "\"Time Limit Exceeded\" On Passing solution...\\n\\nHonestly sounds like an excuse to reduce server load."
                    },
                    {
                        "username": "showtroylove",
                        "content": "Key to this task is avoiding string operations in your solution.  It can save you enormous time and avoids the TLE error.  Going one by one or using two loops stripping on char off the front or back doesn\\'t matter.  Reduce it all to int operations and it simplifies the task immensely.  That\\'s my two cents and I\\'m sticking with it. Cheers!"
                    },
                    {
                        "username": "ahtisham225ali",
                        "content": "The Simple Solution to the Problem in python is here https://hecodesit.com/longest-palindromic-substring-solution-python-leetcode/\\n"
                    },
                    {
                        "username": "0Camus0",
                        "content": "Hi, \\n\\nMany Manacher\\u2019s Algorithm implementation threads over the internet, but they always handle the even string case as:\\n\\n\"We just add $ to the string before and after, so baba would be $b$a$b$a$ and now we can have this case working too...\"\\n\\nBut it\\'s kind of defeating the purpose of having a O(n) time complexity, because you are doing another O(n) just to add the $, and then another O(n) to remove the $ for the even case. \\n\\nMaybe there is another Manchester\\'s implementation that doesn\\'t require that tricky \"add $\" in order to work.\\n\\nFor my solution I had two pases, one for the even and one for the odd, but I feel dumb when I see solutions from other people.. still 14 ms."
                    },
                    {
                        "username": "kshitij_sanghvi",
                        "content": "For folks getting a TLE. There are certain optimisations that work which would not work for smaller inputs.\\nIf you think about it logically the constant in dictionary look up is substantially higher that that of a list look up. However, we need to create a list and initialise it. This is where the constant in dictionary look up is traded off by default dict.\\n"
                    },
                    {
                        "username": "office93662",
                        "content": "Could someone help me understand how the time complexity is o(n^3) for the brute force?"
                    },
                    {
                        "username": "annen",
                        "content": "There are O(N^2) sub-strings. Checking whether a string is a palindrome is O(N). So O(N^3)"
                    },
                    {
                        "username": "infoie",
                        "content": "O(n3) runtime, O(1) space \\u2013 Brute force:\\nThe obvious brute force solution is to pick all possible starting and ending positions for a substring, and verify if it is a palindrome. There are a total of such substrings (excluding the trivial solution where a character itself is a palindrome).\\nSince verifying each substring takes O(n) time, the run time complexity is O(n3).\\n![image](https://assets.leetcode.com/users/infoie/image_1576132859.png)\\n\\nO(n2) runtime, O(n) space \\u2013 Dynamic programming:\\nTo improve over the brute force solution from a DP approach, first think how we can avoid unnecessary re-computation in validating palindromes. Consider the case \\u201Cababa\\u201D.\\nIf we already knew that \\u201Cbab\\u201D is a palindrome, it is obvious that \\u201Cababa\\u201D must be a palindrome since the two left and right end letters are the same.\\nStated more formally below:\\n\\tDefine P[ i, j ] \\u2190 true if the substring Si \\u2026 Sj is a palindrome, otherwise false.\\n\\tTherefore,\\n\\tP[ i, j ] \\u2190 ( P[ i+1, j-1 ] and Si = Sj )\\n\\tThe base cases are:\\n\\tP[ i, i ] \\u2190 true\\n\\tP[ i, i+1 ] \\u2190 ( Si = Si+1 )\\nThis yields a straight forward DP solution, which we first initialize the one and two letters palindromes, and work our way up finding all three letters palindromes, and so on\\u2026\\nThis gives us a runtime complexity of O(n2) and uses O(n2) space to store the table.\\n![image](https://assets.leetcode.com/users/infoie/image_1576132896.png)\\n\\nO(n2) runtime, O(1) space \\u2013 Simpler solution:\\nIn fact, we could solve it in O(n2) time using only constant space.\\nWe observe that a palindrome mirrors around its center. Therefore, a palindrome can be expanded from its center, and there are only 2n \\u2013 1 such centers.\\nYou might be asking why there are 2n \\u2013 1 but not n centers? The reason is the center of a palindrome can be in between two letters. Such palindromes have even number of letters (such as \\u201Cabba\\u201D) and its center are between the two \\u2018b\\u2019s.\\nSince expanding a palindrome around its center could take O(n) time, the overall complexity is O(n2).\\n![image](https://assets.leetcode.com/users/infoie/image_1576132950.png)\\n\\nO(n) runtime, O(n) space \\u2013 Manacher\\u2019s algorithm:\\n![image](https://assets.leetcode.com/users/infoie/image_1576132981.png)\\n"
                    },
                    {
                        "username": "luo980",
                        "content": "![alt text]![0_1499137449406_8cb1c4ff-b5a3-46f1-9aeb-eed2e7012534-image.png](/assets/uploads/files/1499137454573-8cb1c4ff-b5a3-46f1-9aeb-eed2e7012534-image-resized.png) \\nHow should i deal with this problem?"
                    }
                ]
            },
            {
                "id": 1576344,
                "content": [
                    {
                        "username": "dword",
                        "content": "Algorithm A: \"Expand Around Center\" (approach 4 described in the solution).\\nO(n) best case (string contains no palindromes).\\nO(n^2) worst case (string consists of one repeated character).\\n\\nAlgorithm B: modified version of algorithm A that looks ahead to the end of a substring consisting of one repeated character, and expands around the whole substring, avoiding the effort of expanding around each position within the substring.\\nO(n) best case (string consists of one repeated character).\\nO(n^2) worst case (string consists of two alternating characters, like \"ababab\".)\\n\\nAlgorithm C: Manacher\\'s.\\nO(n) best and worst case.\\n\\nImplemented in C++, algorithm A runs in 44 ms, while algorithms B and C both run in 4 ms. Apparently, algorithm A is encountering its worst case but algorithm B is not.\\n\\nSure enough, when tested on \"ab\" repeated 5,000 times, algorithms A and B both run in ~100 ms and algorithm C runs in ~0 ms.\\n\\nSo it appears that in the test cases, there\\'s a long string of one repeated character but no similarly long string of two alternating characters.\\n\\nJust something I find interesting."
                    },
                    {
                        "username": "Ab__23",
                        "content": "I would like to report a bug here that, my solution runs successfully on all except the last testcase. When it shows that test case failed, I looked and found that the test case was empty, I mean such a minor bug in test case checking caused bad effect on my accuracy. Please remove the last test case. :("
                    },
                    {
                        "username": "timewaster69",
                        "content": "agreed. it also directly contradicts the two constraints given in the problem. Even if you were to write a testcase accounting for an empty string it still does not work for some reason."
                    },
                    {
                        "username": "martinvilche98",
                        "content": "\"Time Limit Exceeded\" On Passing solution...\\n\\nHonestly sounds like an excuse to reduce server load."
                    },
                    {
                        "username": "showtroylove",
                        "content": "Key to this task is avoiding string operations in your solution.  It can save you enormous time and avoids the TLE error.  Going one by one or using two loops stripping on char off the front or back doesn\\'t matter.  Reduce it all to int operations and it simplifies the task immensely.  That\\'s my two cents and I\\'m sticking with it. Cheers!"
                    },
                    {
                        "username": "ahtisham225ali",
                        "content": "The Simple Solution to the Problem in python is here https://hecodesit.com/longest-palindromic-substring-solution-python-leetcode/\\n"
                    },
                    {
                        "username": "0Camus0",
                        "content": "Hi, \\n\\nMany Manacher\\u2019s Algorithm implementation threads over the internet, but they always handle the even string case as:\\n\\n\"We just add $ to the string before and after, so baba would be $b$a$b$a$ and now we can have this case working too...\"\\n\\nBut it\\'s kind of defeating the purpose of having a O(n) time complexity, because you are doing another O(n) just to add the $, and then another O(n) to remove the $ for the even case. \\n\\nMaybe there is another Manchester\\'s implementation that doesn\\'t require that tricky \"add $\" in order to work.\\n\\nFor my solution I had two pases, one for the even and one for the odd, but I feel dumb when I see solutions from other people.. still 14 ms."
                    },
                    {
                        "username": "kshitij_sanghvi",
                        "content": "For folks getting a TLE. There are certain optimisations that work which would not work for smaller inputs.\\nIf you think about it logically the constant in dictionary look up is substantially higher that that of a list look up. However, we need to create a list and initialise it. This is where the constant in dictionary look up is traded off by default dict.\\n"
                    },
                    {
                        "username": "office93662",
                        "content": "Could someone help me understand how the time complexity is o(n^3) for the brute force?"
                    },
                    {
                        "username": "annen",
                        "content": "There are O(N^2) sub-strings. Checking whether a string is a palindrome is O(N). So O(N^3)"
                    },
                    {
                        "username": "infoie",
                        "content": "O(n3) runtime, O(1) space \\u2013 Brute force:\\nThe obvious brute force solution is to pick all possible starting and ending positions for a substring, and verify if it is a palindrome. There are a total of such substrings (excluding the trivial solution where a character itself is a palindrome).\\nSince verifying each substring takes O(n) time, the run time complexity is O(n3).\\n![image](https://assets.leetcode.com/users/infoie/image_1576132859.png)\\n\\nO(n2) runtime, O(n) space \\u2013 Dynamic programming:\\nTo improve over the brute force solution from a DP approach, first think how we can avoid unnecessary re-computation in validating palindromes. Consider the case \\u201Cababa\\u201D.\\nIf we already knew that \\u201Cbab\\u201D is a palindrome, it is obvious that \\u201Cababa\\u201D must be a palindrome since the two left and right end letters are the same.\\nStated more formally below:\\n\\tDefine P[ i, j ] \\u2190 true if the substring Si \\u2026 Sj is a palindrome, otherwise false.\\n\\tTherefore,\\n\\tP[ i, j ] \\u2190 ( P[ i+1, j-1 ] and Si = Sj )\\n\\tThe base cases are:\\n\\tP[ i, i ] \\u2190 true\\n\\tP[ i, i+1 ] \\u2190 ( Si = Si+1 )\\nThis yields a straight forward DP solution, which we first initialize the one and two letters palindromes, and work our way up finding all three letters palindromes, and so on\\u2026\\nThis gives us a runtime complexity of O(n2) and uses O(n2) space to store the table.\\n![image](https://assets.leetcode.com/users/infoie/image_1576132896.png)\\n\\nO(n2) runtime, O(1) space \\u2013 Simpler solution:\\nIn fact, we could solve it in O(n2) time using only constant space.\\nWe observe that a palindrome mirrors around its center. Therefore, a palindrome can be expanded from its center, and there are only 2n \\u2013 1 such centers.\\nYou might be asking why there are 2n \\u2013 1 but not n centers? The reason is the center of a palindrome can be in between two letters. Such palindromes have even number of letters (such as \\u201Cabba\\u201D) and its center are between the two \\u2018b\\u2019s.\\nSince expanding a palindrome around its center could take O(n) time, the overall complexity is O(n2).\\n![image](https://assets.leetcode.com/users/infoie/image_1576132950.png)\\n\\nO(n) runtime, O(n) space \\u2013 Manacher\\u2019s algorithm:\\n![image](https://assets.leetcode.com/users/infoie/image_1576132981.png)\\n"
                    },
                    {
                        "username": "luo980",
                        "content": "![alt text]![0_1499137449406_8cb1c4ff-b5a3-46f1-9aeb-eed2e7012534-image.png](/assets/uploads/files/1499137454573-8cb1c4ff-b5a3-46f1-9aeb-eed2e7012534-image-resized.png) \\nHow should i deal with this problem?"
                    }
                ]
            },
            {
                "id": 1574602,
                "content": [
                    {
                        "username": "dword",
                        "content": "Algorithm A: \"Expand Around Center\" (approach 4 described in the solution).\\nO(n) best case (string contains no palindromes).\\nO(n^2) worst case (string consists of one repeated character).\\n\\nAlgorithm B: modified version of algorithm A that looks ahead to the end of a substring consisting of one repeated character, and expands around the whole substring, avoiding the effort of expanding around each position within the substring.\\nO(n) best case (string consists of one repeated character).\\nO(n^2) worst case (string consists of two alternating characters, like \"ababab\".)\\n\\nAlgorithm C: Manacher\\'s.\\nO(n) best and worst case.\\n\\nImplemented in C++, algorithm A runs in 44 ms, while algorithms B and C both run in 4 ms. Apparently, algorithm A is encountering its worst case but algorithm B is not.\\n\\nSure enough, when tested on \"ab\" repeated 5,000 times, algorithms A and B both run in ~100 ms and algorithm C runs in ~0 ms.\\n\\nSo it appears that in the test cases, there\\'s a long string of one repeated character but no similarly long string of two alternating characters.\\n\\nJust something I find interesting."
                    },
                    {
                        "username": "Ab__23",
                        "content": "I would like to report a bug here that, my solution runs successfully on all except the last testcase. When it shows that test case failed, I looked and found that the test case was empty, I mean such a minor bug in test case checking caused bad effect on my accuracy. Please remove the last test case. :("
                    },
                    {
                        "username": "timewaster69",
                        "content": "agreed. it also directly contradicts the two constraints given in the problem. Even if you were to write a testcase accounting for an empty string it still does not work for some reason."
                    },
                    {
                        "username": "martinvilche98",
                        "content": "\"Time Limit Exceeded\" On Passing solution...\\n\\nHonestly sounds like an excuse to reduce server load."
                    },
                    {
                        "username": "showtroylove",
                        "content": "Key to this task is avoiding string operations in your solution.  It can save you enormous time and avoids the TLE error.  Going one by one or using two loops stripping on char off the front or back doesn\\'t matter.  Reduce it all to int operations and it simplifies the task immensely.  That\\'s my two cents and I\\'m sticking with it. Cheers!"
                    },
                    {
                        "username": "ahtisham225ali",
                        "content": "The Simple Solution to the Problem in python is here https://hecodesit.com/longest-palindromic-substring-solution-python-leetcode/\\n"
                    },
                    {
                        "username": "0Camus0",
                        "content": "Hi, \\n\\nMany Manacher\\u2019s Algorithm implementation threads over the internet, but they always handle the even string case as:\\n\\n\"We just add $ to the string before and after, so baba would be $b$a$b$a$ and now we can have this case working too...\"\\n\\nBut it\\'s kind of defeating the purpose of having a O(n) time complexity, because you are doing another O(n) just to add the $, and then another O(n) to remove the $ for the even case. \\n\\nMaybe there is another Manchester\\'s implementation that doesn\\'t require that tricky \"add $\" in order to work.\\n\\nFor my solution I had two pases, one for the even and one for the odd, but I feel dumb when I see solutions from other people.. still 14 ms."
                    },
                    {
                        "username": "kshitij_sanghvi",
                        "content": "For folks getting a TLE. There are certain optimisations that work which would not work for smaller inputs.\\nIf you think about it logically the constant in dictionary look up is substantially higher that that of a list look up. However, we need to create a list and initialise it. This is where the constant in dictionary look up is traded off by default dict.\\n"
                    },
                    {
                        "username": "office93662",
                        "content": "Could someone help me understand how the time complexity is o(n^3) for the brute force?"
                    },
                    {
                        "username": "annen",
                        "content": "There are O(N^2) sub-strings. Checking whether a string is a palindrome is O(N). So O(N^3)"
                    },
                    {
                        "username": "infoie",
                        "content": "O(n3) runtime, O(1) space \\u2013 Brute force:\\nThe obvious brute force solution is to pick all possible starting and ending positions for a substring, and verify if it is a palindrome. There are a total of such substrings (excluding the trivial solution where a character itself is a palindrome).\\nSince verifying each substring takes O(n) time, the run time complexity is O(n3).\\n![image](https://assets.leetcode.com/users/infoie/image_1576132859.png)\\n\\nO(n2) runtime, O(n) space \\u2013 Dynamic programming:\\nTo improve over the brute force solution from a DP approach, first think how we can avoid unnecessary re-computation in validating palindromes. Consider the case \\u201Cababa\\u201D.\\nIf we already knew that \\u201Cbab\\u201D is a palindrome, it is obvious that \\u201Cababa\\u201D must be a palindrome since the two left and right end letters are the same.\\nStated more formally below:\\n\\tDefine P[ i, j ] \\u2190 true if the substring Si \\u2026 Sj is a palindrome, otherwise false.\\n\\tTherefore,\\n\\tP[ i, j ] \\u2190 ( P[ i+1, j-1 ] and Si = Sj )\\n\\tThe base cases are:\\n\\tP[ i, i ] \\u2190 true\\n\\tP[ i, i+1 ] \\u2190 ( Si = Si+1 )\\nThis yields a straight forward DP solution, which we first initialize the one and two letters palindromes, and work our way up finding all three letters palindromes, and so on\\u2026\\nThis gives us a runtime complexity of O(n2) and uses O(n2) space to store the table.\\n![image](https://assets.leetcode.com/users/infoie/image_1576132896.png)\\n\\nO(n2) runtime, O(1) space \\u2013 Simpler solution:\\nIn fact, we could solve it in O(n2) time using only constant space.\\nWe observe that a palindrome mirrors around its center. Therefore, a palindrome can be expanded from its center, and there are only 2n \\u2013 1 such centers.\\nYou might be asking why there are 2n \\u2013 1 but not n centers? The reason is the center of a palindrome can be in between two letters. Such palindromes have even number of letters (such as \\u201Cabba\\u201D) and its center are between the two \\u2018b\\u2019s.\\nSince expanding a palindrome around its center could take O(n) time, the overall complexity is O(n2).\\n![image](https://assets.leetcode.com/users/infoie/image_1576132950.png)\\n\\nO(n) runtime, O(n) space \\u2013 Manacher\\u2019s algorithm:\\n![image](https://assets.leetcode.com/users/infoie/image_1576132981.png)\\n"
                    },
                    {
                        "username": "luo980",
                        "content": "![alt text]![0_1499137449406_8cb1c4ff-b5a3-46f1-9aeb-eed2e7012534-image.png](/assets/uploads/files/1499137454573-8cb1c4ff-b5a3-46f1-9aeb-eed2e7012534-image-resized.png) \\nHow should i deal with this problem?"
                    }
                ]
            },
            {
                "id": 1573253,
                "content": [
                    {
                        "username": "dword",
                        "content": "Algorithm A: \"Expand Around Center\" (approach 4 described in the solution).\\nO(n) best case (string contains no palindromes).\\nO(n^2) worst case (string consists of one repeated character).\\n\\nAlgorithm B: modified version of algorithm A that looks ahead to the end of a substring consisting of one repeated character, and expands around the whole substring, avoiding the effort of expanding around each position within the substring.\\nO(n) best case (string consists of one repeated character).\\nO(n^2) worst case (string consists of two alternating characters, like \"ababab\".)\\n\\nAlgorithm C: Manacher\\'s.\\nO(n) best and worst case.\\n\\nImplemented in C++, algorithm A runs in 44 ms, while algorithms B and C both run in 4 ms. Apparently, algorithm A is encountering its worst case but algorithm B is not.\\n\\nSure enough, when tested on \"ab\" repeated 5,000 times, algorithms A and B both run in ~100 ms and algorithm C runs in ~0 ms.\\n\\nSo it appears that in the test cases, there\\'s a long string of one repeated character but no similarly long string of two alternating characters.\\n\\nJust something I find interesting."
                    },
                    {
                        "username": "Ab__23",
                        "content": "I would like to report a bug here that, my solution runs successfully on all except the last testcase. When it shows that test case failed, I looked and found that the test case was empty, I mean such a minor bug in test case checking caused bad effect on my accuracy. Please remove the last test case. :("
                    },
                    {
                        "username": "timewaster69",
                        "content": "agreed. it also directly contradicts the two constraints given in the problem. Even if you were to write a testcase accounting for an empty string it still does not work for some reason."
                    },
                    {
                        "username": "martinvilche98",
                        "content": "\"Time Limit Exceeded\" On Passing solution...\\n\\nHonestly sounds like an excuse to reduce server load."
                    },
                    {
                        "username": "showtroylove",
                        "content": "Key to this task is avoiding string operations in your solution.  It can save you enormous time and avoids the TLE error.  Going one by one or using two loops stripping on char off the front or back doesn\\'t matter.  Reduce it all to int operations and it simplifies the task immensely.  That\\'s my two cents and I\\'m sticking with it. Cheers!"
                    },
                    {
                        "username": "ahtisham225ali",
                        "content": "The Simple Solution to the Problem in python is here https://hecodesit.com/longest-palindromic-substring-solution-python-leetcode/\\n"
                    },
                    {
                        "username": "0Camus0",
                        "content": "Hi, \\n\\nMany Manacher\\u2019s Algorithm implementation threads over the internet, but they always handle the even string case as:\\n\\n\"We just add $ to the string before and after, so baba would be $b$a$b$a$ and now we can have this case working too...\"\\n\\nBut it\\'s kind of defeating the purpose of having a O(n) time complexity, because you are doing another O(n) just to add the $, and then another O(n) to remove the $ for the even case. \\n\\nMaybe there is another Manchester\\'s implementation that doesn\\'t require that tricky \"add $\" in order to work.\\n\\nFor my solution I had two pases, one for the even and one for the odd, but I feel dumb when I see solutions from other people.. still 14 ms."
                    },
                    {
                        "username": "kshitij_sanghvi",
                        "content": "For folks getting a TLE. There are certain optimisations that work which would not work for smaller inputs.\\nIf you think about it logically the constant in dictionary look up is substantially higher that that of a list look up. However, we need to create a list and initialise it. This is where the constant in dictionary look up is traded off by default dict.\\n"
                    },
                    {
                        "username": "office93662",
                        "content": "Could someone help me understand how the time complexity is o(n^3) for the brute force?"
                    },
                    {
                        "username": "annen",
                        "content": "There are O(N^2) sub-strings. Checking whether a string is a palindrome is O(N). So O(N^3)"
                    },
                    {
                        "username": "infoie",
                        "content": "O(n3) runtime, O(1) space \\u2013 Brute force:\\nThe obvious brute force solution is to pick all possible starting and ending positions for a substring, and verify if it is a palindrome. There are a total of such substrings (excluding the trivial solution where a character itself is a palindrome).\\nSince verifying each substring takes O(n) time, the run time complexity is O(n3).\\n![image](https://assets.leetcode.com/users/infoie/image_1576132859.png)\\n\\nO(n2) runtime, O(n) space \\u2013 Dynamic programming:\\nTo improve over the brute force solution from a DP approach, first think how we can avoid unnecessary re-computation in validating palindromes. Consider the case \\u201Cababa\\u201D.\\nIf we already knew that \\u201Cbab\\u201D is a palindrome, it is obvious that \\u201Cababa\\u201D must be a palindrome since the two left and right end letters are the same.\\nStated more formally below:\\n\\tDefine P[ i, j ] \\u2190 true if the substring Si \\u2026 Sj is a palindrome, otherwise false.\\n\\tTherefore,\\n\\tP[ i, j ] \\u2190 ( P[ i+1, j-1 ] and Si = Sj )\\n\\tThe base cases are:\\n\\tP[ i, i ] \\u2190 true\\n\\tP[ i, i+1 ] \\u2190 ( Si = Si+1 )\\nThis yields a straight forward DP solution, which we first initialize the one and two letters palindromes, and work our way up finding all three letters palindromes, and so on\\u2026\\nThis gives us a runtime complexity of O(n2) and uses O(n2) space to store the table.\\n![image](https://assets.leetcode.com/users/infoie/image_1576132896.png)\\n\\nO(n2) runtime, O(1) space \\u2013 Simpler solution:\\nIn fact, we could solve it in O(n2) time using only constant space.\\nWe observe that a palindrome mirrors around its center. Therefore, a palindrome can be expanded from its center, and there are only 2n \\u2013 1 such centers.\\nYou might be asking why there are 2n \\u2013 1 but not n centers? The reason is the center of a palindrome can be in between two letters. Such palindromes have even number of letters (such as \\u201Cabba\\u201D) and its center are between the two \\u2018b\\u2019s.\\nSince expanding a palindrome around its center could take O(n) time, the overall complexity is O(n2).\\n![image](https://assets.leetcode.com/users/infoie/image_1576132950.png)\\n\\nO(n) runtime, O(n) space \\u2013 Manacher\\u2019s algorithm:\\n![image](https://assets.leetcode.com/users/infoie/image_1576132981.png)\\n"
                    },
                    {
                        "username": "luo980",
                        "content": "![alt text]![0_1499137449406_8cb1c4ff-b5a3-46f1-9aeb-eed2e7012534-image.png](/assets/uploads/files/1499137454573-8cb1c4ff-b5a3-46f1-9aeb-eed2e7012534-image-resized.png) \\nHow should i deal with this problem?"
                    }
                ]
            },
            {
                "id": 1568803,
                "content": [
                    {
                        "username": "dword",
                        "content": "Algorithm A: \"Expand Around Center\" (approach 4 described in the solution).\\nO(n) best case (string contains no palindromes).\\nO(n^2) worst case (string consists of one repeated character).\\n\\nAlgorithm B: modified version of algorithm A that looks ahead to the end of a substring consisting of one repeated character, and expands around the whole substring, avoiding the effort of expanding around each position within the substring.\\nO(n) best case (string consists of one repeated character).\\nO(n^2) worst case (string consists of two alternating characters, like \"ababab\".)\\n\\nAlgorithm C: Manacher\\'s.\\nO(n) best and worst case.\\n\\nImplemented in C++, algorithm A runs in 44 ms, while algorithms B and C both run in 4 ms. Apparently, algorithm A is encountering its worst case but algorithm B is not.\\n\\nSure enough, when tested on \"ab\" repeated 5,000 times, algorithms A and B both run in ~100 ms and algorithm C runs in ~0 ms.\\n\\nSo it appears that in the test cases, there\\'s a long string of one repeated character but no similarly long string of two alternating characters.\\n\\nJust something I find interesting."
                    },
                    {
                        "username": "Ab__23",
                        "content": "I would like to report a bug here that, my solution runs successfully on all except the last testcase. When it shows that test case failed, I looked and found that the test case was empty, I mean such a minor bug in test case checking caused bad effect on my accuracy. Please remove the last test case. :("
                    },
                    {
                        "username": "timewaster69",
                        "content": "agreed. it also directly contradicts the two constraints given in the problem. Even if you were to write a testcase accounting for an empty string it still does not work for some reason."
                    },
                    {
                        "username": "martinvilche98",
                        "content": "\"Time Limit Exceeded\" On Passing solution...\\n\\nHonestly sounds like an excuse to reduce server load."
                    },
                    {
                        "username": "showtroylove",
                        "content": "Key to this task is avoiding string operations in your solution.  It can save you enormous time and avoids the TLE error.  Going one by one or using two loops stripping on char off the front or back doesn\\'t matter.  Reduce it all to int operations and it simplifies the task immensely.  That\\'s my two cents and I\\'m sticking with it. Cheers!"
                    },
                    {
                        "username": "ahtisham225ali",
                        "content": "The Simple Solution to the Problem in python is here https://hecodesit.com/longest-palindromic-substring-solution-python-leetcode/\\n"
                    },
                    {
                        "username": "0Camus0",
                        "content": "Hi, \\n\\nMany Manacher\\u2019s Algorithm implementation threads over the internet, but they always handle the even string case as:\\n\\n\"We just add $ to the string before and after, so baba would be $b$a$b$a$ and now we can have this case working too...\"\\n\\nBut it\\'s kind of defeating the purpose of having a O(n) time complexity, because you are doing another O(n) just to add the $, and then another O(n) to remove the $ for the even case. \\n\\nMaybe there is another Manchester\\'s implementation that doesn\\'t require that tricky \"add $\" in order to work.\\n\\nFor my solution I had two pases, one for the even and one for the odd, but I feel dumb when I see solutions from other people.. still 14 ms."
                    },
                    {
                        "username": "kshitij_sanghvi",
                        "content": "For folks getting a TLE. There are certain optimisations that work which would not work for smaller inputs.\\nIf you think about it logically the constant in dictionary look up is substantially higher that that of a list look up. However, we need to create a list and initialise it. This is where the constant in dictionary look up is traded off by default dict.\\n"
                    },
                    {
                        "username": "office93662",
                        "content": "Could someone help me understand how the time complexity is o(n^3) for the brute force?"
                    },
                    {
                        "username": "annen",
                        "content": "There are O(N^2) sub-strings. Checking whether a string is a palindrome is O(N). So O(N^3)"
                    },
                    {
                        "username": "infoie",
                        "content": "O(n3) runtime, O(1) space \\u2013 Brute force:\\nThe obvious brute force solution is to pick all possible starting and ending positions for a substring, and verify if it is a palindrome. There are a total of such substrings (excluding the trivial solution where a character itself is a palindrome).\\nSince verifying each substring takes O(n) time, the run time complexity is O(n3).\\n![image](https://assets.leetcode.com/users/infoie/image_1576132859.png)\\n\\nO(n2) runtime, O(n) space \\u2013 Dynamic programming:\\nTo improve over the brute force solution from a DP approach, first think how we can avoid unnecessary re-computation in validating palindromes. Consider the case \\u201Cababa\\u201D.\\nIf we already knew that \\u201Cbab\\u201D is a palindrome, it is obvious that \\u201Cababa\\u201D must be a palindrome since the two left and right end letters are the same.\\nStated more formally below:\\n\\tDefine P[ i, j ] \\u2190 true if the substring Si \\u2026 Sj is a palindrome, otherwise false.\\n\\tTherefore,\\n\\tP[ i, j ] \\u2190 ( P[ i+1, j-1 ] and Si = Sj )\\n\\tThe base cases are:\\n\\tP[ i, i ] \\u2190 true\\n\\tP[ i, i+1 ] \\u2190 ( Si = Si+1 )\\nThis yields a straight forward DP solution, which we first initialize the one and two letters palindromes, and work our way up finding all three letters palindromes, and so on\\u2026\\nThis gives us a runtime complexity of O(n2) and uses O(n2) space to store the table.\\n![image](https://assets.leetcode.com/users/infoie/image_1576132896.png)\\n\\nO(n2) runtime, O(1) space \\u2013 Simpler solution:\\nIn fact, we could solve it in O(n2) time using only constant space.\\nWe observe that a palindrome mirrors around its center. Therefore, a palindrome can be expanded from its center, and there are only 2n \\u2013 1 such centers.\\nYou might be asking why there are 2n \\u2013 1 but not n centers? The reason is the center of a palindrome can be in between two letters. Such palindromes have even number of letters (such as \\u201Cabba\\u201D) and its center are between the two \\u2018b\\u2019s.\\nSince expanding a palindrome around its center could take O(n) time, the overall complexity is O(n2).\\n![image](https://assets.leetcode.com/users/infoie/image_1576132950.png)\\n\\nO(n) runtime, O(n) space \\u2013 Manacher\\u2019s algorithm:\\n![image](https://assets.leetcode.com/users/infoie/image_1576132981.png)\\n"
                    },
                    {
                        "username": "luo980",
                        "content": "![alt text]![0_1499137449406_8cb1c4ff-b5a3-46f1-9aeb-eed2e7012534-image.png](/assets/uploads/files/1499137454573-8cb1c4ff-b5a3-46f1-9aeb-eed2e7012534-image-resized.png) \\nHow should i deal with this problem?"
                    }
                ]
            },
            {
                "id": 2075986,
                "content": [
                    {
                        "username": "sparasuram",
                        "content": "test case \"ac\" is not a palindromic string. But it shows output as \"a\""
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "we have to find substring, so the string itself could be not palindromic, the answers to that question could be either \"a\" or \"c\", cause they are palindromic"
                    },
                    {
                        "username": "anupamprakash82",
                        "content": "Why O(n^2) solution is giving the TLE? Since the constraint is 1 <= s.length <= 1000, O(n^2) solution should work"
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "[@anupamprakash82](/anupamprakash82) Nuh"
                    },
                    {
                        "username": "anupamprakash82",
                        "content": "[@DamianIvanochko](/DamianIvanochko) is your code getting AC?"
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "bro my solutions is O(n^3)"
                    },
                    {
                        "username": "piyush_mehta22",
                        "content": "if(s.charAt(i) == s.charAt(j) && substring(i,j).length() > longestSubstring.lenght() && isPalindrome(substring(i,j)) {\\nlongestSubstring = substring(i,j);\\n}\\nis much much better than \\nif(isPalindrome(substring(i,j)) {\\n  if(substring.length() > longestSubstring.length()) {\\n     longestubstring = substring(i,j);\\n  }\\n}\\n\\nbecause the first condition first checks whether first and last char are equal or not, then it checks if length is greater or not then it goes for checking is it palindrome or not(which removes  most of the unwanted cases and saves some time), while in second, first it checks the palindrome condition for all string then makes further decision"
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "[@georgezakharov](/georgezakharov) good job lil nigga"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "That\\'s gay, don\\'t post solutions here"
                    },
                    {
                        "username": "jai218",
                        "content": "How do I optimize my code further? \\nI have defined a function outside the class that checks if a string is a palindrome (recursive) and then in the main function i go over all possible substrings starting from the biggest to smallest and checking if that is a palindrome, if True then return that. "
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "anyways your code is still better, mine runs at O(n^3)\\uD83D\\uDC80"
                    },
                    {
                        "username": "AnthonyR21",
                        "content": "## Intuition \n- The problem is to find the longest palndromic substring within a given string.\n- A palindrome reads the same backward as forward.\n- We can use a brute-force approach to check all possible substrings and find the longest one that is also a palindrome.\n\n## Approach\n- Define an ```isPalindrome``` method to check if substring is a palindrome. This method compares characters from the start and end of the substring, moving toward the center.\n- In the ```longestPalindrome``` method:\n- Initialize variables ```maxLength``` to store the length of the longest palindrome found so far and start to store the starting index of the longest palindrome.\n- Iterate through all possible pairs of indexes (i, j) to consider all substrings.\n- For each substring (i, j) check if it's a palindrome using the ```isPalindrome``` method.\n- If it's a palindrome and longer than the current maximum, update ```maxLength``` and start."
                    },
                    {
                        "username": "benlhachemi",
                        "content": "if you passed the \"RUN\" and get the message \"Time Limit Exceeded\" on Submit, your code is correct but the complexity is not.\\nTry to reduce complexity of your algorithm."
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "GigaNigger"
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "My dick is 20 inches"
                    },
                    {
                        "username": "igorKor",
                        "content": "According to the condition of the task, you need to find the longest palindrome.\nWhen tested, the input string is \"babadada\".\nThe test expects to receive \"adada\".\nBut the longest polyndrom in this case will be the substring \"adabada\""
                    },
                    {
                        "username": "AMerrill",
                        "content": "a substring is a set of continuous characters (i.e. you cannot rearrange characters). Thus, for the example given, \"*adada*\" is the longest palindrome that is a substring of \"*babadada*\""
                    },
                    {
                        "username": "mishraanuyesh7",
                        "content": "javascript\\n"
                    },
                    {
                        "username": "showtroylove",
                        "content": "How do you add an image to post?"
                    }
                ]
            },
            {
                "id": 2069483,
                "content": [
                    {
                        "username": "sparasuram",
                        "content": "test case \"ac\" is not a palindromic string. But it shows output as \"a\""
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "we have to find substring, so the string itself could be not palindromic, the answers to that question could be either \"a\" or \"c\", cause they are palindromic"
                    },
                    {
                        "username": "anupamprakash82",
                        "content": "Why O(n^2) solution is giving the TLE? Since the constraint is 1 <= s.length <= 1000, O(n^2) solution should work"
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "[@anupamprakash82](/anupamprakash82) Nuh"
                    },
                    {
                        "username": "anupamprakash82",
                        "content": "[@DamianIvanochko](/DamianIvanochko) is your code getting AC?"
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "bro my solutions is O(n^3)"
                    },
                    {
                        "username": "piyush_mehta22",
                        "content": "if(s.charAt(i) == s.charAt(j) && substring(i,j).length() > longestSubstring.lenght() && isPalindrome(substring(i,j)) {\\nlongestSubstring = substring(i,j);\\n}\\nis much much better than \\nif(isPalindrome(substring(i,j)) {\\n  if(substring.length() > longestSubstring.length()) {\\n     longestubstring = substring(i,j);\\n  }\\n}\\n\\nbecause the first condition first checks whether first and last char are equal or not, then it checks if length is greater or not then it goes for checking is it palindrome or not(which removes  most of the unwanted cases and saves some time), while in second, first it checks the palindrome condition for all string then makes further decision"
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "[@georgezakharov](/georgezakharov) good job lil nigga"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "That\\'s gay, don\\'t post solutions here"
                    },
                    {
                        "username": "jai218",
                        "content": "How do I optimize my code further? \\nI have defined a function outside the class that checks if a string is a palindrome (recursive) and then in the main function i go over all possible substrings starting from the biggest to smallest and checking if that is a palindrome, if True then return that. "
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "anyways your code is still better, mine runs at O(n^3)\\uD83D\\uDC80"
                    },
                    {
                        "username": "AnthonyR21",
                        "content": "## Intuition \n- The problem is to find the longest palndromic substring within a given string.\n- A palindrome reads the same backward as forward.\n- We can use a brute-force approach to check all possible substrings and find the longest one that is also a palindrome.\n\n## Approach\n- Define an ```isPalindrome``` method to check if substring is a palindrome. This method compares characters from the start and end of the substring, moving toward the center.\n- In the ```longestPalindrome``` method:\n- Initialize variables ```maxLength``` to store the length of the longest palindrome found so far and start to store the starting index of the longest palindrome.\n- Iterate through all possible pairs of indexes (i, j) to consider all substrings.\n- For each substring (i, j) check if it's a palindrome using the ```isPalindrome``` method.\n- If it's a palindrome and longer than the current maximum, update ```maxLength``` and start."
                    },
                    {
                        "username": "benlhachemi",
                        "content": "if you passed the \"RUN\" and get the message \"Time Limit Exceeded\" on Submit, your code is correct but the complexity is not.\\nTry to reduce complexity of your algorithm."
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "GigaNigger"
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "My dick is 20 inches"
                    },
                    {
                        "username": "igorKor",
                        "content": "According to the condition of the task, you need to find the longest palindrome.\nWhen tested, the input string is \"babadada\".\nThe test expects to receive \"adada\".\nBut the longest polyndrom in this case will be the substring \"adabada\""
                    },
                    {
                        "username": "AMerrill",
                        "content": "a substring is a set of continuous characters (i.e. you cannot rearrange characters). Thus, for the example given, \"*adada*\" is the longest palindrome that is a substring of \"*babadada*\""
                    },
                    {
                        "username": "mishraanuyesh7",
                        "content": "javascript\\n"
                    },
                    {
                        "username": "showtroylove",
                        "content": "How do you add an image to post?"
                    }
                ]
            },
            {
                "id": 2063076,
                "content": [
                    {
                        "username": "sparasuram",
                        "content": "test case \"ac\" is not a palindromic string. But it shows output as \"a\""
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "we have to find substring, so the string itself could be not palindromic, the answers to that question could be either \"a\" or \"c\", cause they are palindromic"
                    },
                    {
                        "username": "anupamprakash82",
                        "content": "Why O(n^2) solution is giving the TLE? Since the constraint is 1 <= s.length <= 1000, O(n^2) solution should work"
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "[@anupamprakash82](/anupamprakash82) Nuh"
                    },
                    {
                        "username": "anupamprakash82",
                        "content": "[@DamianIvanochko](/DamianIvanochko) is your code getting AC?"
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "bro my solutions is O(n^3)"
                    },
                    {
                        "username": "piyush_mehta22",
                        "content": "if(s.charAt(i) == s.charAt(j) && substring(i,j).length() > longestSubstring.lenght() && isPalindrome(substring(i,j)) {\\nlongestSubstring = substring(i,j);\\n}\\nis much much better than \\nif(isPalindrome(substring(i,j)) {\\n  if(substring.length() > longestSubstring.length()) {\\n     longestubstring = substring(i,j);\\n  }\\n}\\n\\nbecause the first condition first checks whether first and last char are equal or not, then it checks if length is greater or not then it goes for checking is it palindrome or not(which removes  most of the unwanted cases and saves some time), while in second, first it checks the palindrome condition for all string then makes further decision"
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "[@georgezakharov](/georgezakharov) good job lil nigga"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "That\\'s gay, don\\'t post solutions here"
                    },
                    {
                        "username": "jai218",
                        "content": "How do I optimize my code further? \\nI have defined a function outside the class that checks if a string is a palindrome (recursive) and then in the main function i go over all possible substrings starting from the biggest to smallest and checking if that is a palindrome, if True then return that. "
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "anyways your code is still better, mine runs at O(n^3)\\uD83D\\uDC80"
                    },
                    {
                        "username": "AnthonyR21",
                        "content": "## Intuition \n- The problem is to find the longest palndromic substring within a given string.\n- A palindrome reads the same backward as forward.\n- We can use a brute-force approach to check all possible substrings and find the longest one that is also a palindrome.\n\n## Approach\n- Define an ```isPalindrome``` method to check if substring is a palindrome. This method compares characters from the start and end of the substring, moving toward the center.\n- In the ```longestPalindrome``` method:\n- Initialize variables ```maxLength``` to store the length of the longest palindrome found so far and start to store the starting index of the longest palindrome.\n- Iterate through all possible pairs of indexes (i, j) to consider all substrings.\n- For each substring (i, j) check if it's a palindrome using the ```isPalindrome``` method.\n- If it's a palindrome and longer than the current maximum, update ```maxLength``` and start."
                    },
                    {
                        "username": "benlhachemi",
                        "content": "if you passed the \"RUN\" and get the message \"Time Limit Exceeded\" on Submit, your code is correct but the complexity is not.\\nTry to reduce complexity of your algorithm."
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "GigaNigger"
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "My dick is 20 inches"
                    },
                    {
                        "username": "igorKor",
                        "content": "According to the condition of the task, you need to find the longest palindrome.\nWhen tested, the input string is \"babadada\".\nThe test expects to receive \"adada\".\nBut the longest polyndrom in this case will be the substring \"adabada\""
                    },
                    {
                        "username": "AMerrill",
                        "content": "a substring is a set of continuous characters (i.e. you cannot rearrange characters). Thus, for the example given, \"*adada*\" is the longest palindrome that is a substring of \"*babadada*\""
                    },
                    {
                        "username": "mishraanuyesh7",
                        "content": "javascript\\n"
                    },
                    {
                        "username": "showtroylove",
                        "content": "How do you add an image to post?"
                    }
                ]
            },
            {
                "id": 2049173,
                "content": [
                    {
                        "username": "sparasuram",
                        "content": "test case \"ac\" is not a palindromic string. But it shows output as \"a\""
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "we have to find substring, so the string itself could be not palindromic, the answers to that question could be either \"a\" or \"c\", cause they are palindromic"
                    },
                    {
                        "username": "anupamprakash82",
                        "content": "Why O(n^2) solution is giving the TLE? Since the constraint is 1 <= s.length <= 1000, O(n^2) solution should work"
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "[@anupamprakash82](/anupamprakash82) Nuh"
                    },
                    {
                        "username": "anupamprakash82",
                        "content": "[@DamianIvanochko](/DamianIvanochko) is your code getting AC?"
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "bro my solutions is O(n^3)"
                    },
                    {
                        "username": "piyush_mehta22",
                        "content": "if(s.charAt(i) == s.charAt(j) && substring(i,j).length() > longestSubstring.lenght() && isPalindrome(substring(i,j)) {\\nlongestSubstring = substring(i,j);\\n}\\nis much much better than \\nif(isPalindrome(substring(i,j)) {\\n  if(substring.length() > longestSubstring.length()) {\\n     longestubstring = substring(i,j);\\n  }\\n}\\n\\nbecause the first condition first checks whether first and last char are equal or not, then it checks if length is greater or not then it goes for checking is it palindrome or not(which removes  most of the unwanted cases and saves some time), while in second, first it checks the palindrome condition for all string then makes further decision"
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "[@georgezakharov](/georgezakharov) good job lil nigga"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "That\\'s gay, don\\'t post solutions here"
                    },
                    {
                        "username": "jai218",
                        "content": "How do I optimize my code further? \\nI have defined a function outside the class that checks if a string is a palindrome (recursive) and then in the main function i go over all possible substrings starting from the biggest to smallest and checking if that is a palindrome, if True then return that. "
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "anyways your code is still better, mine runs at O(n^3)\\uD83D\\uDC80"
                    },
                    {
                        "username": "AnthonyR21",
                        "content": "## Intuition \n- The problem is to find the longest palndromic substring within a given string.\n- A palindrome reads the same backward as forward.\n- We can use a brute-force approach to check all possible substrings and find the longest one that is also a palindrome.\n\n## Approach\n- Define an ```isPalindrome``` method to check if substring is a palindrome. This method compares characters from the start and end of the substring, moving toward the center.\n- In the ```longestPalindrome``` method:\n- Initialize variables ```maxLength``` to store the length of the longest palindrome found so far and start to store the starting index of the longest palindrome.\n- Iterate through all possible pairs of indexes (i, j) to consider all substrings.\n- For each substring (i, j) check if it's a palindrome using the ```isPalindrome``` method.\n- If it's a palindrome and longer than the current maximum, update ```maxLength``` and start."
                    },
                    {
                        "username": "benlhachemi",
                        "content": "if you passed the \"RUN\" and get the message \"Time Limit Exceeded\" on Submit, your code is correct but the complexity is not.\\nTry to reduce complexity of your algorithm."
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "GigaNigger"
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "My dick is 20 inches"
                    },
                    {
                        "username": "igorKor",
                        "content": "According to the condition of the task, you need to find the longest palindrome.\nWhen tested, the input string is \"babadada\".\nThe test expects to receive \"adada\".\nBut the longest polyndrom in this case will be the substring \"adabada\""
                    },
                    {
                        "username": "AMerrill",
                        "content": "a substring is a set of continuous characters (i.e. you cannot rearrange characters). Thus, for the example given, \"*adada*\" is the longest palindrome that is a substring of \"*babadada*\""
                    },
                    {
                        "username": "mishraanuyesh7",
                        "content": "javascript\\n"
                    },
                    {
                        "username": "showtroylove",
                        "content": "How do you add an image to post?"
                    }
                ]
            },
            {
                "id": 2041500,
                "content": [
                    {
                        "username": "sparasuram",
                        "content": "test case \"ac\" is not a palindromic string. But it shows output as \"a\""
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "we have to find substring, so the string itself could be not palindromic, the answers to that question could be either \"a\" or \"c\", cause they are palindromic"
                    },
                    {
                        "username": "anupamprakash82",
                        "content": "Why O(n^2) solution is giving the TLE? Since the constraint is 1 <= s.length <= 1000, O(n^2) solution should work"
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "[@anupamprakash82](/anupamprakash82) Nuh"
                    },
                    {
                        "username": "anupamprakash82",
                        "content": "[@DamianIvanochko](/DamianIvanochko) is your code getting AC?"
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "bro my solutions is O(n^3)"
                    },
                    {
                        "username": "piyush_mehta22",
                        "content": "if(s.charAt(i) == s.charAt(j) && substring(i,j).length() > longestSubstring.lenght() && isPalindrome(substring(i,j)) {\\nlongestSubstring = substring(i,j);\\n}\\nis much much better than \\nif(isPalindrome(substring(i,j)) {\\n  if(substring.length() > longestSubstring.length()) {\\n     longestubstring = substring(i,j);\\n  }\\n}\\n\\nbecause the first condition first checks whether first and last char are equal or not, then it checks if length is greater or not then it goes for checking is it palindrome or not(which removes  most of the unwanted cases and saves some time), while in second, first it checks the palindrome condition for all string then makes further decision"
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "[@georgezakharov](/georgezakharov) good job lil nigga"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "That\\'s gay, don\\'t post solutions here"
                    },
                    {
                        "username": "jai218",
                        "content": "How do I optimize my code further? \\nI have defined a function outside the class that checks if a string is a palindrome (recursive) and then in the main function i go over all possible substrings starting from the biggest to smallest and checking if that is a palindrome, if True then return that. "
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "anyways your code is still better, mine runs at O(n^3)\\uD83D\\uDC80"
                    },
                    {
                        "username": "AnthonyR21",
                        "content": "## Intuition \n- The problem is to find the longest palndromic substring within a given string.\n- A palindrome reads the same backward as forward.\n- We can use a brute-force approach to check all possible substrings and find the longest one that is also a palindrome.\n\n## Approach\n- Define an ```isPalindrome``` method to check if substring is a palindrome. This method compares characters from the start and end of the substring, moving toward the center.\n- In the ```longestPalindrome``` method:\n- Initialize variables ```maxLength``` to store the length of the longest palindrome found so far and start to store the starting index of the longest palindrome.\n- Iterate through all possible pairs of indexes (i, j) to consider all substrings.\n- For each substring (i, j) check if it's a palindrome using the ```isPalindrome``` method.\n- If it's a palindrome and longer than the current maximum, update ```maxLength``` and start."
                    },
                    {
                        "username": "benlhachemi",
                        "content": "if you passed the \"RUN\" and get the message \"Time Limit Exceeded\" on Submit, your code is correct but the complexity is not.\\nTry to reduce complexity of your algorithm."
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "GigaNigger"
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "My dick is 20 inches"
                    },
                    {
                        "username": "igorKor",
                        "content": "According to the condition of the task, you need to find the longest palindrome.\nWhen tested, the input string is \"babadada\".\nThe test expects to receive \"adada\".\nBut the longest polyndrom in this case will be the substring \"adabada\""
                    },
                    {
                        "username": "AMerrill",
                        "content": "a substring is a set of continuous characters (i.e. you cannot rearrange characters). Thus, for the example given, \"*adada*\" is the longest palindrome that is a substring of \"*babadada*\""
                    },
                    {
                        "username": "mishraanuyesh7",
                        "content": "javascript\\n"
                    },
                    {
                        "username": "showtroylove",
                        "content": "How do you add an image to post?"
                    }
                ]
            },
            {
                "id": 2036858,
                "content": [
                    {
                        "username": "sparasuram",
                        "content": "test case \"ac\" is not a palindromic string. But it shows output as \"a\""
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "we have to find substring, so the string itself could be not palindromic, the answers to that question could be either \"a\" or \"c\", cause they are palindromic"
                    },
                    {
                        "username": "anupamprakash82",
                        "content": "Why O(n^2) solution is giving the TLE? Since the constraint is 1 <= s.length <= 1000, O(n^2) solution should work"
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "[@anupamprakash82](/anupamprakash82) Nuh"
                    },
                    {
                        "username": "anupamprakash82",
                        "content": "[@DamianIvanochko](/DamianIvanochko) is your code getting AC?"
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "bro my solutions is O(n^3)"
                    },
                    {
                        "username": "piyush_mehta22",
                        "content": "if(s.charAt(i) == s.charAt(j) && substring(i,j).length() > longestSubstring.lenght() && isPalindrome(substring(i,j)) {\\nlongestSubstring = substring(i,j);\\n}\\nis much much better than \\nif(isPalindrome(substring(i,j)) {\\n  if(substring.length() > longestSubstring.length()) {\\n     longestubstring = substring(i,j);\\n  }\\n}\\n\\nbecause the first condition first checks whether first and last char are equal or not, then it checks if length is greater or not then it goes for checking is it palindrome or not(which removes  most of the unwanted cases and saves some time), while in second, first it checks the palindrome condition for all string then makes further decision"
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "[@georgezakharov](/georgezakharov) good job lil nigga"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "That\\'s gay, don\\'t post solutions here"
                    },
                    {
                        "username": "jai218",
                        "content": "How do I optimize my code further? \\nI have defined a function outside the class that checks if a string is a palindrome (recursive) and then in the main function i go over all possible substrings starting from the biggest to smallest and checking if that is a palindrome, if True then return that. "
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "anyways your code is still better, mine runs at O(n^3)\\uD83D\\uDC80"
                    },
                    {
                        "username": "AnthonyR21",
                        "content": "## Intuition \n- The problem is to find the longest palndromic substring within a given string.\n- A palindrome reads the same backward as forward.\n- We can use a brute-force approach to check all possible substrings and find the longest one that is also a palindrome.\n\n## Approach\n- Define an ```isPalindrome``` method to check if substring is a palindrome. This method compares characters from the start and end of the substring, moving toward the center.\n- In the ```longestPalindrome``` method:\n- Initialize variables ```maxLength``` to store the length of the longest palindrome found so far and start to store the starting index of the longest palindrome.\n- Iterate through all possible pairs of indexes (i, j) to consider all substrings.\n- For each substring (i, j) check if it's a palindrome using the ```isPalindrome``` method.\n- If it's a palindrome and longer than the current maximum, update ```maxLength``` and start."
                    },
                    {
                        "username": "benlhachemi",
                        "content": "if you passed the \"RUN\" and get the message \"Time Limit Exceeded\" on Submit, your code is correct but the complexity is not.\\nTry to reduce complexity of your algorithm."
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "GigaNigger"
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "My dick is 20 inches"
                    },
                    {
                        "username": "igorKor",
                        "content": "According to the condition of the task, you need to find the longest palindrome.\nWhen tested, the input string is \"babadada\".\nThe test expects to receive \"adada\".\nBut the longest polyndrom in this case will be the substring \"adabada\""
                    },
                    {
                        "username": "AMerrill",
                        "content": "a substring is a set of continuous characters (i.e. you cannot rearrange characters). Thus, for the example given, \"*adada*\" is the longest palindrome that is a substring of \"*babadada*\""
                    },
                    {
                        "username": "mishraanuyesh7",
                        "content": "javascript\\n"
                    },
                    {
                        "username": "showtroylove",
                        "content": "How do you add an image to post?"
                    }
                ]
            },
            {
                "id": 2028006,
                "content": [
                    {
                        "username": "sparasuram",
                        "content": "test case \"ac\" is not a palindromic string. But it shows output as \"a\""
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "we have to find substring, so the string itself could be not palindromic, the answers to that question could be either \"a\" or \"c\", cause they are palindromic"
                    },
                    {
                        "username": "anupamprakash82",
                        "content": "Why O(n^2) solution is giving the TLE? Since the constraint is 1 <= s.length <= 1000, O(n^2) solution should work"
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "[@anupamprakash82](/anupamprakash82) Nuh"
                    },
                    {
                        "username": "anupamprakash82",
                        "content": "[@DamianIvanochko](/DamianIvanochko) is your code getting AC?"
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "bro my solutions is O(n^3)"
                    },
                    {
                        "username": "piyush_mehta22",
                        "content": "if(s.charAt(i) == s.charAt(j) && substring(i,j).length() > longestSubstring.lenght() && isPalindrome(substring(i,j)) {\\nlongestSubstring = substring(i,j);\\n}\\nis much much better than \\nif(isPalindrome(substring(i,j)) {\\n  if(substring.length() > longestSubstring.length()) {\\n     longestubstring = substring(i,j);\\n  }\\n}\\n\\nbecause the first condition first checks whether first and last char are equal or not, then it checks if length is greater or not then it goes for checking is it palindrome or not(which removes  most of the unwanted cases and saves some time), while in second, first it checks the palindrome condition for all string then makes further decision"
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "[@georgezakharov](/georgezakharov) good job lil nigga"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "That\\'s gay, don\\'t post solutions here"
                    },
                    {
                        "username": "jai218",
                        "content": "How do I optimize my code further? \\nI have defined a function outside the class that checks if a string is a palindrome (recursive) and then in the main function i go over all possible substrings starting from the biggest to smallest and checking if that is a palindrome, if True then return that. "
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "anyways your code is still better, mine runs at O(n^3)\\uD83D\\uDC80"
                    },
                    {
                        "username": "AnthonyR21",
                        "content": "## Intuition \n- The problem is to find the longest palndromic substring within a given string.\n- A palindrome reads the same backward as forward.\n- We can use a brute-force approach to check all possible substrings and find the longest one that is also a palindrome.\n\n## Approach\n- Define an ```isPalindrome``` method to check if substring is a palindrome. This method compares characters from the start and end of the substring, moving toward the center.\n- In the ```longestPalindrome``` method:\n- Initialize variables ```maxLength``` to store the length of the longest palindrome found so far and start to store the starting index of the longest palindrome.\n- Iterate through all possible pairs of indexes (i, j) to consider all substrings.\n- For each substring (i, j) check if it's a palindrome using the ```isPalindrome``` method.\n- If it's a palindrome and longer than the current maximum, update ```maxLength``` and start."
                    },
                    {
                        "username": "benlhachemi",
                        "content": "if you passed the \"RUN\" and get the message \"Time Limit Exceeded\" on Submit, your code is correct but the complexity is not.\\nTry to reduce complexity of your algorithm."
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "GigaNigger"
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "My dick is 20 inches"
                    },
                    {
                        "username": "igorKor",
                        "content": "According to the condition of the task, you need to find the longest palindrome.\nWhen tested, the input string is \"babadada\".\nThe test expects to receive \"adada\".\nBut the longest polyndrom in this case will be the substring \"adabada\""
                    },
                    {
                        "username": "AMerrill",
                        "content": "a substring is a set of continuous characters (i.e. you cannot rearrange characters). Thus, for the example given, \"*adada*\" is the longest palindrome that is a substring of \"*babadada*\""
                    },
                    {
                        "username": "mishraanuyesh7",
                        "content": "javascript\\n"
                    },
                    {
                        "username": "showtroylove",
                        "content": "How do you add an image to post?"
                    }
                ]
            },
            {
                "id": 1803485,
                "content": [
                    {
                        "username": "sparasuram",
                        "content": "test case \"ac\" is not a palindromic string. But it shows output as \"a\""
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "we have to find substring, so the string itself could be not palindromic, the answers to that question could be either \"a\" or \"c\", cause they are palindromic"
                    },
                    {
                        "username": "anupamprakash82",
                        "content": "Why O(n^2) solution is giving the TLE? Since the constraint is 1 <= s.length <= 1000, O(n^2) solution should work"
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "[@anupamprakash82](/anupamprakash82) Nuh"
                    },
                    {
                        "username": "anupamprakash82",
                        "content": "[@DamianIvanochko](/DamianIvanochko) is your code getting AC?"
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "bro my solutions is O(n^3)"
                    },
                    {
                        "username": "piyush_mehta22",
                        "content": "if(s.charAt(i) == s.charAt(j) && substring(i,j).length() > longestSubstring.lenght() && isPalindrome(substring(i,j)) {\\nlongestSubstring = substring(i,j);\\n}\\nis much much better than \\nif(isPalindrome(substring(i,j)) {\\n  if(substring.length() > longestSubstring.length()) {\\n     longestubstring = substring(i,j);\\n  }\\n}\\n\\nbecause the first condition first checks whether first and last char are equal or not, then it checks if length is greater or not then it goes for checking is it palindrome or not(which removes  most of the unwanted cases and saves some time), while in second, first it checks the palindrome condition for all string then makes further decision"
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "[@georgezakharov](/georgezakharov) good job lil nigga"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "That\\'s gay, don\\'t post solutions here"
                    },
                    {
                        "username": "jai218",
                        "content": "How do I optimize my code further? \\nI have defined a function outside the class that checks if a string is a palindrome (recursive) and then in the main function i go over all possible substrings starting from the biggest to smallest and checking if that is a palindrome, if True then return that. "
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "anyways your code is still better, mine runs at O(n^3)\\uD83D\\uDC80"
                    },
                    {
                        "username": "AnthonyR21",
                        "content": "## Intuition \n- The problem is to find the longest palndromic substring within a given string.\n- A palindrome reads the same backward as forward.\n- We can use a brute-force approach to check all possible substrings and find the longest one that is also a palindrome.\n\n## Approach\n- Define an ```isPalindrome``` method to check if substring is a palindrome. This method compares characters from the start and end of the substring, moving toward the center.\n- In the ```longestPalindrome``` method:\n- Initialize variables ```maxLength``` to store the length of the longest palindrome found so far and start to store the starting index of the longest palindrome.\n- Iterate through all possible pairs of indexes (i, j) to consider all substrings.\n- For each substring (i, j) check if it's a palindrome using the ```isPalindrome``` method.\n- If it's a palindrome and longer than the current maximum, update ```maxLength``` and start."
                    },
                    {
                        "username": "benlhachemi",
                        "content": "if you passed the \"RUN\" and get the message \"Time Limit Exceeded\" on Submit, your code is correct but the complexity is not.\\nTry to reduce complexity of your algorithm."
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "GigaNigger"
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "My dick is 20 inches"
                    },
                    {
                        "username": "igorKor",
                        "content": "According to the condition of the task, you need to find the longest palindrome.\nWhen tested, the input string is \"babadada\".\nThe test expects to receive \"adada\".\nBut the longest polyndrom in this case will be the substring \"adabada\""
                    },
                    {
                        "username": "AMerrill",
                        "content": "a substring is a set of continuous characters (i.e. you cannot rearrange characters). Thus, for the example given, \"*adada*\" is the longest palindrome that is a substring of \"*babadada*\""
                    },
                    {
                        "username": "mishraanuyesh7",
                        "content": "javascript\\n"
                    },
                    {
                        "username": "showtroylove",
                        "content": "How do you add an image to post?"
                    }
                ]
            },
            {
                "id": 1719259,
                "content": [
                    {
                        "username": "sparasuram",
                        "content": "test case \"ac\" is not a palindromic string. But it shows output as \"a\""
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "we have to find substring, so the string itself could be not palindromic, the answers to that question could be either \"a\" or \"c\", cause they are palindromic"
                    },
                    {
                        "username": "anupamprakash82",
                        "content": "Why O(n^2) solution is giving the TLE? Since the constraint is 1 <= s.length <= 1000, O(n^2) solution should work"
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "[@anupamprakash82](/anupamprakash82) Nuh"
                    },
                    {
                        "username": "anupamprakash82",
                        "content": "[@DamianIvanochko](/DamianIvanochko) is your code getting AC?"
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "bro my solutions is O(n^3)"
                    },
                    {
                        "username": "piyush_mehta22",
                        "content": "if(s.charAt(i) == s.charAt(j) && substring(i,j).length() > longestSubstring.lenght() && isPalindrome(substring(i,j)) {\\nlongestSubstring = substring(i,j);\\n}\\nis much much better than \\nif(isPalindrome(substring(i,j)) {\\n  if(substring.length() > longestSubstring.length()) {\\n     longestubstring = substring(i,j);\\n  }\\n}\\n\\nbecause the first condition first checks whether first and last char are equal or not, then it checks if length is greater or not then it goes for checking is it palindrome or not(which removes  most of the unwanted cases and saves some time), while in second, first it checks the palindrome condition for all string then makes further decision"
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "[@georgezakharov](/georgezakharov) good job lil nigga"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "That\\'s gay, don\\'t post solutions here"
                    },
                    {
                        "username": "jai218",
                        "content": "How do I optimize my code further? \\nI have defined a function outside the class that checks if a string is a palindrome (recursive) and then in the main function i go over all possible substrings starting from the biggest to smallest and checking if that is a palindrome, if True then return that. "
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "anyways your code is still better, mine runs at O(n^3)\\uD83D\\uDC80"
                    },
                    {
                        "username": "AnthonyR21",
                        "content": "## Intuition \n- The problem is to find the longest palndromic substring within a given string.\n- A palindrome reads the same backward as forward.\n- We can use a brute-force approach to check all possible substrings and find the longest one that is also a palindrome.\n\n## Approach\n- Define an ```isPalindrome``` method to check if substring is a palindrome. This method compares characters from the start and end of the substring, moving toward the center.\n- In the ```longestPalindrome``` method:\n- Initialize variables ```maxLength``` to store the length of the longest palindrome found so far and start to store the starting index of the longest palindrome.\n- Iterate through all possible pairs of indexes (i, j) to consider all substrings.\n- For each substring (i, j) check if it's a palindrome using the ```isPalindrome``` method.\n- If it's a palindrome and longer than the current maximum, update ```maxLength``` and start."
                    },
                    {
                        "username": "benlhachemi",
                        "content": "if you passed the \"RUN\" and get the message \"Time Limit Exceeded\" on Submit, your code is correct but the complexity is not.\\nTry to reduce complexity of your algorithm."
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "GigaNigger"
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "My dick is 20 inches"
                    },
                    {
                        "username": "igorKor",
                        "content": "According to the condition of the task, you need to find the longest palindrome.\nWhen tested, the input string is \"babadada\".\nThe test expects to receive \"adada\".\nBut the longest polyndrom in this case will be the substring \"adabada\""
                    },
                    {
                        "username": "AMerrill",
                        "content": "a substring is a set of continuous characters (i.e. you cannot rearrange characters). Thus, for the example given, \"*adada*\" is the longest palindrome that is a substring of \"*babadada*\""
                    },
                    {
                        "username": "mishraanuyesh7",
                        "content": "javascript\\n"
                    },
                    {
                        "username": "showtroylove",
                        "content": "How do you add an image to post?"
                    }
                ]
            },
            {
                "id": 1654196,
                "content": [
                    {
                        "username": "sparasuram",
                        "content": "test case \"ac\" is not a palindromic string. But it shows output as \"a\""
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "we have to find substring, so the string itself could be not palindromic, the answers to that question could be either \"a\" or \"c\", cause they are palindromic"
                    },
                    {
                        "username": "anupamprakash82",
                        "content": "Why O(n^2) solution is giving the TLE? Since the constraint is 1 <= s.length <= 1000, O(n^2) solution should work"
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "[@anupamprakash82](/anupamprakash82) Nuh"
                    },
                    {
                        "username": "anupamprakash82",
                        "content": "[@DamianIvanochko](/DamianIvanochko) is your code getting AC?"
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "bro my solutions is O(n^3)"
                    },
                    {
                        "username": "piyush_mehta22",
                        "content": "if(s.charAt(i) == s.charAt(j) && substring(i,j).length() > longestSubstring.lenght() && isPalindrome(substring(i,j)) {\\nlongestSubstring = substring(i,j);\\n}\\nis much much better than \\nif(isPalindrome(substring(i,j)) {\\n  if(substring.length() > longestSubstring.length()) {\\n     longestubstring = substring(i,j);\\n  }\\n}\\n\\nbecause the first condition first checks whether first and last char are equal or not, then it checks if length is greater or not then it goes for checking is it palindrome or not(which removes  most of the unwanted cases and saves some time), while in second, first it checks the palindrome condition for all string then makes further decision"
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "[@georgezakharov](/georgezakharov) good job lil nigga"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "That\\'s gay, don\\'t post solutions here"
                    },
                    {
                        "username": "jai218",
                        "content": "How do I optimize my code further? \\nI have defined a function outside the class that checks if a string is a palindrome (recursive) and then in the main function i go over all possible substrings starting from the biggest to smallest and checking if that is a palindrome, if True then return that. "
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "anyways your code is still better, mine runs at O(n^3)\\uD83D\\uDC80"
                    },
                    {
                        "username": "AnthonyR21",
                        "content": "## Intuition \n- The problem is to find the longest palndromic substring within a given string.\n- A palindrome reads the same backward as forward.\n- We can use a brute-force approach to check all possible substrings and find the longest one that is also a palindrome.\n\n## Approach\n- Define an ```isPalindrome``` method to check if substring is a palindrome. This method compares characters from the start and end of the substring, moving toward the center.\n- In the ```longestPalindrome``` method:\n- Initialize variables ```maxLength``` to store the length of the longest palindrome found so far and start to store the starting index of the longest palindrome.\n- Iterate through all possible pairs of indexes (i, j) to consider all substrings.\n- For each substring (i, j) check if it's a palindrome using the ```isPalindrome``` method.\n- If it's a palindrome and longer than the current maximum, update ```maxLength``` and start."
                    },
                    {
                        "username": "benlhachemi",
                        "content": "if you passed the \"RUN\" and get the message \"Time Limit Exceeded\" on Submit, your code is correct but the complexity is not.\\nTry to reduce complexity of your algorithm."
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "GigaNigger"
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "My dick is 20 inches"
                    },
                    {
                        "username": "igorKor",
                        "content": "According to the condition of the task, you need to find the longest palindrome.\nWhen tested, the input string is \"babadada\".\nThe test expects to receive \"adada\".\nBut the longest polyndrom in this case will be the substring \"adabada\""
                    },
                    {
                        "username": "AMerrill",
                        "content": "a substring is a set of continuous characters (i.e. you cannot rearrange characters). Thus, for the example given, \"*adada*\" is the longest palindrome that is a substring of \"*babadada*\""
                    },
                    {
                        "username": "mishraanuyesh7",
                        "content": "javascript\\n"
                    },
                    {
                        "username": "showtroylove",
                        "content": "How do you add an image to post?"
                    }
                ]
            },
            {
                "id": 1576613,
                "content": [
                    {
                        "username": "ahtisham225ali",
                        "content": "The Simple Solution to the Problem in python is here https://hecodesit.com/longest-palindromic-substring-solution-python-leetcode/\\n"
                    },
                    {
                        "username": "ahtisham225ali",
                        "content": "The Simple Solution to the Problem in python is here https://hecodesit.com/longest-palindromic-substring-solution-python-leetcode/\\n"
                    },
                    {
                        "username": "Mght_tyb",
                        "content": "![image](https://assets.leetcode.com/users/images/47105dc4-1850-499a-9e78-b90c7e0ac0ef_1639159747.7107038.png)\\n"
                    },
                    {
                        "username": "htt210",
                        "content": "Update: Thank you. It was my misunderstanding.\\n\\nHi there, this is my first time here and I have many stupid questions to ask. \\nI have this test case:\\n\\nInput: aacabdkacaa\\nMy Output: aacabacaa\\nExpected: aca\\n\\nHave you ever encountered this test case? How can we report this error to the author? Thanks"
                    },
                    {
                        "username": "ktime",
                        "content": "I solved it using dynamic programming based on the explanation in\\nhttps://algotree.org/algorithms/dynamic_programming/longest_palindromic_substring/"
                    },
                    {
                        "username": "ambuj100",
                        "content": "The total centers should be equal to the total no. of elements in string which is n then why are there 2n-1 centers ???"
                    },
                    {
                        "username": "delosrd",
                        "content": "I got this given \"aacdefcaa\" when submitting my solution.\\n\\nMy output is \"caa.\" My understanding is that the output could either be \"aac\" or \"caa\" given that \"aacdefcaa\" backwards is \"aacfedcaa\" but the expected output is \"aa.\" Unless my brain is already fried or I think the expected output is wrong?\\n\\n![image](https://assets.leetcode.com/users/images/fbb482d2-1133-4502-ac59-498febd02ded_1600596206.1396868.png)\\n"
                    },
                    {
                        "username": "Itsover12",
                        "content": "[@1shibu](/1shibu) It\\'s \"aa\" because \"caa\" is not a palindrome."
                    },
                    {
                        "username": "1shibu",
                        "content": "\"aac\" is not equal to \"caa\" so it is wrong, but \"aa\" is equal to \"aa\""
                    },
                    {
                        "username": "danyoungmusic93",
                        "content": "Has anyone run into a problem where the testcase runner shows the solution as passing, but the submit button shows different output for the same test case? I ran the same code twice in the test runner and the solution button.\\n\\n![image](https://assets.leetcode.com/users/images/79ac39dd-cdc8-4ee1-bb9c-aef81dc0f46c_1598129427.85128.png)\\n\\n\\nI\\'ve never run into this problem before. This is NOT a Time Limit Exceeded issue, but rather the return value of my solution is different depending on whether I hit submit, or run the test case. Looks like a bug in Leetcode\\'s test cases"
                    },
                    {
                        "username": "max_223",
                        "content": "Alternative non-DP solution here with well-commented code in C++, Java and Python:\\nhttps://www.techiedelight.com/longest-palindromic-substring-non-dp-space-optimized-solution/\\n"
                    },
                    {
                        "username": "baites",
                        "content": "I have an alternative O(n^2) solution using hashing that I discuss in this post: https://baites.github.io/algorithms/algorithm-analysis/2020/03/23/string-hashing-and-palindromes.html\\nAlso, using the same tool, I show how to solve the problem of the Shortest palindrome https://leetcode.com/problems/shortest-palindrome/"
                    },
                    {
                        "username": "monikakumari2k",
                        "content": "okay..bt where is the code :)"
                    }
                ]
            },
            {
                "id": 1576609,
                "content": [
                    {
                        "username": "ahtisham225ali",
                        "content": "The Simple Solution to the Problem in python is here https://hecodesit.com/longest-palindromic-substring-solution-python-leetcode/\\n"
                    },
                    {
                        "username": "ahtisham225ali",
                        "content": "The Simple Solution to the Problem in python is here https://hecodesit.com/longest-palindromic-substring-solution-python-leetcode/\\n"
                    },
                    {
                        "username": "Mght_tyb",
                        "content": "![image](https://assets.leetcode.com/users/images/47105dc4-1850-499a-9e78-b90c7e0ac0ef_1639159747.7107038.png)\\n"
                    },
                    {
                        "username": "htt210",
                        "content": "Update: Thank you. It was my misunderstanding.\\n\\nHi there, this is my first time here and I have many stupid questions to ask. \\nI have this test case:\\n\\nInput: aacabdkacaa\\nMy Output: aacabacaa\\nExpected: aca\\n\\nHave you ever encountered this test case? How can we report this error to the author? Thanks"
                    },
                    {
                        "username": "ktime",
                        "content": "I solved it using dynamic programming based on the explanation in\\nhttps://algotree.org/algorithms/dynamic_programming/longest_palindromic_substring/"
                    },
                    {
                        "username": "ambuj100",
                        "content": "The total centers should be equal to the total no. of elements in string which is n then why are there 2n-1 centers ???"
                    },
                    {
                        "username": "delosrd",
                        "content": "I got this given \"aacdefcaa\" when submitting my solution.\\n\\nMy output is \"caa.\" My understanding is that the output could either be \"aac\" or \"caa\" given that \"aacdefcaa\" backwards is \"aacfedcaa\" but the expected output is \"aa.\" Unless my brain is already fried or I think the expected output is wrong?\\n\\n![image](https://assets.leetcode.com/users/images/fbb482d2-1133-4502-ac59-498febd02ded_1600596206.1396868.png)\\n"
                    },
                    {
                        "username": "Itsover12",
                        "content": "[@1shibu](/1shibu) It\\'s \"aa\" because \"caa\" is not a palindrome."
                    },
                    {
                        "username": "1shibu",
                        "content": "\"aac\" is not equal to \"caa\" so it is wrong, but \"aa\" is equal to \"aa\""
                    },
                    {
                        "username": "danyoungmusic93",
                        "content": "Has anyone run into a problem where the testcase runner shows the solution as passing, but the submit button shows different output for the same test case? I ran the same code twice in the test runner and the solution button.\\n\\n![image](https://assets.leetcode.com/users/images/79ac39dd-cdc8-4ee1-bb9c-aef81dc0f46c_1598129427.85128.png)\\n\\n\\nI\\'ve never run into this problem before. This is NOT a Time Limit Exceeded issue, but rather the return value of my solution is different depending on whether I hit submit, or run the test case. Looks like a bug in Leetcode\\'s test cases"
                    },
                    {
                        "username": "max_223",
                        "content": "Alternative non-DP solution here with well-commented code in C++, Java and Python:\\nhttps://www.techiedelight.com/longest-palindromic-substring-non-dp-space-optimized-solution/\\n"
                    },
                    {
                        "username": "baites",
                        "content": "I have an alternative O(n^2) solution using hashing that I discuss in this post: https://baites.github.io/algorithms/algorithm-analysis/2020/03/23/string-hashing-and-palindromes.html\\nAlso, using the same tool, I show how to solve the problem of the Shortest palindrome https://leetcode.com/problems/shortest-palindrome/"
                    },
                    {
                        "username": "monikakumari2k",
                        "content": "okay..bt where is the code :)"
                    }
                ]
            },
            {
                "id": 1576068,
                "content": [
                    {
                        "username": "ahtisham225ali",
                        "content": "The Simple Solution to the Problem in python is here https://hecodesit.com/longest-palindromic-substring-solution-python-leetcode/\\n"
                    },
                    {
                        "username": "ahtisham225ali",
                        "content": "The Simple Solution to the Problem in python is here https://hecodesit.com/longest-palindromic-substring-solution-python-leetcode/\\n"
                    },
                    {
                        "username": "Mght_tyb",
                        "content": "![image](https://assets.leetcode.com/users/images/47105dc4-1850-499a-9e78-b90c7e0ac0ef_1639159747.7107038.png)\\n"
                    },
                    {
                        "username": "htt210",
                        "content": "Update: Thank you. It was my misunderstanding.\\n\\nHi there, this is my first time here and I have many stupid questions to ask. \\nI have this test case:\\n\\nInput: aacabdkacaa\\nMy Output: aacabacaa\\nExpected: aca\\n\\nHave you ever encountered this test case? How can we report this error to the author? Thanks"
                    },
                    {
                        "username": "ktime",
                        "content": "I solved it using dynamic programming based on the explanation in\\nhttps://algotree.org/algorithms/dynamic_programming/longest_palindromic_substring/"
                    },
                    {
                        "username": "ambuj100",
                        "content": "The total centers should be equal to the total no. of elements in string which is n then why are there 2n-1 centers ???"
                    },
                    {
                        "username": "delosrd",
                        "content": "I got this given \"aacdefcaa\" when submitting my solution.\\n\\nMy output is \"caa.\" My understanding is that the output could either be \"aac\" or \"caa\" given that \"aacdefcaa\" backwards is \"aacfedcaa\" but the expected output is \"aa.\" Unless my brain is already fried or I think the expected output is wrong?\\n\\n![image](https://assets.leetcode.com/users/images/fbb482d2-1133-4502-ac59-498febd02ded_1600596206.1396868.png)\\n"
                    },
                    {
                        "username": "Itsover12",
                        "content": "[@1shibu](/1shibu) It\\'s \"aa\" because \"caa\" is not a palindrome."
                    },
                    {
                        "username": "1shibu",
                        "content": "\"aac\" is not equal to \"caa\" so it is wrong, but \"aa\" is equal to \"aa\""
                    },
                    {
                        "username": "danyoungmusic93",
                        "content": "Has anyone run into a problem where the testcase runner shows the solution as passing, but the submit button shows different output for the same test case? I ran the same code twice in the test runner and the solution button.\\n\\n![image](https://assets.leetcode.com/users/images/79ac39dd-cdc8-4ee1-bb9c-aef81dc0f46c_1598129427.85128.png)\\n\\n\\nI\\'ve never run into this problem before. This is NOT a Time Limit Exceeded issue, but rather the return value of my solution is different depending on whether I hit submit, or run the test case. Looks like a bug in Leetcode\\'s test cases"
                    },
                    {
                        "username": "max_223",
                        "content": "Alternative non-DP solution here with well-commented code in C++, Java and Python:\\nhttps://www.techiedelight.com/longest-palindromic-substring-non-dp-space-optimized-solution/\\n"
                    },
                    {
                        "username": "baites",
                        "content": "I have an alternative O(n^2) solution using hashing that I discuss in this post: https://baites.github.io/algorithms/algorithm-analysis/2020/03/23/string-hashing-and-palindromes.html\\nAlso, using the same tool, I show how to solve the problem of the Shortest palindrome https://leetcode.com/problems/shortest-palindrome/"
                    },
                    {
                        "username": "monikakumari2k",
                        "content": "okay..bt where is the code :)"
                    }
                ]
            },
            {
                "id": 1574881,
                "content": [
                    {
                        "username": "ahtisham225ali",
                        "content": "The Simple Solution to the Problem in python is here https://hecodesit.com/longest-palindromic-substring-solution-python-leetcode/\\n"
                    },
                    {
                        "username": "ahtisham225ali",
                        "content": "The Simple Solution to the Problem in python is here https://hecodesit.com/longest-palindromic-substring-solution-python-leetcode/\\n"
                    },
                    {
                        "username": "Mght_tyb",
                        "content": "![image](https://assets.leetcode.com/users/images/47105dc4-1850-499a-9e78-b90c7e0ac0ef_1639159747.7107038.png)\\n"
                    },
                    {
                        "username": "htt210",
                        "content": "Update: Thank you. It was my misunderstanding.\\n\\nHi there, this is my first time here and I have many stupid questions to ask. \\nI have this test case:\\n\\nInput: aacabdkacaa\\nMy Output: aacabacaa\\nExpected: aca\\n\\nHave you ever encountered this test case? How can we report this error to the author? Thanks"
                    },
                    {
                        "username": "ktime",
                        "content": "I solved it using dynamic programming based on the explanation in\\nhttps://algotree.org/algorithms/dynamic_programming/longest_palindromic_substring/"
                    },
                    {
                        "username": "ambuj100",
                        "content": "The total centers should be equal to the total no. of elements in string which is n then why are there 2n-1 centers ???"
                    },
                    {
                        "username": "delosrd",
                        "content": "I got this given \"aacdefcaa\" when submitting my solution.\\n\\nMy output is \"caa.\" My understanding is that the output could either be \"aac\" or \"caa\" given that \"aacdefcaa\" backwards is \"aacfedcaa\" but the expected output is \"aa.\" Unless my brain is already fried or I think the expected output is wrong?\\n\\n![image](https://assets.leetcode.com/users/images/fbb482d2-1133-4502-ac59-498febd02ded_1600596206.1396868.png)\\n"
                    },
                    {
                        "username": "Itsover12",
                        "content": "[@1shibu](/1shibu) It\\'s \"aa\" because \"caa\" is not a palindrome."
                    },
                    {
                        "username": "1shibu",
                        "content": "\"aac\" is not equal to \"caa\" so it is wrong, but \"aa\" is equal to \"aa\""
                    },
                    {
                        "username": "danyoungmusic93",
                        "content": "Has anyone run into a problem where the testcase runner shows the solution as passing, but the submit button shows different output for the same test case? I ran the same code twice in the test runner and the solution button.\\n\\n![image](https://assets.leetcode.com/users/images/79ac39dd-cdc8-4ee1-bb9c-aef81dc0f46c_1598129427.85128.png)\\n\\n\\nI\\'ve never run into this problem before. This is NOT a Time Limit Exceeded issue, but rather the return value of my solution is different depending on whether I hit submit, or run the test case. Looks like a bug in Leetcode\\'s test cases"
                    },
                    {
                        "username": "max_223",
                        "content": "Alternative non-DP solution here with well-commented code in C++, Java and Python:\\nhttps://www.techiedelight.com/longest-palindromic-substring-non-dp-space-optimized-solution/\\n"
                    },
                    {
                        "username": "baites",
                        "content": "I have an alternative O(n^2) solution using hashing that I discuss in this post: https://baites.github.io/algorithms/algorithm-analysis/2020/03/23/string-hashing-and-palindromes.html\\nAlso, using the same tool, I show how to solve the problem of the Shortest palindrome https://leetcode.com/problems/shortest-palindrome/"
                    },
                    {
                        "username": "monikakumari2k",
                        "content": "okay..bt where is the code :)"
                    }
                ]
            },
            {
                "id": 1574873,
                "content": [
                    {
                        "username": "ahtisham225ali",
                        "content": "The Simple Solution to the Problem in python is here https://hecodesit.com/longest-palindromic-substring-solution-python-leetcode/\\n"
                    },
                    {
                        "username": "ahtisham225ali",
                        "content": "The Simple Solution to the Problem in python is here https://hecodesit.com/longest-palindromic-substring-solution-python-leetcode/\\n"
                    },
                    {
                        "username": "Mght_tyb",
                        "content": "![image](https://assets.leetcode.com/users/images/47105dc4-1850-499a-9e78-b90c7e0ac0ef_1639159747.7107038.png)\\n"
                    },
                    {
                        "username": "htt210",
                        "content": "Update: Thank you. It was my misunderstanding.\\n\\nHi there, this is my first time here and I have many stupid questions to ask. \\nI have this test case:\\n\\nInput: aacabdkacaa\\nMy Output: aacabacaa\\nExpected: aca\\n\\nHave you ever encountered this test case? How can we report this error to the author? Thanks"
                    },
                    {
                        "username": "ktime",
                        "content": "I solved it using dynamic programming based on the explanation in\\nhttps://algotree.org/algorithms/dynamic_programming/longest_palindromic_substring/"
                    },
                    {
                        "username": "ambuj100",
                        "content": "The total centers should be equal to the total no. of elements in string which is n then why are there 2n-1 centers ???"
                    },
                    {
                        "username": "delosrd",
                        "content": "I got this given \"aacdefcaa\" when submitting my solution.\\n\\nMy output is \"caa.\" My understanding is that the output could either be \"aac\" or \"caa\" given that \"aacdefcaa\" backwards is \"aacfedcaa\" but the expected output is \"aa.\" Unless my brain is already fried or I think the expected output is wrong?\\n\\n![image](https://assets.leetcode.com/users/images/fbb482d2-1133-4502-ac59-498febd02ded_1600596206.1396868.png)\\n"
                    },
                    {
                        "username": "Itsover12",
                        "content": "[@1shibu](/1shibu) It\\'s \"aa\" because \"caa\" is not a palindrome."
                    },
                    {
                        "username": "1shibu",
                        "content": "\"aac\" is not equal to \"caa\" so it is wrong, but \"aa\" is equal to \"aa\""
                    },
                    {
                        "username": "danyoungmusic93",
                        "content": "Has anyone run into a problem where the testcase runner shows the solution as passing, but the submit button shows different output for the same test case? I ran the same code twice in the test runner and the solution button.\\n\\n![image](https://assets.leetcode.com/users/images/79ac39dd-cdc8-4ee1-bb9c-aef81dc0f46c_1598129427.85128.png)\\n\\n\\nI\\'ve never run into this problem before. This is NOT a Time Limit Exceeded issue, but rather the return value of my solution is different depending on whether I hit submit, or run the test case. Looks like a bug in Leetcode\\'s test cases"
                    },
                    {
                        "username": "max_223",
                        "content": "Alternative non-DP solution here with well-commented code in C++, Java and Python:\\nhttps://www.techiedelight.com/longest-palindromic-substring-non-dp-space-optimized-solution/\\n"
                    },
                    {
                        "username": "baites",
                        "content": "I have an alternative O(n^2) solution using hashing that I discuss in this post: https://baites.github.io/algorithms/algorithm-analysis/2020/03/23/string-hashing-and-palindromes.html\\nAlso, using the same tool, I show how to solve the problem of the Shortest palindrome https://leetcode.com/problems/shortest-palindrome/"
                    },
                    {
                        "username": "monikakumari2k",
                        "content": "okay..bt where is the code :)"
                    }
                ]
            },
            {
                "id": 1574859,
                "content": [
                    {
                        "username": "ahtisham225ali",
                        "content": "The Simple Solution to the Problem in python is here https://hecodesit.com/longest-palindromic-substring-solution-python-leetcode/\\n"
                    },
                    {
                        "username": "ahtisham225ali",
                        "content": "The Simple Solution to the Problem in python is here https://hecodesit.com/longest-palindromic-substring-solution-python-leetcode/\\n"
                    },
                    {
                        "username": "Mght_tyb",
                        "content": "![image](https://assets.leetcode.com/users/images/47105dc4-1850-499a-9e78-b90c7e0ac0ef_1639159747.7107038.png)\\n"
                    },
                    {
                        "username": "htt210",
                        "content": "Update: Thank you. It was my misunderstanding.\\n\\nHi there, this is my first time here and I have many stupid questions to ask. \\nI have this test case:\\n\\nInput: aacabdkacaa\\nMy Output: aacabacaa\\nExpected: aca\\n\\nHave you ever encountered this test case? How can we report this error to the author? Thanks"
                    },
                    {
                        "username": "ktime",
                        "content": "I solved it using dynamic programming based on the explanation in\\nhttps://algotree.org/algorithms/dynamic_programming/longest_palindromic_substring/"
                    },
                    {
                        "username": "ambuj100",
                        "content": "The total centers should be equal to the total no. of elements in string which is n then why are there 2n-1 centers ???"
                    },
                    {
                        "username": "delosrd",
                        "content": "I got this given \"aacdefcaa\" when submitting my solution.\\n\\nMy output is \"caa.\" My understanding is that the output could either be \"aac\" or \"caa\" given that \"aacdefcaa\" backwards is \"aacfedcaa\" but the expected output is \"aa.\" Unless my brain is already fried or I think the expected output is wrong?\\n\\n![image](https://assets.leetcode.com/users/images/fbb482d2-1133-4502-ac59-498febd02ded_1600596206.1396868.png)\\n"
                    },
                    {
                        "username": "Itsover12",
                        "content": "[@1shibu](/1shibu) It\\'s \"aa\" because \"caa\" is not a palindrome."
                    },
                    {
                        "username": "1shibu",
                        "content": "\"aac\" is not equal to \"caa\" so it is wrong, but \"aa\" is equal to \"aa\""
                    },
                    {
                        "username": "danyoungmusic93",
                        "content": "Has anyone run into a problem where the testcase runner shows the solution as passing, but the submit button shows different output for the same test case? I ran the same code twice in the test runner and the solution button.\\n\\n![image](https://assets.leetcode.com/users/images/79ac39dd-cdc8-4ee1-bb9c-aef81dc0f46c_1598129427.85128.png)\\n\\n\\nI\\'ve never run into this problem before. This is NOT a Time Limit Exceeded issue, but rather the return value of my solution is different depending on whether I hit submit, or run the test case. Looks like a bug in Leetcode\\'s test cases"
                    },
                    {
                        "username": "max_223",
                        "content": "Alternative non-DP solution here with well-commented code in C++, Java and Python:\\nhttps://www.techiedelight.com/longest-palindromic-substring-non-dp-space-optimized-solution/\\n"
                    },
                    {
                        "username": "baites",
                        "content": "I have an alternative O(n^2) solution using hashing that I discuss in this post: https://baites.github.io/algorithms/algorithm-analysis/2020/03/23/string-hashing-and-palindromes.html\\nAlso, using the same tool, I show how to solve the problem of the Shortest palindrome https://leetcode.com/problems/shortest-palindrome/"
                    },
                    {
                        "username": "monikakumari2k",
                        "content": "okay..bt where is the code :)"
                    }
                ]
            },
            {
                "id": 1574395,
                "content": [
                    {
                        "username": "ahtisham225ali",
                        "content": "The Simple Solution to the Problem in python is here https://hecodesit.com/longest-palindromic-substring-solution-python-leetcode/\\n"
                    },
                    {
                        "username": "ahtisham225ali",
                        "content": "The Simple Solution to the Problem in python is here https://hecodesit.com/longest-palindromic-substring-solution-python-leetcode/\\n"
                    },
                    {
                        "username": "Mght_tyb",
                        "content": "![image](https://assets.leetcode.com/users/images/47105dc4-1850-499a-9e78-b90c7e0ac0ef_1639159747.7107038.png)\\n"
                    },
                    {
                        "username": "htt210",
                        "content": "Update: Thank you. It was my misunderstanding.\\n\\nHi there, this is my first time here and I have many stupid questions to ask. \\nI have this test case:\\n\\nInput: aacabdkacaa\\nMy Output: aacabacaa\\nExpected: aca\\n\\nHave you ever encountered this test case? How can we report this error to the author? Thanks"
                    },
                    {
                        "username": "ktime",
                        "content": "I solved it using dynamic programming based on the explanation in\\nhttps://algotree.org/algorithms/dynamic_programming/longest_palindromic_substring/"
                    },
                    {
                        "username": "ambuj100",
                        "content": "The total centers should be equal to the total no. of elements in string which is n then why are there 2n-1 centers ???"
                    },
                    {
                        "username": "delosrd",
                        "content": "I got this given \"aacdefcaa\" when submitting my solution.\\n\\nMy output is \"caa.\" My understanding is that the output could either be \"aac\" or \"caa\" given that \"aacdefcaa\" backwards is \"aacfedcaa\" but the expected output is \"aa.\" Unless my brain is already fried or I think the expected output is wrong?\\n\\n![image](https://assets.leetcode.com/users/images/fbb482d2-1133-4502-ac59-498febd02ded_1600596206.1396868.png)\\n"
                    },
                    {
                        "username": "Itsover12",
                        "content": "[@1shibu](/1shibu) It\\'s \"aa\" because \"caa\" is not a palindrome."
                    },
                    {
                        "username": "1shibu",
                        "content": "\"aac\" is not equal to \"caa\" so it is wrong, but \"aa\" is equal to \"aa\""
                    },
                    {
                        "username": "danyoungmusic93",
                        "content": "Has anyone run into a problem where the testcase runner shows the solution as passing, but the submit button shows different output for the same test case? I ran the same code twice in the test runner and the solution button.\\n\\n![image](https://assets.leetcode.com/users/images/79ac39dd-cdc8-4ee1-bb9c-aef81dc0f46c_1598129427.85128.png)\\n\\n\\nI\\'ve never run into this problem before. This is NOT a Time Limit Exceeded issue, but rather the return value of my solution is different depending on whether I hit submit, or run the test case. Looks like a bug in Leetcode\\'s test cases"
                    },
                    {
                        "username": "max_223",
                        "content": "Alternative non-DP solution here with well-commented code in C++, Java and Python:\\nhttps://www.techiedelight.com/longest-palindromic-substring-non-dp-space-optimized-solution/\\n"
                    },
                    {
                        "username": "baites",
                        "content": "I have an alternative O(n^2) solution using hashing that I discuss in this post: https://baites.github.io/algorithms/algorithm-analysis/2020/03/23/string-hashing-and-palindromes.html\\nAlso, using the same tool, I show how to solve the problem of the Shortest palindrome https://leetcode.com/problems/shortest-palindrome/"
                    },
                    {
                        "username": "monikakumari2k",
                        "content": "okay..bt where is the code :)"
                    }
                ]
            },
            {
                "id": 1574261,
                "content": [
                    {
                        "username": "ahtisham225ali",
                        "content": "The Simple Solution to the Problem in python is here https://hecodesit.com/longest-palindromic-substring-solution-python-leetcode/\\n"
                    },
                    {
                        "username": "ahtisham225ali",
                        "content": "The Simple Solution to the Problem in python is here https://hecodesit.com/longest-palindromic-substring-solution-python-leetcode/\\n"
                    },
                    {
                        "username": "Mght_tyb",
                        "content": "![image](https://assets.leetcode.com/users/images/47105dc4-1850-499a-9e78-b90c7e0ac0ef_1639159747.7107038.png)\\n"
                    },
                    {
                        "username": "htt210",
                        "content": "Update: Thank you. It was my misunderstanding.\\n\\nHi there, this is my first time here and I have many stupid questions to ask. \\nI have this test case:\\n\\nInput: aacabdkacaa\\nMy Output: aacabacaa\\nExpected: aca\\n\\nHave you ever encountered this test case? How can we report this error to the author? Thanks"
                    },
                    {
                        "username": "ktime",
                        "content": "I solved it using dynamic programming based on the explanation in\\nhttps://algotree.org/algorithms/dynamic_programming/longest_palindromic_substring/"
                    },
                    {
                        "username": "ambuj100",
                        "content": "The total centers should be equal to the total no. of elements in string which is n then why are there 2n-1 centers ???"
                    },
                    {
                        "username": "delosrd",
                        "content": "I got this given \"aacdefcaa\" when submitting my solution.\\n\\nMy output is \"caa.\" My understanding is that the output could either be \"aac\" or \"caa\" given that \"aacdefcaa\" backwards is \"aacfedcaa\" but the expected output is \"aa.\" Unless my brain is already fried or I think the expected output is wrong?\\n\\n![image](https://assets.leetcode.com/users/images/fbb482d2-1133-4502-ac59-498febd02ded_1600596206.1396868.png)\\n"
                    },
                    {
                        "username": "Itsover12",
                        "content": "[@1shibu](/1shibu) It\\'s \"aa\" because \"caa\" is not a palindrome."
                    },
                    {
                        "username": "1shibu",
                        "content": "\"aac\" is not equal to \"caa\" so it is wrong, but \"aa\" is equal to \"aa\""
                    },
                    {
                        "username": "danyoungmusic93",
                        "content": "Has anyone run into a problem where the testcase runner shows the solution as passing, but the submit button shows different output for the same test case? I ran the same code twice in the test runner and the solution button.\\n\\n![image](https://assets.leetcode.com/users/images/79ac39dd-cdc8-4ee1-bb9c-aef81dc0f46c_1598129427.85128.png)\\n\\n\\nI\\'ve never run into this problem before. This is NOT a Time Limit Exceeded issue, but rather the return value of my solution is different depending on whether I hit submit, or run the test case. Looks like a bug in Leetcode\\'s test cases"
                    },
                    {
                        "username": "max_223",
                        "content": "Alternative non-DP solution here with well-commented code in C++, Java and Python:\\nhttps://www.techiedelight.com/longest-palindromic-substring-non-dp-space-optimized-solution/\\n"
                    },
                    {
                        "username": "baites",
                        "content": "I have an alternative O(n^2) solution using hashing that I discuss in this post: https://baites.github.io/algorithms/algorithm-analysis/2020/03/23/string-hashing-and-palindromes.html\\nAlso, using the same tool, I show how to solve the problem of the Shortest palindrome https://leetcode.com/problems/shortest-palindrome/"
                    },
                    {
                        "username": "monikakumari2k",
                        "content": "okay..bt where is the code :)"
                    }
                ]
            },
            {
                "id": 1573935,
                "content": [
                    {
                        "username": "ahtisham225ali",
                        "content": "The Simple Solution to the Problem in python is here https://hecodesit.com/longest-palindromic-substring-solution-python-leetcode/\\n"
                    },
                    {
                        "username": "ahtisham225ali",
                        "content": "The Simple Solution to the Problem in python is here https://hecodesit.com/longest-palindromic-substring-solution-python-leetcode/\\n"
                    },
                    {
                        "username": "Mght_tyb",
                        "content": "![image](https://assets.leetcode.com/users/images/47105dc4-1850-499a-9e78-b90c7e0ac0ef_1639159747.7107038.png)\\n"
                    },
                    {
                        "username": "htt210",
                        "content": "Update: Thank you. It was my misunderstanding.\\n\\nHi there, this is my first time here and I have many stupid questions to ask. \\nI have this test case:\\n\\nInput: aacabdkacaa\\nMy Output: aacabacaa\\nExpected: aca\\n\\nHave you ever encountered this test case? How can we report this error to the author? Thanks"
                    },
                    {
                        "username": "ktime",
                        "content": "I solved it using dynamic programming based on the explanation in\\nhttps://algotree.org/algorithms/dynamic_programming/longest_palindromic_substring/"
                    },
                    {
                        "username": "ambuj100",
                        "content": "The total centers should be equal to the total no. of elements in string which is n then why are there 2n-1 centers ???"
                    },
                    {
                        "username": "delosrd",
                        "content": "I got this given \"aacdefcaa\" when submitting my solution.\\n\\nMy output is \"caa.\" My understanding is that the output could either be \"aac\" or \"caa\" given that \"aacdefcaa\" backwards is \"aacfedcaa\" but the expected output is \"aa.\" Unless my brain is already fried or I think the expected output is wrong?\\n\\n![image](https://assets.leetcode.com/users/images/fbb482d2-1133-4502-ac59-498febd02ded_1600596206.1396868.png)\\n"
                    },
                    {
                        "username": "Itsover12",
                        "content": "[@1shibu](/1shibu) It\\'s \"aa\" because \"caa\" is not a palindrome."
                    },
                    {
                        "username": "1shibu",
                        "content": "\"aac\" is not equal to \"caa\" so it is wrong, but \"aa\" is equal to \"aa\""
                    },
                    {
                        "username": "danyoungmusic93",
                        "content": "Has anyone run into a problem where the testcase runner shows the solution as passing, but the submit button shows different output for the same test case? I ran the same code twice in the test runner and the solution button.\\n\\n![image](https://assets.leetcode.com/users/images/79ac39dd-cdc8-4ee1-bb9c-aef81dc0f46c_1598129427.85128.png)\\n\\n\\nI\\'ve never run into this problem before. This is NOT a Time Limit Exceeded issue, but rather the return value of my solution is different depending on whether I hit submit, or run the test case. Looks like a bug in Leetcode\\'s test cases"
                    },
                    {
                        "username": "max_223",
                        "content": "Alternative non-DP solution here with well-commented code in C++, Java and Python:\\nhttps://www.techiedelight.com/longest-palindromic-substring-non-dp-space-optimized-solution/\\n"
                    },
                    {
                        "username": "baites",
                        "content": "I have an alternative O(n^2) solution using hashing that I discuss in this post: https://baites.github.io/algorithms/algorithm-analysis/2020/03/23/string-hashing-and-palindromes.html\\nAlso, using the same tool, I show how to solve the problem of the Shortest palindrome https://leetcode.com/problems/shortest-palindrome/"
                    },
                    {
                        "username": "monikakumari2k",
                        "content": "okay..bt where is the code :)"
                    }
                ]
            },
            {
                "id": 1573543,
                "content": [
                    {
                        "username": "ahtisham225ali",
                        "content": "The Simple Solution to the Problem in python is here https://hecodesit.com/longest-palindromic-substring-solution-python-leetcode/\\n"
                    },
                    {
                        "username": "ahtisham225ali",
                        "content": "The Simple Solution to the Problem in python is here https://hecodesit.com/longest-palindromic-substring-solution-python-leetcode/\\n"
                    },
                    {
                        "username": "Mght_tyb",
                        "content": "![image](https://assets.leetcode.com/users/images/47105dc4-1850-499a-9e78-b90c7e0ac0ef_1639159747.7107038.png)\\n"
                    },
                    {
                        "username": "htt210",
                        "content": "Update: Thank you. It was my misunderstanding.\\n\\nHi there, this is my first time here and I have many stupid questions to ask. \\nI have this test case:\\n\\nInput: aacabdkacaa\\nMy Output: aacabacaa\\nExpected: aca\\n\\nHave you ever encountered this test case? How can we report this error to the author? Thanks"
                    },
                    {
                        "username": "ktime",
                        "content": "I solved it using dynamic programming based on the explanation in\\nhttps://algotree.org/algorithms/dynamic_programming/longest_palindromic_substring/"
                    },
                    {
                        "username": "ambuj100",
                        "content": "The total centers should be equal to the total no. of elements in string which is n then why are there 2n-1 centers ???"
                    },
                    {
                        "username": "delosrd",
                        "content": "I got this given \"aacdefcaa\" when submitting my solution.\\n\\nMy output is \"caa.\" My understanding is that the output could either be \"aac\" or \"caa\" given that \"aacdefcaa\" backwards is \"aacfedcaa\" but the expected output is \"aa.\" Unless my brain is already fried or I think the expected output is wrong?\\n\\n![image](https://assets.leetcode.com/users/images/fbb482d2-1133-4502-ac59-498febd02ded_1600596206.1396868.png)\\n"
                    },
                    {
                        "username": "Itsover12",
                        "content": "[@1shibu](/1shibu) It\\'s \"aa\" because \"caa\" is not a palindrome."
                    },
                    {
                        "username": "1shibu",
                        "content": "\"aac\" is not equal to \"caa\" so it is wrong, but \"aa\" is equal to \"aa\""
                    },
                    {
                        "username": "danyoungmusic93",
                        "content": "Has anyone run into a problem where the testcase runner shows the solution as passing, but the submit button shows different output for the same test case? I ran the same code twice in the test runner and the solution button.\\n\\n![image](https://assets.leetcode.com/users/images/79ac39dd-cdc8-4ee1-bb9c-aef81dc0f46c_1598129427.85128.png)\\n\\n\\nI\\'ve never run into this problem before. This is NOT a Time Limit Exceeded issue, but rather the return value of my solution is different depending on whether I hit submit, or run the test case. Looks like a bug in Leetcode\\'s test cases"
                    },
                    {
                        "username": "max_223",
                        "content": "Alternative non-DP solution here with well-commented code in C++, Java and Python:\\nhttps://www.techiedelight.com/longest-palindromic-substring-non-dp-space-optimized-solution/\\n"
                    },
                    {
                        "username": "baites",
                        "content": "I have an alternative O(n^2) solution using hashing that I discuss in this post: https://baites.github.io/algorithms/algorithm-analysis/2020/03/23/string-hashing-and-palindromes.html\\nAlso, using the same tool, I show how to solve the problem of the Shortest palindrome https://leetcode.com/problems/shortest-palindrome/"
                    },
                    {
                        "username": "monikakumari2k",
                        "content": "okay..bt where is the code :)"
                    }
                ]
            },
            {
                "id": 1573060,
                "content": [
                    {
                        "username": "mp0wr",
                        "content": "The problem statement claims the grader will accept alternate correct answers.\\n> Note: \"aba\" is also a valid answer.\\n\\nMy code takes \"babad\" as input, and outputs \"aba\".\\n\\n## Using [Run Code]\\nGrader returns:\\n> Expected \"bab\"\\n\\nThere\\'s no way (other than [Submit]) to know that another palindrome of equal length is accepted. \\n"
                    },
                    {
                        "username": "jamespaz311",
                        "content": "Did i miss something? I know that palindromic is when String s==s(reversed) but how it end up \"a\" from \"ac\"?"
                    },
                    {
                        "username": "user2531u",
                        "content": "Has anyone come across this in an actual interview?"
                    },
                    {
                        "username": "supreme_dalek",
                        "content": "If anyone understands \"a\" from \"ac\" to fit the definition of a palindrome, can you please let me know by providing a link or citation to an authoratative source stating as much?\\n\\nThanks,\\nmr.T\\n"
                    },
                    {
                        "username": "gktk",
                        "content": "The link to Manacher\\'s algorithm provided in the Solution section is dead: https://articles.leetcode.com/longest-palindromic-substring-part-ii/\\n\\nI get a database error. Could someone please fix it? Thanks!"
                    },
                    {
                        "username": "RayYang_",
                        "content": "see the picture , what\\'s wrong with this?\\n![image](https://s3-lc-upload.s3.amazonaws.com/users/rayyang_/image_1536665252.png)\\n"
                    },
                    {
                        "username": "rabeeh",
                        "content": "Hi, \\nwhen I submit my codes, judge keep being pending, I wonder if anyone has how to solve it.\\nThanks."
                    },
                    {
                        "username": "aaaaaqi5",
                        "content": "Why input \"abcda\" should return \"a\"? \\nDoesn't make sense at all!\\n\\nCan anyone explain?"
                    },
                    {
                        "username": "Future6",
                        "content": "Should the answer be \"aacakacaa\"?\\n\\nBut it gives \"aca\" as correct answer. Did i miss something here?"
                    },
                    {
                        "username": "AssasianKing",
                        "content": "Can be easily solved using [Manacher\\u2019s Algorithm](httphttps://en.wikipedia.org/wiki/Longest_palindromic_substring#Manacher.27s_algorithm://) .\\n\\nRefer\": https://www.hackerearth.com/practice/algorithms/string-algorithm/manachars-algorithm/tutorial/\\n\\n\\n"
                    }
                ]
            },
            {
                "id": 1572778,
                "content": [
                    {
                        "username": "mp0wr",
                        "content": "The problem statement claims the grader will accept alternate correct answers.\\n> Note: \"aba\" is also a valid answer.\\n\\nMy code takes \"babad\" as input, and outputs \"aba\".\\n\\n## Using [Run Code]\\nGrader returns:\\n> Expected \"bab\"\\n\\nThere\\'s no way (other than [Submit]) to know that another palindrome of equal length is accepted. \\n"
                    },
                    {
                        "username": "jamespaz311",
                        "content": "Did i miss something? I know that palindromic is when String s==s(reversed) but how it end up \"a\" from \"ac\"?"
                    },
                    {
                        "username": "user2531u",
                        "content": "Has anyone come across this in an actual interview?"
                    },
                    {
                        "username": "supreme_dalek",
                        "content": "If anyone understands \"a\" from \"ac\" to fit the definition of a palindrome, can you please let me know by providing a link or citation to an authoratative source stating as much?\\n\\nThanks,\\nmr.T\\n"
                    },
                    {
                        "username": "gktk",
                        "content": "The link to Manacher\\'s algorithm provided in the Solution section is dead: https://articles.leetcode.com/longest-palindromic-substring-part-ii/\\n\\nI get a database error. Could someone please fix it? Thanks!"
                    },
                    {
                        "username": "RayYang_",
                        "content": "see the picture , what\\'s wrong with this?\\n![image](https://s3-lc-upload.s3.amazonaws.com/users/rayyang_/image_1536665252.png)\\n"
                    },
                    {
                        "username": "rabeeh",
                        "content": "Hi, \\nwhen I submit my codes, judge keep being pending, I wonder if anyone has how to solve it.\\nThanks."
                    },
                    {
                        "username": "aaaaaqi5",
                        "content": "Why input \"abcda\" should return \"a\"? \\nDoesn't make sense at all!\\n\\nCan anyone explain?"
                    },
                    {
                        "username": "Future6",
                        "content": "Should the answer be \"aacakacaa\"?\\n\\nBut it gives \"aca\" as correct answer. Did i miss something here?"
                    },
                    {
                        "username": "AssasianKing",
                        "content": "Can be easily solved using [Manacher\\u2019s Algorithm](httphttps://en.wikipedia.org/wiki/Longest_palindromic_substring#Manacher.27s_algorithm://) .\\n\\nRefer\": https://www.hackerearth.com/practice/algorithms/string-algorithm/manachars-algorithm/tutorial/\\n\\n\\n"
                    }
                ]
            },
            {
                "id": 1572743,
                "content": [
                    {
                        "username": "mp0wr",
                        "content": "The problem statement claims the grader will accept alternate correct answers.\\n> Note: \"aba\" is also a valid answer.\\n\\nMy code takes \"babad\" as input, and outputs \"aba\".\\n\\n## Using [Run Code]\\nGrader returns:\\n> Expected \"bab\"\\n\\nThere\\'s no way (other than [Submit]) to know that another palindrome of equal length is accepted. \\n"
                    },
                    {
                        "username": "jamespaz311",
                        "content": "Did i miss something? I know that palindromic is when String s==s(reversed) but how it end up \"a\" from \"ac\"?"
                    },
                    {
                        "username": "user2531u",
                        "content": "Has anyone come across this in an actual interview?"
                    },
                    {
                        "username": "supreme_dalek",
                        "content": "If anyone understands \"a\" from \"ac\" to fit the definition of a palindrome, can you please let me know by providing a link or citation to an authoratative source stating as much?\\n\\nThanks,\\nmr.T\\n"
                    },
                    {
                        "username": "gktk",
                        "content": "The link to Manacher\\'s algorithm provided in the Solution section is dead: https://articles.leetcode.com/longest-palindromic-substring-part-ii/\\n\\nI get a database error. Could someone please fix it? Thanks!"
                    },
                    {
                        "username": "RayYang_",
                        "content": "see the picture , what\\'s wrong with this?\\n![image](https://s3-lc-upload.s3.amazonaws.com/users/rayyang_/image_1536665252.png)\\n"
                    },
                    {
                        "username": "rabeeh",
                        "content": "Hi, \\nwhen I submit my codes, judge keep being pending, I wonder if anyone has how to solve it.\\nThanks."
                    },
                    {
                        "username": "aaaaaqi5",
                        "content": "Why input \"abcda\" should return \"a\"? \\nDoesn't make sense at all!\\n\\nCan anyone explain?"
                    },
                    {
                        "username": "Future6",
                        "content": "Should the answer be \"aacakacaa\"?\\n\\nBut it gives \"aca\" as correct answer. Did i miss something here?"
                    },
                    {
                        "username": "AssasianKing",
                        "content": "Can be easily solved using [Manacher\\u2019s Algorithm](httphttps://en.wikipedia.org/wiki/Longest_palindromic_substring#Manacher.27s_algorithm://) .\\n\\nRefer\": https://www.hackerearth.com/practice/algorithms/string-algorithm/manachars-algorithm/tutorial/\\n\\n\\n"
                    }
                ]
            },
            {
                "id": 1572529,
                "content": [
                    {
                        "username": "mp0wr",
                        "content": "The problem statement claims the grader will accept alternate correct answers.\\n> Note: \"aba\" is also a valid answer.\\n\\nMy code takes \"babad\" as input, and outputs \"aba\".\\n\\n## Using [Run Code]\\nGrader returns:\\n> Expected \"bab\"\\n\\nThere\\'s no way (other than [Submit]) to know that another palindrome of equal length is accepted. \\n"
                    },
                    {
                        "username": "jamespaz311",
                        "content": "Did i miss something? I know that palindromic is when String s==s(reversed) but how it end up \"a\" from \"ac\"?"
                    },
                    {
                        "username": "user2531u",
                        "content": "Has anyone come across this in an actual interview?"
                    },
                    {
                        "username": "supreme_dalek",
                        "content": "If anyone understands \"a\" from \"ac\" to fit the definition of a palindrome, can you please let me know by providing a link or citation to an authoratative source stating as much?\\n\\nThanks,\\nmr.T\\n"
                    },
                    {
                        "username": "gktk",
                        "content": "The link to Manacher\\'s algorithm provided in the Solution section is dead: https://articles.leetcode.com/longest-palindromic-substring-part-ii/\\n\\nI get a database error. Could someone please fix it? Thanks!"
                    },
                    {
                        "username": "RayYang_",
                        "content": "see the picture , what\\'s wrong with this?\\n![image](https://s3-lc-upload.s3.amazonaws.com/users/rayyang_/image_1536665252.png)\\n"
                    },
                    {
                        "username": "rabeeh",
                        "content": "Hi, \\nwhen I submit my codes, judge keep being pending, I wonder if anyone has how to solve it.\\nThanks."
                    },
                    {
                        "username": "aaaaaqi5",
                        "content": "Why input \"abcda\" should return \"a\"? \\nDoesn't make sense at all!\\n\\nCan anyone explain?"
                    },
                    {
                        "username": "Future6",
                        "content": "Should the answer be \"aacakacaa\"?\\n\\nBut it gives \"aca\" as correct answer. Did i miss something here?"
                    },
                    {
                        "username": "AssasianKing",
                        "content": "Can be easily solved using [Manacher\\u2019s Algorithm](httphttps://en.wikipedia.org/wiki/Longest_palindromic_substring#Manacher.27s_algorithm://) .\\n\\nRefer\": https://www.hackerearth.com/practice/algorithms/string-algorithm/manachars-algorithm/tutorial/\\n\\n\\n"
                    }
                ]
            },
            {
                "id": 1572481,
                "content": [
                    {
                        "username": "mp0wr",
                        "content": "The problem statement claims the grader will accept alternate correct answers.\\n> Note: \"aba\" is also a valid answer.\\n\\nMy code takes \"babad\" as input, and outputs \"aba\".\\n\\n## Using [Run Code]\\nGrader returns:\\n> Expected \"bab\"\\n\\nThere\\'s no way (other than [Submit]) to know that another palindrome of equal length is accepted. \\n"
                    },
                    {
                        "username": "jamespaz311",
                        "content": "Did i miss something? I know that palindromic is when String s==s(reversed) but how it end up \"a\" from \"ac\"?"
                    },
                    {
                        "username": "user2531u",
                        "content": "Has anyone come across this in an actual interview?"
                    },
                    {
                        "username": "supreme_dalek",
                        "content": "If anyone understands \"a\" from \"ac\" to fit the definition of a palindrome, can you please let me know by providing a link or citation to an authoratative source stating as much?\\n\\nThanks,\\nmr.T\\n"
                    },
                    {
                        "username": "gktk",
                        "content": "The link to Manacher\\'s algorithm provided in the Solution section is dead: https://articles.leetcode.com/longest-palindromic-substring-part-ii/\\n\\nI get a database error. Could someone please fix it? Thanks!"
                    },
                    {
                        "username": "RayYang_",
                        "content": "see the picture , what\\'s wrong with this?\\n![image](https://s3-lc-upload.s3.amazonaws.com/users/rayyang_/image_1536665252.png)\\n"
                    },
                    {
                        "username": "rabeeh",
                        "content": "Hi, \\nwhen I submit my codes, judge keep being pending, I wonder if anyone has how to solve it.\\nThanks."
                    },
                    {
                        "username": "aaaaaqi5",
                        "content": "Why input \"abcda\" should return \"a\"? \\nDoesn't make sense at all!\\n\\nCan anyone explain?"
                    },
                    {
                        "username": "Future6",
                        "content": "Should the answer be \"aacakacaa\"?\\n\\nBut it gives \"aca\" as correct answer. Did i miss something here?"
                    },
                    {
                        "username": "AssasianKing",
                        "content": "Can be easily solved using [Manacher\\u2019s Algorithm](httphttps://en.wikipedia.org/wiki/Longest_palindromic_substring#Manacher.27s_algorithm://) .\\n\\nRefer\": https://www.hackerearth.com/practice/algorithms/string-algorithm/manachars-algorithm/tutorial/\\n\\n\\n"
                    }
                ]
            },
            {
                "id": 1572141,
                "content": [
                    {
                        "username": "mp0wr",
                        "content": "The problem statement claims the grader will accept alternate correct answers.\\n> Note: \"aba\" is also a valid answer.\\n\\nMy code takes \"babad\" as input, and outputs \"aba\".\\n\\n## Using [Run Code]\\nGrader returns:\\n> Expected \"bab\"\\n\\nThere\\'s no way (other than [Submit]) to know that another palindrome of equal length is accepted. \\n"
                    },
                    {
                        "username": "jamespaz311",
                        "content": "Did i miss something? I know that palindromic is when String s==s(reversed) but how it end up \"a\" from \"ac\"?"
                    },
                    {
                        "username": "user2531u",
                        "content": "Has anyone come across this in an actual interview?"
                    },
                    {
                        "username": "supreme_dalek",
                        "content": "If anyone understands \"a\" from \"ac\" to fit the definition of a palindrome, can you please let me know by providing a link or citation to an authoratative source stating as much?\\n\\nThanks,\\nmr.T\\n"
                    },
                    {
                        "username": "gktk",
                        "content": "The link to Manacher\\'s algorithm provided in the Solution section is dead: https://articles.leetcode.com/longest-palindromic-substring-part-ii/\\n\\nI get a database error. Could someone please fix it? Thanks!"
                    },
                    {
                        "username": "RayYang_",
                        "content": "see the picture , what\\'s wrong with this?\\n![image](https://s3-lc-upload.s3.amazonaws.com/users/rayyang_/image_1536665252.png)\\n"
                    },
                    {
                        "username": "rabeeh",
                        "content": "Hi, \\nwhen I submit my codes, judge keep being pending, I wonder if anyone has how to solve it.\\nThanks."
                    },
                    {
                        "username": "aaaaaqi5",
                        "content": "Why input \"abcda\" should return \"a\"? \\nDoesn't make sense at all!\\n\\nCan anyone explain?"
                    },
                    {
                        "username": "Future6",
                        "content": "Should the answer be \"aacakacaa\"?\\n\\nBut it gives \"aca\" as correct answer. Did i miss something here?"
                    },
                    {
                        "username": "AssasianKing",
                        "content": "Can be easily solved using [Manacher\\u2019s Algorithm](httphttps://en.wikipedia.org/wiki/Longest_palindromic_substring#Manacher.27s_algorithm://) .\\n\\nRefer\": https://www.hackerearth.com/practice/algorithms/string-algorithm/manachars-algorithm/tutorial/\\n\\n\\n"
                    }
                ]
            },
            {
                "id": 1570974,
                "content": [
                    {
                        "username": "mp0wr",
                        "content": "The problem statement claims the grader will accept alternate correct answers.\\n> Note: \"aba\" is also a valid answer.\\n\\nMy code takes \"babad\" as input, and outputs \"aba\".\\n\\n## Using [Run Code]\\nGrader returns:\\n> Expected \"bab\"\\n\\nThere\\'s no way (other than [Submit]) to know that another palindrome of equal length is accepted. \\n"
                    },
                    {
                        "username": "jamespaz311",
                        "content": "Did i miss something? I know that palindromic is when String s==s(reversed) but how it end up \"a\" from \"ac\"?"
                    },
                    {
                        "username": "user2531u",
                        "content": "Has anyone come across this in an actual interview?"
                    },
                    {
                        "username": "supreme_dalek",
                        "content": "If anyone understands \"a\" from \"ac\" to fit the definition of a palindrome, can you please let me know by providing a link or citation to an authoratative source stating as much?\\n\\nThanks,\\nmr.T\\n"
                    },
                    {
                        "username": "gktk",
                        "content": "The link to Manacher\\'s algorithm provided in the Solution section is dead: https://articles.leetcode.com/longest-palindromic-substring-part-ii/\\n\\nI get a database error. Could someone please fix it? Thanks!"
                    },
                    {
                        "username": "RayYang_",
                        "content": "see the picture , what\\'s wrong with this?\\n![image](https://s3-lc-upload.s3.amazonaws.com/users/rayyang_/image_1536665252.png)\\n"
                    },
                    {
                        "username": "rabeeh",
                        "content": "Hi, \\nwhen I submit my codes, judge keep being pending, I wonder if anyone has how to solve it.\\nThanks."
                    },
                    {
                        "username": "aaaaaqi5",
                        "content": "Why input \"abcda\" should return \"a\"? \\nDoesn't make sense at all!\\n\\nCan anyone explain?"
                    },
                    {
                        "username": "Future6",
                        "content": "Should the answer be \"aacakacaa\"?\\n\\nBut it gives \"aca\" as correct answer. Did i miss something here?"
                    },
                    {
                        "username": "AssasianKing",
                        "content": "Can be easily solved using [Manacher\\u2019s Algorithm](httphttps://en.wikipedia.org/wiki/Longest_palindromic_substring#Manacher.27s_algorithm://) .\\n\\nRefer\": https://www.hackerearth.com/practice/algorithms/string-algorithm/manachars-algorithm/tutorial/\\n\\n\\n"
                    }
                ]
            },
            {
                "id": 1570973,
                "content": [
                    {
                        "username": "mp0wr",
                        "content": "The problem statement claims the grader will accept alternate correct answers.\\n> Note: \"aba\" is also a valid answer.\\n\\nMy code takes \"babad\" as input, and outputs \"aba\".\\n\\n## Using [Run Code]\\nGrader returns:\\n> Expected \"bab\"\\n\\nThere\\'s no way (other than [Submit]) to know that another palindrome of equal length is accepted. \\n"
                    },
                    {
                        "username": "jamespaz311",
                        "content": "Did i miss something? I know that palindromic is when String s==s(reversed) but how it end up \"a\" from \"ac\"?"
                    },
                    {
                        "username": "user2531u",
                        "content": "Has anyone come across this in an actual interview?"
                    },
                    {
                        "username": "supreme_dalek",
                        "content": "If anyone understands \"a\" from \"ac\" to fit the definition of a palindrome, can you please let me know by providing a link or citation to an authoratative source stating as much?\\n\\nThanks,\\nmr.T\\n"
                    },
                    {
                        "username": "gktk",
                        "content": "The link to Manacher\\'s algorithm provided in the Solution section is dead: https://articles.leetcode.com/longest-palindromic-substring-part-ii/\\n\\nI get a database error. Could someone please fix it? Thanks!"
                    },
                    {
                        "username": "RayYang_",
                        "content": "see the picture , what\\'s wrong with this?\\n![image](https://s3-lc-upload.s3.amazonaws.com/users/rayyang_/image_1536665252.png)\\n"
                    },
                    {
                        "username": "rabeeh",
                        "content": "Hi, \\nwhen I submit my codes, judge keep being pending, I wonder if anyone has how to solve it.\\nThanks."
                    },
                    {
                        "username": "aaaaaqi5",
                        "content": "Why input \"abcda\" should return \"a\"? \\nDoesn't make sense at all!\\n\\nCan anyone explain?"
                    },
                    {
                        "username": "Future6",
                        "content": "Should the answer be \"aacakacaa\"?\\n\\nBut it gives \"aca\" as correct answer. Did i miss something here?"
                    },
                    {
                        "username": "AssasianKing",
                        "content": "Can be easily solved using [Manacher\\u2019s Algorithm](httphttps://en.wikipedia.org/wiki/Longest_palindromic_substring#Manacher.27s_algorithm://) .\\n\\nRefer\": https://www.hackerearth.com/practice/algorithms/string-algorithm/manachars-algorithm/tutorial/\\n\\n\\n"
                    }
                ]
            },
            {
                "id": 1570209,
                "content": [
                    {
                        "username": "mp0wr",
                        "content": "The problem statement claims the grader will accept alternate correct answers.\\n> Note: \"aba\" is also a valid answer.\\n\\nMy code takes \"babad\" as input, and outputs \"aba\".\\n\\n## Using [Run Code]\\nGrader returns:\\n> Expected \"bab\"\\n\\nThere\\'s no way (other than [Submit]) to know that another palindrome of equal length is accepted. \\n"
                    },
                    {
                        "username": "jamespaz311",
                        "content": "Did i miss something? I know that palindromic is when String s==s(reversed) but how it end up \"a\" from \"ac\"?"
                    },
                    {
                        "username": "user2531u",
                        "content": "Has anyone come across this in an actual interview?"
                    },
                    {
                        "username": "supreme_dalek",
                        "content": "If anyone understands \"a\" from \"ac\" to fit the definition of a palindrome, can you please let me know by providing a link or citation to an authoratative source stating as much?\\n\\nThanks,\\nmr.T\\n"
                    },
                    {
                        "username": "gktk",
                        "content": "The link to Manacher\\'s algorithm provided in the Solution section is dead: https://articles.leetcode.com/longest-palindromic-substring-part-ii/\\n\\nI get a database error. Could someone please fix it? Thanks!"
                    },
                    {
                        "username": "RayYang_",
                        "content": "see the picture , what\\'s wrong with this?\\n![image](https://s3-lc-upload.s3.amazonaws.com/users/rayyang_/image_1536665252.png)\\n"
                    },
                    {
                        "username": "rabeeh",
                        "content": "Hi, \\nwhen I submit my codes, judge keep being pending, I wonder if anyone has how to solve it.\\nThanks."
                    },
                    {
                        "username": "aaaaaqi5",
                        "content": "Why input \"abcda\" should return \"a\"? \\nDoesn't make sense at all!\\n\\nCan anyone explain?"
                    },
                    {
                        "username": "Future6",
                        "content": "Should the answer be \"aacakacaa\"?\\n\\nBut it gives \"aca\" as correct answer. Did i miss something here?"
                    },
                    {
                        "username": "AssasianKing",
                        "content": "Can be easily solved using [Manacher\\u2019s Algorithm](httphttps://en.wikipedia.org/wiki/Longest_palindromic_substring#Manacher.27s_algorithm://) .\\n\\nRefer\": https://www.hackerearth.com/practice/algorithms/string-algorithm/manachars-algorithm/tutorial/\\n\\n\\n"
                    }
                ]
            },
            {
                "id": 1576453,
                "content": [
                    {
                        "username": "mp0wr",
                        "content": "The problem statement claims the grader will accept alternate correct answers.\\n> Note: \"aba\" is also a valid answer.\\n\\nMy code takes \"babad\" as input, and outputs \"aba\".\\n\\n## Using [Run Code]\\nGrader returns:\\n> Expected \"bab\"\\n\\nThere\\'s no way (other than [Submit]) to know that another palindrome of equal length is accepted. \\n"
                    },
                    {
                        "username": "jamespaz311",
                        "content": "Did i miss something? I know that palindromic is when String s==s(reversed) but how it end up \"a\" from \"ac\"?"
                    },
                    {
                        "username": "user2531u",
                        "content": "Has anyone come across this in an actual interview?"
                    },
                    {
                        "username": "supreme_dalek",
                        "content": "If anyone understands \"a\" from \"ac\" to fit the definition of a palindrome, can you please let me know by providing a link or citation to an authoratative source stating as much?\\n\\nThanks,\\nmr.T\\n"
                    },
                    {
                        "username": "gktk",
                        "content": "The link to Manacher\\'s algorithm provided in the Solution section is dead: https://articles.leetcode.com/longest-palindromic-substring-part-ii/\\n\\nI get a database error. Could someone please fix it? Thanks!"
                    },
                    {
                        "username": "RayYang_",
                        "content": "see the picture , what\\'s wrong with this?\\n![image](https://s3-lc-upload.s3.amazonaws.com/users/rayyang_/image_1536665252.png)\\n"
                    },
                    {
                        "username": "rabeeh",
                        "content": "Hi, \\nwhen I submit my codes, judge keep being pending, I wonder if anyone has how to solve it.\\nThanks."
                    },
                    {
                        "username": "aaaaaqi5",
                        "content": "Why input \"abcda\" should return \"a\"? \\nDoesn't make sense at all!\\n\\nCan anyone explain?"
                    },
                    {
                        "username": "Future6",
                        "content": "Should the answer be \"aacakacaa\"?\\n\\nBut it gives \"aca\" as correct answer. Did i miss something here?"
                    },
                    {
                        "username": "AssasianKing",
                        "content": "Can be easily solved using [Manacher\\u2019s Algorithm](httphttps://en.wikipedia.org/wiki/Longest_palindromic_substring#Manacher.27s_algorithm://) .\\n\\nRefer\": https://www.hackerearth.com/practice/algorithms/string-algorithm/manachars-algorithm/tutorial/\\n\\n\\n"
                    }
                ]
            },
            {
                "id": 1575285,
                "content": [
                    {
                        "username": "dhavalkolapkar",
                        "content": "Variable Sliding window is used when we have to find a subarry or substring with a condition. Find max subarray with distinct chars.\\nNow why is this a DP and not sliding window as we have to find a min substring with palindrome."
                    },
                    {
                        "username": "msn_user",
                        "content": "Refer below for non-DP solution and well-commented code in C++, Java and Python:\\nhttps://www.techiedelight.com/longest-palindromic-substring-non-dp-space-optimized-solution/"
                    },
                    {
                        "username": "JasonDada",
                        "content": "Using dynamic programming algorithm, the memorization table dp[i,j] shows the maximum palindromic substring lengith is 3.  Then the answer is \"aba\". However, leetcode rejects the this answer.  Please help me understand why the accepted answer is \"a\" instead of \"aba\". \\n"
                    },
                    {
                        "username": "hanayashiki",
                        "content": "Input:\\n\"abcdasdfghjkldcba\"\\nOutput:\\n\"abcd\"\\nExpected:\\n\"a\"\\n\\nobviously s[0:4] = \\'abcd\\' while s[-5:-1]=\\'dcba\\' so the answer should be \\'abcd\\'"
                    },
                    {
                        "username": "jt88",
                        "content": "the problem is, you don\\'t know what a palindrome is...\"abcd\" != \"dcba\", if that were the case you would return the whole string and then there would be no point to the exercise"
                    },
                    {
                        "username": "mailo14",
                        "content": "I got Wrong Answer on test:\\nInput:\"abcda\"\\nOutput:\"\"\\nExpected:\"a\"\\nIs \"a\" a palindrom?"
                    },
                    {
                        "username": "Aman__Bhardwaj",
                        "content": "Are you for real dude? O(n^3) accepted but O(n^2) giving TLE!\\n\\n1. O(n^3) -> Accepted \\n ```\\nclass Solution {\\n    private static boolean isPalindrome(String s, int start, int end){\\n        while(start<end){\\n            if(s.charAt(start)!=s.charAt(end)) return false;\\n            start++;\\n            end--;\\n        }\\n        return true;\\n    }\\n\\n    public String longestPalindrome(String s) {\\n        int len = s.length();\\n        String ans = \"\";\\n        for(int start=0;start<len;start++){\\n            for(int end=start;end<len;end++){\\n                if(isPalindrome(s,start,end) && ans.length()<end-start+1) ans = s.substring(start,end+1);\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n\\n// BruteForce Code \\n// Time Complexity : O(len^3)\\n// Space Complexity : O(len)\\n```\\n\\n2. O(n^2) -> TLE\\n```\\nclass Solution {\\n    public String longestPalindrome(String s) {\\n        int len = s.length();\\n        String ans = \"\";\\n        for(int start=0;start<len;start++){\\n            String temp = \"\", temp_ = \"\";\\n            for(int end=start;end<len;end++){\\n                temp_ = temp_ + s.charAt(end);\\n                temp = s.charAt(end) + temp;\\n                if(temp.equals(temp_) && ans.length()<temp.length()) ans = temp;\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n\\n// Optimal Code \\n// Time Complexity : O(len^2)\\n// Space Complexity : O(len*2)\\n```"
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "stop posting solutions"
                    },
                    {
                        "username": "layyy",
                        "content": "A substring from index i to j can be palindrome only if the substring from index i+1 to j-1 is palindrome and characters at index i and j are equal \\ndp[i][j]=1 only if dp[i+1][j-1]==1 and s[i]==s[j]"
                    },
                    {
                        "username": "Vaibhav247",
                        "content": "class Solution {\\npublic:\\n    string longestPalindrome(string s) {\\n        int n = s.size();\\n        int num=0;\\n        if(s.size()==1) {\\n            return s;\\n        }\\n        int min_ind , max_ind;\\n        for(int i=0; i<n; i++ ) {\\n            int x=i;\\n            int y=i;\\n            int count=1;\\n            if(count>num) {\\n                num=count;\\n                min_ind=x;\\n                max_ind=y;\\n            }\\n            x--;\\n            y++;\\n            while(x>=0 && y<n) {\\n                if(s[x]==s[y]) {\\n                    count=count+2;\\n                    x--;\\n                    y++;\\n                    if(count>num) {\\n                        num=count;\\n                        min_ind=x+1;\\n                        max_ind=y-1;\\n                    }\\n                }\\n                else {\\n                    break;\\n                }\\n            }\\n        }\\n        for(int i=0; i<n-1; i++ ) {\\n            int x=i;\\n            int y=i+1;\\n            int count=0;\\n            while(x>=0 && y<n) {\\n                if(s[x]==s[y]) {\\n                    count=count+2;\\n                    x--;\\n                    y++;\\n                    if(count>num) {\\n                        num=count;\\n                        min_ind=x+1;\\n                        max_ind=y-1;\\n                    }\\n                }\\n                else {\\n                    break;\\n                }\\n            }\\n        }\\n        string ans=\"\";\\n        for(int i=min_ind; i<=max_ind; i++) {\\n            ans.push_back(s[i]);\\n        }\\n        return ans;\\n    }\\n};\\n"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "devrathod_212",
                        "content": "s =\\n\"aacabdkacaa\"\\n\\nin this testcase expected output is wrong\\nmy code output : aacabacaa\\nexpected: aca.\\n\\nHow?\\ncan anyone solve this ?  "
                    },
                    {
                        "username": "BLANK-Zora",
                        "content": "can someone explain me the case 141 , it just says s = \\nthat\\'s it , its like not even in the constraint , its not even a string , its just ... it"
                    }
                ]
            },
            {
                "id": 1574081,
                "content": [
                    {
                        "username": "dhavalkolapkar",
                        "content": "Variable Sliding window is used when we have to find a subarry or substring with a condition. Find max subarray with distinct chars.\\nNow why is this a DP and not sliding window as we have to find a min substring with palindrome."
                    },
                    {
                        "username": "msn_user",
                        "content": "Refer below for non-DP solution and well-commented code in C++, Java and Python:\\nhttps://www.techiedelight.com/longest-palindromic-substring-non-dp-space-optimized-solution/"
                    },
                    {
                        "username": "JasonDada",
                        "content": "Using dynamic programming algorithm, the memorization table dp[i,j] shows the maximum palindromic substring lengith is 3.  Then the answer is \"aba\". However, leetcode rejects the this answer.  Please help me understand why the accepted answer is \"a\" instead of \"aba\". \\n"
                    },
                    {
                        "username": "hanayashiki",
                        "content": "Input:\\n\"abcdasdfghjkldcba\"\\nOutput:\\n\"abcd\"\\nExpected:\\n\"a\"\\n\\nobviously s[0:4] = \\'abcd\\' while s[-5:-1]=\\'dcba\\' so the answer should be \\'abcd\\'"
                    },
                    {
                        "username": "jt88",
                        "content": "the problem is, you don\\'t know what a palindrome is...\"abcd\" != \"dcba\", if that were the case you would return the whole string and then there would be no point to the exercise"
                    },
                    {
                        "username": "mailo14",
                        "content": "I got Wrong Answer on test:\\nInput:\"abcda\"\\nOutput:\"\"\\nExpected:\"a\"\\nIs \"a\" a palindrom?"
                    },
                    {
                        "username": "Aman__Bhardwaj",
                        "content": "Are you for real dude? O(n^3) accepted but O(n^2) giving TLE!\\n\\n1. O(n^3) -> Accepted \\n ```\\nclass Solution {\\n    private static boolean isPalindrome(String s, int start, int end){\\n        while(start<end){\\n            if(s.charAt(start)!=s.charAt(end)) return false;\\n            start++;\\n            end--;\\n        }\\n        return true;\\n    }\\n\\n    public String longestPalindrome(String s) {\\n        int len = s.length();\\n        String ans = \"\";\\n        for(int start=0;start<len;start++){\\n            for(int end=start;end<len;end++){\\n                if(isPalindrome(s,start,end) && ans.length()<end-start+1) ans = s.substring(start,end+1);\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n\\n// BruteForce Code \\n// Time Complexity : O(len^3)\\n// Space Complexity : O(len)\\n```\\n\\n2. O(n^2) -> TLE\\n```\\nclass Solution {\\n    public String longestPalindrome(String s) {\\n        int len = s.length();\\n        String ans = \"\";\\n        for(int start=0;start<len;start++){\\n            String temp = \"\", temp_ = \"\";\\n            for(int end=start;end<len;end++){\\n                temp_ = temp_ + s.charAt(end);\\n                temp = s.charAt(end) + temp;\\n                if(temp.equals(temp_) && ans.length()<temp.length()) ans = temp;\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n\\n// Optimal Code \\n// Time Complexity : O(len^2)\\n// Space Complexity : O(len*2)\\n```"
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "stop posting solutions"
                    },
                    {
                        "username": "layyy",
                        "content": "A substring from index i to j can be palindrome only if the substring from index i+1 to j-1 is palindrome and characters at index i and j are equal \\ndp[i][j]=1 only if dp[i+1][j-1]==1 and s[i]==s[j]"
                    },
                    {
                        "username": "Vaibhav247",
                        "content": "class Solution {\\npublic:\\n    string longestPalindrome(string s) {\\n        int n = s.size();\\n        int num=0;\\n        if(s.size()==1) {\\n            return s;\\n        }\\n        int min_ind , max_ind;\\n        for(int i=0; i<n; i++ ) {\\n            int x=i;\\n            int y=i;\\n            int count=1;\\n            if(count>num) {\\n                num=count;\\n                min_ind=x;\\n                max_ind=y;\\n            }\\n            x--;\\n            y++;\\n            while(x>=0 && y<n) {\\n                if(s[x]==s[y]) {\\n                    count=count+2;\\n                    x--;\\n                    y++;\\n                    if(count>num) {\\n                        num=count;\\n                        min_ind=x+1;\\n                        max_ind=y-1;\\n                    }\\n                }\\n                else {\\n                    break;\\n                }\\n            }\\n        }\\n        for(int i=0; i<n-1; i++ ) {\\n            int x=i;\\n            int y=i+1;\\n            int count=0;\\n            while(x>=0 && y<n) {\\n                if(s[x]==s[y]) {\\n                    count=count+2;\\n                    x--;\\n                    y++;\\n                    if(count>num) {\\n                        num=count;\\n                        min_ind=x+1;\\n                        max_ind=y-1;\\n                    }\\n                }\\n                else {\\n                    break;\\n                }\\n            }\\n        }\\n        string ans=\"\";\\n        for(int i=min_ind; i<=max_ind; i++) {\\n            ans.push_back(s[i]);\\n        }\\n        return ans;\\n    }\\n};\\n"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "devrathod_212",
                        "content": "s =\\n\"aacabdkacaa\"\\n\\nin this testcase expected output is wrong\\nmy code output : aacabacaa\\nexpected: aca.\\n\\nHow?\\ncan anyone solve this ?  "
                    },
                    {
                        "username": "BLANK-Zora",
                        "content": "can someone explain me the case 141 , it just says s = \\nthat\\'s it , its like not even in the constraint , its not even a string , its just ... it"
                    }
                ]
            },
            {
                "id": 1571894,
                "content": [
                    {
                        "username": "dhavalkolapkar",
                        "content": "Variable Sliding window is used when we have to find a subarry or substring with a condition. Find max subarray with distinct chars.\\nNow why is this a DP and not sliding window as we have to find a min substring with palindrome."
                    },
                    {
                        "username": "msn_user",
                        "content": "Refer below for non-DP solution and well-commented code in C++, Java and Python:\\nhttps://www.techiedelight.com/longest-palindromic-substring-non-dp-space-optimized-solution/"
                    },
                    {
                        "username": "JasonDada",
                        "content": "Using dynamic programming algorithm, the memorization table dp[i,j] shows the maximum palindromic substring lengith is 3.  Then the answer is \"aba\". However, leetcode rejects the this answer.  Please help me understand why the accepted answer is \"a\" instead of \"aba\". \\n"
                    },
                    {
                        "username": "hanayashiki",
                        "content": "Input:\\n\"abcdasdfghjkldcba\"\\nOutput:\\n\"abcd\"\\nExpected:\\n\"a\"\\n\\nobviously s[0:4] = \\'abcd\\' while s[-5:-1]=\\'dcba\\' so the answer should be \\'abcd\\'"
                    },
                    {
                        "username": "jt88",
                        "content": "the problem is, you don\\'t know what a palindrome is...\"abcd\" != \"dcba\", if that were the case you would return the whole string and then there would be no point to the exercise"
                    },
                    {
                        "username": "mailo14",
                        "content": "I got Wrong Answer on test:\\nInput:\"abcda\"\\nOutput:\"\"\\nExpected:\"a\"\\nIs \"a\" a palindrom?"
                    },
                    {
                        "username": "Aman__Bhardwaj",
                        "content": "Are you for real dude? O(n^3) accepted but O(n^2) giving TLE!\\n\\n1. O(n^3) -> Accepted \\n ```\\nclass Solution {\\n    private static boolean isPalindrome(String s, int start, int end){\\n        while(start<end){\\n            if(s.charAt(start)!=s.charAt(end)) return false;\\n            start++;\\n            end--;\\n        }\\n        return true;\\n    }\\n\\n    public String longestPalindrome(String s) {\\n        int len = s.length();\\n        String ans = \"\";\\n        for(int start=0;start<len;start++){\\n            for(int end=start;end<len;end++){\\n                if(isPalindrome(s,start,end) && ans.length()<end-start+1) ans = s.substring(start,end+1);\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n\\n// BruteForce Code \\n// Time Complexity : O(len^3)\\n// Space Complexity : O(len)\\n```\\n\\n2. O(n^2) -> TLE\\n```\\nclass Solution {\\n    public String longestPalindrome(String s) {\\n        int len = s.length();\\n        String ans = \"\";\\n        for(int start=0;start<len;start++){\\n            String temp = \"\", temp_ = \"\";\\n            for(int end=start;end<len;end++){\\n                temp_ = temp_ + s.charAt(end);\\n                temp = s.charAt(end) + temp;\\n                if(temp.equals(temp_) && ans.length()<temp.length()) ans = temp;\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n\\n// Optimal Code \\n// Time Complexity : O(len^2)\\n// Space Complexity : O(len*2)\\n```"
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "stop posting solutions"
                    },
                    {
                        "username": "layyy",
                        "content": "A substring from index i to j can be palindrome only if the substring from index i+1 to j-1 is palindrome and characters at index i and j are equal \\ndp[i][j]=1 only if dp[i+1][j-1]==1 and s[i]==s[j]"
                    },
                    {
                        "username": "Vaibhav247",
                        "content": "class Solution {\\npublic:\\n    string longestPalindrome(string s) {\\n        int n = s.size();\\n        int num=0;\\n        if(s.size()==1) {\\n            return s;\\n        }\\n        int min_ind , max_ind;\\n        for(int i=0; i<n; i++ ) {\\n            int x=i;\\n            int y=i;\\n            int count=1;\\n            if(count>num) {\\n                num=count;\\n                min_ind=x;\\n                max_ind=y;\\n            }\\n            x--;\\n            y++;\\n            while(x>=0 && y<n) {\\n                if(s[x]==s[y]) {\\n                    count=count+2;\\n                    x--;\\n                    y++;\\n                    if(count>num) {\\n                        num=count;\\n                        min_ind=x+1;\\n                        max_ind=y-1;\\n                    }\\n                }\\n                else {\\n                    break;\\n                }\\n            }\\n        }\\n        for(int i=0; i<n-1; i++ ) {\\n            int x=i;\\n            int y=i+1;\\n            int count=0;\\n            while(x>=0 && y<n) {\\n                if(s[x]==s[y]) {\\n                    count=count+2;\\n                    x--;\\n                    y++;\\n                    if(count>num) {\\n                        num=count;\\n                        min_ind=x+1;\\n                        max_ind=y-1;\\n                    }\\n                }\\n                else {\\n                    break;\\n                }\\n            }\\n        }\\n        string ans=\"\";\\n        for(int i=min_ind; i<=max_ind; i++) {\\n            ans.push_back(s[i]);\\n        }\\n        return ans;\\n    }\\n};\\n"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "devrathod_212",
                        "content": "s =\\n\"aacabdkacaa\"\\n\\nin this testcase expected output is wrong\\nmy code output : aacabacaa\\nexpected: aca.\\n\\nHow?\\ncan anyone solve this ?  "
                    },
                    {
                        "username": "BLANK-Zora",
                        "content": "can someone explain me the case 141 , it just says s = \\nthat\\'s it , its like not even in the constraint , its not even a string , its just ... it"
                    }
                ]
            },
            {
                "id": 1571892,
                "content": [
                    {
                        "username": "dhavalkolapkar",
                        "content": "Variable Sliding window is used when we have to find a subarry or substring with a condition. Find max subarray with distinct chars.\\nNow why is this a DP and not sliding window as we have to find a min substring with palindrome."
                    },
                    {
                        "username": "msn_user",
                        "content": "Refer below for non-DP solution and well-commented code in C++, Java and Python:\\nhttps://www.techiedelight.com/longest-palindromic-substring-non-dp-space-optimized-solution/"
                    },
                    {
                        "username": "JasonDada",
                        "content": "Using dynamic programming algorithm, the memorization table dp[i,j] shows the maximum palindromic substring lengith is 3.  Then the answer is \"aba\". However, leetcode rejects the this answer.  Please help me understand why the accepted answer is \"a\" instead of \"aba\". \\n"
                    },
                    {
                        "username": "hanayashiki",
                        "content": "Input:\\n\"abcdasdfghjkldcba\"\\nOutput:\\n\"abcd\"\\nExpected:\\n\"a\"\\n\\nobviously s[0:4] = \\'abcd\\' while s[-5:-1]=\\'dcba\\' so the answer should be \\'abcd\\'"
                    },
                    {
                        "username": "jt88",
                        "content": "the problem is, you don\\'t know what a palindrome is...\"abcd\" != \"dcba\", if that were the case you would return the whole string and then there would be no point to the exercise"
                    },
                    {
                        "username": "mailo14",
                        "content": "I got Wrong Answer on test:\\nInput:\"abcda\"\\nOutput:\"\"\\nExpected:\"a\"\\nIs \"a\" a palindrom?"
                    },
                    {
                        "username": "Aman__Bhardwaj",
                        "content": "Are you for real dude? O(n^3) accepted but O(n^2) giving TLE!\\n\\n1. O(n^3) -> Accepted \\n ```\\nclass Solution {\\n    private static boolean isPalindrome(String s, int start, int end){\\n        while(start<end){\\n            if(s.charAt(start)!=s.charAt(end)) return false;\\n            start++;\\n            end--;\\n        }\\n        return true;\\n    }\\n\\n    public String longestPalindrome(String s) {\\n        int len = s.length();\\n        String ans = \"\";\\n        for(int start=0;start<len;start++){\\n            for(int end=start;end<len;end++){\\n                if(isPalindrome(s,start,end) && ans.length()<end-start+1) ans = s.substring(start,end+1);\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n\\n// BruteForce Code \\n// Time Complexity : O(len^3)\\n// Space Complexity : O(len)\\n```\\n\\n2. O(n^2) -> TLE\\n```\\nclass Solution {\\n    public String longestPalindrome(String s) {\\n        int len = s.length();\\n        String ans = \"\";\\n        for(int start=0;start<len;start++){\\n            String temp = \"\", temp_ = \"\";\\n            for(int end=start;end<len;end++){\\n                temp_ = temp_ + s.charAt(end);\\n                temp = s.charAt(end) + temp;\\n                if(temp.equals(temp_) && ans.length()<temp.length()) ans = temp;\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n\\n// Optimal Code \\n// Time Complexity : O(len^2)\\n// Space Complexity : O(len*2)\\n```"
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "stop posting solutions"
                    },
                    {
                        "username": "layyy",
                        "content": "A substring from index i to j can be palindrome only if the substring from index i+1 to j-1 is palindrome and characters at index i and j are equal \\ndp[i][j]=1 only if dp[i+1][j-1]==1 and s[i]==s[j]"
                    },
                    {
                        "username": "Vaibhav247",
                        "content": "class Solution {\\npublic:\\n    string longestPalindrome(string s) {\\n        int n = s.size();\\n        int num=0;\\n        if(s.size()==1) {\\n            return s;\\n        }\\n        int min_ind , max_ind;\\n        for(int i=0; i<n; i++ ) {\\n            int x=i;\\n            int y=i;\\n            int count=1;\\n            if(count>num) {\\n                num=count;\\n                min_ind=x;\\n                max_ind=y;\\n            }\\n            x--;\\n            y++;\\n            while(x>=0 && y<n) {\\n                if(s[x]==s[y]) {\\n                    count=count+2;\\n                    x--;\\n                    y++;\\n                    if(count>num) {\\n                        num=count;\\n                        min_ind=x+1;\\n                        max_ind=y-1;\\n                    }\\n                }\\n                else {\\n                    break;\\n                }\\n            }\\n        }\\n        for(int i=0; i<n-1; i++ ) {\\n            int x=i;\\n            int y=i+1;\\n            int count=0;\\n            while(x>=0 && y<n) {\\n                if(s[x]==s[y]) {\\n                    count=count+2;\\n                    x--;\\n                    y++;\\n                    if(count>num) {\\n                        num=count;\\n                        min_ind=x+1;\\n                        max_ind=y-1;\\n                    }\\n                }\\n                else {\\n                    break;\\n                }\\n            }\\n        }\\n        string ans=\"\";\\n        for(int i=min_ind; i<=max_ind; i++) {\\n            ans.push_back(s[i]);\\n        }\\n        return ans;\\n    }\\n};\\n"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "devrathod_212",
                        "content": "s =\\n\"aacabdkacaa\"\\n\\nin this testcase expected output is wrong\\nmy code output : aacabacaa\\nexpected: aca.\\n\\nHow?\\ncan anyone solve this ?  "
                    },
                    {
                        "username": "BLANK-Zora",
                        "content": "can someone explain me the case 141 , it just says s = \\nthat\\'s it , its like not even in the constraint , its not even a string , its just ... it"
                    }
                ]
            },
            {
                "id": 1570972,
                "content": [
                    {
                        "username": "dhavalkolapkar",
                        "content": "Variable Sliding window is used when we have to find a subarry or substring with a condition. Find max subarray with distinct chars.\\nNow why is this a DP and not sliding window as we have to find a min substring with palindrome."
                    },
                    {
                        "username": "msn_user",
                        "content": "Refer below for non-DP solution and well-commented code in C++, Java and Python:\\nhttps://www.techiedelight.com/longest-palindromic-substring-non-dp-space-optimized-solution/"
                    },
                    {
                        "username": "JasonDada",
                        "content": "Using dynamic programming algorithm, the memorization table dp[i,j] shows the maximum palindromic substring lengith is 3.  Then the answer is \"aba\". However, leetcode rejects the this answer.  Please help me understand why the accepted answer is \"a\" instead of \"aba\". \\n"
                    },
                    {
                        "username": "hanayashiki",
                        "content": "Input:\\n\"abcdasdfghjkldcba\"\\nOutput:\\n\"abcd\"\\nExpected:\\n\"a\"\\n\\nobviously s[0:4] = \\'abcd\\' while s[-5:-1]=\\'dcba\\' so the answer should be \\'abcd\\'"
                    },
                    {
                        "username": "jt88",
                        "content": "the problem is, you don\\'t know what a palindrome is...\"abcd\" != \"dcba\", if that were the case you would return the whole string and then there would be no point to the exercise"
                    },
                    {
                        "username": "mailo14",
                        "content": "I got Wrong Answer on test:\\nInput:\"abcda\"\\nOutput:\"\"\\nExpected:\"a\"\\nIs \"a\" a palindrom?"
                    },
                    {
                        "username": "Aman__Bhardwaj",
                        "content": "Are you for real dude? O(n^3) accepted but O(n^2) giving TLE!\\n\\n1. O(n^3) -> Accepted \\n ```\\nclass Solution {\\n    private static boolean isPalindrome(String s, int start, int end){\\n        while(start<end){\\n            if(s.charAt(start)!=s.charAt(end)) return false;\\n            start++;\\n            end--;\\n        }\\n        return true;\\n    }\\n\\n    public String longestPalindrome(String s) {\\n        int len = s.length();\\n        String ans = \"\";\\n        for(int start=0;start<len;start++){\\n            for(int end=start;end<len;end++){\\n                if(isPalindrome(s,start,end) && ans.length()<end-start+1) ans = s.substring(start,end+1);\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n\\n// BruteForce Code \\n// Time Complexity : O(len^3)\\n// Space Complexity : O(len)\\n```\\n\\n2. O(n^2) -> TLE\\n```\\nclass Solution {\\n    public String longestPalindrome(String s) {\\n        int len = s.length();\\n        String ans = \"\";\\n        for(int start=0;start<len;start++){\\n            String temp = \"\", temp_ = \"\";\\n            for(int end=start;end<len;end++){\\n                temp_ = temp_ + s.charAt(end);\\n                temp = s.charAt(end) + temp;\\n                if(temp.equals(temp_) && ans.length()<temp.length()) ans = temp;\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n\\n// Optimal Code \\n// Time Complexity : O(len^2)\\n// Space Complexity : O(len*2)\\n```"
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "stop posting solutions"
                    },
                    {
                        "username": "layyy",
                        "content": "A substring from index i to j can be palindrome only if the substring from index i+1 to j-1 is palindrome and characters at index i and j are equal \\ndp[i][j]=1 only if dp[i+1][j-1]==1 and s[i]==s[j]"
                    },
                    {
                        "username": "Vaibhav247",
                        "content": "class Solution {\\npublic:\\n    string longestPalindrome(string s) {\\n        int n = s.size();\\n        int num=0;\\n        if(s.size()==1) {\\n            return s;\\n        }\\n        int min_ind , max_ind;\\n        for(int i=0; i<n; i++ ) {\\n            int x=i;\\n            int y=i;\\n            int count=1;\\n            if(count>num) {\\n                num=count;\\n                min_ind=x;\\n                max_ind=y;\\n            }\\n            x--;\\n            y++;\\n            while(x>=0 && y<n) {\\n                if(s[x]==s[y]) {\\n                    count=count+2;\\n                    x--;\\n                    y++;\\n                    if(count>num) {\\n                        num=count;\\n                        min_ind=x+1;\\n                        max_ind=y-1;\\n                    }\\n                }\\n                else {\\n                    break;\\n                }\\n            }\\n        }\\n        for(int i=0; i<n-1; i++ ) {\\n            int x=i;\\n            int y=i+1;\\n            int count=0;\\n            while(x>=0 && y<n) {\\n                if(s[x]==s[y]) {\\n                    count=count+2;\\n                    x--;\\n                    y++;\\n                    if(count>num) {\\n                        num=count;\\n                        min_ind=x+1;\\n                        max_ind=y-1;\\n                    }\\n                }\\n                else {\\n                    break;\\n                }\\n            }\\n        }\\n        string ans=\"\";\\n        for(int i=min_ind; i<=max_ind; i++) {\\n            ans.push_back(s[i]);\\n        }\\n        return ans;\\n    }\\n};\\n"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "devrathod_212",
                        "content": "s =\\n\"aacabdkacaa\"\\n\\nin this testcase expected output is wrong\\nmy code output : aacabacaa\\nexpected: aca.\\n\\nHow?\\ncan anyone solve this ?  "
                    },
                    {
                        "username": "BLANK-Zora",
                        "content": "can someone explain me the case 141 , it just says s = \\nthat\\'s it , its like not even in the constraint , its not even a string , its just ... it"
                    }
                ]
            },
            {
                "id": 2058336,
                "content": [
                    {
                        "username": "dhavalkolapkar",
                        "content": "Variable Sliding window is used when we have to find a subarry or substring with a condition. Find max subarray with distinct chars.\\nNow why is this a DP and not sliding window as we have to find a min substring with palindrome."
                    },
                    {
                        "username": "msn_user",
                        "content": "Refer below for non-DP solution and well-commented code in C++, Java and Python:\\nhttps://www.techiedelight.com/longest-palindromic-substring-non-dp-space-optimized-solution/"
                    },
                    {
                        "username": "JasonDada",
                        "content": "Using dynamic programming algorithm, the memorization table dp[i,j] shows the maximum palindromic substring lengith is 3.  Then the answer is \"aba\". However, leetcode rejects the this answer.  Please help me understand why the accepted answer is \"a\" instead of \"aba\". \\n"
                    },
                    {
                        "username": "hanayashiki",
                        "content": "Input:\\n\"abcdasdfghjkldcba\"\\nOutput:\\n\"abcd\"\\nExpected:\\n\"a\"\\n\\nobviously s[0:4] = \\'abcd\\' while s[-5:-1]=\\'dcba\\' so the answer should be \\'abcd\\'"
                    },
                    {
                        "username": "jt88",
                        "content": "the problem is, you don\\'t know what a palindrome is...\"abcd\" != \"dcba\", if that were the case you would return the whole string and then there would be no point to the exercise"
                    },
                    {
                        "username": "mailo14",
                        "content": "I got Wrong Answer on test:\\nInput:\"abcda\"\\nOutput:\"\"\\nExpected:\"a\"\\nIs \"a\" a palindrom?"
                    },
                    {
                        "username": "Aman__Bhardwaj",
                        "content": "Are you for real dude? O(n^3) accepted but O(n^2) giving TLE!\\n\\n1. O(n^3) -> Accepted \\n ```\\nclass Solution {\\n    private static boolean isPalindrome(String s, int start, int end){\\n        while(start<end){\\n            if(s.charAt(start)!=s.charAt(end)) return false;\\n            start++;\\n            end--;\\n        }\\n        return true;\\n    }\\n\\n    public String longestPalindrome(String s) {\\n        int len = s.length();\\n        String ans = \"\";\\n        for(int start=0;start<len;start++){\\n            for(int end=start;end<len;end++){\\n                if(isPalindrome(s,start,end) && ans.length()<end-start+1) ans = s.substring(start,end+1);\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n\\n// BruteForce Code \\n// Time Complexity : O(len^3)\\n// Space Complexity : O(len)\\n```\\n\\n2. O(n^2) -> TLE\\n```\\nclass Solution {\\n    public String longestPalindrome(String s) {\\n        int len = s.length();\\n        String ans = \"\";\\n        for(int start=0;start<len;start++){\\n            String temp = \"\", temp_ = \"\";\\n            for(int end=start;end<len;end++){\\n                temp_ = temp_ + s.charAt(end);\\n                temp = s.charAt(end) + temp;\\n                if(temp.equals(temp_) && ans.length()<temp.length()) ans = temp;\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n\\n// Optimal Code \\n// Time Complexity : O(len^2)\\n// Space Complexity : O(len*2)\\n```"
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "stop posting solutions"
                    },
                    {
                        "username": "layyy",
                        "content": "A substring from index i to j can be palindrome only if the substring from index i+1 to j-1 is palindrome and characters at index i and j are equal \\ndp[i][j]=1 only if dp[i+1][j-1]==1 and s[i]==s[j]"
                    },
                    {
                        "username": "Vaibhav247",
                        "content": "class Solution {\\npublic:\\n    string longestPalindrome(string s) {\\n        int n = s.size();\\n        int num=0;\\n        if(s.size()==1) {\\n            return s;\\n        }\\n        int min_ind , max_ind;\\n        for(int i=0; i<n; i++ ) {\\n            int x=i;\\n            int y=i;\\n            int count=1;\\n            if(count>num) {\\n                num=count;\\n                min_ind=x;\\n                max_ind=y;\\n            }\\n            x--;\\n            y++;\\n            while(x>=0 && y<n) {\\n                if(s[x]==s[y]) {\\n                    count=count+2;\\n                    x--;\\n                    y++;\\n                    if(count>num) {\\n                        num=count;\\n                        min_ind=x+1;\\n                        max_ind=y-1;\\n                    }\\n                }\\n                else {\\n                    break;\\n                }\\n            }\\n        }\\n        for(int i=0; i<n-1; i++ ) {\\n            int x=i;\\n            int y=i+1;\\n            int count=0;\\n            while(x>=0 && y<n) {\\n                if(s[x]==s[y]) {\\n                    count=count+2;\\n                    x--;\\n                    y++;\\n                    if(count>num) {\\n                        num=count;\\n                        min_ind=x+1;\\n                        max_ind=y-1;\\n                    }\\n                }\\n                else {\\n                    break;\\n                }\\n            }\\n        }\\n        string ans=\"\";\\n        for(int i=min_ind; i<=max_ind; i++) {\\n            ans.push_back(s[i]);\\n        }\\n        return ans;\\n    }\\n};\\n"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "devrathod_212",
                        "content": "s =\\n\"aacabdkacaa\"\\n\\nin this testcase expected output is wrong\\nmy code output : aacabacaa\\nexpected: aca.\\n\\nHow?\\ncan anyone solve this ?  "
                    },
                    {
                        "username": "BLANK-Zora",
                        "content": "can someone explain me the case 141 , it just says s = \\nthat\\'s it , its like not even in the constraint , its not even a string , its just ... it"
                    }
                ]
            },
            {
                "id": 2041347,
                "content": [
                    {
                        "username": "dhavalkolapkar",
                        "content": "Variable Sliding window is used when we have to find a subarry or substring with a condition. Find max subarray with distinct chars.\\nNow why is this a DP and not sliding window as we have to find a min substring with palindrome."
                    },
                    {
                        "username": "msn_user",
                        "content": "Refer below for non-DP solution and well-commented code in C++, Java and Python:\\nhttps://www.techiedelight.com/longest-palindromic-substring-non-dp-space-optimized-solution/"
                    },
                    {
                        "username": "JasonDada",
                        "content": "Using dynamic programming algorithm, the memorization table dp[i,j] shows the maximum palindromic substring lengith is 3.  Then the answer is \"aba\". However, leetcode rejects the this answer.  Please help me understand why the accepted answer is \"a\" instead of \"aba\". \\n"
                    },
                    {
                        "username": "hanayashiki",
                        "content": "Input:\\n\"abcdasdfghjkldcba\"\\nOutput:\\n\"abcd\"\\nExpected:\\n\"a\"\\n\\nobviously s[0:4] = \\'abcd\\' while s[-5:-1]=\\'dcba\\' so the answer should be \\'abcd\\'"
                    },
                    {
                        "username": "jt88",
                        "content": "the problem is, you don\\'t know what a palindrome is...\"abcd\" != \"dcba\", if that were the case you would return the whole string and then there would be no point to the exercise"
                    },
                    {
                        "username": "mailo14",
                        "content": "I got Wrong Answer on test:\\nInput:\"abcda\"\\nOutput:\"\"\\nExpected:\"a\"\\nIs \"a\" a palindrom?"
                    },
                    {
                        "username": "Aman__Bhardwaj",
                        "content": "Are you for real dude? O(n^3) accepted but O(n^2) giving TLE!\\n\\n1. O(n^3) -> Accepted \\n ```\\nclass Solution {\\n    private static boolean isPalindrome(String s, int start, int end){\\n        while(start<end){\\n            if(s.charAt(start)!=s.charAt(end)) return false;\\n            start++;\\n            end--;\\n        }\\n        return true;\\n    }\\n\\n    public String longestPalindrome(String s) {\\n        int len = s.length();\\n        String ans = \"\";\\n        for(int start=0;start<len;start++){\\n            for(int end=start;end<len;end++){\\n                if(isPalindrome(s,start,end) && ans.length()<end-start+1) ans = s.substring(start,end+1);\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n\\n// BruteForce Code \\n// Time Complexity : O(len^3)\\n// Space Complexity : O(len)\\n```\\n\\n2. O(n^2) -> TLE\\n```\\nclass Solution {\\n    public String longestPalindrome(String s) {\\n        int len = s.length();\\n        String ans = \"\";\\n        for(int start=0;start<len;start++){\\n            String temp = \"\", temp_ = \"\";\\n            for(int end=start;end<len;end++){\\n                temp_ = temp_ + s.charAt(end);\\n                temp = s.charAt(end) + temp;\\n                if(temp.equals(temp_) && ans.length()<temp.length()) ans = temp;\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n\\n// Optimal Code \\n// Time Complexity : O(len^2)\\n// Space Complexity : O(len*2)\\n```"
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "stop posting solutions"
                    },
                    {
                        "username": "layyy",
                        "content": "A substring from index i to j can be palindrome only if the substring from index i+1 to j-1 is palindrome and characters at index i and j are equal \\ndp[i][j]=1 only if dp[i+1][j-1]==1 and s[i]==s[j]"
                    },
                    {
                        "username": "Vaibhav247",
                        "content": "class Solution {\\npublic:\\n    string longestPalindrome(string s) {\\n        int n = s.size();\\n        int num=0;\\n        if(s.size()==1) {\\n            return s;\\n        }\\n        int min_ind , max_ind;\\n        for(int i=0; i<n; i++ ) {\\n            int x=i;\\n            int y=i;\\n            int count=1;\\n            if(count>num) {\\n                num=count;\\n                min_ind=x;\\n                max_ind=y;\\n            }\\n            x--;\\n            y++;\\n            while(x>=0 && y<n) {\\n                if(s[x]==s[y]) {\\n                    count=count+2;\\n                    x--;\\n                    y++;\\n                    if(count>num) {\\n                        num=count;\\n                        min_ind=x+1;\\n                        max_ind=y-1;\\n                    }\\n                }\\n                else {\\n                    break;\\n                }\\n            }\\n        }\\n        for(int i=0; i<n-1; i++ ) {\\n            int x=i;\\n            int y=i+1;\\n            int count=0;\\n            while(x>=0 && y<n) {\\n                if(s[x]==s[y]) {\\n                    count=count+2;\\n                    x--;\\n                    y++;\\n                    if(count>num) {\\n                        num=count;\\n                        min_ind=x+1;\\n                        max_ind=y-1;\\n                    }\\n                }\\n                else {\\n                    break;\\n                }\\n            }\\n        }\\n        string ans=\"\";\\n        for(int i=min_ind; i<=max_ind; i++) {\\n            ans.push_back(s[i]);\\n        }\\n        return ans;\\n    }\\n};\\n"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "devrathod_212",
                        "content": "s =\\n\"aacabdkacaa\"\\n\\nin this testcase expected output is wrong\\nmy code output : aacabacaa\\nexpected: aca.\\n\\nHow?\\ncan anyone solve this ?  "
                    },
                    {
                        "username": "BLANK-Zora",
                        "content": "can someone explain me the case 141 , it just says s = \\nthat\\'s it , its like not even in the constraint , its not even a string , its just ... it"
                    }
                ]
            },
            {
                "id": 2019252,
                "content": [
                    {
                        "username": "dhavalkolapkar",
                        "content": "Variable Sliding window is used when we have to find a subarry or substring with a condition. Find max subarray with distinct chars.\\nNow why is this a DP and not sliding window as we have to find a min substring with palindrome."
                    },
                    {
                        "username": "msn_user",
                        "content": "Refer below for non-DP solution and well-commented code in C++, Java and Python:\\nhttps://www.techiedelight.com/longest-palindromic-substring-non-dp-space-optimized-solution/"
                    },
                    {
                        "username": "JasonDada",
                        "content": "Using dynamic programming algorithm, the memorization table dp[i,j] shows the maximum palindromic substring lengith is 3.  Then the answer is \"aba\". However, leetcode rejects the this answer.  Please help me understand why the accepted answer is \"a\" instead of \"aba\". \\n"
                    },
                    {
                        "username": "hanayashiki",
                        "content": "Input:\\n\"abcdasdfghjkldcba\"\\nOutput:\\n\"abcd\"\\nExpected:\\n\"a\"\\n\\nobviously s[0:4] = \\'abcd\\' while s[-5:-1]=\\'dcba\\' so the answer should be \\'abcd\\'"
                    },
                    {
                        "username": "jt88",
                        "content": "the problem is, you don\\'t know what a palindrome is...\"abcd\" != \"dcba\", if that were the case you would return the whole string and then there would be no point to the exercise"
                    },
                    {
                        "username": "mailo14",
                        "content": "I got Wrong Answer on test:\\nInput:\"abcda\"\\nOutput:\"\"\\nExpected:\"a\"\\nIs \"a\" a palindrom?"
                    },
                    {
                        "username": "Aman__Bhardwaj",
                        "content": "Are you for real dude? O(n^3) accepted but O(n^2) giving TLE!\\n\\n1. O(n^3) -> Accepted \\n ```\\nclass Solution {\\n    private static boolean isPalindrome(String s, int start, int end){\\n        while(start<end){\\n            if(s.charAt(start)!=s.charAt(end)) return false;\\n            start++;\\n            end--;\\n        }\\n        return true;\\n    }\\n\\n    public String longestPalindrome(String s) {\\n        int len = s.length();\\n        String ans = \"\";\\n        for(int start=0;start<len;start++){\\n            for(int end=start;end<len;end++){\\n                if(isPalindrome(s,start,end) && ans.length()<end-start+1) ans = s.substring(start,end+1);\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n\\n// BruteForce Code \\n// Time Complexity : O(len^3)\\n// Space Complexity : O(len)\\n```\\n\\n2. O(n^2) -> TLE\\n```\\nclass Solution {\\n    public String longestPalindrome(String s) {\\n        int len = s.length();\\n        String ans = \"\";\\n        for(int start=0;start<len;start++){\\n            String temp = \"\", temp_ = \"\";\\n            for(int end=start;end<len;end++){\\n                temp_ = temp_ + s.charAt(end);\\n                temp = s.charAt(end) + temp;\\n                if(temp.equals(temp_) && ans.length()<temp.length()) ans = temp;\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n\\n// Optimal Code \\n// Time Complexity : O(len^2)\\n// Space Complexity : O(len*2)\\n```"
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "stop posting solutions"
                    },
                    {
                        "username": "layyy",
                        "content": "A substring from index i to j can be palindrome only if the substring from index i+1 to j-1 is palindrome and characters at index i and j are equal \\ndp[i][j]=1 only if dp[i+1][j-1]==1 and s[i]==s[j]"
                    },
                    {
                        "username": "Vaibhav247",
                        "content": "class Solution {\\npublic:\\n    string longestPalindrome(string s) {\\n        int n = s.size();\\n        int num=0;\\n        if(s.size()==1) {\\n            return s;\\n        }\\n        int min_ind , max_ind;\\n        for(int i=0; i<n; i++ ) {\\n            int x=i;\\n            int y=i;\\n            int count=1;\\n            if(count>num) {\\n                num=count;\\n                min_ind=x;\\n                max_ind=y;\\n            }\\n            x--;\\n            y++;\\n            while(x>=0 && y<n) {\\n                if(s[x]==s[y]) {\\n                    count=count+2;\\n                    x--;\\n                    y++;\\n                    if(count>num) {\\n                        num=count;\\n                        min_ind=x+1;\\n                        max_ind=y-1;\\n                    }\\n                }\\n                else {\\n                    break;\\n                }\\n            }\\n        }\\n        for(int i=0; i<n-1; i++ ) {\\n            int x=i;\\n            int y=i+1;\\n            int count=0;\\n            while(x>=0 && y<n) {\\n                if(s[x]==s[y]) {\\n                    count=count+2;\\n                    x--;\\n                    y++;\\n                    if(count>num) {\\n                        num=count;\\n                        min_ind=x+1;\\n                        max_ind=y-1;\\n                    }\\n                }\\n                else {\\n                    break;\\n                }\\n            }\\n        }\\n        string ans=\"\";\\n        for(int i=min_ind; i<=max_ind; i++) {\\n            ans.push_back(s[i]);\\n        }\\n        return ans;\\n    }\\n};\\n"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "devrathod_212",
                        "content": "s =\\n\"aacabdkacaa\"\\n\\nin this testcase expected output is wrong\\nmy code output : aacabacaa\\nexpected: aca.\\n\\nHow?\\ncan anyone solve this ?  "
                    },
                    {
                        "username": "BLANK-Zora",
                        "content": "can someone explain me the case 141 , it just says s = \\nthat\\'s it , its like not even in the constraint , its not even a string , its just ... it"
                    }
                ]
            },
            {
                "id": 2016852,
                "content": [
                    {
                        "username": "dhavalkolapkar",
                        "content": "Variable Sliding window is used when we have to find a subarry or substring with a condition. Find max subarray with distinct chars.\\nNow why is this a DP and not sliding window as we have to find a min substring with palindrome."
                    },
                    {
                        "username": "msn_user",
                        "content": "Refer below for non-DP solution and well-commented code in C++, Java and Python:\\nhttps://www.techiedelight.com/longest-palindromic-substring-non-dp-space-optimized-solution/"
                    },
                    {
                        "username": "JasonDada",
                        "content": "Using dynamic programming algorithm, the memorization table dp[i,j] shows the maximum palindromic substring lengith is 3.  Then the answer is \"aba\". However, leetcode rejects the this answer.  Please help me understand why the accepted answer is \"a\" instead of \"aba\". \\n"
                    },
                    {
                        "username": "hanayashiki",
                        "content": "Input:\\n\"abcdasdfghjkldcba\"\\nOutput:\\n\"abcd\"\\nExpected:\\n\"a\"\\n\\nobviously s[0:4] = \\'abcd\\' while s[-5:-1]=\\'dcba\\' so the answer should be \\'abcd\\'"
                    },
                    {
                        "username": "jt88",
                        "content": "the problem is, you don\\'t know what a palindrome is...\"abcd\" != \"dcba\", if that were the case you would return the whole string and then there would be no point to the exercise"
                    },
                    {
                        "username": "mailo14",
                        "content": "I got Wrong Answer on test:\\nInput:\"abcda\"\\nOutput:\"\"\\nExpected:\"a\"\\nIs \"a\" a palindrom?"
                    },
                    {
                        "username": "Aman__Bhardwaj",
                        "content": "Are you for real dude? O(n^3) accepted but O(n^2) giving TLE!\\n\\n1. O(n^3) -> Accepted \\n ```\\nclass Solution {\\n    private static boolean isPalindrome(String s, int start, int end){\\n        while(start<end){\\n            if(s.charAt(start)!=s.charAt(end)) return false;\\n            start++;\\n            end--;\\n        }\\n        return true;\\n    }\\n\\n    public String longestPalindrome(String s) {\\n        int len = s.length();\\n        String ans = \"\";\\n        for(int start=0;start<len;start++){\\n            for(int end=start;end<len;end++){\\n                if(isPalindrome(s,start,end) && ans.length()<end-start+1) ans = s.substring(start,end+1);\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n\\n// BruteForce Code \\n// Time Complexity : O(len^3)\\n// Space Complexity : O(len)\\n```\\n\\n2. O(n^2) -> TLE\\n```\\nclass Solution {\\n    public String longestPalindrome(String s) {\\n        int len = s.length();\\n        String ans = \"\";\\n        for(int start=0;start<len;start++){\\n            String temp = \"\", temp_ = \"\";\\n            for(int end=start;end<len;end++){\\n                temp_ = temp_ + s.charAt(end);\\n                temp = s.charAt(end) + temp;\\n                if(temp.equals(temp_) && ans.length()<temp.length()) ans = temp;\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n\\n// Optimal Code \\n// Time Complexity : O(len^2)\\n// Space Complexity : O(len*2)\\n```"
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "stop posting solutions"
                    },
                    {
                        "username": "layyy",
                        "content": "A substring from index i to j can be palindrome only if the substring from index i+1 to j-1 is palindrome and characters at index i and j are equal \\ndp[i][j]=1 only if dp[i+1][j-1]==1 and s[i]==s[j]"
                    },
                    {
                        "username": "Vaibhav247",
                        "content": "class Solution {\\npublic:\\n    string longestPalindrome(string s) {\\n        int n = s.size();\\n        int num=0;\\n        if(s.size()==1) {\\n            return s;\\n        }\\n        int min_ind , max_ind;\\n        for(int i=0; i<n; i++ ) {\\n            int x=i;\\n            int y=i;\\n            int count=1;\\n            if(count>num) {\\n                num=count;\\n                min_ind=x;\\n                max_ind=y;\\n            }\\n            x--;\\n            y++;\\n            while(x>=0 && y<n) {\\n                if(s[x]==s[y]) {\\n                    count=count+2;\\n                    x--;\\n                    y++;\\n                    if(count>num) {\\n                        num=count;\\n                        min_ind=x+1;\\n                        max_ind=y-1;\\n                    }\\n                }\\n                else {\\n                    break;\\n                }\\n            }\\n        }\\n        for(int i=0; i<n-1; i++ ) {\\n            int x=i;\\n            int y=i+1;\\n            int count=0;\\n            while(x>=0 && y<n) {\\n                if(s[x]==s[y]) {\\n                    count=count+2;\\n                    x--;\\n                    y++;\\n                    if(count>num) {\\n                        num=count;\\n                        min_ind=x+1;\\n                        max_ind=y-1;\\n                    }\\n                }\\n                else {\\n                    break;\\n                }\\n            }\\n        }\\n        string ans=\"\";\\n        for(int i=min_ind; i<=max_ind; i++) {\\n            ans.push_back(s[i]);\\n        }\\n        return ans;\\n    }\\n};\\n"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "devrathod_212",
                        "content": "s =\\n\"aacabdkacaa\"\\n\\nin this testcase expected output is wrong\\nmy code output : aacabacaa\\nexpected: aca.\\n\\nHow?\\ncan anyone solve this ?  "
                    },
                    {
                        "username": "BLANK-Zora",
                        "content": "can someone explain me the case 141 , it just says s = \\nthat\\'s it , its like not even in the constraint , its not even a string , its just ... it"
                    }
                ]
            },
            {
                "id": 2010967,
                "content": [
                    {
                        "username": "dhavalkolapkar",
                        "content": "Variable Sliding window is used when we have to find a subarry or substring with a condition. Find max subarray with distinct chars.\\nNow why is this a DP and not sliding window as we have to find a min substring with palindrome."
                    },
                    {
                        "username": "msn_user",
                        "content": "Refer below for non-DP solution and well-commented code in C++, Java and Python:\\nhttps://www.techiedelight.com/longest-palindromic-substring-non-dp-space-optimized-solution/"
                    },
                    {
                        "username": "JasonDada",
                        "content": "Using dynamic programming algorithm, the memorization table dp[i,j] shows the maximum palindromic substring lengith is 3.  Then the answer is \"aba\". However, leetcode rejects the this answer.  Please help me understand why the accepted answer is \"a\" instead of \"aba\". \\n"
                    },
                    {
                        "username": "hanayashiki",
                        "content": "Input:\\n\"abcdasdfghjkldcba\"\\nOutput:\\n\"abcd\"\\nExpected:\\n\"a\"\\n\\nobviously s[0:4] = \\'abcd\\' while s[-5:-1]=\\'dcba\\' so the answer should be \\'abcd\\'"
                    },
                    {
                        "username": "jt88",
                        "content": "the problem is, you don\\'t know what a palindrome is...\"abcd\" != \"dcba\", if that were the case you would return the whole string and then there would be no point to the exercise"
                    },
                    {
                        "username": "mailo14",
                        "content": "I got Wrong Answer on test:\\nInput:\"abcda\"\\nOutput:\"\"\\nExpected:\"a\"\\nIs \"a\" a palindrom?"
                    },
                    {
                        "username": "Aman__Bhardwaj",
                        "content": "Are you for real dude? O(n^3) accepted but O(n^2) giving TLE!\\n\\n1. O(n^3) -> Accepted \\n ```\\nclass Solution {\\n    private static boolean isPalindrome(String s, int start, int end){\\n        while(start<end){\\n            if(s.charAt(start)!=s.charAt(end)) return false;\\n            start++;\\n            end--;\\n        }\\n        return true;\\n    }\\n\\n    public String longestPalindrome(String s) {\\n        int len = s.length();\\n        String ans = \"\";\\n        for(int start=0;start<len;start++){\\n            for(int end=start;end<len;end++){\\n                if(isPalindrome(s,start,end) && ans.length()<end-start+1) ans = s.substring(start,end+1);\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n\\n// BruteForce Code \\n// Time Complexity : O(len^3)\\n// Space Complexity : O(len)\\n```\\n\\n2. O(n^2) -> TLE\\n```\\nclass Solution {\\n    public String longestPalindrome(String s) {\\n        int len = s.length();\\n        String ans = \"\";\\n        for(int start=0;start<len;start++){\\n            String temp = \"\", temp_ = \"\";\\n            for(int end=start;end<len;end++){\\n                temp_ = temp_ + s.charAt(end);\\n                temp = s.charAt(end) + temp;\\n                if(temp.equals(temp_) && ans.length()<temp.length()) ans = temp;\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n\\n// Optimal Code \\n// Time Complexity : O(len^2)\\n// Space Complexity : O(len*2)\\n```"
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "stop posting solutions"
                    },
                    {
                        "username": "layyy",
                        "content": "A substring from index i to j can be palindrome only if the substring from index i+1 to j-1 is palindrome and characters at index i and j are equal \\ndp[i][j]=1 only if dp[i+1][j-1]==1 and s[i]==s[j]"
                    },
                    {
                        "username": "Vaibhav247",
                        "content": "class Solution {\\npublic:\\n    string longestPalindrome(string s) {\\n        int n = s.size();\\n        int num=0;\\n        if(s.size()==1) {\\n            return s;\\n        }\\n        int min_ind , max_ind;\\n        for(int i=0; i<n; i++ ) {\\n            int x=i;\\n            int y=i;\\n            int count=1;\\n            if(count>num) {\\n                num=count;\\n                min_ind=x;\\n                max_ind=y;\\n            }\\n            x--;\\n            y++;\\n            while(x>=0 && y<n) {\\n                if(s[x]==s[y]) {\\n                    count=count+2;\\n                    x--;\\n                    y++;\\n                    if(count>num) {\\n                        num=count;\\n                        min_ind=x+1;\\n                        max_ind=y-1;\\n                    }\\n                }\\n                else {\\n                    break;\\n                }\\n            }\\n        }\\n        for(int i=0; i<n-1; i++ ) {\\n            int x=i;\\n            int y=i+1;\\n            int count=0;\\n            while(x>=0 && y<n) {\\n                if(s[x]==s[y]) {\\n                    count=count+2;\\n                    x--;\\n                    y++;\\n                    if(count>num) {\\n                        num=count;\\n                        min_ind=x+1;\\n                        max_ind=y-1;\\n                    }\\n                }\\n                else {\\n                    break;\\n                }\\n            }\\n        }\\n        string ans=\"\";\\n        for(int i=min_ind; i<=max_ind; i++) {\\n            ans.push_back(s[i]);\\n        }\\n        return ans;\\n    }\\n};\\n"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "devrathod_212",
                        "content": "s =\\n\"aacabdkacaa\"\\n\\nin this testcase expected output is wrong\\nmy code output : aacabacaa\\nexpected: aca.\\n\\nHow?\\ncan anyone solve this ?  "
                    },
                    {
                        "username": "BLANK-Zora",
                        "content": "can someone explain me the case 141 , it just says s = \\nthat\\'s it , its like not even in the constraint , its not even a string , its just ... it"
                    }
                ]
            },
            {
                "id": 2007280,
                "content": [
                    {
                        "username": "aylahjomri",
                        "content": "why does it say 141/141 testcases passed but says Time Limit Exceeded and the last executed input is empty ?"
                    },
                    {
                        "username": "CvamReborn_C2R",
                        "content": "Wrong Question some test cases are not right"
                    },
                    {
                        "username": "ak_3101",
                        "content": "okay so is it absolutely normal to get an intuition of writing code in tabular form or everybody first write recursion, and then top down/ bottom up"
                    },
                    {
                        "username": "jfonseca32",
                        "content": "There is something wrong with this question. I made and ran the code in Python and for every test case LeetCode says the code failed on, it works when I run it in Python."
                    },
                    {
                        "username": "timewaster69",
                        "content": "I think the test case s= (nothing) should be removed. It only causes errors and the constraints specifically state that there's at least one character to work with, and that there's specifically alphanumericals to deal with."
                    },
                    {
                        "username": "kevinbiju",
                        "content": "how do we learn to optimize brute force approach\\n"
                    },
                    {
                        "username": "espinosarennieljun",
                        "content": "To solve this you only need to mind two things. \none, Palindrome can't have with more than one even number of character duplicate.\ntwo, all single character should be ignore you only need to add one single character if the result total number is odd. example the total none single character of string is 6 and you can place single character on the middle of the string so it become 7."
                    },
                    {
                        "username": "muraripavansai22",
                        "content": "\"aacabdkacaa\"\\n\\nThis is my output : \"aacakacaa\"\\ngiven this should be expected : \"aca\"\\n\\nThere is some error with this test case\\ncorrect me if im wrong."
                    },
                    {
                        "username": "Ab__23",
                        "content": "\"aacakacaa\" is a subsequence of input string not it's substring, as the question is to find substring that's where you are getting wrong.\nFor example : let string = \"abcdef\"\nit's substrings: 'a' 'ab' 'abc' 'cde' 'abcde' ...\nit's subsequences : 'a' 'ab' 'ac' 'acf' 'abe' ..."
                    },
                    {
                        "username": "TheMystery28",
                        "content": "I've tried and failed enough times to allow myself to see the hints and come up with an optimal solution.\n\nHowever, I'd like to understand why my old code gives a \"time exceeded\" error for \"aacabdkacaa\" when I have made sure to skip the calculation that can be skipped to avoid wasting time.\n\nCould someone please enlighten me?\n\n ```\n#include <algorithm>\n#include <iostream>\n#include <string>\n#include <string_view>\n#include <unordered_map>\n#include <set>\n#include <functional>\n#include <list>\n#include <iterator>\n#include <memory>\n\n\nclass Solution {\n\n    private:\n\n        std::unordered_map<char, std::set<int>> vOfList{};\n\n        int numberOfDifferentLetters{0};\n        int numberOfDifferentLettersBeingMoreThanOne{0};\n        std::vector<char> allOfTheDifferentLetters{};\n\n    public:\n        void itLoop2(std::set<int>::iterator& auto_pLeftItPos,\n                     std::set<int>::iterator& auto_pRightItPos,\n                     int pLeft, int pRight,\n                     std::string& palindromic, const std::string_view& s,\n                     bool trueToStopTheSpetialLoopToLoop){\n                        \n                    if (abs(*auto_pLeftItPos-*auto_pRightItPos)+1<=palindromic.length()) return;\n                    if(s[pLeft] == s[pRight]){\n\n                        if (pLeft==pRight||abs(pLeft - pRight)==1){\n                            palindromic=s.substr(*auto_pLeftItPos,abs(*auto_pLeftItPos-*auto_pRightItPos)+1);\n                        }\n                        else{\n\n\n                        itLoop2(auto_pLeftItPos, auto_pRightItPos,\n                                pLeft+1, pRight-1,palindromic, \n                                s,trueToStopTheSpetialLoopToLoop);}\n                    }\n                    else if (trueToStopTheSpetialLoopToLoop==false){\n                        trueToStopTheSpetialLoopToLoop = true;\n                    \n                        int x{std::abs(static_cast<int>(std::distance(auto_pLeftItPos,auto_pRightItPos)))};\n\n\n                        int c{0};\n\n                        for (int n{x};n>0;--n){\n                            //remainder that auto_pLeftItPos/auto_pRightItPos are in reverse for their iterator\n\n                            if (n==x) {++c;continue;} //If not we wouldn't be here in the first place\n\n\n\n                            int z{n};\n\n                            auto auto_pLeftItPosEdit{std::prev(auto_pLeftItPos,c)};\n\n                            itLoop2(auto_pLeftItPosEdit, auto_pRightItPos,\n                                *auto_pLeftItPosEdit, pRight,\n                                palindromic, \n                                s,trueToStopTheSpetialLoopToLoop);\n\n                            auto auto_pRightItPosEdit{auto_pRightItPos};\n\n                            while(auto_pLeftItPosEdit!=auto_pLeftItPos){\n                                \n                                auto_pLeftItPosEdit = std::next(auto_pLeftItPosEdit,1);\n                                auto_pRightItPosEdit = std::next(auto_pRightItPosEdit, 1);\n\n                                if (abs(*auto_pLeftItPos-*auto_pRightItPos)+1<=palindromic.length()) continue;\n\n                                itLoop2(auto_pLeftItPosEdit, auto_pRightItPosEdit,\n                                *auto_pLeftItPosEdit, *auto_pRightItPosEdit,\n                                palindromic, \n                                s,trueToStopTheSpetialLoopToLoop);\n\n                            }\n\n                            ++c;\n                        }\n\n                    }\n                    else return;\n\n        }\n\n        void itLoop(std::unordered_map<char, std::set<int>>::iterator& itBegin,\n                    std::string& palindromic, const std::string_view& s){\n                    \n\n                bool trueToStopTheSpetialLoopToLoop{false};\n\n            \n                auto *ptr {&((itBegin->second))};\n             \n                std::set<int>::iterator setEnd {ptr->begin()};\n\n\n                std::set<int>::iterator setBegin {ptr->end()};\n\n                std::advance(setBegin, -1);\n                //end() give the iterator AFTER the last element of the container\n\n            int pLeft{*setEnd};\n\n            int pRight{*setBegin};\n\n            if (abs(pLeft-pRight)+1<=palindromic.length()) return;\n\n\n            itLoop2(setEnd, setBegin, pLeft, pRight, palindromic, s, trueToStopTheSpetialLoopToLoop);\n\n\n        }\n\n        std::string longestPalindrome(const std::string_view& s) {\n\n            if (s.length()==0){\n                return \"\";\n            }\n            \n            std::vector<bool> everythingUsed (s.length(), false);\n\n            auto finised{[&]() -> bool {return (std::all_of(everythingUsed.begin(), everythingUsed.end(), [&](bool v) { return v; }));}};\n                \n            for (int x{0}; x<s.length()&&!finised();++x){\n\n\n                        if (everythingUsed[x]==false){\n                            everythingUsed[x]=true;\n\n                            ++numberOfDifferentLetters;\n                            allOfTheDifferentLetters.push_back(s[x]);\n\n\n                            for (int y{x+1};y<s.length()&&!finised();++y){\n                                if (everythingUsed[y]==true) continue;\n\n                                else {\n                                    if (s[x]==s[y]){\n                                        everythingUsed[y]=true;\n                                        vOfList[s[x]].insert({x,y});\n                                        ++numberOfDifferentLettersBeingMoreThanOne;\n                                    }\n                                }\n                            }\n                        }\n                        else continue;\n                    }\n\n            if (numberOfDifferentLettersBeingMoreThanOne==0) {\n                std::string str_ch {s[0]};\n                return str_ch;\n            };\n\n            std::unordered_map<char, std::set<int>>::iterator itBegin {vOfList.begin()};\n        \n\n            \n            std::string palindromic{};\n\n            while(itBegin != vOfList.end()){\n            \n                itLoop(itBegin, palindromic, s );\n                ++itBegin;\n            \n                }\n            \n            return palindromic;\n    \n    }\n};\n```\n"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "shri1403",
                        "content": "hi i was trying to solve this using the concepts of longest common substring and longest palindromic substring,\nhowver it doesnt work for the cases like aadabcadaa. this gives adaa as the ans and not ada. please help me with this\nthe following is my code:\n  string lcsub(string s , string s2){\n        int n=s.size();\n        int m=s2.size();\n         \n         vector<vector<int>> dp(n+1,vector<int>(m+1,0));\n         for(int i=0 ; i<=n;i++){\n             dp[i][0]=0;\n         }\n         for(int j=0; j<=m; j++){\n             dp[0][j]=0;\n         }\n        int maxi=0; int row=0; int col=0;\n         for(int i=1;i<=n;i++){\n             for(int j=1; j<=m ;j++){\n                 if(s[i-1]==s2[j-1]){\n                     dp[i][j]=1+dp[i-1][j-1];\n                     if(dp[i][j]>maxi){\n                         maxi=dp[i][j];\n                         row=i;\n                         col=j;\n                     }\n\n                    } \n                else\n                dp[i][j]=0; // if the continuity is broken then there is no LCS'\n                    \n             }\n         }\n\n        \n         //maxi is the length of the longest commmon palindromic substring\n         \n         //we also have the row and col at which maxi element is found;\n         string ans=\"\";\n         int len=maxi;\n\n\n         while((row>0&&col>0) && len>0){ //added this condition of len>0 beacsyein the second test case bbc print horha tha and this was because humara len=2 ka lcsubstring h par abhi tak row ya col 0 nhi hua tha toh islioye c bhi append hogya\n         //toh matlab yeh h ki jaha tak len h utna hi string me daalo\n               ans+=s[row-1];\n               row--;\n               col--;\n               len--;\n\n         }\n       cout<<maxi;\n        \n         return ans;\n\n\n    }\n    string longestPalindrome(string s) {\n        string s2=s;\n        reverse(s.begin(),s.end());\n        return lcsub(s2,s);\n    }"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    }
                ]
            },
            {
                "id": 2005284,
                "content": [
                    {
                        "username": "aylahjomri",
                        "content": "why does it say 141/141 testcases passed but says Time Limit Exceeded and the last executed input is empty ?"
                    },
                    {
                        "username": "CvamReborn_C2R",
                        "content": "Wrong Question some test cases are not right"
                    },
                    {
                        "username": "ak_3101",
                        "content": "okay so is it absolutely normal to get an intuition of writing code in tabular form or everybody first write recursion, and then top down/ bottom up"
                    },
                    {
                        "username": "jfonseca32",
                        "content": "There is something wrong with this question. I made and ran the code in Python and for every test case LeetCode says the code failed on, it works when I run it in Python."
                    },
                    {
                        "username": "timewaster69",
                        "content": "I think the test case s= (nothing) should be removed. It only causes errors and the constraints specifically state that there's at least one character to work with, and that there's specifically alphanumericals to deal with."
                    },
                    {
                        "username": "kevinbiju",
                        "content": "how do we learn to optimize brute force approach\\n"
                    },
                    {
                        "username": "espinosarennieljun",
                        "content": "To solve this you only need to mind two things. \none, Palindrome can't have with more than one even number of character duplicate.\ntwo, all single character should be ignore you only need to add one single character if the result total number is odd. example the total none single character of string is 6 and you can place single character on the middle of the string so it become 7."
                    },
                    {
                        "username": "muraripavansai22",
                        "content": "\"aacabdkacaa\"\\n\\nThis is my output : \"aacakacaa\"\\ngiven this should be expected : \"aca\"\\n\\nThere is some error with this test case\\ncorrect me if im wrong."
                    },
                    {
                        "username": "Ab__23",
                        "content": "\"aacakacaa\" is a subsequence of input string not it's substring, as the question is to find substring that's where you are getting wrong.\nFor example : let string = \"abcdef\"\nit's substrings: 'a' 'ab' 'abc' 'cde' 'abcde' ...\nit's subsequences : 'a' 'ab' 'ac' 'acf' 'abe' ..."
                    },
                    {
                        "username": "TheMystery28",
                        "content": "I've tried and failed enough times to allow myself to see the hints and come up with an optimal solution.\n\nHowever, I'd like to understand why my old code gives a \"time exceeded\" error for \"aacabdkacaa\" when I have made sure to skip the calculation that can be skipped to avoid wasting time.\n\nCould someone please enlighten me?\n\n ```\n#include <algorithm>\n#include <iostream>\n#include <string>\n#include <string_view>\n#include <unordered_map>\n#include <set>\n#include <functional>\n#include <list>\n#include <iterator>\n#include <memory>\n\n\nclass Solution {\n\n    private:\n\n        std::unordered_map<char, std::set<int>> vOfList{};\n\n        int numberOfDifferentLetters{0};\n        int numberOfDifferentLettersBeingMoreThanOne{0};\n        std::vector<char> allOfTheDifferentLetters{};\n\n    public:\n        void itLoop2(std::set<int>::iterator& auto_pLeftItPos,\n                     std::set<int>::iterator& auto_pRightItPos,\n                     int pLeft, int pRight,\n                     std::string& palindromic, const std::string_view& s,\n                     bool trueToStopTheSpetialLoopToLoop){\n                        \n                    if (abs(*auto_pLeftItPos-*auto_pRightItPos)+1<=palindromic.length()) return;\n                    if(s[pLeft] == s[pRight]){\n\n                        if (pLeft==pRight||abs(pLeft - pRight)==1){\n                            palindromic=s.substr(*auto_pLeftItPos,abs(*auto_pLeftItPos-*auto_pRightItPos)+1);\n                        }\n                        else{\n\n\n                        itLoop2(auto_pLeftItPos, auto_pRightItPos,\n                                pLeft+1, pRight-1,palindromic, \n                                s,trueToStopTheSpetialLoopToLoop);}\n                    }\n                    else if (trueToStopTheSpetialLoopToLoop==false){\n                        trueToStopTheSpetialLoopToLoop = true;\n                    \n                        int x{std::abs(static_cast<int>(std::distance(auto_pLeftItPos,auto_pRightItPos)))};\n\n\n                        int c{0};\n\n                        for (int n{x};n>0;--n){\n                            //remainder that auto_pLeftItPos/auto_pRightItPos are in reverse for their iterator\n\n                            if (n==x) {++c;continue;} //If not we wouldn't be here in the first place\n\n\n\n                            int z{n};\n\n                            auto auto_pLeftItPosEdit{std::prev(auto_pLeftItPos,c)};\n\n                            itLoop2(auto_pLeftItPosEdit, auto_pRightItPos,\n                                *auto_pLeftItPosEdit, pRight,\n                                palindromic, \n                                s,trueToStopTheSpetialLoopToLoop);\n\n                            auto auto_pRightItPosEdit{auto_pRightItPos};\n\n                            while(auto_pLeftItPosEdit!=auto_pLeftItPos){\n                                \n                                auto_pLeftItPosEdit = std::next(auto_pLeftItPosEdit,1);\n                                auto_pRightItPosEdit = std::next(auto_pRightItPosEdit, 1);\n\n                                if (abs(*auto_pLeftItPos-*auto_pRightItPos)+1<=palindromic.length()) continue;\n\n                                itLoop2(auto_pLeftItPosEdit, auto_pRightItPosEdit,\n                                *auto_pLeftItPosEdit, *auto_pRightItPosEdit,\n                                palindromic, \n                                s,trueToStopTheSpetialLoopToLoop);\n\n                            }\n\n                            ++c;\n                        }\n\n                    }\n                    else return;\n\n        }\n\n        void itLoop(std::unordered_map<char, std::set<int>>::iterator& itBegin,\n                    std::string& palindromic, const std::string_view& s){\n                    \n\n                bool trueToStopTheSpetialLoopToLoop{false};\n\n            \n                auto *ptr {&((itBegin->second))};\n             \n                std::set<int>::iterator setEnd {ptr->begin()};\n\n\n                std::set<int>::iterator setBegin {ptr->end()};\n\n                std::advance(setBegin, -1);\n                //end() give the iterator AFTER the last element of the container\n\n            int pLeft{*setEnd};\n\n            int pRight{*setBegin};\n\n            if (abs(pLeft-pRight)+1<=palindromic.length()) return;\n\n\n            itLoop2(setEnd, setBegin, pLeft, pRight, palindromic, s, trueToStopTheSpetialLoopToLoop);\n\n\n        }\n\n        std::string longestPalindrome(const std::string_view& s) {\n\n            if (s.length()==0){\n                return \"\";\n            }\n            \n            std::vector<bool> everythingUsed (s.length(), false);\n\n            auto finised{[&]() -> bool {return (std::all_of(everythingUsed.begin(), everythingUsed.end(), [&](bool v) { return v; }));}};\n                \n            for (int x{0}; x<s.length()&&!finised();++x){\n\n\n                        if (everythingUsed[x]==false){\n                            everythingUsed[x]=true;\n\n                            ++numberOfDifferentLetters;\n                            allOfTheDifferentLetters.push_back(s[x]);\n\n\n                            for (int y{x+1};y<s.length()&&!finised();++y){\n                                if (everythingUsed[y]==true) continue;\n\n                                else {\n                                    if (s[x]==s[y]){\n                                        everythingUsed[y]=true;\n                                        vOfList[s[x]].insert({x,y});\n                                        ++numberOfDifferentLettersBeingMoreThanOne;\n                                    }\n                                }\n                            }\n                        }\n                        else continue;\n                    }\n\n            if (numberOfDifferentLettersBeingMoreThanOne==0) {\n                std::string str_ch {s[0]};\n                return str_ch;\n            };\n\n            std::unordered_map<char, std::set<int>>::iterator itBegin {vOfList.begin()};\n        \n\n            \n            std::string palindromic{};\n\n            while(itBegin != vOfList.end()){\n            \n                itLoop(itBegin, palindromic, s );\n                ++itBegin;\n            \n                }\n            \n            return palindromic;\n    \n    }\n};\n```\n"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "shri1403",
                        "content": "hi i was trying to solve this using the concepts of longest common substring and longest palindromic substring,\nhowver it doesnt work for the cases like aadabcadaa. this gives adaa as the ans and not ada. please help me with this\nthe following is my code:\n  string lcsub(string s , string s2){\n        int n=s.size();\n        int m=s2.size();\n         \n         vector<vector<int>> dp(n+1,vector<int>(m+1,0));\n         for(int i=0 ; i<=n;i++){\n             dp[i][0]=0;\n         }\n         for(int j=0; j<=m; j++){\n             dp[0][j]=0;\n         }\n        int maxi=0; int row=0; int col=0;\n         for(int i=1;i<=n;i++){\n             for(int j=1; j<=m ;j++){\n                 if(s[i-1]==s2[j-1]){\n                     dp[i][j]=1+dp[i-1][j-1];\n                     if(dp[i][j]>maxi){\n                         maxi=dp[i][j];\n                         row=i;\n                         col=j;\n                     }\n\n                    } \n                else\n                dp[i][j]=0; // if the continuity is broken then there is no LCS'\n                    \n             }\n         }\n\n        \n         //maxi is the length of the longest commmon palindromic substring\n         \n         //we also have the row and col at which maxi element is found;\n         string ans=\"\";\n         int len=maxi;\n\n\n         while((row>0&&col>0) && len>0){ //added this condition of len>0 beacsyein the second test case bbc print horha tha and this was because humara len=2 ka lcsubstring h par abhi tak row ya col 0 nhi hua tha toh islioye c bhi append hogya\n         //toh matlab yeh h ki jaha tak len h utna hi string me daalo\n               ans+=s[row-1];\n               row--;\n               col--;\n               len--;\n\n         }\n       cout<<maxi;\n        \n         return ans;\n\n\n    }\n    string longestPalindrome(string s) {\n        string s2=s;\n        reverse(s.begin(),s.end());\n        return lcsub(s2,s);\n    }"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    }
                ]
            },
            {
                "id": 2001061,
                "content": [
                    {
                        "username": "aylahjomri",
                        "content": "why does it say 141/141 testcases passed but says Time Limit Exceeded and the last executed input is empty ?"
                    },
                    {
                        "username": "CvamReborn_C2R",
                        "content": "Wrong Question some test cases are not right"
                    },
                    {
                        "username": "ak_3101",
                        "content": "okay so is it absolutely normal to get an intuition of writing code in tabular form or everybody first write recursion, and then top down/ bottom up"
                    },
                    {
                        "username": "jfonseca32",
                        "content": "There is something wrong with this question. I made and ran the code in Python and for every test case LeetCode says the code failed on, it works when I run it in Python."
                    },
                    {
                        "username": "timewaster69",
                        "content": "I think the test case s= (nothing) should be removed. It only causes errors and the constraints specifically state that there's at least one character to work with, and that there's specifically alphanumericals to deal with."
                    },
                    {
                        "username": "kevinbiju",
                        "content": "how do we learn to optimize brute force approach\\n"
                    },
                    {
                        "username": "espinosarennieljun",
                        "content": "To solve this you only need to mind two things. \none, Palindrome can't have with more than one even number of character duplicate.\ntwo, all single character should be ignore you only need to add one single character if the result total number is odd. example the total none single character of string is 6 and you can place single character on the middle of the string so it become 7."
                    },
                    {
                        "username": "muraripavansai22",
                        "content": "\"aacabdkacaa\"\\n\\nThis is my output : \"aacakacaa\"\\ngiven this should be expected : \"aca\"\\n\\nThere is some error with this test case\\ncorrect me if im wrong."
                    },
                    {
                        "username": "Ab__23",
                        "content": "\"aacakacaa\" is a subsequence of input string not it's substring, as the question is to find substring that's where you are getting wrong.\nFor example : let string = \"abcdef\"\nit's substrings: 'a' 'ab' 'abc' 'cde' 'abcde' ...\nit's subsequences : 'a' 'ab' 'ac' 'acf' 'abe' ..."
                    },
                    {
                        "username": "TheMystery28",
                        "content": "I've tried and failed enough times to allow myself to see the hints and come up with an optimal solution.\n\nHowever, I'd like to understand why my old code gives a \"time exceeded\" error for \"aacabdkacaa\" when I have made sure to skip the calculation that can be skipped to avoid wasting time.\n\nCould someone please enlighten me?\n\n ```\n#include <algorithm>\n#include <iostream>\n#include <string>\n#include <string_view>\n#include <unordered_map>\n#include <set>\n#include <functional>\n#include <list>\n#include <iterator>\n#include <memory>\n\n\nclass Solution {\n\n    private:\n\n        std::unordered_map<char, std::set<int>> vOfList{};\n\n        int numberOfDifferentLetters{0};\n        int numberOfDifferentLettersBeingMoreThanOne{0};\n        std::vector<char> allOfTheDifferentLetters{};\n\n    public:\n        void itLoop2(std::set<int>::iterator& auto_pLeftItPos,\n                     std::set<int>::iterator& auto_pRightItPos,\n                     int pLeft, int pRight,\n                     std::string& palindromic, const std::string_view& s,\n                     bool trueToStopTheSpetialLoopToLoop){\n                        \n                    if (abs(*auto_pLeftItPos-*auto_pRightItPos)+1<=palindromic.length()) return;\n                    if(s[pLeft] == s[pRight]){\n\n                        if (pLeft==pRight||abs(pLeft - pRight)==1){\n                            palindromic=s.substr(*auto_pLeftItPos,abs(*auto_pLeftItPos-*auto_pRightItPos)+1);\n                        }\n                        else{\n\n\n                        itLoop2(auto_pLeftItPos, auto_pRightItPos,\n                                pLeft+1, pRight-1,palindromic, \n                                s,trueToStopTheSpetialLoopToLoop);}\n                    }\n                    else if (trueToStopTheSpetialLoopToLoop==false){\n                        trueToStopTheSpetialLoopToLoop = true;\n                    \n                        int x{std::abs(static_cast<int>(std::distance(auto_pLeftItPos,auto_pRightItPos)))};\n\n\n                        int c{0};\n\n                        for (int n{x};n>0;--n){\n                            //remainder that auto_pLeftItPos/auto_pRightItPos are in reverse for their iterator\n\n                            if (n==x) {++c;continue;} //If not we wouldn't be here in the first place\n\n\n\n                            int z{n};\n\n                            auto auto_pLeftItPosEdit{std::prev(auto_pLeftItPos,c)};\n\n                            itLoop2(auto_pLeftItPosEdit, auto_pRightItPos,\n                                *auto_pLeftItPosEdit, pRight,\n                                palindromic, \n                                s,trueToStopTheSpetialLoopToLoop);\n\n                            auto auto_pRightItPosEdit{auto_pRightItPos};\n\n                            while(auto_pLeftItPosEdit!=auto_pLeftItPos){\n                                \n                                auto_pLeftItPosEdit = std::next(auto_pLeftItPosEdit,1);\n                                auto_pRightItPosEdit = std::next(auto_pRightItPosEdit, 1);\n\n                                if (abs(*auto_pLeftItPos-*auto_pRightItPos)+1<=palindromic.length()) continue;\n\n                                itLoop2(auto_pLeftItPosEdit, auto_pRightItPosEdit,\n                                *auto_pLeftItPosEdit, *auto_pRightItPosEdit,\n                                palindromic, \n                                s,trueToStopTheSpetialLoopToLoop);\n\n                            }\n\n                            ++c;\n                        }\n\n                    }\n                    else return;\n\n        }\n\n        void itLoop(std::unordered_map<char, std::set<int>>::iterator& itBegin,\n                    std::string& palindromic, const std::string_view& s){\n                    \n\n                bool trueToStopTheSpetialLoopToLoop{false};\n\n            \n                auto *ptr {&((itBegin->second))};\n             \n                std::set<int>::iterator setEnd {ptr->begin()};\n\n\n                std::set<int>::iterator setBegin {ptr->end()};\n\n                std::advance(setBegin, -1);\n                //end() give the iterator AFTER the last element of the container\n\n            int pLeft{*setEnd};\n\n            int pRight{*setBegin};\n\n            if (abs(pLeft-pRight)+1<=palindromic.length()) return;\n\n\n            itLoop2(setEnd, setBegin, pLeft, pRight, palindromic, s, trueToStopTheSpetialLoopToLoop);\n\n\n        }\n\n        std::string longestPalindrome(const std::string_view& s) {\n\n            if (s.length()==0){\n                return \"\";\n            }\n            \n            std::vector<bool> everythingUsed (s.length(), false);\n\n            auto finised{[&]() -> bool {return (std::all_of(everythingUsed.begin(), everythingUsed.end(), [&](bool v) { return v; }));}};\n                \n            for (int x{0}; x<s.length()&&!finised();++x){\n\n\n                        if (everythingUsed[x]==false){\n                            everythingUsed[x]=true;\n\n                            ++numberOfDifferentLetters;\n                            allOfTheDifferentLetters.push_back(s[x]);\n\n\n                            for (int y{x+1};y<s.length()&&!finised();++y){\n                                if (everythingUsed[y]==true) continue;\n\n                                else {\n                                    if (s[x]==s[y]){\n                                        everythingUsed[y]=true;\n                                        vOfList[s[x]].insert({x,y});\n                                        ++numberOfDifferentLettersBeingMoreThanOne;\n                                    }\n                                }\n                            }\n                        }\n                        else continue;\n                    }\n\n            if (numberOfDifferentLettersBeingMoreThanOne==0) {\n                std::string str_ch {s[0]};\n                return str_ch;\n            };\n\n            std::unordered_map<char, std::set<int>>::iterator itBegin {vOfList.begin()};\n        \n\n            \n            std::string palindromic{};\n\n            while(itBegin != vOfList.end()){\n            \n                itLoop(itBegin, palindromic, s );\n                ++itBegin;\n            \n                }\n            \n            return palindromic;\n    \n    }\n};\n```\n"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "shri1403",
                        "content": "hi i was trying to solve this using the concepts of longest common substring and longest palindromic substring,\nhowver it doesnt work for the cases like aadabcadaa. this gives adaa as the ans and not ada. please help me with this\nthe following is my code:\n  string lcsub(string s , string s2){\n        int n=s.size();\n        int m=s2.size();\n         \n         vector<vector<int>> dp(n+1,vector<int>(m+1,0));\n         for(int i=0 ; i<=n;i++){\n             dp[i][0]=0;\n         }\n         for(int j=0; j<=m; j++){\n             dp[0][j]=0;\n         }\n        int maxi=0; int row=0; int col=0;\n         for(int i=1;i<=n;i++){\n             for(int j=1; j<=m ;j++){\n                 if(s[i-1]==s2[j-1]){\n                     dp[i][j]=1+dp[i-1][j-1];\n                     if(dp[i][j]>maxi){\n                         maxi=dp[i][j];\n                         row=i;\n                         col=j;\n                     }\n\n                    } \n                else\n                dp[i][j]=0; // if the continuity is broken then there is no LCS'\n                    \n             }\n         }\n\n        \n         //maxi is the length of the longest commmon palindromic substring\n         \n         //we also have the row and col at which maxi element is found;\n         string ans=\"\";\n         int len=maxi;\n\n\n         while((row>0&&col>0) && len>0){ //added this condition of len>0 beacsyein the second test case bbc print horha tha and this was because humara len=2 ka lcsubstring h par abhi tak row ya col 0 nhi hua tha toh islioye c bhi append hogya\n         //toh matlab yeh h ki jaha tak len h utna hi string me daalo\n               ans+=s[row-1];\n               row--;\n               col--;\n               len--;\n\n         }\n       cout<<maxi;\n        \n         return ans;\n\n\n    }\n    string longestPalindrome(string s) {\n        string s2=s;\n        reverse(s.begin(),s.end());\n        return lcsub(s2,s);\n    }"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    }
                ]
            },
            {
                "id": 1996056,
                "content": [
                    {
                        "username": "aylahjomri",
                        "content": "why does it say 141/141 testcases passed but says Time Limit Exceeded and the last executed input is empty ?"
                    },
                    {
                        "username": "CvamReborn_C2R",
                        "content": "Wrong Question some test cases are not right"
                    },
                    {
                        "username": "ak_3101",
                        "content": "okay so is it absolutely normal to get an intuition of writing code in tabular form or everybody first write recursion, and then top down/ bottom up"
                    },
                    {
                        "username": "jfonseca32",
                        "content": "There is something wrong with this question. I made and ran the code in Python and for every test case LeetCode says the code failed on, it works when I run it in Python."
                    },
                    {
                        "username": "timewaster69",
                        "content": "I think the test case s= (nothing) should be removed. It only causes errors and the constraints specifically state that there's at least one character to work with, and that there's specifically alphanumericals to deal with."
                    },
                    {
                        "username": "kevinbiju",
                        "content": "how do we learn to optimize brute force approach\\n"
                    },
                    {
                        "username": "espinosarennieljun",
                        "content": "To solve this you only need to mind two things. \none, Palindrome can't have with more than one even number of character duplicate.\ntwo, all single character should be ignore you only need to add one single character if the result total number is odd. example the total none single character of string is 6 and you can place single character on the middle of the string so it become 7."
                    },
                    {
                        "username": "muraripavansai22",
                        "content": "\"aacabdkacaa\"\\n\\nThis is my output : \"aacakacaa\"\\ngiven this should be expected : \"aca\"\\n\\nThere is some error with this test case\\ncorrect me if im wrong."
                    },
                    {
                        "username": "Ab__23",
                        "content": "\"aacakacaa\" is a subsequence of input string not it's substring, as the question is to find substring that's where you are getting wrong.\nFor example : let string = \"abcdef\"\nit's substrings: 'a' 'ab' 'abc' 'cde' 'abcde' ...\nit's subsequences : 'a' 'ab' 'ac' 'acf' 'abe' ..."
                    },
                    {
                        "username": "TheMystery28",
                        "content": "I've tried and failed enough times to allow myself to see the hints and come up with an optimal solution.\n\nHowever, I'd like to understand why my old code gives a \"time exceeded\" error for \"aacabdkacaa\" when I have made sure to skip the calculation that can be skipped to avoid wasting time.\n\nCould someone please enlighten me?\n\n ```\n#include <algorithm>\n#include <iostream>\n#include <string>\n#include <string_view>\n#include <unordered_map>\n#include <set>\n#include <functional>\n#include <list>\n#include <iterator>\n#include <memory>\n\n\nclass Solution {\n\n    private:\n\n        std::unordered_map<char, std::set<int>> vOfList{};\n\n        int numberOfDifferentLetters{0};\n        int numberOfDifferentLettersBeingMoreThanOne{0};\n        std::vector<char> allOfTheDifferentLetters{};\n\n    public:\n        void itLoop2(std::set<int>::iterator& auto_pLeftItPos,\n                     std::set<int>::iterator& auto_pRightItPos,\n                     int pLeft, int pRight,\n                     std::string& palindromic, const std::string_view& s,\n                     bool trueToStopTheSpetialLoopToLoop){\n                        \n                    if (abs(*auto_pLeftItPos-*auto_pRightItPos)+1<=palindromic.length()) return;\n                    if(s[pLeft] == s[pRight]){\n\n                        if (pLeft==pRight||abs(pLeft - pRight)==1){\n                            palindromic=s.substr(*auto_pLeftItPos,abs(*auto_pLeftItPos-*auto_pRightItPos)+1);\n                        }\n                        else{\n\n\n                        itLoop2(auto_pLeftItPos, auto_pRightItPos,\n                                pLeft+1, pRight-1,palindromic, \n                                s,trueToStopTheSpetialLoopToLoop);}\n                    }\n                    else if (trueToStopTheSpetialLoopToLoop==false){\n                        trueToStopTheSpetialLoopToLoop = true;\n                    \n                        int x{std::abs(static_cast<int>(std::distance(auto_pLeftItPos,auto_pRightItPos)))};\n\n\n                        int c{0};\n\n                        for (int n{x};n>0;--n){\n                            //remainder that auto_pLeftItPos/auto_pRightItPos are in reverse for their iterator\n\n                            if (n==x) {++c;continue;} //If not we wouldn't be here in the first place\n\n\n\n                            int z{n};\n\n                            auto auto_pLeftItPosEdit{std::prev(auto_pLeftItPos,c)};\n\n                            itLoop2(auto_pLeftItPosEdit, auto_pRightItPos,\n                                *auto_pLeftItPosEdit, pRight,\n                                palindromic, \n                                s,trueToStopTheSpetialLoopToLoop);\n\n                            auto auto_pRightItPosEdit{auto_pRightItPos};\n\n                            while(auto_pLeftItPosEdit!=auto_pLeftItPos){\n                                \n                                auto_pLeftItPosEdit = std::next(auto_pLeftItPosEdit,1);\n                                auto_pRightItPosEdit = std::next(auto_pRightItPosEdit, 1);\n\n                                if (abs(*auto_pLeftItPos-*auto_pRightItPos)+1<=palindromic.length()) continue;\n\n                                itLoop2(auto_pLeftItPosEdit, auto_pRightItPosEdit,\n                                *auto_pLeftItPosEdit, *auto_pRightItPosEdit,\n                                palindromic, \n                                s,trueToStopTheSpetialLoopToLoop);\n\n                            }\n\n                            ++c;\n                        }\n\n                    }\n                    else return;\n\n        }\n\n        void itLoop(std::unordered_map<char, std::set<int>>::iterator& itBegin,\n                    std::string& palindromic, const std::string_view& s){\n                    \n\n                bool trueToStopTheSpetialLoopToLoop{false};\n\n            \n                auto *ptr {&((itBegin->second))};\n             \n                std::set<int>::iterator setEnd {ptr->begin()};\n\n\n                std::set<int>::iterator setBegin {ptr->end()};\n\n                std::advance(setBegin, -1);\n                //end() give the iterator AFTER the last element of the container\n\n            int pLeft{*setEnd};\n\n            int pRight{*setBegin};\n\n            if (abs(pLeft-pRight)+1<=palindromic.length()) return;\n\n\n            itLoop2(setEnd, setBegin, pLeft, pRight, palindromic, s, trueToStopTheSpetialLoopToLoop);\n\n\n        }\n\n        std::string longestPalindrome(const std::string_view& s) {\n\n            if (s.length()==0){\n                return \"\";\n            }\n            \n            std::vector<bool> everythingUsed (s.length(), false);\n\n            auto finised{[&]() -> bool {return (std::all_of(everythingUsed.begin(), everythingUsed.end(), [&](bool v) { return v; }));}};\n                \n            for (int x{0}; x<s.length()&&!finised();++x){\n\n\n                        if (everythingUsed[x]==false){\n                            everythingUsed[x]=true;\n\n                            ++numberOfDifferentLetters;\n                            allOfTheDifferentLetters.push_back(s[x]);\n\n\n                            for (int y{x+1};y<s.length()&&!finised();++y){\n                                if (everythingUsed[y]==true) continue;\n\n                                else {\n                                    if (s[x]==s[y]){\n                                        everythingUsed[y]=true;\n                                        vOfList[s[x]].insert({x,y});\n                                        ++numberOfDifferentLettersBeingMoreThanOne;\n                                    }\n                                }\n                            }\n                        }\n                        else continue;\n                    }\n\n            if (numberOfDifferentLettersBeingMoreThanOne==0) {\n                std::string str_ch {s[0]};\n                return str_ch;\n            };\n\n            std::unordered_map<char, std::set<int>>::iterator itBegin {vOfList.begin()};\n        \n\n            \n            std::string palindromic{};\n\n            while(itBegin != vOfList.end()){\n            \n                itLoop(itBegin, palindromic, s );\n                ++itBegin;\n            \n                }\n            \n            return palindromic;\n    \n    }\n};\n```\n"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "shri1403",
                        "content": "hi i was trying to solve this using the concepts of longest common substring and longest palindromic substring,\nhowver it doesnt work for the cases like aadabcadaa. this gives adaa as the ans and not ada. please help me with this\nthe following is my code:\n  string lcsub(string s , string s2){\n        int n=s.size();\n        int m=s2.size();\n         \n         vector<vector<int>> dp(n+1,vector<int>(m+1,0));\n         for(int i=0 ; i<=n;i++){\n             dp[i][0]=0;\n         }\n         for(int j=0; j<=m; j++){\n             dp[0][j]=0;\n         }\n        int maxi=0; int row=0; int col=0;\n         for(int i=1;i<=n;i++){\n             for(int j=1; j<=m ;j++){\n                 if(s[i-1]==s2[j-1]){\n                     dp[i][j]=1+dp[i-1][j-1];\n                     if(dp[i][j]>maxi){\n                         maxi=dp[i][j];\n                         row=i;\n                         col=j;\n                     }\n\n                    } \n                else\n                dp[i][j]=0; // if the continuity is broken then there is no LCS'\n                    \n             }\n         }\n\n        \n         //maxi is the length of the longest commmon palindromic substring\n         \n         //we also have the row and col at which maxi element is found;\n         string ans=\"\";\n         int len=maxi;\n\n\n         while((row>0&&col>0) && len>0){ //added this condition of len>0 beacsyein the second test case bbc print horha tha and this was because humara len=2 ka lcsubstring h par abhi tak row ya col 0 nhi hua tha toh islioye c bhi append hogya\n         //toh matlab yeh h ki jaha tak len h utna hi string me daalo\n               ans+=s[row-1];\n               row--;\n               col--;\n               len--;\n\n         }\n       cout<<maxi;\n        \n         return ans;\n\n\n    }\n    string longestPalindrome(string s) {\n        string s2=s;\n        reverse(s.begin(),s.end());\n        return lcsub(s2,s);\n    }"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    }
                ]
            },
            {
                "id": 1992101,
                "content": [
                    {
                        "username": "aylahjomri",
                        "content": "why does it say 141/141 testcases passed but says Time Limit Exceeded and the last executed input is empty ?"
                    },
                    {
                        "username": "CvamReborn_C2R",
                        "content": "Wrong Question some test cases are not right"
                    },
                    {
                        "username": "ak_3101",
                        "content": "okay so is it absolutely normal to get an intuition of writing code in tabular form or everybody first write recursion, and then top down/ bottom up"
                    },
                    {
                        "username": "jfonseca32",
                        "content": "There is something wrong with this question. I made and ran the code in Python and for every test case LeetCode says the code failed on, it works when I run it in Python."
                    },
                    {
                        "username": "timewaster69",
                        "content": "I think the test case s= (nothing) should be removed. It only causes errors and the constraints specifically state that there's at least one character to work with, and that there's specifically alphanumericals to deal with."
                    },
                    {
                        "username": "kevinbiju",
                        "content": "how do we learn to optimize brute force approach\\n"
                    },
                    {
                        "username": "espinosarennieljun",
                        "content": "To solve this you only need to mind two things. \none, Palindrome can't have with more than one even number of character duplicate.\ntwo, all single character should be ignore you only need to add one single character if the result total number is odd. example the total none single character of string is 6 and you can place single character on the middle of the string so it become 7."
                    },
                    {
                        "username": "muraripavansai22",
                        "content": "\"aacabdkacaa\"\\n\\nThis is my output : \"aacakacaa\"\\ngiven this should be expected : \"aca\"\\n\\nThere is some error with this test case\\ncorrect me if im wrong."
                    },
                    {
                        "username": "Ab__23",
                        "content": "\"aacakacaa\" is a subsequence of input string not it's substring, as the question is to find substring that's where you are getting wrong.\nFor example : let string = \"abcdef\"\nit's substrings: 'a' 'ab' 'abc' 'cde' 'abcde' ...\nit's subsequences : 'a' 'ab' 'ac' 'acf' 'abe' ..."
                    },
                    {
                        "username": "TheMystery28",
                        "content": "I've tried and failed enough times to allow myself to see the hints and come up with an optimal solution.\n\nHowever, I'd like to understand why my old code gives a \"time exceeded\" error for \"aacabdkacaa\" when I have made sure to skip the calculation that can be skipped to avoid wasting time.\n\nCould someone please enlighten me?\n\n ```\n#include <algorithm>\n#include <iostream>\n#include <string>\n#include <string_view>\n#include <unordered_map>\n#include <set>\n#include <functional>\n#include <list>\n#include <iterator>\n#include <memory>\n\n\nclass Solution {\n\n    private:\n\n        std::unordered_map<char, std::set<int>> vOfList{};\n\n        int numberOfDifferentLetters{0};\n        int numberOfDifferentLettersBeingMoreThanOne{0};\n        std::vector<char> allOfTheDifferentLetters{};\n\n    public:\n        void itLoop2(std::set<int>::iterator& auto_pLeftItPos,\n                     std::set<int>::iterator& auto_pRightItPos,\n                     int pLeft, int pRight,\n                     std::string& palindromic, const std::string_view& s,\n                     bool trueToStopTheSpetialLoopToLoop){\n                        \n                    if (abs(*auto_pLeftItPos-*auto_pRightItPos)+1<=palindromic.length()) return;\n                    if(s[pLeft] == s[pRight]){\n\n                        if (pLeft==pRight||abs(pLeft - pRight)==1){\n                            palindromic=s.substr(*auto_pLeftItPos,abs(*auto_pLeftItPos-*auto_pRightItPos)+1);\n                        }\n                        else{\n\n\n                        itLoop2(auto_pLeftItPos, auto_pRightItPos,\n                                pLeft+1, pRight-1,palindromic, \n                                s,trueToStopTheSpetialLoopToLoop);}\n                    }\n                    else if (trueToStopTheSpetialLoopToLoop==false){\n                        trueToStopTheSpetialLoopToLoop = true;\n                    \n                        int x{std::abs(static_cast<int>(std::distance(auto_pLeftItPos,auto_pRightItPos)))};\n\n\n                        int c{0};\n\n                        for (int n{x};n>0;--n){\n                            //remainder that auto_pLeftItPos/auto_pRightItPos are in reverse for their iterator\n\n                            if (n==x) {++c;continue;} //If not we wouldn't be here in the first place\n\n\n\n                            int z{n};\n\n                            auto auto_pLeftItPosEdit{std::prev(auto_pLeftItPos,c)};\n\n                            itLoop2(auto_pLeftItPosEdit, auto_pRightItPos,\n                                *auto_pLeftItPosEdit, pRight,\n                                palindromic, \n                                s,trueToStopTheSpetialLoopToLoop);\n\n                            auto auto_pRightItPosEdit{auto_pRightItPos};\n\n                            while(auto_pLeftItPosEdit!=auto_pLeftItPos){\n                                \n                                auto_pLeftItPosEdit = std::next(auto_pLeftItPosEdit,1);\n                                auto_pRightItPosEdit = std::next(auto_pRightItPosEdit, 1);\n\n                                if (abs(*auto_pLeftItPos-*auto_pRightItPos)+1<=palindromic.length()) continue;\n\n                                itLoop2(auto_pLeftItPosEdit, auto_pRightItPosEdit,\n                                *auto_pLeftItPosEdit, *auto_pRightItPosEdit,\n                                palindromic, \n                                s,trueToStopTheSpetialLoopToLoop);\n\n                            }\n\n                            ++c;\n                        }\n\n                    }\n                    else return;\n\n        }\n\n        void itLoop(std::unordered_map<char, std::set<int>>::iterator& itBegin,\n                    std::string& palindromic, const std::string_view& s){\n                    \n\n                bool trueToStopTheSpetialLoopToLoop{false};\n\n            \n                auto *ptr {&((itBegin->second))};\n             \n                std::set<int>::iterator setEnd {ptr->begin()};\n\n\n                std::set<int>::iterator setBegin {ptr->end()};\n\n                std::advance(setBegin, -1);\n                //end() give the iterator AFTER the last element of the container\n\n            int pLeft{*setEnd};\n\n            int pRight{*setBegin};\n\n            if (abs(pLeft-pRight)+1<=palindromic.length()) return;\n\n\n            itLoop2(setEnd, setBegin, pLeft, pRight, palindromic, s, trueToStopTheSpetialLoopToLoop);\n\n\n        }\n\n        std::string longestPalindrome(const std::string_view& s) {\n\n            if (s.length()==0){\n                return \"\";\n            }\n            \n            std::vector<bool> everythingUsed (s.length(), false);\n\n            auto finised{[&]() -> bool {return (std::all_of(everythingUsed.begin(), everythingUsed.end(), [&](bool v) { return v; }));}};\n                \n            for (int x{0}; x<s.length()&&!finised();++x){\n\n\n                        if (everythingUsed[x]==false){\n                            everythingUsed[x]=true;\n\n                            ++numberOfDifferentLetters;\n                            allOfTheDifferentLetters.push_back(s[x]);\n\n\n                            for (int y{x+1};y<s.length()&&!finised();++y){\n                                if (everythingUsed[y]==true) continue;\n\n                                else {\n                                    if (s[x]==s[y]){\n                                        everythingUsed[y]=true;\n                                        vOfList[s[x]].insert({x,y});\n                                        ++numberOfDifferentLettersBeingMoreThanOne;\n                                    }\n                                }\n                            }\n                        }\n                        else continue;\n                    }\n\n            if (numberOfDifferentLettersBeingMoreThanOne==0) {\n                std::string str_ch {s[0]};\n                return str_ch;\n            };\n\n            std::unordered_map<char, std::set<int>>::iterator itBegin {vOfList.begin()};\n        \n\n            \n            std::string palindromic{};\n\n            while(itBegin != vOfList.end()){\n            \n                itLoop(itBegin, palindromic, s );\n                ++itBegin;\n            \n                }\n            \n            return palindromic;\n    \n    }\n};\n```\n"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "shri1403",
                        "content": "hi i was trying to solve this using the concepts of longest common substring and longest palindromic substring,\nhowver it doesnt work for the cases like aadabcadaa. this gives adaa as the ans and not ada. please help me with this\nthe following is my code:\n  string lcsub(string s , string s2){\n        int n=s.size();\n        int m=s2.size();\n         \n         vector<vector<int>> dp(n+1,vector<int>(m+1,0));\n         for(int i=0 ; i<=n;i++){\n             dp[i][0]=0;\n         }\n         for(int j=0; j<=m; j++){\n             dp[0][j]=0;\n         }\n        int maxi=0; int row=0; int col=0;\n         for(int i=1;i<=n;i++){\n             for(int j=1; j<=m ;j++){\n                 if(s[i-1]==s2[j-1]){\n                     dp[i][j]=1+dp[i-1][j-1];\n                     if(dp[i][j]>maxi){\n                         maxi=dp[i][j];\n                         row=i;\n                         col=j;\n                     }\n\n                    } \n                else\n                dp[i][j]=0; // if the continuity is broken then there is no LCS'\n                    \n             }\n         }\n\n        \n         //maxi is the length of the longest commmon palindromic substring\n         \n         //we also have the row and col at which maxi element is found;\n         string ans=\"\";\n         int len=maxi;\n\n\n         while((row>0&&col>0) && len>0){ //added this condition of len>0 beacsyein the second test case bbc print horha tha and this was because humara len=2 ka lcsubstring h par abhi tak row ya col 0 nhi hua tha toh islioye c bhi append hogya\n         //toh matlab yeh h ki jaha tak len h utna hi string me daalo\n               ans+=s[row-1];\n               row--;\n               col--;\n               len--;\n\n         }\n       cout<<maxi;\n        \n         return ans;\n\n\n    }\n    string longestPalindrome(string s) {\n        string s2=s;\n        reverse(s.begin(),s.end());\n        return lcsub(s2,s);\n    }"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    }
                ]
            },
            {
                "id": 1983388,
                "content": [
                    {
                        "username": "aylahjomri",
                        "content": "why does it say 141/141 testcases passed but says Time Limit Exceeded and the last executed input is empty ?"
                    },
                    {
                        "username": "CvamReborn_C2R",
                        "content": "Wrong Question some test cases are not right"
                    },
                    {
                        "username": "ak_3101",
                        "content": "okay so is it absolutely normal to get an intuition of writing code in tabular form or everybody first write recursion, and then top down/ bottom up"
                    },
                    {
                        "username": "jfonseca32",
                        "content": "There is something wrong with this question. I made and ran the code in Python and for every test case LeetCode says the code failed on, it works when I run it in Python."
                    },
                    {
                        "username": "timewaster69",
                        "content": "I think the test case s= (nothing) should be removed. It only causes errors and the constraints specifically state that there's at least one character to work with, and that there's specifically alphanumericals to deal with."
                    },
                    {
                        "username": "kevinbiju",
                        "content": "how do we learn to optimize brute force approach\\n"
                    },
                    {
                        "username": "espinosarennieljun",
                        "content": "To solve this you only need to mind two things. \none, Palindrome can't have with more than one even number of character duplicate.\ntwo, all single character should be ignore you only need to add one single character if the result total number is odd. example the total none single character of string is 6 and you can place single character on the middle of the string so it become 7."
                    },
                    {
                        "username": "muraripavansai22",
                        "content": "\"aacabdkacaa\"\\n\\nThis is my output : \"aacakacaa\"\\ngiven this should be expected : \"aca\"\\n\\nThere is some error with this test case\\ncorrect me if im wrong."
                    },
                    {
                        "username": "Ab__23",
                        "content": "\"aacakacaa\" is a subsequence of input string not it's substring, as the question is to find substring that's where you are getting wrong.\nFor example : let string = \"abcdef\"\nit's substrings: 'a' 'ab' 'abc' 'cde' 'abcde' ...\nit's subsequences : 'a' 'ab' 'ac' 'acf' 'abe' ..."
                    },
                    {
                        "username": "TheMystery28",
                        "content": "I've tried and failed enough times to allow myself to see the hints and come up with an optimal solution.\n\nHowever, I'd like to understand why my old code gives a \"time exceeded\" error for \"aacabdkacaa\" when I have made sure to skip the calculation that can be skipped to avoid wasting time.\n\nCould someone please enlighten me?\n\n ```\n#include <algorithm>\n#include <iostream>\n#include <string>\n#include <string_view>\n#include <unordered_map>\n#include <set>\n#include <functional>\n#include <list>\n#include <iterator>\n#include <memory>\n\n\nclass Solution {\n\n    private:\n\n        std::unordered_map<char, std::set<int>> vOfList{};\n\n        int numberOfDifferentLetters{0};\n        int numberOfDifferentLettersBeingMoreThanOne{0};\n        std::vector<char> allOfTheDifferentLetters{};\n\n    public:\n        void itLoop2(std::set<int>::iterator& auto_pLeftItPos,\n                     std::set<int>::iterator& auto_pRightItPos,\n                     int pLeft, int pRight,\n                     std::string& palindromic, const std::string_view& s,\n                     bool trueToStopTheSpetialLoopToLoop){\n                        \n                    if (abs(*auto_pLeftItPos-*auto_pRightItPos)+1<=palindromic.length()) return;\n                    if(s[pLeft] == s[pRight]){\n\n                        if (pLeft==pRight||abs(pLeft - pRight)==1){\n                            palindromic=s.substr(*auto_pLeftItPos,abs(*auto_pLeftItPos-*auto_pRightItPos)+1);\n                        }\n                        else{\n\n\n                        itLoop2(auto_pLeftItPos, auto_pRightItPos,\n                                pLeft+1, pRight-1,palindromic, \n                                s,trueToStopTheSpetialLoopToLoop);}\n                    }\n                    else if (trueToStopTheSpetialLoopToLoop==false){\n                        trueToStopTheSpetialLoopToLoop = true;\n                    \n                        int x{std::abs(static_cast<int>(std::distance(auto_pLeftItPos,auto_pRightItPos)))};\n\n\n                        int c{0};\n\n                        for (int n{x};n>0;--n){\n                            //remainder that auto_pLeftItPos/auto_pRightItPos are in reverse for their iterator\n\n                            if (n==x) {++c;continue;} //If not we wouldn't be here in the first place\n\n\n\n                            int z{n};\n\n                            auto auto_pLeftItPosEdit{std::prev(auto_pLeftItPos,c)};\n\n                            itLoop2(auto_pLeftItPosEdit, auto_pRightItPos,\n                                *auto_pLeftItPosEdit, pRight,\n                                palindromic, \n                                s,trueToStopTheSpetialLoopToLoop);\n\n                            auto auto_pRightItPosEdit{auto_pRightItPos};\n\n                            while(auto_pLeftItPosEdit!=auto_pLeftItPos){\n                                \n                                auto_pLeftItPosEdit = std::next(auto_pLeftItPosEdit,1);\n                                auto_pRightItPosEdit = std::next(auto_pRightItPosEdit, 1);\n\n                                if (abs(*auto_pLeftItPos-*auto_pRightItPos)+1<=palindromic.length()) continue;\n\n                                itLoop2(auto_pLeftItPosEdit, auto_pRightItPosEdit,\n                                *auto_pLeftItPosEdit, *auto_pRightItPosEdit,\n                                palindromic, \n                                s,trueToStopTheSpetialLoopToLoop);\n\n                            }\n\n                            ++c;\n                        }\n\n                    }\n                    else return;\n\n        }\n\n        void itLoop(std::unordered_map<char, std::set<int>>::iterator& itBegin,\n                    std::string& palindromic, const std::string_view& s){\n                    \n\n                bool trueToStopTheSpetialLoopToLoop{false};\n\n            \n                auto *ptr {&((itBegin->second))};\n             \n                std::set<int>::iterator setEnd {ptr->begin()};\n\n\n                std::set<int>::iterator setBegin {ptr->end()};\n\n                std::advance(setBegin, -1);\n                //end() give the iterator AFTER the last element of the container\n\n            int pLeft{*setEnd};\n\n            int pRight{*setBegin};\n\n            if (abs(pLeft-pRight)+1<=palindromic.length()) return;\n\n\n            itLoop2(setEnd, setBegin, pLeft, pRight, palindromic, s, trueToStopTheSpetialLoopToLoop);\n\n\n        }\n\n        std::string longestPalindrome(const std::string_view& s) {\n\n            if (s.length()==0){\n                return \"\";\n            }\n            \n            std::vector<bool> everythingUsed (s.length(), false);\n\n            auto finised{[&]() -> bool {return (std::all_of(everythingUsed.begin(), everythingUsed.end(), [&](bool v) { return v; }));}};\n                \n            for (int x{0}; x<s.length()&&!finised();++x){\n\n\n                        if (everythingUsed[x]==false){\n                            everythingUsed[x]=true;\n\n                            ++numberOfDifferentLetters;\n                            allOfTheDifferentLetters.push_back(s[x]);\n\n\n                            for (int y{x+1};y<s.length()&&!finised();++y){\n                                if (everythingUsed[y]==true) continue;\n\n                                else {\n                                    if (s[x]==s[y]){\n                                        everythingUsed[y]=true;\n                                        vOfList[s[x]].insert({x,y});\n                                        ++numberOfDifferentLettersBeingMoreThanOne;\n                                    }\n                                }\n                            }\n                        }\n                        else continue;\n                    }\n\n            if (numberOfDifferentLettersBeingMoreThanOne==0) {\n                std::string str_ch {s[0]};\n                return str_ch;\n            };\n\n            std::unordered_map<char, std::set<int>>::iterator itBegin {vOfList.begin()};\n        \n\n            \n            std::string palindromic{};\n\n            while(itBegin != vOfList.end()){\n            \n                itLoop(itBegin, palindromic, s );\n                ++itBegin;\n            \n                }\n            \n            return palindromic;\n    \n    }\n};\n```\n"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "shri1403",
                        "content": "hi i was trying to solve this using the concepts of longest common substring and longest palindromic substring,\nhowver it doesnt work for the cases like aadabcadaa. this gives adaa as the ans and not ada. please help me with this\nthe following is my code:\n  string lcsub(string s , string s2){\n        int n=s.size();\n        int m=s2.size();\n         \n         vector<vector<int>> dp(n+1,vector<int>(m+1,0));\n         for(int i=0 ; i<=n;i++){\n             dp[i][0]=0;\n         }\n         for(int j=0; j<=m; j++){\n             dp[0][j]=0;\n         }\n        int maxi=0; int row=0; int col=0;\n         for(int i=1;i<=n;i++){\n             for(int j=1; j<=m ;j++){\n                 if(s[i-1]==s2[j-1]){\n                     dp[i][j]=1+dp[i-1][j-1];\n                     if(dp[i][j]>maxi){\n                         maxi=dp[i][j];\n                         row=i;\n                         col=j;\n                     }\n\n                    } \n                else\n                dp[i][j]=0; // if the continuity is broken then there is no LCS'\n                    \n             }\n         }\n\n        \n         //maxi is the length of the longest commmon palindromic substring\n         \n         //we also have the row and col at which maxi element is found;\n         string ans=\"\";\n         int len=maxi;\n\n\n         while((row>0&&col>0) && len>0){ //added this condition of len>0 beacsyein the second test case bbc print horha tha and this was because humara len=2 ka lcsubstring h par abhi tak row ya col 0 nhi hua tha toh islioye c bhi append hogya\n         //toh matlab yeh h ki jaha tak len h utna hi string me daalo\n               ans+=s[row-1];\n               row--;\n               col--;\n               len--;\n\n         }\n       cout<<maxi;\n        \n         return ans;\n\n\n    }\n    string longestPalindrome(string s) {\n        string s2=s;\n        reverse(s.begin(),s.end());\n        return lcsub(s2,s);\n    }"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    }
                ]
            },
            {
                "id": 1981985,
                "content": [
                    {
                        "username": "aylahjomri",
                        "content": "why does it say 141/141 testcases passed but says Time Limit Exceeded and the last executed input is empty ?"
                    },
                    {
                        "username": "CvamReborn_C2R",
                        "content": "Wrong Question some test cases are not right"
                    },
                    {
                        "username": "ak_3101",
                        "content": "okay so is it absolutely normal to get an intuition of writing code in tabular form or everybody first write recursion, and then top down/ bottom up"
                    },
                    {
                        "username": "jfonseca32",
                        "content": "There is something wrong with this question. I made and ran the code in Python and for every test case LeetCode says the code failed on, it works when I run it in Python."
                    },
                    {
                        "username": "timewaster69",
                        "content": "I think the test case s= (nothing) should be removed. It only causes errors and the constraints specifically state that there's at least one character to work with, and that there's specifically alphanumericals to deal with."
                    },
                    {
                        "username": "kevinbiju",
                        "content": "how do we learn to optimize brute force approach\\n"
                    },
                    {
                        "username": "espinosarennieljun",
                        "content": "To solve this you only need to mind two things. \none, Palindrome can't have with more than one even number of character duplicate.\ntwo, all single character should be ignore you only need to add one single character if the result total number is odd. example the total none single character of string is 6 and you can place single character on the middle of the string so it become 7."
                    },
                    {
                        "username": "muraripavansai22",
                        "content": "\"aacabdkacaa\"\\n\\nThis is my output : \"aacakacaa\"\\ngiven this should be expected : \"aca\"\\n\\nThere is some error with this test case\\ncorrect me if im wrong."
                    },
                    {
                        "username": "Ab__23",
                        "content": "\"aacakacaa\" is a subsequence of input string not it's substring, as the question is to find substring that's where you are getting wrong.\nFor example : let string = \"abcdef\"\nit's substrings: 'a' 'ab' 'abc' 'cde' 'abcde' ...\nit's subsequences : 'a' 'ab' 'ac' 'acf' 'abe' ..."
                    },
                    {
                        "username": "TheMystery28",
                        "content": "I've tried and failed enough times to allow myself to see the hints and come up with an optimal solution.\n\nHowever, I'd like to understand why my old code gives a \"time exceeded\" error for \"aacabdkacaa\" when I have made sure to skip the calculation that can be skipped to avoid wasting time.\n\nCould someone please enlighten me?\n\n ```\n#include <algorithm>\n#include <iostream>\n#include <string>\n#include <string_view>\n#include <unordered_map>\n#include <set>\n#include <functional>\n#include <list>\n#include <iterator>\n#include <memory>\n\n\nclass Solution {\n\n    private:\n\n        std::unordered_map<char, std::set<int>> vOfList{};\n\n        int numberOfDifferentLetters{0};\n        int numberOfDifferentLettersBeingMoreThanOne{0};\n        std::vector<char> allOfTheDifferentLetters{};\n\n    public:\n        void itLoop2(std::set<int>::iterator& auto_pLeftItPos,\n                     std::set<int>::iterator& auto_pRightItPos,\n                     int pLeft, int pRight,\n                     std::string& palindromic, const std::string_view& s,\n                     bool trueToStopTheSpetialLoopToLoop){\n                        \n                    if (abs(*auto_pLeftItPos-*auto_pRightItPos)+1<=palindromic.length()) return;\n                    if(s[pLeft] == s[pRight]){\n\n                        if (pLeft==pRight||abs(pLeft - pRight)==1){\n                            palindromic=s.substr(*auto_pLeftItPos,abs(*auto_pLeftItPos-*auto_pRightItPos)+1);\n                        }\n                        else{\n\n\n                        itLoop2(auto_pLeftItPos, auto_pRightItPos,\n                                pLeft+1, pRight-1,palindromic, \n                                s,trueToStopTheSpetialLoopToLoop);}\n                    }\n                    else if (trueToStopTheSpetialLoopToLoop==false){\n                        trueToStopTheSpetialLoopToLoop = true;\n                    \n                        int x{std::abs(static_cast<int>(std::distance(auto_pLeftItPos,auto_pRightItPos)))};\n\n\n                        int c{0};\n\n                        for (int n{x};n>0;--n){\n                            //remainder that auto_pLeftItPos/auto_pRightItPos are in reverse for their iterator\n\n                            if (n==x) {++c;continue;} //If not we wouldn't be here in the first place\n\n\n\n                            int z{n};\n\n                            auto auto_pLeftItPosEdit{std::prev(auto_pLeftItPos,c)};\n\n                            itLoop2(auto_pLeftItPosEdit, auto_pRightItPos,\n                                *auto_pLeftItPosEdit, pRight,\n                                palindromic, \n                                s,trueToStopTheSpetialLoopToLoop);\n\n                            auto auto_pRightItPosEdit{auto_pRightItPos};\n\n                            while(auto_pLeftItPosEdit!=auto_pLeftItPos){\n                                \n                                auto_pLeftItPosEdit = std::next(auto_pLeftItPosEdit,1);\n                                auto_pRightItPosEdit = std::next(auto_pRightItPosEdit, 1);\n\n                                if (abs(*auto_pLeftItPos-*auto_pRightItPos)+1<=palindromic.length()) continue;\n\n                                itLoop2(auto_pLeftItPosEdit, auto_pRightItPosEdit,\n                                *auto_pLeftItPosEdit, *auto_pRightItPosEdit,\n                                palindromic, \n                                s,trueToStopTheSpetialLoopToLoop);\n\n                            }\n\n                            ++c;\n                        }\n\n                    }\n                    else return;\n\n        }\n\n        void itLoop(std::unordered_map<char, std::set<int>>::iterator& itBegin,\n                    std::string& palindromic, const std::string_view& s){\n                    \n\n                bool trueToStopTheSpetialLoopToLoop{false};\n\n            \n                auto *ptr {&((itBegin->second))};\n             \n                std::set<int>::iterator setEnd {ptr->begin()};\n\n\n                std::set<int>::iterator setBegin {ptr->end()};\n\n                std::advance(setBegin, -1);\n                //end() give the iterator AFTER the last element of the container\n\n            int pLeft{*setEnd};\n\n            int pRight{*setBegin};\n\n            if (abs(pLeft-pRight)+1<=palindromic.length()) return;\n\n\n            itLoop2(setEnd, setBegin, pLeft, pRight, palindromic, s, trueToStopTheSpetialLoopToLoop);\n\n\n        }\n\n        std::string longestPalindrome(const std::string_view& s) {\n\n            if (s.length()==0){\n                return \"\";\n            }\n            \n            std::vector<bool> everythingUsed (s.length(), false);\n\n            auto finised{[&]() -> bool {return (std::all_of(everythingUsed.begin(), everythingUsed.end(), [&](bool v) { return v; }));}};\n                \n            for (int x{0}; x<s.length()&&!finised();++x){\n\n\n                        if (everythingUsed[x]==false){\n                            everythingUsed[x]=true;\n\n                            ++numberOfDifferentLetters;\n                            allOfTheDifferentLetters.push_back(s[x]);\n\n\n                            for (int y{x+1};y<s.length()&&!finised();++y){\n                                if (everythingUsed[y]==true) continue;\n\n                                else {\n                                    if (s[x]==s[y]){\n                                        everythingUsed[y]=true;\n                                        vOfList[s[x]].insert({x,y});\n                                        ++numberOfDifferentLettersBeingMoreThanOne;\n                                    }\n                                }\n                            }\n                        }\n                        else continue;\n                    }\n\n            if (numberOfDifferentLettersBeingMoreThanOne==0) {\n                std::string str_ch {s[0]};\n                return str_ch;\n            };\n\n            std::unordered_map<char, std::set<int>>::iterator itBegin {vOfList.begin()};\n        \n\n            \n            std::string palindromic{};\n\n            while(itBegin != vOfList.end()){\n            \n                itLoop(itBegin, palindromic, s );\n                ++itBegin;\n            \n                }\n            \n            return palindromic;\n    \n    }\n};\n```\n"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "shri1403",
                        "content": "hi i was trying to solve this using the concepts of longest common substring and longest palindromic substring,\nhowver it doesnt work for the cases like aadabcadaa. this gives adaa as the ans and not ada. please help me with this\nthe following is my code:\n  string lcsub(string s , string s2){\n        int n=s.size();\n        int m=s2.size();\n         \n         vector<vector<int>> dp(n+1,vector<int>(m+1,0));\n         for(int i=0 ; i<=n;i++){\n             dp[i][0]=0;\n         }\n         for(int j=0; j<=m; j++){\n             dp[0][j]=0;\n         }\n        int maxi=0; int row=0; int col=0;\n         for(int i=1;i<=n;i++){\n             for(int j=1; j<=m ;j++){\n                 if(s[i-1]==s2[j-1]){\n                     dp[i][j]=1+dp[i-1][j-1];\n                     if(dp[i][j]>maxi){\n                         maxi=dp[i][j];\n                         row=i;\n                         col=j;\n                     }\n\n                    } \n                else\n                dp[i][j]=0; // if the continuity is broken then there is no LCS'\n                    \n             }\n         }\n\n        \n         //maxi is the length of the longest commmon palindromic substring\n         \n         //we also have the row and col at which maxi element is found;\n         string ans=\"\";\n         int len=maxi;\n\n\n         while((row>0&&col>0) && len>0){ //added this condition of len>0 beacsyein the second test case bbc print horha tha and this was because humara len=2 ka lcsubstring h par abhi tak row ya col 0 nhi hua tha toh islioye c bhi append hogya\n         //toh matlab yeh h ki jaha tak len h utna hi string me daalo\n               ans+=s[row-1];\n               row--;\n               col--;\n               len--;\n\n         }\n       cout<<maxi;\n        \n         return ans;\n\n\n    }\n    string longestPalindrome(string s) {\n        string s2=s;\n        reverse(s.begin(),s.end());\n        return lcsub(s2,s);\n    }"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    }
                ]
            },
            {
                "id": 1971179,
                "content": [
                    {
                        "username": "aylahjomri",
                        "content": "why does it say 141/141 testcases passed but says Time Limit Exceeded and the last executed input is empty ?"
                    },
                    {
                        "username": "CvamReborn_C2R",
                        "content": "Wrong Question some test cases are not right"
                    },
                    {
                        "username": "ak_3101",
                        "content": "okay so is it absolutely normal to get an intuition of writing code in tabular form or everybody first write recursion, and then top down/ bottom up"
                    },
                    {
                        "username": "jfonseca32",
                        "content": "There is something wrong with this question. I made and ran the code in Python and for every test case LeetCode says the code failed on, it works when I run it in Python."
                    },
                    {
                        "username": "timewaster69",
                        "content": "I think the test case s= (nothing) should be removed. It only causes errors and the constraints specifically state that there's at least one character to work with, and that there's specifically alphanumericals to deal with."
                    },
                    {
                        "username": "kevinbiju",
                        "content": "how do we learn to optimize brute force approach\\n"
                    },
                    {
                        "username": "espinosarennieljun",
                        "content": "To solve this you only need to mind two things. \none, Palindrome can't have with more than one even number of character duplicate.\ntwo, all single character should be ignore you only need to add one single character if the result total number is odd. example the total none single character of string is 6 and you can place single character on the middle of the string so it become 7."
                    },
                    {
                        "username": "muraripavansai22",
                        "content": "\"aacabdkacaa\"\\n\\nThis is my output : \"aacakacaa\"\\ngiven this should be expected : \"aca\"\\n\\nThere is some error with this test case\\ncorrect me if im wrong."
                    },
                    {
                        "username": "Ab__23",
                        "content": "\"aacakacaa\" is a subsequence of input string not it's substring, as the question is to find substring that's where you are getting wrong.\nFor example : let string = \"abcdef\"\nit's substrings: 'a' 'ab' 'abc' 'cde' 'abcde' ...\nit's subsequences : 'a' 'ab' 'ac' 'acf' 'abe' ..."
                    },
                    {
                        "username": "TheMystery28",
                        "content": "I've tried and failed enough times to allow myself to see the hints and come up with an optimal solution.\n\nHowever, I'd like to understand why my old code gives a \"time exceeded\" error for \"aacabdkacaa\" when I have made sure to skip the calculation that can be skipped to avoid wasting time.\n\nCould someone please enlighten me?\n\n ```\n#include <algorithm>\n#include <iostream>\n#include <string>\n#include <string_view>\n#include <unordered_map>\n#include <set>\n#include <functional>\n#include <list>\n#include <iterator>\n#include <memory>\n\n\nclass Solution {\n\n    private:\n\n        std::unordered_map<char, std::set<int>> vOfList{};\n\n        int numberOfDifferentLetters{0};\n        int numberOfDifferentLettersBeingMoreThanOne{0};\n        std::vector<char> allOfTheDifferentLetters{};\n\n    public:\n        void itLoop2(std::set<int>::iterator& auto_pLeftItPos,\n                     std::set<int>::iterator& auto_pRightItPos,\n                     int pLeft, int pRight,\n                     std::string& palindromic, const std::string_view& s,\n                     bool trueToStopTheSpetialLoopToLoop){\n                        \n                    if (abs(*auto_pLeftItPos-*auto_pRightItPos)+1<=palindromic.length()) return;\n                    if(s[pLeft] == s[pRight]){\n\n                        if (pLeft==pRight||abs(pLeft - pRight)==1){\n                            palindromic=s.substr(*auto_pLeftItPos,abs(*auto_pLeftItPos-*auto_pRightItPos)+1);\n                        }\n                        else{\n\n\n                        itLoop2(auto_pLeftItPos, auto_pRightItPos,\n                                pLeft+1, pRight-1,palindromic, \n                                s,trueToStopTheSpetialLoopToLoop);}\n                    }\n                    else if (trueToStopTheSpetialLoopToLoop==false){\n                        trueToStopTheSpetialLoopToLoop = true;\n                    \n                        int x{std::abs(static_cast<int>(std::distance(auto_pLeftItPos,auto_pRightItPos)))};\n\n\n                        int c{0};\n\n                        for (int n{x};n>0;--n){\n                            //remainder that auto_pLeftItPos/auto_pRightItPos are in reverse for their iterator\n\n                            if (n==x) {++c;continue;} //If not we wouldn't be here in the first place\n\n\n\n                            int z{n};\n\n                            auto auto_pLeftItPosEdit{std::prev(auto_pLeftItPos,c)};\n\n                            itLoop2(auto_pLeftItPosEdit, auto_pRightItPos,\n                                *auto_pLeftItPosEdit, pRight,\n                                palindromic, \n                                s,trueToStopTheSpetialLoopToLoop);\n\n                            auto auto_pRightItPosEdit{auto_pRightItPos};\n\n                            while(auto_pLeftItPosEdit!=auto_pLeftItPos){\n                                \n                                auto_pLeftItPosEdit = std::next(auto_pLeftItPosEdit,1);\n                                auto_pRightItPosEdit = std::next(auto_pRightItPosEdit, 1);\n\n                                if (abs(*auto_pLeftItPos-*auto_pRightItPos)+1<=palindromic.length()) continue;\n\n                                itLoop2(auto_pLeftItPosEdit, auto_pRightItPosEdit,\n                                *auto_pLeftItPosEdit, *auto_pRightItPosEdit,\n                                palindromic, \n                                s,trueToStopTheSpetialLoopToLoop);\n\n                            }\n\n                            ++c;\n                        }\n\n                    }\n                    else return;\n\n        }\n\n        void itLoop(std::unordered_map<char, std::set<int>>::iterator& itBegin,\n                    std::string& palindromic, const std::string_view& s){\n                    \n\n                bool trueToStopTheSpetialLoopToLoop{false};\n\n            \n                auto *ptr {&((itBegin->second))};\n             \n                std::set<int>::iterator setEnd {ptr->begin()};\n\n\n                std::set<int>::iterator setBegin {ptr->end()};\n\n                std::advance(setBegin, -1);\n                //end() give the iterator AFTER the last element of the container\n\n            int pLeft{*setEnd};\n\n            int pRight{*setBegin};\n\n            if (abs(pLeft-pRight)+1<=palindromic.length()) return;\n\n\n            itLoop2(setEnd, setBegin, pLeft, pRight, palindromic, s, trueToStopTheSpetialLoopToLoop);\n\n\n        }\n\n        std::string longestPalindrome(const std::string_view& s) {\n\n            if (s.length()==0){\n                return \"\";\n            }\n            \n            std::vector<bool> everythingUsed (s.length(), false);\n\n            auto finised{[&]() -> bool {return (std::all_of(everythingUsed.begin(), everythingUsed.end(), [&](bool v) { return v; }));}};\n                \n            for (int x{0}; x<s.length()&&!finised();++x){\n\n\n                        if (everythingUsed[x]==false){\n                            everythingUsed[x]=true;\n\n                            ++numberOfDifferentLetters;\n                            allOfTheDifferentLetters.push_back(s[x]);\n\n\n                            for (int y{x+1};y<s.length()&&!finised();++y){\n                                if (everythingUsed[y]==true) continue;\n\n                                else {\n                                    if (s[x]==s[y]){\n                                        everythingUsed[y]=true;\n                                        vOfList[s[x]].insert({x,y});\n                                        ++numberOfDifferentLettersBeingMoreThanOne;\n                                    }\n                                }\n                            }\n                        }\n                        else continue;\n                    }\n\n            if (numberOfDifferentLettersBeingMoreThanOne==0) {\n                std::string str_ch {s[0]};\n                return str_ch;\n            };\n\n            std::unordered_map<char, std::set<int>>::iterator itBegin {vOfList.begin()};\n        \n\n            \n            std::string palindromic{};\n\n            while(itBegin != vOfList.end()){\n            \n                itLoop(itBegin, palindromic, s );\n                ++itBegin;\n            \n                }\n            \n            return palindromic;\n    \n    }\n};\n```\n"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "shri1403",
                        "content": "hi i was trying to solve this using the concepts of longest common substring and longest palindromic substring,\nhowver it doesnt work for the cases like aadabcadaa. this gives adaa as the ans and not ada. please help me with this\nthe following is my code:\n  string lcsub(string s , string s2){\n        int n=s.size();\n        int m=s2.size();\n         \n         vector<vector<int>> dp(n+1,vector<int>(m+1,0));\n         for(int i=0 ; i<=n;i++){\n             dp[i][0]=0;\n         }\n         for(int j=0; j<=m; j++){\n             dp[0][j]=0;\n         }\n        int maxi=0; int row=0; int col=0;\n         for(int i=1;i<=n;i++){\n             for(int j=1; j<=m ;j++){\n                 if(s[i-1]==s2[j-1]){\n                     dp[i][j]=1+dp[i-1][j-1];\n                     if(dp[i][j]>maxi){\n                         maxi=dp[i][j];\n                         row=i;\n                         col=j;\n                     }\n\n                    } \n                else\n                dp[i][j]=0; // if the continuity is broken then there is no LCS'\n                    \n             }\n         }\n\n        \n         //maxi is the length of the longest commmon palindromic substring\n         \n         //we also have the row and col at which maxi element is found;\n         string ans=\"\";\n         int len=maxi;\n\n\n         while((row>0&&col>0) && len>0){ //added this condition of len>0 beacsyein the second test case bbc print horha tha and this was because humara len=2 ka lcsubstring h par abhi tak row ya col 0 nhi hua tha toh islioye c bhi append hogya\n         //toh matlab yeh h ki jaha tak len h utna hi string me daalo\n               ans+=s[row-1];\n               row--;\n               col--;\n               len--;\n\n         }\n       cout<<maxi;\n        \n         return ans;\n\n\n    }\n    string longestPalindrome(string s) {\n        string s2=s;\n        reverse(s.begin(),s.end());\n        return lcsub(s2,s);\n    }"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    }
                ]
            },
            {
                "id": 1964122,
                "content": [
                    {
                        "username": "aylahjomri",
                        "content": "why does it say 141/141 testcases passed but says Time Limit Exceeded and the last executed input is empty ?"
                    },
                    {
                        "username": "CvamReborn_C2R",
                        "content": "Wrong Question some test cases are not right"
                    },
                    {
                        "username": "ak_3101",
                        "content": "okay so is it absolutely normal to get an intuition of writing code in tabular form or everybody first write recursion, and then top down/ bottom up"
                    },
                    {
                        "username": "jfonseca32",
                        "content": "There is something wrong with this question. I made and ran the code in Python and for every test case LeetCode says the code failed on, it works when I run it in Python."
                    },
                    {
                        "username": "timewaster69",
                        "content": "I think the test case s= (nothing) should be removed. It only causes errors and the constraints specifically state that there's at least one character to work with, and that there's specifically alphanumericals to deal with."
                    },
                    {
                        "username": "kevinbiju",
                        "content": "how do we learn to optimize brute force approach\\n"
                    },
                    {
                        "username": "espinosarennieljun",
                        "content": "To solve this you only need to mind two things. \none, Palindrome can't have with more than one even number of character duplicate.\ntwo, all single character should be ignore you only need to add one single character if the result total number is odd. example the total none single character of string is 6 and you can place single character on the middle of the string so it become 7."
                    },
                    {
                        "username": "muraripavansai22",
                        "content": "\"aacabdkacaa\"\\n\\nThis is my output : \"aacakacaa\"\\ngiven this should be expected : \"aca\"\\n\\nThere is some error with this test case\\ncorrect me if im wrong."
                    },
                    {
                        "username": "Ab__23",
                        "content": "\"aacakacaa\" is a subsequence of input string not it's substring, as the question is to find substring that's where you are getting wrong.\nFor example : let string = \"abcdef\"\nit's substrings: 'a' 'ab' 'abc' 'cde' 'abcde' ...\nit's subsequences : 'a' 'ab' 'ac' 'acf' 'abe' ..."
                    },
                    {
                        "username": "TheMystery28",
                        "content": "I've tried and failed enough times to allow myself to see the hints and come up with an optimal solution.\n\nHowever, I'd like to understand why my old code gives a \"time exceeded\" error for \"aacabdkacaa\" when I have made sure to skip the calculation that can be skipped to avoid wasting time.\n\nCould someone please enlighten me?\n\n ```\n#include <algorithm>\n#include <iostream>\n#include <string>\n#include <string_view>\n#include <unordered_map>\n#include <set>\n#include <functional>\n#include <list>\n#include <iterator>\n#include <memory>\n\n\nclass Solution {\n\n    private:\n\n        std::unordered_map<char, std::set<int>> vOfList{};\n\n        int numberOfDifferentLetters{0};\n        int numberOfDifferentLettersBeingMoreThanOne{0};\n        std::vector<char> allOfTheDifferentLetters{};\n\n    public:\n        void itLoop2(std::set<int>::iterator& auto_pLeftItPos,\n                     std::set<int>::iterator& auto_pRightItPos,\n                     int pLeft, int pRight,\n                     std::string& palindromic, const std::string_view& s,\n                     bool trueToStopTheSpetialLoopToLoop){\n                        \n                    if (abs(*auto_pLeftItPos-*auto_pRightItPos)+1<=palindromic.length()) return;\n                    if(s[pLeft] == s[pRight]){\n\n                        if (pLeft==pRight||abs(pLeft - pRight)==1){\n                            palindromic=s.substr(*auto_pLeftItPos,abs(*auto_pLeftItPos-*auto_pRightItPos)+1);\n                        }\n                        else{\n\n\n                        itLoop2(auto_pLeftItPos, auto_pRightItPos,\n                                pLeft+1, pRight-1,palindromic, \n                                s,trueToStopTheSpetialLoopToLoop);}\n                    }\n                    else if (trueToStopTheSpetialLoopToLoop==false){\n                        trueToStopTheSpetialLoopToLoop = true;\n                    \n                        int x{std::abs(static_cast<int>(std::distance(auto_pLeftItPos,auto_pRightItPos)))};\n\n\n                        int c{0};\n\n                        for (int n{x};n>0;--n){\n                            //remainder that auto_pLeftItPos/auto_pRightItPos are in reverse for their iterator\n\n                            if (n==x) {++c;continue;} //If not we wouldn't be here in the first place\n\n\n\n                            int z{n};\n\n                            auto auto_pLeftItPosEdit{std::prev(auto_pLeftItPos,c)};\n\n                            itLoop2(auto_pLeftItPosEdit, auto_pRightItPos,\n                                *auto_pLeftItPosEdit, pRight,\n                                palindromic, \n                                s,trueToStopTheSpetialLoopToLoop);\n\n                            auto auto_pRightItPosEdit{auto_pRightItPos};\n\n                            while(auto_pLeftItPosEdit!=auto_pLeftItPos){\n                                \n                                auto_pLeftItPosEdit = std::next(auto_pLeftItPosEdit,1);\n                                auto_pRightItPosEdit = std::next(auto_pRightItPosEdit, 1);\n\n                                if (abs(*auto_pLeftItPos-*auto_pRightItPos)+1<=palindromic.length()) continue;\n\n                                itLoop2(auto_pLeftItPosEdit, auto_pRightItPosEdit,\n                                *auto_pLeftItPosEdit, *auto_pRightItPosEdit,\n                                palindromic, \n                                s,trueToStopTheSpetialLoopToLoop);\n\n                            }\n\n                            ++c;\n                        }\n\n                    }\n                    else return;\n\n        }\n\n        void itLoop(std::unordered_map<char, std::set<int>>::iterator& itBegin,\n                    std::string& palindromic, const std::string_view& s){\n                    \n\n                bool trueToStopTheSpetialLoopToLoop{false};\n\n            \n                auto *ptr {&((itBegin->second))};\n             \n                std::set<int>::iterator setEnd {ptr->begin()};\n\n\n                std::set<int>::iterator setBegin {ptr->end()};\n\n                std::advance(setBegin, -1);\n                //end() give the iterator AFTER the last element of the container\n\n            int pLeft{*setEnd};\n\n            int pRight{*setBegin};\n\n            if (abs(pLeft-pRight)+1<=palindromic.length()) return;\n\n\n            itLoop2(setEnd, setBegin, pLeft, pRight, palindromic, s, trueToStopTheSpetialLoopToLoop);\n\n\n        }\n\n        std::string longestPalindrome(const std::string_view& s) {\n\n            if (s.length()==0){\n                return \"\";\n            }\n            \n            std::vector<bool> everythingUsed (s.length(), false);\n\n            auto finised{[&]() -> bool {return (std::all_of(everythingUsed.begin(), everythingUsed.end(), [&](bool v) { return v; }));}};\n                \n            for (int x{0}; x<s.length()&&!finised();++x){\n\n\n                        if (everythingUsed[x]==false){\n                            everythingUsed[x]=true;\n\n                            ++numberOfDifferentLetters;\n                            allOfTheDifferentLetters.push_back(s[x]);\n\n\n                            for (int y{x+1};y<s.length()&&!finised();++y){\n                                if (everythingUsed[y]==true) continue;\n\n                                else {\n                                    if (s[x]==s[y]){\n                                        everythingUsed[y]=true;\n                                        vOfList[s[x]].insert({x,y});\n                                        ++numberOfDifferentLettersBeingMoreThanOne;\n                                    }\n                                }\n                            }\n                        }\n                        else continue;\n                    }\n\n            if (numberOfDifferentLettersBeingMoreThanOne==0) {\n                std::string str_ch {s[0]};\n                return str_ch;\n            };\n\n            std::unordered_map<char, std::set<int>>::iterator itBegin {vOfList.begin()};\n        \n\n            \n            std::string palindromic{};\n\n            while(itBegin != vOfList.end()){\n            \n                itLoop(itBegin, palindromic, s );\n                ++itBegin;\n            \n                }\n            \n            return palindromic;\n    \n    }\n};\n```\n"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "shri1403",
                        "content": "hi i was trying to solve this using the concepts of longest common substring and longest palindromic substring,\nhowver it doesnt work for the cases like aadabcadaa. this gives adaa as the ans and not ada. please help me with this\nthe following is my code:\n  string lcsub(string s , string s2){\n        int n=s.size();\n        int m=s2.size();\n         \n         vector<vector<int>> dp(n+1,vector<int>(m+1,0));\n         for(int i=0 ; i<=n;i++){\n             dp[i][0]=0;\n         }\n         for(int j=0; j<=m; j++){\n             dp[0][j]=0;\n         }\n        int maxi=0; int row=0; int col=0;\n         for(int i=1;i<=n;i++){\n             for(int j=1; j<=m ;j++){\n                 if(s[i-1]==s2[j-1]){\n                     dp[i][j]=1+dp[i-1][j-1];\n                     if(dp[i][j]>maxi){\n                         maxi=dp[i][j];\n                         row=i;\n                         col=j;\n                     }\n\n                    } \n                else\n                dp[i][j]=0; // if the continuity is broken then there is no LCS'\n                    \n             }\n         }\n\n        \n         //maxi is the length of the longest commmon palindromic substring\n         \n         //we also have the row and col at which maxi element is found;\n         string ans=\"\";\n         int len=maxi;\n\n\n         while((row>0&&col>0) && len>0){ //added this condition of len>0 beacsyein the second test case bbc print horha tha and this was because humara len=2 ka lcsubstring h par abhi tak row ya col 0 nhi hua tha toh islioye c bhi append hogya\n         //toh matlab yeh h ki jaha tak len h utna hi string me daalo\n               ans+=s[row-1];\n               row--;\n               col--;\n               len--;\n\n         }\n       cout<<maxi;\n        \n         return ans;\n\n\n    }\n    string longestPalindrome(string s) {\n        string s2=s;\n        reverse(s.begin(),s.end());\n        return lcsub(s2,s);\n    }"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    }
                ]
            },
            {
                "id": 1963368,
                "content": [
                    {
                        "username": "aylahjomri",
                        "content": "why does it say 141/141 testcases passed but says Time Limit Exceeded and the last executed input is empty ?"
                    },
                    {
                        "username": "CvamReborn_C2R",
                        "content": "Wrong Question some test cases are not right"
                    },
                    {
                        "username": "ak_3101",
                        "content": "okay so is it absolutely normal to get an intuition of writing code in tabular form or everybody first write recursion, and then top down/ bottom up"
                    },
                    {
                        "username": "jfonseca32",
                        "content": "There is something wrong with this question. I made and ran the code in Python and for every test case LeetCode says the code failed on, it works when I run it in Python."
                    },
                    {
                        "username": "timewaster69",
                        "content": "I think the test case s= (nothing) should be removed. It only causes errors and the constraints specifically state that there's at least one character to work with, and that there's specifically alphanumericals to deal with."
                    },
                    {
                        "username": "kevinbiju",
                        "content": "how do we learn to optimize brute force approach\\n"
                    },
                    {
                        "username": "espinosarennieljun",
                        "content": "To solve this you only need to mind two things. \none, Palindrome can't have with more than one even number of character duplicate.\ntwo, all single character should be ignore you only need to add one single character if the result total number is odd. example the total none single character of string is 6 and you can place single character on the middle of the string so it become 7."
                    },
                    {
                        "username": "muraripavansai22",
                        "content": "\"aacabdkacaa\"\\n\\nThis is my output : \"aacakacaa\"\\ngiven this should be expected : \"aca\"\\n\\nThere is some error with this test case\\ncorrect me if im wrong."
                    },
                    {
                        "username": "Ab__23",
                        "content": "\"aacakacaa\" is a subsequence of input string not it's substring, as the question is to find substring that's where you are getting wrong.\nFor example : let string = \"abcdef\"\nit's substrings: 'a' 'ab' 'abc' 'cde' 'abcde' ...\nit's subsequences : 'a' 'ab' 'ac' 'acf' 'abe' ..."
                    },
                    {
                        "username": "TheMystery28",
                        "content": "I've tried and failed enough times to allow myself to see the hints and come up with an optimal solution.\n\nHowever, I'd like to understand why my old code gives a \"time exceeded\" error for \"aacabdkacaa\" when I have made sure to skip the calculation that can be skipped to avoid wasting time.\n\nCould someone please enlighten me?\n\n ```\n#include <algorithm>\n#include <iostream>\n#include <string>\n#include <string_view>\n#include <unordered_map>\n#include <set>\n#include <functional>\n#include <list>\n#include <iterator>\n#include <memory>\n\n\nclass Solution {\n\n    private:\n\n        std::unordered_map<char, std::set<int>> vOfList{};\n\n        int numberOfDifferentLetters{0};\n        int numberOfDifferentLettersBeingMoreThanOne{0};\n        std::vector<char> allOfTheDifferentLetters{};\n\n    public:\n        void itLoop2(std::set<int>::iterator& auto_pLeftItPos,\n                     std::set<int>::iterator& auto_pRightItPos,\n                     int pLeft, int pRight,\n                     std::string& palindromic, const std::string_view& s,\n                     bool trueToStopTheSpetialLoopToLoop){\n                        \n                    if (abs(*auto_pLeftItPos-*auto_pRightItPos)+1<=palindromic.length()) return;\n                    if(s[pLeft] == s[pRight]){\n\n                        if (pLeft==pRight||abs(pLeft - pRight)==1){\n                            palindromic=s.substr(*auto_pLeftItPos,abs(*auto_pLeftItPos-*auto_pRightItPos)+1);\n                        }\n                        else{\n\n\n                        itLoop2(auto_pLeftItPos, auto_pRightItPos,\n                                pLeft+1, pRight-1,palindromic, \n                                s,trueToStopTheSpetialLoopToLoop);}\n                    }\n                    else if (trueToStopTheSpetialLoopToLoop==false){\n                        trueToStopTheSpetialLoopToLoop = true;\n                    \n                        int x{std::abs(static_cast<int>(std::distance(auto_pLeftItPos,auto_pRightItPos)))};\n\n\n                        int c{0};\n\n                        for (int n{x};n>0;--n){\n                            //remainder that auto_pLeftItPos/auto_pRightItPos are in reverse for their iterator\n\n                            if (n==x) {++c;continue;} //If not we wouldn't be here in the first place\n\n\n\n                            int z{n};\n\n                            auto auto_pLeftItPosEdit{std::prev(auto_pLeftItPos,c)};\n\n                            itLoop2(auto_pLeftItPosEdit, auto_pRightItPos,\n                                *auto_pLeftItPosEdit, pRight,\n                                palindromic, \n                                s,trueToStopTheSpetialLoopToLoop);\n\n                            auto auto_pRightItPosEdit{auto_pRightItPos};\n\n                            while(auto_pLeftItPosEdit!=auto_pLeftItPos){\n                                \n                                auto_pLeftItPosEdit = std::next(auto_pLeftItPosEdit,1);\n                                auto_pRightItPosEdit = std::next(auto_pRightItPosEdit, 1);\n\n                                if (abs(*auto_pLeftItPos-*auto_pRightItPos)+1<=palindromic.length()) continue;\n\n                                itLoop2(auto_pLeftItPosEdit, auto_pRightItPosEdit,\n                                *auto_pLeftItPosEdit, *auto_pRightItPosEdit,\n                                palindromic, \n                                s,trueToStopTheSpetialLoopToLoop);\n\n                            }\n\n                            ++c;\n                        }\n\n                    }\n                    else return;\n\n        }\n\n        void itLoop(std::unordered_map<char, std::set<int>>::iterator& itBegin,\n                    std::string& palindromic, const std::string_view& s){\n                    \n\n                bool trueToStopTheSpetialLoopToLoop{false};\n\n            \n                auto *ptr {&((itBegin->second))};\n             \n                std::set<int>::iterator setEnd {ptr->begin()};\n\n\n                std::set<int>::iterator setBegin {ptr->end()};\n\n                std::advance(setBegin, -1);\n                //end() give the iterator AFTER the last element of the container\n\n            int pLeft{*setEnd};\n\n            int pRight{*setBegin};\n\n            if (abs(pLeft-pRight)+1<=palindromic.length()) return;\n\n\n            itLoop2(setEnd, setBegin, pLeft, pRight, palindromic, s, trueToStopTheSpetialLoopToLoop);\n\n\n        }\n\n        std::string longestPalindrome(const std::string_view& s) {\n\n            if (s.length()==0){\n                return \"\";\n            }\n            \n            std::vector<bool> everythingUsed (s.length(), false);\n\n            auto finised{[&]() -> bool {return (std::all_of(everythingUsed.begin(), everythingUsed.end(), [&](bool v) { return v; }));}};\n                \n            for (int x{0}; x<s.length()&&!finised();++x){\n\n\n                        if (everythingUsed[x]==false){\n                            everythingUsed[x]=true;\n\n                            ++numberOfDifferentLetters;\n                            allOfTheDifferentLetters.push_back(s[x]);\n\n\n                            for (int y{x+1};y<s.length()&&!finised();++y){\n                                if (everythingUsed[y]==true) continue;\n\n                                else {\n                                    if (s[x]==s[y]){\n                                        everythingUsed[y]=true;\n                                        vOfList[s[x]].insert({x,y});\n                                        ++numberOfDifferentLettersBeingMoreThanOne;\n                                    }\n                                }\n                            }\n                        }\n                        else continue;\n                    }\n\n            if (numberOfDifferentLettersBeingMoreThanOne==0) {\n                std::string str_ch {s[0]};\n                return str_ch;\n            };\n\n            std::unordered_map<char, std::set<int>>::iterator itBegin {vOfList.begin()};\n        \n\n            \n            std::string palindromic{};\n\n            while(itBegin != vOfList.end()){\n            \n                itLoop(itBegin, palindromic, s );\n                ++itBegin;\n            \n                }\n            \n            return palindromic;\n    \n    }\n};\n```\n"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "shri1403",
                        "content": "hi i was trying to solve this using the concepts of longest common substring and longest palindromic substring,\nhowver it doesnt work for the cases like aadabcadaa. this gives adaa as the ans and not ada. please help me with this\nthe following is my code:\n  string lcsub(string s , string s2){\n        int n=s.size();\n        int m=s2.size();\n         \n         vector<vector<int>> dp(n+1,vector<int>(m+1,0));\n         for(int i=0 ; i<=n;i++){\n             dp[i][0]=0;\n         }\n         for(int j=0; j<=m; j++){\n             dp[0][j]=0;\n         }\n        int maxi=0; int row=0; int col=0;\n         for(int i=1;i<=n;i++){\n             for(int j=1; j<=m ;j++){\n                 if(s[i-1]==s2[j-1]){\n                     dp[i][j]=1+dp[i-1][j-1];\n                     if(dp[i][j]>maxi){\n                         maxi=dp[i][j];\n                         row=i;\n                         col=j;\n                     }\n\n                    } \n                else\n                dp[i][j]=0; // if the continuity is broken then there is no LCS'\n                    \n             }\n         }\n\n        \n         //maxi is the length of the longest commmon palindromic substring\n         \n         //we also have the row and col at which maxi element is found;\n         string ans=\"\";\n         int len=maxi;\n\n\n         while((row>0&&col>0) && len>0){ //added this condition of len>0 beacsyein the second test case bbc print horha tha and this was because humara len=2 ka lcsubstring h par abhi tak row ya col 0 nhi hua tha toh islioye c bhi append hogya\n         //toh matlab yeh h ki jaha tak len h utna hi string me daalo\n               ans+=s[row-1];\n               row--;\n               col--;\n               len--;\n\n         }\n       cout<<maxi;\n        \n         return ans;\n\n\n    }\n    string longestPalindrome(string s) {\n        string s2=s;\n        reverse(s.begin(),s.end());\n        return lcsub(s2,s);\n    }"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    }
                ]
            },
            {
                "id": 1959257,
                "content": [
                    {
                        "username": "Whitchurch",
                        "content": "I did a generic Dynamic Programming approach and hit a TLE.\nHas anyone done Memoization to cut down on redundancies, did that help avoid the TLE.\n\nI used a dictionary for memoization, it worked well. However , i don't know how to use it inside this LongestPalindrome function, without re-creating the dictionary over and over again. Is there a way to check if dictionary already exists and not re-create it.\n\nThanks"
                    },
                    {
                        "username": "Ishan1_1",
                        "content": "for the test case \"aacabdkacaa\" why the correct answer is \"aca\" and not \"aacakacaa\" isnt it the longest palindrome"
                    },
                    {
                        "username": "shuklaprakhar24",
                        "content": "Can we solve in o(n3) ?\\n"
                    },
                    {
                        "username": "nullskill",
                        "content": "I wonder what is the correct output should be for the input string \\'abc\\'? Shall it be \\'a\\', \\'b\\' or \\'c\\' ? Any of the three?"
                    },
                    {
                        "username": "Hritik__k",
                        "content": "Any of the three"
                    },
                    {
                        "username": "alvordar",
                        "content": "Anyone in Java getting 141/141 passed but it says Time Limit Exceeded for a blank input: s = .\\nIn other version I was getting an actual time limit exceeded and the given input but in this case it says all test passed but time limit exceeded.\\nAny idea?"
                    },
                    {
                        "username": "Hritik__k",
                        "content": "try passing the values by ref"
                    },
                    {
                        "username": "MaxiGalaxi",
                        "content": "I dont pass testcase 141, I can\\'t see any character in s"
                    },
                    {
                        "username": "anshh10",
                        "content": "Hi, why is this code not working?\\nclass Solution {\\npublic:\\n    string longestPalindrome(string s) \\n    {\\n        int left,right=0;\\n        int maxLen=1;\\n        string maxString=s.substr(0,1);\\n        for(int i=1;i<s.size();i++)\\n        {\\n            left=i;\\n            right=i;\\n            if(s[i]==s[i-1])\\n            {\\n                left--;\\n                while(left>=0 && right<=s.size()-1 && s[left]==s[right])\\n                {\\n                    if(right-left+1>=maxLen)\\n                    {\\n                        maxString=s.substr(left,right+1);\\n                        cout<<maxString<<endl;\\n                        maxLen=right-left+1;\\n                    }\\n                    left--;\\n                    right++;\\n                }\\n            }\\n            else\\n            {\\n                while(left>=0 && right<=s.size()-1 && s[left]==s[right])\\n                {\\n                    if(right-left+1>=maxLen)\\n                    {\\n                        maxString=s.substr(left,right);\\n                        cout<<maxString<<endl;\\n                        maxLen=right-left+1;\\n                    }\\n                    left--;\\n                    right++;\\n                }\\n            }\\n        }\\n        return maxString;\\n        \\n    }\\n};"
                    },
                    {
                        "username": "slucker",
                        "content": "I solved this problem for the first submit by brute-force and beat >60%.\\nJust try to think in every position you will a Palindromic, move left and right to get the Longest match.\\nWe only have two case for each: left=i-1, r=i+1 and left=i, right=i+1;\\nTotal is O(n^2) complexity, O(1) space.\\n"
                    },
                    {
                        "username": "kazangeorg",
                        "content": "Wrong Answer\n\n87 / 141 testcases passed\nInput\ns =\n\"aacabdkacaa\"\nUse Testcase\nOutput\n\"aaca\"\nExpected\n\"aca\"\n\n\nWhy???"
                    },
                    {
                        "username": "dav3th3t3chg33k",
                        "content": "easy problem to solve\\n"
                    }
                ]
            },
            {
                "id": 1955166,
                "content": [
                    {
                        "username": "Whitchurch",
                        "content": "I did a generic Dynamic Programming approach and hit a TLE.\nHas anyone done Memoization to cut down on redundancies, did that help avoid the TLE.\n\nI used a dictionary for memoization, it worked well. However , i don't know how to use it inside this LongestPalindrome function, without re-creating the dictionary over and over again. Is there a way to check if dictionary already exists and not re-create it.\n\nThanks"
                    },
                    {
                        "username": "Ishan1_1",
                        "content": "for the test case \"aacabdkacaa\" why the correct answer is \"aca\" and not \"aacakacaa\" isnt it the longest palindrome"
                    },
                    {
                        "username": "shuklaprakhar24",
                        "content": "Can we solve in o(n3) ?\\n"
                    },
                    {
                        "username": "nullskill",
                        "content": "I wonder what is the correct output should be for the input string \\'abc\\'? Shall it be \\'a\\', \\'b\\' or \\'c\\' ? Any of the three?"
                    },
                    {
                        "username": "Hritik__k",
                        "content": "Any of the three"
                    },
                    {
                        "username": "alvordar",
                        "content": "Anyone in Java getting 141/141 passed but it says Time Limit Exceeded for a blank input: s = .\\nIn other version I was getting an actual time limit exceeded and the given input but in this case it says all test passed but time limit exceeded.\\nAny idea?"
                    },
                    {
                        "username": "Hritik__k",
                        "content": "try passing the values by ref"
                    },
                    {
                        "username": "MaxiGalaxi",
                        "content": "I dont pass testcase 141, I can\\'t see any character in s"
                    },
                    {
                        "username": "anshh10",
                        "content": "Hi, why is this code not working?\\nclass Solution {\\npublic:\\n    string longestPalindrome(string s) \\n    {\\n        int left,right=0;\\n        int maxLen=1;\\n        string maxString=s.substr(0,1);\\n        for(int i=1;i<s.size();i++)\\n        {\\n            left=i;\\n            right=i;\\n            if(s[i]==s[i-1])\\n            {\\n                left--;\\n                while(left>=0 && right<=s.size()-1 && s[left]==s[right])\\n                {\\n                    if(right-left+1>=maxLen)\\n                    {\\n                        maxString=s.substr(left,right+1);\\n                        cout<<maxString<<endl;\\n                        maxLen=right-left+1;\\n                    }\\n                    left--;\\n                    right++;\\n                }\\n            }\\n            else\\n            {\\n                while(left>=0 && right<=s.size()-1 && s[left]==s[right])\\n                {\\n                    if(right-left+1>=maxLen)\\n                    {\\n                        maxString=s.substr(left,right);\\n                        cout<<maxString<<endl;\\n                        maxLen=right-left+1;\\n                    }\\n                    left--;\\n                    right++;\\n                }\\n            }\\n        }\\n        return maxString;\\n        \\n    }\\n};"
                    },
                    {
                        "username": "slucker",
                        "content": "I solved this problem for the first submit by brute-force and beat >60%.\\nJust try to think in every position you will a Palindromic, move left and right to get the Longest match.\\nWe only have two case for each: left=i-1, r=i+1 and left=i, right=i+1;\\nTotal is O(n^2) complexity, O(1) space.\\n"
                    },
                    {
                        "username": "kazangeorg",
                        "content": "Wrong Answer\n\n87 / 141 testcases passed\nInput\ns =\n\"aacabdkacaa\"\nUse Testcase\nOutput\n\"aaca\"\nExpected\n\"aca\"\n\n\nWhy???"
                    },
                    {
                        "username": "dav3th3t3chg33k",
                        "content": "easy problem to solve\\n"
                    }
                ]
            },
            {
                "id": 1946438,
                "content": [
                    {
                        "username": "Whitchurch",
                        "content": "I did a generic Dynamic Programming approach and hit a TLE.\nHas anyone done Memoization to cut down on redundancies, did that help avoid the TLE.\n\nI used a dictionary for memoization, it worked well. However , i don't know how to use it inside this LongestPalindrome function, without re-creating the dictionary over and over again. Is there a way to check if dictionary already exists and not re-create it.\n\nThanks"
                    },
                    {
                        "username": "Ishan1_1",
                        "content": "for the test case \"aacabdkacaa\" why the correct answer is \"aca\" and not \"aacakacaa\" isnt it the longest palindrome"
                    },
                    {
                        "username": "shuklaprakhar24",
                        "content": "Can we solve in o(n3) ?\\n"
                    },
                    {
                        "username": "nullskill",
                        "content": "I wonder what is the correct output should be for the input string \\'abc\\'? Shall it be \\'a\\', \\'b\\' or \\'c\\' ? Any of the three?"
                    },
                    {
                        "username": "Hritik__k",
                        "content": "Any of the three"
                    },
                    {
                        "username": "alvordar",
                        "content": "Anyone in Java getting 141/141 passed but it says Time Limit Exceeded for a blank input: s = .\\nIn other version I was getting an actual time limit exceeded and the given input but in this case it says all test passed but time limit exceeded.\\nAny idea?"
                    },
                    {
                        "username": "Hritik__k",
                        "content": "try passing the values by ref"
                    },
                    {
                        "username": "MaxiGalaxi",
                        "content": "I dont pass testcase 141, I can\\'t see any character in s"
                    },
                    {
                        "username": "anshh10",
                        "content": "Hi, why is this code not working?\\nclass Solution {\\npublic:\\n    string longestPalindrome(string s) \\n    {\\n        int left,right=0;\\n        int maxLen=1;\\n        string maxString=s.substr(0,1);\\n        for(int i=1;i<s.size();i++)\\n        {\\n            left=i;\\n            right=i;\\n            if(s[i]==s[i-1])\\n            {\\n                left--;\\n                while(left>=0 && right<=s.size()-1 && s[left]==s[right])\\n                {\\n                    if(right-left+1>=maxLen)\\n                    {\\n                        maxString=s.substr(left,right+1);\\n                        cout<<maxString<<endl;\\n                        maxLen=right-left+1;\\n                    }\\n                    left--;\\n                    right++;\\n                }\\n            }\\n            else\\n            {\\n                while(left>=0 && right<=s.size()-1 && s[left]==s[right])\\n                {\\n                    if(right-left+1>=maxLen)\\n                    {\\n                        maxString=s.substr(left,right);\\n                        cout<<maxString<<endl;\\n                        maxLen=right-left+1;\\n                    }\\n                    left--;\\n                    right++;\\n                }\\n            }\\n        }\\n        return maxString;\\n        \\n    }\\n};"
                    },
                    {
                        "username": "slucker",
                        "content": "I solved this problem for the first submit by brute-force and beat >60%.\\nJust try to think in every position you will a Palindromic, move left and right to get the Longest match.\\nWe only have two case for each: left=i-1, r=i+1 and left=i, right=i+1;\\nTotal is O(n^2) complexity, O(1) space.\\n"
                    },
                    {
                        "username": "kazangeorg",
                        "content": "Wrong Answer\n\n87 / 141 testcases passed\nInput\ns =\n\"aacabdkacaa\"\nUse Testcase\nOutput\n\"aaca\"\nExpected\n\"aca\"\n\n\nWhy???"
                    },
                    {
                        "username": "dav3th3t3chg33k",
                        "content": "easy problem to solve\\n"
                    }
                ]
            },
            {
                "id": 1942062,
                "content": [
                    {
                        "username": "Whitchurch",
                        "content": "I did a generic Dynamic Programming approach and hit a TLE.\nHas anyone done Memoization to cut down on redundancies, did that help avoid the TLE.\n\nI used a dictionary for memoization, it worked well. However , i don't know how to use it inside this LongestPalindrome function, without re-creating the dictionary over and over again. Is there a way to check if dictionary already exists and not re-create it.\n\nThanks"
                    },
                    {
                        "username": "Ishan1_1",
                        "content": "for the test case \"aacabdkacaa\" why the correct answer is \"aca\" and not \"aacakacaa\" isnt it the longest palindrome"
                    },
                    {
                        "username": "shuklaprakhar24",
                        "content": "Can we solve in o(n3) ?\\n"
                    },
                    {
                        "username": "nullskill",
                        "content": "I wonder what is the correct output should be for the input string \\'abc\\'? Shall it be \\'a\\', \\'b\\' or \\'c\\' ? Any of the three?"
                    },
                    {
                        "username": "Hritik__k",
                        "content": "Any of the three"
                    },
                    {
                        "username": "alvordar",
                        "content": "Anyone in Java getting 141/141 passed but it says Time Limit Exceeded for a blank input: s = .\\nIn other version I was getting an actual time limit exceeded and the given input but in this case it says all test passed but time limit exceeded.\\nAny idea?"
                    },
                    {
                        "username": "Hritik__k",
                        "content": "try passing the values by ref"
                    },
                    {
                        "username": "MaxiGalaxi",
                        "content": "I dont pass testcase 141, I can\\'t see any character in s"
                    },
                    {
                        "username": "anshh10",
                        "content": "Hi, why is this code not working?\\nclass Solution {\\npublic:\\n    string longestPalindrome(string s) \\n    {\\n        int left,right=0;\\n        int maxLen=1;\\n        string maxString=s.substr(0,1);\\n        for(int i=1;i<s.size();i++)\\n        {\\n            left=i;\\n            right=i;\\n            if(s[i]==s[i-1])\\n            {\\n                left--;\\n                while(left>=0 && right<=s.size()-1 && s[left]==s[right])\\n                {\\n                    if(right-left+1>=maxLen)\\n                    {\\n                        maxString=s.substr(left,right+1);\\n                        cout<<maxString<<endl;\\n                        maxLen=right-left+1;\\n                    }\\n                    left--;\\n                    right++;\\n                }\\n            }\\n            else\\n            {\\n                while(left>=0 && right<=s.size()-1 && s[left]==s[right])\\n                {\\n                    if(right-left+1>=maxLen)\\n                    {\\n                        maxString=s.substr(left,right);\\n                        cout<<maxString<<endl;\\n                        maxLen=right-left+1;\\n                    }\\n                    left--;\\n                    right++;\\n                }\\n            }\\n        }\\n        return maxString;\\n        \\n    }\\n};"
                    },
                    {
                        "username": "slucker",
                        "content": "I solved this problem for the first submit by brute-force and beat >60%.\\nJust try to think in every position you will a Palindromic, move left and right to get the Longest match.\\nWe only have two case for each: left=i-1, r=i+1 and left=i, right=i+1;\\nTotal is O(n^2) complexity, O(1) space.\\n"
                    },
                    {
                        "username": "kazangeorg",
                        "content": "Wrong Answer\n\n87 / 141 testcases passed\nInput\ns =\n\"aacabdkacaa\"\nUse Testcase\nOutput\n\"aaca\"\nExpected\n\"aca\"\n\n\nWhy???"
                    },
                    {
                        "username": "dav3th3t3chg33k",
                        "content": "easy problem to solve\\n"
                    }
                ]
            },
            {
                "id": 1941651,
                "content": [
                    {
                        "username": "Whitchurch",
                        "content": "I did a generic Dynamic Programming approach and hit a TLE.\nHas anyone done Memoization to cut down on redundancies, did that help avoid the TLE.\n\nI used a dictionary for memoization, it worked well. However , i don't know how to use it inside this LongestPalindrome function, without re-creating the dictionary over and over again. Is there a way to check if dictionary already exists and not re-create it.\n\nThanks"
                    },
                    {
                        "username": "Ishan1_1",
                        "content": "for the test case \"aacabdkacaa\" why the correct answer is \"aca\" and not \"aacakacaa\" isnt it the longest palindrome"
                    },
                    {
                        "username": "shuklaprakhar24",
                        "content": "Can we solve in o(n3) ?\\n"
                    },
                    {
                        "username": "nullskill",
                        "content": "I wonder what is the correct output should be for the input string \\'abc\\'? Shall it be \\'a\\', \\'b\\' or \\'c\\' ? Any of the three?"
                    },
                    {
                        "username": "Hritik__k",
                        "content": "Any of the three"
                    },
                    {
                        "username": "alvordar",
                        "content": "Anyone in Java getting 141/141 passed but it says Time Limit Exceeded for a blank input: s = .\\nIn other version I was getting an actual time limit exceeded and the given input but in this case it says all test passed but time limit exceeded.\\nAny idea?"
                    },
                    {
                        "username": "Hritik__k",
                        "content": "try passing the values by ref"
                    },
                    {
                        "username": "MaxiGalaxi",
                        "content": "I dont pass testcase 141, I can\\'t see any character in s"
                    },
                    {
                        "username": "anshh10",
                        "content": "Hi, why is this code not working?\\nclass Solution {\\npublic:\\n    string longestPalindrome(string s) \\n    {\\n        int left,right=0;\\n        int maxLen=1;\\n        string maxString=s.substr(0,1);\\n        for(int i=1;i<s.size();i++)\\n        {\\n            left=i;\\n            right=i;\\n            if(s[i]==s[i-1])\\n            {\\n                left--;\\n                while(left>=0 && right<=s.size()-1 && s[left]==s[right])\\n                {\\n                    if(right-left+1>=maxLen)\\n                    {\\n                        maxString=s.substr(left,right+1);\\n                        cout<<maxString<<endl;\\n                        maxLen=right-left+1;\\n                    }\\n                    left--;\\n                    right++;\\n                }\\n            }\\n            else\\n            {\\n                while(left>=0 && right<=s.size()-1 && s[left]==s[right])\\n                {\\n                    if(right-left+1>=maxLen)\\n                    {\\n                        maxString=s.substr(left,right);\\n                        cout<<maxString<<endl;\\n                        maxLen=right-left+1;\\n                    }\\n                    left--;\\n                    right++;\\n                }\\n            }\\n        }\\n        return maxString;\\n        \\n    }\\n};"
                    },
                    {
                        "username": "slucker",
                        "content": "I solved this problem for the first submit by brute-force and beat >60%.\\nJust try to think in every position you will a Palindromic, move left and right to get the Longest match.\\nWe only have two case for each: left=i-1, r=i+1 and left=i, right=i+1;\\nTotal is O(n^2) complexity, O(1) space.\\n"
                    },
                    {
                        "username": "kazangeorg",
                        "content": "Wrong Answer\n\n87 / 141 testcases passed\nInput\ns =\n\"aacabdkacaa\"\nUse Testcase\nOutput\n\"aaca\"\nExpected\n\"aca\"\n\n\nWhy???"
                    },
                    {
                        "username": "dav3th3t3chg33k",
                        "content": "easy problem to solve\\n"
                    }
                ]
            },
            {
                "id": 1939791,
                "content": [
                    {
                        "username": "Whitchurch",
                        "content": "I did a generic Dynamic Programming approach and hit a TLE.\nHas anyone done Memoization to cut down on redundancies, did that help avoid the TLE.\n\nI used a dictionary for memoization, it worked well. However , i don't know how to use it inside this LongestPalindrome function, without re-creating the dictionary over and over again. Is there a way to check if dictionary already exists and not re-create it.\n\nThanks"
                    },
                    {
                        "username": "Ishan1_1",
                        "content": "for the test case \"aacabdkacaa\" why the correct answer is \"aca\" and not \"aacakacaa\" isnt it the longest palindrome"
                    },
                    {
                        "username": "shuklaprakhar24",
                        "content": "Can we solve in o(n3) ?\\n"
                    },
                    {
                        "username": "nullskill",
                        "content": "I wonder what is the correct output should be for the input string \\'abc\\'? Shall it be \\'a\\', \\'b\\' or \\'c\\' ? Any of the three?"
                    },
                    {
                        "username": "Hritik__k",
                        "content": "Any of the three"
                    },
                    {
                        "username": "alvordar",
                        "content": "Anyone in Java getting 141/141 passed but it says Time Limit Exceeded for a blank input: s = .\\nIn other version I was getting an actual time limit exceeded and the given input but in this case it says all test passed but time limit exceeded.\\nAny idea?"
                    },
                    {
                        "username": "Hritik__k",
                        "content": "try passing the values by ref"
                    },
                    {
                        "username": "MaxiGalaxi",
                        "content": "I dont pass testcase 141, I can\\'t see any character in s"
                    },
                    {
                        "username": "anshh10",
                        "content": "Hi, why is this code not working?\\nclass Solution {\\npublic:\\n    string longestPalindrome(string s) \\n    {\\n        int left,right=0;\\n        int maxLen=1;\\n        string maxString=s.substr(0,1);\\n        for(int i=1;i<s.size();i++)\\n        {\\n            left=i;\\n            right=i;\\n            if(s[i]==s[i-1])\\n            {\\n                left--;\\n                while(left>=0 && right<=s.size()-1 && s[left]==s[right])\\n                {\\n                    if(right-left+1>=maxLen)\\n                    {\\n                        maxString=s.substr(left,right+1);\\n                        cout<<maxString<<endl;\\n                        maxLen=right-left+1;\\n                    }\\n                    left--;\\n                    right++;\\n                }\\n            }\\n            else\\n            {\\n                while(left>=0 && right<=s.size()-1 && s[left]==s[right])\\n                {\\n                    if(right-left+1>=maxLen)\\n                    {\\n                        maxString=s.substr(left,right);\\n                        cout<<maxString<<endl;\\n                        maxLen=right-left+1;\\n                    }\\n                    left--;\\n                    right++;\\n                }\\n            }\\n        }\\n        return maxString;\\n        \\n    }\\n};"
                    },
                    {
                        "username": "slucker",
                        "content": "I solved this problem for the first submit by brute-force and beat >60%.\\nJust try to think in every position you will a Palindromic, move left and right to get the Longest match.\\nWe only have two case for each: left=i-1, r=i+1 and left=i, right=i+1;\\nTotal is O(n^2) complexity, O(1) space.\\n"
                    },
                    {
                        "username": "kazangeorg",
                        "content": "Wrong Answer\n\n87 / 141 testcases passed\nInput\ns =\n\"aacabdkacaa\"\nUse Testcase\nOutput\n\"aaca\"\nExpected\n\"aca\"\n\n\nWhy???"
                    },
                    {
                        "username": "dav3th3t3chg33k",
                        "content": "easy problem to solve\\n"
                    }
                ]
            },
            {
                "id": 1935672,
                "content": [
                    {
                        "username": "Whitchurch",
                        "content": "I did a generic Dynamic Programming approach and hit a TLE.\nHas anyone done Memoization to cut down on redundancies, did that help avoid the TLE.\n\nI used a dictionary for memoization, it worked well. However , i don't know how to use it inside this LongestPalindrome function, without re-creating the dictionary over and over again. Is there a way to check if dictionary already exists and not re-create it.\n\nThanks"
                    },
                    {
                        "username": "Ishan1_1",
                        "content": "for the test case \"aacabdkacaa\" why the correct answer is \"aca\" and not \"aacakacaa\" isnt it the longest palindrome"
                    },
                    {
                        "username": "shuklaprakhar24",
                        "content": "Can we solve in o(n3) ?\\n"
                    },
                    {
                        "username": "nullskill",
                        "content": "I wonder what is the correct output should be for the input string \\'abc\\'? Shall it be \\'a\\', \\'b\\' or \\'c\\' ? Any of the three?"
                    },
                    {
                        "username": "Hritik__k",
                        "content": "Any of the three"
                    },
                    {
                        "username": "alvordar",
                        "content": "Anyone in Java getting 141/141 passed but it says Time Limit Exceeded for a blank input: s = .\\nIn other version I was getting an actual time limit exceeded and the given input but in this case it says all test passed but time limit exceeded.\\nAny idea?"
                    },
                    {
                        "username": "Hritik__k",
                        "content": "try passing the values by ref"
                    },
                    {
                        "username": "MaxiGalaxi",
                        "content": "I dont pass testcase 141, I can\\'t see any character in s"
                    },
                    {
                        "username": "anshh10",
                        "content": "Hi, why is this code not working?\\nclass Solution {\\npublic:\\n    string longestPalindrome(string s) \\n    {\\n        int left,right=0;\\n        int maxLen=1;\\n        string maxString=s.substr(0,1);\\n        for(int i=1;i<s.size();i++)\\n        {\\n            left=i;\\n            right=i;\\n            if(s[i]==s[i-1])\\n            {\\n                left--;\\n                while(left>=0 && right<=s.size()-1 && s[left]==s[right])\\n                {\\n                    if(right-left+1>=maxLen)\\n                    {\\n                        maxString=s.substr(left,right+1);\\n                        cout<<maxString<<endl;\\n                        maxLen=right-left+1;\\n                    }\\n                    left--;\\n                    right++;\\n                }\\n            }\\n            else\\n            {\\n                while(left>=0 && right<=s.size()-1 && s[left]==s[right])\\n                {\\n                    if(right-left+1>=maxLen)\\n                    {\\n                        maxString=s.substr(left,right);\\n                        cout<<maxString<<endl;\\n                        maxLen=right-left+1;\\n                    }\\n                    left--;\\n                    right++;\\n                }\\n            }\\n        }\\n        return maxString;\\n        \\n    }\\n};"
                    },
                    {
                        "username": "slucker",
                        "content": "I solved this problem for the first submit by brute-force and beat >60%.\\nJust try to think in every position you will a Palindromic, move left and right to get the Longest match.\\nWe only have two case for each: left=i-1, r=i+1 and left=i, right=i+1;\\nTotal is O(n^2) complexity, O(1) space.\\n"
                    },
                    {
                        "username": "kazangeorg",
                        "content": "Wrong Answer\n\n87 / 141 testcases passed\nInput\ns =\n\"aacabdkacaa\"\nUse Testcase\nOutput\n\"aaca\"\nExpected\n\"aca\"\n\n\nWhy???"
                    },
                    {
                        "username": "dav3th3t3chg33k",
                        "content": "easy problem to solve\\n"
                    }
                ]
            },
            {
                "id": 1930093,
                "content": [
                    {
                        "username": "Whitchurch",
                        "content": "I did a generic Dynamic Programming approach and hit a TLE.\nHas anyone done Memoization to cut down on redundancies, did that help avoid the TLE.\n\nI used a dictionary for memoization, it worked well. However , i don't know how to use it inside this LongestPalindrome function, without re-creating the dictionary over and over again. Is there a way to check if dictionary already exists and not re-create it.\n\nThanks"
                    },
                    {
                        "username": "Ishan1_1",
                        "content": "for the test case \"aacabdkacaa\" why the correct answer is \"aca\" and not \"aacakacaa\" isnt it the longest palindrome"
                    },
                    {
                        "username": "shuklaprakhar24",
                        "content": "Can we solve in o(n3) ?\\n"
                    },
                    {
                        "username": "nullskill",
                        "content": "I wonder what is the correct output should be for the input string \\'abc\\'? Shall it be \\'a\\', \\'b\\' or \\'c\\' ? Any of the three?"
                    },
                    {
                        "username": "Hritik__k",
                        "content": "Any of the three"
                    },
                    {
                        "username": "alvordar",
                        "content": "Anyone in Java getting 141/141 passed but it says Time Limit Exceeded for a blank input: s = .\\nIn other version I was getting an actual time limit exceeded and the given input but in this case it says all test passed but time limit exceeded.\\nAny idea?"
                    },
                    {
                        "username": "Hritik__k",
                        "content": "try passing the values by ref"
                    },
                    {
                        "username": "MaxiGalaxi",
                        "content": "I dont pass testcase 141, I can\\'t see any character in s"
                    },
                    {
                        "username": "anshh10",
                        "content": "Hi, why is this code not working?\\nclass Solution {\\npublic:\\n    string longestPalindrome(string s) \\n    {\\n        int left,right=0;\\n        int maxLen=1;\\n        string maxString=s.substr(0,1);\\n        for(int i=1;i<s.size();i++)\\n        {\\n            left=i;\\n            right=i;\\n            if(s[i]==s[i-1])\\n            {\\n                left--;\\n                while(left>=0 && right<=s.size()-1 && s[left]==s[right])\\n                {\\n                    if(right-left+1>=maxLen)\\n                    {\\n                        maxString=s.substr(left,right+1);\\n                        cout<<maxString<<endl;\\n                        maxLen=right-left+1;\\n                    }\\n                    left--;\\n                    right++;\\n                }\\n            }\\n            else\\n            {\\n                while(left>=0 && right<=s.size()-1 && s[left]==s[right])\\n                {\\n                    if(right-left+1>=maxLen)\\n                    {\\n                        maxString=s.substr(left,right);\\n                        cout<<maxString<<endl;\\n                        maxLen=right-left+1;\\n                    }\\n                    left--;\\n                    right++;\\n                }\\n            }\\n        }\\n        return maxString;\\n        \\n    }\\n};"
                    },
                    {
                        "username": "slucker",
                        "content": "I solved this problem for the first submit by brute-force and beat >60%.\\nJust try to think in every position you will a Palindromic, move left and right to get the Longest match.\\nWe only have two case for each: left=i-1, r=i+1 and left=i, right=i+1;\\nTotal is O(n^2) complexity, O(1) space.\\n"
                    },
                    {
                        "username": "kazangeorg",
                        "content": "Wrong Answer\n\n87 / 141 testcases passed\nInput\ns =\n\"aacabdkacaa\"\nUse Testcase\nOutput\n\"aaca\"\nExpected\n\"aca\"\n\n\nWhy???"
                    },
                    {
                        "username": "dav3th3t3chg33k",
                        "content": "easy problem to solve\\n"
                    }
                ]
            },
            {
                "id": 1921441,
                "content": [
                    {
                        "username": "Whitchurch",
                        "content": "I did a generic Dynamic Programming approach and hit a TLE.\nHas anyone done Memoization to cut down on redundancies, did that help avoid the TLE.\n\nI used a dictionary for memoization, it worked well. However , i don't know how to use it inside this LongestPalindrome function, without re-creating the dictionary over and over again. Is there a way to check if dictionary already exists and not re-create it.\n\nThanks"
                    },
                    {
                        "username": "Ishan1_1",
                        "content": "for the test case \"aacabdkacaa\" why the correct answer is \"aca\" and not \"aacakacaa\" isnt it the longest palindrome"
                    },
                    {
                        "username": "shuklaprakhar24",
                        "content": "Can we solve in o(n3) ?\\n"
                    },
                    {
                        "username": "nullskill",
                        "content": "I wonder what is the correct output should be for the input string \\'abc\\'? Shall it be \\'a\\', \\'b\\' or \\'c\\' ? Any of the three?"
                    },
                    {
                        "username": "Hritik__k",
                        "content": "Any of the three"
                    },
                    {
                        "username": "alvordar",
                        "content": "Anyone in Java getting 141/141 passed but it says Time Limit Exceeded for a blank input: s = .\\nIn other version I was getting an actual time limit exceeded and the given input but in this case it says all test passed but time limit exceeded.\\nAny idea?"
                    },
                    {
                        "username": "Hritik__k",
                        "content": "try passing the values by ref"
                    },
                    {
                        "username": "MaxiGalaxi",
                        "content": "I dont pass testcase 141, I can\\'t see any character in s"
                    },
                    {
                        "username": "anshh10",
                        "content": "Hi, why is this code not working?\\nclass Solution {\\npublic:\\n    string longestPalindrome(string s) \\n    {\\n        int left,right=0;\\n        int maxLen=1;\\n        string maxString=s.substr(0,1);\\n        for(int i=1;i<s.size();i++)\\n        {\\n            left=i;\\n            right=i;\\n            if(s[i]==s[i-1])\\n            {\\n                left--;\\n                while(left>=0 && right<=s.size()-1 && s[left]==s[right])\\n                {\\n                    if(right-left+1>=maxLen)\\n                    {\\n                        maxString=s.substr(left,right+1);\\n                        cout<<maxString<<endl;\\n                        maxLen=right-left+1;\\n                    }\\n                    left--;\\n                    right++;\\n                }\\n            }\\n            else\\n            {\\n                while(left>=0 && right<=s.size()-1 && s[left]==s[right])\\n                {\\n                    if(right-left+1>=maxLen)\\n                    {\\n                        maxString=s.substr(left,right);\\n                        cout<<maxString<<endl;\\n                        maxLen=right-left+1;\\n                    }\\n                    left--;\\n                    right++;\\n                }\\n            }\\n        }\\n        return maxString;\\n        \\n    }\\n};"
                    },
                    {
                        "username": "slucker",
                        "content": "I solved this problem for the first submit by brute-force and beat >60%.\\nJust try to think in every position you will a Palindromic, move left and right to get the Longest match.\\nWe only have two case for each: left=i-1, r=i+1 and left=i, right=i+1;\\nTotal is O(n^2) complexity, O(1) space.\\n"
                    },
                    {
                        "username": "kazangeorg",
                        "content": "Wrong Answer\n\n87 / 141 testcases passed\nInput\ns =\n\"aacabdkacaa\"\nUse Testcase\nOutput\n\"aaca\"\nExpected\n\"aca\"\n\n\nWhy???"
                    },
                    {
                        "username": "dav3th3t3chg33k",
                        "content": "easy problem to solve\\n"
                    }
                ]
            },
            {
                "id": 1918683,
                "content": [
                    {
                        "username": "Whitchurch",
                        "content": "I did a generic Dynamic Programming approach and hit a TLE.\nHas anyone done Memoization to cut down on redundancies, did that help avoid the TLE.\n\nI used a dictionary for memoization, it worked well. However , i don't know how to use it inside this LongestPalindrome function, without re-creating the dictionary over and over again. Is there a way to check if dictionary already exists and not re-create it.\n\nThanks"
                    },
                    {
                        "username": "Ishan1_1",
                        "content": "for the test case \"aacabdkacaa\" why the correct answer is \"aca\" and not \"aacakacaa\" isnt it the longest palindrome"
                    },
                    {
                        "username": "shuklaprakhar24",
                        "content": "Can we solve in o(n3) ?\\n"
                    },
                    {
                        "username": "nullskill",
                        "content": "I wonder what is the correct output should be for the input string \\'abc\\'? Shall it be \\'a\\', \\'b\\' or \\'c\\' ? Any of the three?"
                    },
                    {
                        "username": "Hritik__k",
                        "content": "Any of the three"
                    },
                    {
                        "username": "alvordar",
                        "content": "Anyone in Java getting 141/141 passed but it says Time Limit Exceeded for a blank input: s = .\\nIn other version I was getting an actual time limit exceeded and the given input but in this case it says all test passed but time limit exceeded.\\nAny idea?"
                    },
                    {
                        "username": "Hritik__k",
                        "content": "try passing the values by ref"
                    },
                    {
                        "username": "MaxiGalaxi",
                        "content": "I dont pass testcase 141, I can\\'t see any character in s"
                    },
                    {
                        "username": "anshh10",
                        "content": "Hi, why is this code not working?\\nclass Solution {\\npublic:\\n    string longestPalindrome(string s) \\n    {\\n        int left,right=0;\\n        int maxLen=1;\\n        string maxString=s.substr(0,1);\\n        for(int i=1;i<s.size();i++)\\n        {\\n            left=i;\\n            right=i;\\n            if(s[i]==s[i-1])\\n            {\\n                left--;\\n                while(left>=0 && right<=s.size()-1 && s[left]==s[right])\\n                {\\n                    if(right-left+1>=maxLen)\\n                    {\\n                        maxString=s.substr(left,right+1);\\n                        cout<<maxString<<endl;\\n                        maxLen=right-left+1;\\n                    }\\n                    left--;\\n                    right++;\\n                }\\n            }\\n            else\\n            {\\n                while(left>=0 && right<=s.size()-1 && s[left]==s[right])\\n                {\\n                    if(right-left+1>=maxLen)\\n                    {\\n                        maxString=s.substr(left,right);\\n                        cout<<maxString<<endl;\\n                        maxLen=right-left+1;\\n                    }\\n                    left--;\\n                    right++;\\n                }\\n            }\\n        }\\n        return maxString;\\n        \\n    }\\n};"
                    },
                    {
                        "username": "slucker",
                        "content": "I solved this problem for the first submit by brute-force and beat >60%.\\nJust try to think in every position you will a Palindromic, move left and right to get the Longest match.\\nWe only have two case for each: left=i-1, r=i+1 and left=i, right=i+1;\\nTotal is O(n^2) complexity, O(1) space.\\n"
                    },
                    {
                        "username": "kazangeorg",
                        "content": "Wrong Answer\n\n87 / 141 testcases passed\nInput\ns =\n\"aacabdkacaa\"\nUse Testcase\nOutput\n\"aaca\"\nExpected\n\"aca\"\n\n\nWhy???"
                    },
                    {
                        "username": "dav3th3t3chg33k",
                        "content": "easy problem to solve\\n"
                    }
                ]
            },
            {
                "id": 1902313,
                "content": [
                    {
                        "username": "user7351F",
                        "content": "class Solution {\\n    public String longestPalindrome(String s) {\\n    int i = 0;\\n     if(1 <= s.length() && s.length() <= 1000){\\n       if(s.length() == 1 || s.length() == 0){\\n           return s;\\n       }\\n       if(isPalindrome(s)){\\n         String new_str = s.substring(i+1,s.length()-1);\\n         longestPalindrome(new_str);\\n         \\n         \\n       } \\n       else{\\n           String new_str1 = s.substring(i,s.length()-1); \\n          longestPalindrome(new_str1);\\n          \\n          \\n       } \\n     }\\n     return s;\\n    }\\n     boolean isPalindrome(String s1){\\n       int a = 0;\\n       int j = s1.length() - 1;\\n       while(a <= j){\\n         if(s1.charAt(a) != s1.charAt(j)){\\n           return false;\\n         }\\n         \\n         a++;\\n         j--;\\n       }\\n       return true;\\n     }  \\n}\\nCAn someone explain what is wrong in my code?"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Posting your solution in discussions is wrong"
                    },
                    {
                        "username": "Mookambika8",
                        "content": "Hello Leetcoders,\\n\\nI have a basic question in the understanding of the logic that needs to be followed for solving this problem without brute force.\\n\\nI have the below approach in mind:\\n\\nwhen you get the longest length, \\n1. we need to get the palindrome with that length.\\n2. We need to reduce length to be checked by -1\\n3. shift left the window by 1 by fixing the end and moving only left index by 1 until there is only value 1 difference between start and end while end > start\\n4. shift left the window by 1 by fixing the end and moving only right index by 1 until there is only value 1 difference between start and end while end > start\\n5. the above to loop around until we have the i reaching end of the string.\\n\\nCan you please review this approach and let me know if this is good enough for the solution or I got the whole idea wrong."
                    },
                    {
                        "username": "KaleemRazaSyedJ",
                        "content": "How are you finding the length of the longest paldromic substring?\n"
                    },
                    {
                        "username": "rohitrangde",
                        "content": "Wrong Answer\\n\\nInput\\ns =\\n\"aacabdkacaa\"\\n\\nOutput\\n\"aacakacaa\"\\nExpected\\n\"aca\"\\n\\nis it wrong output ?\\n"
                    },
                    {
                        "username": "KaleemRazaSyedJ",
                        "content": "Your answer is aacakacaa is incorrect because we are asked for substring not subsequence."
                    },
                    {
                        "username": "anj20",
                        "content": "can we do this in a tc better than O(N^2)?"
                    },
                    {
                        "username": "espinosarennieljun",
                        "content": "I always ended up hitting the time limit exceeded error. "
                    },
                    {
                        "username": "PrashanthVR",
                        "content": "For one particular testcase while submitting, the compiler shows run time exceeded. But when I give that particular test case manually, it passes. HOw?\\n\\n"
                    },
                    {
                        "username": "joinfanng",
                        "content": "how the testcase \"ac\" works???\\nideally it should return nuthimg"
                    },
                    {
                        "username": "chibi_chihiro",
                        "content": "You can just use brute force if you are struggling :p"
                    },
                    {
                        "username": "balakrishna_95",
                        "content": "class Solution {\\n\\t  static boolean h(String s)\\n    {\\n    \\tString j=\"\";\\n    \\tfor(int i=s.length()-1;i>=0;i--)\\n    \\t{\\n    \\t\\tj=j+s.charAt(i);\\n    \\t}\\n    \\tif(j.equals(s))\\n    \\t{\\n    \\t\\treturn true;\\n    \\t}\\n    \\treturn false;\\n    }\\n\\tpublic String longestPalindrome(String s){\\n        int max=1;\\n        int start=0;\\n        for(int i=0;i<s.length();i++)\\n        {\\n        \\tfor(int j=i;j<s.length();j++)\\n        \\t{\\n        \\t\\tif(h(s.substring(i,j+1)))\\n        \\t\\t{\\n        \\t\\t\\tif(j-i+1>max)\\n        \\t\\t\\t{\\n        \\t\\t\\t  start=i;\\n        \\t\\t\\t  max=j-i+1;\\n        \\t\\t\\t}\\n        \\t\\t}\\n        \\t}\\n        }\\n\\t\\treturn s.substring(start,start+max);\\n\\t}\\n}\\n"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "balakrishna_95",
                        "content": "why my code is not working for all the test case\\n"
                    },
                    {
                        "username": "SlowCodiee",
                        "content": "Please specify in the question what should I return if there are no valid palindrome substring"
                    }
                ]
            },
            {
                "id": 1899428,
                "content": [
                    {
                        "username": "user7351F",
                        "content": "class Solution {\\n    public String longestPalindrome(String s) {\\n    int i = 0;\\n     if(1 <= s.length() && s.length() <= 1000){\\n       if(s.length() == 1 || s.length() == 0){\\n           return s;\\n       }\\n       if(isPalindrome(s)){\\n         String new_str = s.substring(i+1,s.length()-1);\\n         longestPalindrome(new_str);\\n         \\n         \\n       } \\n       else{\\n           String new_str1 = s.substring(i,s.length()-1); \\n          longestPalindrome(new_str1);\\n          \\n          \\n       } \\n     }\\n     return s;\\n    }\\n     boolean isPalindrome(String s1){\\n       int a = 0;\\n       int j = s1.length() - 1;\\n       while(a <= j){\\n         if(s1.charAt(a) != s1.charAt(j)){\\n           return false;\\n         }\\n         \\n         a++;\\n         j--;\\n       }\\n       return true;\\n     }  \\n}\\nCAn someone explain what is wrong in my code?"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Posting your solution in discussions is wrong"
                    },
                    {
                        "username": "Mookambika8",
                        "content": "Hello Leetcoders,\\n\\nI have a basic question in the understanding of the logic that needs to be followed for solving this problem without brute force.\\n\\nI have the below approach in mind:\\n\\nwhen you get the longest length, \\n1. we need to get the palindrome with that length.\\n2. We need to reduce length to be checked by -1\\n3. shift left the window by 1 by fixing the end and moving only left index by 1 until there is only value 1 difference between start and end while end > start\\n4. shift left the window by 1 by fixing the end and moving only right index by 1 until there is only value 1 difference between start and end while end > start\\n5. the above to loop around until we have the i reaching end of the string.\\n\\nCan you please review this approach and let me know if this is good enough for the solution or I got the whole idea wrong."
                    },
                    {
                        "username": "KaleemRazaSyedJ",
                        "content": "How are you finding the length of the longest paldromic substring?\n"
                    },
                    {
                        "username": "rohitrangde",
                        "content": "Wrong Answer\\n\\nInput\\ns =\\n\"aacabdkacaa\"\\n\\nOutput\\n\"aacakacaa\"\\nExpected\\n\"aca\"\\n\\nis it wrong output ?\\n"
                    },
                    {
                        "username": "KaleemRazaSyedJ",
                        "content": "Your answer is aacakacaa is incorrect because we are asked for substring not subsequence."
                    },
                    {
                        "username": "anj20",
                        "content": "can we do this in a tc better than O(N^2)?"
                    },
                    {
                        "username": "espinosarennieljun",
                        "content": "I always ended up hitting the time limit exceeded error. "
                    },
                    {
                        "username": "PrashanthVR",
                        "content": "For one particular testcase while submitting, the compiler shows run time exceeded. But when I give that particular test case manually, it passes. HOw?\\n\\n"
                    },
                    {
                        "username": "joinfanng",
                        "content": "how the testcase \"ac\" works???\\nideally it should return nuthimg"
                    },
                    {
                        "username": "chibi_chihiro",
                        "content": "You can just use brute force if you are struggling :p"
                    },
                    {
                        "username": "balakrishna_95",
                        "content": "class Solution {\\n\\t  static boolean h(String s)\\n    {\\n    \\tString j=\"\";\\n    \\tfor(int i=s.length()-1;i>=0;i--)\\n    \\t{\\n    \\t\\tj=j+s.charAt(i);\\n    \\t}\\n    \\tif(j.equals(s))\\n    \\t{\\n    \\t\\treturn true;\\n    \\t}\\n    \\treturn false;\\n    }\\n\\tpublic String longestPalindrome(String s){\\n        int max=1;\\n        int start=0;\\n        for(int i=0;i<s.length();i++)\\n        {\\n        \\tfor(int j=i;j<s.length();j++)\\n        \\t{\\n        \\t\\tif(h(s.substring(i,j+1)))\\n        \\t\\t{\\n        \\t\\t\\tif(j-i+1>max)\\n        \\t\\t\\t{\\n        \\t\\t\\t  start=i;\\n        \\t\\t\\t  max=j-i+1;\\n        \\t\\t\\t}\\n        \\t\\t}\\n        \\t}\\n        }\\n\\t\\treturn s.substring(start,start+max);\\n\\t}\\n}\\n"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "balakrishna_95",
                        "content": "why my code is not working for all the test case\\n"
                    },
                    {
                        "username": "SlowCodiee",
                        "content": "Please specify in the question what should I return if there are no valid palindrome substring"
                    }
                ]
            },
            {
                "id": 1895244,
                "content": [
                    {
                        "username": "user7351F",
                        "content": "class Solution {\\n    public String longestPalindrome(String s) {\\n    int i = 0;\\n     if(1 <= s.length() && s.length() <= 1000){\\n       if(s.length() == 1 || s.length() == 0){\\n           return s;\\n       }\\n       if(isPalindrome(s)){\\n         String new_str = s.substring(i+1,s.length()-1);\\n         longestPalindrome(new_str);\\n         \\n         \\n       } \\n       else{\\n           String new_str1 = s.substring(i,s.length()-1); \\n          longestPalindrome(new_str1);\\n          \\n          \\n       } \\n     }\\n     return s;\\n    }\\n     boolean isPalindrome(String s1){\\n       int a = 0;\\n       int j = s1.length() - 1;\\n       while(a <= j){\\n         if(s1.charAt(a) != s1.charAt(j)){\\n           return false;\\n         }\\n         \\n         a++;\\n         j--;\\n       }\\n       return true;\\n     }  \\n}\\nCAn someone explain what is wrong in my code?"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Posting your solution in discussions is wrong"
                    },
                    {
                        "username": "Mookambika8",
                        "content": "Hello Leetcoders,\\n\\nI have a basic question in the understanding of the logic that needs to be followed for solving this problem without brute force.\\n\\nI have the below approach in mind:\\n\\nwhen you get the longest length, \\n1. we need to get the palindrome with that length.\\n2. We need to reduce length to be checked by -1\\n3. shift left the window by 1 by fixing the end and moving only left index by 1 until there is only value 1 difference between start and end while end > start\\n4. shift left the window by 1 by fixing the end and moving only right index by 1 until there is only value 1 difference between start and end while end > start\\n5. the above to loop around until we have the i reaching end of the string.\\n\\nCan you please review this approach and let me know if this is good enough for the solution or I got the whole idea wrong."
                    },
                    {
                        "username": "KaleemRazaSyedJ",
                        "content": "How are you finding the length of the longest paldromic substring?\n"
                    },
                    {
                        "username": "rohitrangde",
                        "content": "Wrong Answer\\n\\nInput\\ns =\\n\"aacabdkacaa\"\\n\\nOutput\\n\"aacakacaa\"\\nExpected\\n\"aca\"\\n\\nis it wrong output ?\\n"
                    },
                    {
                        "username": "KaleemRazaSyedJ",
                        "content": "Your answer is aacakacaa is incorrect because we are asked for substring not subsequence."
                    },
                    {
                        "username": "anj20",
                        "content": "can we do this in a tc better than O(N^2)?"
                    },
                    {
                        "username": "espinosarennieljun",
                        "content": "I always ended up hitting the time limit exceeded error. "
                    },
                    {
                        "username": "PrashanthVR",
                        "content": "For one particular testcase while submitting, the compiler shows run time exceeded. But when I give that particular test case manually, it passes. HOw?\\n\\n"
                    },
                    {
                        "username": "joinfanng",
                        "content": "how the testcase \"ac\" works???\\nideally it should return nuthimg"
                    },
                    {
                        "username": "chibi_chihiro",
                        "content": "You can just use brute force if you are struggling :p"
                    },
                    {
                        "username": "balakrishna_95",
                        "content": "class Solution {\\n\\t  static boolean h(String s)\\n    {\\n    \\tString j=\"\";\\n    \\tfor(int i=s.length()-1;i>=0;i--)\\n    \\t{\\n    \\t\\tj=j+s.charAt(i);\\n    \\t}\\n    \\tif(j.equals(s))\\n    \\t{\\n    \\t\\treturn true;\\n    \\t}\\n    \\treturn false;\\n    }\\n\\tpublic String longestPalindrome(String s){\\n        int max=1;\\n        int start=0;\\n        for(int i=0;i<s.length();i++)\\n        {\\n        \\tfor(int j=i;j<s.length();j++)\\n        \\t{\\n        \\t\\tif(h(s.substring(i,j+1)))\\n        \\t\\t{\\n        \\t\\t\\tif(j-i+1>max)\\n        \\t\\t\\t{\\n        \\t\\t\\t  start=i;\\n        \\t\\t\\t  max=j-i+1;\\n        \\t\\t\\t}\\n        \\t\\t}\\n        \\t}\\n        }\\n\\t\\treturn s.substring(start,start+max);\\n\\t}\\n}\\n"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "balakrishna_95",
                        "content": "why my code is not working for all the test case\\n"
                    },
                    {
                        "username": "SlowCodiee",
                        "content": "Please specify in the question what should I return if there are no valid palindrome substring"
                    }
                ]
            },
            {
                "id": 1889881,
                "content": [
                    {
                        "username": "user7351F",
                        "content": "class Solution {\\n    public String longestPalindrome(String s) {\\n    int i = 0;\\n     if(1 <= s.length() && s.length() <= 1000){\\n       if(s.length() == 1 || s.length() == 0){\\n           return s;\\n       }\\n       if(isPalindrome(s)){\\n         String new_str = s.substring(i+1,s.length()-1);\\n         longestPalindrome(new_str);\\n         \\n         \\n       } \\n       else{\\n           String new_str1 = s.substring(i,s.length()-1); \\n          longestPalindrome(new_str1);\\n          \\n          \\n       } \\n     }\\n     return s;\\n    }\\n     boolean isPalindrome(String s1){\\n       int a = 0;\\n       int j = s1.length() - 1;\\n       while(a <= j){\\n         if(s1.charAt(a) != s1.charAt(j)){\\n           return false;\\n         }\\n         \\n         a++;\\n         j--;\\n       }\\n       return true;\\n     }  \\n}\\nCAn someone explain what is wrong in my code?"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Posting your solution in discussions is wrong"
                    },
                    {
                        "username": "Mookambika8",
                        "content": "Hello Leetcoders,\\n\\nI have a basic question in the understanding of the logic that needs to be followed for solving this problem without brute force.\\n\\nI have the below approach in mind:\\n\\nwhen you get the longest length, \\n1. we need to get the palindrome with that length.\\n2. We need to reduce length to be checked by -1\\n3. shift left the window by 1 by fixing the end and moving only left index by 1 until there is only value 1 difference between start and end while end > start\\n4. shift left the window by 1 by fixing the end and moving only right index by 1 until there is only value 1 difference between start and end while end > start\\n5. the above to loop around until we have the i reaching end of the string.\\n\\nCan you please review this approach and let me know if this is good enough for the solution or I got the whole idea wrong."
                    },
                    {
                        "username": "KaleemRazaSyedJ",
                        "content": "How are you finding the length of the longest paldromic substring?\n"
                    },
                    {
                        "username": "rohitrangde",
                        "content": "Wrong Answer\\n\\nInput\\ns =\\n\"aacabdkacaa\"\\n\\nOutput\\n\"aacakacaa\"\\nExpected\\n\"aca\"\\n\\nis it wrong output ?\\n"
                    },
                    {
                        "username": "KaleemRazaSyedJ",
                        "content": "Your answer is aacakacaa is incorrect because we are asked for substring not subsequence."
                    },
                    {
                        "username": "anj20",
                        "content": "can we do this in a tc better than O(N^2)?"
                    },
                    {
                        "username": "espinosarennieljun",
                        "content": "I always ended up hitting the time limit exceeded error. "
                    },
                    {
                        "username": "PrashanthVR",
                        "content": "For one particular testcase while submitting, the compiler shows run time exceeded. But when I give that particular test case manually, it passes. HOw?\\n\\n"
                    },
                    {
                        "username": "joinfanng",
                        "content": "how the testcase \"ac\" works???\\nideally it should return nuthimg"
                    },
                    {
                        "username": "chibi_chihiro",
                        "content": "You can just use brute force if you are struggling :p"
                    },
                    {
                        "username": "balakrishna_95",
                        "content": "class Solution {\\n\\t  static boolean h(String s)\\n    {\\n    \\tString j=\"\";\\n    \\tfor(int i=s.length()-1;i>=0;i--)\\n    \\t{\\n    \\t\\tj=j+s.charAt(i);\\n    \\t}\\n    \\tif(j.equals(s))\\n    \\t{\\n    \\t\\treturn true;\\n    \\t}\\n    \\treturn false;\\n    }\\n\\tpublic String longestPalindrome(String s){\\n        int max=1;\\n        int start=0;\\n        for(int i=0;i<s.length();i++)\\n        {\\n        \\tfor(int j=i;j<s.length();j++)\\n        \\t{\\n        \\t\\tif(h(s.substring(i,j+1)))\\n        \\t\\t{\\n        \\t\\t\\tif(j-i+1>max)\\n        \\t\\t\\t{\\n        \\t\\t\\t  start=i;\\n        \\t\\t\\t  max=j-i+1;\\n        \\t\\t\\t}\\n        \\t\\t}\\n        \\t}\\n        }\\n\\t\\treturn s.substring(start,start+max);\\n\\t}\\n}\\n"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "balakrishna_95",
                        "content": "why my code is not working for all the test case\\n"
                    },
                    {
                        "username": "SlowCodiee",
                        "content": "Please specify in the question what should I return if there are no valid palindrome substring"
                    }
                ]
            },
            {
                "id": 1889597,
                "content": [
                    {
                        "username": "user7351F",
                        "content": "class Solution {\\n    public String longestPalindrome(String s) {\\n    int i = 0;\\n     if(1 <= s.length() && s.length() <= 1000){\\n       if(s.length() == 1 || s.length() == 0){\\n           return s;\\n       }\\n       if(isPalindrome(s)){\\n         String new_str = s.substring(i+1,s.length()-1);\\n         longestPalindrome(new_str);\\n         \\n         \\n       } \\n       else{\\n           String new_str1 = s.substring(i,s.length()-1); \\n          longestPalindrome(new_str1);\\n          \\n          \\n       } \\n     }\\n     return s;\\n    }\\n     boolean isPalindrome(String s1){\\n       int a = 0;\\n       int j = s1.length() - 1;\\n       while(a <= j){\\n         if(s1.charAt(a) != s1.charAt(j)){\\n           return false;\\n         }\\n         \\n         a++;\\n         j--;\\n       }\\n       return true;\\n     }  \\n}\\nCAn someone explain what is wrong in my code?"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Posting your solution in discussions is wrong"
                    },
                    {
                        "username": "Mookambika8",
                        "content": "Hello Leetcoders,\\n\\nI have a basic question in the understanding of the logic that needs to be followed for solving this problem without brute force.\\n\\nI have the below approach in mind:\\n\\nwhen you get the longest length, \\n1. we need to get the palindrome with that length.\\n2. We need to reduce length to be checked by -1\\n3. shift left the window by 1 by fixing the end and moving only left index by 1 until there is only value 1 difference between start and end while end > start\\n4. shift left the window by 1 by fixing the end and moving only right index by 1 until there is only value 1 difference between start and end while end > start\\n5. the above to loop around until we have the i reaching end of the string.\\n\\nCan you please review this approach and let me know if this is good enough for the solution or I got the whole idea wrong."
                    },
                    {
                        "username": "KaleemRazaSyedJ",
                        "content": "How are you finding the length of the longest paldromic substring?\n"
                    },
                    {
                        "username": "rohitrangde",
                        "content": "Wrong Answer\\n\\nInput\\ns =\\n\"aacabdkacaa\"\\n\\nOutput\\n\"aacakacaa\"\\nExpected\\n\"aca\"\\n\\nis it wrong output ?\\n"
                    },
                    {
                        "username": "KaleemRazaSyedJ",
                        "content": "Your answer is aacakacaa is incorrect because we are asked for substring not subsequence."
                    },
                    {
                        "username": "anj20",
                        "content": "can we do this in a tc better than O(N^2)?"
                    },
                    {
                        "username": "espinosarennieljun",
                        "content": "I always ended up hitting the time limit exceeded error. "
                    },
                    {
                        "username": "PrashanthVR",
                        "content": "For one particular testcase while submitting, the compiler shows run time exceeded. But when I give that particular test case manually, it passes. HOw?\\n\\n"
                    },
                    {
                        "username": "joinfanng",
                        "content": "how the testcase \"ac\" works???\\nideally it should return nuthimg"
                    },
                    {
                        "username": "chibi_chihiro",
                        "content": "You can just use brute force if you are struggling :p"
                    },
                    {
                        "username": "balakrishna_95",
                        "content": "class Solution {\\n\\t  static boolean h(String s)\\n    {\\n    \\tString j=\"\";\\n    \\tfor(int i=s.length()-1;i>=0;i--)\\n    \\t{\\n    \\t\\tj=j+s.charAt(i);\\n    \\t}\\n    \\tif(j.equals(s))\\n    \\t{\\n    \\t\\treturn true;\\n    \\t}\\n    \\treturn false;\\n    }\\n\\tpublic String longestPalindrome(String s){\\n        int max=1;\\n        int start=0;\\n        for(int i=0;i<s.length();i++)\\n        {\\n        \\tfor(int j=i;j<s.length();j++)\\n        \\t{\\n        \\t\\tif(h(s.substring(i,j+1)))\\n        \\t\\t{\\n        \\t\\t\\tif(j-i+1>max)\\n        \\t\\t\\t{\\n        \\t\\t\\t  start=i;\\n        \\t\\t\\t  max=j-i+1;\\n        \\t\\t\\t}\\n        \\t\\t}\\n        \\t}\\n        }\\n\\t\\treturn s.substring(start,start+max);\\n\\t}\\n}\\n"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "balakrishna_95",
                        "content": "why my code is not working for all the test case\\n"
                    },
                    {
                        "username": "SlowCodiee",
                        "content": "Please specify in the question what should I return if there are no valid palindrome substring"
                    }
                ]
            },
            {
                "id": 1887989,
                "content": [
                    {
                        "username": "user7351F",
                        "content": "class Solution {\\n    public String longestPalindrome(String s) {\\n    int i = 0;\\n     if(1 <= s.length() && s.length() <= 1000){\\n       if(s.length() == 1 || s.length() == 0){\\n           return s;\\n       }\\n       if(isPalindrome(s)){\\n         String new_str = s.substring(i+1,s.length()-1);\\n         longestPalindrome(new_str);\\n         \\n         \\n       } \\n       else{\\n           String new_str1 = s.substring(i,s.length()-1); \\n          longestPalindrome(new_str1);\\n          \\n          \\n       } \\n     }\\n     return s;\\n    }\\n     boolean isPalindrome(String s1){\\n       int a = 0;\\n       int j = s1.length() - 1;\\n       while(a <= j){\\n         if(s1.charAt(a) != s1.charAt(j)){\\n           return false;\\n         }\\n         \\n         a++;\\n         j--;\\n       }\\n       return true;\\n     }  \\n}\\nCAn someone explain what is wrong in my code?"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Posting your solution in discussions is wrong"
                    },
                    {
                        "username": "Mookambika8",
                        "content": "Hello Leetcoders,\\n\\nI have a basic question in the understanding of the logic that needs to be followed for solving this problem without brute force.\\n\\nI have the below approach in mind:\\n\\nwhen you get the longest length, \\n1. we need to get the palindrome with that length.\\n2. We need to reduce length to be checked by -1\\n3. shift left the window by 1 by fixing the end and moving only left index by 1 until there is only value 1 difference between start and end while end > start\\n4. shift left the window by 1 by fixing the end and moving only right index by 1 until there is only value 1 difference between start and end while end > start\\n5. the above to loop around until we have the i reaching end of the string.\\n\\nCan you please review this approach and let me know if this is good enough for the solution or I got the whole idea wrong."
                    },
                    {
                        "username": "KaleemRazaSyedJ",
                        "content": "How are you finding the length of the longest paldromic substring?\n"
                    },
                    {
                        "username": "rohitrangde",
                        "content": "Wrong Answer\\n\\nInput\\ns =\\n\"aacabdkacaa\"\\n\\nOutput\\n\"aacakacaa\"\\nExpected\\n\"aca\"\\n\\nis it wrong output ?\\n"
                    },
                    {
                        "username": "KaleemRazaSyedJ",
                        "content": "Your answer is aacakacaa is incorrect because we are asked for substring not subsequence."
                    },
                    {
                        "username": "anj20",
                        "content": "can we do this in a tc better than O(N^2)?"
                    },
                    {
                        "username": "espinosarennieljun",
                        "content": "I always ended up hitting the time limit exceeded error. "
                    },
                    {
                        "username": "PrashanthVR",
                        "content": "For one particular testcase while submitting, the compiler shows run time exceeded. But when I give that particular test case manually, it passes. HOw?\\n\\n"
                    },
                    {
                        "username": "joinfanng",
                        "content": "how the testcase \"ac\" works???\\nideally it should return nuthimg"
                    },
                    {
                        "username": "chibi_chihiro",
                        "content": "You can just use brute force if you are struggling :p"
                    },
                    {
                        "username": "balakrishna_95",
                        "content": "class Solution {\\n\\t  static boolean h(String s)\\n    {\\n    \\tString j=\"\";\\n    \\tfor(int i=s.length()-1;i>=0;i--)\\n    \\t{\\n    \\t\\tj=j+s.charAt(i);\\n    \\t}\\n    \\tif(j.equals(s))\\n    \\t{\\n    \\t\\treturn true;\\n    \\t}\\n    \\treturn false;\\n    }\\n\\tpublic String longestPalindrome(String s){\\n        int max=1;\\n        int start=0;\\n        for(int i=0;i<s.length();i++)\\n        {\\n        \\tfor(int j=i;j<s.length();j++)\\n        \\t{\\n        \\t\\tif(h(s.substring(i,j+1)))\\n        \\t\\t{\\n        \\t\\t\\tif(j-i+1>max)\\n        \\t\\t\\t{\\n        \\t\\t\\t  start=i;\\n        \\t\\t\\t  max=j-i+1;\\n        \\t\\t\\t}\\n        \\t\\t}\\n        \\t}\\n        }\\n\\t\\treturn s.substring(start,start+max);\\n\\t}\\n}\\n"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "balakrishna_95",
                        "content": "why my code is not working for all the test case\\n"
                    },
                    {
                        "username": "SlowCodiee",
                        "content": "Please specify in the question what should I return if there are no valid palindrome substring"
                    }
                ]
            },
            {
                "id": 1882674,
                "content": [
                    {
                        "username": "user7351F",
                        "content": "class Solution {\\n    public String longestPalindrome(String s) {\\n    int i = 0;\\n     if(1 <= s.length() && s.length() <= 1000){\\n       if(s.length() == 1 || s.length() == 0){\\n           return s;\\n       }\\n       if(isPalindrome(s)){\\n         String new_str = s.substring(i+1,s.length()-1);\\n         longestPalindrome(new_str);\\n         \\n         \\n       } \\n       else{\\n           String new_str1 = s.substring(i,s.length()-1); \\n          longestPalindrome(new_str1);\\n          \\n          \\n       } \\n     }\\n     return s;\\n    }\\n     boolean isPalindrome(String s1){\\n       int a = 0;\\n       int j = s1.length() - 1;\\n       while(a <= j){\\n         if(s1.charAt(a) != s1.charAt(j)){\\n           return false;\\n         }\\n         \\n         a++;\\n         j--;\\n       }\\n       return true;\\n     }  \\n}\\nCAn someone explain what is wrong in my code?"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Posting your solution in discussions is wrong"
                    },
                    {
                        "username": "Mookambika8",
                        "content": "Hello Leetcoders,\\n\\nI have a basic question in the understanding of the logic that needs to be followed for solving this problem without brute force.\\n\\nI have the below approach in mind:\\n\\nwhen you get the longest length, \\n1. we need to get the palindrome with that length.\\n2. We need to reduce length to be checked by -1\\n3. shift left the window by 1 by fixing the end and moving only left index by 1 until there is only value 1 difference between start and end while end > start\\n4. shift left the window by 1 by fixing the end and moving only right index by 1 until there is only value 1 difference between start and end while end > start\\n5. the above to loop around until we have the i reaching end of the string.\\n\\nCan you please review this approach and let me know if this is good enough for the solution or I got the whole idea wrong."
                    },
                    {
                        "username": "KaleemRazaSyedJ",
                        "content": "How are you finding the length of the longest paldromic substring?\n"
                    },
                    {
                        "username": "rohitrangde",
                        "content": "Wrong Answer\\n\\nInput\\ns =\\n\"aacabdkacaa\"\\n\\nOutput\\n\"aacakacaa\"\\nExpected\\n\"aca\"\\n\\nis it wrong output ?\\n"
                    },
                    {
                        "username": "KaleemRazaSyedJ",
                        "content": "Your answer is aacakacaa is incorrect because we are asked for substring not subsequence."
                    },
                    {
                        "username": "anj20",
                        "content": "can we do this in a tc better than O(N^2)?"
                    },
                    {
                        "username": "espinosarennieljun",
                        "content": "I always ended up hitting the time limit exceeded error. "
                    },
                    {
                        "username": "PrashanthVR",
                        "content": "For one particular testcase while submitting, the compiler shows run time exceeded. But when I give that particular test case manually, it passes. HOw?\\n\\n"
                    },
                    {
                        "username": "joinfanng",
                        "content": "how the testcase \"ac\" works???\\nideally it should return nuthimg"
                    },
                    {
                        "username": "chibi_chihiro",
                        "content": "You can just use brute force if you are struggling :p"
                    },
                    {
                        "username": "balakrishna_95",
                        "content": "class Solution {\\n\\t  static boolean h(String s)\\n    {\\n    \\tString j=\"\";\\n    \\tfor(int i=s.length()-1;i>=0;i--)\\n    \\t{\\n    \\t\\tj=j+s.charAt(i);\\n    \\t}\\n    \\tif(j.equals(s))\\n    \\t{\\n    \\t\\treturn true;\\n    \\t}\\n    \\treturn false;\\n    }\\n\\tpublic String longestPalindrome(String s){\\n        int max=1;\\n        int start=0;\\n        for(int i=0;i<s.length();i++)\\n        {\\n        \\tfor(int j=i;j<s.length();j++)\\n        \\t{\\n        \\t\\tif(h(s.substring(i,j+1)))\\n        \\t\\t{\\n        \\t\\t\\tif(j-i+1>max)\\n        \\t\\t\\t{\\n        \\t\\t\\t  start=i;\\n        \\t\\t\\t  max=j-i+1;\\n        \\t\\t\\t}\\n        \\t\\t}\\n        \\t}\\n        }\\n\\t\\treturn s.substring(start,start+max);\\n\\t}\\n}\\n"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "balakrishna_95",
                        "content": "why my code is not working for all the test case\\n"
                    },
                    {
                        "username": "SlowCodiee",
                        "content": "Please specify in the question what should I return if there are no valid palindrome substring"
                    }
                ]
            },
            {
                "id": 1878146,
                "content": [
                    {
                        "username": "user7351F",
                        "content": "class Solution {\\n    public String longestPalindrome(String s) {\\n    int i = 0;\\n     if(1 <= s.length() && s.length() <= 1000){\\n       if(s.length() == 1 || s.length() == 0){\\n           return s;\\n       }\\n       if(isPalindrome(s)){\\n         String new_str = s.substring(i+1,s.length()-1);\\n         longestPalindrome(new_str);\\n         \\n         \\n       } \\n       else{\\n           String new_str1 = s.substring(i,s.length()-1); \\n          longestPalindrome(new_str1);\\n          \\n          \\n       } \\n     }\\n     return s;\\n    }\\n     boolean isPalindrome(String s1){\\n       int a = 0;\\n       int j = s1.length() - 1;\\n       while(a <= j){\\n         if(s1.charAt(a) != s1.charAt(j)){\\n           return false;\\n         }\\n         \\n         a++;\\n         j--;\\n       }\\n       return true;\\n     }  \\n}\\nCAn someone explain what is wrong in my code?"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Posting your solution in discussions is wrong"
                    },
                    {
                        "username": "Mookambika8",
                        "content": "Hello Leetcoders,\\n\\nI have a basic question in the understanding of the logic that needs to be followed for solving this problem without brute force.\\n\\nI have the below approach in mind:\\n\\nwhen you get the longest length, \\n1. we need to get the palindrome with that length.\\n2. We need to reduce length to be checked by -1\\n3. shift left the window by 1 by fixing the end and moving only left index by 1 until there is only value 1 difference between start and end while end > start\\n4. shift left the window by 1 by fixing the end and moving only right index by 1 until there is only value 1 difference between start and end while end > start\\n5. the above to loop around until we have the i reaching end of the string.\\n\\nCan you please review this approach and let me know if this is good enough for the solution or I got the whole idea wrong."
                    },
                    {
                        "username": "KaleemRazaSyedJ",
                        "content": "How are you finding the length of the longest paldromic substring?\n"
                    },
                    {
                        "username": "rohitrangde",
                        "content": "Wrong Answer\\n\\nInput\\ns =\\n\"aacabdkacaa\"\\n\\nOutput\\n\"aacakacaa\"\\nExpected\\n\"aca\"\\n\\nis it wrong output ?\\n"
                    },
                    {
                        "username": "KaleemRazaSyedJ",
                        "content": "Your answer is aacakacaa is incorrect because we are asked for substring not subsequence."
                    },
                    {
                        "username": "anj20",
                        "content": "can we do this in a tc better than O(N^2)?"
                    },
                    {
                        "username": "espinosarennieljun",
                        "content": "I always ended up hitting the time limit exceeded error. "
                    },
                    {
                        "username": "PrashanthVR",
                        "content": "For one particular testcase while submitting, the compiler shows run time exceeded. But when I give that particular test case manually, it passes. HOw?\\n\\n"
                    },
                    {
                        "username": "joinfanng",
                        "content": "how the testcase \"ac\" works???\\nideally it should return nuthimg"
                    },
                    {
                        "username": "chibi_chihiro",
                        "content": "You can just use brute force if you are struggling :p"
                    },
                    {
                        "username": "balakrishna_95",
                        "content": "class Solution {\\n\\t  static boolean h(String s)\\n    {\\n    \\tString j=\"\";\\n    \\tfor(int i=s.length()-1;i>=0;i--)\\n    \\t{\\n    \\t\\tj=j+s.charAt(i);\\n    \\t}\\n    \\tif(j.equals(s))\\n    \\t{\\n    \\t\\treturn true;\\n    \\t}\\n    \\treturn false;\\n    }\\n\\tpublic String longestPalindrome(String s){\\n        int max=1;\\n        int start=0;\\n        for(int i=0;i<s.length();i++)\\n        {\\n        \\tfor(int j=i;j<s.length();j++)\\n        \\t{\\n        \\t\\tif(h(s.substring(i,j+1)))\\n        \\t\\t{\\n        \\t\\t\\tif(j-i+1>max)\\n        \\t\\t\\t{\\n        \\t\\t\\t  start=i;\\n        \\t\\t\\t  max=j-i+1;\\n        \\t\\t\\t}\\n        \\t\\t}\\n        \\t}\\n        }\\n\\t\\treturn s.substring(start,start+max);\\n\\t}\\n}\\n"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "balakrishna_95",
                        "content": "why my code is not working for all the test case\\n"
                    },
                    {
                        "username": "SlowCodiee",
                        "content": "Please specify in the question what should I return if there are no valid palindrome substring"
                    }
                ]
            },
            {
                "id": 1876690,
                "content": [
                    {
                        "username": "user7351F",
                        "content": "class Solution {\\n    public String longestPalindrome(String s) {\\n    int i = 0;\\n     if(1 <= s.length() && s.length() <= 1000){\\n       if(s.length() == 1 || s.length() == 0){\\n           return s;\\n       }\\n       if(isPalindrome(s)){\\n         String new_str = s.substring(i+1,s.length()-1);\\n         longestPalindrome(new_str);\\n         \\n         \\n       } \\n       else{\\n           String new_str1 = s.substring(i,s.length()-1); \\n          longestPalindrome(new_str1);\\n          \\n          \\n       } \\n     }\\n     return s;\\n    }\\n     boolean isPalindrome(String s1){\\n       int a = 0;\\n       int j = s1.length() - 1;\\n       while(a <= j){\\n         if(s1.charAt(a) != s1.charAt(j)){\\n           return false;\\n         }\\n         \\n         a++;\\n         j--;\\n       }\\n       return true;\\n     }  \\n}\\nCAn someone explain what is wrong in my code?"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Posting your solution in discussions is wrong"
                    },
                    {
                        "username": "Mookambika8",
                        "content": "Hello Leetcoders,\\n\\nI have a basic question in the understanding of the logic that needs to be followed for solving this problem without brute force.\\n\\nI have the below approach in mind:\\n\\nwhen you get the longest length, \\n1. we need to get the palindrome with that length.\\n2. We need to reduce length to be checked by -1\\n3. shift left the window by 1 by fixing the end and moving only left index by 1 until there is only value 1 difference between start and end while end > start\\n4. shift left the window by 1 by fixing the end and moving only right index by 1 until there is only value 1 difference between start and end while end > start\\n5. the above to loop around until we have the i reaching end of the string.\\n\\nCan you please review this approach and let me know if this is good enough for the solution or I got the whole idea wrong."
                    },
                    {
                        "username": "KaleemRazaSyedJ",
                        "content": "How are you finding the length of the longest paldromic substring?\n"
                    },
                    {
                        "username": "rohitrangde",
                        "content": "Wrong Answer\\n\\nInput\\ns =\\n\"aacabdkacaa\"\\n\\nOutput\\n\"aacakacaa\"\\nExpected\\n\"aca\"\\n\\nis it wrong output ?\\n"
                    },
                    {
                        "username": "KaleemRazaSyedJ",
                        "content": "Your answer is aacakacaa is incorrect because we are asked for substring not subsequence."
                    },
                    {
                        "username": "anj20",
                        "content": "can we do this in a tc better than O(N^2)?"
                    },
                    {
                        "username": "espinosarennieljun",
                        "content": "I always ended up hitting the time limit exceeded error. "
                    },
                    {
                        "username": "PrashanthVR",
                        "content": "For one particular testcase while submitting, the compiler shows run time exceeded. But when I give that particular test case manually, it passes. HOw?\\n\\n"
                    },
                    {
                        "username": "joinfanng",
                        "content": "how the testcase \"ac\" works???\\nideally it should return nuthimg"
                    },
                    {
                        "username": "chibi_chihiro",
                        "content": "You can just use brute force if you are struggling :p"
                    },
                    {
                        "username": "balakrishna_95",
                        "content": "class Solution {\\n\\t  static boolean h(String s)\\n    {\\n    \\tString j=\"\";\\n    \\tfor(int i=s.length()-1;i>=0;i--)\\n    \\t{\\n    \\t\\tj=j+s.charAt(i);\\n    \\t}\\n    \\tif(j.equals(s))\\n    \\t{\\n    \\t\\treturn true;\\n    \\t}\\n    \\treturn false;\\n    }\\n\\tpublic String longestPalindrome(String s){\\n        int max=1;\\n        int start=0;\\n        for(int i=0;i<s.length();i++)\\n        {\\n        \\tfor(int j=i;j<s.length();j++)\\n        \\t{\\n        \\t\\tif(h(s.substring(i,j+1)))\\n        \\t\\t{\\n        \\t\\t\\tif(j-i+1>max)\\n        \\t\\t\\t{\\n        \\t\\t\\t  start=i;\\n        \\t\\t\\t  max=j-i+1;\\n        \\t\\t\\t}\\n        \\t\\t}\\n        \\t}\\n        }\\n\\t\\treturn s.substring(start,start+max);\\n\\t}\\n}\\n"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "balakrishna_95",
                        "content": "why my code is not working for all the test case\\n"
                    },
                    {
                        "username": "SlowCodiee",
                        "content": "Please specify in the question what should I return if there are no valid palindrome substring"
                    }
                ]
            },
            {
                "id": 1874541,
                "content": [
                    {
                        "username": "user7351F",
                        "content": "class Solution {\\n    public String longestPalindrome(String s) {\\n    int i = 0;\\n     if(1 <= s.length() && s.length() <= 1000){\\n       if(s.length() == 1 || s.length() == 0){\\n           return s;\\n       }\\n       if(isPalindrome(s)){\\n         String new_str = s.substring(i+1,s.length()-1);\\n         longestPalindrome(new_str);\\n         \\n         \\n       } \\n       else{\\n           String new_str1 = s.substring(i,s.length()-1); \\n          longestPalindrome(new_str1);\\n          \\n          \\n       } \\n     }\\n     return s;\\n    }\\n     boolean isPalindrome(String s1){\\n       int a = 0;\\n       int j = s1.length() - 1;\\n       while(a <= j){\\n         if(s1.charAt(a) != s1.charAt(j)){\\n           return false;\\n         }\\n         \\n         a++;\\n         j--;\\n       }\\n       return true;\\n     }  \\n}\\nCAn someone explain what is wrong in my code?"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Posting your solution in discussions is wrong"
                    },
                    {
                        "username": "Mookambika8",
                        "content": "Hello Leetcoders,\\n\\nI have a basic question in the understanding of the logic that needs to be followed for solving this problem without brute force.\\n\\nI have the below approach in mind:\\n\\nwhen you get the longest length, \\n1. we need to get the palindrome with that length.\\n2. We need to reduce length to be checked by -1\\n3. shift left the window by 1 by fixing the end and moving only left index by 1 until there is only value 1 difference between start and end while end > start\\n4. shift left the window by 1 by fixing the end and moving only right index by 1 until there is only value 1 difference between start and end while end > start\\n5. the above to loop around until we have the i reaching end of the string.\\n\\nCan you please review this approach and let me know if this is good enough for the solution or I got the whole idea wrong."
                    },
                    {
                        "username": "KaleemRazaSyedJ",
                        "content": "How are you finding the length of the longest paldromic substring?\n"
                    },
                    {
                        "username": "rohitrangde",
                        "content": "Wrong Answer\\n\\nInput\\ns =\\n\"aacabdkacaa\"\\n\\nOutput\\n\"aacakacaa\"\\nExpected\\n\"aca\"\\n\\nis it wrong output ?\\n"
                    },
                    {
                        "username": "KaleemRazaSyedJ",
                        "content": "Your answer is aacakacaa is incorrect because we are asked for substring not subsequence."
                    },
                    {
                        "username": "anj20",
                        "content": "can we do this in a tc better than O(N^2)?"
                    },
                    {
                        "username": "espinosarennieljun",
                        "content": "I always ended up hitting the time limit exceeded error. "
                    },
                    {
                        "username": "PrashanthVR",
                        "content": "For one particular testcase while submitting, the compiler shows run time exceeded. But when I give that particular test case manually, it passes. HOw?\\n\\n"
                    },
                    {
                        "username": "joinfanng",
                        "content": "how the testcase \"ac\" works???\\nideally it should return nuthimg"
                    },
                    {
                        "username": "chibi_chihiro",
                        "content": "You can just use brute force if you are struggling :p"
                    },
                    {
                        "username": "balakrishna_95",
                        "content": "class Solution {\\n\\t  static boolean h(String s)\\n    {\\n    \\tString j=\"\";\\n    \\tfor(int i=s.length()-1;i>=0;i--)\\n    \\t{\\n    \\t\\tj=j+s.charAt(i);\\n    \\t}\\n    \\tif(j.equals(s))\\n    \\t{\\n    \\t\\treturn true;\\n    \\t}\\n    \\treturn false;\\n    }\\n\\tpublic String longestPalindrome(String s){\\n        int max=1;\\n        int start=0;\\n        for(int i=0;i<s.length();i++)\\n        {\\n        \\tfor(int j=i;j<s.length();j++)\\n        \\t{\\n        \\t\\tif(h(s.substring(i,j+1)))\\n        \\t\\t{\\n        \\t\\t\\tif(j-i+1>max)\\n        \\t\\t\\t{\\n        \\t\\t\\t  start=i;\\n        \\t\\t\\t  max=j-i+1;\\n        \\t\\t\\t}\\n        \\t\\t}\\n        \\t}\\n        }\\n\\t\\treturn s.substring(start,start+max);\\n\\t}\\n}\\n"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "balakrishna_95",
                        "content": "why my code is not working for all the test case\\n"
                    },
                    {
                        "username": "SlowCodiee",
                        "content": "Please specify in the question what should I return if there are no valid palindrome substring"
                    }
                ]
            },
            {
                "id": 1870788,
                "content": [
                    {
                        "username": "ankush920",
                        "content": "\\nEXPLAINED TEXT || C++ || DYNAMIC PROGRAMMING\\nankush920\\n0\\nin a few seconds\\nIntuition\\ntake 2-d matrix of dp in which\\ni--> intial position and j --> final postion\\nsee all possible valid combination for palindrom and store it in this array\\n-> upper half of this array is not useful or invalid because i>j mean intial pos > final pos --> not valid\\n-> for i==j mean only one word and it is always palindromic\\n-> for j-i ==1 mean two word it is only palindromic when both char are same( s[i] == s[j])\\n\\n-> now main point for all other case :-\\n( understand my solution upto this point upvote it vro :) )\\nfor palindromic -> first pos char (i) and last pos char(j) must be equal and the portion in between then aslo need to be equal.\\n\\ni and using not traditional for loop and slightly modify it for only considred valid case ( i<=j)\\n\\n//for answer\\ni take two variable start and end store 0 ( mean first char of string in that (single char definately palindromic))\\n->for each palindrom case i check wheater\\ntheir j -i ( string length ) is greater then my ans lenght ( end - start) --> if it is then i change my start and end ( start =i ,end =j)\\n\\nnote * :-\\nfor string len >=1 --> answer>=1 and because of that i intially take length one not checking for one length\\n\\nApproach\\nbottom up dynamic programming\\n\\nComplexity\\nTime complexity:\\n0(n2)\\n\\nSpace complexity:\\n0(n2)\\n\\nCode\\n\\n//////  for explaination refer pep coding :)\\nclass Solution {\\npublic:\\nint dp[1000][1000];\\n    string longestPalindrome(string s) {\\n    \\n\\n    memset( dp,0, sizeof(dp));\\n     int i = 0 , j =0 ;\\n     int g =0, n = s.size();\\n     int start =0, end=0;\\n\\n if( n ==1)\\n   {  \\n   return s;  \\n}\\n     for( int g=0; g<n ;g++ )  /// gap \\n     {\\n         for( int i = 0 ,j=g ; i<n && j<n ;i++, j++ ) // covering all possible of i<j\\n         {\\n           \\n           if(i==j)\\n           {             \\n               dp[i][j] =1;\\n               continue;\\n           }\\n\\n           if(j-i==1 &&s[i]==s[j])\\n           {           \\n                dp[i][j] =1;\\n                \\n                if((j-i) >(end-start) )\\n                {\\n                     start =i;\\n                     end =j;\\n                }\\n                 \\n           continue;\\n           }\\n        \\n            \\n            if( s[i]==s[j] && dp[i+1][j-1]==1)\\n            { \\n                 dp[i][j] =1;\\n                \\n                if( j-i> (end-start) )\\n                {\\n                     start =i;\\n                     end =j;\\n                }\\n                  \\n            }\\n             \\n         }\\n     }\\n\\n     return s.substr(start, end+1-start);   \\n    }\\n};"
                    },
                    {
                        "username": "MiGameasa",
                        "content": "Hi, I'm kinda new and this is my code, it only work with palin string that 3 or less. Can someone point out how to fix this? \n\n```class Solution {\n    public String longestPalindrome(String s) {\n        int left=0, right=s.length()-1, temp = 0;\n        for(int i = 0; i < s.length(); i++){\n            for(int j = right; j > i; j--){\n                if(s.charAt(i) != s.charAt(j)){\n                    continue;\n                }else{\n                    left = i;\n                    right = j;\n                    temp = right;\n                    right--;\n                    break;\n                }\n            }\n        }\n\n        return s.substring(left, temp + 1);\n    }\n}"
                    },
                    {
                        "username": "Namasteydunia",
                        "content": "why it is not letting us use reverse() function in javascript. reverse() is a valid javascript function to reverse a string."
                    },
                    {
                        "username": "charucjoshi",
                        "content": "Can someone please explain why this is wrong?\\n\\nWrong Answer\\ns=\"aacabdkacaa\"\\nOutput\\n\"aacakacaa\"\\nExpected\\n\"aca\""
                    },
                    {
                        "username": "alphazwest",
                        "content": "For the first case, are not `abba` and `baab` both palindromic substrings -- both *longer* than the given solution output? "
                    },
                    {
                        "username": "harshitha____9",
                        "content": "why time limit exceeding?\\n\\nbool check(string s,int i,int j)\\n{\\n    \\n    while(i<=j)\\n    {\\n        if(s[i]!=s[j])\\n        {\\n            return false;\\n        }\\n        i++;\\n        j--;\\n    }\\n    return true;\\n}\\n void f(int i,int j,string&ans,string s)\\n {\\n     if(i>j) return;\\n     if(j<0) return;\\n    if(check(s,i,j))\\n    {\\n        if(ans.size()<(j-i+1))\\n        {\\n            ans=s.substr(i,j-i+1);\\n        }\\n        return;\\n    }\\n    \\n     f(i+1,j,ans,s);\\n     f(i,j-1,ans,s);\\n    \\n }\\n    string longestPalindrome(string s) {\\n        int i=0,j=s.size()-1;\\n        string ans=\"\";\\n        f(i,j,ans,s);\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "nishantwestside",
                        "content": "There seems to be an extra curly brace at the end of your code, which may be causing a syntax error. However, assuming that this is a typographical error, the most likely reason why your code is exceeding the limit is because the time complexity of the algorithm is high.\\n\\nThe code is using a recursive function to check all possible substrings in the input string s, and then checking if they are palindromes or not using the check() function. This approach has an exponential time complexity of O(2^n), where n is the length of the input string s.\\n\\nThis means that as the length of the input string grows, the number of recursive calls made by the algorithm also grows exponentially, leading to a potential stack overflow or timeout.\\n\\nTo optimize the algorithm, you can use dynamic programming or expand around the center approach to reduce the time complexity to O(n2).\\n\\nDynamic Programming Approach:\\n\\n- Define a boolean table of size n x n, where n is the length of the input string.\\n- Initialize all cells in the table to false.\\n- Set all cells (i, i) to true, since a single character is always a palindrome.\\n- For all pairs of indices i, j where i < j, set table[i][j] to true if s[i] == s[j] and table[i+1][j-1] is also true. - This means that a substring from i to j is a palindrome if its first and last characters are equal, and its - inner substring is also a palindrome.\\n- Keep track of the longest palindrome found so far and its starting and ending indices."
                    },
                    {
                        "username": "optic188",
                        "content": "actually really curios about error one one of test cases \\nTime Limit Exceeded\\nnothing mentioned in desciption about complexity of algoritm or memeory using restrictions ? Why then this test case is not passing "
                    },
                    {
                        "username": "yashAryan",
                        "content": "Line 1061: Char 9: runtime error: addition of unsigned offset to 0x7fff8d8fc2b0 overflowed to 0x7fff8d8fc2af (basic_string.h)\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior /usr/bin/../lib/gcc/x86_64-linux-gnu/9/../../../../include/c++/9/bits/basic_string.h:1070:9\n\n\n\n\nI am facing this error. Can anyone tell me what's wrong with my code?  \n class Solution {\npublic:\n    string longestPalindrome(string s) {\n        string t=\"#\";\n    for(int i=0;i<s.size();i++)\n    {\n        t+=s[i];\n        t+=\"#\";\n    }\n    int n=t.size();\n    vector<int> v(n,0);\n    int c=0,mirr=0,r=0;\n    for(int i=1;i<t.size()-1;i++)\n    {\n        mirr=2*c-i;\n        if(i<r and mirr>=0)\n        {\n            v[i]=min(v[mirr],r-i);\n        }\n        while(t[i+v[i]+1]==t[i-v[i]-1])\n        {\n            v[i]++;\n        }\n        if(i+v[i]>r)\n        {\n            c=i;\n            r=i+v[i];\n        }\n    }\n    int index=max_element(v.begin(),v.end())-v.begin();\n    int value=v[index];\n    int start=index-value;\n    string f=t.substr(start,2*value);\n    f.erase(remove(f.begin(),f.end(),'#'),f.end());\n\n    return f;\n    }\n};\n\n[Link to the question](https://leetcode.com/problems/longest-palindromic-substring/description/)"
                    },
                    {
                        "username": "DavidLindon",
                        "content": "This problem is extremely poor since it isn\\'t obvious that all the test cases can easily be solved by expanding around center.\\n\\nWhat about \"bbbba\", output should be bbbb!"
                    },
                    {
                        "username": "harshitha____9",
                        "content": "string f(int i,int j,string ref,string s,string&ans)\\n {\\n     if(i>=j) return ref;\\n     if(s[i]==s[j])\\n     {\\n         i++;\\n         j--;\\n     }\\n     else if(s[i]!=s[j])\\n     {\\n         string l=f(i+1,j,ref.substr(i+1,j-i),s,ans);\\n         string r=f(i,j-1,ref.substr(i,j-i),s,ans);\\n         if(l.size()>r.size())\\n         {\\n             ans=l;\\n         }\\n         else\\n         {\\n             ans=r;\\n         }\\n     }\\n      \\n     return ref;\\n }\\n    string longestPalindrome(string s) {\\n        int i=0,j=s.size()-1;\\n        string c=s;\\n        string ans=\"\";\\n        f(i,j,c,s,ans);\\n        return ans;\\n    }\\nwhat is wrong with this code......"
                    }
                ]
            },
            {
                "id": 1870494,
                "content": [
                    {
                        "username": "ankush920",
                        "content": "\\nEXPLAINED TEXT || C++ || DYNAMIC PROGRAMMING\\nankush920\\n0\\nin a few seconds\\nIntuition\\ntake 2-d matrix of dp in which\\ni--> intial position and j --> final postion\\nsee all possible valid combination for palindrom and store it in this array\\n-> upper half of this array is not useful or invalid because i>j mean intial pos > final pos --> not valid\\n-> for i==j mean only one word and it is always palindromic\\n-> for j-i ==1 mean two word it is only palindromic when both char are same( s[i] == s[j])\\n\\n-> now main point for all other case :-\\n( understand my solution upto this point upvote it vro :) )\\nfor palindromic -> first pos char (i) and last pos char(j) must be equal and the portion in between then aslo need to be equal.\\n\\ni and using not traditional for loop and slightly modify it for only considred valid case ( i<=j)\\n\\n//for answer\\ni take two variable start and end store 0 ( mean first char of string in that (single char definately palindromic))\\n->for each palindrom case i check wheater\\ntheir j -i ( string length ) is greater then my ans lenght ( end - start) --> if it is then i change my start and end ( start =i ,end =j)\\n\\nnote * :-\\nfor string len >=1 --> answer>=1 and because of that i intially take length one not checking for one length\\n\\nApproach\\nbottom up dynamic programming\\n\\nComplexity\\nTime complexity:\\n0(n2)\\n\\nSpace complexity:\\n0(n2)\\n\\nCode\\n\\n//////  for explaination refer pep coding :)\\nclass Solution {\\npublic:\\nint dp[1000][1000];\\n    string longestPalindrome(string s) {\\n    \\n\\n    memset( dp,0, sizeof(dp));\\n     int i = 0 , j =0 ;\\n     int g =0, n = s.size();\\n     int start =0, end=0;\\n\\n if( n ==1)\\n   {  \\n   return s;  \\n}\\n     for( int g=0; g<n ;g++ )  /// gap \\n     {\\n         for( int i = 0 ,j=g ; i<n && j<n ;i++, j++ ) // covering all possible of i<j\\n         {\\n           \\n           if(i==j)\\n           {             \\n               dp[i][j] =1;\\n               continue;\\n           }\\n\\n           if(j-i==1 &&s[i]==s[j])\\n           {           \\n                dp[i][j] =1;\\n                \\n                if((j-i) >(end-start) )\\n                {\\n                     start =i;\\n                     end =j;\\n                }\\n                 \\n           continue;\\n           }\\n        \\n            \\n            if( s[i]==s[j] && dp[i+1][j-1]==1)\\n            { \\n                 dp[i][j] =1;\\n                \\n                if( j-i> (end-start) )\\n                {\\n                     start =i;\\n                     end =j;\\n                }\\n                  \\n            }\\n             \\n         }\\n     }\\n\\n     return s.substr(start, end+1-start);   \\n    }\\n};"
                    },
                    {
                        "username": "MiGameasa",
                        "content": "Hi, I'm kinda new and this is my code, it only work with palin string that 3 or less. Can someone point out how to fix this? \n\n```class Solution {\n    public String longestPalindrome(String s) {\n        int left=0, right=s.length()-1, temp = 0;\n        for(int i = 0; i < s.length(); i++){\n            for(int j = right; j > i; j--){\n                if(s.charAt(i) != s.charAt(j)){\n                    continue;\n                }else{\n                    left = i;\n                    right = j;\n                    temp = right;\n                    right--;\n                    break;\n                }\n            }\n        }\n\n        return s.substring(left, temp + 1);\n    }\n}"
                    },
                    {
                        "username": "Namasteydunia",
                        "content": "why it is not letting us use reverse() function in javascript. reverse() is a valid javascript function to reverse a string."
                    },
                    {
                        "username": "charucjoshi",
                        "content": "Can someone please explain why this is wrong?\\n\\nWrong Answer\\ns=\"aacabdkacaa\"\\nOutput\\n\"aacakacaa\"\\nExpected\\n\"aca\""
                    },
                    {
                        "username": "alphazwest",
                        "content": "For the first case, are not `abba` and `baab` both palindromic substrings -- both *longer* than the given solution output? "
                    },
                    {
                        "username": "harshitha____9",
                        "content": "why time limit exceeding?\\n\\nbool check(string s,int i,int j)\\n{\\n    \\n    while(i<=j)\\n    {\\n        if(s[i]!=s[j])\\n        {\\n            return false;\\n        }\\n        i++;\\n        j--;\\n    }\\n    return true;\\n}\\n void f(int i,int j,string&ans,string s)\\n {\\n     if(i>j) return;\\n     if(j<0) return;\\n    if(check(s,i,j))\\n    {\\n        if(ans.size()<(j-i+1))\\n        {\\n            ans=s.substr(i,j-i+1);\\n        }\\n        return;\\n    }\\n    \\n     f(i+1,j,ans,s);\\n     f(i,j-1,ans,s);\\n    \\n }\\n    string longestPalindrome(string s) {\\n        int i=0,j=s.size()-1;\\n        string ans=\"\";\\n        f(i,j,ans,s);\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "nishantwestside",
                        "content": "There seems to be an extra curly brace at the end of your code, which may be causing a syntax error. However, assuming that this is a typographical error, the most likely reason why your code is exceeding the limit is because the time complexity of the algorithm is high.\\n\\nThe code is using a recursive function to check all possible substrings in the input string s, and then checking if they are palindromes or not using the check() function. This approach has an exponential time complexity of O(2^n), where n is the length of the input string s.\\n\\nThis means that as the length of the input string grows, the number of recursive calls made by the algorithm also grows exponentially, leading to a potential stack overflow or timeout.\\n\\nTo optimize the algorithm, you can use dynamic programming or expand around the center approach to reduce the time complexity to O(n2).\\n\\nDynamic Programming Approach:\\n\\n- Define a boolean table of size n x n, where n is the length of the input string.\\n- Initialize all cells in the table to false.\\n- Set all cells (i, i) to true, since a single character is always a palindrome.\\n- For all pairs of indices i, j where i < j, set table[i][j] to true if s[i] == s[j] and table[i+1][j-1] is also true. - This means that a substring from i to j is a palindrome if its first and last characters are equal, and its - inner substring is also a palindrome.\\n- Keep track of the longest palindrome found so far and its starting and ending indices."
                    },
                    {
                        "username": "optic188",
                        "content": "actually really curios about error one one of test cases \\nTime Limit Exceeded\\nnothing mentioned in desciption about complexity of algoritm or memeory using restrictions ? Why then this test case is not passing "
                    },
                    {
                        "username": "yashAryan",
                        "content": "Line 1061: Char 9: runtime error: addition of unsigned offset to 0x7fff8d8fc2b0 overflowed to 0x7fff8d8fc2af (basic_string.h)\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior /usr/bin/../lib/gcc/x86_64-linux-gnu/9/../../../../include/c++/9/bits/basic_string.h:1070:9\n\n\n\n\nI am facing this error. Can anyone tell me what's wrong with my code?  \n class Solution {\npublic:\n    string longestPalindrome(string s) {\n        string t=\"#\";\n    for(int i=0;i<s.size();i++)\n    {\n        t+=s[i];\n        t+=\"#\";\n    }\n    int n=t.size();\n    vector<int> v(n,0);\n    int c=0,mirr=0,r=0;\n    for(int i=1;i<t.size()-1;i++)\n    {\n        mirr=2*c-i;\n        if(i<r and mirr>=0)\n        {\n            v[i]=min(v[mirr],r-i);\n        }\n        while(t[i+v[i]+1]==t[i-v[i]-1])\n        {\n            v[i]++;\n        }\n        if(i+v[i]>r)\n        {\n            c=i;\n            r=i+v[i];\n        }\n    }\n    int index=max_element(v.begin(),v.end())-v.begin();\n    int value=v[index];\n    int start=index-value;\n    string f=t.substr(start,2*value);\n    f.erase(remove(f.begin(),f.end(),'#'),f.end());\n\n    return f;\n    }\n};\n\n[Link to the question](https://leetcode.com/problems/longest-palindromic-substring/description/)"
                    },
                    {
                        "username": "DavidLindon",
                        "content": "This problem is extremely poor since it isn\\'t obvious that all the test cases can easily be solved by expanding around center.\\n\\nWhat about \"bbbba\", output should be bbbb!"
                    },
                    {
                        "username": "harshitha____9",
                        "content": "string f(int i,int j,string ref,string s,string&ans)\\n {\\n     if(i>=j) return ref;\\n     if(s[i]==s[j])\\n     {\\n         i++;\\n         j--;\\n     }\\n     else if(s[i]!=s[j])\\n     {\\n         string l=f(i+1,j,ref.substr(i+1,j-i),s,ans);\\n         string r=f(i,j-1,ref.substr(i,j-i),s,ans);\\n         if(l.size()>r.size())\\n         {\\n             ans=l;\\n         }\\n         else\\n         {\\n             ans=r;\\n         }\\n     }\\n      \\n     return ref;\\n }\\n    string longestPalindrome(string s) {\\n        int i=0,j=s.size()-1;\\n        string c=s;\\n        string ans=\"\";\\n        f(i,j,c,s,ans);\\n        return ans;\\n    }\\nwhat is wrong with this code......"
                    }
                ]
            },
            {
                "id": 1870190,
                "content": [
                    {
                        "username": "ankush920",
                        "content": "\\nEXPLAINED TEXT || C++ || DYNAMIC PROGRAMMING\\nankush920\\n0\\nin a few seconds\\nIntuition\\ntake 2-d matrix of dp in which\\ni--> intial position and j --> final postion\\nsee all possible valid combination for palindrom and store it in this array\\n-> upper half of this array is not useful or invalid because i>j mean intial pos > final pos --> not valid\\n-> for i==j mean only one word and it is always palindromic\\n-> for j-i ==1 mean two word it is only palindromic when both char are same( s[i] == s[j])\\n\\n-> now main point for all other case :-\\n( understand my solution upto this point upvote it vro :) )\\nfor palindromic -> first pos char (i) and last pos char(j) must be equal and the portion in between then aslo need to be equal.\\n\\ni and using not traditional for loop and slightly modify it for only considred valid case ( i<=j)\\n\\n//for answer\\ni take two variable start and end store 0 ( mean first char of string in that (single char definately palindromic))\\n->for each palindrom case i check wheater\\ntheir j -i ( string length ) is greater then my ans lenght ( end - start) --> if it is then i change my start and end ( start =i ,end =j)\\n\\nnote * :-\\nfor string len >=1 --> answer>=1 and because of that i intially take length one not checking for one length\\n\\nApproach\\nbottom up dynamic programming\\n\\nComplexity\\nTime complexity:\\n0(n2)\\n\\nSpace complexity:\\n0(n2)\\n\\nCode\\n\\n//////  for explaination refer pep coding :)\\nclass Solution {\\npublic:\\nint dp[1000][1000];\\n    string longestPalindrome(string s) {\\n    \\n\\n    memset( dp,0, sizeof(dp));\\n     int i = 0 , j =0 ;\\n     int g =0, n = s.size();\\n     int start =0, end=0;\\n\\n if( n ==1)\\n   {  \\n   return s;  \\n}\\n     for( int g=0; g<n ;g++ )  /// gap \\n     {\\n         for( int i = 0 ,j=g ; i<n && j<n ;i++, j++ ) // covering all possible of i<j\\n         {\\n           \\n           if(i==j)\\n           {             \\n               dp[i][j] =1;\\n               continue;\\n           }\\n\\n           if(j-i==1 &&s[i]==s[j])\\n           {           \\n                dp[i][j] =1;\\n                \\n                if((j-i) >(end-start) )\\n                {\\n                     start =i;\\n                     end =j;\\n                }\\n                 \\n           continue;\\n           }\\n        \\n            \\n            if( s[i]==s[j] && dp[i+1][j-1]==1)\\n            { \\n                 dp[i][j] =1;\\n                \\n                if( j-i> (end-start) )\\n                {\\n                     start =i;\\n                     end =j;\\n                }\\n                  \\n            }\\n             \\n         }\\n     }\\n\\n     return s.substr(start, end+1-start);   \\n    }\\n};"
                    },
                    {
                        "username": "MiGameasa",
                        "content": "Hi, I'm kinda new and this is my code, it only work with palin string that 3 or less. Can someone point out how to fix this? \n\n```class Solution {\n    public String longestPalindrome(String s) {\n        int left=0, right=s.length()-1, temp = 0;\n        for(int i = 0; i < s.length(); i++){\n            for(int j = right; j > i; j--){\n                if(s.charAt(i) != s.charAt(j)){\n                    continue;\n                }else{\n                    left = i;\n                    right = j;\n                    temp = right;\n                    right--;\n                    break;\n                }\n            }\n        }\n\n        return s.substring(left, temp + 1);\n    }\n}"
                    },
                    {
                        "username": "Namasteydunia",
                        "content": "why it is not letting us use reverse() function in javascript. reverse() is a valid javascript function to reverse a string."
                    },
                    {
                        "username": "charucjoshi",
                        "content": "Can someone please explain why this is wrong?\\n\\nWrong Answer\\ns=\"aacabdkacaa\"\\nOutput\\n\"aacakacaa\"\\nExpected\\n\"aca\""
                    },
                    {
                        "username": "alphazwest",
                        "content": "For the first case, are not `abba` and `baab` both palindromic substrings -- both *longer* than the given solution output? "
                    },
                    {
                        "username": "harshitha____9",
                        "content": "why time limit exceeding?\\n\\nbool check(string s,int i,int j)\\n{\\n    \\n    while(i<=j)\\n    {\\n        if(s[i]!=s[j])\\n        {\\n            return false;\\n        }\\n        i++;\\n        j--;\\n    }\\n    return true;\\n}\\n void f(int i,int j,string&ans,string s)\\n {\\n     if(i>j) return;\\n     if(j<0) return;\\n    if(check(s,i,j))\\n    {\\n        if(ans.size()<(j-i+1))\\n        {\\n            ans=s.substr(i,j-i+1);\\n        }\\n        return;\\n    }\\n    \\n     f(i+1,j,ans,s);\\n     f(i,j-1,ans,s);\\n    \\n }\\n    string longestPalindrome(string s) {\\n        int i=0,j=s.size()-1;\\n        string ans=\"\";\\n        f(i,j,ans,s);\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "nishantwestside",
                        "content": "There seems to be an extra curly brace at the end of your code, which may be causing a syntax error. However, assuming that this is a typographical error, the most likely reason why your code is exceeding the limit is because the time complexity of the algorithm is high.\\n\\nThe code is using a recursive function to check all possible substrings in the input string s, and then checking if they are palindromes or not using the check() function. This approach has an exponential time complexity of O(2^n), where n is the length of the input string s.\\n\\nThis means that as the length of the input string grows, the number of recursive calls made by the algorithm also grows exponentially, leading to a potential stack overflow or timeout.\\n\\nTo optimize the algorithm, you can use dynamic programming or expand around the center approach to reduce the time complexity to O(n2).\\n\\nDynamic Programming Approach:\\n\\n- Define a boolean table of size n x n, where n is the length of the input string.\\n- Initialize all cells in the table to false.\\n- Set all cells (i, i) to true, since a single character is always a palindrome.\\n- For all pairs of indices i, j where i < j, set table[i][j] to true if s[i] == s[j] and table[i+1][j-1] is also true. - This means that a substring from i to j is a palindrome if its first and last characters are equal, and its - inner substring is also a palindrome.\\n- Keep track of the longest palindrome found so far and its starting and ending indices."
                    },
                    {
                        "username": "optic188",
                        "content": "actually really curios about error one one of test cases \\nTime Limit Exceeded\\nnothing mentioned in desciption about complexity of algoritm or memeory using restrictions ? Why then this test case is not passing "
                    },
                    {
                        "username": "yashAryan",
                        "content": "Line 1061: Char 9: runtime error: addition of unsigned offset to 0x7fff8d8fc2b0 overflowed to 0x7fff8d8fc2af (basic_string.h)\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior /usr/bin/../lib/gcc/x86_64-linux-gnu/9/../../../../include/c++/9/bits/basic_string.h:1070:9\n\n\n\n\nI am facing this error. Can anyone tell me what's wrong with my code?  \n class Solution {\npublic:\n    string longestPalindrome(string s) {\n        string t=\"#\";\n    for(int i=0;i<s.size();i++)\n    {\n        t+=s[i];\n        t+=\"#\";\n    }\n    int n=t.size();\n    vector<int> v(n,0);\n    int c=0,mirr=0,r=0;\n    for(int i=1;i<t.size()-1;i++)\n    {\n        mirr=2*c-i;\n        if(i<r and mirr>=0)\n        {\n            v[i]=min(v[mirr],r-i);\n        }\n        while(t[i+v[i]+1]==t[i-v[i]-1])\n        {\n            v[i]++;\n        }\n        if(i+v[i]>r)\n        {\n            c=i;\n            r=i+v[i];\n        }\n    }\n    int index=max_element(v.begin(),v.end())-v.begin();\n    int value=v[index];\n    int start=index-value;\n    string f=t.substr(start,2*value);\n    f.erase(remove(f.begin(),f.end(),'#'),f.end());\n\n    return f;\n    }\n};\n\n[Link to the question](https://leetcode.com/problems/longest-palindromic-substring/description/)"
                    },
                    {
                        "username": "DavidLindon",
                        "content": "This problem is extremely poor since it isn\\'t obvious that all the test cases can easily be solved by expanding around center.\\n\\nWhat about \"bbbba\", output should be bbbb!"
                    },
                    {
                        "username": "harshitha____9",
                        "content": "string f(int i,int j,string ref,string s,string&ans)\\n {\\n     if(i>=j) return ref;\\n     if(s[i]==s[j])\\n     {\\n         i++;\\n         j--;\\n     }\\n     else if(s[i]!=s[j])\\n     {\\n         string l=f(i+1,j,ref.substr(i+1,j-i),s,ans);\\n         string r=f(i,j-1,ref.substr(i,j-i),s,ans);\\n         if(l.size()>r.size())\\n         {\\n             ans=l;\\n         }\\n         else\\n         {\\n             ans=r;\\n         }\\n     }\\n      \\n     return ref;\\n }\\n    string longestPalindrome(string s) {\\n        int i=0,j=s.size()-1;\\n        string c=s;\\n        string ans=\"\";\\n        f(i,j,c,s,ans);\\n        return ans;\\n    }\\nwhat is wrong with this code......"
                    }
                ]
            },
            {
                "id": 1862816,
                "content": [
                    {
                        "username": "ankush920",
                        "content": "\\nEXPLAINED TEXT || C++ || DYNAMIC PROGRAMMING\\nankush920\\n0\\nin a few seconds\\nIntuition\\ntake 2-d matrix of dp in which\\ni--> intial position and j --> final postion\\nsee all possible valid combination for palindrom and store it in this array\\n-> upper half of this array is not useful or invalid because i>j mean intial pos > final pos --> not valid\\n-> for i==j mean only one word and it is always palindromic\\n-> for j-i ==1 mean two word it is only palindromic when both char are same( s[i] == s[j])\\n\\n-> now main point for all other case :-\\n( understand my solution upto this point upvote it vro :) )\\nfor palindromic -> first pos char (i) and last pos char(j) must be equal and the portion in between then aslo need to be equal.\\n\\ni and using not traditional for loop and slightly modify it for only considred valid case ( i<=j)\\n\\n//for answer\\ni take two variable start and end store 0 ( mean first char of string in that (single char definately palindromic))\\n->for each palindrom case i check wheater\\ntheir j -i ( string length ) is greater then my ans lenght ( end - start) --> if it is then i change my start and end ( start =i ,end =j)\\n\\nnote * :-\\nfor string len >=1 --> answer>=1 and because of that i intially take length one not checking for one length\\n\\nApproach\\nbottom up dynamic programming\\n\\nComplexity\\nTime complexity:\\n0(n2)\\n\\nSpace complexity:\\n0(n2)\\n\\nCode\\n\\n//////  for explaination refer pep coding :)\\nclass Solution {\\npublic:\\nint dp[1000][1000];\\n    string longestPalindrome(string s) {\\n    \\n\\n    memset( dp,0, sizeof(dp));\\n     int i = 0 , j =0 ;\\n     int g =0, n = s.size();\\n     int start =0, end=0;\\n\\n if( n ==1)\\n   {  \\n   return s;  \\n}\\n     for( int g=0; g<n ;g++ )  /// gap \\n     {\\n         for( int i = 0 ,j=g ; i<n && j<n ;i++, j++ ) // covering all possible of i<j\\n         {\\n           \\n           if(i==j)\\n           {             \\n               dp[i][j] =1;\\n               continue;\\n           }\\n\\n           if(j-i==1 &&s[i]==s[j])\\n           {           \\n                dp[i][j] =1;\\n                \\n                if((j-i) >(end-start) )\\n                {\\n                     start =i;\\n                     end =j;\\n                }\\n                 \\n           continue;\\n           }\\n        \\n            \\n            if( s[i]==s[j] && dp[i+1][j-1]==1)\\n            { \\n                 dp[i][j] =1;\\n                \\n                if( j-i> (end-start) )\\n                {\\n                     start =i;\\n                     end =j;\\n                }\\n                  \\n            }\\n             \\n         }\\n     }\\n\\n     return s.substr(start, end+1-start);   \\n    }\\n};"
                    },
                    {
                        "username": "MiGameasa",
                        "content": "Hi, I'm kinda new and this is my code, it only work with palin string that 3 or less. Can someone point out how to fix this? \n\n```class Solution {\n    public String longestPalindrome(String s) {\n        int left=0, right=s.length()-1, temp = 0;\n        for(int i = 0; i < s.length(); i++){\n            for(int j = right; j > i; j--){\n                if(s.charAt(i) != s.charAt(j)){\n                    continue;\n                }else{\n                    left = i;\n                    right = j;\n                    temp = right;\n                    right--;\n                    break;\n                }\n            }\n        }\n\n        return s.substring(left, temp + 1);\n    }\n}"
                    },
                    {
                        "username": "Namasteydunia",
                        "content": "why it is not letting us use reverse() function in javascript. reverse() is a valid javascript function to reverse a string."
                    },
                    {
                        "username": "charucjoshi",
                        "content": "Can someone please explain why this is wrong?\\n\\nWrong Answer\\ns=\"aacabdkacaa\"\\nOutput\\n\"aacakacaa\"\\nExpected\\n\"aca\""
                    },
                    {
                        "username": "alphazwest",
                        "content": "For the first case, are not `abba` and `baab` both palindromic substrings -- both *longer* than the given solution output? "
                    },
                    {
                        "username": "harshitha____9",
                        "content": "why time limit exceeding?\\n\\nbool check(string s,int i,int j)\\n{\\n    \\n    while(i<=j)\\n    {\\n        if(s[i]!=s[j])\\n        {\\n            return false;\\n        }\\n        i++;\\n        j--;\\n    }\\n    return true;\\n}\\n void f(int i,int j,string&ans,string s)\\n {\\n     if(i>j) return;\\n     if(j<0) return;\\n    if(check(s,i,j))\\n    {\\n        if(ans.size()<(j-i+1))\\n        {\\n            ans=s.substr(i,j-i+1);\\n        }\\n        return;\\n    }\\n    \\n     f(i+1,j,ans,s);\\n     f(i,j-1,ans,s);\\n    \\n }\\n    string longestPalindrome(string s) {\\n        int i=0,j=s.size()-1;\\n        string ans=\"\";\\n        f(i,j,ans,s);\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "nishantwestside",
                        "content": "There seems to be an extra curly brace at the end of your code, which may be causing a syntax error. However, assuming that this is a typographical error, the most likely reason why your code is exceeding the limit is because the time complexity of the algorithm is high.\\n\\nThe code is using a recursive function to check all possible substrings in the input string s, and then checking if they are palindromes or not using the check() function. This approach has an exponential time complexity of O(2^n), where n is the length of the input string s.\\n\\nThis means that as the length of the input string grows, the number of recursive calls made by the algorithm also grows exponentially, leading to a potential stack overflow or timeout.\\n\\nTo optimize the algorithm, you can use dynamic programming or expand around the center approach to reduce the time complexity to O(n2).\\n\\nDynamic Programming Approach:\\n\\n- Define a boolean table of size n x n, where n is the length of the input string.\\n- Initialize all cells in the table to false.\\n- Set all cells (i, i) to true, since a single character is always a palindrome.\\n- For all pairs of indices i, j where i < j, set table[i][j] to true if s[i] == s[j] and table[i+1][j-1] is also true. - This means that a substring from i to j is a palindrome if its first and last characters are equal, and its - inner substring is also a palindrome.\\n- Keep track of the longest palindrome found so far and its starting and ending indices."
                    },
                    {
                        "username": "optic188",
                        "content": "actually really curios about error one one of test cases \\nTime Limit Exceeded\\nnothing mentioned in desciption about complexity of algoritm or memeory using restrictions ? Why then this test case is not passing "
                    },
                    {
                        "username": "yashAryan",
                        "content": "Line 1061: Char 9: runtime error: addition of unsigned offset to 0x7fff8d8fc2b0 overflowed to 0x7fff8d8fc2af (basic_string.h)\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior /usr/bin/../lib/gcc/x86_64-linux-gnu/9/../../../../include/c++/9/bits/basic_string.h:1070:9\n\n\n\n\nI am facing this error. Can anyone tell me what's wrong with my code?  \n class Solution {\npublic:\n    string longestPalindrome(string s) {\n        string t=\"#\";\n    for(int i=0;i<s.size();i++)\n    {\n        t+=s[i];\n        t+=\"#\";\n    }\n    int n=t.size();\n    vector<int> v(n,0);\n    int c=0,mirr=0,r=0;\n    for(int i=1;i<t.size()-1;i++)\n    {\n        mirr=2*c-i;\n        if(i<r and mirr>=0)\n        {\n            v[i]=min(v[mirr],r-i);\n        }\n        while(t[i+v[i]+1]==t[i-v[i]-1])\n        {\n            v[i]++;\n        }\n        if(i+v[i]>r)\n        {\n            c=i;\n            r=i+v[i];\n        }\n    }\n    int index=max_element(v.begin(),v.end())-v.begin();\n    int value=v[index];\n    int start=index-value;\n    string f=t.substr(start,2*value);\n    f.erase(remove(f.begin(),f.end(),'#'),f.end());\n\n    return f;\n    }\n};\n\n[Link to the question](https://leetcode.com/problems/longest-palindromic-substring/description/)"
                    },
                    {
                        "username": "DavidLindon",
                        "content": "This problem is extremely poor since it isn\\'t obvious that all the test cases can easily be solved by expanding around center.\\n\\nWhat about \"bbbba\", output should be bbbb!"
                    },
                    {
                        "username": "harshitha____9",
                        "content": "string f(int i,int j,string ref,string s,string&ans)\\n {\\n     if(i>=j) return ref;\\n     if(s[i]==s[j])\\n     {\\n         i++;\\n         j--;\\n     }\\n     else if(s[i]!=s[j])\\n     {\\n         string l=f(i+1,j,ref.substr(i+1,j-i),s,ans);\\n         string r=f(i,j-1,ref.substr(i,j-i),s,ans);\\n         if(l.size()>r.size())\\n         {\\n             ans=l;\\n         }\\n         else\\n         {\\n             ans=r;\\n         }\\n     }\\n      \\n     return ref;\\n }\\n    string longestPalindrome(string s) {\\n        int i=0,j=s.size()-1;\\n        string c=s;\\n        string ans=\"\";\\n        f(i,j,c,s,ans);\\n        return ans;\\n    }\\nwhat is wrong with this code......"
                    }
                ]
            },
            {
                "id": 1853707,
                "content": [
                    {
                        "username": "ankush920",
                        "content": "\\nEXPLAINED TEXT || C++ || DYNAMIC PROGRAMMING\\nankush920\\n0\\nin a few seconds\\nIntuition\\ntake 2-d matrix of dp in which\\ni--> intial position and j --> final postion\\nsee all possible valid combination for palindrom and store it in this array\\n-> upper half of this array is not useful or invalid because i>j mean intial pos > final pos --> not valid\\n-> for i==j mean only one word and it is always palindromic\\n-> for j-i ==1 mean two word it is only palindromic when both char are same( s[i] == s[j])\\n\\n-> now main point for all other case :-\\n( understand my solution upto this point upvote it vro :) )\\nfor palindromic -> first pos char (i) and last pos char(j) must be equal and the portion in between then aslo need to be equal.\\n\\ni and using not traditional for loop and slightly modify it for only considred valid case ( i<=j)\\n\\n//for answer\\ni take two variable start and end store 0 ( mean first char of string in that (single char definately palindromic))\\n->for each palindrom case i check wheater\\ntheir j -i ( string length ) is greater then my ans lenght ( end - start) --> if it is then i change my start and end ( start =i ,end =j)\\n\\nnote * :-\\nfor string len >=1 --> answer>=1 and because of that i intially take length one not checking for one length\\n\\nApproach\\nbottom up dynamic programming\\n\\nComplexity\\nTime complexity:\\n0(n2)\\n\\nSpace complexity:\\n0(n2)\\n\\nCode\\n\\n//////  for explaination refer pep coding :)\\nclass Solution {\\npublic:\\nint dp[1000][1000];\\n    string longestPalindrome(string s) {\\n    \\n\\n    memset( dp,0, sizeof(dp));\\n     int i = 0 , j =0 ;\\n     int g =0, n = s.size();\\n     int start =0, end=0;\\n\\n if( n ==1)\\n   {  \\n   return s;  \\n}\\n     for( int g=0; g<n ;g++ )  /// gap \\n     {\\n         for( int i = 0 ,j=g ; i<n && j<n ;i++, j++ ) // covering all possible of i<j\\n         {\\n           \\n           if(i==j)\\n           {             \\n               dp[i][j] =1;\\n               continue;\\n           }\\n\\n           if(j-i==1 &&s[i]==s[j])\\n           {           \\n                dp[i][j] =1;\\n                \\n                if((j-i) >(end-start) )\\n                {\\n                     start =i;\\n                     end =j;\\n                }\\n                 \\n           continue;\\n           }\\n        \\n            \\n            if( s[i]==s[j] && dp[i+1][j-1]==1)\\n            { \\n                 dp[i][j] =1;\\n                \\n                if( j-i> (end-start) )\\n                {\\n                     start =i;\\n                     end =j;\\n                }\\n                  \\n            }\\n             \\n         }\\n     }\\n\\n     return s.substr(start, end+1-start);   \\n    }\\n};"
                    },
                    {
                        "username": "MiGameasa",
                        "content": "Hi, I'm kinda new and this is my code, it only work with palin string that 3 or less. Can someone point out how to fix this? \n\n```class Solution {\n    public String longestPalindrome(String s) {\n        int left=0, right=s.length()-1, temp = 0;\n        for(int i = 0; i < s.length(); i++){\n            for(int j = right; j > i; j--){\n                if(s.charAt(i) != s.charAt(j)){\n                    continue;\n                }else{\n                    left = i;\n                    right = j;\n                    temp = right;\n                    right--;\n                    break;\n                }\n            }\n        }\n\n        return s.substring(left, temp + 1);\n    }\n}"
                    },
                    {
                        "username": "Namasteydunia",
                        "content": "why it is not letting us use reverse() function in javascript. reverse() is a valid javascript function to reverse a string."
                    },
                    {
                        "username": "charucjoshi",
                        "content": "Can someone please explain why this is wrong?\\n\\nWrong Answer\\ns=\"aacabdkacaa\"\\nOutput\\n\"aacakacaa\"\\nExpected\\n\"aca\""
                    },
                    {
                        "username": "alphazwest",
                        "content": "For the first case, are not `abba` and `baab` both palindromic substrings -- both *longer* than the given solution output? "
                    },
                    {
                        "username": "harshitha____9",
                        "content": "why time limit exceeding?\\n\\nbool check(string s,int i,int j)\\n{\\n    \\n    while(i<=j)\\n    {\\n        if(s[i]!=s[j])\\n        {\\n            return false;\\n        }\\n        i++;\\n        j--;\\n    }\\n    return true;\\n}\\n void f(int i,int j,string&ans,string s)\\n {\\n     if(i>j) return;\\n     if(j<0) return;\\n    if(check(s,i,j))\\n    {\\n        if(ans.size()<(j-i+1))\\n        {\\n            ans=s.substr(i,j-i+1);\\n        }\\n        return;\\n    }\\n    \\n     f(i+1,j,ans,s);\\n     f(i,j-1,ans,s);\\n    \\n }\\n    string longestPalindrome(string s) {\\n        int i=0,j=s.size()-1;\\n        string ans=\"\";\\n        f(i,j,ans,s);\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "nishantwestside",
                        "content": "There seems to be an extra curly brace at the end of your code, which may be causing a syntax error. However, assuming that this is a typographical error, the most likely reason why your code is exceeding the limit is because the time complexity of the algorithm is high.\\n\\nThe code is using a recursive function to check all possible substrings in the input string s, and then checking if they are palindromes or not using the check() function. This approach has an exponential time complexity of O(2^n), where n is the length of the input string s.\\n\\nThis means that as the length of the input string grows, the number of recursive calls made by the algorithm also grows exponentially, leading to a potential stack overflow or timeout.\\n\\nTo optimize the algorithm, you can use dynamic programming or expand around the center approach to reduce the time complexity to O(n2).\\n\\nDynamic Programming Approach:\\n\\n- Define a boolean table of size n x n, where n is the length of the input string.\\n- Initialize all cells in the table to false.\\n- Set all cells (i, i) to true, since a single character is always a palindrome.\\n- For all pairs of indices i, j where i < j, set table[i][j] to true if s[i] == s[j] and table[i+1][j-1] is also true. - This means that a substring from i to j is a palindrome if its first and last characters are equal, and its - inner substring is also a palindrome.\\n- Keep track of the longest palindrome found so far and its starting and ending indices."
                    },
                    {
                        "username": "optic188",
                        "content": "actually really curios about error one one of test cases \\nTime Limit Exceeded\\nnothing mentioned in desciption about complexity of algoritm or memeory using restrictions ? Why then this test case is not passing "
                    },
                    {
                        "username": "yashAryan",
                        "content": "Line 1061: Char 9: runtime error: addition of unsigned offset to 0x7fff8d8fc2b0 overflowed to 0x7fff8d8fc2af (basic_string.h)\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior /usr/bin/../lib/gcc/x86_64-linux-gnu/9/../../../../include/c++/9/bits/basic_string.h:1070:9\n\n\n\n\nI am facing this error. Can anyone tell me what's wrong with my code?  \n class Solution {\npublic:\n    string longestPalindrome(string s) {\n        string t=\"#\";\n    for(int i=0;i<s.size();i++)\n    {\n        t+=s[i];\n        t+=\"#\";\n    }\n    int n=t.size();\n    vector<int> v(n,0);\n    int c=0,mirr=0,r=0;\n    for(int i=1;i<t.size()-1;i++)\n    {\n        mirr=2*c-i;\n        if(i<r and mirr>=0)\n        {\n            v[i]=min(v[mirr],r-i);\n        }\n        while(t[i+v[i]+1]==t[i-v[i]-1])\n        {\n            v[i]++;\n        }\n        if(i+v[i]>r)\n        {\n            c=i;\n            r=i+v[i];\n        }\n    }\n    int index=max_element(v.begin(),v.end())-v.begin();\n    int value=v[index];\n    int start=index-value;\n    string f=t.substr(start,2*value);\n    f.erase(remove(f.begin(),f.end(),'#'),f.end());\n\n    return f;\n    }\n};\n\n[Link to the question](https://leetcode.com/problems/longest-palindromic-substring/description/)"
                    },
                    {
                        "username": "DavidLindon",
                        "content": "This problem is extremely poor since it isn\\'t obvious that all the test cases can easily be solved by expanding around center.\\n\\nWhat about \"bbbba\", output should be bbbb!"
                    },
                    {
                        "username": "harshitha____9",
                        "content": "string f(int i,int j,string ref,string s,string&ans)\\n {\\n     if(i>=j) return ref;\\n     if(s[i]==s[j])\\n     {\\n         i++;\\n         j--;\\n     }\\n     else if(s[i]!=s[j])\\n     {\\n         string l=f(i+1,j,ref.substr(i+1,j-i),s,ans);\\n         string r=f(i,j-1,ref.substr(i,j-i),s,ans);\\n         if(l.size()>r.size())\\n         {\\n             ans=l;\\n         }\\n         else\\n         {\\n             ans=r;\\n         }\\n     }\\n      \\n     return ref;\\n }\\n    string longestPalindrome(string s) {\\n        int i=0,j=s.size()-1;\\n        string c=s;\\n        string ans=\"\";\\n        f(i,j,c,s,ans);\\n        return ans;\\n    }\\nwhat is wrong with this code......"
                    }
                ]
            },
            {
                "id": 1848242,
                "content": [
                    {
                        "username": "ankush920",
                        "content": "\\nEXPLAINED TEXT || C++ || DYNAMIC PROGRAMMING\\nankush920\\n0\\nin a few seconds\\nIntuition\\ntake 2-d matrix of dp in which\\ni--> intial position and j --> final postion\\nsee all possible valid combination for palindrom and store it in this array\\n-> upper half of this array is not useful or invalid because i>j mean intial pos > final pos --> not valid\\n-> for i==j mean only one word and it is always palindromic\\n-> for j-i ==1 mean two word it is only palindromic when both char are same( s[i] == s[j])\\n\\n-> now main point for all other case :-\\n( understand my solution upto this point upvote it vro :) )\\nfor palindromic -> first pos char (i) and last pos char(j) must be equal and the portion in between then aslo need to be equal.\\n\\ni and using not traditional for loop and slightly modify it for only considred valid case ( i<=j)\\n\\n//for answer\\ni take two variable start and end store 0 ( mean first char of string in that (single char definately palindromic))\\n->for each palindrom case i check wheater\\ntheir j -i ( string length ) is greater then my ans lenght ( end - start) --> if it is then i change my start and end ( start =i ,end =j)\\n\\nnote * :-\\nfor string len >=1 --> answer>=1 and because of that i intially take length one not checking for one length\\n\\nApproach\\nbottom up dynamic programming\\n\\nComplexity\\nTime complexity:\\n0(n2)\\n\\nSpace complexity:\\n0(n2)\\n\\nCode\\n\\n//////  for explaination refer pep coding :)\\nclass Solution {\\npublic:\\nint dp[1000][1000];\\n    string longestPalindrome(string s) {\\n    \\n\\n    memset( dp,0, sizeof(dp));\\n     int i = 0 , j =0 ;\\n     int g =0, n = s.size();\\n     int start =0, end=0;\\n\\n if( n ==1)\\n   {  \\n   return s;  \\n}\\n     for( int g=0; g<n ;g++ )  /// gap \\n     {\\n         for( int i = 0 ,j=g ; i<n && j<n ;i++, j++ ) // covering all possible of i<j\\n         {\\n           \\n           if(i==j)\\n           {             \\n               dp[i][j] =1;\\n               continue;\\n           }\\n\\n           if(j-i==1 &&s[i]==s[j])\\n           {           \\n                dp[i][j] =1;\\n                \\n                if((j-i) >(end-start) )\\n                {\\n                     start =i;\\n                     end =j;\\n                }\\n                 \\n           continue;\\n           }\\n        \\n            \\n            if( s[i]==s[j] && dp[i+1][j-1]==1)\\n            { \\n                 dp[i][j] =1;\\n                \\n                if( j-i> (end-start) )\\n                {\\n                     start =i;\\n                     end =j;\\n                }\\n                  \\n            }\\n             \\n         }\\n     }\\n\\n     return s.substr(start, end+1-start);   \\n    }\\n};"
                    },
                    {
                        "username": "MiGameasa",
                        "content": "Hi, I'm kinda new and this is my code, it only work with palin string that 3 or less. Can someone point out how to fix this? \n\n```class Solution {\n    public String longestPalindrome(String s) {\n        int left=0, right=s.length()-1, temp = 0;\n        for(int i = 0; i < s.length(); i++){\n            for(int j = right; j > i; j--){\n                if(s.charAt(i) != s.charAt(j)){\n                    continue;\n                }else{\n                    left = i;\n                    right = j;\n                    temp = right;\n                    right--;\n                    break;\n                }\n            }\n        }\n\n        return s.substring(left, temp + 1);\n    }\n}"
                    },
                    {
                        "username": "Namasteydunia",
                        "content": "why it is not letting us use reverse() function in javascript. reverse() is a valid javascript function to reverse a string."
                    },
                    {
                        "username": "charucjoshi",
                        "content": "Can someone please explain why this is wrong?\\n\\nWrong Answer\\ns=\"aacabdkacaa\"\\nOutput\\n\"aacakacaa\"\\nExpected\\n\"aca\""
                    },
                    {
                        "username": "alphazwest",
                        "content": "For the first case, are not `abba` and `baab` both palindromic substrings -- both *longer* than the given solution output? "
                    },
                    {
                        "username": "harshitha____9",
                        "content": "why time limit exceeding?\\n\\nbool check(string s,int i,int j)\\n{\\n    \\n    while(i<=j)\\n    {\\n        if(s[i]!=s[j])\\n        {\\n            return false;\\n        }\\n        i++;\\n        j--;\\n    }\\n    return true;\\n}\\n void f(int i,int j,string&ans,string s)\\n {\\n     if(i>j) return;\\n     if(j<0) return;\\n    if(check(s,i,j))\\n    {\\n        if(ans.size()<(j-i+1))\\n        {\\n            ans=s.substr(i,j-i+1);\\n        }\\n        return;\\n    }\\n    \\n     f(i+1,j,ans,s);\\n     f(i,j-1,ans,s);\\n    \\n }\\n    string longestPalindrome(string s) {\\n        int i=0,j=s.size()-1;\\n        string ans=\"\";\\n        f(i,j,ans,s);\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "nishantwestside",
                        "content": "There seems to be an extra curly brace at the end of your code, which may be causing a syntax error. However, assuming that this is a typographical error, the most likely reason why your code is exceeding the limit is because the time complexity of the algorithm is high.\\n\\nThe code is using a recursive function to check all possible substrings in the input string s, and then checking if they are palindromes or not using the check() function. This approach has an exponential time complexity of O(2^n), where n is the length of the input string s.\\n\\nThis means that as the length of the input string grows, the number of recursive calls made by the algorithm also grows exponentially, leading to a potential stack overflow or timeout.\\n\\nTo optimize the algorithm, you can use dynamic programming or expand around the center approach to reduce the time complexity to O(n2).\\n\\nDynamic Programming Approach:\\n\\n- Define a boolean table of size n x n, where n is the length of the input string.\\n- Initialize all cells in the table to false.\\n- Set all cells (i, i) to true, since a single character is always a palindrome.\\n- For all pairs of indices i, j where i < j, set table[i][j] to true if s[i] == s[j] and table[i+1][j-1] is also true. - This means that a substring from i to j is a palindrome if its first and last characters are equal, and its - inner substring is also a palindrome.\\n- Keep track of the longest palindrome found so far and its starting and ending indices."
                    },
                    {
                        "username": "optic188",
                        "content": "actually really curios about error one one of test cases \\nTime Limit Exceeded\\nnothing mentioned in desciption about complexity of algoritm or memeory using restrictions ? Why then this test case is not passing "
                    },
                    {
                        "username": "yashAryan",
                        "content": "Line 1061: Char 9: runtime error: addition of unsigned offset to 0x7fff8d8fc2b0 overflowed to 0x7fff8d8fc2af (basic_string.h)\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior /usr/bin/../lib/gcc/x86_64-linux-gnu/9/../../../../include/c++/9/bits/basic_string.h:1070:9\n\n\n\n\nI am facing this error. Can anyone tell me what's wrong with my code?  \n class Solution {\npublic:\n    string longestPalindrome(string s) {\n        string t=\"#\";\n    for(int i=0;i<s.size();i++)\n    {\n        t+=s[i];\n        t+=\"#\";\n    }\n    int n=t.size();\n    vector<int> v(n,0);\n    int c=0,mirr=0,r=0;\n    for(int i=1;i<t.size()-1;i++)\n    {\n        mirr=2*c-i;\n        if(i<r and mirr>=0)\n        {\n            v[i]=min(v[mirr],r-i);\n        }\n        while(t[i+v[i]+1]==t[i-v[i]-1])\n        {\n            v[i]++;\n        }\n        if(i+v[i]>r)\n        {\n            c=i;\n            r=i+v[i];\n        }\n    }\n    int index=max_element(v.begin(),v.end())-v.begin();\n    int value=v[index];\n    int start=index-value;\n    string f=t.substr(start,2*value);\n    f.erase(remove(f.begin(),f.end(),'#'),f.end());\n\n    return f;\n    }\n};\n\n[Link to the question](https://leetcode.com/problems/longest-palindromic-substring/description/)"
                    },
                    {
                        "username": "DavidLindon",
                        "content": "This problem is extremely poor since it isn\\'t obvious that all the test cases can easily be solved by expanding around center.\\n\\nWhat about \"bbbba\", output should be bbbb!"
                    },
                    {
                        "username": "harshitha____9",
                        "content": "string f(int i,int j,string ref,string s,string&ans)\\n {\\n     if(i>=j) return ref;\\n     if(s[i]==s[j])\\n     {\\n         i++;\\n         j--;\\n     }\\n     else if(s[i]!=s[j])\\n     {\\n         string l=f(i+1,j,ref.substr(i+1,j-i),s,ans);\\n         string r=f(i,j-1,ref.substr(i,j-i),s,ans);\\n         if(l.size()>r.size())\\n         {\\n             ans=l;\\n         }\\n         else\\n         {\\n             ans=r;\\n         }\\n     }\\n      \\n     return ref;\\n }\\n    string longestPalindrome(string s) {\\n        int i=0,j=s.size()-1;\\n        string c=s;\\n        string ans=\"\";\\n        f(i,j,c,s,ans);\\n        return ans;\\n    }\\nwhat is wrong with this code......"
                    }
                ]
            },
            {
                "id": 1845223,
                "content": [
                    {
                        "username": "ankush920",
                        "content": "\\nEXPLAINED TEXT || C++ || DYNAMIC PROGRAMMING\\nankush920\\n0\\nin a few seconds\\nIntuition\\ntake 2-d matrix of dp in which\\ni--> intial position and j --> final postion\\nsee all possible valid combination for palindrom and store it in this array\\n-> upper half of this array is not useful or invalid because i>j mean intial pos > final pos --> not valid\\n-> for i==j mean only one word and it is always palindromic\\n-> for j-i ==1 mean two word it is only palindromic when both char are same( s[i] == s[j])\\n\\n-> now main point for all other case :-\\n( understand my solution upto this point upvote it vro :) )\\nfor palindromic -> first pos char (i) and last pos char(j) must be equal and the portion in between then aslo need to be equal.\\n\\ni and using not traditional for loop and slightly modify it for only considred valid case ( i<=j)\\n\\n//for answer\\ni take two variable start and end store 0 ( mean first char of string in that (single char definately palindromic))\\n->for each palindrom case i check wheater\\ntheir j -i ( string length ) is greater then my ans lenght ( end - start) --> if it is then i change my start and end ( start =i ,end =j)\\n\\nnote * :-\\nfor string len >=1 --> answer>=1 and because of that i intially take length one not checking for one length\\n\\nApproach\\nbottom up dynamic programming\\n\\nComplexity\\nTime complexity:\\n0(n2)\\n\\nSpace complexity:\\n0(n2)\\n\\nCode\\n\\n//////  for explaination refer pep coding :)\\nclass Solution {\\npublic:\\nint dp[1000][1000];\\n    string longestPalindrome(string s) {\\n    \\n\\n    memset( dp,0, sizeof(dp));\\n     int i = 0 , j =0 ;\\n     int g =0, n = s.size();\\n     int start =0, end=0;\\n\\n if( n ==1)\\n   {  \\n   return s;  \\n}\\n     for( int g=0; g<n ;g++ )  /// gap \\n     {\\n         for( int i = 0 ,j=g ; i<n && j<n ;i++, j++ ) // covering all possible of i<j\\n         {\\n           \\n           if(i==j)\\n           {             \\n               dp[i][j] =1;\\n               continue;\\n           }\\n\\n           if(j-i==1 &&s[i]==s[j])\\n           {           \\n                dp[i][j] =1;\\n                \\n                if((j-i) >(end-start) )\\n                {\\n                     start =i;\\n                     end =j;\\n                }\\n                 \\n           continue;\\n           }\\n        \\n            \\n            if( s[i]==s[j] && dp[i+1][j-1]==1)\\n            { \\n                 dp[i][j] =1;\\n                \\n                if( j-i> (end-start) )\\n                {\\n                     start =i;\\n                     end =j;\\n                }\\n                  \\n            }\\n             \\n         }\\n     }\\n\\n     return s.substr(start, end+1-start);   \\n    }\\n};"
                    },
                    {
                        "username": "MiGameasa",
                        "content": "Hi, I'm kinda new and this is my code, it only work with palin string that 3 or less. Can someone point out how to fix this? \n\n```class Solution {\n    public String longestPalindrome(String s) {\n        int left=0, right=s.length()-1, temp = 0;\n        for(int i = 0; i < s.length(); i++){\n            for(int j = right; j > i; j--){\n                if(s.charAt(i) != s.charAt(j)){\n                    continue;\n                }else{\n                    left = i;\n                    right = j;\n                    temp = right;\n                    right--;\n                    break;\n                }\n            }\n        }\n\n        return s.substring(left, temp + 1);\n    }\n}"
                    },
                    {
                        "username": "Namasteydunia",
                        "content": "why it is not letting us use reverse() function in javascript. reverse() is a valid javascript function to reverse a string."
                    },
                    {
                        "username": "charucjoshi",
                        "content": "Can someone please explain why this is wrong?\\n\\nWrong Answer\\ns=\"aacabdkacaa\"\\nOutput\\n\"aacakacaa\"\\nExpected\\n\"aca\""
                    },
                    {
                        "username": "alphazwest",
                        "content": "For the first case, are not `abba` and `baab` both palindromic substrings -- both *longer* than the given solution output? "
                    },
                    {
                        "username": "harshitha____9",
                        "content": "why time limit exceeding?\\n\\nbool check(string s,int i,int j)\\n{\\n    \\n    while(i<=j)\\n    {\\n        if(s[i]!=s[j])\\n        {\\n            return false;\\n        }\\n        i++;\\n        j--;\\n    }\\n    return true;\\n}\\n void f(int i,int j,string&ans,string s)\\n {\\n     if(i>j) return;\\n     if(j<0) return;\\n    if(check(s,i,j))\\n    {\\n        if(ans.size()<(j-i+1))\\n        {\\n            ans=s.substr(i,j-i+1);\\n        }\\n        return;\\n    }\\n    \\n     f(i+1,j,ans,s);\\n     f(i,j-1,ans,s);\\n    \\n }\\n    string longestPalindrome(string s) {\\n        int i=0,j=s.size()-1;\\n        string ans=\"\";\\n        f(i,j,ans,s);\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "nishantwestside",
                        "content": "There seems to be an extra curly brace at the end of your code, which may be causing a syntax error. However, assuming that this is a typographical error, the most likely reason why your code is exceeding the limit is because the time complexity of the algorithm is high.\\n\\nThe code is using a recursive function to check all possible substrings in the input string s, and then checking if they are palindromes or not using the check() function. This approach has an exponential time complexity of O(2^n), where n is the length of the input string s.\\n\\nThis means that as the length of the input string grows, the number of recursive calls made by the algorithm also grows exponentially, leading to a potential stack overflow or timeout.\\n\\nTo optimize the algorithm, you can use dynamic programming or expand around the center approach to reduce the time complexity to O(n2).\\n\\nDynamic Programming Approach:\\n\\n- Define a boolean table of size n x n, where n is the length of the input string.\\n- Initialize all cells in the table to false.\\n- Set all cells (i, i) to true, since a single character is always a palindrome.\\n- For all pairs of indices i, j where i < j, set table[i][j] to true if s[i] == s[j] and table[i+1][j-1] is also true. - This means that a substring from i to j is a palindrome if its first and last characters are equal, and its - inner substring is also a palindrome.\\n- Keep track of the longest palindrome found so far and its starting and ending indices."
                    },
                    {
                        "username": "optic188",
                        "content": "actually really curios about error one one of test cases \\nTime Limit Exceeded\\nnothing mentioned in desciption about complexity of algoritm or memeory using restrictions ? Why then this test case is not passing "
                    },
                    {
                        "username": "yashAryan",
                        "content": "Line 1061: Char 9: runtime error: addition of unsigned offset to 0x7fff8d8fc2b0 overflowed to 0x7fff8d8fc2af (basic_string.h)\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior /usr/bin/../lib/gcc/x86_64-linux-gnu/9/../../../../include/c++/9/bits/basic_string.h:1070:9\n\n\n\n\nI am facing this error. Can anyone tell me what's wrong with my code?  \n class Solution {\npublic:\n    string longestPalindrome(string s) {\n        string t=\"#\";\n    for(int i=0;i<s.size();i++)\n    {\n        t+=s[i];\n        t+=\"#\";\n    }\n    int n=t.size();\n    vector<int> v(n,0);\n    int c=0,mirr=0,r=0;\n    for(int i=1;i<t.size()-1;i++)\n    {\n        mirr=2*c-i;\n        if(i<r and mirr>=0)\n        {\n            v[i]=min(v[mirr],r-i);\n        }\n        while(t[i+v[i]+1]==t[i-v[i]-1])\n        {\n            v[i]++;\n        }\n        if(i+v[i]>r)\n        {\n            c=i;\n            r=i+v[i];\n        }\n    }\n    int index=max_element(v.begin(),v.end())-v.begin();\n    int value=v[index];\n    int start=index-value;\n    string f=t.substr(start,2*value);\n    f.erase(remove(f.begin(),f.end(),'#'),f.end());\n\n    return f;\n    }\n};\n\n[Link to the question](https://leetcode.com/problems/longest-palindromic-substring/description/)"
                    },
                    {
                        "username": "DavidLindon",
                        "content": "This problem is extremely poor since it isn\\'t obvious that all the test cases can easily be solved by expanding around center.\\n\\nWhat about \"bbbba\", output should be bbbb!"
                    },
                    {
                        "username": "harshitha____9",
                        "content": "string f(int i,int j,string ref,string s,string&ans)\\n {\\n     if(i>=j) return ref;\\n     if(s[i]==s[j])\\n     {\\n         i++;\\n         j--;\\n     }\\n     else if(s[i]!=s[j])\\n     {\\n         string l=f(i+1,j,ref.substr(i+1,j-i),s,ans);\\n         string r=f(i,j-1,ref.substr(i,j-i),s,ans);\\n         if(l.size()>r.size())\\n         {\\n             ans=l;\\n         }\\n         else\\n         {\\n             ans=r;\\n         }\\n     }\\n      \\n     return ref;\\n }\\n    string longestPalindrome(string s) {\\n        int i=0,j=s.size()-1;\\n        string c=s;\\n        string ans=\"\";\\n        f(i,j,c,s,ans);\\n        return ans;\\n    }\\nwhat is wrong with this code......"
                    }
                ]
            },
            {
                "id": 1845027,
                "content": [
                    {
                        "username": "ankush920",
                        "content": "\\nEXPLAINED TEXT || C++ || DYNAMIC PROGRAMMING\\nankush920\\n0\\nin a few seconds\\nIntuition\\ntake 2-d matrix of dp in which\\ni--> intial position and j --> final postion\\nsee all possible valid combination for palindrom and store it in this array\\n-> upper half of this array is not useful or invalid because i>j mean intial pos > final pos --> not valid\\n-> for i==j mean only one word and it is always palindromic\\n-> for j-i ==1 mean two word it is only palindromic when both char are same( s[i] == s[j])\\n\\n-> now main point for all other case :-\\n( understand my solution upto this point upvote it vro :) )\\nfor palindromic -> first pos char (i) and last pos char(j) must be equal and the portion in between then aslo need to be equal.\\n\\ni and using not traditional for loop and slightly modify it for only considred valid case ( i<=j)\\n\\n//for answer\\ni take two variable start and end store 0 ( mean first char of string in that (single char definately palindromic))\\n->for each palindrom case i check wheater\\ntheir j -i ( string length ) is greater then my ans lenght ( end - start) --> if it is then i change my start and end ( start =i ,end =j)\\n\\nnote * :-\\nfor string len >=1 --> answer>=1 and because of that i intially take length one not checking for one length\\n\\nApproach\\nbottom up dynamic programming\\n\\nComplexity\\nTime complexity:\\n0(n2)\\n\\nSpace complexity:\\n0(n2)\\n\\nCode\\n\\n//////  for explaination refer pep coding :)\\nclass Solution {\\npublic:\\nint dp[1000][1000];\\n    string longestPalindrome(string s) {\\n    \\n\\n    memset( dp,0, sizeof(dp));\\n     int i = 0 , j =0 ;\\n     int g =0, n = s.size();\\n     int start =0, end=0;\\n\\n if( n ==1)\\n   {  \\n   return s;  \\n}\\n     for( int g=0; g<n ;g++ )  /// gap \\n     {\\n         for( int i = 0 ,j=g ; i<n && j<n ;i++, j++ ) // covering all possible of i<j\\n         {\\n           \\n           if(i==j)\\n           {             \\n               dp[i][j] =1;\\n               continue;\\n           }\\n\\n           if(j-i==1 &&s[i]==s[j])\\n           {           \\n                dp[i][j] =1;\\n                \\n                if((j-i) >(end-start) )\\n                {\\n                     start =i;\\n                     end =j;\\n                }\\n                 \\n           continue;\\n           }\\n        \\n            \\n            if( s[i]==s[j] && dp[i+1][j-1]==1)\\n            { \\n                 dp[i][j] =1;\\n                \\n                if( j-i> (end-start) )\\n                {\\n                     start =i;\\n                     end =j;\\n                }\\n                  \\n            }\\n             \\n         }\\n     }\\n\\n     return s.substr(start, end+1-start);   \\n    }\\n};"
                    },
                    {
                        "username": "MiGameasa",
                        "content": "Hi, I'm kinda new and this is my code, it only work with palin string that 3 or less. Can someone point out how to fix this? \n\n```class Solution {\n    public String longestPalindrome(String s) {\n        int left=0, right=s.length()-1, temp = 0;\n        for(int i = 0; i < s.length(); i++){\n            for(int j = right; j > i; j--){\n                if(s.charAt(i) != s.charAt(j)){\n                    continue;\n                }else{\n                    left = i;\n                    right = j;\n                    temp = right;\n                    right--;\n                    break;\n                }\n            }\n        }\n\n        return s.substring(left, temp + 1);\n    }\n}"
                    },
                    {
                        "username": "Namasteydunia",
                        "content": "why it is not letting us use reverse() function in javascript. reverse() is a valid javascript function to reverse a string."
                    },
                    {
                        "username": "charucjoshi",
                        "content": "Can someone please explain why this is wrong?\\n\\nWrong Answer\\ns=\"aacabdkacaa\"\\nOutput\\n\"aacakacaa\"\\nExpected\\n\"aca\""
                    },
                    {
                        "username": "alphazwest",
                        "content": "For the first case, are not `abba` and `baab` both palindromic substrings -- both *longer* than the given solution output? "
                    },
                    {
                        "username": "harshitha____9",
                        "content": "why time limit exceeding?\\n\\nbool check(string s,int i,int j)\\n{\\n    \\n    while(i<=j)\\n    {\\n        if(s[i]!=s[j])\\n        {\\n            return false;\\n        }\\n        i++;\\n        j--;\\n    }\\n    return true;\\n}\\n void f(int i,int j,string&ans,string s)\\n {\\n     if(i>j) return;\\n     if(j<0) return;\\n    if(check(s,i,j))\\n    {\\n        if(ans.size()<(j-i+1))\\n        {\\n            ans=s.substr(i,j-i+1);\\n        }\\n        return;\\n    }\\n    \\n     f(i+1,j,ans,s);\\n     f(i,j-1,ans,s);\\n    \\n }\\n    string longestPalindrome(string s) {\\n        int i=0,j=s.size()-1;\\n        string ans=\"\";\\n        f(i,j,ans,s);\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "nishantwestside",
                        "content": "There seems to be an extra curly brace at the end of your code, which may be causing a syntax error. However, assuming that this is a typographical error, the most likely reason why your code is exceeding the limit is because the time complexity of the algorithm is high.\\n\\nThe code is using a recursive function to check all possible substrings in the input string s, and then checking if they are palindromes or not using the check() function. This approach has an exponential time complexity of O(2^n), where n is the length of the input string s.\\n\\nThis means that as the length of the input string grows, the number of recursive calls made by the algorithm also grows exponentially, leading to a potential stack overflow or timeout.\\n\\nTo optimize the algorithm, you can use dynamic programming or expand around the center approach to reduce the time complexity to O(n2).\\n\\nDynamic Programming Approach:\\n\\n- Define a boolean table of size n x n, where n is the length of the input string.\\n- Initialize all cells in the table to false.\\n- Set all cells (i, i) to true, since a single character is always a palindrome.\\n- For all pairs of indices i, j where i < j, set table[i][j] to true if s[i] == s[j] and table[i+1][j-1] is also true. - This means that a substring from i to j is a palindrome if its first and last characters are equal, and its - inner substring is also a palindrome.\\n- Keep track of the longest palindrome found so far and its starting and ending indices."
                    },
                    {
                        "username": "optic188",
                        "content": "actually really curios about error one one of test cases \\nTime Limit Exceeded\\nnothing mentioned in desciption about complexity of algoritm or memeory using restrictions ? Why then this test case is not passing "
                    },
                    {
                        "username": "yashAryan",
                        "content": "Line 1061: Char 9: runtime error: addition of unsigned offset to 0x7fff8d8fc2b0 overflowed to 0x7fff8d8fc2af (basic_string.h)\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior /usr/bin/../lib/gcc/x86_64-linux-gnu/9/../../../../include/c++/9/bits/basic_string.h:1070:9\n\n\n\n\nI am facing this error. Can anyone tell me what's wrong with my code?  \n class Solution {\npublic:\n    string longestPalindrome(string s) {\n        string t=\"#\";\n    for(int i=0;i<s.size();i++)\n    {\n        t+=s[i];\n        t+=\"#\";\n    }\n    int n=t.size();\n    vector<int> v(n,0);\n    int c=0,mirr=0,r=0;\n    for(int i=1;i<t.size()-1;i++)\n    {\n        mirr=2*c-i;\n        if(i<r and mirr>=0)\n        {\n            v[i]=min(v[mirr],r-i);\n        }\n        while(t[i+v[i]+1]==t[i-v[i]-1])\n        {\n            v[i]++;\n        }\n        if(i+v[i]>r)\n        {\n            c=i;\n            r=i+v[i];\n        }\n    }\n    int index=max_element(v.begin(),v.end())-v.begin();\n    int value=v[index];\n    int start=index-value;\n    string f=t.substr(start,2*value);\n    f.erase(remove(f.begin(),f.end(),'#'),f.end());\n\n    return f;\n    }\n};\n\n[Link to the question](https://leetcode.com/problems/longest-palindromic-substring/description/)"
                    },
                    {
                        "username": "DavidLindon",
                        "content": "This problem is extremely poor since it isn\\'t obvious that all the test cases can easily be solved by expanding around center.\\n\\nWhat about \"bbbba\", output should be bbbb!"
                    },
                    {
                        "username": "harshitha____9",
                        "content": "string f(int i,int j,string ref,string s,string&ans)\\n {\\n     if(i>=j) return ref;\\n     if(s[i]==s[j])\\n     {\\n         i++;\\n         j--;\\n     }\\n     else if(s[i]!=s[j])\\n     {\\n         string l=f(i+1,j,ref.substr(i+1,j-i),s,ans);\\n         string r=f(i,j-1,ref.substr(i,j-i),s,ans);\\n         if(l.size()>r.size())\\n         {\\n             ans=l;\\n         }\\n         else\\n         {\\n             ans=r;\\n         }\\n     }\\n      \\n     return ref;\\n }\\n    string longestPalindrome(string s) {\\n        int i=0,j=s.size()-1;\\n        string c=s;\\n        string ans=\"\";\\n        f(i,j,c,s,ans);\\n        return ans;\\n    }\\nwhat is wrong with this code......"
                    }
                ]
            },
            {
                "id": 1840601,
                "content": [
                    {
                        "username": "ankush920",
                        "content": "\\nEXPLAINED TEXT || C++ || DYNAMIC PROGRAMMING\\nankush920\\n0\\nin a few seconds\\nIntuition\\ntake 2-d matrix of dp in which\\ni--> intial position and j --> final postion\\nsee all possible valid combination for palindrom and store it in this array\\n-> upper half of this array is not useful or invalid because i>j mean intial pos > final pos --> not valid\\n-> for i==j mean only one word and it is always palindromic\\n-> for j-i ==1 mean two word it is only palindromic when both char are same( s[i] == s[j])\\n\\n-> now main point for all other case :-\\n( understand my solution upto this point upvote it vro :) )\\nfor palindromic -> first pos char (i) and last pos char(j) must be equal and the portion in between then aslo need to be equal.\\n\\ni and using not traditional for loop and slightly modify it for only considred valid case ( i<=j)\\n\\n//for answer\\ni take two variable start and end store 0 ( mean first char of string in that (single char definately palindromic))\\n->for each palindrom case i check wheater\\ntheir j -i ( string length ) is greater then my ans lenght ( end - start) --> if it is then i change my start and end ( start =i ,end =j)\\n\\nnote * :-\\nfor string len >=1 --> answer>=1 and because of that i intially take length one not checking for one length\\n\\nApproach\\nbottom up dynamic programming\\n\\nComplexity\\nTime complexity:\\n0(n2)\\n\\nSpace complexity:\\n0(n2)\\n\\nCode\\n\\n//////  for explaination refer pep coding :)\\nclass Solution {\\npublic:\\nint dp[1000][1000];\\n    string longestPalindrome(string s) {\\n    \\n\\n    memset( dp,0, sizeof(dp));\\n     int i = 0 , j =0 ;\\n     int g =0, n = s.size();\\n     int start =0, end=0;\\n\\n if( n ==1)\\n   {  \\n   return s;  \\n}\\n     for( int g=0; g<n ;g++ )  /// gap \\n     {\\n         for( int i = 0 ,j=g ; i<n && j<n ;i++, j++ ) // covering all possible of i<j\\n         {\\n           \\n           if(i==j)\\n           {             \\n               dp[i][j] =1;\\n               continue;\\n           }\\n\\n           if(j-i==1 &&s[i]==s[j])\\n           {           \\n                dp[i][j] =1;\\n                \\n                if((j-i) >(end-start) )\\n                {\\n                     start =i;\\n                     end =j;\\n                }\\n                 \\n           continue;\\n           }\\n        \\n            \\n            if( s[i]==s[j] && dp[i+1][j-1]==1)\\n            { \\n                 dp[i][j] =1;\\n                \\n                if( j-i> (end-start) )\\n                {\\n                     start =i;\\n                     end =j;\\n                }\\n                  \\n            }\\n             \\n         }\\n     }\\n\\n     return s.substr(start, end+1-start);   \\n    }\\n};"
                    },
                    {
                        "username": "MiGameasa",
                        "content": "Hi, I'm kinda new and this is my code, it only work with palin string that 3 or less. Can someone point out how to fix this? \n\n```class Solution {\n    public String longestPalindrome(String s) {\n        int left=0, right=s.length()-1, temp = 0;\n        for(int i = 0; i < s.length(); i++){\n            for(int j = right; j > i; j--){\n                if(s.charAt(i) != s.charAt(j)){\n                    continue;\n                }else{\n                    left = i;\n                    right = j;\n                    temp = right;\n                    right--;\n                    break;\n                }\n            }\n        }\n\n        return s.substring(left, temp + 1);\n    }\n}"
                    },
                    {
                        "username": "Namasteydunia",
                        "content": "why it is not letting us use reverse() function in javascript. reverse() is a valid javascript function to reverse a string."
                    },
                    {
                        "username": "charucjoshi",
                        "content": "Can someone please explain why this is wrong?\\n\\nWrong Answer\\ns=\"aacabdkacaa\"\\nOutput\\n\"aacakacaa\"\\nExpected\\n\"aca\""
                    },
                    {
                        "username": "alphazwest",
                        "content": "For the first case, are not `abba` and `baab` both palindromic substrings -- both *longer* than the given solution output? "
                    },
                    {
                        "username": "harshitha____9",
                        "content": "why time limit exceeding?\\n\\nbool check(string s,int i,int j)\\n{\\n    \\n    while(i<=j)\\n    {\\n        if(s[i]!=s[j])\\n        {\\n            return false;\\n        }\\n        i++;\\n        j--;\\n    }\\n    return true;\\n}\\n void f(int i,int j,string&ans,string s)\\n {\\n     if(i>j) return;\\n     if(j<0) return;\\n    if(check(s,i,j))\\n    {\\n        if(ans.size()<(j-i+1))\\n        {\\n            ans=s.substr(i,j-i+1);\\n        }\\n        return;\\n    }\\n    \\n     f(i+1,j,ans,s);\\n     f(i,j-1,ans,s);\\n    \\n }\\n    string longestPalindrome(string s) {\\n        int i=0,j=s.size()-1;\\n        string ans=\"\";\\n        f(i,j,ans,s);\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "nishantwestside",
                        "content": "There seems to be an extra curly brace at the end of your code, which may be causing a syntax error. However, assuming that this is a typographical error, the most likely reason why your code is exceeding the limit is because the time complexity of the algorithm is high.\\n\\nThe code is using a recursive function to check all possible substrings in the input string s, and then checking if they are palindromes or not using the check() function. This approach has an exponential time complexity of O(2^n), where n is the length of the input string s.\\n\\nThis means that as the length of the input string grows, the number of recursive calls made by the algorithm also grows exponentially, leading to a potential stack overflow or timeout.\\n\\nTo optimize the algorithm, you can use dynamic programming or expand around the center approach to reduce the time complexity to O(n2).\\n\\nDynamic Programming Approach:\\n\\n- Define a boolean table of size n x n, where n is the length of the input string.\\n- Initialize all cells in the table to false.\\n- Set all cells (i, i) to true, since a single character is always a palindrome.\\n- For all pairs of indices i, j where i < j, set table[i][j] to true if s[i] == s[j] and table[i+1][j-1] is also true. - This means that a substring from i to j is a palindrome if its first and last characters are equal, and its - inner substring is also a palindrome.\\n- Keep track of the longest palindrome found so far and its starting and ending indices."
                    },
                    {
                        "username": "optic188",
                        "content": "actually really curios about error one one of test cases \\nTime Limit Exceeded\\nnothing mentioned in desciption about complexity of algoritm or memeory using restrictions ? Why then this test case is not passing "
                    },
                    {
                        "username": "yashAryan",
                        "content": "Line 1061: Char 9: runtime error: addition of unsigned offset to 0x7fff8d8fc2b0 overflowed to 0x7fff8d8fc2af (basic_string.h)\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior /usr/bin/../lib/gcc/x86_64-linux-gnu/9/../../../../include/c++/9/bits/basic_string.h:1070:9\n\n\n\n\nI am facing this error. Can anyone tell me what's wrong with my code?  \n class Solution {\npublic:\n    string longestPalindrome(string s) {\n        string t=\"#\";\n    for(int i=0;i<s.size();i++)\n    {\n        t+=s[i];\n        t+=\"#\";\n    }\n    int n=t.size();\n    vector<int> v(n,0);\n    int c=0,mirr=0,r=0;\n    for(int i=1;i<t.size()-1;i++)\n    {\n        mirr=2*c-i;\n        if(i<r and mirr>=0)\n        {\n            v[i]=min(v[mirr],r-i);\n        }\n        while(t[i+v[i]+1]==t[i-v[i]-1])\n        {\n            v[i]++;\n        }\n        if(i+v[i]>r)\n        {\n            c=i;\n            r=i+v[i];\n        }\n    }\n    int index=max_element(v.begin(),v.end())-v.begin();\n    int value=v[index];\n    int start=index-value;\n    string f=t.substr(start,2*value);\n    f.erase(remove(f.begin(),f.end(),'#'),f.end());\n\n    return f;\n    }\n};\n\n[Link to the question](https://leetcode.com/problems/longest-palindromic-substring/description/)"
                    },
                    {
                        "username": "DavidLindon",
                        "content": "This problem is extremely poor since it isn\\'t obvious that all the test cases can easily be solved by expanding around center.\\n\\nWhat about \"bbbba\", output should be bbbb!"
                    },
                    {
                        "username": "harshitha____9",
                        "content": "string f(int i,int j,string ref,string s,string&ans)\\n {\\n     if(i>=j) return ref;\\n     if(s[i]==s[j])\\n     {\\n         i++;\\n         j--;\\n     }\\n     else if(s[i]!=s[j])\\n     {\\n         string l=f(i+1,j,ref.substr(i+1,j-i),s,ans);\\n         string r=f(i,j-1,ref.substr(i,j-i),s,ans);\\n         if(l.size()>r.size())\\n         {\\n             ans=l;\\n         }\\n         else\\n         {\\n             ans=r;\\n         }\\n     }\\n      \\n     return ref;\\n }\\n    string longestPalindrome(string s) {\\n        int i=0,j=s.size()-1;\\n        string c=s;\\n        string ans=\"\";\\n        f(i,j,c,s,ans);\\n        return ans;\\n    }\\nwhat is wrong with this code......"
                    }
                ]
            },
            {
                "id": 1838635,
                "content": [
                    {
                        "username": "ankush920",
                        "content": "\\nEXPLAINED TEXT || C++ || DYNAMIC PROGRAMMING\\nankush920\\n0\\nin a few seconds\\nIntuition\\ntake 2-d matrix of dp in which\\ni--> intial position and j --> final postion\\nsee all possible valid combination for palindrom and store it in this array\\n-> upper half of this array is not useful or invalid because i>j mean intial pos > final pos --> not valid\\n-> for i==j mean only one word and it is always palindromic\\n-> for j-i ==1 mean two word it is only palindromic when both char are same( s[i] == s[j])\\n\\n-> now main point for all other case :-\\n( understand my solution upto this point upvote it vro :) )\\nfor palindromic -> first pos char (i) and last pos char(j) must be equal and the portion in between then aslo need to be equal.\\n\\ni and using not traditional for loop and slightly modify it for only considred valid case ( i<=j)\\n\\n//for answer\\ni take two variable start and end store 0 ( mean first char of string in that (single char definately palindromic))\\n->for each palindrom case i check wheater\\ntheir j -i ( string length ) is greater then my ans lenght ( end - start) --> if it is then i change my start and end ( start =i ,end =j)\\n\\nnote * :-\\nfor string len >=1 --> answer>=1 and because of that i intially take length one not checking for one length\\n\\nApproach\\nbottom up dynamic programming\\n\\nComplexity\\nTime complexity:\\n0(n2)\\n\\nSpace complexity:\\n0(n2)\\n\\nCode\\n\\n//////  for explaination refer pep coding :)\\nclass Solution {\\npublic:\\nint dp[1000][1000];\\n    string longestPalindrome(string s) {\\n    \\n\\n    memset( dp,0, sizeof(dp));\\n     int i = 0 , j =0 ;\\n     int g =0, n = s.size();\\n     int start =0, end=0;\\n\\n if( n ==1)\\n   {  \\n   return s;  \\n}\\n     for( int g=0; g<n ;g++ )  /// gap \\n     {\\n         for( int i = 0 ,j=g ; i<n && j<n ;i++, j++ ) // covering all possible of i<j\\n         {\\n           \\n           if(i==j)\\n           {             \\n               dp[i][j] =1;\\n               continue;\\n           }\\n\\n           if(j-i==1 &&s[i]==s[j])\\n           {           \\n                dp[i][j] =1;\\n                \\n                if((j-i) >(end-start) )\\n                {\\n                     start =i;\\n                     end =j;\\n                }\\n                 \\n           continue;\\n           }\\n        \\n            \\n            if( s[i]==s[j] && dp[i+1][j-1]==1)\\n            { \\n                 dp[i][j] =1;\\n                \\n                if( j-i> (end-start) )\\n                {\\n                     start =i;\\n                     end =j;\\n                }\\n                  \\n            }\\n             \\n         }\\n     }\\n\\n     return s.substr(start, end+1-start);   \\n    }\\n};"
                    },
                    {
                        "username": "MiGameasa",
                        "content": "Hi, I'm kinda new and this is my code, it only work with palin string that 3 or less. Can someone point out how to fix this? \n\n```class Solution {\n    public String longestPalindrome(String s) {\n        int left=0, right=s.length()-1, temp = 0;\n        for(int i = 0; i < s.length(); i++){\n            for(int j = right; j > i; j--){\n                if(s.charAt(i) != s.charAt(j)){\n                    continue;\n                }else{\n                    left = i;\n                    right = j;\n                    temp = right;\n                    right--;\n                    break;\n                }\n            }\n        }\n\n        return s.substring(left, temp + 1);\n    }\n}"
                    },
                    {
                        "username": "Namasteydunia",
                        "content": "why it is not letting us use reverse() function in javascript. reverse() is a valid javascript function to reverse a string."
                    },
                    {
                        "username": "charucjoshi",
                        "content": "Can someone please explain why this is wrong?\\n\\nWrong Answer\\ns=\"aacabdkacaa\"\\nOutput\\n\"aacakacaa\"\\nExpected\\n\"aca\""
                    },
                    {
                        "username": "alphazwest",
                        "content": "For the first case, are not `abba` and `baab` both palindromic substrings -- both *longer* than the given solution output? "
                    },
                    {
                        "username": "harshitha____9",
                        "content": "why time limit exceeding?\\n\\nbool check(string s,int i,int j)\\n{\\n    \\n    while(i<=j)\\n    {\\n        if(s[i]!=s[j])\\n        {\\n            return false;\\n        }\\n        i++;\\n        j--;\\n    }\\n    return true;\\n}\\n void f(int i,int j,string&ans,string s)\\n {\\n     if(i>j) return;\\n     if(j<0) return;\\n    if(check(s,i,j))\\n    {\\n        if(ans.size()<(j-i+1))\\n        {\\n            ans=s.substr(i,j-i+1);\\n        }\\n        return;\\n    }\\n    \\n     f(i+1,j,ans,s);\\n     f(i,j-1,ans,s);\\n    \\n }\\n    string longestPalindrome(string s) {\\n        int i=0,j=s.size()-1;\\n        string ans=\"\";\\n        f(i,j,ans,s);\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "nishantwestside",
                        "content": "There seems to be an extra curly brace at the end of your code, which may be causing a syntax error. However, assuming that this is a typographical error, the most likely reason why your code is exceeding the limit is because the time complexity of the algorithm is high.\\n\\nThe code is using a recursive function to check all possible substrings in the input string s, and then checking if they are palindromes or not using the check() function. This approach has an exponential time complexity of O(2^n), where n is the length of the input string s.\\n\\nThis means that as the length of the input string grows, the number of recursive calls made by the algorithm also grows exponentially, leading to a potential stack overflow or timeout.\\n\\nTo optimize the algorithm, you can use dynamic programming or expand around the center approach to reduce the time complexity to O(n2).\\n\\nDynamic Programming Approach:\\n\\n- Define a boolean table of size n x n, where n is the length of the input string.\\n- Initialize all cells in the table to false.\\n- Set all cells (i, i) to true, since a single character is always a palindrome.\\n- For all pairs of indices i, j where i < j, set table[i][j] to true if s[i] == s[j] and table[i+1][j-1] is also true. - This means that a substring from i to j is a palindrome if its first and last characters are equal, and its - inner substring is also a palindrome.\\n- Keep track of the longest palindrome found so far and its starting and ending indices."
                    },
                    {
                        "username": "optic188",
                        "content": "actually really curios about error one one of test cases \\nTime Limit Exceeded\\nnothing mentioned in desciption about complexity of algoritm or memeory using restrictions ? Why then this test case is not passing "
                    },
                    {
                        "username": "yashAryan",
                        "content": "Line 1061: Char 9: runtime error: addition of unsigned offset to 0x7fff8d8fc2b0 overflowed to 0x7fff8d8fc2af (basic_string.h)\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior /usr/bin/../lib/gcc/x86_64-linux-gnu/9/../../../../include/c++/9/bits/basic_string.h:1070:9\n\n\n\n\nI am facing this error. Can anyone tell me what's wrong with my code?  \n class Solution {\npublic:\n    string longestPalindrome(string s) {\n        string t=\"#\";\n    for(int i=0;i<s.size();i++)\n    {\n        t+=s[i];\n        t+=\"#\";\n    }\n    int n=t.size();\n    vector<int> v(n,0);\n    int c=0,mirr=0,r=0;\n    for(int i=1;i<t.size()-1;i++)\n    {\n        mirr=2*c-i;\n        if(i<r and mirr>=0)\n        {\n            v[i]=min(v[mirr],r-i);\n        }\n        while(t[i+v[i]+1]==t[i-v[i]-1])\n        {\n            v[i]++;\n        }\n        if(i+v[i]>r)\n        {\n            c=i;\n            r=i+v[i];\n        }\n    }\n    int index=max_element(v.begin(),v.end())-v.begin();\n    int value=v[index];\n    int start=index-value;\n    string f=t.substr(start,2*value);\n    f.erase(remove(f.begin(),f.end(),'#'),f.end());\n\n    return f;\n    }\n};\n\n[Link to the question](https://leetcode.com/problems/longest-palindromic-substring/description/)"
                    },
                    {
                        "username": "DavidLindon",
                        "content": "This problem is extremely poor since it isn\\'t obvious that all the test cases can easily be solved by expanding around center.\\n\\nWhat about \"bbbba\", output should be bbbb!"
                    },
                    {
                        "username": "harshitha____9",
                        "content": "string f(int i,int j,string ref,string s,string&ans)\\n {\\n     if(i>=j) return ref;\\n     if(s[i]==s[j])\\n     {\\n         i++;\\n         j--;\\n     }\\n     else if(s[i]!=s[j])\\n     {\\n         string l=f(i+1,j,ref.substr(i+1,j-i),s,ans);\\n         string r=f(i,j-1,ref.substr(i,j-i),s,ans);\\n         if(l.size()>r.size())\\n         {\\n             ans=l;\\n         }\\n         else\\n         {\\n             ans=r;\\n         }\\n     }\\n      \\n     return ref;\\n }\\n    string longestPalindrome(string s) {\\n        int i=0,j=s.size()-1;\\n        string c=s;\\n        string ans=\"\";\\n        f(i,j,c,s,ans);\\n        return ans;\\n    }\\nwhat is wrong with this code......"
                    }
                ]
            },
            {
                "id": 1833334,
                "content": [
                    {
                        "username": "Meena_leetcode",
                        "content": "for input \"cbbd\", wouldn\\'t the longest palindromic substring be \"bcb\" instead of \"bb\"?"
                    },
                    {
                        "username": "ufve0704terry",
                        "content": "I find out that I have such a big problem.\\nEverytime I AC I must need to have several times debug.\\nBut everytime I finish debug and AC,I don\\'t even know why the program can run...\\nI usually think that the program still have some problem I need to solve but it AC..."
                    },
                    {
                        "username": "Ritik_Gupta1",
                        "content": "Palindromic in String "
                    },
                    {
                        "username": "PythonAnalyst",
                        "content": "I passed all the tests except the last one, the 141st. At the last one, he submits either nothing or an empty line for input and writes \"Time Limit Exceed'. Has anyone encountered a similar problem?"
                    },
                    {
                        "username": "misuvasish114",
                        "content": "Can be solved in linear time using Manacher\\'s Algorithm\\nhttps://en.wikipedia.org/wiki/Longest_palindromic_substring#Manacher.27s_algorithm"
                    },
                    {
                        "username": "dunionwagner",
                        "content": "I think that a good testcase to test would be a test where it\\'s a complete palindrome, like racecar or tacocat, or bbbb."
                    },
                    {
                        "username": "vishakha_1102",
                        "content": "Can someone please tell me the error in this code? I\\'m not able to get why it is showing runtime error."
                    },
                    {
                        "username": "vishakha_1102",
                        "content": "string subString(string s, string x, int n, int m){\\n        int t[n+1][m+1];\\n        int result=0,r=0,c=0;\\n        string ans=\"\";\\n        for(int i=0;i<n+1;i++){\\n            for(int j=0;j<m+1;j++){\\n                if(i==0 || j==0)\\n                  t[i][j]=0;\\n                if(s[i-1]==x[j-1]){\\n                    t[i][j]=1+t[i-1][j-1];\\n                    if (result<t[i][j]) {\\n                     result = t[i][j];\\n                      r=i;\\n                      c=j;\\n                  }\\n                }\\n                else\\n                  t[i][j]=0;\\n            }\\n        }\\n        while(result>0){\\n           ans.push_back(s[r-1]);\\n           r--;\\n           result--;\\n        }\\n        return ans;\\n\\n    }\\n    string longestPalindrome(string s) {\\n     int n=s.size();\\n     string x =\"\";\\n     for(int i=n-1;i>=0;i--){\\n         x.push_back(s[i]);\\n     }\\n     return subString(s,x,n,n);\\n    }"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "rahulgupta1597",
                        "content": "This will not work for input s =\"aacabdkacaa\""
                    },
                    {
                        "username": "cheungtriedtocode",
                        "content": "need help ,what can i do to solve TLE ,\\n```\\nclass Solution(object):\\n    def longestPalindrome(self, s):\\n        left = 0\\n        dp=\"\"\\n        \\n        for i in range(len(s)):\\n            left = i +1\\n            cur = \"\"\\n            while left<=len(s):\\n                # print(s[i:left])\\n                cur = s[i:left] if s[i:left]==s[i:left][::-1] else cur \\n                left+=1 \\n            dp = max(dp,cur,key=len)\\n      \\n        return dp \\n```"
                    },
                    {
                        "username": "pktk001",
                        "content": "141th testcase is not visible. I\\'m getting TLE on 141th testcase when I try to solve it with hashing.\\n"
                    }
                ]
            },
            {
                "id": 1829001,
                "content": [
                    {
                        "username": "Meena_leetcode",
                        "content": "for input \"cbbd\", wouldn\\'t the longest palindromic substring be \"bcb\" instead of \"bb\"?"
                    },
                    {
                        "username": "ufve0704terry",
                        "content": "I find out that I have such a big problem.\\nEverytime I AC I must need to have several times debug.\\nBut everytime I finish debug and AC,I don\\'t even know why the program can run...\\nI usually think that the program still have some problem I need to solve but it AC..."
                    },
                    {
                        "username": "Ritik_Gupta1",
                        "content": "Palindromic in String "
                    },
                    {
                        "username": "PythonAnalyst",
                        "content": "I passed all the tests except the last one, the 141st. At the last one, he submits either nothing or an empty line for input and writes \"Time Limit Exceed'. Has anyone encountered a similar problem?"
                    },
                    {
                        "username": "misuvasish114",
                        "content": "Can be solved in linear time using Manacher\\'s Algorithm\\nhttps://en.wikipedia.org/wiki/Longest_palindromic_substring#Manacher.27s_algorithm"
                    },
                    {
                        "username": "dunionwagner",
                        "content": "I think that a good testcase to test would be a test where it\\'s a complete palindrome, like racecar or tacocat, or bbbb."
                    },
                    {
                        "username": "vishakha_1102",
                        "content": "Can someone please tell me the error in this code? I\\'m not able to get why it is showing runtime error."
                    },
                    {
                        "username": "vishakha_1102",
                        "content": "string subString(string s, string x, int n, int m){\\n        int t[n+1][m+1];\\n        int result=0,r=0,c=0;\\n        string ans=\"\";\\n        for(int i=0;i<n+1;i++){\\n            for(int j=0;j<m+1;j++){\\n                if(i==0 || j==0)\\n                  t[i][j]=0;\\n                if(s[i-1]==x[j-1]){\\n                    t[i][j]=1+t[i-1][j-1];\\n                    if (result<t[i][j]) {\\n                     result = t[i][j];\\n                      r=i;\\n                      c=j;\\n                  }\\n                }\\n                else\\n                  t[i][j]=0;\\n            }\\n        }\\n        while(result>0){\\n           ans.push_back(s[r-1]);\\n           r--;\\n           result--;\\n        }\\n        return ans;\\n\\n    }\\n    string longestPalindrome(string s) {\\n     int n=s.size();\\n     string x =\"\";\\n     for(int i=n-1;i>=0;i--){\\n         x.push_back(s[i]);\\n     }\\n     return subString(s,x,n,n);\\n    }"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "rahulgupta1597",
                        "content": "This will not work for input s =\"aacabdkacaa\""
                    },
                    {
                        "username": "cheungtriedtocode",
                        "content": "need help ,what can i do to solve TLE ,\\n```\\nclass Solution(object):\\n    def longestPalindrome(self, s):\\n        left = 0\\n        dp=\"\"\\n        \\n        for i in range(len(s)):\\n            left = i +1\\n            cur = \"\"\\n            while left<=len(s):\\n                # print(s[i:left])\\n                cur = s[i:left] if s[i:left]==s[i:left][::-1] else cur \\n                left+=1 \\n            dp = max(dp,cur,key=len)\\n      \\n        return dp \\n```"
                    },
                    {
                        "username": "pktk001",
                        "content": "141th testcase is not visible. I\\'m getting TLE on 141th testcase when I try to solve it with hashing.\\n"
                    }
                ]
            },
            {
                "id": 1828061,
                "content": [
                    {
                        "username": "Meena_leetcode",
                        "content": "for input \"cbbd\", wouldn\\'t the longest palindromic substring be \"bcb\" instead of \"bb\"?"
                    },
                    {
                        "username": "ufve0704terry",
                        "content": "I find out that I have such a big problem.\\nEverytime I AC I must need to have several times debug.\\nBut everytime I finish debug and AC,I don\\'t even know why the program can run...\\nI usually think that the program still have some problem I need to solve but it AC..."
                    },
                    {
                        "username": "Ritik_Gupta1",
                        "content": "Palindromic in String "
                    },
                    {
                        "username": "PythonAnalyst",
                        "content": "I passed all the tests except the last one, the 141st. At the last one, he submits either nothing or an empty line for input and writes \"Time Limit Exceed'. Has anyone encountered a similar problem?"
                    },
                    {
                        "username": "misuvasish114",
                        "content": "Can be solved in linear time using Manacher\\'s Algorithm\\nhttps://en.wikipedia.org/wiki/Longest_palindromic_substring#Manacher.27s_algorithm"
                    },
                    {
                        "username": "dunionwagner",
                        "content": "I think that a good testcase to test would be a test where it\\'s a complete palindrome, like racecar or tacocat, or bbbb."
                    },
                    {
                        "username": "vishakha_1102",
                        "content": "Can someone please tell me the error in this code? I\\'m not able to get why it is showing runtime error."
                    },
                    {
                        "username": "vishakha_1102",
                        "content": "string subString(string s, string x, int n, int m){\\n        int t[n+1][m+1];\\n        int result=0,r=0,c=0;\\n        string ans=\"\";\\n        for(int i=0;i<n+1;i++){\\n            for(int j=0;j<m+1;j++){\\n                if(i==0 || j==0)\\n                  t[i][j]=0;\\n                if(s[i-1]==x[j-1]){\\n                    t[i][j]=1+t[i-1][j-1];\\n                    if (result<t[i][j]) {\\n                     result = t[i][j];\\n                      r=i;\\n                      c=j;\\n                  }\\n                }\\n                else\\n                  t[i][j]=0;\\n            }\\n        }\\n        while(result>0){\\n           ans.push_back(s[r-1]);\\n           r--;\\n           result--;\\n        }\\n        return ans;\\n\\n    }\\n    string longestPalindrome(string s) {\\n     int n=s.size();\\n     string x =\"\";\\n     for(int i=n-1;i>=0;i--){\\n         x.push_back(s[i]);\\n     }\\n     return subString(s,x,n,n);\\n    }"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "rahulgupta1597",
                        "content": "This will not work for input s =\"aacabdkacaa\""
                    },
                    {
                        "username": "cheungtriedtocode",
                        "content": "need help ,what can i do to solve TLE ,\\n```\\nclass Solution(object):\\n    def longestPalindrome(self, s):\\n        left = 0\\n        dp=\"\"\\n        \\n        for i in range(len(s)):\\n            left = i +1\\n            cur = \"\"\\n            while left<=len(s):\\n                # print(s[i:left])\\n                cur = s[i:left] if s[i:left]==s[i:left][::-1] else cur \\n                left+=1 \\n            dp = max(dp,cur,key=len)\\n      \\n        return dp \\n```"
                    },
                    {
                        "username": "pktk001",
                        "content": "141th testcase is not visible. I\\'m getting TLE on 141th testcase when I try to solve it with hashing.\\n"
                    }
                ]
            },
            {
                "id": 1826139,
                "content": [
                    {
                        "username": "Meena_leetcode",
                        "content": "for input \"cbbd\", wouldn\\'t the longest palindromic substring be \"bcb\" instead of \"bb\"?"
                    },
                    {
                        "username": "ufve0704terry",
                        "content": "I find out that I have such a big problem.\\nEverytime I AC I must need to have several times debug.\\nBut everytime I finish debug and AC,I don\\'t even know why the program can run...\\nI usually think that the program still have some problem I need to solve but it AC..."
                    },
                    {
                        "username": "Ritik_Gupta1",
                        "content": "Palindromic in String "
                    },
                    {
                        "username": "PythonAnalyst",
                        "content": "I passed all the tests except the last one, the 141st. At the last one, he submits either nothing or an empty line for input and writes \"Time Limit Exceed'. Has anyone encountered a similar problem?"
                    },
                    {
                        "username": "misuvasish114",
                        "content": "Can be solved in linear time using Manacher\\'s Algorithm\\nhttps://en.wikipedia.org/wiki/Longest_palindromic_substring#Manacher.27s_algorithm"
                    },
                    {
                        "username": "dunionwagner",
                        "content": "I think that a good testcase to test would be a test where it\\'s a complete palindrome, like racecar or tacocat, or bbbb."
                    },
                    {
                        "username": "vishakha_1102",
                        "content": "Can someone please tell me the error in this code? I\\'m not able to get why it is showing runtime error."
                    },
                    {
                        "username": "vishakha_1102",
                        "content": "string subString(string s, string x, int n, int m){\\n        int t[n+1][m+1];\\n        int result=0,r=0,c=0;\\n        string ans=\"\";\\n        for(int i=0;i<n+1;i++){\\n            for(int j=0;j<m+1;j++){\\n                if(i==0 || j==0)\\n                  t[i][j]=0;\\n                if(s[i-1]==x[j-1]){\\n                    t[i][j]=1+t[i-1][j-1];\\n                    if (result<t[i][j]) {\\n                     result = t[i][j];\\n                      r=i;\\n                      c=j;\\n                  }\\n                }\\n                else\\n                  t[i][j]=0;\\n            }\\n        }\\n        while(result>0){\\n           ans.push_back(s[r-1]);\\n           r--;\\n           result--;\\n        }\\n        return ans;\\n\\n    }\\n    string longestPalindrome(string s) {\\n     int n=s.size();\\n     string x =\"\";\\n     for(int i=n-1;i>=0;i--){\\n         x.push_back(s[i]);\\n     }\\n     return subString(s,x,n,n);\\n    }"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "rahulgupta1597",
                        "content": "This will not work for input s =\"aacabdkacaa\""
                    },
                    {
                        "username": "cheungtriedtocode",
                        "content": "need help ,what can i do to solve TLE ,\\n```\\nclass Solution(object):\\n    def longestPalindrome(self, s):\\n        left = 0\\n        dp=\"\"\\n        \\n        for i in range(len(s)):\\n            left = i +1\\n            cur = \"\"\\n            while left<=len(s):\\n                # print(s[i:left])\\n                cur = s[i:left] if s[i:left]==s[i:left][::-1] else cur \\n                left+=1 \\n            dp = max(dp,cur,key=len)\\n      \\n        return dp \\n```"
                    },
                    {
                        "username": "pktk001",
                        "content": "141th testcase is not visible. I\\'m getting TLE on 141th testcase when I try to solve it with hashing.\\n"
                    }
                ]
            },
            {
                "id": 1813226,
                "content": [
                    {
                        "username": "Meena_leetcode",
                        "content": "for input \"cbbd\", wouldn\\'t the longest palindromic substring be \"bcb\" instead of \"bb\"?"
                    },
                    {
                        "username": "ufve0704terry",
                        "content": "I find out that I have such a big problem.\\nEverytime I AC I must need to have several times debug.\\nBut everytime I finish debug and AC,I don\\'t even know why the program can run...\\nI usually think that the program still have some problem I need to solve but it AC..."
                    },
                    {
                        "username": "Ritik_Gupta1",
                        "content": "Palindromic in String "
                    },
                    {
                        "username": "PythonAnalyst",
                        "content": "I passed all the tests except the last one, the 141st. At the last one, he submits either nothing or an empty line for input and writes \"Time Limit Exceed'. Has anyone encountered a similar problem?"
                    },
                    {
                        "username": "misuvasish114",
                        "content": "Can be solved in linear time using Manacher\\'s Algorithm\\nhttps://en.wikipedia.org/wiki/Longest_palindromic_substring#Manacher.27s_algorithm"
                    },
                    {
                        "username": "dunionwagner",
                        "content": "I think that a good testcase to test would be a test where it\\'s a complete palindrome, like racecar or tacocat, or bbbb."
                    },
                    {
                        "username": "vishakha_1102",
                        "content": "Can someone please tell me the error in this code? I\\'m not able to get why it is showing runtime error."
                    },
                    {
                        "username": "vishakha_1102",
                        "content": "string subString(string s, string x, int n, int m){\\n        int t[n+1][m+1];\\n        int result=0,r=0,c=0;\\n        string ans=\"\";\\n        for(int i=0;i<n+1;i++){\\n            for(int j=0;j<m+1;j++){\\n                if(i==0 || j==0)\\n                  t[i][j]=0;\\n                if(s[i-1]==x[j-1]){\\n                    t[i][j]=1+t[i-1][j-1];\\n                    if (result<t[i][j]) {\\n                     result = t[i][j];\\n                      r=i;\\n                      c=j;\\n                  }\\n                }\\n                else\\n                  t[i][j]=0;\\n            }\\n        }\\n        while(result>0){\\n           ans.push_back(s[r-1]);\\n           r--;\\n           result--;\\n        }\\n        return ans;\\n\\n    }\\n    string longestPalindrome(string s) {\\n     int n=s.size();\\n     string x =\"\";\\n     for(int i=n-1;i>=0;i--){\\n         x.push_back(s[i]);\\n     }\\n     return subString(s,x,n,n);\\n    }"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "rahulgupta1597",
                        "content": "This will not work for input s =\"aacabdkacaa\""
                    },
                    {
                        "username": "cheungtriedtocode",
                        "content": "need help ,what can i do to solve TLE ,\\n```\\nclass Solution(object):\\n    def longestPalindrome(self, s):\\n        left = 0\\n        dp=\"\"\\n        \\n        for i in range(len(s)):\\n            left = i +1\\n            cur = \"\"\\n            while left<=len(s):\\n                # print(s[i:left])\\n                cur = s[i:left] if s[i:left]==s[i:left][::-1] else cur \\n                left+=1 \\n            dp = max(dp,cur,key=len)\\n      \\n        return dp \\n```"
                    },
                    {
                        "username": "pktk001",
                        "content": "141th testcase is not visible. I\\'m getting TLE on 141th testcase when I try to solve it with hashing.\\n"
                    }
                ]
            },
            {
                "id": 1809884,
                "content": [
                    {
                        "username": "Meena_leetcode",
                        "content": "for input \"cbbd\", wouldn\\'t the longest palindromic substring be \"bcb\" instead of \"bb\"?"
                    },
                    {
                        "username": "ufve0704terry",
                        "content": "I find out that I have such a big problem.\\nEverytime I AC I must need to have several times debug.\\nBut everytime I finish debug and AC,I don\\'t even know why the program can run...\\nI usually think that the program still have some problem I need to solve but it AC..."
                    },
                    {
                        "username": "Ritik_Gupta1",
                        "content": "Palindromic in String "
                    },
                    {
                        "username": "PythonAnalyst",
                        "content": "I passed all the tests except the last one, the 141st. At the last one, he submits either nothing or an empty line for input and writes \"Time Limit Exceed'. Has anyone encountered a similar problem?"
                    },
                    {
                        "username": "misuvasish114",
                        "content": "Can be solved in linear time using Manacher\\'s Algorithm\\nhttps://en.wikipedia.org/wiki/Longest_palindromic_substring#Manacher.27s_algorithm"
                    },
                    {
                        "username": "dunionwagner",
                        "content": "I think that a good testcase to test would be a test where it\\'s a complete palindrome, like racecar or tacocat, or bbbb."
                    },
                    {
                        "username": "vishakha_1102",
                        "content": "Can someone please tell me the error in this code? I\\'m not able to get why it is showing runtime error."
                    },
                    {
                        "username": "vishakha_1102",
                        "content": "string subString(string s, string x, int n, int m){\\n        int t[n+1][m+1];\\n        int result=0,r=0,c=0;\\n        string ans=\"\";\\n        for(int i=0;i<n+1;i++){\\n            for(int j=0;j<m+1;j++){\\n                if(i==0 || j==0)\\n                  t[i][j]=0;\\n                if(s[i-1]==x[j-1]){\\n                    t[i][j]=1+t[i-1][j-1];\\n                    if (result<t[i][j]) {\\n                     result = t[i][j];\\n                      r=i;\\n                      c=j;\\n                  }\\n                }\\n                else\\n                  t[i][j]=0;\\n            }\\n        }\\n        while(result>0){\\n           ans.push_back(s[r-1]);\\n           r--;\\n           result--;\\n        }\\n        return ans;\\n\\n    }\\n    string longestPalindrome(string s) {\\n     int n=s.size();\\n     string x =\"\";\\n     for(int i=n-1;i>=0;i--){\\n         x.push_back(s[i]);\\n     }\\n     return subString(s,x,n,n);\\n    }"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "rahulgupta1597",
                        "content": "This will not work for input s =\"aacabdkacaa\""
                    },
                    {
                        "username": "cheungtriedtocode",
                        "content": "need help ,what can i do to solve TLE ,\\n```\\nclass Solution(object):\\n    def longestPalindrome(self, s):\\n        left = 0\\n        dp=\"\"\\n        \\n        for i in range(len(s)):\\n            left = i +1\\n            cur = \"\"\\n            while left<=len(s):\\n                # print(s[i:left])\\n                cur = s[i:left] if s[i:left]==s[i:left][::-1] else cur \\n                left+=1 \\n            dp = max(dp,cur,key=len)\\n      \\n        return dp \\n```"
                    },
                    {
                        "username": "pktk001",
                        "content": "141th testcase is not visible. I\\'m getting TLE on 141th testcase when I try to solve it with hashing.\\n"
                    }
                ]
            },
            {
                "id": 1809335,
                "content": [
                    {
                        "username": "Meena_leetcode",
                        "content": "for input \"cbbd\", wouldn\\'t the longest palindromic substring be \"bcb\" instead of \"bb\"?"
                    },
                    {
                        "username": "ufve0704terry",
                        "content": "I find out that I have such a big problem.\\nEverytime I AC I must need to have several times debug.\\nBut everytime I finish debug and AC,I don\\'t even know why the program can run...\\nI usually think that the program still have some problem I need to solve but it AC..."
                    },
                    {
                        "username": "Ritik_Gupta1",
                        "content": "Palindromic in String "
                    },
                    {
                        "username": "PythonAnalyst",
                        "content": "I passed all the tests except the last one, the 141st. At the last one, he submits either nothing or an empty line for input and writes \"Time Limit Exceed'. Has anyone encountered a similar problem?"
                    },
                    {
                        "username": "misuvasish114",
                        "content": "Can be solved in linear time using Manacher\\'s Algorithm\\nhttps://en.wikipedia.org/wiki/Longest_palindromic_substring#Manacher.27s_algorithm"
                    },
                    {
                        "username": "dunionwagner",
                        "content": "I think that a good testcase to test would be a test where it\\'s a complete palindrome, like racecar or tacocat, or bbbb."
                    },
                    {
                        "username": "vishakha_1102",
                        "content": "Can someone please tell me the error in this code? I\\'m not able to get why it is showing runtime error."
                    },
                    {
                        "username": "vishakha_1102",
                        "content": "string subString(string s, string x, int n, int m){\\n        int t[n+1][m+1];\\n        int result=0,r=0,c=0;\\n        string ans=\"\";\\n        for(int i=0;i<n+1;i++){\\n            for(int j=0;j<m+1;j++){\\n                if(i==0 || j==0)\\n                  t[i][j]=0;\\n                if(s[i-1]==x[j-1]){\\n                    t[i][j]=1+t[i-1][j-1];\\n                    if (result<t[i][j]) {\\n                     result = t[i][j];\\n                      r=i;\\n                      c=j;\\n                  }\\n                }\\n                else\\n                  t[i][j]=0;\\n            }\\n        }\\n        while(result>0){\\n           ans.push_back(s[r-1]);\\n           r--;\\n           result--;\\n        }\\n        return ans;\\n\\n    }\\n    string longestPalindrome(string s) {\\n     int n=s.size();\\n     string x =\"\";\\n     for(int i=n-1;i>=0;i--){\\n         x.push_back(s[i]);\\n     }\\n     return subString(s,x,n,n);\\n    }"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "rahulgupta1597",
                        "content": "This will not work for input s =\"aacabdkacaa\""
                    },
                    {
                        "username": "cheungtriedtocode",
                        "content": "need help ,what can i do to solve TLE ,\\n```\\nclass Solution(object):\\n    def longestPalindrome(self, s):\\n        left = 0\\n        dp=\"\"\\n        \\n        for i in range(len(s)):\\n            left = i +1\\n            cur = \"\"\\n            while left<=len(s):\\n                # print(s[i:left])\\n                cur = s[i:left] if s[i:left]==s[i:left][::-1] else cur \\n                left+=1 \\n            dp = max(dp,cur,key=len)\\n      \\n        return dp \\n```"
                    },
                    {
                        "username": "pktk001",
                        "content": "141th testcase is not visible. I\\'m getting TLE on 141th testcase when I try to solve it with hashing.\\n"
                    }
                ]
            },
            {
                "id": 1809333,
                "content": [
                    {
                        "username": "Meena_leetcode",
                        "content": "for input \"cbbd\", wouldn\\'t the longest palindromic substring be \"bcb\" instead of \"bb\"?"
                    },
                    {
                        "username": "ufve0704terry",
                        "content": "I find out that I have such a big problem.\\nEverytime I AC I must need to have several times debug.\\nBut everytime I finish debug and AC,I don\\'t even know why the program can run...\\nI usually think that the program still have some problem I need to solve but it AC..."
                    },
                    {
                        "username": "Ritik_Gupta1",
                        "content": "Palindromic in String "
                    },
                    {
                        "username": "PythonAnalyst",
                        "content": "I passed all the tests except the last one, the 141st. At the last one, he submits either nothing or an empty line for input and writes \"Time Limit Exceed'. Has anyone encountered a similar problem?"
                    },
                    {
                        "username": "misuvasish114",
                        "content": "Can be solved in linear time using Manacher\\'s Algorithm\\nhttps://en.wikipedia.org/wiki/Longest_palindromic_substring#Manacher.27s_algorithm"
                    },
                    {
                        "username": "dunionwagner",
                        "content": "I think that a good testcase to test would be a test where it\\'s a complete palindrome, like racecar or tacocat, or bbbb."
                    },
                    {
                        "username": "vishakha_1102",
                        "content": "Can someone please tell me the error in this code? I\\'m not able to get why it is showing runtime error."
                    },
                    {
                        "username": "vishakha_1102",
                        "content": "string subString(string s, string x, int n, int m){\\n        int t[n+1][m+1];\\n        int result=0,r=0,c=0;\\n        string ans=\"\";\\n        for(int i=0;i<n+1;i++){\\n            for(int j=0;j<m+1;j++){\\n                if(i==0 || j==0)\\n                  t[i][j]=0;\\n                if(s[i-1]==x[j-1]){\\n                    t[i][j]=1+t[i-1][j-1];\\n                    if (result<t[i][j]) {\\n                     result = t[i][j];\\n                      r=i;\\n                      c=j;\\n                  }\\n                }\\n                else\\n                  t[i][j]=0;\\n            }\\n        }\\n        while(result>0){\\n           ans.push_back(s[r-1]);\\n           r--;\\n           result--;\\n        }\\n        return ans;\\n\\n    }\\n    string longestPalindrome(string s) {\\n     int n=s.size();\\n     string x =\"\";\\n     for(int i=n-1;i>=0;i--){\\n         x.push_back(s[i]);\\n     }\\n     return subString(s,x,n,n);\\n    }"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "rahulgupta1597",
                        "content": "This will not work for input s =\"aacabdkacaa\""
                    },
                    {
                        "username": "cheungtriedtocode",
                        "content": "need help ,what can i do to solve TLE ,\\n```\\nclass Solution(object):\\n    def longestPalindrome(self, s):\\n        left = 0\\n        dp=\"\"\\n        \\n        for i in range(len(s)):\\n            left = i +1\\n            cur = \"\"\\n            while left<=len(s):\\n                # print(s[i:left])\\n                cur = s[i:left] if s[i:left]==s[i:left][::-1] else cur \\n                left+=1 \\n            dp = max(dp,cur,key=len)\\n      \\n        return dp \\n```"
                    },
                    {
                        "username": "pktk001",
                        "content": "141th testcase is not visible. I\\'m getting TLE on 141th testcase when I try to solve it with hashing.\\n"
                    }
                ]
            },
            {
                "id": 1809326,
                "content": [
                    {
                        "username": "Meena_leetcode",
                        "content": "for input \"cbbd\", wouldn\\'t the longest palindromic substring be \"bcb\" instead of \"bb\"?"
                    },
                    {
                        "username": "ufve0704terry",
                        "content": "I find out that I have such a big problem.\\nEverytime I AC I must need to have several times debug.\\nBut everytime I finish debug and AC,I don\\'t even know why the program can run...\\nI usually think that the program still have some problem I need to solve but it AC..."
                    },
                    {
                        "username": "Ritik_Gupta1",
                        "content": "Palindromic in String "
                    },
                    {
                        "username": "PythonAnalyst",
                        "content": "I passed all the tests except the last one, the 141st. At the last one, he submits either nothing or an empty line for input and writes \"Time Limit Exceed'. Has anyone encountered a similar problem?"
                    },
                    {
                        "username": "misuvasish114",
                        "content": "Can be solved in linear time using Manacher\\'s Algorithm\\nhttps://en.wikipedia.org/wiki/Longest_palindromic_substring#Manacher.27s_algorithm"
                    },
                    {
                        "username": "dunionwagner",
                        "content": "I think that a good testcase to test would be a test where it\\'s a complete palindrome, like racecar or tacocat, or bbbb."
                    },
                    {
                        "username": "vishakha_1102",
                        "content": "Can someone please tell me the error in this code? I\\'m not able to get why it is showing runtime error."
                    },
                    {
                        "username": "vishakha_1102",
                        "content": "string subString(string s, string x, int n, int m){\\n        int t[n+1][m+1];\\n        int result=0,r=0,c=0;\\n        string ans=\"\";\\n        for(int i=0;i<n+1;i++){\\n            for(int j=0;j<m+1;j++){\\n                if(i==0 || j==0)\\n                  t[i][j]=0;\\n                if(s[i-1]==x[j-1]){\\n                    t[i][j]=1+t[i-1][j-1];\\n                    if (result<t[i][j]) {\\n                     result = t[i][j];\\n                      r=i;\\n                      c=j;\\n                  }\\n                }\\n                else\\n                  t[i][j]=0;\\n            }\\n        }\\n        while(result>0){\\n           ans.push_back(s[r-1]);\\n           r--;\\n           result--;\\n        }\\n        return ans;\\n\\n    }\\n    string longestPalindrome(string s) {\\n     int n=s.size();\\n     string x =\"\";\\n     for(int i=n-1;i>=0;i--){\\n         x.push_back(s[i]);\\n     }\\n     return subString(s,x,n,n);\\n    }"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "rahulgupta1597",
                        "content": "This will not work for input s =\"aacabdkacaa\""
                    },
                    {
                        "username": "cheungtriedtocode",
                        "content": "need help ,what can i do to solve TLE ,\\n```\\nclass Solution(object):\\n    def longestPalindrome(self, s):\\n        left = 0\\n        dp=\"\"\\n        \\n        for i in range(len(s)):\\n            left = i +1\\n            cur = \"\"\\n            while left<=len(s):\\n                # print(s[i:left])\\n                cur = s[i:left] if s[i:left]==s[i:left][::-1] else cur \\n                left+=1 \\n            dp = max(dp,cur,key=len)\\n      \\n        return dp \\n```"
                    },
                    {
                        "username": "pktk001",
                        "content": "141th testcase is not visible. I\\'m getting TLE on 141th testcase when I try to solve it with hashing.\\n"
                    }
                ]
            },
            {
                "id": 1807028,
                "content": [
                    {
                        "username": "Meena_leetcode",
                        "content": "for input \"cbbd\", wouldn\\'t the longest palindromic substring be \"bcb\" instead of \"bb\"?"
                    },
                    {
                        "username": "ufve0704terry",
                        "content": "I find out that I have such a big problem.\\nEverytime I AC I must need to have several times debug.\\nBut everytime I finish debug and AC,I don\\'t even know why the program can run...\\nI usually think that the program still have some problem I need to solve but it AC..."
                    },
                    {
                        "username": "Ritik_Gupta1",
                        "content": "Palindromic in String "
                    },
                    {
                        "username": "PythonAnalyst",
                        "content": "I passed all the tests except the last one, the 141st. At the last one, he submits either nothing or an empty line for input and writes \"Time Limit Exceed'. Has anyone encountered a similar problem?"
                    },
                    {
                        "username": "misuvasish114",
                        "content": "Can be solved in linear time using Manacher\\'s Algorithm\\nhttps://en.wikipedia.org/wiki/Longest_palindromic_substring#Manacher.27s_algorithm"
                    },
                    {
                        "username": "dunionwagner",
                        "content": "I think that a good testcase to test would be a test where it\\'s a complete palindrome, like racecar or tacocat, or bbbb."
                    },
                    {
                        "username": "vishakha_1102",
                        "content": "Can someone please tell me the error in this code? I\\'m not able to get why it is showing runtime error."
                    },
                    {
                        "username": "vishakha_1102",
                        "content": "string subString(string s, string x, int n, int m){\\n        int t[n+1][m+1];\\n        int result=0,r=0,c=0;\\n        string ans=\"\";\\n        for(int i=0;i<n+1;i++){\\n            for(int j=0;j<m+1;j++){\\n                if(i==0 || j==0)\\n                  t[i][j]=0;\\n                if(s[i-1]==x[j-1]){\\n                    t[i][j]=1+t[i-1][j-1];\\n                    if (result<t[i][j]) {\\n                     result = t[i][j];\\n                      r=i;\\n                      c=j;\\n                  }\\n                }\\n                else\\n                  t[i][j]=0;\\n            }\\n        }\\n        while(result>0){\\n           ans.push_back(s[r-1]);\\n           r--;\\n           result--;\\n        }\\n        return ans;\\n\\n    }\\n    string longestPalindrome(string s) {\\n     int n=s.size();\\n     string x =\"\";\\n     for(int i=n-1;i>=0;i--){\\n         x.push_back(s[i]);\\n     }\\n     return subString(s,x,n,n);\\n    }"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "rahulgupta1597",
                        "content": "This will not work for input s =\"aacabdkacaa\""
                    },
                    {
                        "username": "cheungtriedtocode",
                        "content": "need help ,what can i do to solve TLE ,\\n```\\nclass Solution(object):\\n    def longestPalindrome(self, s):\\n        left = 0\\n        dp=\"\"\\n        \\n        for i in range(len(s)):\\n            left = i +1\\n            cur = \"\"\\n            while left<=len(s):\\n                # print(s[i:left])\\n                cur = s[i:left] if s[i:left]==s[i:left][::-1] else cur \\n                left+=1 \\n            dp = max(dp,cur,key=len)\\n      \\n        return dp \\n```"
                    },
                    {
                        "username": "pktk001",
                        "content": "141th testcase is not visible. I\\'m getting TLE on 141th testcase when I try to solve it with hashing.\\n"
                    }
                ]
            },
            {
                "id": 1798978,
                "content": [
                    {
                        "username": "Sampath3756",
                        "content": "in my code i am able to pass all test cases but time limit exceeds, my approach of the problem is using for of for loop for starting and ending point of the substring, and checking the substring is palindrome or not, if it is palindrome comparing the sizes of the longest and current sub string and replacing the longest string with current sub string, could anyone help me for getting my approach better and pass all test cases in time"
                    },
                    {
                        "username": "steve1302",
                        "content": "for input  \"aacabdkacaa\" test case is expecting \"aca\" which is incorrect output.  \"aaca\" is the correct one. how can we solve this??"
                    },
                    {
                        "username": "AMerrill",
                        "content": "\"*aca*\" is the correct output, as \"*aaca*\" is not a palindrome."
                    },
                    {
                        "username": "jems1123",
                        "content": "Can some one implement LCS with recursion and  return data type should be string"
                    },
                    {
                        "username": "user5248P",
                        "content": "LeetCode needs to improve the test cases here. My brute force solution was good enough"
                    },
                    {
                        "username": "vishal0509",
                        "content": "time limit exceeded :("
                    },
                    {
                        "username": "vishal0509",
                        "content": "i am using o(n^2) "
                    },
                    {
                        "username": "AveryBurke",
                        "content": " [@LeetCode](/LeetCode)\nthe expected answer for test case 46 is incorrect.\nThe test string is \"aacabdkacaa\" and the expected out put is \"aca\". I can obtain the following palindromes of length 9 by deleting substring (i've added spacing to make this easier to see):\n\n\"aaca b acaa\" by deleting the substring 'dk'\n\"aaca k acaa\" by deleting the substring 'bd'\n\"aaca d acaa\" by deleting the substrings 'b' and 'k'\n\nmy solution produces the palindrome \"aacabacaa\" (deleting 'dk') but the solution is rejected on test case 46.  How do I get my solution accepted?  \n"
                    },
                    {
                        "username": "slashtab",
                        "content": "The substring is continuous part of the string. You can not delete some characters in-between. "
                    },
                    {
                        "username": "lakshyag9775",
                        "content": "Please Put it under  **HARD** Tag"
                    },
                    {
                        "username": "CristianM92",
                        "content": "Check Manacher\\u2019s algorithm"
                    },
                    {
                        "username": "aayushnag84",
                        "content": "Can anyone explain why this code is not working?\\n\\n\\n``class Solution \\n{\\n      public String longestPalindrome(String s) \\n    {\\n        recur(s, 0, s.length()-1);\\n        System.out.println(max);\\n        return ans;\\n    }\\n    static int max = 0;\\n    static String ans = \"\";\\n    public static int recur(String s, int i, int j)\\n    {\\n        if(i==j) return 1;\\n        else if(j-i == 1 && s.charAt(i)==s.charAt(j)) return 2;\\n        else if(j-i == 1) return 1;\\n        else\\n        {\\n            if(s.charAt(i) == s.charAt(j)) \\n            {         \\n                System.out.println(s.substring(i,j+1));       \\n                int temp = 2 + recur(s, i+1, j-1);\\n                max = temp>max ? temp: max;\\n                ans = temp>max ? s.substring(i,j+1) : ans;\\n                return temp;\\n            }                \\n            else \\n            {\\n                System.out.println(s.substring(i,j+1)); \\n                int temp = recur(s, i+1, j-1);\\n                max = temp>max ? temp : max;\\n                ans = temp>max ? s.substring(i,j+1) : ans;\\n                return temp;\\n            }\\n        }\\n    }\\n}``"
                    },
                    {
                        "username": "Primus4",
                        "content": "my 131 test cases have passed and code runs excellent in other compilers but here it gives garbage value;\\n "
                    }
                ]
            },
            {
                "id": 1798409,
                "content": [
                    {
                        "username": "Sampath3756",
                        "content": "in my code i am able to pass all test cases but time limit exceeds, my approach of the problem is using for of for loop for starting and ending point of the substring, and checking the substring is palindrome or not, if it is palindrome comparing the sizes of the longest and current sub string and replacing the longest string with current sub string, could anyone help me for getting my approach better and pass all test cases in time"
                    },
                    {
                        "username": "steve1302",
                        "content": "for input  \"aacabdkacaa\" test case is expecting \"aca\" which is incorrect output.  \"aaca\" is the correct one. how can we solve this??"
                    },
                    {
                        "username": "AMerrill",
                        "content": "\"*aca*\" is the correct output, as \"*aaca*\" is not a palindrome."
                    },
                    {
                        "username": "jems1123",
                        "content": "Can some one implement LCS with recursion and  return data type should be string"
                    },
                    {
                        "username": "user5248P",
                        "content": "LeetCode needs to improve the test cases here. My brute force solution was good enough"
                    },
                    {
                        "username": "vishal0509",
                        "content": "time limit exceeded :("
                    },
                    {
                        "username": "vishal0509",
                        "content": "i am using o(n^2) "
                    },
                    {
                        "username": "AveryBurke",
                        "content": " [@LeetCode](/LeetCode)\nthe expected answer for test case 46 is incorrect.\nThe test string is \"aacabdkacaa\" and the expected out put is \"aca\". I can obtain the following palindromes of length 9 by deleting substring (i've added spacing to make this easier to see):\n\n\"aaca b acaa\" by deleting the substring 'dk'\n\"aaca k acaa\" by deleting the substring 'bd'\n\"aaca d acaa\" by deleting the substrings 'b' and 'k'\n\nmy solution produces the palindrome \"aacabacaa\" (deleting 'dk') but the solution is rejected on test case 46.  How do I get my solution accepted?  \n"
                    },
                    {
                        "username": "slashtab",
                        "content": "The substring is continuous part of the string. You can not delete some characters in-between. "
                    },
                    {
                        "username": "lakshyag9775",
                        "content": "Please Put it under  **HARD** Tag"
                    },
                    {
                        "username": "CristianM92",
                        "content": "Check Manacher\\u2019s algorithm"
                    },
                    {
                        "username": "aayushnag84",
                        "content": "Can anyone explain why this code is not working?\\n\\n\\n``class Solution \\n{\\n      public String longestPalindrome(String s) \\n    {\\n        recur(s, 0, s.length()-1);\\n        System.out.println(max);\\n        return ans;\\n    }\\n    static int max = 0;\\n    static String ans = \"\";\\n    public static int recur(String s, int i, int j)\\n    {\\n        if(i==j) return 1;\\n        else if(j-i == 1 && s.charAt(i)==s.charAt(j)) return 2;\\n        else if(j-i == 1) return 1;\\n        else\\n        {\\n            if(s.charAt(i) == s.charAt(j)) \\n            {         \\n                System.out.println(s.substring(i,j+1));       \\n                int temp = 2 + recur(s, i+1, j-1);\\n                max = temp>max ? temp: max;\\n                ans = temp>max ? s.substring(i,j+1) : ans;\\n                return temp;\\n            }                \\n            else \\n            {\\n                System.out.println(s.substring(i,j+1)); \\n                int temp = recur(s, i+1, j-1);\\n                max = temp>max ? temp : max;\\n                ans = temp>max ? s.substring(i,j+1) : ans;\\n                return temp;\\n            }\\n        }\\n    }\\n}``"
                    },
                    {
                        "username": "Primus4",
                        "content": "my 131 test cases have passed and code runs excellent in other compilers but here it gives garbage value;\\n "
                    }
                ]
            },
            {
                "id": 1796077,
                "content": [
                    {
                        "username": "Sampath3756",
                        "content": "in my code i am able to pass all test cases but time limit exceeds, my approach of the problem is using for of for loop for starting and ending point of the substring, and checking the substring is palindrome or not, if it is palindrome comparing the sizes of the longest and current sub string and replacing the longest string with current sub string, could anyone help me for getting my approach better and pass all test cases in time"
                    },
                    {
                        "username": "steve1302",
                        "content": "for input  \"aacabdkacaa\" test case is expecting \"aca\" which is incorrect output.  \"aaca\" is the correct one. how can we solve this??"
                    },
                    {
                        "username": "AMerrill",
                        "content": "\"*aca*\" is the correct output, as \"*aaca*\" is not a palindrome."
                    },
                    {
                        "username": "jems1123",
                        "content": "Can some one implement LCS with recursion and  return data type should be string"
                    },
                    {
                        "username": "user5248P",
                        "content": "LeetCode needs to improve the test cases here. My brute force solution was good enough"
                    },
                    {
                        "username": "vishal0509",
                        "content": "time limit exceeded :("
                    },
                    {
                        "username": "vishal0509",
                        "content": "i am using o(n^2) "
                    },
                    {
                        "username": "AveryBurke",
                        "content": " [@LeetCode](/LeetCode)\nthe expected answer for test case 46 is incorrect.\nThe test string is \"aacabdkacaa\" and the expected out put is \"aca\". I can obtain the following palindromes of length 9 by deleting substring (i've added spacing to make this easier to see):\n\n\"aaca b acaa\" by deleting the substring 'dk'\n\"aaca k acaa\" by deleting the substring 'bd'\n\"aaca d acaa\" by deleting the substrings 'b' and 'k'\n\nmy solution produces the palindrome \"aacabacaa\" (deleting 'dk') but the solution is rejected on test case 46.  How do I get my solution accepted?  \n"
                    },
                    {
                        "username": "slashtab",
                        "content": "The substring is continuous part of the string. You can not delete some characters in-between. "
                    },
                    {
                        "username": "lakshyag9775",
                        "content": "Please Put it under  **HARD** Tag"
                    },
                    {
                        "username": "CristianM92",
                        "content": "Check Manacher\\u2019s algorithm"
                    },
                    {
                        "username": "aayushnag84",
                        "content": "Can anyone explain why this code is not working?\\n\\n\\n``class Solution \\n{\\n      public String longestPalindrome(String s) \\n    {\\n        recur(s, 0, s.length()-1);\\n        System.out.println(max);\\n        return ans;\\n    }\\n    static int max = 0;\\n    static String ans = \"\";\\n    public static int recur(String s, int i, int j)\\n    {\\n        if(i==j) return 1;\\n        else if(j-i == 1 && s.charAt(i)==s.charAt(j)) return 2;\\n        else if(j-i == 1) return 1;\\n        else\\n        {\\n            if(s.charAt(i) == s.charAt(j)) \\n            {         \\n                System.out.println(s.substring(i,j+1));       \\n                int temp = 2 + recur(s, i+1, j-1);\\n                max = temp>max ? temp: max;\\n                ans = temp>max ? s.substring(i,j+1) : ans;\\n                return temp;\\n            }                \\n            else \\n            {\\n                System.out.println(s.substring(i,j+1)); \\n                int temp = recur(s, i+1, j-1);\\n                max = temp>max ? temp : max;\\n                ans = temp>max ? s.substring(i,j+1) : ans;\\n                return temp;\\n            }\\n        }\\n    }\\n}``"
                    },
                    {
                        "username": "Primus4",
                        "content": "my 131 test cases have passed and code runs excellent in other compilers but here it gives garbage value;\\n "
                    }
                ]
            },
            {
                "id": 1795396,
                "content": [
                    {
                        "username": "Sampath3756",
                        "content": "in my code i am able to pass all test cases but time limit exceeds, my approach of the problem is using for of for loop for starting and ending point of the substring, and checking the substring is palindrome or not, if it is palindrome comparing the sizes of the longest and current sub string and replacing the longest string with current sub string, could anyone help me for getting my approach better and pass all test cases in time"
                    },
                    {
                        "username": "steve1302",
                        "content": "for input  \"aacabdkacaa\" test case is expecting \"aca\" which is incorrect output.  \"aaca\" is the correct one. how can we solve this??"
                    },
                    {
                        "username": "AMerrill",
                        "content": "\"*aca*\" is the correct output, as \"*aaca*\" is not a palindrome."
                    },
                    {
                        "username": "jems1123",
                        "content": "Can some one implement LCS with recursion and  return data type should be string"
                    },
                    {
                        "username": "user5248P",
                        "content": "LeetCode needs to improve the test cases here. My brute force solution was good enough"
                    },
                    {
                        "username": "vishal0509",
                        "content": "time limit exceeded :("
                    },
                    {
                        "username": "vishal0509",
                        "content": "i am using o(n^2) "
                    },
                    {
                        "username": "AveryBurke",
                        "content": " [@LeetCode](/LeetCode)\nthe expected answer for test case 46 is incorrect.\nThe test string is \"aacabdkacaa\" and the expected out put is \"aca\". I can obtain the following palindromes of length 9 by deleting substring (i've added spacing to make this easier to see):\n\n\"aaca b acaa\" by deleting the substring 'dk'\n\"aaca k acaa\" by deleting the substring 'bd'\n\"aaca d acaa\" by deleting the substrings 'b' and 'k'\n\nmy solution produces the palindrome \"aacabacaa\" (deleting 'dk') but the solution is rejected on test case 46.  How do I get my solution accepted?  \n"
                    },
                    {
                        "username": "slashtab",
                        "content": "The substring is continuous part of the string. You can not delete some characters in-between. "
                    },
                    {
                        "username": "lakshyag9775",
                        "content": "Please Put it under  **HARD** Tag"
                    },
                    {
                        "username": "CristianM92",
                        "content": "Check Manacher\\u2019s algorithm"
                    },
                    {
                        "username": "aayushnag84",
                        "content": "Can anyone explain why this code is not working?\\n\\n\\n``class Solution \\n{\\n      public String longestPalindrome(String s) \\n    {\\n        recur(s, 0, s.length()-1);\\n        System.out.println(max);\\n        return ans;\\n    }\\n    static int max = 0;\\n    static String ans = \"\";\\n    public static int recur(String s, int i, int j)\\n    {\\n        if(i==j) return 1;\\n        else if(j-i == 1 && s.charAt(i)==s.charAt(j)) return 2;\\n        else if(j-i == 1) return 1;\\n        else\\n        {\\n            if(s.charAt(i) == s.charAt(j)) \\n            {         \\n                System.out.println(s.substring(i,j+1));       \\n                int temp = 2 + recur(s, i+1, j-1);\\n                max = temp>max ? temp: max;\\n                ans = temp>max ? s.substring(i,j+1) : ans;\\n                return temp;\\n            }                \\n            else \\n            {\\n                System.out.println(s.substring(i,j+1)); \\n                int temp = recur(s, i+1, j-1);\\n                max = temp>max ? temp : max;\\n                ans = temp>max ? s.substring(i,j+1) : ans;\\n                return temp;\\n            }\\n        }\\n    }\\n}``"
                    },
                    {
                        "username": "Primus4",
                        "content": "my 131 test cases have passed and code runs excellent in other compilers but here it gives garbage value;\\n "
                    }
                ]
            },
            {
                "id": 1792944,
                "content": [
                    {
                        "username": "Sampath3756",
                        "content": "in my code i am able to pass all test cases but time limit exceeds, my approach of the problem is using for of for loop for starting and ending point of the substring, and checking the substring is palindrome or not, if it is palindrome comparing the sizes of the longest and current sub string and replacing the longest string with current sub string, could anyone help me for getting my approach better and pass all test cases in time"
                    },
                    {
                        "username": "steve1302",
                        "content": "for input  \"aacabdkacaa\" test case is expecting \"aca\" which is incorrect output.  \"aaca\" is the correct one. how can we solve this??"
                    },
                    {
                        "username": "AMerrill",
                        "content": "\"*aca*\" is the correct output, as \"*aaca*\" is not a palindrome."
                    },
                    {
                        "username": "jems1123",
                        "content": "Can some one implement LCS with recursion and  return data type should be string"
                    },
                    {
                        "username": "user5248P",
                        "content": "LeetCode needs to improve the test cases here. My brute force solution was good enough"
                    },
                    {
                        "username": "vishal0509",
                        "content": "time limit exceeded :("
                    },
                    {
                        "username": "vishal0509",
                        "content": "i am using o(n^2) "
                    },
                    {
                        "username": "AveryBurke",
                        "content": " [@LeetCode](/LeetCode)\nthe expected answer for test case 46 is incorrect.\nThe test string is \"aacabdkacaa\" and the expected out put is \"aca\". I can obtain the following palindromes of length 9 by deleting substring (i've added spacing to make this easier to see):\n\n\"aaca b acaa\" by deleting the substring 'dk'\n\"aaca k acaa\" by deleting the substring 'bd'\n\"aaca d acaa\" by deleting the substrings 'b' and 'k'\n\nmy solution produces the palindrome \"aacabacaa\" (deleting 'dk') but the solution is rejected on test case 46.  How do I get my solution accepted?  \n"
                    },
                    {
                        "username": "slashtab",
                        "content": "The substring is continuous part of the string. You can not delete some characters in-between. "
                    },
                    {
                        "username": "lakshyag9775",
                        "content": "Please Put it under  **HARD** Tag"
                    },
                    {
                        "username": "CristianM92",
                        "content": "Check Manacher\\u2019s algorithm"
                    },
                    {
                        "username": "aayushnag84",
                        "content": "Can anyone explain why this code is not working?\\n\\n\\n``class Solution \\n{\\n      public String longestPalindrome(String s) \\n    {\\n        recur(s, 0, s.length()-1);\\n        System.out.println(max);\\n        return ans;\\n    }\\n    static int max = 0;\\n    static String ans = \"\";\\n    public static int recur(String s, int i, int j)\\n    {\\n        if(i==j) return 1;\\n        else if(j-i == 1 && s.charAt(i)==s.charAt(j)) return 2;\\n        else if(j-i == 1) return 1;\\n        else\\n        {\\n            if(s.charAt(i) == s.charAt(j)) \\n            {         \\n                System.out.println(s.substring(i,j+1));       \\n                int temp = 2 + recur(s, i+1, j-1);\\n                max = temp>max ? temp: max;\\n                ans = temp>max ? s.substring(i,j+1) : ans;\\n                return temp;\\n            }                \\n            else \\n            {\\n                System.out.println(s.substring(i,j+1)); \\n                int temp = recur(s, i+1, j-1);\\n                max = temp>max ? temp : max;\\n                ans = temp>max ? s.substring(i,j+1) : ans;\\n                return temp;\\n            }\\n        }\\n    }\\n}``"
                    },
                    {
                        "username": "Primus4",
                        "content": "my 131 test cases have passed and code runs excellent in other compilers but here it gives garbage value;\\n "
                    }
                ]
            },
            {
                "id": 1792517,
                "content": [
                    {
                        "username": "Sampath3756",
                        "content": "in my code i am able to pass all test cases but time limit exceeds, my approach of the problem is using for of for loop for starting and ending point of the substring, and checking the substring is palindrome or not, if it is palindrome comparing the sizes of the longest and current sub string and replacing the longest string with current sub string, could anyone help me for getting my approach better and pass all test cases in time"
                    },
                    {
                        "username": "steve1302",
                        "content": "for input  \"aacabdkacaa\" test case is expecting \"aca\" which is incorrect output.  \"aaca\" is the correct one. how can we solve this??"
                    },
                    {
                        "username": "AMerrill",
                        "content": "\"*aca*\" is the correct output, as \"*aaca*\" is not a palindrome."
                    },
                    {
                        "username": "jems1123",
                        "content": "Can some one implement LCS with recursion and  return data type should be string"
                    },
                    {
                        "username": "user5248P",
                        "content": "LeetCode needs to improve the test cases here. My brute force solution was good enough"
                    },
                    {
                        "username": "vishal0509",
                        "content": "time limit exceeded :("
                    },
                    {
                        "username": "vishal0509",
                        "content": "i am using o(n^2) "
                    },
                    {
                        "username": "AveryBurke",
                        "content": " [@LeetCode](/LeetCode)\nthe expected answer for test case 46 is incorrect.\nThe test string is \"aacabdkacaa\" and the expected out put is \"aca\". I can obtain the following palindromes of length 9 by deleting substring (i've added spacing to make this easier to see):\n\n\"aaca b acaa\" by deleting the substring 'dk'\n\"aaca k acaa\" by deleting the substring 'bd'\n\"aaca d acaa\" by deleting the substrings 'b' and 'k'\n\nmy solution produces the palindrome \"aacabacaa\" (deleting 'dk') but the solution is rejected on test case 46.  How do I get my solution accepted?  \n"
                    },
                    {
                        "username": "slashtab",
                        "content": "The substring is continuous part of the string. You can not delete some characters in-between. "
                    },
                    {
                        "username": "lakshyag9775",
                        "content": "Please Put it under  **HARD** Tag"
                    },
                    {
                        "username": "CristianM92",
                        "content": "Check Manacher\\u2019s algorithm"
                    },
                    {
                        "username": "aayushnag84",
                        "content": "Can anyone explain why this code is not working?\\n\\n\\n``class Solution \\n{\\n      public String longestPalindrome(String s) \\n    {\\n        recur(s, 0, s.length()-1);\\n        System.out.println(max);\\n        return ans;\\n    }\\n    static int max = 0;\\n    static String ans = \"\";\\n    public static int recur(String s, int i, int j)\\n    {\\n        if(i==j) return 1;\\n        else if(j-i == 1 && s.charAt(i)==s.charAt(j)) return 2;\\n        else if(j-i == 1) return 1;\\n        else\\n        {\\n            if(s.charAt(i) == s.charAt(j)) \\n            {         \\n                System.out.println(s.substring(i,j+1));       \\n                int temp = 2 + recur(s, i+1, j-1);\\n                max = temp>max ? temp: max;\\n                ans = temp>max ? s.substring(i,j+1) : ans;\\n                return temp;\\n            }                \\n            else \\n            {\\n                System.out.println(s.substring(i,j+1)); \\n                int temp = recur(s, i+1, j-1);\\n                max = temp>max ? temp : max;\\n                ans = temp>max ? s.substring(i,j+1) : ans;\\n                return temp;\\n            }\\n        }\\n    }\\n}``"
                    },
                    {
                        "username": "Primus4",
                        "content": "my 131 test cases have passed and code runs excellent in other compilers but here it gives garbage value;\\n "
                    }
                ]
            },
            {
                "id": 1791003,
                "content": [
                    {
                        "username": "Sampath3756",
                        "content": "in my code i am able to pass all test cases but time limit exceeds, my approach of the problem is using for of for loop for starting and ending point of the substring, and checking the substring is palindrome or not, if it is palindrome comparing the sizes of the longest and current sub string and replacing the longest string with current sub string, could anyone help me for getting my approach better and pass all test cases in time"
                    },
                    {
                        "username": "steve1302",
                        "content": "for input  \"aacabdkacaa\" test case is expecting \"aca\" which is incorrect output.  \"aaca\" is the correct one. how can we solve this??"
                    },
                    {
                        "username": "AMerrill",
                        "content": "\"*aca*\" is the correct output, as \"*aaca*\" is not a palindrome."
                    },
                    {
                        "username": "jems1123",
                        "content": "Can some one implement LCS with recursion and  return data type should be string"
                    },
                    {
                        "username": "user5248P",
                        "content": "LeetCode needs to improve the test cases here. My brute force solution was good enough"
                    },
                    {
                        "username": "vishal0509",
                        "content": "time limit exceeded :("
                    },
                    {
                        "username": "vishal0509",
                        "content": "i am using o(n^2) "
                    },
                    {
                        "username": "AveryBurke",
                        "content": " [@LeetCode](/LeetCode)\nthe expected answer for test case 46 is incorrect.\nThe test string is \"aacabdkacaa\" and the expected out put is \"aca\". I can obtain the following palindromes of length 9 by deleting substring (i've added spacing to make this easier to see):\n\n\"aaca b acaa\" by deleting the substring 'dk'\n\"aaca k acaa\" by deleting the substring 'bd'\n\"aaca d acaa\" by deleting the substrings 'b' and 'k'\n\nmy solution produces the palindrome \"aacabacaa\" (deleting 'dk') but the solution is rejected on test case 46.  How do I get my solution accepted?  \n"
                    },
                    {
                        "username": "slashtab",
                        "content": "The substring is continuous part of the string. You can not delete some characters in-between. "
                    },
                    {
                        "username": "lakshyag9775",
                        "content": "Please Put it under  **HARD** Tag"
                    },
                    {
                        "username": "CristianM92",
                        "content": "Check Manacher\\u2019s algorithm"
                    },
                    {
                        "username": "aayushnag84",
                        "content": "Can anyone explain why this code is not working?\\n\\n\\n``class Solution \\n{\\n      public String longestPalindrome(String s) \\n    {\\n        recur(s, 0, s.length()-1);\\n        System.out.println(max);\\n        return ans;\\n    }\\n    static int max = 0;\\n    static String ans = \"\";\\n    public static int recur(String s, int i, int j)\\n    {\\n        if(i==j) return 1;\\n        else if(j-i == 1 && s.charAt(i)==s.charAt(j)) return 2;\\n        else if(j-i == 1) return 1;\\n        else\\n        {\\n            if(s.charAt(i) == s.charAt(j)) \\n            {         \\n                System.out.println(s.substring(i,j+1));       \\n                int temp = 2 + recur(s, i+1, j-1);\\n                max = temp>max ? temp: max;\\n                ans = temp>max ? s.substring(i,j+1) : ans;\\n                return temp;\\n            }                \\n            else \\n            {\\n                System.out.println(s.substring(i,j+1)); \\n                int temp = recur(s, i+1, j-1);\\n                max = temp>max ? temp : max;\\n                ans = temp>max ? s.substring(i,j+1) : ans;\\n                return temp;\\n            }\\n        }\\n    }\\n}``"
                    },
                    {
                        "username": "Primus4",
                        "content": "my 131 test cases have passed and code runs excellent in other compilers but here it gives garbage value;\\n "
                    }
                ]
            },
            {
                "id": 1789086,
                "content": [
                    {
                        "username": "Sampath3756",
                        "content": "in my code i am able to pass all test cases but time limit exceeds, my approach of the problem is using for of for loop for starting and ending point of the substring, and checking the substring is palindrome or not, if it is palindrome comparing the sizes of the longest and current sub string and replacing the longest string with current sub string, could anyone help me for getting my approach better and pass all test cases in time"
                    },
                    {
                        "username": "steve1302",
                        "content": "for input  \"aacabdkacaa\" test case is expecting \"aca\" which is incorrect output.  \"aaca\" is the correct one. how can we solve this??"
                    },
                    {
                        "username": "AMerrill",
                        "content": "\"*aca*\" is the correct output, as \"*aaca*\" is not a palindrome."
                    },
                    {
                        "username": "jems1123",
                        "content": "Can some one implement LCS with recursion and  return data type should be string"
                    },
                    {
                        "username": "user5248P",
                        "content": "LeetCode needs to improve the test cases here. My brute force solution was good enough"
                    },
                    {
                        "username": "vishal0509",
                        "content": "time limit exceeded :("
                    },
                    {
                        "username": "vishal0509",
                        "content": "i am using o(n^2) "
                    },
                    {
                        "username": "AveryBurke",
                        "content": " [@LeetCode](/LeetCode)\nthe expected answer for test case 46 is incorrect.\nThe test string is \"aacabdkacaa\" and the expected out put is \"aca\". I can obtain the following palindromes of length 9 by deleting substring (i've added spacing to make this easier to see):\n\n\"aaca b acaa\" by deleting the substring 'dk'\n\"aaca k acaa\" by deleting the substring 'bd'\n\"aaca d acaa\" by deleting the substrings 'b' and 'k'\n\nmy solution produces the palindrome \"aacabacaa\" (deleting 'dk') but the solution is rejected on test case 46.  How do I get my solution accepted?  \n"
                    },
                    {
                        "username": "slashtab",
                        "content": "The substring is continuous part of the string. You can not delete some characters in-between. "
                    },
                    {
                        "username": "lakshyag9775",
                        "content": "Please Put it under  **HARD** Tag"
                    },
                    {
                        "username": "CristianM92",
                        "content": "Check Manacher\\u2019s algorithm"
                    },
                    {
                        "username": "aayushnag84",
                        "content": "Can anyone explain why this code is not working?\\n\\n\\n``class Solution \\n{\\n      public String longestPalindrome(String s) \\n    {\\n        recur(s, 0, s.length()-1);\\n        System.out.println(max);\\n        return ans;\\n    }\\n    static int max = 0;\\n    static String ans = \"\";\\n    public static int recur(String s, int i, int j)\\n    {\\n        if(i==j) return 1;\\n        else if(j-i == 1 && s.charAt(i)==s.charAt(j)) return 2;\\n        else if(j-i == 1) return 1;\\n        else\\n        {\\n            if(s.charAt(i) == s.charAt(j)) \\n            {         \\n                System.out.println(s.substring(i,j+1));       \\n                int temp = 2 + recur(s, i+1, j-1);\\n                max = temp>max ? temp: max;\\n                ans = temp>max ? s.substring(i,j+1) : ans;\\n                return temp;\\n            }                \\n            else \\n            {\\n                System.out.println(s.substring(i,j+1)); \\n                int temp = recur(s, i+1, j-1);\\n                max = temp>max ? temp : max;\\n                ans = temp>max ? s.substring(i,j+1) : ans;\\n                return temp;\\n            }\\n        }\\n    }\\n}``"
                    },
                    {
                        "username": "Primus4",
                        "content": "my 131 test cases have passed and code runs excellent in other compilers but here it gives garbage value;\\n "
                    }
                ]
            },
            {
                "id": 1786279,
                "content": [
                    {
                        "username": "Sampath3756",
                        "content": "in my code i am able to pass all test cases but time limit exceeds, my approach of the problem is using for of for loop for starting and ending point of the substring, and checking the substring is palindrome or not, if it is palindrome comparing the sizes of the longest and current sub string and replacing the longest string with current sub string, could anyone help me for getting my approach better and pass all test cases in time"
                    },
                    {
                        "username": "steve1302",
                        "content": "for input  \"aacabdkacaa\" test case is expecting \"aca\" which is incorrect output.  \"aaca\" is the correct one. how can we solve this??"
                    },
                    {
                        "username": "AMerrill",
                        "content": "\"*aca*\" is the correct output, as \"*aaca*\" is not a palindrome."
                    },
                    {
                        "username": "jems1123",
                        "content": "Can some one implement LCS with recursion and  return data type should be string"
                    },
                    {
                        "username": "user5248P",
                        "content": "LeetCode needs to improve the test cases here. My brute force solution was good enough"
                    },
                    {
                        "username": "vishal0509",
                        "content": "time limit exceeded :("
                    },
                    {
                        "username": "vishal0509",
                        "content": "i am using o(n^2) "
                    },
                    {
                        "username": "AveryBurke",
                        "content": " [@LeetCode](/LeetCode)\nthe expected answer for test case 46 is incorrect.\nThe test string is \"aacabdkacaa\" and the expected out put is \"aca\". I can obtain the following palindromes of length 9 by deleting substring (i've added spacing to make this easier to see):\n\n\"aaca b acaa\" by deleting the substring 'dk'\n\"aaca k acaa\" by deleting the substring 'bd'\n\"aaca d acaa\" by deleting the substrings 'b' and 'k'\n\nmy solution produces the palindrome \"aacabacaa\" (deleting 'dk') but the solution is rejected on test case 46.  How do I get my solution accepted?  \n"
                    },
                    {
                        "username": "slashtab",
                        "content": "The substring is continuous part of the string. You can not delete some characters in-between. "
                    },
                    {
                        "username": "lakshyag9775",
                        "content": "Please Put it under  **HARD** Tag"
                    },
                    {
                        "username": "CristianM92",
                        "content": "Check Manacher\\u2019s algorithm"
                    },
                    {
                        "username": "aayushnag84",
                        "content": "Can anyone explain why this code is not working?\\n\\n\\n``class Solution \\n{\\n      public String longestPalindrome(String s) \\n    {\\n        recur(s, 0, s.length()-1);\\n        System.out.println(max);\\n        return ans;\\n    }\\n    static int max = 0;\\n    static String ans = \"\";\\n    public static int recur(String s, int i, int j)\\n    {\\n        if(i==j) return 1;\\n        else if(j-i == 1 && s.charAt(i)==s.charAt(j)) return 2;\\n        else if(j-i == 1) return 1;\\n        else\\n        {\\n            if(s.charAt(i) == s.charAt(j)) \\n            {         \\n                System.out.println(s.substring(i,j+1));       \\n                int temp = 2 + recur(s, i+1, j-1);\\n                max = temp>max ? temp: max;\\n                ans = temp>max ? s.substring(i,j+1) : ans;\\n                return temp;\\n            }                \\n            else \\n            {\\n                System.out.println(s.substring(i,j+1)); \\n                int temp = recur(s, i+1, j-1);\\n                max = temp>max ? temp : max;\\n                ans = temp>max ? s.substring(i,j+1) : ans;\\n                return temp;\\n            }\\n        }\\n    }\\n}``"
                    },
                    {
                        "username": "Primus4",
                        "content": "my 131 test cases have passed and code runs excellent in other compilers but here it gives garbage value;\\n "
                    }
                ]
            },
            {
                "id": 1785028,
                "content": [
                    {
                        "username": "Sampath3756",
                        "content": "in my code i am able to pass all test cases but time limit exceeds, my approach of the problem is using for of for loop for starting and ending point of the substring, and checking the substring is palindrome or not, if it is palindrome comparing the sizes of the longest and current sub string and replacing the longest string with current sub string, could anyone help me for getting my approach better and pass all test cases in time"
                    },
                    {
                        "username": "steve1302",
                        "content": "for input  \"aacabdkacaa\" test case is expecting \"aca\" which is incorrect output.  \"aaca\" is the correct one. how can we solve this??"
                    },
                    {
                        "username": "AMerrill",
                        "content": "\"*aca*\" is the correct output, as \"*aaca*\" is not a palindrome."
                    },
                    {
                        "username": "jems1123",
                        "content": "Can some one implement LCS with recursion and  return data type should be string"
                    },
                    {
                        "username": "user5248P",
                        "content": "LeetCode needs to improve the test cases here. My brute force solution was good enough"
                    },
                    {
                        "username": "vishal0509",
                        "content": "time limit exceeded :("
                    },
                    {
                        "username": "vishal0509",
                        "content": "i am using o(n^2) "
                    },
                    {
                        "username": "AveryBurke",
                        "content": " [@LeetCode](/LeetCode)\nthe expected answer for test case 46 is incorrect.\nThe test string is \"aacabdkacaa\" and the expected out put is \"aca\". I can obtain the following palindromes of length 9 by deleting substring (i've added spacing to make this easier to see):\n\n\"aaca b acaa\" by deleting the substring 'dk'\n\"aaca k acaa\" by deleting the substring 'bd'\n\"aaca d acaa\" by deleting the substrings 'b' and 'k'\n\nmy solution produces the palindrome \"aacabacaa\" (deleting 'dk') but the solution is rejected on test case 46.  How do I get my solution accepted?  \n"
                    },
                    {
                        "username": "slashtab",
                        "content": "The substring is continuous part of the string. You can not delete some characters in-between. "
                    },
                    {
                        "username": "lakshyag9775",
                        "content": "Please Put it under  **HARD** Tag"
                    },
                    {
                        "username": "CristianM92",
                        "content": "Check Manacher\\u2019s algorithm"
                    },
                    {
                        "username": "aayushnag84",
                        "content": "Can anyone explain why this code is not working?\\n\\n\\n``class Solution \\n{\\n      public String longestPalindrome(String s) \\n    {\\n        recur(s, 0, s.length()-1);\\n        System.out.println(max);\\n        return ans;\\n    }\\n    static int max = 0;\\n    static String ans = \"\";\\n    public static int recur(String s, int i, int j)\\n    {\\n        if(i==j) return 1;\\n        else if(j-i == 1 && s.charAt(i)==s.charAt(j)) return 2;\\n        else if(j-i == 1) return 1;\\n        else\\n        {\\n            if(s.charAt(i) == s.charAt(j)) \\n            {         \\n                System.out.println(s.substring(i,j+1));       \\n                int temp = 2 + recur(s, i+1, j-1);\\n                max = temp>max ? temp: max;\\n                ans = temp>max ? s.substring(i,j+1) : ans;\\n                return temp;\\n            }                \\n            else \\n            {\\n                System.out.println(s.substring(i,j+1)); \\n                int temp = recur(s, i+1, j-1);\\n                max = temp>max ? temp : max;\\n                ans = temp>max ? s.substring(i,j+1) : ans;\\n                return temp;\\n            }\\n        }\\n    }\\n}``"
                    },
                    {
                        "username": "Primus4",
                        "content": "my 131 test cases have passed and code runs excellent in other compilers but here it gives garbage value;\\n "
                    }
                ]
            },
            {
                "id": 1780987,
                "content": [
                    {
                        "username": "kasomaibrahim",
                        "content": "A faster solution with time complexity of O(n) is the Manacher algorithm. It utilizes the idea that if a palindrome has its center at the current position and its right boundary has reached position j, then the palindrome with its center at the current position will have the same length as the palindrome with its center at the symmetrical position of j with respect to the current position, as long as j is within the boundary of the palindrome with center at the current position."
                    },
                    {
                        "username": "Satyarth_Agrahari",
                        "content": "The C++ code provided implements Manacher\\'s algorithm to find the longest palindromic substring in a given input string.\\n\\nThe code starts by defining a function named \"longestPalindrome\" which takes a string as its input and returns a string as its output.\\n\\nThe first step in the function is to preprocess the input string by inserting special characters between each character and also at the beginning and end of the string. This is done by creating a new string \"temp\" and iterating through each character in the input string, adding it to \"temp\" and also adding the special character \"#\" after it. This modified string is then stored in \"s\".\\n\\nNext, the code defines two arrays \"p\" and \"id\" of size n+1, where n is the length of the modified string. The array \"p\" is used to hold the length of the palindrome centered at each character in the modified string and the array \"id\" is used to keep track of the center and right boundary of the current palindrome.\\n\\nThe code then initializes two variables \"mx\" and \"id\" to 0 and assigns the value 0 to all elements of the \"p\" array.\\n\\nThe algorithm then starts iterating through each character in the modified string using a for loop, for each i in s.\\n\\nThe first thing the code does inside the for loop is to check if the current character is within the right boundary of the previous palindrome. If so, it uses the \"mirroring\" technique to calculate the length of the palindrome centered at the current character. It sets the value of \"p[i]\" to the minimum of \"p[(id*2-i)\" and \"mx-i\".\\n\\nOtherwise, the code falls back to the \"expanding around the center\" technique and starts checking the characters on both sides of the current character to find the length of the palindrome centered at the current character.\\n\\nThe code then updates the \"mx\" and \"id\" variables if the current palindrome exceeds the right boundary of the previous palindrome.\\n\\nFinally, the code finds the center and length of the longest palindrome by iterating through the \"p\" array and returning the substring of the original input string using the center and length information.\\n\\nIt\\'s important to note that the above code is just an example and this specific implementation may be different from other ones, but the overall idea and algorithm remains the same."
                    },
                    {
                        "username": "paragtharani24",
                        "content": "can anyone please optimize  below code:\\n\\n/**\\n * @param {string} s\\n * @return {string}\\n */\\nvar longestPalindrome = function(s) {\\n    let longestPalString = \"\"\\n    for(var i=0; i<s.length; i++){\\n        let str = \"\"\\n        for(var j=i; j<s.length; j++){\\n            str = str + s[j]\\n            if(isPalindrome(str)){\\n                if(str.length > longestPalString.length){\\n                    longestPalString = str\\n                }\\n            }\\n        }\\n    }\\n\\n    return longestPalString;\\n};\\n\\nfunction isPalindrome(str){\\n    let left = 0\\n    let right = str.length - 1\\n\\n    while (left < right) {\\n        if (str[left++] !== str[right--]) {\\n            return false\\n        }\\n    }\\n\\n    return true\\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "AasheeshLikePanner",
                        "content": "Hi, I am getting memory limit exceeds in my code. Can you please help to fix. I know my code taking too much memory, but how I fix this.\\nCan we able to modify it so it doesn\\'t give memory limit exceeds or we are not able to modify it.\\nThanks for any suggestion.\\n\\n  class Solution {\\n    `List<String> outer = new ArrayList<>();\\n    public String longestPalindrome(String s) {\\n        String result = \"\";\\n        helper(s , 0, s.length()- 1, \"\");\\n        for (String man:outer) {\\n            int l = man.length();\\n            if (result.length()<l){\\n                result = man;\\n            }\\n        }\\n        return result;\\n    }\\n    public void helper(String s, int start, int end, String result){\\n        int mid = result.length()/2;\\n        if(start> end){\\n            outer.add(result);\\n            return;\\n        }\\n        if(start == end){\\n            char ch = s.charAt(end);\\n            String left = result.substring(0, mid);\\n            String right = result.substring(mid);\\n            result = left + ch + right;\\n            outer.add(result);\\n            helper(s, start + 1, s.length() -1, \"\");\\n             return;\\n        }\\n        char ch1 = s.charAt(start);\\n        char ch2 = s.charAt(end);\\n        if(ch1 == ch2){\\n\\n            String left = result.substring(0, mid);\\n            String right = result.substring(mid);\\n            result = left + ch1 + ch2 + right;\\n            helper(s, start + 1, end - 1, result);\\n        }\\n        result = \"\";\\n        helper(s, start, end - 1, result);\\n    }\\n}`"
                    },
                    {
                        "username": "hiranmay1000",
                        "content": "Why this is coming? help!!\n\nYour input\n\"aacabdkacaa\"\nOutput\n\"aacabacaa\"\nExpected\n\"aca\""
                    },
                    {
                        "username": "hiranmay1000",
                        "content": "Why this is happening please help !! \\nI have used map for finding the longest palindromic substring\\n\\nYour input : \"aacabdkacaa\"\\nOutput : \"aacabacaa\"\\nExpected : \"aca\""
                    },
                    {
                        "username": "shubha_neema",
                        "content": "Getting wrong answer, even for correct answer. Can anyone tell me why this is happening?\\nInput\\ns =\"babad\"\\nOutput\\n\"aba\"\\nExpected\\n\"bab\""
                    },
                    {
                        "username": "vismay__yerunkar",
                        "content": "Subscribe Hustlers Algorithm\\uD83D\\uDCA6\\uD83D\\uDCA6\\uD83D\\uDCA6\\uD83D\\uDD25\\uD83D\\uDD25 `https://youtu.be/94RdOzbXvHM`  Lets make a stronger problem solving community. subscribe to the channel for amazing dsa content."
                    },
                    {
                        "username": "prasannaprassu80",
                        "content": "What is wrong in my code? 127/141 test cases are passed. if i check the failed test case, by copy and paste them in the test case, that test case is getting passed,. then why it is showing test cases failed?\n\n\ndef longestPalindrome(self, s: str) -> str:\n        length_list= []\n        max_len=0\n        result=\"\"\n        for i in range(len(s)):\n            for j in range(i+1, len(s)+1):\n                substring= s[i:j]\n                rev_substring= substring[::-1]\n                if (substring== rev_substring):\n                    length_list.append(substring)\n        for each in length_list:\n            if len(each)> max_len:\n                max_len= len(each)\n                result= each\n        return (result)\n[leetcode](https://leetcode.com) "
                    },
                    {
                        "username": "Yongbi",
                        "content": "[@prasannaprassu80](/prasannaprassu80)\nTime Limit Exceeded!!!\n\nIt not a error of your code, it's time complexity."
                    },
                    {
                        "username": "zohairhadi",
                        "content": "I thought that I\\'d come up with a good solution but there\\'s a lot of edge cases that my solution doesn\\'t cater to. \\nAny suggestions on what I\\'m missing?\\n\\n`\\n        def longestPalindrome(self, s):\\n\\n\\n        longest = \"\"\\n        temp_longest = \"\"\\n        for i in range(1, len(s)-2):\\n\\n            if s[i-1] == s[i+1]:\\n                count = 2\\n                while (s[i-count] == s[i+count]):\\n                    count += 1\\n                count -= 1\\n                temp_longest = s[i-count: i+count + 1]\\n\\n            elif s[i] == s[i+1]:\\n                count = 1\\n                while (s[i-count] == s[i+1+count]):\\n                    count += 1\\n                count -= 1\\n                temp_longest = s[i-count: i+1+count + 1]\\n\\n            if len(temp_longest) > len(longest):\\n                longest = temp_longest\\n\\n        return longest            \\n`"
                    },
                    {
                        "username": "Yongbi",
                        "content": "[@zohairhadi2000](/zohairhadi2000) This code will get in trouble even for simple testcase:\ns= \"bbbbbbbb\"\nWhy?\n\nBecause you didnt define a boundary condition for string that you check on:\n```\nif s[i-1] == s[i+1]:\n            count = 2\n            while (s[i-count] == s[i+count]):\n                count += 1\n            count -= 1\n            temp_longest = s[i-count: i+count + 1]\n```\nWhat if? s[i-count], i-count<0?, i+count>len(s)-1. It returns a \n_IndexError: string index out of range_ right\n\nSo first, check your condition, then run dry test (change some simple case by yourself). \n\nYou can use a slide windows to check, and only check to len(s)-l-1, l=max last found palindromic substring.\n\n```\nclass Solution:\n    def longestPalindrome(self, s: str) -> str:\n        n, l, i, temp, s1 = [len(s), 1, 0, 0, s[::-1]] \n        if s1==s: return s \n        while i+l <= n-1:\n            for j in range(l,n-i+1):\n                if s1[i:i+j] ==s[n-j-i:n-i]: l=j; temp=i\n                if s1[i:i+j] not in s: break\n            if i<=n-l-1:    i+=1; continue \n            else: break \n        if temp==0 and l==1: return s[0]\n        return s[n-l-temp:n-temp]  \n```"
                    }
                ]
            },
            {
                "id": 1777802,
                "content": [
                    {
                        "username": "kasomaibrahim",
                        "content": "A faster solution with time complexity of O(n) is the Manacher algorithm. It utilizes the idea that if a palindrome has its center at the current position and its right boundary has reached position j, then the palindrome with its center at the current position will have the same length as the palindrome with its center at the symmetrical position of j with respect to the current position, as long as j is within the boundary of the palindrome with center at the current position."
                    },
                    {
                        "username": "Satyarth_Agrahari",
                        "content": "The C++ code provided implements Manacher\\'s algorithm to find the longest palindromic substring in a given input string.\\n\\nThe code starts by defining a function named \"longestPalindrome\" which takes a string as its input and returns a string as its output.\\n\\nThe first step in the function is to preprocess the input string by inserting special characters between each character and also at the beginning and end of the string. This is done by creating a new string \"temp\" and iterating through each character in the input string, adding it to \"temp\" and also adding the special character \"#\" after it. This modified string is then stored in \"s\".\\n\\nNext, the code defines two arrays \"p\" and \"id\" of size n+1, where n is the length of the modified string. The array \"p\" is used to hold the length of the palindrome centered at each character in the modified string and the array \"id\" is used to keep track of the center and right boundary of the current palindrome.\\n\\nThe code then initializes two variables \"mx\" and \"id\" to 0 and assigns the value 0 to all elements of the \"p\" array.\\n\\nThe algorithm then starts iterating through each character in the modified string using a for loop, for each i in s.\\n\\nThe first thing the code does inside the for loop is to check if the current character is within the right boundary of the previous palindrome. If so, it uses the \"mirroring\" technique to calculate the length of the palindrome centered at the current character. It sets the value of \"p[i]\" to the minimum of \"p[(id*2-i)\" and \"mx-i\".\\n\\nOtherwise, the code falls back to the \"expanding around the center\" technique and starts checking the characters on both sides of the current character to find the length of the palindrome centered at the current character.\\n\\nThe code then updates the \"mx\" and \"id\" variables if the current palindrome exceeds the right boundary of the previous palindrome.\\n\\nFinally, the code finds the center and length of the longest palindrome by iterating through the \"p\" array and returning the substring of the original input string using the center and length information.\\n\\nIt\\'s important to note that the above code is just an example and this specific implementation may be different from other ones, but the overall idea and algorithm remains the same."
                    },
                    {
                        "username": "paragtharani24",
                        "content": "can anyone please optimize  below code:\\n\\n/**\\n * @param {string} s\\n * @return {string}\\n */\\nvar longestPalindrome = function(s) {\\n    let longestPalString = \"\"\\n    for(var i=0; i<s.length; i++){\\n        let str = \"\"\\n        for(var j=i; j<s.length; j++){\\n            str = str + s[j]\\n            if(isPalindrome(str)){\\n                if(str.length > longestPalString.length){\\n                    longestPalString = str\\n                }\\n            }\\n        }\\n    }\\n\\n    return longestPalString;\\n};\\n\\nfunction isPalindrome(str){\\n    let left = 0\\n    let right = str.length - 1\\n\\n    while (left < right) {\\n        if (str[left++] !== str[right--]) {\\n            return false\\n        }\\n    }\\n\\n    return true\\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "AasheeshLikePanner",
                        "content": "Hi, I am getting memory limit exceeds in my code. Can you please help to fix. I know my code taking too much memory, but how I fix this.\\nCan we able to modify it so it doesn\\'t give memory limit exceeds or we are not able to modify it.\\nThanks for any suggestion.\\n\\n  class Solution {\\n    `List<String> outer = new ArrayList<>();\\n    public String longestPalindrome(String s) {\\n        String result = \"\";\\n        helper(s , 0, s.length()- 1, \"\");\\n        for (String man:outer) {\\n            int l = man.length();\\n            if (result.length()<l){\\n                result = man;\\n            }\\n        }\\n        return result;\\n    }\\n    public void helper(String s, int start, int end, String result){\\n        int mid = result.length()/2;\\n        if(start> end){\\n            outer.add(result);\\n            return;\\n        }\\n        if(start == end){\\n            char ch = s.charAt(end);\\n            String left = result.substring(0, mid);\\n            String right = result.substring(mid);\\n            result = left + ch + right;\\n            outer.add(result);\\n            helper(s, start + 1, s.length() -1, \"\");\\n             return;\\n        }\\n        char ch1 = s.charAt(start);\\n        char ch2 = s.charAt(end);\\n        if(ch1 == ch2){\\n\\n            String left = result.substring(0, mid);\\n            String right = result.substring(mid);\\n            result = left + ch1 + ch2 + right;\\n            helper(s, start + 1, end - 1, result);\\n        }\\n        result = \"\";\\n        helper(s, start, end - 1, result);\\n    }\\n}`"
                    },
                    {
                        "username": "hiranmay1000",
                        "content": "Why this is coming? help!!\n\nYour input\n\"aacabdkacaa\"\nOutput\n\"aacabacaa\"\nExpected\n\"aca\""
                    },
                    {
                        "username": "hiranmay1000",
                        "content": "Why this is happening please help !! \\nI have used map for finding the longest palindromic substring\\n\\nYour input : \"aacabdkacaa\"\\nOutput : \"aacabacaa\"\\nExpected : \"aca\""
                    },
                    {
                        "username": "shubha_neema",
                        "content": "Getting wrong answer, even for correct answer. Can anyone tell me why this is happening?\\nInput\\ns =\"babad\"\\nOutput\\n\"aba\"\\nExpected\\n\"bab\""
                    },
                    {
                        "username": "vismay__yerunkar",
                        "content": "Subscribe Hustlers Algorithm\\uD83D\\uDCA6\\uD83D\\uDCA6\\uD83D\\uDCA6\\uD83D\\uDD25\\uD83D\\uDD25 `https://youtu.be/94RdOzbXvHM`  Lets make a stronger problem solving community. subscribe to the channel for amazing dsa content."
                    },
                    {
                        "username": "prasannaprassu80",
                        "content": "What is wrong in my code? 127/141 test cases are passed. if i check the failed test case, by copy and paste them in the test case, that test case is getting passed,. then why it is showing test cases failed?\n\n\ndef longestPalindrome(self, s: str) -> str:\n        length_list= []\n        max_len=0\n        result=\"\"\n        for i in range(len(s)):\n            for j in range(i+1, len(s)+1):\n                substring= s[i:j]\n                rev_substring= substring[::-1]\n                if (substring== rev_substring):\n                    length_list.append(substring)\n        for each in length_list:\n            if len(each)> max_len:\n                max_len= len(each)\n                result= each\n        return (result)\n[leetcode](https://leetcode.com) "
                    },
                    {
                        "username": "Yongbi",
                        "content": "[@prasannaprassu80](/prasannaprassu80)\nTime Limit Exceeded!!!\n\nIt not a error of your code, it's time complexity."
                    },
                    {
                        "username": "zohairhadi",
                        "content": "I thought that I\\'d come up with a good solution but there\\'s a lot of edge cases that my solution doesn\\'t cater to. \\nAny suggestions on what I\\'m missing?\\n\\n`\\n        def longestPalindrome(self, s):\\n\\n\\n        longest = \"\"\\n        temp_longest = \"\"\\n        for i in range(1, len(s)-2):\\n\\n            if s[i-1] == s[i+1]:\\n                count = 2\\n                while (s[i-count] == s[i+count]):\\n                    count += 1\\n                count -= 1\\n                temp_longest = s[i-count: i+count + 1]\\n\\n            elif s[i] == s[i+1]:\\n                count = 1\\n                while (s[i-count] == s[i+1+count]):\\n                    count += 1\\n                count -= 1\\n                temp_longest = s[i-count: i+1+count + 1]\\n\\n            if len(temp_longest) > len(longest):\\n                longest = temp_longest\\n\\n        return longest            \\n`"
                    },
                    {
                        "username": "Yongbi",
                        "content": "[@zohairhadi2000](/zohairhadi2000) This code will get in trouble even for simple testcase:\ns= \"bbbbbbbb\"\nWhy?\n\nBecause you didnt define a boundary condition for string that you check on:\n```\nif s[i-1] == s[i+1]:\n            count = 2\n            while (s[i-count] == s[i+count]):\n                count += 1\n            count -= 1\n            temp_longest = s[i-count: i+count + 1]\n```\nWhat if? s[i-count], i-count<0?, i+count>len(s)-1. It returns a \n_IndexError: string index out of range_ right\n\nSo first, check your condition, then run dry test (change some simple case by yourself). \n\nYou can use a slide windows to check, and only check to len(s)-l-1, l=max last found palindromic substring.\n\n```\nclass Solution:\n    def longestPalindrome(self, s: str) -> str:\n        n, l, i, temp, s1 = [len(s), 1, 0, 0, s[::-1]] \n        if s1==s: return s \n        while i+l <= n-1:\n            for j in range(l,n-i+1):\n                if s1[i:i+j] ==s[n-j-i:n-i]: l=j; temp=i\n                if s1[i:i+j] not in s: break\n            if i<=n-l-1:    i+=1; continue \n            else: break \n        if temp==0 and l==1: return s[0]\n        return s[n-l-temp:n-temp]  \n```"
                    }
                ]
            },
            {
                "id": 1777520,
                "content": [
                    {
                        "username": "kasomaibrahim",
                        "content": "A faster solution with time complexity of O(n) is the Manacher algorithm. It utilizes the idea that if a palindrome has its center at the current position and its right boundary has reached position j, then the palindrome with its center at the current position will have the same length as the palindrome with its center at the symmetrical position of j with respect to the current position, as long as j is within the boundary of the palindrome with center at the current position."
                    },
                    {
                        "username": "Satyarth_Agrahari",
                        "content": "The C++ code provided implements Manacher\\'s algorithm to find the longest palindromic substring in a given input string.\\n\\nThe code starts by defining a function named \"longestPalindrome\" which takes a string as its input and returns a string as its output.\\n\\nThe first step in the function is to preprocess the input string by inserting special characters between each character and also at the beginning and end of the string. This is done by creating a new string \"temp\" and iterating through each character in the input string, adding it to \"temp\" and also adding the special character \"#\" after it. This modified string is then stored in \"s\".\\n\\nNext, the code defines two arrays \"p\" and \"id\" of size n+1, where n is the length of the modified string. The array \"p\" is used to hold the length of the palindrome centered at each character in the modified string and the array \"id\" is used to keep track of the center and right boundary of the current palindrome.\\n\\nThe code then initializes two variables \"mx\" and \"id\" to 0 and assigns the value 0 to all elements of the \"p\" array.\\n\\nThe algorithm then starts iterating through each character in the modified string using a for loop, for each i in s.\\n\\nThe first thing the code does inside the for loop is to check if the current character is within the right boundary of the previous palindrome. If so, it uses the \"mirroring\" technique to calculate the length of the palindrome centered at the current character. It sets the value of \"p[i]\" to the minimum of \"p[(id*2-i)\" and \"mx-i\".\\n\\nOtherwise, the code falls back to the \"expanding around the center\" technique and starts checking the characters on both sides of the current character to find the length of the palindrome centered at the current character.\\n\\nThe code then updates the \"mx\" and \"id\" variables if the current palindrome exceeds the right boundary of the previous palindrome.\\n\\nFinally, the code finds the center and length of the longest palindrome by iterating through the \"p\" array and returning the substring of the original input string using the center and length information.\\n\\nIt\\'s important to note that the above code is just an example and this specific implementation may be different from other ones, but the overall idea and algorithm remains the same."
                    },
                    {
                        "username": "paragtharani24",
                        "content": "can anyone please optimize  below code:\\n\\n/**\\n * @param {string} s\\n * @return {string}\\n */\\nvar longestPalindrome = function(s) {\\n    let longestPalString = \"\"\\n    for(var i=0; i<s.length; i++){\\n        let str = \"\"\\n        for(var j=i; j<s.length; j++){\\n            str = str + s[j]\\n            if(isPalindrome(str)){\\n                if(str.length > longestPalString.length){\\n                    longestPalString = str\\n                }\\n            }\\n        }\\n    }\\n\\n    return longestPalString;\\n};\\n\\nfunction isPalindrome(str){\\n    let left = 0\\n    let right = str.length - 1\\n\\n    while (left < right) {\\n        if (str[left++] !== str[right--]) {\\n            return false\\n        }\\n    }\\n\\n    return true\\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "AasheeshLikePanner",
                        "content": "Hi, I am getting memory limit exceeds in my code. Can you please help to fix. I know my code taking too much memory, but how I fix this.\\nCan we able to modify it so it doesn\\'t give memory limit exceeds or we are not able to modify it.\\nThanks for any suggestion.\\n\\n  class Solution {\\n    `List<String> outer = new ArrayList<>();\\n    public String longestPalindrome(String s) {\\n        String result = \"\";\\n        helper(s , 0, s.length()- 1, \"\");\\n        for (String man:outer) {\\n            int l = man.length();\\n            if (result.length()<l){\\n                result = man;\\n            }\\n        }\\n        return result;\\n    }\\n    public void helper(String s, int start, int end, String result){\\n        int mid = result.length()/2;\\n        if(start> end){\\n            outer.add(result);\\n            return;\\n        }\\n        if(start == end){\\n            char ch = s.charAt(end);\\n            String left = result.substring(0, mid);\\n            String right = result.substring(mid);\\n            result = left + ch + right;\\n            outer.add(result);\\n            helper(s, start + 1, s.length() -1, \"\");\\n             return;\\n        }\\n        char ch1 = s.charAt(start);\\n        char ch2 = s.charAt(end);\\n        if(ch1 == ch2){\\n\\n            String left = result.substring(0, mid);\\n            String right = result.substring(mid);\\n            result = left + ch1 + ch2 + right;\\n            helper(s, start + 1, end - 1, result);\\n        }\\n        result = \"\";\\n        helper(s, start, end - 1, result);\\n    }\\n}`"
                    },
                    {
                        "username": "hiranmay1000",
                        "content": "Why this is coming? help!!\n\nYour input\n\"aacabdkacaa\"\nOutput\n\"aacabacaa\"\nExpected\n\"aca\""
                    },
                    {
                        "username": "hiranmay1000",
                        "content": "Why this is happening please help !! \\nI have used map for finding the longest palindromic substring\\n\\nYour input : \"aacabdkacaa\"\\nOutput : \"aacabacaa\"\\nExpected : \"aca\""
                    },
                    {
                        "username": "shubha_neema",
                        "content": "Getting wrong answer, even for correct answer. Can anyone tell me why this is happening?\\nInput\\ns =\"babad\"\\nOutput\\n\"aba\"\\nExpected\\n\"bab\""
                    },
                    {
                        "username": "vismay__yerunkar",
                        "content": "Subscribe Hustlers Algorithm\\uD83D\\uDCA6\\uD83D\\uDCA6\\uD83D\\uDCA6\\uD83D\\uDD25\\uD83D\\uDD25 `https://youtu.be/94RdOzbXvHM`  Lets make a stronger problem solving community. subscribe to the channel for amazing dsa content."
                    },
                    {
                        "username": "prasannaprassu80",
                        "content": "What is wrong in my code? 127/141 test cases are passed. if i check the failed test case, by copy and paste them in the test case, that test case is getting passed,. then why it is showing test cases failed?\n\n\ndef longestPalindrome(self, s: str) -> str:\n        length_list= []\n        max_len=0\n        result=\"\"\n        for i in range(len(s)):\n            for j in range(i+1, len(s)+1):\n                substring= s[i:j]\n                rev_substring= substring[::-1]\n                if (substring== rev_substring):\n                    length_list.append(substring)\n        for each in length_list:\n            if len(each)> max_len:\n                max_len= len(each)\n                result= each\n        return (result)\n[leetcode](https://leetcode.com) "
                    },
                    {
                        "username": "Yongbi",
                        "content": "[@prasannaprassu80](/prasannaprassu80)\nTime Limit Exceeded!!!\n\nIt not a error of your code, it's time complexity."
                    },
                    {
                        "username": "zohairhadi",
                        "content": "I thought that I\\'d come up with a good solution but there\\'s a lot of edge cases that my solution doesn\\'t cater to. \\nAny suggestions on what I\\'m missing?\\n\\n`\\n        def longestPalindrome(self, s):\\n\\n\\n        longest = \"\"\\n        temp_longest = \"\"\\n        for i in range(1, len(s)-2):\\n\\n            if s[i-1] == s[i+1]:\\n                count = 2\\n                while (s[i-count] == s[i+count]):\\n                    count += 1\\n                count -= 1\\n                temp_longest = s[i-count: i+count + 1]\\n\\n            elif s[i] == s[i+1]:\\n                count = 1\\n                while (s[i-count] == s[i+1+count]):\\n                    count += 1\\n                count -= 1\\n                temp_longest = s[i-count: i+1+count + 1]\\n\\n            if len(temp_longest) > len(longest):\\n                longest = temp_longest\\n\\n        return longest            \\n`"
                    },
                    {
                        "username": "Yongbi",
                        "content": "[@zohairhadi2000](/zohairhadi2000) This code will get in trouble even for simple testcase:\ns= \"bbbbbbbb\"\nWhy?\n\nBecause you didnt define a boundary condition for string that you check on:\n```\nif s[i-1] == s[i+1]:\n            count = 2\n            while (s[i-count] == s[i+count]):\n                count += 1\n            count -= 1\n            temp_longest = s[i-count: i+count + 1]\n```\nWhat if? s[i-count], i-count<0?, i+count>len(s)-1. It returns a \n_IndexError: string index out of range_ right\n\nSo first, check your condition, then run dry test (change some simple case by yourself). \n\nYou can use a slide windows to check, and only check to len(s)-l-1, l=max last found palindromic substring.\n\n```\nclass Solution:\n    def longestPalindrome(self, s: str) -> str:\n        n, l, i, temp, s1 = [len(s), 1, 0, 0, s[::-1]] \n        if s1==s: return s \n        while i+l <= n-1:\n            for j in range(l,n-i+1):\n                if s1[i:i+j] ==s[n-j-i:n-i]: l=j; temp=i\n                if s1[i:i+j] not in s: break\n            if i<=n-l-1:    i+=1; continue \n            else: break \n        if temp==0 and l==1: return s[0]\n        return s[n-l-temp:n-temp]  \n```"
                    }
                ]
            },
            {
                "id": 1776677,
                "content": [
                    {
                        "username": "kasomaibrahim",
                        "content": "A faster solution with time complexity of O(n) is the Manacher algorithm. It utilizes the idea that if a palindrome has its center at the current position and its right boundary has reached position j, then the palindrome with its center at the current position will have the same length as the palindrome with its center at the symmetrical position of j with respect to the current position, as long as j is within the boundary of the palindrome with center at the current position."
                    },
                    {
                        "username": "Satyarth_Agrahari",
                        "content": "The C++ code provided implements Manacher\\'s algorithm to find the longest palindromic substring in a given input string.\\n\\nThe code starts by defining a function named \"longestPalindrome\" which takes a string as its input and returns a string as its output.\\n\\nThe first step in the function is to preprocess the input string by inserting special characters between each character and also at the beginning and end of the string. This is done by creating a new string \"temp\" and iterating through each character in the input string, adding it to \"temp\" and also adding the special character \"#\" after it. This modified string is then stored in \"s\".\\n\\nNext, the code defines two arrays \"p\" and \"id\" of size n+1, where n is the length of the modified string. The array \"p\" is used to hold the length of the palindrome centered at each character in the modified string and the array \"id\" is used to keep track of the center and right boundary of the current palindrome.\\n\\nThe code then initializes two variables \"mx\" and \"id\" to 0 and assigns the value 0 to all elements of the \"p\" array.\\n\\nThe algorithm then starts iterating through each character in the modified string using a for loop, for each i in s.\\n\\nThe first thing the code does inside the for loop is to check if the current character is within the right boundary of the previous palindrome. If so, it uses the \"mirroring\" technique to calculate the length of the palindrome centered at the current character. It sets the value of \"p[i]\" to the minimum of \"p[(id*2-i)\" and \"mx-i\".\\n\\nOtherwise, the code falls back to the \"expanding around the center\" technique and starts checking the characters on both sides of the current character to find the length of the palindrome centered at the current character.\\n\\nThe code then updates the \"mx\" and \"id\" variables if the current palindrome exceeds the right boundary of the previous palindrome.\\n\\nFinally, the code finds the center and length of the longest palindrome by iterating through the \"p\" array and returning the substring of the original input string using the center and length information.\\n\\nIt\\'s important to note that the above code is just an example and this specific implementation may be different from other ones, but the overall idea and algorithm remains the same."
                    },
                    {
                        "username": "paragtharani24",
                        "content": "can anyone please optimize  below code:\\n\\n/**\\n * @param {string} s\\n * @return {string}\\n */\\nvar longestPalindrome = function(s) {\\n    let longestPalString = \"\"\\n    for(var i=0; i<s.length; i++){\\n        let str = \"\"\\n        for(var j=i; j<s.length; j++){\\n            str = str + s[j]\\n            if(isPalindrome(str)){\\n                if(str.length > longestPalString.length){\\n                    longestPalString = str\\n                }\\n            }\\n        }\\n    }\\n\\n    return longestPalString;\\n};\\n\\nfunction isPalindrome(str){\\n    let left = 0\\n    let right = str.length - 1\\n\\n    while (left < right) {\\n        if (str[left++] !== str[right--]) {\\n            return false\\n        }\\n    }\\n\\n    return true\\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "AasheeshLikePanner",
                        "content": "Hi, I am getting memory limit exceeds in my code. Can you please help to fix. I know my code taking too much memory, but how I fix this.\\nCan we able to modify it so it doesn\\'t give memory limit exceeds or we are not able to modify it.\\nThanks for any suggestion.\\n\\n  class Solution {\\n    `List<String> outer = new ArrayList<>();\\n    public String longestPalindrome(String s) {\\n        String result = \"\";\\n        helper(s , 0, s.length()- 1, \"\");\\n        for (String man:outer) {\\n            int l = man.length();\\n            if (result.length()<l){\\n                result = man;\\n            }\\n        }\\n        return result;\\n    }\\n    public void helper(String s, int start, int end, String result){\\n        int mid = result.length()/2;\\n        if(start> end){\\n            outer.add(result);\\n            return;\\n        }\\n        if(start == end){\\n            char ch = s.charAt(end);\\n            String left = result.substring(0, mid);\\n            String right = result.substring(mid);\\n            result = left + ch + right;\\n            outer.add(result);\\n            helper(s, start + 1, s.length() -1, \"\");\\n             return;\\n        }\\n        char ch1 = s.charAt(start);\\n        char ch2 = s.charAt(end);\\n        if(ch1 == ch2){\\n\\n            String left = result.substring(0, mid);\\n            String right = result.substring(mid);\\n            result = left + ch1 + ch2 + right;\\n            helper(s, start + 1, end - 1, result);\\n        }\\n        result = \"\";\\n        helper(s, start, end - 1, result);\\n    }\\n}`"
                    },
                    {
                        "username": "hiranmay1000",
                        "content": "Why this is coming? help!!\n\nYour input\n\"aacabdkacaa\"\nOutput\n\"aacabacaa\"\nExpected\n\"aca\""
                    },
                    {
                        "username": "hiranmay1000",
                        "content": "Why this is happening please help !! \\nI have used map for finding the longest palindromic substring\\n\\nYour input : \"aacabdkacaa\"\\nOutput : \"aacabacaa\"\\nExpected : \"aca\""
                    },
                    {
                        "username": "shubha_neema",
                        "content": "Getting wrong answer, even for correct answer. Can anyone tell me why this is happening?\\nInput\\ns =\"babad\"\\nOutput\\n\"aba\"\\nExpected\\n\"bab\""
                    },
                    {
                        "username": "vismay__yerunkar",
                        "content": "Subscribe Hustlers Algorithm\\uD83D\\uDCA6\\uD83D\\uDCA6\\uD83D\\uDCA6\\uD83D\\uDD25\\uD83D\\uDD25 `https://youtu.be/94RdOzbXvHM`  Lets make a stronger problem solving community. subscribe to the channel for amazing dsa content."
                    },
                    {
                        "username": "prasannaprassu80",
                        "content": "What is wrong in my code? 127/141 test cases are passed. if i check the failed test case, by copy and paste them in the test case, that test case is getting passed,. then why it is showing test cases failed?\n\n\ndef longestPalindrome(self, s: str) -> str:\n        length_list= []\n        max_len=0\n        result=\"\"\n        for i in range(len(s)):\n            for j in range(i+1, len(s)+1):\n                substring= s[i:j]\n                rev_substring= substring[::-1]\n                if (substring== rev_substring):\n                    length_list.append(substring)\n        for each in length_list:\n            if len(each)> max_len:\n                max_len= len(each)\n                result= each\n        return (result)\n[leetcode](https://leetcode.com) "
                    },
                    {
                        "username": "Yongbi",
                        "content": "[@prasannaprassu80](/prasannaprassu80)\nTime Limit Exceeded!!!\n\nIt not a error of your code, it's time complexity."
                    },
                    {
                        "username": "zohairhadi",
                        "content": "I thought that I\\'d come up with a good solution but there\\'s a lot of edge cases that my solution doesn\\'t cater to. \\nAny suggestions on what I\\'m missing?\\n\\n`\\n        def longestPalindrome(self, s):\\n\\n\\n        longest = \"\"\\n        temp_longest = \"\"\\n        for i in range(1, len(s)-2):\\n\\n            if s[i-1] == s[i+1]:\\n                count = 2\\n                while (s[i-count] == s[i+count]):\\n                    count += 1\\n                count -= 1\\n                temp_longest = s[i-count: i+count + 1]\\n\\n            elif s[i] == s[i+1]:\\n                count = 1\\n                while (s[i-count] == s[i+1+count]):\\n                    count += 1\\n                count -= 1\\n                temp_longest = s[i-count: i+1+count + 1]\\n\\n            if len(temp_longest) > len(longest):\\n                longest = temp_longest\\n\\n        return longest            \\n`"
                    },
                    {
                        "username": "Yongbi",
                        "content": "[@zohairhadi2000](/zohairhadi2000) This code will get in trouble even for simple testcase:\ns= \"bbbbbbbb\"\nWhy?\n\nBecause you didnt define a boundary condition for string that you check on:\n```\nif s[i-1] == s[i+1]:\n            count = 2\n            while (s[i-count] == s[i+count]):\n                count += 1\n            count -= 1\n            temp_longest = s[i-count: i+count + 1]\n```\nWhat if? s[i-count], i-count<0?, i+count>len(s)-1. It returns a \n_IndexError: string index out of range_ right\n\nSo first, check your condition, then run dry test (change some simple case by yourself). \n\nYou can use a slide windows to check, and only check to len(s)-l-1, l=max last found palindromic substring.\n\n```\nclass Solution:\n    def longestPalindrome(self, s: str) -> str:\n        n, l, i, temp, s1 = [len(s), 1, 0, 0, s[::-1]] \n        if s1==s: return s \n        while i+l <= n-1:\n            for j in range(l,n-i+1):\n                if s1[i:i+j] ==s[n-j-i:n-i]: l=j; temp=i\n                if s1[i:i+j] not in s: break\n            if i<=n-l-1:    i+=1; continue \n            else: break \n        if temp==0 and l==1: return s[0]\n        return s[n-l-temp:n-temp]  \n```"
                    }
                ]
            },
            {
                "id": 1775657,
                "content": [
                    {
                        "username": "kasomaibrahim",
                        "content": "A faster solution with time complexity of O(n) is the Manacher algorithm. It utilizes the idea that if a palindrome has its center at the current position and its right boundary has reached position j, then the palindrome with its center at the current position will have the same length as the palindrome with its center at the symmetrical position of j with respect to the current position, as long as j is within the boundary of the palindrome with center at the current position."
                    },
                    {
                        "username": "Satyarth_Agrahari",
                        "content": "The C++ code provided implements Manacher\\'s algorithm to find the longest palindromic substring in a given input string.\\n\\nThe code starts by defining a function named \"longestPalindrome\" which takes a string as its input and returns a string as its output.\\n\\nThe first step in the function is to preprocess the input string by inserting special characters between each character and also at the beginning and end of the string. This is done by creating a new string \"temp\" and iterating through each character in the input string, adding it to \"temp\" and also adding the special character \"#\" after it. This modified string is then stored in \"s\".\\n\\nNext, the code defines two arrays \"p\" and \"id\" of size n+1, where n is the length of the modified string. The array \"p\" is used to hold the length of the palindrome centered at each character in the modified string and the array \"id\" is used to keep track of the center and right boundary of the current palindrome.\\n\\nThe code then initializes two variables \"mx\" and \"id\" to 0 and assigns the value 0 to all elements of the \"p\" array.\\n\\nThe algorithm then starts iterating through each character in the modified string using a for loop, for each i in s.\\n\\nThe first thing the code does inside the for loop is to check if the current character is within the right boundary of the previous palindrome. If so, it uses the \"mirroring\" technique to calculate the length of the palindrome centered at the current character. It sets the value of \"p[i]\" to the minimum of \"p[(id*2-i)\" and \"mx-i\".\\n\\nOtherwise, the code falls back to the \"expanding around the center\" technique and starts checking the characters on both sides of the current character to find the length of the palindrome centered at the current character.\\n\\nThe code then updates the \"mx\" and \"id\" variables if the current palindrome exceeds the right boundary of the previous palindrome.\\n\\nFinally, the code finds the center and length of the longest palindrome by iterating through the \"p\" array and returning the substring of the original input string using the center and length information.\\n\\nIt\\'s important to note that the above code is just an example and this specific implementation may be different from other ones, but the overall idea and algorithm remains the same."
                    },
                    {
                        "username": "paragtharani24",
                        "content": "can anyone please optimize  below code:\\n\\n/**\\n * @param {string} s\\n * @return {string}\\n */\\nvar longestPalindrome = function(s) {\\n    let longestPalString = \"\"\\n    for(var i=0; i<s.length; i++){\\n        let str = \"\"\\n        for(var j=i; j<s.length; j++){\\n            str = str + s[j]\\n            if(isPalindrome(str)){\\n                if(str.length > longestPalString.length){\\n                    longestPalString = str\\n                }\\n            }\\n        }\\n    }\\n\\n    return longestPalString;\\n};\\n\\nfunction isPalindrome(str){\\n    let left = 0\\n    let right = str.length - 1\\n\\n    while (left < right) {\\n        if (str[left++] !== str[right--]) {\\n            return false\\n        }\\n    }\\n\\n    return true\\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "AasheeshLikePanner",
                        "content": "Hi, I am getting memory limit exceeds in my code. Can you please help to fix. I know my code taking too much memory, but how I fix this.\\nCan we able to modify it so it doesn\\'t give memory limit exceeds or we are not able to modify it.\\nThanks for any suggestion.\\n\\n  class Solution {\\n    `List<String> outer = new ArrayList<>();\\n    public String longestPalindrome(String s) {\\n        String result = \"\";\\n        helper(s , 0, s.length()- 1, \"\");\\n        for (String man:outer) {\\n            int l = man.length();\\n            if (result.length()<l){\\n                result = man;\\n            }\\n        }\\n        return result;\\n    }\\n    public void helper(String s, int start, int end, String result){\\n        int mid = result.length()/2;\\n        if(start> end){\\n            outer.add(result);\\n            return;\\n        }\\n        if(start == end){\\n            char ch = s.charAt(end);\\n            String left = result.substring(0, mid);\\n            String right = result.substring(mid);\\n            result = left + ch + right;\\n            outer.add(result);\\n            helper(s, start + 1, s.length() -1, \"\");\\n             return;\\n        }\\n        char ch1 = s.charAt(start);\\n        char ch2 = s.charAt(end);\\n        if(ch1 == ch2){\\n\\n            String left = result.substring(0, mid);\\n            String right = result.substring(mid);\\n            result = left + ch1 + ch2 + right;\\n            helper(s, start + 1, end - 1, result);\\n        }\\n        result = \"\";\\n        helper(s, start, end - 1, result);\\n    }\\n}`"
                    },
                    {
                        "username": "hiranmay1000",
                        "content": "Why this is coming? help!!\n\nYour input\n\"aacabdkacaa\"\nOutput\n\"aacabacaa\"\nExpected\n\"aca\""
                    },
                    {
                        "username": "hiranmay1000",
                        "content": "Why this is happening please help !! \\nI have used map for finding the longest palindromic substring\\n\\nYour input : \"aacabdkacaa\"\\nOutput : \"aacabacaa\"\\nExpected : \"aca\""
                    },
                    {
                        "username": "shubha_neema",
                        "content": "Getting wrong answer, even for correct answer. Can anyone tell me why this is happening?\\nInput\\ns =\"babad\"\\nOutput\\n\"aba\"\\nExpected\\n\"bab\""
                    },
                    {
                        "username": "vismay__yerunkar",
                        "content": "Subscribe Hustlers Algorithm\\uD83D\\uDCA6\\uD83D\\uDCA6\\uD83D\\uDCA6\\uD83D\\uDD25\\uD83D\\uDD25 `https://youtu.be/94RdOzbXvHM`  Lets make a stronger problem solving community. subscribe to the channel for amazing dsa content."
                    },
                    {
                        "username": "prasannaprassu80",
                        "content": "What is wrong in my code? 127/141 test cases are passed. if i check the failed test case, by copy and paste them in the test case, that test case is getting passed,. then why it is showing test cases failed?\n\n\ndef longestPalindrome(self, s: str) -> str:\n        length_list= []\n        max_len=0\n        result=\"\"\n        for i in range(len(s)):\n            for j in range(i+1, len(s)+1):\n                substring= s[i:j]\n                rev_substring= substring[::-1]\n                if (substring== rev_substring):\n                    length_list.append(substring)\n        for each in length_list:\n            if len(each)> max_len:\n                max_len= len(each)\n                result= each\n        return (result)\n[leetcode](https://leetcode.com) "
                    },
                    {
                        "username": "Yongbi",
                        "content": "[@prasannaprassu80](/prasannaprassu80)\nTime Limit Exceeded!!!\n\nIt not a error of your code, it's time complexity."
                    },
                    {
                        "username": "zohairhadi",
                        "content": "I thought that I\\'d come up with a good solution but there\\'s a lot of edge cases that my solution doesn\\'t cater to. \\nAny suggestions on what I\\'m missing?\\n\\n`\\n        def longestPalindrome(self, s):\\n\\n\\n        longest = \"\"\\n        temp_longest = \"\"\\n        for i in range(1, len(s)-2):\\n\\n            if s[i-1] == s[i+1]:\\n                count = 2\\n                while (s[i-count] == s[i+count]):\\n                    count += 1\\n                count -= 1\\n                temp_longest = s[i-count: i+count + 1]\\n\\n            elif s[i] == s[i+1]:\\n                count = 1\\n                while (s[i-count] == s[i+1+count]):\\n                    count += 1\\n                count -= 1\\n                temp_longest = s[i-count: i+1+count + 1]\\n\\n            if len(temp_longest) > len(longest):\\n                longest = temp_longest\\n\\n        return longest            \\n`"
                    },
                    {
                        "username": "Yongbi",
                        "content": "[@zohairhadi2000](/zohairhadi2000) This code will get in trouble even for simple testcase:\ns= \"bbbbbbbb\"\nWhy?\n\nBecause you didnt define a boundary condition for string that you check on:\n```\nif s[i-1] == s[i+1]:\n            count = 2\n            while (s[i-count] == s[i+count]):\n                count += 1\n            count -= 1\n            temp_longest = s[i-count: i+count + 1]\n```\nWhat if? s[i-count], i-count<0?, i+count>len(s)-1. It returns a \n_IndexError: string index out of range_ right\n\nSo first, check your condition, then run dry test (change some simple case by yourself). \n\nYou can use a slide windows to check, and only check to len(s)-l-1, l=max last found palindromic substring.\n\n```\nclass Solution:\n    def longestPalindrome(self, s: str) -> str:\n        n, l, i, temp, s1 = [len(s), 1, 0, 0, s[::-1]] \n        if s1==s: return s \n        while i+l <= n-1:\n            for j in range(l,n-i+1):\n                if s1[i:i+j] ==s[n-j-i:n-i]: l=j; temp=i\n                if s1[i:i+j] not in s: break\n            if i<=n-l-1:    i+=1; continue \n            else: break \n        if temp==0 and l==1: return s[0]\n        return s[n-l-temp:n-temp]  \n```"
                    }
                ]
            },
            {
                "id": 1775653,
                "content": [
                    {
                        "username": "kasomaibrahim",
                        "content": "A faster solution with time complexity of O(n) is the Manacher algorithm. It utilizes the idea that if a palindrome has its center at the current position and its right boundary has reached position j, then the palindrome with its center at the current position will have the same length as the palindrome with its center at the symmetrical position of j with respect to the current position, as long as j is within the boundary of the palindrome with center at the current position."
                    },
                    {
                        "username": "Satyarth_Agrahari",
                        "content": "The C++ code provided implements Manacher\\'s algorithm to find the longest palindromic substring in a given input string.\\n\\nThe code starts by defining a function named \"longestPalindrome\" which takes a string as its input and returns a string as its output.\\n\\nThe first step in the function is to preprocess the input string by inserting special characters between each character and also at the beginning and end of the string. This is done by creating a new string \"temp\" and iterating through each character in the input string, adding it to \"temp\" and also adding the special character \"#\" after it. This modified string is then stored in \"s\".\\n\\nNext, the code defines two arrays \"p\" and \"id\" of size n+1, where n is the length of the modified string. The array \"p\" is used to hold the length of the palindrome centered at each character in the modified string and the array \"id\" is used to keep track of the center and right boundary of the current palindrome.\\n\\nThe code then initializes two variables \"mx\" and \"id\" to 0 and assigns the value 0 to all elements of the \"p\" array.\\n\\nThe algorithm then starts iterating through each character in the modified string using a for loop, for each i in s.\\n\\nThe first thing the code does inside the for loop is to check if the current character is within the right boundary of the previous palindrome. If so, it uses the \"mirroring\" technique to calculate the length of the palindrome centered at the current character. It sets the value of \"p[i]\" to the minimum of \"p[(id*2-i)\" and \"mx-i\".\\n\\nOtherwise, the code falls back to the \"expanding around the center\" technique and starts checking the characters on both sides of the current character to find the length of the palindrome centered at the current character.\\n\\nThe code then updates the \"mx\" and \"id\" variables if the current palindrome exceeds the right boundary of the previous palindrome.\\n\\nFinally, the code finds the center and length of the longest palindrome by iterating through the \"p\" array and returning the substring of the original input string using the center and length information.\\n\\nIt\\'s important to note that the above code is just an example and this specific implementation may be different from other ones, but the overall idea and algorithm remains the same."
                    },
                    {
                        "username": "paragtharani24",
                        "content": "can anyone please optimize  below code:\\n\\n/**\\n * @param {string} s\\n * @return {string}\\n */\\nvar longestPalindrome = function(s) {\\n    let longestPalString = \"\"\\n    for(var i=0; i<s.length; i++){\\n        let str = \"\"\\n        for(var j=i; j<s.length; j++){\\n            str = str + s[j]\\n            if(isPalindrome(str)){\\n                if(str.length > longestPalString.length){\\n                    longestPalString = str\\n                }\\n            }\\n        }\\n    }\\n\\n    return longestPalString;\\n};\\n\\nfunction isPalindrome(str){\\n    let left = 0\\n    let right = str.length - 1\\n\\n    while (left < right) {\\n        if (str[left++] !== str[right--]) {\\n            return false\\n        }\\n    }\\n\\n    return true\\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "AasheeshLikePanner",
                        "content": "Hi, I am getting memory limit exceeds in my code. Can you please help to fix. I know my code taking too much memory, but how I fix this.\\nCan we able to modify it so it doesn\\'t give memory limit exceeds or we are not able to modify it.\\nThanks for any suggestion.\\n\\n  class Solution {\\n    `List<String> outer = new ArrayList<>();\\n    public String longestPalindrome(String s) {\\n        String result = \"\";\\n        helper(s , 0, s.length()- 1, \"\");\\n        for (String man:outer) {\\n            int l = man.length();\\n            if (result.length()<l){\\n                result = man;\\n            }\\n        }\\n        return result;\\n    }\\n    public void helper(String s, int start, int end, String result){\\n        int mid = result.length()/2;\\n        if(start> end){\\n            outer.add(result);\\n            return;\\n        }\\n        if(start == end){\\n            char ch = s.charAt(end);\\n            String left = result.substring(0, mid);\\n            String right = result.substring(mid);\\n            result = left + ch + right;\\n            outer.add(result);\\n            helper(s, start + 1, s.length() -1, \"\");\\n             return;\\n        }\\n        char ch1 = s.charAt(start);\\n        char ch2 = s.charAt(end);\\n        if(ch1 == ch2){\\n\\n            String left = result.substring(0, mid);\\n            String right = result.substring(mid);\\n            result = left + ch1 + ch2 + right;\\n            helper(s, start + 1, end - 1, result);\\n        }\\n        result = \"\";\\n        helper(s, start, end - 1, result);\\n    }\\n}`"
                    },
                    {
                        "username": "hiranmay1000",
                        "content": "Why this is coming? help!!\n\nYour input\n\"aacabdkacaa\"\nOutput\n\"aacabacaa\"\nExpected\n\"aca\""
                    },
                    {
                        "username": "hiranmay1000",
                        "content": "Why this is happening please help !! \\nI have used map for finding the longest palindromic substring\\n\\nYour input : \"aacabdkacaa\"\\nOutput : \"aacabacaa\"\\nExpected : \"aca\""
                    },
                    {
                        "username": "shubha_neema",
                        "content": "Getting wrong answer, even for correct answer. Can anyone tell me why this is happening?\\nInput\\ns =\"babad\"\\nOutput\\n\"aba\"\\nExpected\\n\"bab\""
                    },
                    {
                        "username": "vismay__yerunkar",
                        "content": "Subscribe Hustlers Algorithm\\uD83D\\uDCA6\\uD83D\\uDCA6\\uD83D\\uDCA6\\uD83D\\uDD25\\uD83D\\uDD25 `https://youtu.be/94RdOzbXvHM`  Lets make a stronger problem solving community. subscribe to the channel for amazing dsa content."
                    },
                    {
                        "username": "prasannaprassu80",
                        "content": "What is wrong in my code? 127/141 test cases are passed. if i check the failed test case, by copy and paste them in the test case, that test case is getting passed,. then why it is showing test cases failed?\n\n\ndef longestPalindrome(self, s: str) -> str:\n        length_list= []\n        max_len=0\n        result=\"\"\n        for i in range(len(s)):\n            for j in range(i+1, len(s)+1):\n                substring= s[i:j]\n                rev_substring= substring[::-1]\n                if (substring== rev_substring):\n                    length_list.append(substring)\n        for each in length_list:\n            if len(each)> max_len:\n                max_len= len(each)\n                result= each\n        return (result)\n[leetcode](https://leetcode.com) "
                    },
                    {
                        "username": "Yongbi",
                        "content": "[@prasannaprassu80](/prasannaprassu80)\nTime Limit Exceeded!!!\n\nIt not a error of your code, it's time complexity."
                    },
                    {
                        "username": "zohairhadi",
                        "content": "I thought that I\\'d come up with a good solution but there\\'s a lot of edge cases that my solution doesn\\'t cater to. \\nAny suggestions on what I\\'m missing?\\n\\n`\\n        def longestPalindrome(self, s):\\n\\n\\n        longest = \"\"\\n        temp_longest = \"\"\\n        for i in range(1, len(s)-2):\\n\\n            if s[i-1] == s[i+1]:\\n                count = 2\\n                while (s[i-count] == s[i+count]):\\n                    count += 1\\n                count -= 1\\n                temp_longest = s[i-count: i+count + 1]\\n\\n            elif s[i] == s[i+1]:\\n                count = 1\\n                while (s[i-count] == s[i+1+count]):\\n                    count += 1\\n                count -= 1\\n                temp_longest = s[i-count: i+1+count + 1]\\n\\n            if len(temp_longest) > len(longest):\\n                longest = temp_longest\\n\\n        return longest            \\n`"
                    },
                    {
                        "username": "Yongbi",
                        "content": "[@zohairhadi2000](/zohairhadi2000) This code will get in trouble even for simple testcase:\ns= \"bbbbbbbb\"\nWhy?\n\nBecause you didnt define a boundary condition for string that you check on:\n```\nif s[i-1] == s[i+1]:\n            count = 2\n            while (s[i-count] == s[i+count]):\n                count += 1\n            count -= 1\n            temp_longest = s[i-count: i+count + 1]\n```\nWhat if? s[i-count], i-count<0?, i+count>len(s)-1. It returns a \n_IndexError: string index out of range_ right\n\nSo first, check your condition, then run dry test (change some simple case by yourself). \n\nYou can use a slide windows to check, and only check to len(s)-l-1, l=max last found palindromic substring.\n\n```\nclass Solution:\n    def longestPalindrome(self, s: str) -> str:\n        n, l, i, temp, s1 = [len(s), 1, 0, 0, s[::-1]] \n        if s1==s: return s \n        while i+l <= n-1:\n            for j in range(l,n-i+1):\n                if s1[i:i+j] ==s[n-j-i:n-i]: l=j; temp=i\n                if s1[i:i+j] not in s: break\n            if i<=n-l-1:    i+=1; continue \n            else: break \n        if temp==0 and l==1: return s[0]\n        return s[n-l-temp:n-temp]  \n```"
                    }
                ]
            },
            {
                "id": 1771056,
                "content": [
                    {
                        "username": "kasomaibrahim",
                        "content": "A faster solution with time complexity of O(n) is the Manacher algorithm. It utilizes the idea that if a palindrome has its center at the current position and its right boundary has reached position j, then the palindrome with its center at the current position will have the same length as the palindrome with its center at the symmetrical position of j with respect to the current position, as long as j is within the boundary of the palindrome with center at the current position."
                    },
                    {
                        "username": "Satyarth_Agrahari",
                        "content": "The C++ code provided implements Manacher\\'s algorithm to find the longest palindromic substring in a given input string.\\n\\nThe code starts by defining a function named \"longestPalindrome\" which takes a string as its input and returns a string as its output.\\n\\nThe first step in the function is to preprocess the input string by inserting special characters between each character and also at the beginning and end of the string. This is done by creating a new string \"temp\" and iterating through each character in the input string, adding it to \"temp\" and also adding the special character \"#\" after it. This modified string is then stored in \"s\".\\n\\nNext, the code defines two arrays \"p\" and \"id\" of size n+1, where n is the length of the modified string. The array \"p\" is used to hold the length of the palindrome centered at each character in the modified string and the array \"id\" is used to keep track of the center and right boundary of the current palindrome.\\n\\nThe code then initializes two variables \"mx\" and \"id\" to 0 and assigns the value 0 to all elements of the \"p\" array.\\n\\nThe algorithm then starts iterating through each character in the modified string using a for loop, for each i in s.\\n\\nThe first thing the code does inside the for loop is to check if the current character is within the right boundary of the previous palindrome. If so, it uses the \"mirroring\" technique to calculate the length of the palindrome centered at the current character. It sets the value of \"p[i]\" to the minimum of \"p[(id*2-i)\" and \"mx-i\".\\n\\nOtherwise, the code falls back to the \"expanding around the center\" technique and starts checking the characters on both sides of the current character to find the length of the palindrome centered at the current character.\\n\\nThe code then updates the \"mx\" and \"id\" variables if the current palindrome exceeds the right boundary of the previous palindrome.\\n\\nFinally, the code finds the center and length of the longest palindrome by iterating through the \"p\" array and returning the substring of the original input string using the center and length information.\\n\\nIt\\'s important to note that the above code is just an example and this specific implementation may be different from other ones, but the overall idea and algorithm remains the same."
                    },
                    {
                        "username": "paragtharani24",
                        "content": "can anyone please optimize  below code:\\n\\n/**\\n * @param {string} s\\n * @return {string}\\n */\\nvar longestPalindrome = function(s) {\\n    let longestPalString = \"\"\\n    for(var i=0; i<s.length; i++){\\n        let str = \"\"\\n        for(var j=i; j<s.length; j++){\\n            str = str + s[j]\\n            if(isPalindrome(str)){\\n                if(str.length > longestPalString.length){\\n                    longestPalString = str\\n                }\\n            }\\n        }\\n    }\\n\\n    return longestPalString;\\n};\\n\\nfunction isPalindrome(str){\\n    let left = 0\\n    let right = str.length - 1\\n\\n    while (left < right) {\\n        if (str[left++] !== str[right--]) {\\n            return false\\n        }\\n    }\\n\\n    return true\\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "AasheeshLikePanner",
                        "content": "Hi, I am getting memory limit exceeds in my code. Can you please help to fix. I know my code taking too much memory, but how I fix this.\\nCan we able to modify it so it doesn\\'t give memory limit exceeds or we are not able to modify it.\\nThanks for any suggestion.\\n\\n  class Solution {\\n    `List<String> outer = new ArrayList<>();\\n    public String longestPalindrome(String s) {\\n        String result = \"\";\\n        helper(s , 0, s.length()- 1, \"\");\\n        for (String man:outer) {\\n            int l = man.length();\\n            if (result.length()<l){\\n                result = man;\\n            }\\n        }\\n        return result;\\n    }\\n    public void helper(String s, int start, int end, String result){\\n        int mid = result.length()/2;\\n        if(start> end){\\n            outer.add(result);\\n            return;\\n        }\\n        if(start == end){\\n            char ch = s.charAt(end);\\n            String left = result.substring(0, mid);\\n            String right = result.substring(mid);\\n            result = left + ch + right;\\n            outer.add(result);\\n            helper(s, start + 1, s.length() -1, \"\");\\n             return;\\n        }\\n        char ch1 = s.charAt(start);\\n        char ch2 = s.charAt(end);\\n        if(ch1 == ch2){\\n\\n            String left = result.substring(0, mid);\\n            String right = result.substring(mid);\\n            result = left + ch1 + ch2 + right;\\n            helper(s, start + 1, end - 1, result);\\n        }\\n        result = \"\";\\n        helper(s, start, end - 1, result);\\n    }\\n}`"
                    },
                    {
                        "username": "hiranmay1000",
                        "content": "Why this is coming? help!!\n\nYour input\n\"aacabdkacaa\"\nOutput\n\"aacabacaa\"\nExpected\n\"aca\""
                    },
                    {
                        "username": "hiranmay1000",
                        "content": "Why this is happening please help !! \\nI have used map for finding the longest palindromic substring\\n\\nYour input : \"aacabdkacaa\"\\nOutput : \"aacabacaa\"\\nExpected : \"aca\""
                    },
                    {
                        "username": "shubha_neema",
                        "content": "Getting wrong answer, even for correct answer. Can anyone tell me why this is happening?\\nInput\\ns =\"babad\"\\nOutput\\n\"aba\"\\nExpected\\n\"bab\""
                    },
                    {
                        "username": "vismay__yerunkar",
                        "content": "Subscribe Hustlers Algorithm\\uD83D\\uDCA6\\uD83D\\uDCA6\\uD83D\\uDCA6\\uD83D\\uDD25\\uD83D\\uDD25 `https://youtu.be/94RdOzbXvHM`  Lets make a stronger problem solving community. subscribe to the channel for amazing dsa content."
                    },
                    {
                        "username": "prasannaprassu80",
                        "content": "What is wrong in my code? 127/141 test cases are passed. if i check the failed test case, by copy and paste them in the test case, that test case is getting passed,. then why it is showing test cases failed?\n\n\ndef longestPalindrome(self, s: str) -> str:\n        length_list= []\n        max_len=0\n        result=\"\"\n        for i in range(len(s)):\n            for j in range(i+1, len(s)+1):\n                substring= s[i:j]\n                rev_substring= substring[::-1]\n                if (substring== rev_substring):\n                    length_list.append(substring)\n        for each in length_list:\n            if len(each)> max_len:\n                max_len= len(each)\n                result= each\n        return (result)\n[leetcode](https://leetcode.com) "
                    },
                    {
                        "username": "Yongbi",
                        "content": "[@prasannaprassu80](/prasannaprassu80)\nTime Limit Exceeded!!!\n\nIt not a error of your code, it's time complexity."
                    },
                    {
                        "username": "zohairhadi",
                        "content": "I thought that I\\'d come up with a good solution but there\\'s a lot of edge cases that my solution doesn\\'t cater to. \\nAny suggestions on what I\\'m missing?\\n\\n`\\n        def longestPalindrome(self, s):\\n\\n\\n        longest = \"\"\\n        temp_longest = \"\"\\n        for i in range(1, len(s)-2):\\n\\n            if s[i-1] == s[i+1]:\\n                count = 2\\n                while (s[i-count] == s[i+count]):\\n                    count += 1\\n                count -= 1\\n                temp_longest = s[i-count: i+count + 1]\\n\\n            elif s[i] == s[i+1]:\\n                count = 1\\n                while (s[i-count] == s[i+1+count]):\\n                    count += 1\\n                count -= 1\\n                temp_longest = s[i-count: i+1+count + 1]\\n\\n            if len(temp_longest) > len(longest):\\n                longest = temp_longest\\n\\n        return longest            \\n`"
                    },
                    {
                        "username": "Yongbi",
                        "content": "[@zohairhadi2000](/zohairhadi2000) This code will get in trouble even for simple testcase:\ns= \"bbbbbbbb\"\nWhy?\n\nBecause you didnt define a boundary condition for string that you check on:\n```\nif s[i-1] == s[i+1]:\n            count = 2\n            while (s[i-count] == s[i+count]):\n                count += 1\n            count -= 1\n            temp_longest = s[i-count: i+count + 1]\n```\nWhat if? s[i-count], i-count<0?, i+count>len(s)-1. It returns a \n_IndexError: string index out of range_ right\n\nSo first, check your condition, then run dry test (change some simple case by yourself). \n\nYou can use a slide windows to check, and only check to len(s)-l-1, l=max last found palindromic substring.\n\n```\nclass Solution:\n    def longestPalindrome(self, s: str) -> str:\n        n, l, i, temp, s1 = [len(s), 1, 0, 0, s[::-1]] \n        if s1==s: return s \n        while i+l <= n-1:\n            for j in range(l,n-i+1):\n                if s1[i:i+j] ==s[n-j-i:n-i]: l=j; temp=i\n                if s1[i:i+j] not in s: break\n            if i<=n-l-1:    i+=1; continue \n            else: break \n        if temp==0 and l==1: return s[0]\n        return s[n-l-temp:n-temp]  \n```"
                    }
                ]
            },
            {
                "id": 1766681,
                "content": [
                    {
                        "username": "kasomaibrahim",
                        "content": "A faster solution with time complexity of O(n) is the Manacher algorithm. It utilizes the idea that if a palindrome has its center at the current position and its right boundary has reached position j, then the palindrome with its center at the current position will have the same length as the palindrome with its center at the symmetrical position of j with respect to the current position, as long as j is within the boundary of the palindrome with center at the current position."
                    },
                    {
                        "username": "Satyarth_Agrahari",
                        "content": "The C++ code provided implements Manacher\\'s algorithm to find the longest palindromic substring in a given input string.\\n\\nThe code starts by defining a function named \"longestPalindrome\" which takes a string as its input and returns a string as its output.\\n\\nThe first step in the function is to preprocess the input string by inserting special characters between each character and also at the beginning and end of the string. This is done by creating a new string \"temp\" and iterating through each character in the input string, adding it to \"temp\" and also adding the special character \"#\" after it. This modified string is then stored in \"s\".\\n\\nNext, the code defines two arrays \"p\" and \"id\" of size n+1, where n is the length of the modified string. The array \"p\" is used to hold the length of the palindrome centered at each character in the modified string and the array \"id\" is used to keep track of the center and right boundary of the current palindrome.\\n\\nThe code then initializes two variables \"mx\" and \"id\" to 0 and assigns the value 0 to all elements of the \"p\" array.\\n\\nThe algorithm then starts iterating through each character in the modified string using a for loop, for each i in s.\\n\\nThe first thing the code does inside the for loop is to check if the current character is within the right boundary of the previous palindrome. If so, it uses the \"mirroring\" technique to calculate the length of the palindrome centered at the current character. It sets the value of \"p[i]\" to the minimum of \"p[(id*2-i)\" and \"mx-i\".\\n\\nOtherwise, the code falls back to the \"expanding around the center\" technique and starts checking the characters on both sides of the current character to find the length of the palindrome centered at the current character.\\n\\nThe code then updates the \"mx\" and \"id\" variables if the current palindrome exceeds the right boundary of the previous palindrome.\\n\\nFinally, the code finds the center and length of the longest palindrome by iterating through the \"p\" array and returning the substring of the original input string using the center and length information.\\n\\nIt\\'s important to note that the above code is just an example and this specific implementation may be different from other ones, but the overall idea and algorithm remains the same."
                    },
                    {
                        "username": "paragtharani24",
                        "content": "can anyone please optimize  below code:\\n\\n/**\\n * @param {string} s\\n * @return {string}\\n */\\nvar longestPalindrome = function(s) {\\n    let longestPalString = \"\"\\n    for(var i=0; i<s.length; i++){\\n        let str = \"\"\\n        for(var j=i; j<s.length; j++){\\n            str = str + s[j]\\n            if(isPalindrome(str)){\\n                if(str.length > longestPalString.length){\\n                    longestPalString = str\\n                }\\n            }\\n        }\\n    }\\n\\n    return longestPalString;\\n};\\n\\nfunction isPalindrome(str){\\n    let left = 0\\n    let right = str.length - 1\\n\\n    while (left < right) {\\n        if (str[left++] !== str[right--]) {\\n            return false\\n        }\\n    }\\n\\n    return true\\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "AasheeshLikePanner",
                        "content": "Hi, I am getting memory limit exceeds in my code. Can you please help to fix. I know my code taking too much memory, but how I fix this.\\nCan we able to modify it so it doesn\\'t give memory limit exceeds or we are not able to modify it.\\nThanks for any suggestion.\\n\\n  class Solution {\\n    `List<String> outer = new ArrayList<>();\\n    public String longestPalindrome(String s) {\\n        String result = \"\";\\n        helper(s , 0, s.length()- 1, \"\");\\n        for (String man:outer) {\\n            int l = man.length();\\n            if (result.length()<l){\\n                result = man;\\n            }\\n        }\\n        return result;\\n    }\\n    public void helper(String s, int start, int end, String result){\\n        int mid = result.length()/2;\\n        if(start> end){\\n            outer.add(result);\\n            return;\\n        }\\n        if(start == end){\\n            char ch = s.charAt(end);\\n            String left = result.substring(0, mid);\\n            String right = result.substring(mid);\\n            result = left + ch + right;\\n            outer.add(result);\\n            helper(s, start + 1, s.length() -1, \"\");\\n             return;\\n        }\\n        char ch1 = s.charAt(start);\\n        char ch2 = s.charAt(end);\\n        if(ch1 == ch2){\\n\\n            String left = result.substring(0, mid);\\n            String right = result.substring(mid);\\n            result = left + ch1 + ch2 + right;\\n            helper(s, start + 1, end - 1, result);\\n        }\\n        result = \"\";\\n        helper(s, start, end - 1, result);\\n    }\\n}`"
                    },
                    {
                        "username": "hiranmay1000",
                        "content": "Why this is coming? help!!\n\nYour input\n\"aacabdkacaa\"\nOutput\n\"aacabacaa\"\nExpected\n\"aca\""
                    },
                    {
                        "username": "hiranmay1000",
                        "content": "Why this is happening please help !! \\nI have used map for finding the longest palindromic substring\\n\\nYour input : \"aacabdkacaa\"\\nOutput : \"aacabacaa\"\\nExpected : \"aca\""
                    },
                    {
                        "username": "shubha_neema",
                        "content": "Getting wrong answer, even for correct answer. Can anyone tell me why this is happening?\\nInput\\ns =\"babad\"\\nOutput\\n\"aba\"\\nExpected\\n\"bab\""
                    },
                    {
                        "username": "vismay__yerunkar",
                        "content": "Subscribe Hustlers Algorithm\\uD83D\\uDCA6\\uD83D\\uDCA6\\uD83D\\uDCA6\\uD83D\\uDD25\\uD83D\\uDD25 `https://youtu.be/94RdOzbXvHM`  Lets make a stronger problem solving community. subscribe to the channel for amazing dsa content."
                    },
                    {
                        "username": "prasannaprassu80",
                        "content": "What is wrong in my code? 127/141 test cases are passed. if i check the failed test case, by copy and paste them in the test case, that test case is getting passed,. then why it is showing test cases failed?\n\n\ndef longestPalindrome(self, s: str) -> str:\n        length_list= []\n        max_len=0\n        result=\"\"\n        for i in range(len(s)):\n            for j in range(i+1, len(s)+1):\n                substring= s[i:j]\n                rev_substring= substring[::-1]\n                if (substring== rev_substring):\n                    length_list.append(substring)\n        for each in length_list:\n            if len(each)> max_len:\n                max_len= len(each)\n                result= each\n        return (result)\n[leetcode](https://leetcode.com) "
                    },
                    {
                        "username": "Yongbi",
                        "content": "[@prasannaprassu80](/prasannaprassu80)\nTime Limit Exceeded!!!\n\nIt not a error of your code, it's time complexity."
                    },
                    {
                        "username": "zohairhadi",
                        "content": "I thought that I\\'d come up with a good solution but there\\'s a lot of edge cases that my solution doesn\\'t cater to. \\nAny suggestions on what I\\'m missing?\\n\\n`\\n        def longestPalindrome(self, s):\\n\\n\\n        longest = \"\"\\n        temp_longest = \"\"\\n        for i in range(1, len(s)-2):\\n\\n            if s[i-1] == s[i+1]:\\n                count = 2\\n                while (s[i-count] == s[i+count]):\\n                    count += 1\\n                count -= 1\\n                temp_longest = s[i-count: i+count + 1]\\n\\n            elif s[i] == s[i+1]:\\n                count = 1\\n                while (s[i-count] == s[i+1+count]):\\n                    count += 1\\n                count -= 1\\n                temp_longest = s[i-count: i+1+count + 1]\\n\\n            if len(temp_longest) > len(longest):\\n                longest = temp_longest\\n\\n        return longest            \\n`"
                    },
                    {
                        "username": "Yongbi",
                        "content": "[@zohairhadi2000](/zohairhadi2000) This code will get in trouble even for simple testcase:\ns= \"bbbbbbbb\"\nWhy?\n\nBecause you didnt define a boundary condition for string that you check on:\n```\nif s[i-1] == s[i+1]:\n            count = 2\n            while (s[i-count] == s[i+count]):\n                count += 1\n            count -= 1\n            temp_longest = s[i-count: i+count + 1]\n```\nWhat if? s[i-count], i-count<0?, i+count>len(s)-1. It returns a \n_IndexError: string index out of range_ right\n\nSo first, check your condition, then run dry test (change some simple case by yourself). \n\nYou can use a slide windows to check, and only check to len(s)-l-1, l=max last found palindromic substring.\n\n```\nclass Solution:\n    def longestPalindrome(self, s: str) -> str:\n        n, l, i, temp, s1 = [len(s), 1, 0, 0, s[::-1]] \n        if s1==s: return s \n        while i+l <= n-1:\n            for j in range(l,n-i+1):\n                if s1[i:i+j] ==s[n-j-i:n-i]: l=j; temp=i\n                if s1[i:i+j] not in s: break\n            if i<=n-l-1:    i+=1; continue \n            else: break \n        if temp==0 and l==1: return s[0]\n        return s[n-l-temp:n-temp]  \n```"
                    }
                ]
            },
            {
                "id": 1765850,
                "content": [
                    {
                        "username": "kasomaibrahim",
                        "content": "A faster solution with time complexity of O(n) is the Manacher algorithm. It utilizes the idea that if a palindrome has its center at the current position and its right boundary has reached position j, then the palindrome with its center at the current position will have the same length as the palindrome with its center at the symmetrical position of j with respect to the current position, as long as j is within the boundary of the palindrome with center at the current position."
                    },
                    {
                        "username": "Satyarth_Agrahari",
                        "content": "The C++ code provided implements Manacher\\'s algorithm to find the longest palindromic substring in a given input string.\\n\\nThe code starts by defining a function named \"longestPalindrome\" which takes a string as its input and returns a string as its output.\\n\\nThe first step in the function is to preprocess the input string by inserting special characters between each character and also at the beginning and end of the string. This is done by creating a new string \"temp\" and iterating through each character in the input string, adding it to \"temp\" and also adding the special character \"#\" after it. This modified string is then stored in \"s\".\\n\\nNext, the code defines two arrays \"p\" and \"id\" of size n+1, where n is the length of the modified string. The array \"p\" is used to hold the length of the palindrome centered at each character in the modified string and the array \"id\" is used to keep track of the center and right boundary of the current palindrome.\\n\\nThe code then initializes two variables \"mx\" and \"id\" to 0 and assigns the value 0 to all elements of the \"p\" array.\\n\\nThe algorithm then starts iterating through each character in the modified string using a for loop, for each i in s.\\n\\nThe first thing the code does inside the for loop is to check if the current character is within the right boundary of the previous palindrome. If so, it uses the \"mirroring\" technique to calculate the length of the palindrome centered at the current character. It sets the value of \"p[i]\" to the minimum of \"p[(id*2-i)\" and \"mx-i\".\\n\\nOtherwise, the code falls back to the \"expanding around the center\" technique and starts checking the characters on both sides of the current character to find the length of the palindrome centered at the current character.\\n\\nThe code then updates the \"mx\" and \"id\" variables if the current palindrome exceeds the right boundary of the previous palindrome.\\n\\nFinally, the code finds the center and length of the longest palindrome by iterating through the \"p\" array and returning the substring of the original input string using the center and length information.\\n\\nIt\\'s important to note that the above code is just an example and this specific implementation may be different from other ones, but the overall idea and algorithm remains the same."
                    },
                    {
                        "username": "paragtharani24",
                        "content": "can anyone please optimize  below code:\\n\\n/**\\n * @param {string} s\\n * @return {string}\\n */\\nvar longestPalindrome = function(s) {\\n    let longestPalString = \"\"\\n    for(var i=0; i<s.length; i++){\\n        let str = \"\"\\n        for(var j=i; j<s.length; j++){\\n            str = str + s[j]\\n            if(isPalindrome(str)){\\n                if(str.length > longestPalString.length){\\n                    longestPalString = str\\n                }\\n            }\\n        }\\n    }\\n\\n    return longestPalString;\\n};\\n\\nfunction isPalindrome(str){\\n    let left = 0\\n    let right = str.length - 1\\n\\n    while (left < right) {\\n        if (str[left++] !== str[right--]) {\\n            return false\\n        }\\n    }\\n\\n    return true\\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "AasheeshLikePanner",
                        "content": "Hi, I am getting memory limit exceeds in my code. Can you please help to fix. I know my code taking too much memory, but how I fix this.\\nCan we able to modify it so it doesn\\'t give memory limit exceeds or we are not able to modify it.\\nThanks for any suggestion.\\n\\n  class Solution {\\n    `List<String> outer = new ArrayList<>();\\n    public String longestPalindrome(String s) {\\n        String result = \"\";\\n        helper(s , 0, s.length()- 1, \"\");\\n        for (String man:outer) {\\n            int l = man.length();\\n            if (result.length()<l){\\n                result = man;\\n            }\\n        }\\n        return result;\\n    }\\n    public void helper(String s, int start, int end, String result){\\n        int mid = result.length()/2;\\n        if(start> end){\\n            outer.add(result);\\n            return;\\n        }\\n        if(start == end){\\n            char ch = s.charAt(end);\\n            String left = result.substring(0, mid);\\n            String right = result.substring(mid);\\n            result = left + ch + right;\\n            outer.add(result);\\n            helper(s, start + 1, s.length() -1, \"\");\\n             return;\\n        }\\n        char ch1 = s.charAt(start);\\n        char ch2 = s.charAt(end);\\n        if(ch1 == ch2){\\n\\n            String left = result.substring(0, mid);\\n            String right = result.substring(mid);\\n            result = left + ch1 + ch2 + right;\\n            helper(s, start + 1, end - 1, result);\\n        }\\n        result = \"\";\\n        helper(s, start, end - 1, result);\\n    }\\n}`"
                    },
                    {
                        "username": "hiranmay1000",
                        "content": "Why this is coming? help!!\n\nYour input\n\"aacabdkacaa\"\nOutput\n\"aacabacaa\"\nExpected\n\"aca\""
                    },
                    {
                        "username": "hiranmay1000",
                        "content": "Why this is happening please help !! \\nI have used map for finding the longest palindromic substring\\n\\nYour input : \"aacabdkacaa\"\\nOutput : \"aacabacaa\"\\nExpected : \"aca\""
                    },
                    {
                        "username": "shubha_neema",
                        "content": "Getting wrong answer, even for correct answer. Can anyone tell me why this is happening?\\nInput\\ns =\"babad\"\\nOutput\\n\"aba\"\\nExpected\\n\"bab\""
                    },
                    {
                        "username": "vismay__yerunkar",
                        "content": "Subscribe Hustlers Algorithm\\uD83D\\uDCA6\\uD83D\\uDCA6\\uD83D\\uDCA6\\uD83D\\uDD25\\uD83D\\uDD25 `https://youtu.be/94RdOzbXvHM`  Lets make a stronger problem solving community. subscribe to the channel for amazing dsa content."
                    },
                    {
                        "username": "prasannaprassu80",
                        "content": "What is wrong in my code? 127/141 test cases are passed. if i check the failed test case, by copy and paste them in the test case, that test case is getting passed,. then why it is showing test cases failed?\n\n\ndef longestPalindrome(self, s: str) -> str:\n        length_list= []\n        max_len=0\n        result=\"\"\n        for i in range(len(s)):\n            for j in range(i+1, len(s)+1):\n                substring= s[i:j]\n                rev_substring= substring[::-1]\n                if (substring== rev_substring):\n                    length_list.append(substring)\n        for each in length_list:\n            if len(each)> max_len:\n                max_len= len(each)\n                result= each\n        return (result)\n[leetcode](https://leetcode.com) "
                    },
                    {
                        "username": "Yongbi",
                        "content": "[@prasannaprassu80](/prasannaprassu80)\nTime Limit Exceeded!!!\n\nIt not a error of your code, it's time complexity."
                    },
                    {
                        "username": "zohairhadi",
                        "content": "I thought that I\\'d come up with a good solution but there\\'s a lot of edge cases that my solution doesn\\'t cater to. \\nAny suggestions on what I\\'m missing?\\n\\n`\\n        def longestPalindrome(self, s):\\n\\n\\n        longest = \"\"\\n        temp_longest = \"\"\\n        for i in range(1, len(s)-2):\\n\\n            if s[i-1] == s[i+1]:\\n                count = 2\\n                while (s[i-count] == s[i+count]):\\n                    count += 1\\n                count -= 1\\n                temp_longest = s[i-count: i+count + 1]\\n\\n            elif s[i] == s[i+1]:\\n                count = 1\\n                while (s[i-count] == s[i+1+count]):\\n                    count += 1\\n                count -= 1\\n                temp_longest = s[i-count: i+1+count + 1]\\n\\n            if len(temp_longest) > len(longest):\\n                longest = temp_longest\\n\\n        return longest            \\n`"
                    },
                    {
                        "username": "Yongbi",
                        "content": "[@zohairhadi2000](/zohairhadi2000) This code will get in trouble even for simple testcase:\ns= \"bbbbbbbb\"\nWhy?\n\nBecause you didnt define a boundary condition for string that you check on:\n```\nif s[i-1] == s[i+1]:\n            count = 2\n            while (s[i-count] == s[i+count]):\n                count += 1\n            count -= 1\n            temp_longest = s[i-count: i+count + 1]\n```\nWhat if? s[i-count], i-count<0?, i+count>len(s)-1. It returns a \n_IndexError: string index out of range_ right\n\nSo first, check your condition, then run dry test (change some simple case by yourself). \n\nYou can use a slide windows to check, and only check to len(s)-l-1, l=max last found palindromic substring.\n\n```\nclass Solution:\n    def longestPalindrome(self, s: str) -> str:\n        n, l, i, temp, s1 = [len(s), 1, 0, 0, s[::-1]] \n        if s1==s: return s \n        while i+l <= n-1:\n            for j in range(l,n-i+1):\n                if s1[i:i+j] ==s[n-j-i:n-i]: l=j; temp=i\n                if s1[i:i+j] not in s: break\n            if i<=n-l-1:    i+=1; continue \n            else: break \n        if temp==0 and l==1: return s[0]\n        return s[n-l-temp:n-temp]  \n```"
                    }
                ]
            },
            {
                "id": 1763937,
                "content": [
                    {
                        "username": "kasomaibrahim",
                        "content": "A faster solution with time complexity of O(n) is the Manacher algorithm. It utilizes the idea that if a palindrome has its center at the current position and its right boundary has reached position j, then the palindrome with its center at the current position will have the same length as the palindrome with its center at the symmetrical position of j with respect to the current position, as long as j is within the boundary of the palindrome with center at the current position."
                    },
                    {
                        "username": "Satyarth_Agrahari",
                        "content": "The C++ code provided implements Manacher\\'s algorithm to find the longest palindromic substring in a given input string.\\n\\nThe code starts by defining a function named \"longestPalindrome\" which takes a string as its input and returns a string as its output.\\n\\nThe first step in the function is to preprocess the input string by inserting special characters between each character and also at the beginning and end of the string. This is done by creating a new string \"temp\" and iterating through each character in the input string, adding it to \"temp\" and also adding the special character \"#\" after it. This modified string is then stored in \"s\".\\n\\nNext, the code defines two arrays \"p\" and \"id\" of size n+1, where n is the length of the modified string. The array \"p\" is used to hold the length of the palindrome centered at each character in the modified string and the array \"id\" is used to keep track of the center and right boundary of the current palindrome.\\n\\nThe code then initializes two variables \"mx\" and \"id\" to 0 and assigns the value 0 to all elements of the \"p\" array.\\n\\nThe algorithm then starts iterating through each character in the modified string using a for loop, for each i in s.\\n\\nThe first thing the code does inside the for loop is to check if the current character is within the right boundary of the previous palindrome. If so, it uses the \"mirroring\" technique to calculate the length of the palindrome centered at the current character. It sets the value of \"p[i]\" to the minimum of \"p[(id*2-i)\" and \"mx-i\".\\n\\nOtherwise, the code falls back to the \"expanding around the center\" technique and starts checking the characters on both sides of the current character to find the length of the palindrome centered at the current character.\\n\\nThe code then updates the \"mx\" and \"id\" variables if the current palindrome exceeds the right boundary of the previous palindrome.\\n\\nFinally, the code finds the center and length of the longest palindrome by iterating through the \"p\" array and returning the substring of the original input string using the center and length information.\\n\\nIt\\'s important to note that the above code is just an example and this specific implementation may be different from other ones, but the overall idea and algorithm remains the same."
                    },
                    {
                        "username": "paragtharani24",
                        "content": "can anyone please optimize  below code:\\n\\n/**\\n * @param {string} s\\n * @return {string}\\n */\\nvar longestPalindrome = function(s) {\\n    let longestPalString = \"\"\\n    for(var i=0; i<s.length; i++){\\n        let str = \"\"\\n        for(var j=i; j<s.length; j++){\\n            str = str + s[j]\\n            if(isPalindrome(str)){\\n                if(str.length > longestPalString.length){\\n                    longestPalString = str\\n                }\\n            }\\n        }\\n    }\\n\\n    return longestPalString;\\n};\\n\\nfunction isPalindrome(str){\\n    let left = 0\\n    let right = str.length - 1\\n\\n    while (left < right) {\\n        if (str[left++] !== str[right--]) {\\n            return false\\n        }\\n    }\\n\\n    return true\\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "AasheeshLikePanner",
                        "content": "Hi, I am getting memory limit exceeds in my code. Can you please help to fix. I know my code taking too much memory, but how I fix this.\\nCan we able to modify it so it doesn\\'t give memory limit exceeds or we are not able to modify it.\\nThanks for any suggestion.\\n\\n  class Solution {\\n    `List<String> outer = new ArrayList<>();\\n    public String longestPalindrome(String s) {\\n        String result = \"\";\\n        helper(s , 0, s.length()- 1, \"\");\\n        for (String man:outer) {\\n            int l = man.length();\\n            if (result.length()<l){\\n                result = man;\\n            }\\n        }\\n        return result;\\n    }\\n    public void helper(String s, int start, int end, String result){\\n        int mid = result.length()/2;\\n        if(start> end){\\n            outer.add(result);\\n            return;\\n        }\\n        if(start == end){\\n            char ch = s.charAt(end);\\n            String left = result.substring(0, mid);\\n            String right = result.substring(mid);\\n            result = left + ch + right;\\n            outer.add(result);\\n            helper(s, start + 1, s.length() -1, \"\");\\n             return;\\n        }\\n        char ch1 = s.charAt(start);\\n        char ch2 = s.charAt(end);\\n        if(ch1 == ch2){\\n\\n            String left = result.substring(0, mid);\\n            String right = result.substring(mid);\\n            result = left + ch1 + ch2 + right;\\n            helper(s, start + 1, end - 1, result);\\n        }\\n        result = \"\";\\n        helper(s, start, end - 1, result);\\n    }\\n}`"
                    },
                    {
                        "username": "hiranmay1000",
                        "content": "Why this is coming? help!!\n\nYour input\n\"aacabdkacaa\"\nOutput\n\"aacabacaa\"\nExpected\n\"aca\""
                    },
                    {
                        "username": "hiranmay1000",
                        "content": "Why this is happening please help !! \\nI have used map for finding the longest palindromic substring\\n\\nYour input : \"aacabdkacaa\"\\nOutput : \"aacabacaa\"\\nExpected : \"aca\""
                    },
                    {
                        "username": "shubha_neema",
                        "content": "Getting wrong answer, even for correct answer. Can anyone tell me why this is happening?\\nInput\\ns =\"babad\"\\nOutput\\n\"aba\"\\nExpected\\n\"bab\""
                    },
                    {
                        "username": "vismay__yerunkar",
                        "content": "Subscribe Hustlers Algorithm\\uD83D\\uDCA6\\uD83D\\uDCA6\\uD83D\\uDCA6\\uD83D\\uDD25\\uD83D\\uDD25 `https://youtu.be/94RdOzbXvHM`  Lets make a stronger problem solving community. subscribe to the channel for amazing dsa content."
                    },
                    {
                        "username": "prasannaprassu80",
                        "content": "What is wrong in my code? 127/141 test cases are passed. if i check the failed test case, by copy and paste them in the test case, that test case is getting passed,. then why it is showing test cases failed?\n\n\ndef longestPalindrome(self, s: str) -> str:\n        length_list= []\n        max_len=0\n        result=\"\"\n        for i in range(len(s)):\n            for j in range(i+1, len(s)+1):\n                substring= s[i:j]\n                rev_substring= substring[::-1]\n                if (substring== rev_substring):\n                    length_list.append(substring)\n        for each in length_list:\n            if len(each)> max_len:\n                max_len= len(each)\n                result= each\n        return (result)\n[leetcode](https://leetcode.com) "
                    },
                    {
                        "username": "Yongbi",
                        "content": "[@prasannaprassu80](/prasannaprassu80)\nTime Limit Exceeded!!!\n\nIt not a error of your code, it's time complexity."
                    },
                    {
                        "username": "zohairhadi",
                        "content": "I thought that I\\'d come up with a good solution but there\\'s a lot of edge cases that my solution doesn\\'t cater to. \\nAny suggestions on what I\\'m missing?\\n\\n`\\n        def longestPalindrome(self, s):\\n\\n\\n        longest = \"\"\\n        temp_longest = \"\"\\n        for i in range(1, len(s)-2):\\n\\n            if s[i-1] == s[i+1]:\\n                count = 2\\n                while (s[i-count] == s[i+count]):\\n                    count += 1\\n                count -= 1\\n                temp_longest = s[i-count: i+count + 1]\\n\\n            elif s[i] == s[i+1]:\\n                count = 1\\n                while (s[i-count] == s[i+1+count]):\\n                    count += 1\\n                count -= 1\\n                temp_longest = s[i-count: i+1+count + 1]\\n\\n            if len(temp_longest) > len(longest):\\n                longest = temp_longest\\n\\n        return longest            \\n`"
                    },
                    {
                        "username": "Yongbi",
                        "content": "[@zohairhadi2000](/zohairhadi2000) This code will get in trouble even for simple testcase:\ns= \"bbbbbbbb\"\nWhy?\n\nBecause you didnt define a boundary condition for string that you check on:\n```\nif s[i-1] == s[i+1]:\n            count = 2\n            while (s[i-count] == s[i+count]):\n                count += 1\n            count -= 1\n            temp_longest = s[i-count: i+count + 1]\n```\nWhat if? s[i-count], i-count<0?, i+count>len(s)-1. It returns a \n_IndexError: string index out of range_ right\n\nSo first, check your condition, then run dry test (change some simple case by yourself). \n\nYou can use a slide windows to check, and only check to len(s)-l-1, l=max last found palindromic substring.\n\n```\nclass Solution:\n    def longestPalindrome(self, s: str) -> str:\n        n, l, i, temp, s1 = [len(s), 1, 0, 0, s[::-1]] \n        if s1==s: return s \n        while i+l <= n-1:\n            for j in range(l,n-i+1):\n                if s1[i:i+j] ==s[n-j-i:n-i]: l=j; temp=i\n                if s1[i:i+j] not in s: break\n            if i<=n-l-1:    i+=1; continue \n            else: break \n        if temp==0 and l==1: return s[0]\n        return s[n-l-temp:n-temp]  \n```"
                    }
                ]
            },
            {
                "id": 1759488,
                "content": [
                    {
                        "username": "amart73",
                        "content": "mmm, isn\\'t \"aacabacaa\" a valid and longer palindrome in \"aacabdkacaa\" than \"aca\", why the wrong answer result?\\n\\nWrong Answer\\nInput\\ns =\\n\"aacabdkacaa\"\\n62 / 141 testcases passed\\nOutput\\n\"aacabacaa\"\\nExpected\\n\"aca\"\\n"
                    },
                    {
                        "username": "Bhawesh12",
                        "content": "Because \"aacabdkacaa\" has d and k in between string whereas your answer has \"aacabacaa\"  as a output. How come you skip the 2 letters in between. They will break the palindromic string and the output must be \"aca\""
                    },
                    {
                        "username": "asingh882",
                        "content": "/**\\n * @param {string} s\\n * @return {string}\\n */\\nvar longestPalindrome = function(s) {\\n    \\n    let longest = \"\";\\n    for(let i = 0; i < s.length; i++) {\\n        for(let j = i + 1; j <= s.length; j++) {\\n            let current = s.slice(i, j);\\n            if(isPalindrome(current) && current.length > longest.length) {\\n                    longest = current;\\n            }\\n        }\\n    }\\n    return longest;\\n};\\n\\nvar isPalindrome = function(s) {\\n    let reversed = s.split(\"\").reverse().join(\\'\\');\\n    return s === reversed;\\n}\\n\\n\"Time Limit Exceeded\" \\nHow this can be fixed?"
                    },
                    {
                        "username": "christianc750",
                        "content": "This fails due to time limits but I\\'m curious if my approach is correct\\n\\n `var longestPalindrome = function(s) {\\n let maxlengthpalindrome = { length: 0, output: \\'\\'};\\n const answer = maxlengthpalindromeInnerScope(s,maxlengthpalindrome);\\n console.log (maxlengthpalindrome);\\n return maxlengthpalindrome.output;\\n\\n};\\n\\nfunction maxlengthpalindromeInnerScope(s,memo) {\\n\\n if (s.length === 0) return \\'\\';\\n if (s.length === 1) {\\n    memo.length = 1;\\n    memo.output = s;\\n    return s;\\n }\\n if (s.length <= memo.length) return memo.output;\\n \\n const pal_length = returnPalindrome(s).length;\\n\\n if (pal_length > 1) {\\n    memo.length = pal_length;\\n    memo.output = s;\\n    return s; \\n }\\n\\n const leftSubStringLP = maxlengthpalindromeInnerScope(s.substring(0,s.length-1), memo);\\n const rightSubStringLP = maxlengthpalindromeInnerScope(s.substring(1,s.length), memo); \\n}`"
                    },
                    {
                        "username": "Yongbi",
                        "content": "No need check all of string, check up to s.length-1- last_found_maxlength."
                    },
                    {
                        "username": "sjorsp",
                        "content": "Funny, I already solved this one by my self, but I thought, would ChatGPT handle this?\\nFirst attempt and it worked without any alterations......"
                    },
                    {
                        "username": "xgz2",
                        "content": "Is it feasible to use a set to maintain the formerly confirmed palindromes rather than the matrix representation described in the solutions? I don\\'t seem to be able to get this to work and am instead getting time limit exceeded for many cases."
                    },
                    {
                        "username": "Maheshzzz",
                        "content": "even though my solution passes 141/141 test cases why it is showing time limit exceeded"
                    },
                    {
                        "username": "ndungu_dedan",
                        "content": "Isn`t the longest palindrome for this input \\n\\'babad\\' => baba"
                    },
                    {
                        "username": "DevPj09",
                        "content": "No. Palindrome are the numbers/words which have same looks even after reversed.\\neg: 151. Even if you reverse it still looks the same\\nbut for the input \\'baba\\' reverse is : \\'abab\\' which is not identical to the initial value."
                    },
                    {
                        "username": "dev3008",
                        "content": "class Solution:\\n    def longestPalindrome(self, s: str) -> str:\\n        for i in range(len(s),-1,-1):\\n            for j in range(0,(len(s)-i)+1):\\n                start=j\\n                end=j+i\\n                if(end<=len(s)):\\n                    temp_sub_string = s[j:end]\\n                    if temp_sub_string == temp_sub_string[::-1]:\\n                        return temp_sub_string\\n                        break\\n\\nI have written this solution based on DP But it is stuck in TLE Error...what can be done to improve this solution ?"
                    },
                    {
                        "username": "zfar-",
                        "content": "Hi , \ni don't understand how can be a palindrome of \"abb\" is \"bb\" ? \nas palindrome \"abb\" - \"bba\" -> resulting in only 'b' to be a palindrome.\n\n Can anyone explain ? "
                    },
                    {
                        "username": "DevPj09",
                        "content": "No. Palindrome are the numbers/words which have same looks even after reversed.\\neg: deed. Even if you reverse it still looks the same\\nbut for the input \\'abb\\' reverse is : \\'bba\\' which is not identical to the initial value.\\n\\nhowever, in case of \\'bb\\' even if you reverse it, it is the same. Hope it answers\\n"
                    },
                    {
                        "username": "johnson0127",
                        "content": "s =\\n\"aacabdkacaa\"\\n\\nwhy output is not \"aacabdkacaa\"\\nExpected  is \"aca\" ?\\n"
                    }
                ]
            },
            {
                "id": 1758513,
                "content": [
                    {
                        "username": "amart73",
                        "content": "mmm, isn\\'t \"aacabacaa\" a valid and longer palindrome in \"aacabdkacaa\" than \"aca\", why the wrong answer result?\\n\\nWrong Answer\\nInput\\ns =\\n\"aacabdkacaa\"\\n62 / 141 testcases passed\\nOutput\\n\"aacabacaa\"\\nExpected\\n\"aca\"\\n"
                    },
                    {
                        "username": "Bhawesh12",
                        "content": "Because \"aacabdkacaa\" has d and k in between string whereas your answer has \"aacabacaa\"  as a output. How come you skip the 2 letters in between. They will break the palindromic string and the output must be \"aca\""
                    },
                    {
                        "username": "asingh882",
                        "content": "/**\\n * @param {string} s\\n * @return {string}\\n */\\nvar longestPalindrome = function(s) {\\n    \\n    let longest = \"\";\\n    for(let i = 0; i < s.length; i++) {\\n        for(let j = i + 1; j <= s.length; j++) {\\n            let current = s.slice(i, j);\\n            if(isPalindrome(current) && current.length > longest.length) {\\n                    longest = current;\\n            }\\n        }\\n    }\\n    return longest;\\n};\\n\\nvar isPalindrome = function(s) {\\n    let reversed = s.split(\"\").reverse().join(\\'\\');\\n    return s === reversed;\\n}\\n\\n\"Time Limit Exceeded\" \\nHow this can be fixed?"
                    },
                    {
                        "username": "christianc750",
                        "content": "This fails due to time limits but I\\'m curious if my approach is correct\\n\\n `var longestPalindrome = function(s) {\\n let maxlengthpalindrome = { length: 0, output: \\'\\'};\\n const answer = maxlengthpalindromeInnerScope(s,maxlengthpalindrome);\\n console.log (maxlengthpalindrome);\\n return maxlengthpalindrome.output;\\n\\n};\\n\\nfunction maxlengthpalindromeInnerScope(s,memo) {\\n\\n if (s.length === 0) return \\'\\';\\n if (s.length === 1) {\\n    memo.length = 1;\\n    memo.output = s;\\n    return s;\\n }\\n if (s.length <= memo.length) return memo.output;\\n \\n const pal_length = returnPalindrome(s).length;\\n\\n if (pal_length > 1) {\\n    memo.length = pal_length;\\n    memo.output = s;\\n    return s; \\n }\\n\\n const leftSubStringLP = maxlengthpalindromeInnerScope(s.substring(0,s.length-1), memo);\\n const rightSubStringLP = maxlengthpalindromeInnerScope(s.substring(1,s.length), memo); \\n}`"
                    },
                    {
                        "username": "Yongbi",
                        "content": "No need check all of string, check up to s.length-1- last_found_maxlength."
                    },
                    {
                        "username": "sjorsp",
                        "content": "Funny, I already solved this one by my self, but I thought, would ChatGPT handle this?\\nFirst attempt and it worked without any alterations......"
                    },
                    {
                        "username": "xgz2",
                        "content": "Is it feasible to use a set to maintain the formerly confirmed palindromes rather than the matrix representation described in the solutions? I don\\'t seem to be able to get this to work and am instead getting time limit exceeded for many cases."
                    },
                    {
                        "username": "Maheshzzz",
                        "content": "even though my solution passes 141/141 test cases why it is showing time limit exceeded"
                    },
                    {
                        "username": "ndungu_dedan",
                        "content": "Isn`t the longest palindrome for this input \\n\\'babad\\' => baba"
                    },
                    {
                        "username": "DevPj09",
                        "content": "No. Palindrome are the numbers/words which have same looks even after reversed.\\neg: 151. Even if you reverse it still looks the same\\nbut for the input \\'baba\\' reverse is : \\'abab\\' which is not identical to the initial value."
                    },
                    {
                        "username": "dev3008",
                        "content": "class Solution:\\n    def longestPalindrome(self, s: str) -> str:\\n        for i in range(len(s),-1,-1):\\n            for j in range(0,(len(s)-i)+1):\\n                start=j\\n                end=j+i\\n                if(end<=len(s)):\\n                    temp_sub_string = s[j:end]\\n                    if temp_sub_string == temp_sub_string[::-1]:\\n                        return temp_sub_string\\n                        break\\n\\nI have written this solution based on DP But it is stuck in TLE Error...what can be done to improve this solution ?"
                    },
                    {
                        "username": "zfar-",
                        "content": "Hi , \ni don't understand how can be a palindrome of \"abb\" is \"bb\" ? \nas palindrome \"abb\" - \"bba\" -> resulting in only 'b' to be a palindrome.\n\n Can anyone explain ? "
                    },
                    {
                        "username": "DevPj09",
                        "content": "No. Palindrome are the numbers/words which have same looks even after reversed.\\neg: deed. Even if you reverse it still looks the same\\nbut for the input \\'abb\\' reverse is : \\'bba\\' which is not identical to the initial value.\\n\\nhowever, in case of \\'bb\\' even if you reverse it, it is the same. Hope it answers\\n"
                    },
                    {
                        "username": "johnson0127",
                        "content": "s =\\n\"aacabdkacaa\"\\n\\nwhy output is not \"aacabdkacaa\"\\nExpected  is \"aca\" ?\\n"
                    }
                ]
            },
            {
                "id": 1757868,
                "content": [
                    {
                        "username": "amart73",
                        "content": "mmm, isn\\'t \"aacabacaa\" a valid and longer palindrome in \"aacabdkacaa\" than \"aca\", why the wrong answer result?\\n\\nWrong Answer\\nInput\\ns =\\n\"aacabdkacaa\"\\n62 / 141 testcases passed\\nOutput\\n\"aacabacaa\"\\nExpected\\n\"aca\"\\n"
                    },
                    {
                        "username": "Bhawesh12",
                        "content": "Because \"aacabdkacaa\" has d and k in between string whereas your answer has \"aacabacaa\"  as a output. How come you skip the 2 letters in between. They will break the palindromic string and the output must be \"aca\""
                    },
                    {
                        "username": "asingh882",
                        "content": "/**\\n * @param {string} s\\n * @return {string}\\n */\\nvar longestPalindrome = function(s) {\\n    \\n    let longest = \"\";\\n    for(let i = 0; i < s.length; i++) {\\n        for(let j = i + 1; j <= s.length; j++) {\\n            let current = s.slice(i, j);\\n            if(isPalindrome(current) && current.length > longest.length) {\\n                    longest = current;\\n            }\\n        }\\n    }\\n    return longest;\\n};\\n\\nvar isPalindrome = function(s) {\\n    let reversed = s.split(\"\").reverse().join(\\'\\');\\n    return s === reversed;\\n}\\n\\n\"Time Limit Exceeded\" \\nHow this can be fixed?"
                    },
                    {
                        "username": "christianc750",
                        "content": "This fails due to time limits but I\\'m curious if my approach is correct\\n\\n `var longestPalindrome = function(s) {\\n let maxlengthpalindrome = { length: 0, output: \\'\\'};\\n const answer = maxlengthpalindromeInnerScope(s,maxlengthpalindrome);\\n console.log (maxlengthpalindrome);\\n return maxlengthpalindrome.output;\\n\\n};\\n\\nfunction maxlengthpalindromeInnerScope(s,memo) {\\n\\n if (s.length === 0) return \\'\\';\\n if (s.length === 1) {\\n    memo.length = 1;\\n    memo.output = s;\\n    return s;\\n }\\n if (s.length <= memo.length) return memo.output;\\n \\n const pal_length = returnPalindrome(s).length;\\n\\n if (pal_length > 1) {\\n    memo.length = pal_length;\\n    memo.output = s;\\n    return s; \\n }\\n\\n const leftSubStringLP = maxlengthpalindromeInnerScope(s.substring(0,s.length-1), memo);\\n const rightSubStringLP = maxlengthpalindromeInnerScope(s.substring(1,s.length), memo); \\n}`"
                    },
                    {
                        "username": "Yongbi",
                        "content": "No need check all of string, check up to s.length-1- last_found_maxlength."
                    },
                    {
                        "username": "sjorsp",
                        "content": "Funny, I already solved this one by my self, but I thought, would ChatGPT handle this?\\nFirst attempt and it worked without any alterations......"
                    },
                    {
                        "username": "xgz2",
                        "content": "Is it feasible to use a set to maintain the formerly confirmed palindromes rather than the matrix representation described in the solutions? I don\\'t seem to be able to get this to work and am instead getting time limit exceeded for many cases."
                    },
                    {
                        "username": "Maheshzzz",
                        "content": "even though my solution passes 141/141 test cases why it is showing time limit exceeded"
                    },
                    {
                        "username": "ndungu_dedan",
                        "content": "Isn`t the longest palindrome for this input \\n\\'babad\\' => baba"
                    },
                    {
                        "username": "DevPj09",
                        "content": "No. Palindrome are the numbers/words which have same looks even after reversed.\\neg: 151. Even if you reverse it still looks the same\\nbut for the input \\'baba\\' reverse is : \\'abab\\' which is not identical to the initial value."
                    },
                    {
                        "username": "dev3008",
                        "content": "class Solution:\\n    def longestPalindrome(self, s: str) -> str:\\n        for i in range(len(s),-1,-1):\\n            for j in range(0,(len(s)-i)+1):\\n                start=j\\n                end=j+i\\n                if(end<=len(s)):\\n                    temp_sub_string = s[j:end]\\n                    if temp_sub_string == temp_sub_string[::-1]:\\n                        return temp_sub_string\\n                        break\\n\\nI have written this solution based on DP But it is stuck in TLE Error...what can be done to improve this solution ?"
                    },
                    {
                        "username": "zfar-",
                        "content": "Hi , \ni don't understand how can be a palindrome of \"abb\" is \"bb\" ? \nas palindrome \"abb\" - \"bba\" -> resulting in only 'b' to be a palindrome.\n\n Can anyone explain ? "
                    },
                    {
                        "username": "DevPj09",
                        "content": "No. Palindrome are the numbers/words which have same looks even after reversed.\\neg: deed. Even if you reverse it still looks the same\\nbut for the input \\'abb\\' reverse is : \\'bba\\' which is not identical to the initial value.\\n\\nhowever, in case of \\'bb\\' even if you reverse it, it is the same. Hope it answers\\n"
                    },
                    {
                        "username": "johnson0127",
                        "content": "s =\\n\"aacabdkacaa\"\\n\\nwhy output is not \"aacabdkacaa\"\\nExpected  is \"aca\" ?\\n"
                    }
                ]
            },
            {
                "id": 1756160,
                "content": [
                    {
                        "username": "amart73",
                        "content": "mmm, isn\\'t \"aacabacaa\" a valid and longer palindrome in \"aacabdkacaa\" than \"aca\", why the wrong answer result?\\n\\nWrong Answer\\nInput\\ns =\\n\"aacabdkacaa\"\\n62 / 141 testcases passed\\nOutput\\n\"aacabacaa\"\\nExpected\\n\"aca\"\\n"
                    },
                    {
                        "username": "Bhawesh12",
                        "content": "Because \"aacabdkacaa\" has d and k in between string whereas your answer has \"aacabacaa\"  as a output. How come you skip the 2 letters in between. They will break the palindromic string and the output must be \"aca\""
                    },
                    {
                        "username": "asingh882",
                        "content": "/**\\n * @param {string} s\\n * @return {string}\\n */\\nvar longestPalindrome = function(s) {\\n    \\n    let longest = \"\";\\n    for(let i = 0; i < s.length; i++) {\\n        for(let j = i + 1; j <= s.length; j++) {\\n            let current = s.slice(i, j);\\n            if(isPalindrome(current) && current.length > longest.length) {\\n                    longest = current;\\n            }\\n        }\\n    }\\n    return longest;\\n};\\n\\nvar isPalindrome = function(s) {\\n    let reversed = s.split(\"\").reverse().join(\\'\\');\\n    return s === reversed;\\n}\\n\\n\"Time Limit Exceeded\" \\nHow this can be fixed?"
                    },
                    {
                        "username": "christianc750",
                        "content": "This fails due to time limits but I\\'m curious if my approach is correct\\n\\n `var longestPalindrome = function(s) {\\n let maxlengthpalindrome = { length: 0, output: \\'\\'};\\n const answer = maxlengthpalindromeInnerScope(s,maxlengthpalindrome);\\n console.log (maxlengthpalindrome);\\n return maxlengthpalindrome.output;\\n\\n};\\n\\nfunction maxlengthpalindromeInnerScope(s,memo) {\\n\\n if (s.length === 0) return \\'\\';\\n if (s.length === 1) {\\n    memo.length = 1;\\n    memo.output = s;\\n    return s;\\n }\\n if (s.length <= memo.length) return memo.output;\\n \\n const pal_length = returnPalindrome(s).length;\\n\\n if (pal_length > 1) {\\n    memo.length = pal_length;\\n    memo.output = s;\\n    return s; \\n }\\n\\n const leftSubStringLP = maxlengthpalindromeInnerScope(s.substring(0,s.length-1), memo);\\n const rightSubStringLP = maxlengthpalindromeInnerScope(s.substring(1,s.length), memo); \\n}`"
                    },
                    {
                        "username": "Yongbi",
                        "content": "No need check all of string, check up to s.length-1- last_found_maxlength."
                    },
                    {
                        "username": "sjorsp",
                        "content": "Funny, I already solved this one by my self, but I thought, would ChatGPT handle this?\\nFirst attempt and it worked without any alterations......"
                    },
                    {
                        "username": "xgz2",
                        "content": "Is it feasible to use a set to maintain the formerly confirmed palindromes rather than the matrix representation described in the solutions? I don\\'t seem to be able to get this to work and am instead getting time limit exceeded for many cases."
                    },
                    {
                        "username": "Maheshzzz",
                        "content": "even though my solution passes 141/141 test cases why it is showing time limit exceeded"
                    },
                    {
                        "username": "ndungu_dedan",
                        "content": "Isn`t the longest palindrome for this input \\n\\'babad\\' => baba"
                    },
                    {
                        "username": "DevPj09",
                        "content": "No. Palindrome are the numbers/words which have same looks even after reversed.\\neg: 151. Even if you reverse it still looks the same\\nbut for the input \\'baba\\' reverse is : \\'abab\\' which is not identical to the initial value."
                    },
                    {
                        "username": "dev3008",
                        "content": "class Solution:\\n    def longestPalindrome(self, s: str) -> str:\\n        for i in range(len(s),-1,-1):\\n            for j in range(0,(len(s)-i)+1):\\n                start=j\\n                end=j+i\\n                if(end<=len(s)):\\n                    temp_sub_string = s[j:end]\\n                    if temp_sub_string == temp_sub_string[::-1]:\\n                        return temp_sub_string\\n                        break\\n\\nI have written this solution based on DP But it is stuck in TLE Error...what can be done to improve this solution ?"
                    },
                    {
                        "username": "zfar-",
                        "content": "Hi , \ni don't understand how can be a palindrome of \"abb\" is \"bb\" ? \nas palindrome \"abb\" - \"bba\" -> resulting in only 'b' to be a palindrome.\n\n Can anyone explain ? "
                    },
                    {
                        "username": "DevPj09",
                        "content": "No. Palindrome are the numbers/words which have same looks even after reversed.\\neg: deed. Even if you reverse it still looks the same\\nbut for the input \\'abb\\' reverse is : \\'bba\\' which is not identical to the initial value.\\n\\nhowever, in case of \\'bb\\' even if you reverse it, it is the same. Hope it answers\\n"
                    },
                    {
                        "username": "johnson0127",
                        "content": "s =\\n\"aacabdkacaa\"\\n\\nwhy output is not \"aacabdkacaa\"\\nExpected  is \"aca\" ?\\n"
                    }
                ]
            },
            {
                "id": 1753546,
                "content": [
                    {
                        "username": "amart73",
                        "content": "mmm, isn\\'t \"aacabacaa\" a valid and longer palindrome in \"aacabdkacaa\" than \"aca\", why the wrong answer result?\\n\\nWrong Answer\\nInput\\ns =\\n\"aacabdkacaa\"\\n62 / 141 testcases passed\\nOutput\\n\"aacabacaa\"\\nExpected\\n\"aca\"\\n"
                    },
                    {
                        "username": "Bhawesh12",
                        "content": "Because \"aacabdkacaa\" has d and k in between string whereas your answer has \"aacabacaa\"  as a output. How come you skip the 2 letters in between. They will break the palindromic string and the output must be \"aca\""
                    },
                    {
                        "username": "asingh882",
                        "content": "/**\\n * @param {string} s\\n * @return {string}\\n */\\nvar longestPalindrome = function(s) {\\n    \\n    let longest = \"\";\\n    for(let i = 0; i < s.length; i++) {\\n        for(let j = i + 1; j <= s.length; j++) {\\n            let current = s.slice(i, j);\\n            if(isPalindrome(current) && current.length > longest.length) {\\n                    longest = current;\\n            }\\n        }\\n    }\\n    return longest;\\n};\\n\\nvar isPalindrome = function(s) {\\n    let reversed = s.split(\"\").reverse().join(\\'\\');\\n    return s === reversed;\\n}\\n\\n\"Time Limit Exceeded\" \\nHow this can be fixed?"
                    },
                    {
                        "username": "christianc750",
                        "content": "This fails due to time limits but I\\'m curious if my approach is correct\\n\\n `var longestPalindrome = function(s) {\\n let maxlengthpalindrome = { length: 0, output: \\'\\'};\\n const answer = maxlengthpalindromeInnerScope(s,maxlengthpalindrome);\\n console.log (maxlengthpalindrome);\\n return maxlengthpalindrome.output;\\n\\n};\\n\\nfunction maxlengthpalindromeInnerScope(s,memo) {\\n\\n if (s.length === 0) return \\'\\';\\n if (s.length === 1) {\\n    memo.length = 1;\\n    memo.output = s;\\n    return s;\\n }\\n if (s.length <= memo.length) return memo.output;\\n \\n const pal_length = returnPalindrome(s).length;\\n\\n if (pal_length > 1) {\\n    memo.length = pal_length;\\n    memo.output = s;\\n    return s; \\n }\\n\\n const leftSubStringLP = maxlengthpalindromeInnerScope(s.substring(0,s.length-1), memo);\\n const rightSubStringLP = maxlengthpalindromeInnerScope(s.substring(1,s.length), memo); \\n}`"
                    },
                    {
                        "username": "Yongbi",
                        "content": "No need check all of string, check up to s.length-1- last_found_maxlength."
                    },
                    {
                        "username": "sjorsp",
                        "content": "Funny, I already solved this one by my self, but I thought, would ChatGPT handle this?\\nFirst attempt and it worked without any alterations......"
                    },
                    {
                        "username": "xgz2",
                        "content": "Is it feasible to use a set to maintain the formerly confirmed palindromes rather than the matrix representation described in the solutions? I don\\'t seem to be able to get this to work and am instead getting time limit exceeded for many cases."
                    },
                    {
                        "username": "Maheshzzz",
                        "content": "even though my solution passes 141/141 test cases why it is showing time limit exceeded"
                    },
                    {
                        "username": "ndungu_dedan",
                        "content": "Isn`t the longest palindrome for this input \\n\\'babad\\' => baba"
                    },
                    {
                        "username": "DevPj09",
                        "content": "No. Palindrome are the numbers/words which have same looks even after reversed.\\neg: 151. Even if you reverse it still looks the same\\nbut for the input \\'baba\\' reverse is : \\'abab\\' which is not identical to the initial value."
                    },
                    {
                        "username": "dev3008",
                        "content": "class Solution:\\n    def longestPalindrome(self, s: str) -> str:\\n        for i in range(len(s),-1,-1):\\n            for j in range(0,(len(s)-i)+1):\\n                start=j\\n                end=j+i\\n                if(end<=len(s)):\\n                    temp_sub_string = s[j:end]\\n                    if temp_sub_string == temp_sub_string[::-1]:\\n                        return temp_sub_string\\n                        break\\n\\nI have written this solution based on DP But it is stuck in TLE Error...what can be done to improve this solution ?"
                    },
                    {
                        "username": "zfar-",
                        "content": "Hi , \ni don't understand how can be a palindrome of \"abb\" is \"bb\" ? \nas palindrome \"abb\" - \"bba\" -> resulting in only 'b' to be a palindrome.\n\n Can anyone explain ? "
                    },
                    {
                        "username": "DevPj09",
                        "content": "No. Palindrome are the numbers/words which have same looks even after reversed.\\neg: deed. Even if you reverse it still looks the same\\nbut for the input \\'abb\\' reverse is : \\'bba\\' which is not identical to the initial value.\\n\\nhowever, in case of \\'bb\\' even if you reverse it, it is the same. Hope it answers\\n"
                    },
                    {
                        "username": "johnson0127",
                        "content": "s =\\n\"aacabdkacaa\"\\n\\nwhy output is not \"aacabdkacaa\"\\nExpected  is \"aca\" ?\\n"
                    }
                ]
            },
            {
                "id": 1750988,
                "content": [
                    {
                        "username": "amart73",
                        "content": "mmm, isn\\'t \"aacabacaa\" a valid and longer palindrome in \"aacabdkacaa\" than \"aca\", why the wrong answer result?\\n\\nWrong Answer\\nInput\\ns =\\n\"aacabdkacaa\"\\n62 / 141 testcases passed\\nOutput\\n\"aacabacaa\"\\nExpected\\n\"aca\"\\n"
                    },
                    {
                        "username": "Bhawesh12",
                        "content": "Because \"aacabdkacaa\" has d and k in between string whereas your answer has \"aacabacaa\"  as a output. How come you skip the 2 letters in between. They will break the palindromic string and the output must be \"aca\""
                    },
                    {
                        "username": "asingh882",
                        "content": "/**\\n * @param {string} s\\n * @return {string}\\n */\\nvar longestPalindrome = function(s) {\\n    \\n    let longest = \"\";\\n    for(let i = 0; i < s.length; i++) {\\n        for(let j = i + 1; j <= s.length; j++) {\\n            let current = s.slice(i, j);\\n            if(isPalindrome(current) && current.length > longest.length) {\\n                    longest = current;\\n            }\\n        }\\n    }\\n    return longest;\\n};\\n\\nvar isPalindrome = function(s) {\\n    let reversed = s.split(\"\").reverse().join(\\'\\');\\n    return s === reversed;\\n}\\n\\n\"Time Limit Exceeded\" \\nHow this can be fixed?"
                    },
                    {
                        "username": "christianc750",
                        "content": "This fails due to time limits but I\\'m curious if my approach is correct\\n\\n `var longestPalindrome = function(s) {\\n let maxlengthpalindrome = { length: 0, output: \\'\\'};\\n const answer = maxlengthpalindromeInnerScope(s,maxlengthpalindrome);\\n console.log (maxlengthpalindrome);\\n return maxlengthpalindrome.output;\\n\\n};\\n\\nfunction maxlengthpalindromeInnerScope(s,memo) {\\n\\n if (s.length === 0) return \\'\\';\\n if (s.length === 1) {\\n    memo.length = 1;\\n    memo.output = s;\\n    return s;\\n }\\n if (s.length <= memo.length) return memo.output;\\n \\n const pal_length = returnPalindrome(s).length;\\n\\n if (pal_length > 1) {\\n    memo.length = pal_length;\\n    memo.output = s;\\n    return s; \\n }\\n\\n const leftSubStringLP = maxlengthpalindromeInnerScope(s.substring(0,s.length-1), memo);\\n const rightSubStringLP = maxlengthpalindromeInnerScope(s.substring(1,s.length), memo); \\n}`"
                    },
                    {
                        "username": "Yongbi",
                        "content": "No need check all of string, check up to s.length-1- last_found_maxlength."
                    },
                    {
                        "username": "sjorsp",
                        "content": "Funny, I already solved this one by my self, but I thought, would ChatGPT handle this?\\nFirst attempt and it worked without any alterations......"
                    },
                    {
                        "username": "xgz2",
                        "content": "Is it feasible to use a set to maintain the formerly confirmed palindromes rather than the matrix representation described in the solutions? I don\\'t seem to be able to get this to work and am instead getting time limit exceeded for many cases."
                    },
                    {
                        "username": "Maheshzzz",
                        "content": "even though my solution passes 141/141 test cases why it is showing time limit exceeded"
                    },
                    {
                        "username": "ndungu_dedan",
                        "content": "Isn`t the longest palindrome for this input \\n\\'babad\\' => baba"
                    },
                    {
                        "username": "DevPj09",
                        "content": "No. Palindrome are the numbers/words which have same looks even after reversed.\\neg: 151. Even if you reverse it still looks the same\\nbut for the input \\'baba\\' reverse is : \\'abab\\' which is not identical to the initial value."
                    },
                    {
                        "username": "dev3008",
                        "content": "class Solution:\\n    def longestPalindrome(self, s: str) -> str:\\n        for i in range(len(s),-1,-1):\\n            for j in range(0,(len(s)-i)+1):\\n                start=j\\n                end=j+i\\n                if(end<=len(s)):\\n                    temp_sub_string = s[j:end]\\n                    if temp_sub_string == temp_sub_string[::-1]:\\n                        return temp_sub_string\\n                        break\\n\\nI have written this solution based on DP But it is stuck in TLE Error...what can be done to improve this solution ?"
                    },
                    {
                        "username": "zfar-",
                        "content": "Hi , \ni don't understand how can be a palindrome of \"abb\" is \"bb\" ? \nas palindrome \"abb\" - \"bba\" -> resulting in only 'b' to be a palindrome.\n\n Can anyone explain ? "
                    },
                    {
                        "username": "DevPj09",
                        "content": "No. Palindrome are the numbers/words which have same looks even after reversed.\\neg: deed. Even if you reverse it still looks the same\\nbut for the input \\'abb\\' reverse is : \\'bba\\' which is not identical to the initial value.\\n\\nhowever, in case of \\'bb\\' even if you reverse it, it is the same. Hope it answers\\n"
                    },
                    {
                        "username": "johnson0127",
                        "content": "s =\\n\"aacabdkacaa\"\\n\\nwhy output is not \"aacabdkacaa\"\\nExpected  is \"aca\" ?\\n"
                    }
                ]
            },
            {
                "id": 1745230,
                "content": [
                    {
                        "username": "amart73",
                        "content": "mmm, isn\\'t \"aacabacaa\" a valid and longer palindrome in \"aacabdkacaa\" than \"aca\", why the wrong answer result?\\n\\nWrong Answer\\nInput\\ns =\\n\"aacabdkacaa\"\\n62 / 141 testcases passed\\nOutput\\n\"aacabacaa\"\\nExpected\\n\"aca\"\\n"
                    },
                    {
                        "username": "Bhawesh12",
                        "content": "Because \"aacabdkacaa\" has d and k in between string whereas your answer has \"aacabacaa\"  as a output. How come you skip the 2 letters in between. They will break the palindromic string and the output must be \"aca\""
                    },
                    {
                        "username": "asingh882",
                        "content": "/**\\n * @param {string} s\\n * @return {string}\\n */\\nvar longestPalindrome = function(s) {\\n    \\n    let longest = \"\";\\n    for(let i = 0; i < s.length; i++) {\\n        for(let j = i + 1; j <= s.length; j++) {\\n            let current = s.slice(i, j);\\n            if(isPalindrome(current) && current.length > longest.length) {\\n                    longest = current;\\n            }\\n        }\\n    }\\n    return longest;\\n};\\n\\nvar isPalindrome = function(s) {\\n    let reversed = s.split(\"\").reverse().join(\\'\\');\\n    return s === reversed;\\n}\\n\\n\"Time Limit Exceeded\" \\nHow this can be fixed?"
                    },
                    {
                        "username": "christianc750",
                        "content": "This fails due to time limits but I\\'m curious if my approach is correct\\n\\n `var longestPalindrome = function(s) {\\n let maxlengthpalindrome = { length: 0, output: \\'\\'};\\n const answer = maxlengthpalindromeInnerScope(s,maxlengthpalindrome);\\n console.log (maxlengthpalindrome);\\n return maxlengthpalindrome.output;\\n\\n};\\n\\nfunction maxlengthpalindromeInnerScope(s,memo) {\\n\\n if (s.length === 0) return \\'\\';\\n if (s.length === 1) {\\n    memo.length = 1;\\n    memo.output = s;\\n    return s;\\n }\\n if (s.length <= memo.length) return memo.output;\\n \\n const pal_length = returnPalindrome(s).length;\\n\\n if (pal_length > 1) {\\n    memo.length = pal_length;\\n    memo.output = s;\\n    return s; \\n }\\n\\n const leftSubStringLP = maxlengthpalindromeInnerScope(s.substring(0,s.length-1), memo);\\n const rightSubStringLP = maxlengthpalindromeInnerScope(s.substring(1,s.length), memo); \\n}`"
                    },
                    {
                        "username": "Yongbi",
                        "content": "No need check all of string, check up to s.length-1- last_found_maxlength."
                    },
                    {
                        "username": "sjorsp",
                        "content": "Funny, I already solved this one by my self, but I thought, would ChatGPT handle this?\\nFirst attempt and it worked without any alterations......"
                    },
                    {
                        "username": "xgz2",
                        "content": "Is it feasible to use a set to maintain the formerly confirmed palindromes rather than the matrix representation described in the solutions? I don\\'t seem to be able to get this to work and am instead getting time limit exceeded for many cases."
                    },
                    {
                        "username": "Maheshzzz",
                        "content": "even though my solution passes 141/141 test cases why it is showing time limit exceeded"
                    },
                    {
                        "username": "ndungu_dedan",
                        "content": "Isn`t the longest palindrome for this input \\n\\'babad\\' => baba"
                    },
                    {
                        "username": "DevPj09",
                        "content": "No. Palindrome are the numbers/words which have same looks even after reversed.\\neg: 151. Even if you reverse it still looks the same\\nbut for the input \\'baba\\' reverse is : \\'abab\\' which is not identical to the initial value."
                    },
                    {
                        "username": "dev3008",
                        "content": "class Solution:\\n    def longestPalindrome(self, s: str) -> str:\\n        for i in range(len(s),-1,-1):\\n            for j in range(0,(len(s)-i)+1):\\n                start=j\\n                end=j+i\\n                if(end<=len(s)):\\n                    temp_sub_string = s[j:end]\\n                    if temp_sub_string == temp_sub_string[::-1]:\\n                        return temp_sub_string\\n                        break\\n\\nI have written this solution based on DP But it is stuck in TLE Error...what can be done to improve this solution ?"
                    },
                    {
                        "username": "zfar-",
                        "content": "Hi , \ni don't understand how can be a palindrome of \"abb\" is \"bb\" ? \nas palindrome \"abb\" - \"bba\" -> resulting in only 'b' to be a palindrome.\n\n Can anyone explain ? "
                    },
                    {
                        "username": "DevPj09",
                        "content": "No. Palindrome are the numbers/words which have same looks even after reversed.\\neg: deed. Even if you reverse it still looks the same\\nbut for the input \\'abb\\' reverse is : \\'bba\\' which is not identical to the initial value.\\n\\nhowever, in case of \\'bb\\' even if you reverse it, it is the same. Hope it answers\\n"
                    },
                    {
                        "username": "johnson0127",
                        "content": "s =\\n\"aacabdkacaa\"\\n\\nwhy output is not \"aacabdkacaa\"\\nExpected  is \"aca\" ?\\n"
                    }
                ]
            },
            {
                "id": 1741850,
                "content": [
                    {
                        "username": "amart73",
                        "content": "mmm, isn\\'t \"aacabacaa\" a valid and longer palindrome in \"aacabdkacaa\" than \"aca\", why the wrong answer result?\\n\\nWrong Answer\\nInput\\ns =\\n\"aacabdkacaa\"\\n62 / 141 testcases passed\\nOutput\\n\"aacabacaa\"\\nExpected\\n\"aca\"\\n"
                    },
                    {
                        "username": "Bhawesh12",
                        "content": "Because \"aacabdkacaa\" has d and k in between string whereas your answer has \"aacabacaa\"  as a output. How come you skip the 2 letters in between. They will break the palindromic string and the output must be \"aca\""
                    },
                    {
                        "username": "asingh882",
                        "content": "/**\\n * @param {string} s\\n * @return {string}\\n */\\nvar longestPalindrome = function(s) {\\n    \\n    let longest = \"\";\\n    for(let i = 0; i < s.length; i++) {\\n        for(let j = i + 1; j <= s.length; j++) {\\n            let current = s.slice(i, j);\\n            if(isPalindrome(current) && current.length > longest.length) {\\n                    longest = current;\\n            }\\n        }\\n    }\\n    return longest;\\n};\\n\\nvar isPalindrome = function(s) {\\n    let reversed = s.split(\"\").reverse().join(\\'\\');\\n    return s === reversed;\\n}\\n\\n\"Time Limit Exceeded\" \\nHow this can be fixed?"
                    },
                    {
                        "username": "christianc750",
                        "content": "This fails due to time limits but I\\'m curious if my approach is correct\\n\\n `var longestPalindrome = function(s) {\\n let maxlengthpalindrome = { length: 0, output: \\'\\'};\\n const answer = maxlengthpalindromeInnerScope(s,maxlengthpalindrome);\\n console.log (maxlengthpalindrome);\\n return maxlengthpalindrome.output;\\n\\n};\\n\\nfunction maxlengthpalindromeInnerScope(s,memo) {\\n\\n if (s.length === 0) return \\'\\';\\n if (s.length === 1) {\\n    memo.length = 1;\\n    memo.output = s;\\n    return s;\\n }\\n if (s.length <= memo.length) return memo.output;\\n \\n const pal_length = returnPalindrome(s).length;\\n\\n if (pal_length > 1) {\\n    memo.length = pal_length;\\n    memo.output = s;\\n    return s; \\n }\\n\\n const leftSubStringLP = maxlengthpalindromeInnerScope(s.substring(0,s.length-1), memo);\\n const rightSubStringLP = maxlengthpalindromeInnerScope(s.substring(1,s.length), memo); \\n}`"
                    },
                    {
                        "username": "Yongbi",
                        "content": "No need check all of string, check up to s.length-1- last_found_maxlength."
                    },
                    {
                        "username": "sjorsp",
                        "content": "Funny, I already solved this one by my self, but I thought, would ChatGPT handle this?\\nFirst attempt and it worked without any alterations......"
                    },
                    {
                        "username": "xgz2",
                        "content": "Is it feasible to use a set to maintain the formerly confirmed palindromes rather than the matrix representation described in the solutions? I don\\'t seem to be able to get this to work and am instead getting time limit exceeded for many cases."
                    },
                    {
                        "username": "Maheshzzz",
                        "content": "even though my solution passes 141/141 test cases why it is showing time limit exceeded"
                    },
                    {
                        "username": "ndungu_dedan",
                        "content": "Isn`t the longest palindrome for this input \\n\\'babad\\' => baba"
                    },
                    {
                        "username": "DevPj09",
                        "content": "No. Palindrome are the numbers/words which have same looks even after reversed.\\neg: 151. Even if you reverse it still looks the same\\nbut for the input \\'baba\\' reverse is : \\'abab\\' which is not identical to the initial value."
                    },
                    {
                        "username": "dev3008",
                        "content": "class Solution:\\n    def longestPalindrome(self, s: str) -> str:\\n        for i in range(len(s),-1,-1):\\n            for j in range(0,(len(s)-i)+1):\\n                start=j\\n                end=j+i\\n                if(end<=len(s)):\\n                    temp_sub_string = s[j:end]\\n                    if temp_sub_string == temp_sub_string[::-1]:\\n                        return temp_sub_string\\n                        break\\n\\nI have written this solution based on DP But it is stuck in TLE Error...what can be done to improve this solution ?"
                    },
                    {
                        "username": "zfar-",
                        "content": "Hi , \ni don't understand how can be a palindrome of \"abb\" is \"bb\" ? \nas palindrome \"abb\" - \"bba\" -> resulting in only 'b' to be a palindrome.\n\n Can anyone explain ? "
                    },
                    {
                        "username": "DevPj09",
                        "content": "No. Palindrome are the numbers/words which have same looks even after reversed.\\neg: deed. Even if you reverse it still looks the same\\nbut for the input \\'abb\\' reverse is : \\'bba\\' which is not identical to the initial value.\\n\\nhowever, in case of \\'bb\\' even if you reverse it, it is the same. Hope it answers\\n"
                    },
                    {
                        "username": "johnson0127",
                        "content": "s =\\n\"aacabdkacaa\"\\n\\nwhy output is not \"aacabdkacaa\"\\nExpected  is \"aca\" ?\\n"
                    }
                ]
            },
            {
                "id": 1737303,
                "content": [
                    {
                        "username": "amart73",
                        "content": "mmm, isn\\'t \"aacabacaa\" a valid and longer palindrome in \"aacabdkacaa\" than \"aca\", why the wrong answer result?\\n\\nWrong Answer\\nInput\\ns =\\n\"aacabdkacaa\"\\n62 / 141 testcases passed\\nOutput\\n\"aacabacaa\"\\nExpected\\n\"aca\"\\n"
                    },
                    {
                        "username": "Bhawesh12",
                        "content": "Because \"aacabdkacaa\" has d and k in between string whereas your answer has \"aacabacaa\"  as a output. How come you skip the 2 letters in between. They will break the palindromic string and the output must be \"aca\""
                    },
                    {
                        "username": "asingh882",
                        "content": "/**\\n * @param {string} s\\n * @return {string}\\n */\\nvar longestPalindrome = function(s) {\\n    \\n    let longest = \"\";\\n    for(let i = 0; i < s.length; i++) {\\n        for(let j = i + 1; j <= s.length; j++) {\\n            let current = s.slice(i, j);\\n            if(isPalindrome(current) && current.length > longest.length) {\\n                    longest = current;\\n            }\\n        }\\n    }\\n    return longest;\\n};\\n\\nvar isPalindrome = function(s) {\\n    let reversed = s.split(\"\").reverse().join(\\'\\');\\n    return s === reversed;\\n}\\n\\n\"Time Limit Exceeded\" \\nHow this can be fixed?"
                    },
                    {
                        "username": "christianc750",
                        "content": "This fails due to time limits but I\\'m curious if my approach is correct\\n\\n `var longestPalindrome = function(s) {\\n let maxlengthpalindrome = { length: 0, output: \\'\\'};\\n const answer = maxlengthpalindromeInnerScope(s,maxlengthpalindrome);\\n console.log (maxlengthpalindrome);\\n return maxlengthpalindrome.output;\\n\\n};\\n\\nfunction maxlengthpalindromeInnerScope(s,memo) {\\n\\n if (s.length === 0) return \\'\\';\\n if (s.length === 1) {\\n    memo.length = 1;\\n    memo.output = s;\\n    return s;\\n }\\n if (s.length <= memo.length) return memo.output;\\n \\n const pal_length = returnPalindrome(s).length;\\n\\n if (pal_length > 1) {\\n    memo.length = pal_length;\\n    memo.output = s;\\n    return s; \\n }\\n\\n const leftSubStringLP = maxlengthpalindromeInnerScope(s.substring(0,s.length-1), memo);\\n const rightSubStringLP = maxlengthpalindromeInnerScope(s.substring(1,s.length), memo); \\n}`"
                    },
                    {
                        "username": "Yongbi",
                        "content": "No need check all of string, check up to s.length-1- last_found_maxlength."
                    },
                    {
                        "username": "sjorsp",
                        "content": "Funny, I already solved this one by my self, but I thought, would ChatGPT handle this?\\nFirst attempt and it worked without any alterations......"
                    },
                    {
                        "username": "xgz2",
                        "content": "Is it feasible to use a set to maintain the formerly confirmed palindromes rather than the matrix representation described in the solutions? I don\\'t seem to be able to get this to work and am instead getting time limit exceeded for many cases."
                    },
                    {
                        "username": "Maheshzzz",
                        "content": "even though my solution passes 141/141 test cases why it is showing time limit exceeded"
                    },
                    {
                        "username": "ndungu_dedan",
                        "content": "Isn`t the longest palindrome for this input \\n\\'babad\\' => baba"
                    },
                    {
                        "username": "DevPj09",
                        "content": "No. Palindrome are the numbers/words which have same looks even after reversed.\\neg: 151. Even if you reverse it still looks the same\\nbut for the input \\'baba\\' reverse is : \\'abab\\' which is not identical to the initial value."
                    },
                    {
                        "username": "dev3008",
                        "content": "class Solution:\\n    def longestPalindrome(self, s: str) -> str:\\n        for i in range(len(s),-1,-1):\\n            for j in range(0,(len(s)-i)+1):\\n                start=j\\n                end=j+i\\n                if(end<=len(s)):\\n                    temp_sub_string = s[j:end]\\n                    if temp_sub_string == temp_sub_string[::-1]:\\n                        return temp_sub_string\\n                        break\\n\\nI have written this solution based on DP But it is stuck in TLE Error...what can be done to improve this solution ?"
                    },
                    {
                        "username": "zfar-",
                        "content": "Hi , \ni don't understand how can be a palindrome of \"abb\" is \"bb\" ? \nas palindrome \"abb\" - \"bba\" -> resulting in only 'b' to be a palindrome.\n\n Can anyone explain ? "
                    },
                    {
                        "username": "DevPj09",
                        "content": "No. Palindrome are the numbers/words which have same looks even after reversed.\\neg: deed. Even if you reverse it still looks the same\\nbut for the input \\'abb\\' reverse is : \\'bba\\' which is not identical to the initial value.\\n\\nhowever, in case of \\'bb\\' even if you reverse it, it is the same. Hope it answers\\n"
                    },
                    {
                        "username": "johnson0127",
                        "content": "s =\\n\"aacabdkacaa\"\\n\\nwhy output is not \"aacabdkacaa\"\\nExpected  is \"aca\" ?\\n"
                    }
                ]
            },
            {
                "id": 1736245,
                "content": [
                    {
                        "username": "amart73",
                        "content": "mmm, isn\\'t \"aacabacaa\" a valid and longer palindrome in \"aacabdkacaa\" than \"aca\", why the wrong answer result?\\n\\nWrong Answer\\nInput\\ns =\\n\"aacabdkacaa\"\\n62 / 141 testcases passed\\nOutput\\n\"aacabacaa\"\\nExpected\\n\"aca\"\\n"
                    },
                    {
                        "username": "Bhawesh12",
                        "content": "Because \"aacabdkacaa\" has d and k in between string whereas your answer has \"aacabacaa\"  as a output. How come you skip the 2 letters in between. They will break the palindromic string and the output must be \"aca\""
                    },
                    {
                        "username": "asingh882",
                        "content": "/**\\n * @param {string} s\\n * @return {string}\\n */\\nvar longestPalindrome = function(s) {\\n    \\n    let longest = \"\";\\n    for(let i = 0; i < s.length; i++) {\\n        for(let j = i + 1; j <= s.length; j++) {\\n            let current = s.slice(i, j);\\n            if(isPalindrome(current) && current.length > longest.length) {\\n                    longest = current;\\n            }\\n        }\\n    }\\n    return longest;\\n};\\n\\nvar isPalindrome = function(s) {\\n    let reversed = s.split(\"\").reverse().join(\\'\\');\\n    return s === reversed;\\n}\\n\\n\"Time Limit Exceeded\" \\nHow this can be fixed?"
                    },
                    {
                        "username": "christianc750",
                        "content": "This fails due to time limits but I\\'m curious if my approach is correct\\n\\n `var longestPalindrome = function(s) {\\n let maxlengthpalindrome = { length: 0, output: \\'\\'};\\n const answer = maxlengthpalindromeInnerScope(s,maxlengthpalindrome);\\n console.log (maxlengthpalindrome);\\n return maxlengthpalindrome.output;\\n\\n};\\n\\nfunction maxlengthpalindromeInnerScope(s,memo) {\\n\\n if (s.length === 0) return \\'\\';\\n if (s.length === 1) {\\n    memo.length = 1;\\n    memo.output = s;\\n    return s;\\n }\\n if (s.length <= memo.length) return memo.output;\\n \\n const pal_length = returnPalindrome(s).length;\\n\\n if (pal_length > 1) {\\n    memo.length = pal_length;\\n    memo.output = s;\\n    return s; \\n }\\n\\n const leftSubStringLP = maxlengthpalindromeInnerScope(s.substring(0,s.length-1), memo);\\n const rightSubStringLP = maxlengthpalindromeInnerScope(s.substring(1,s.length), memo); \\n}`"
                    },
                    {
                        "username": "Yongbi",
                        "content": "No need check all of string, check up to s.length-1- last_found_maxlength."
                    },
                    {
                        "username": "sjorsp",
                        "content": "Funny, I already solved this one by my self, but I thought, would ChatGPT handle this?\\nFirst attempt and it worked without any alterations......"
                    },
                    {
                        "username": "xgz2",
                        "content": "Is it feasible to use a set to maintain the formerly confirmed palindromes rather than the matrix representation described in the solutions? I don\\'t seem to be able to get this to work and am instead getting time limit exceeded for many cases."
                    },
                    {
                        "username": "Maheshzzz",
                        "content": "even though my solution passes 141/141 test cases why it is showing time limit exceeded"
                    },
                    {
                        "username": "ndungu_dedan",
                        "content": "Isn`t the longest palindrome for this input \\n\\'babad\\' => baba"
                    },
                    {
                        "username": "DevPj09",
                        "content": "No. Palindrome are the numbers/words which have same looks even after reversed.\\neg: 151. Even if you reverse it still looks the same\\nbut for the input \\'baba\\' reverse is : \\'abab\\' which is not identical to the initial value."
                    },
                    {
                        "username": "dev3008",
                        "content": "class Solution:\\n    def longestPalindrome(self, s: str) -> str:\\n        for i in range(len(s),-1,-1):\\n            for j in range(0,(len(s)-i)+1):\\n                start=j\\n                end=j+i\\n                if(end<=len(s)):\\n                    temp_sub_string = s[j:end]\\n                    if temp_sub_string == temp_sub_string[::-1]:\\n                        return temp_sub_string\\n                        break\\n\\nI have written this solution based on DP But it is stuck in TLE Error...what can be done to improve this solution ?"
                    },
                    {
                        "username": "zfar-",
                        "content": "Hi , \ni don't understand how can be a palindrome of \"abb\" is \"bb\" ? \nas palindrome \"abb\" - \"bba\" -> resulting in only 'b' to be a palindrome.\n\n Can anyone explain ? "
                    },
                    {
                        "username": "DevPj09",
                        "content": "No. Palindrome are the numbers/words which have same looks even after reversed.\\neg: deed. Even if you reverse it still looks the same\\nbut for the input \\'abb\\' reverse is : \\'bba\\' which is not identical to the initial value.\\n\\nhowever, in case of \\'bb\\' even if you reverse it, it is the same. Hope it answers\\n"
                    },
                    {
                        "username": "johnson0127",
                        "content": "s =\\n\"aacabdkacaa\"\\n\\nwhy output is not \"aacabdkacaa\"\\nExpected  is \"aca\" ?\\n"
                    }
                ]
            },
            {
                "id": 1735713,
                "content": [
                    {
                        "username": "Vinit_Anishkumar_Masrani",
                        "content": "When I submit, I get TLE error for the following test case:\nTime Limit Exceeded\nAnd it shows 141/141 testcases passed\nLast executed Input:\n s =\n\n\nWhat is the expected output for this testcase? And why is my code though passing big strings in testcase fails because of TLE in empty one."
                    },
                    {
                        "username": "DevPj09",
                        "content": "This is a bug. Happened with me too. I changed the browser and it worked. Might be due to network or cache.\\n"
                    },
                    {
                        "username": "TheCScience",
                        "content": "Here is problem solution in Java, Python, C++ and C programming.\\n[https://thecscience.com/leetcode-longest-palindromic-substring-problem-solution.html](https://thecscience.com/leetcode-longest-palindromic-substring-problem-solution.html)"
                    },
                    {
                        "username": "Shekhar_k_s",
                        "content": "My Solution was of O(n2) and final result is Time Limit Exceeded ( TLE ) . LOL \\uD83D\\uDE12\\n `void check(vector<vector<bool>> &v, int start, int end, string s, int &indexStart, int &indexEnd)\\n{\\n    if(s[start]==s[end])\\n    {\\n        if(v[start+1][end-1]==true)\\n        {\\n            v[start][end]=true;\\n            // cout<<start<<\" \"<<end<<endl;\\n            indexStart=start;\\n            indexEnd=end;\\n        }else\\n        {\\n            v[start][end]=false;\\n        }\\n    }\\n    else\\n    v[start][end]=false;\\n}\\n\\n\\n\\nclass Solution {\\npublic:\\n    string longestPalindrome(string s) {\\n        int len=s.length();\\n        int indexStart=0;\\n        int indexEnd=0;\\n        vector<vector<bool>> arr;\\n        for(int i=0;i<len;i++)\\n        {\\n            vector<bool> v(len);\\n            v[i]=true;\\n            arr.push_back(v);\\n        }\\n        for(int i=1;i<len;i++)\\n        {\\n            if(s[i-1]==s[i]){\\n                arr[i-1][i]=true;\\n                indexStart=i-1;\\n                indexEnd=i;\\n            }\\n            else\\n            arr[i-1][i]=false;\\n        }\\n        // cout<<indexStart<<\" \"<<indexEnd<<endl;\\n        int start=0;\\n        int end=2;\\n        while(end-start<=len)\\n        {\\n            while(end<len)\\n            {\\n                check(arr, start, end, s, indexStart, indexEnd);\\n                start++;\\n                end++;\\n            }\\n            int temp=end-start;\\n            temp++;\\n            start=0;\\n            end=temp;\\n        }\\n        string ans;\\n        for(int i=indexStart;i<=indexEnd;i++)\\n        {\\n            ans+=s[i];\\n        }\\n        // cout<<indexStart<<\" \"<<indexEnd<<endl;\\n        return ans;\\n    }\\n};`"
                    },
                    {
                        "username": "joshi248",
                        "content": "What is wrong here please tell\\n ```\\nclass Solution {\\npublic:\\n    bool isPalindrome(string strs){\\n        int n = strs.length();\\n        for(int i=0;i<n/2;++i){\\n            if(strs[i]!=strs[n-i-1]) return false;\\n        }\\n        return true;\\n    }\\n    string check(vector<string> &temp){\\n        string sruti = \"\";\\n        for(auto strs:temp){\\n            if(isPalindrome(strs)){\\n              if(strs.length() > sruti.length()) sruti = strs;\\n            }\\n        }\\n        return sruti;\\n    }\\n    string longestPalindrome(string s) {\\n        \\n        vector<string> temp;\\n        int n = s.length();\\n        if(n==1){\\n            if(isPalindrome(s)){\\n                return s;\\n            }\\n            return \"\";\\n        }\\n        for(int i=0;i<n;++i){\\n            for(int j=1;j<=n-i;++j){\\n                temp.push_back(s.substr(i,j));\\n            }\\n        }\\n        string ans = check(temp);\\n        return ans;\\n\\n\\n    }\\n};\\n```"
                    },
                    {
                        "username": "ayushi_828",
                        "content": "class Solution {\\n   int resultStart;\\n    int resultLength;\\n\\n    public String longestPalindrome(String s) {\\n        int strLength = s.length();\\n        if (strLength < 2) {\\n            return s;\\n        }\\n        for (int start = 0; start < strLength - 1; start++) {\\n            expandRange(s, start, start);\\n            expandRange(s, start, start + 1);\\n        }\\n        return s.substring(resultStart, resultStart + resultLength);\\n    }\\n\\n    private void expandRange(String str, int begin, int end) {\\n       while (begin >= 0 && end < str.length() &&\\n                    str.charAt(begin) == str.charAt(end)) {\\n            begin--;\\n            end++;\\n        }\\n       if (resultLength < end - begin - 1) {\\n            resultStart = begin + 1;\\n            resultLength = end - begin - 1;\\n        }\\n    }\\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "sukriti_sinha7",
                        "content": "class Solution {\\npublic:\\n    string longestPalindrome(string s) {\\n        string ans = \"\";\\n        for(int i = 0; i < s.length() ; i ++){\\n            string s1 = extend(s,i,i), s2 = extend(s, i, i+1);\\n\\n            if(s1.length() > ans.length()) ans = s1;\\n            if(s2.length() > ans.length()) ans = s2;\\n        }\\n\\n        return ans;\\n    }\\n\\n    string extend(string s, int left, int right){\\n        while(left >= 0 && right < s.length() && s[left] == s[right]){\\n            left--;\\n            right++;\\n        }\\n        return s.substr(left+1, right - left - 1);\\n    }\\n};"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "utkarshv2619",
                        "content": "//easy solution:\\n\\nclass Solution {\\npublic:\\n    string longestPalindrome(string s) {\\n        string res;\\n        int reslen = 0;\\n        \\n        if(s.size()<=1)\\n            return s; \\n        \\n        for(int i=0;i<s.size()-1;i++)\\n        {\\n            //odd length\\n            int l=i;\\n            int r=i;\\n            while(l>=0 && r<s.size() && s[l]==s[r])\\n            {\\n                if(r-l+1 > reslen  )\\n                {\\n                    res = s.substr(l, r-l+1);\\n                    reslen = r-l+1;\\n                }\\n                l--;\\n                r++;\\n            }\\n            //even length\\n            int L=i;\\n            int R=i+1;\\n            while(L>=0 && R<s.size() && s[L]==s[R])\\n            {\\n                if(R-L+1 > reslen)\\n                {\\n                    res = s.substr(L,R-L+1);\\n                    reslen = R-L+1;\\n                }\\n                L--;\\n                R++;\\n            }\\n        }\\n        return res;\\n    }\\n    \\n};"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "//Easy rules.\n\n💡 Discussion Rules\n1. Please don't post any solutions in this discussion.\n\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\n\n3. If you'd like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "codecat____",
                        "content": "I have \"Time Limit Exceeded\" problem here \nhow can i reduce running time in my code ?\n\ncode is given :\n\n\n\n\n\nclass Solution:\n    def longestPalindrome(self, s: str) -> str:\n        y=[]\n        x=[]\n        for i in range(len(s)):\n            for j in range(i+1,len(s)+1):\n                y.append(s[i:j])\n        for k in y:\n            if k == k[::-1]:\n                x.append(k)\n        w=[]\n        for v in x:\n            w.append(len(v))\n        if len(s)==1:\n            return s\n        for q in x:\n            if len(q)==max(w):\n                return(q)\n  "
                    },
                    {
                        "username": "noob-pika",
                        "content": "Check out the last two solutions in the solutions section of this question. The last one has a time complexity of O(n) but may take a while to understand whereas the second last one has a time complexity of O(n^2) but fairly easy"
                    },
                    {
                        "username": "Yongbi",
                        "content": "[@codecat____](/codecat____) Just use 2 pointer and reverse string that\\'s enough. I see that you have 5 loop in your algorithm!! It\\'s kind of too much, right?"
                    },
                    {
                        "username": "itanki3085",
                        "content": "Different result between LeetCode and my computer.\\nI got the result : `load of value 15, which is not a valid value for type \\'bool\\'`, but my code at that line is\\n```cpp\\ndp[from][to] = dp[from+1][to-1] && (s[from]==s[to]);\\n```\\nHow was that possible when I assign a boolean value into a address stores boolean value still get an error?\\nAt least it is not related to compiler. But what is the problem related to?"
                    },
                    {
                        "username": "Khudoyshukur",
                        "content": "Are we allowed to use class only? When I am writing without classes it is giving error: use of undeclared identifier \\'solution\\'. What should i do?"
                    }
                ]
            },
            {
                "id": 1735647,
                "content": [
                    {
                        "username": "Vinit_Anishkumar_Masrani",
                        "content": "When I submit, I get TLE error for the following test case:\nTime Limit Exceeded\nAnd it shows 141/141 testcases passed\nLast executed Input:\n s =\n\n\nWhat is the expected output for this testcase? And why is my code though passing big strings in testcase fails because of TLE in empty one."
                    },
                    {
                        "username": "DevPj09",
                        "content": "This is a bug. Happened with me too. I changed the browser and it worked. Might be due to network or cache.\\n"
                    },
                    {
                        "username": "TheCScience",
                        "content": "Here is problem solution in Java, Python, C++ and C programming.\\n[https://thecscience.com/leetcode-longest-palindromic-substring-problem-solution.html](https://thecscience.com/leetcode-longest-palindromic-substring-problem-solution.html)"
                    },
                    {
                        "username": "Shekhar_k_s",
                        "content": "My Solution was of O(n2) and final result is Time Limit Exceeded ( TLE ) . LOL \\uD83D\\uDE12\\n `void check(vector<vector<bool>> &v, int start, int end, string s, int &indexStart, int &indexEnd)\\n{\\n    if(s[start]==s[end])\\n    {\\n        if(v[start+1][end-1]==true)\\n        {\\n            v[start][end]=true;\\n            // cout<<start<<\" \"<<end<<endl;\\n            indexStart=start;\\n            indexEnd=end;\\n        }else\\n        {\\n            v[start][end]=false;\\n        }\\n    }\\n    else\\n    v[start][end]=false;\\n}\\n\\n\\n\\nclass Solution {\\npublic:\\n    string longestPalindrome(string s) {\\n        int len=s.length();\\n        int indexStart=0;\\n        int indexEnd=0;\\n        vector<vector<bool>> arr;\\n        for(int i=0;i<len;i++)\\n        {\\n            vector<bool> v(len);\\n            v[i]=true;\\n            arr.push_back(v);\\n        }\\n        for(int i=1;i<len;i++)\\n        {\\n            if(s[i-1]==s[i]){\\n                arr[i-1][i]=true;\\n                indexStart=i-1;\\n                indexEnd=i;\\n            }\\n            else\\n            arr[i-1][i]=false;\\n        }\\n        // cout<<indexStart<<\" \"<<indexEnd<<endl;\\n        int start=0;\\n        int end=2;\\n        while(end-start<=len)\\n        {\\n            while(end<len)\\n            {\\n                check(arr, start, end, s, indexStart, indexEnd);\\n                start++;\\n                end++;\\n            }\\n            int temp=end-start;\\n            temp++;\\n            start=0;\\n            end=temp;\\n        }\\n        string ans;\\n        for(int i=indexStart;i<=indexEnd;i++)\\n        {\\n            ans+=s[i];\\n        }\\n        // cout<<indexStart<<\" \"<<indexEnd<<endl;\\n        return ans;\\n    }\\n};`"
                    },
                    {
                        "username": "joshi248",
                        "content": "What is wrong here please tell\\n ```\\nclass Solution {\\npublic:\\n    bool isPalindrome(string strs){\\n        int n = strs.length();\\n        for(int i=0;i<n/2;++i){\\n            if(strs[i]!=strs[n-i-1]) return false;\\n        }\\n        return true;\\n    }\\n    string check(vector<string> &temp){\\n        string sruti = \"\";\\n        for(auto strs:temp){\\n            if(isPalindrome(strs)){\\n              if(strs.length() > sruti.length()) sruti = strs;\\n            }\\n        }\\n        return sruti;\\n    }\\n    string longestPalindrome(string s) {\\n        \\n        vector<string> temp;\\n        int n = s.length();\\n        if(n==1){\\n            if(isPalindrome(s)){\\n                return s;\\n            }\\n            return \"\";\\n        }\\n        for(int i=0;i<n;++i){\\n            for(int j=1;j<=n-i;++j){\\n                temp.push_back(s.substr(i,j));\\n            }\\n        }\\n        string ans = check(temp);\\n        return ans;\\n\\n\\n    }\\n};\\n```"
                    },
                    {
                        "username": "ayushi_828",
                        "content": "class Solution {\\n   int resultStart;\\n    int resultLength;\\n\\n    public String longestPalindrome(String s) {\\n        int strLength = s.length();\\n        if (strLength < 2) {\\n            return s;\\n        }\\n        for (int start = 0; start < strLength - 1; start++) {\\n            expandRange(s, start, start);\\n            expandRange(s, start, start + 1);\\n        }\\n        return s.substring(resultStart, resultStart + resultLength);\\n    }\\n\\n    private void expandRange(String str, int begin, int end) {\\n       while (begin >= 0 && end < str.length() &&\\n                    str.charAt(begin) == str.charAt(end)) {\\n            begin--;\\n            end++;\\n        }\\n       if (resultLength < end - begin - 1) {\\n            resultStart = begin + 1;\\n            resultLength = end - begin - 1;\\n        }\\n    }\\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "sukriti_sinha7",
                        "content": "class Solution {\\npublic:\\n    string longestPalindrome(string s) {\\n        string ans = \"\";\\n        for(int i = 0; i < s.length() ; i ++){\\n            string s1 = extend(s,i,i), s2 = extend(s, i, i+1);\\n\\n            if(s1.length() > ans.length()) ans = s1;\\n            if(s2.length() > ans.length()) ans = s2;\\n        }\\n\\n        return ans;\\n    }\\n\\n    string extend(string s, int left, int right){\\n        while(left >= 0 && right < s.length() && s[left] == s[right]){\\n            left--;\\n            right++;\\n        }\\n        return s.substr(left+1, right - left - 1);\\n    }\\n};"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "utkarshv2619",
                        "content": "//easy solution:\\n\\nclass Solution {\\npublic:\\n    string longestPalindrome(string s) {\\n        string res;\\n        int reslen = 0;\\n        \\n        if(s.size()<=1)\\n            return s; \\n        \\n        for(int i=0;i<s.size()-1;i++)\\n        {\\n            //odd length\\n            int l=i;\\n            int r=i;\\n            while(l>=0 && r<s.size() && s[l]==s[r])\\n            {\\n                if(r-l+1 > reslen  )\\n                {\\n                    res = s.substr(l, r-l+1);\\n                    reslen = r-l+1;\\n                }\\n                l--;\\n                r++;\\n            }\\n            //even length\\n            int L=i;\\n            int R=i+1;\\n            while(L>=0 && R<s.size() && s[L]==s[R])\\n            {\\n                if(R-L+1 > reslen)\\n                {\\n                    res = s.substr(L,R-L+1);\\n                    reslen = R-L+1;\\n                }\\n                L--;\\n                R++;\\n            }\\n        }\\n        return res;\\n    }\\n    \\n};"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "//Easy rules.\n\n💡 Discussion Rules\n1. Please don't post any solutions in this discussion.\n\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\n\n3. If you'd like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "codecat____",
                        "content": "I have \"Time Limit Exceeded\" problem here \nhow can i reduce running time in my code ?\n\ncode is given :\n\n\n\n\n\nclass Solution:\n    def longestPalindrome(self, s: str) -> str:\n        y=[]\n        x=[]\n        for i in range(len(s)):\n            for j in range(i+1,len(s)+1):\n                y.append(s[i:j])\n        for k in y:\n            if k == k[::-1]:\n                x.append(k)\n        w=[]\n        for v in x:\n            w.append(len(v))\n        if len(s)==1:\n            return s\n        for q in x:\n            if len(q)==max(w):\n                return(q)\n  "
                    },
                    {
                        "username": "noob-pika",
                        "content": "Check out the last two solutions in the solutions section of this question. The last one has a time complexity of O(n) but may take a while to understand whereas the second last one has a time complexity of O(n^2) but fairly easy"
                    },
                    {
                        "username": "Yongbi",
                        "content": "[@codecat____](/codecat____) Just use 2 pointer and reverse string that\\'s enough. I see that you have 5 loop in your algorithm!! It\\'s kind of too much, right?"
                    },
                    {
                        "username": "itanki3085",
                        "content": "Different result between LeetCode and my computer.\\nI got the result : `load of value 15, which is not a valid value for type \\'bool\\'`, but my code at that line is\\n```cpp\\ndp[from][to] = dp[from+1][to-1] && (s[from]==s[to]);\\n```\\nHow was that possible when I assign a boolean value into a address stores boolean value still get an error?\\nAt least it is not related to compiler. But what is the problem related to?"
                    },
                    {
                        "username": "Khudoyshukur",
                        "content": "Are we allowed to use class only? When I am writing without classes it is giving error: use of undeclared identifier \\'solution\\'. What should i do?"
                    }
                ]
            },
            {
                "id": 1734023,
                "content": [
                    {
                        "username": "Vinit_Anishkumar_Masrani",
                        "content": "When I submit, I get TLE error for the following test case:\nTime Limit Exceeded\nAnd it shows 141/141 testcases passed\nLast executed Input:\n s =\n\n\nWhat is the expected output for this testcase? And why is my code though passing big strings in testcase fails because of TLE in empty one."
                    },
                    {
                        "username": "DevPj09",
                        "content": "This is a bug. Happened with me too. I changed the browser and it worked. Might be due to network or cache.\\n"
                    },
                    {
                        "username": "TheCScience",
                        "content": "Here is problem solution in Java, Python, C++ and C programming.\\n[https://thecscience.com/leetcode-longest-palindromic-substring-problem-solution.html](https://thecscience.com/leetcode-longest-palindromic-substring-problem-solution.html)"
                    },
                    {
                        "username": "Shekhar_k_s",
                        "content": "My Solution was of O(n2) and final result is Time Limit Exceeded ( TLE ) . LOL \\uD83D\\uDE12\\n `void check(vector<vector<bool>> &v, int start, int end, string s, int &indexStart, int &indexEnd)\\n{\\n    if(s[start]==s[end])\\n    {\\n        if(v[start+1][end-1]==true)\\n        {\\n            v[start][end]=true;\\n            // cout<<start<<\" \"<<end<<endl;\\n            indexStart=start;\\n            indexEnd=end;\\n        }else\\n        {\\n            v[start][end]=false;\\n        }\\n    }\\n    else\\n    v[start][end]=false;\\n}\\n\\n\\n\\nclass Solution {\\npublic:\\n    string longestPalindrome(string s) {\\n        int len=s.length();\\n        int indexStart=0;\\n        int indexEnd=0;\\n        vector<vector<bool>> arr;\\n        for(int i=0;i<len;i++)\\n        {\\n            vector<bool> v(len);\\n            v[i]=true;\\n            arr.push_back(v);\\n        }\\n        for(int i=1;i<len;i++)\\n        {\\n            if(s[i-1]==s[i]){\\n                arr[i-1][i]=true;\\n                indexStart=i-1;\\n                indexEnd=i;\\n            }\\n            else\\n            arr[i-1][i]=false;\\n        }\\n        // cout<<indexStart<<\" \"<<indexEnd<<endl;\\n        int start=0;\\n        int end=2;\\n        while(end-start<=len)\\n        {\\n            while(end<len)\\n            {\\n                check(arr, start, end, s, indexStart, indexEnd);\\n                start++;\\n                end++;\\n            }\\n            int temp=end-start;\\n            temp++;\\n            start=0;\\n            end=temp;\\n        }\\n        string ans;\\n        for(int i=indexStart;i<=indexEnd;i++)\\n        {\\n            ans+=s[i];\\n        }\\n        // cout<<indexStart<<\" \"<<indexEnd<<endl;\\n        return ans;\\n    }\\n};`"
                    },
                    {
                        "username": "joshi248",
                        "content": "What is wrong here please tell\\n ```\\nclass Solution {\\npublic:\\n    bool isPalindrome(string strs){\\n        int n = strs.length();\\n        for(int i=0;i<n/2;++i){\\n            if(strs[i]!=strs[n-i-1]) return false;\\n        }\\n        return true;\\n    }\\n    string check(vector<string> &temp){\\n        string sruti = \"\";\\n        for(auto strs:temp){\\n            if(isPalindrome(strs)){\\n              if(strs.length() > sruti.length()) sruti = strs;\\n            }\\n        }\\n        return sruti;\\n    }\\n    string longestPalindrome(string s) {\\n        \\n        vector<string> temp;\\n        int n = s.length();\\n        if(n==1){\\n            if(isPalindrome(s)){\\n                return s;\\n            }\\n            return \"\";\\n        }\\n        for(int i=0;i<n;++i){\\n            for(int j=1;j<=n-i;++j){\\n                temp.push_back(s.substr(i,j));\\n            }\\n        }\\n        string ans = check(temp);\\n        return ans;\\n\\n\\n    }\\n};\\n```"
                    },
                    {
                        "username": "ayushi_828",
                        "content": "class Solution {\\n   int resultStart;\\n    int resultLength;\\n\\n    public String longestPalindrome(String s) {\\n        int strLength = s.length();\\n        if (strLength < 2) {\\n            return s;\\n        }\\n        for (int start = 0; start < strLength - 1; start++) {\\n            expandRange(s, start, start);\\n            expandRange(s, start, start + 1);\\n        }\\n        return s.substring(resultStart, resultStart + resultLength);\\n    }\\n\\n    private void expandRange(String str, int begin, int end) {\\n       while (begin >= 0 && end < str.length() &&\\n                    str.charAt(begin) == str.charAt(end)) {\\n            begin--;\\n            end++;\\n        }\\n       if (resultLength < end - begin - 1) {\\n            resultStart = begin + 1;\\n            resultLength = end - begin - 1;\\n        }\\n    }\\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "sukriti_sinha7",
                        "content": "class Solution {\\npublic:\\n    string longestPalindrome(string s) {\\n        string ans = \"\";\\n        for(int i = 0; i < s.length() ; i ++){\\n            string s1 = extend(s,i,i), s2 = extend(s, i, i+1);\\n\\n            if(s1.length() > ans.length()) ans = s1;\\n            if(s2.length() > ans.length()) ans = s2;\\n        }\\n\\n        return ans;\\n    }\\n\\n    string extend(string s, int left, int right){\\n        while(left >= 0 && right < s.length() && s[left] == s[right]){\\n            left--;\\n            right++;\\n        }\\n        return s.substr(left+1, right - left - 1);\\n    }\\n};"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "utkarshv2619",
                        "content": "//easy solution:\\n\\nclass Solution {\\npublic:\\n    string longestPalindrome(string s) {\\n        string res;\\n        int reslen = 0;\\n        \\n        if(s.size()<=1)\\n            return s; \\n        \\n        for(int i=0;i<s.size()-1;i++)\\n        {\\n            //odd length\\n            int l=i;\\n            int r=i;\\n            while(l>=0 && r<s.size() && s[l]==s[r])\\n            {\\n                if(r-l+1 > reslen  )\\n                {\\n                    res = s.substr(l, r-l+1);\\n                    reslen = r-l+1;\\n                }\\n                l--;\\n                r++;\\n            }\\n            //even length\\n            int L=i;\\n            int R=i+1;\\n            while(L>=0 && R<s.size() && s[L]==s[R])\\n            {\\n                if(R-L+1 > reslen)\\n                {\\n                    res = s.substr(L,R-L+1);\\n                    reslen = R-L+1;\\n                }\\n                L--;\\n                R++;\\n            }\\n        }\\n        return res;\\n    }\\n    \\n};"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "//Easy rules.\n\n💡 Discussion Rules\n1. Please don't post any solutions in this discussion.\n\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\n\n3. If you'd like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "codecat____",
                        "content": "I have \"Time Limit Exceeded\" problem here \nhow can i reduce running time in my code ?\n\ncode is given :\n\n\n\n\n\nclass Solution:\n    def longestPalindrome(self, s: str) -> str:\n        y=[]\n        x=[]\n        for i in range(len(s)):\n            for j in range(i+1,len(s)+1):\n                y.append(s[i:j])\n        for k in y:\n            if k == k[::-1]:\n                x.append(k)\n        w=[]\n        for v in x:\n            w.append(len(v))\n        if len(s)==1:\n            return s\n        for q in x:\n            if len(q)==max(w):\n                return(q)\n  "
                    },
                    {
                        "username": "noob-pika",
                        "content": "Check out the last two solutions in the solutions section of this question. The last one has a time complexity of O(n) but may take a while to understand whereas the second last one has a time complexity of O(n^2) but fairly easy"
                    },
                    {
                        "username": "Yongbi",
                        "content": "[@codecat____](/codecat____) Just use 2 pointer and reverse string that\\'s enough. I see that you have 5 loop in your algorithm!! It\\'s kind of too much, right?"
                    },
                    {
                        "username": "itanki3085",
                        "content": "Different result between LeetCode and my computer.\\nI got the result : `load of value 15, which is not a valid value for type \\'bool\\'`, but my code at that line is\\n```cpp\\ndp[from][to] = dp[from+1][to-1] && (s[from]==s[to]);\\n```\\nHow was that possible when I assign a boolean value into a address stores boolean value still get an error?\\nAt least it is not related to compiler. But what is the problem related to?"
                    },
                    {
                        "username": "Khudoyshukur",
                        "content": "Are we allowed to use class only? When I am writing without classes it is giving error: use of undeclared identifier \\'solution\\'. What should i do?"
                    }
                ]
            },
            {
                "id": 1732901,
                "content": [
                    {
                        "username": "Vinit_Anishkumar_Masrani",
                        "content": "When I submit, I get TLE error for the following test case:\nTime Limit Exceeded\nAnd it shows 141/141 testcases passed\nLast executed Input:\n s =\n\n\nWhat is the expected output for this testcase? And why is my code though passing big strings in testcase fails because of TLE in empty one."
                    },
                    {
                        "username": "DevPj09",
                        "content": "This is a bug. Happened with me too. I changed the browser and it worked. Might be due to network or cache.\\n"
                    },
                    {
                        "username": "TheCScience",
                        "content": "Here is problem solution in Java, Python, C++ and C programming.\\n[https://thecscience.com/leetcode-longest-palindromic-substring-problem-solution.html](https://thecscience.com/leetcode-longest-palindromic-substring-problem-solution.html)"
                    },
                    {
                        "username": "Shekhar_k_s",
                        "content": "My Solution was of O(n2) and final result is Time Limit Exceeded ( TLE ) . LOL \\uD83D\\uDE12\\n `void check(vector<vector<bool>> &v, int start, int end, string s, int &indexStart, int &indexEnd)\\n{\\n    if(s[start]==s[end])\\n    {\\n        if(v[start+1][end-1]==true)\\n        {\\n            v[start][end]=true;\\n            // cout<<start<<\" \"<<end<<endl;\\n            indexStart=start;\\n            indexEnd=end;\\n        }else\\n        {\\n            v[start][end]=false;\\n        }\\n    }\\n    else\\n    v[start][end]=false;\\n}\\n\\n\\n\\nclass Solution {\\npublic:\\n    string longestPalindrome(string s) {\\n        int len=s.length();\\n        int indexStart=0;\\n        int indexEnd=0;\\n        vector<vector<bool>> arr;\\n        for(int i=0;i<len;i++)\\n        {\\n            vector<bool> v(len);\\n            v[i]=true;\\n            arr.push_back(v);\\n        }\\n        for(int i=1;i<len;i++)\\n        {\\n            if(s[i-1]==s[i]){\\n                arr[i-1][i]=true;\\n                indexStart=i-1;\\n                indexEnd=i;\\n            }\\n            else\\n            arr[i-1][i]=false;\\n        }\\n        // cout<<indexStart<<\" \"<<indexEnd<<endl;\\n        int start=0;\\n        int end=2;\\n        while(end-start<=len)\\n        {\\n            while(end<len)\\n            {\\n                check(arr, start, end, s, indexStart, indexEnd);\\n                start++;\\n                end++;\\n            }\\n            int temp=end-start;\\n            temp++;\\n            start=0;\\n            end=temp;\\n        }\\n        string ans;\\n        for(int i=indexStart;i<=indexEnd;i++)\\n        {\\n            ans+=s[i];\\n        }\\n        // cout<<indexStart<<\" \"<<indexEnd<<endl;\\n        return ans;\\n    }\\n};`"
                    },
                    {
                        "username": "joshi248",
                        "content": "What is wrong here please tell\\n ```\\nclass Solution {\\npublic:\\n    bool isPalindrome(string strs){\\n        int n = strs.length();\\n        for(int i=0;i<n/2;++i){\\n            if(strs[i]!=strs[n-i-1]) return false;\\n        }\\n        return true;\\n    }\\n    string check(vector<string> &temp){\\n        string sruti = \"\";\\n        for(auto strs:temp){\\n            if(isPalindrome(strs)){\\n              if(strs.length() > sruti.length()) sruti = strs;\\n            }\\n        }\\n        return sruti;\\n    }\\n    string longestPalindrome(string s) {\\n        \\n        vector<string> temp;\\n        int n = s.length();\\n        if(n==1){\\n            if(isPalindrome(s)){\\n                return s;\\n            }\\n            return \"\";\\n        }\\n        for(int i=0;i<n;++i){\\n            for(int j=1;j<=n-i;++j){\\n                temp.push_back(s.substr(i,j));\\n            }\\n        }\\n        string ans = check(temp);\\n        return ans;\\n\\n\\n    }\\n};\\n```"
                    },
                    {
                        "username": "ayushi_828",
                        "content": "class Solution {\\n   int resultStart;\\n    int resultLength;\\n\\n    public String longestPalindrome(String s) {\\n        int strLength = s.length();\\n        if (strLength < 2) {\\n            return s;\\n        }\\n        for (int start = 0; start < strLength - 1; start++) {\\n            expandRange(s, start, start);\\n            expandRange(s, start, start + 1);\\n        }\\n        return s.substring(resultStart, resultStart + resultLength);\\n    }\\n\\n    private void expandRange(String str, int begin, int end) {\\n       while (begin >= 0 && end < str.length() &&\\n                    str.charAt(begin) == str.charAt(end)) {\\n            begin--;\\n            end++;\\n        }\\n       if (resultLength < end - begin - 1) {\\n            resultStart = begin + 1;\\n            resultLength = end - begin - 1;\\n        }\\n    }\\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "sukriti_sinha7",
                        "content": "class Solution {\\npublic:\\n    string longestPalindrome(string s) {\\n        string ans = \"\";\\n        for(int i = 0; i < s.length() ; i ++){\\n            string s1 = extend(s,i,i), s2 = extend(s, i, i+1);\\n\\n            if(s1.length() > ans.length()) ans = s1;\\n            if(s2.length() > ans.length()) ans = s2;\\n        }\\n\\n        return ans;\\n    }\\n\\n    string extend(string s, int left, int right){\\n        while(left >= 0 && right < s.length() && s[left] == s[right]){\\n            left--;\\n            right++;\\n        }\\n        return s.substr(left+1, right - left - 1);\\n    }\\n};"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "utkarshv2619",
                        "content": "//easy solution:\\n\\nclass Solution {\\npublic:\\n    string longestPalindrome(string s) {\\n        string res;\\n        int reslen = 0;\\n        \\n        if(s.size()<=1)\\n            return s; \\n        \\n        for(int i=0;i<s.size()-1;i++)\\n        {\\n            //odd length\\n            int l=i;\\n            int r=i;\\n            while(l>=0 && r<s.size() && s[l]==s[r])\\n            {\\n                if(r-l+1 > reslen  )\\n                {\\n                    res = s.substr(l, r-l+1);\\n                    reslen = r-l+1;\\n                }\\n                l--;\\n                r++;\\n            }\\n            //even length\\n            int L=i;\\n            int R=i+1;\\n            while(L>=0 && R<s.size() && s[L]==s[R])\\n            {\\n                if(R-L+1 > reslen)\\n                {\\n                    res = s.substr(L,R-L+1);\\n                    reslen = R-L+1;\\n                }\\n                L--;\\n                R++;\\n            }\\n        }\\n        return res;\\n    }\\n    \\n};"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "//Easy rules.\n\n💡 Discussion Rules\n1. Please don't post any solutions in this discussion.\n\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\n\n3. If you'd like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "codecat____",
                        "content": "I have \"Time Limit Exceeded\" problem here \nhow can i reduce running time in my code ?\n\ncode is given :\n\n\n\n\n\nclass Solution:\n    def longestPalindrome(self, s: str) -> str:\n        y=[]\n        x=[]\n        for i in range(len(s)):\n            for j in range(i+1,len(s)+1):\n                y.append(s[i:j])\n        for k in y:\n            if k == k[::-1]:\n                x.append(k)\n        w=[]\n        for v in x:\n            w.append(len(v))\n        if len(s)==1:\n            return s\n        for q in x:\n            if len(q)==max(w):\n                return(q)\n  "
                    },
                    {
                        "username": "noob-pika",
                        "content": "Check out the last two solutions in the solutions section of this question. The last one has a time complexity of O(n) but may take a while to understand whereas the second last one has a time complexity of O(n^2) but fairly easy"
                    },
                    {
                        "username": "Yongbi",
                        "content": "[@codecat____](/codecat____) Just use 2 pointer and reverse string that\\'s enough. I see that you have 5 loop in your algorithm!! It\\'s kind of too much, right?"
                    },
                    {
                        "username": "itanki3085",
                        "content": "Different result between LeetCode and my computer.\\nI got the result : `load of value 15, which is not a valid value for type \\'bool\\'`, but my code at that line is\\n```cpp\\ndp[from][to] = dp[from+1][to-1] && (s[from]==s[to]);\\n```\\nHow was that possible when I assign a boolean value into a address stores boolean value still get an error?\\nAt least it is not related to compiler. But what is the problem related to?"
                    },
                    {
                        "username": "Khudoyshukur",
                        "content": "Are we allowed to use class only? When I am writing without classes it is giving error: use of undeclared identifier \\'solution\\'. What should i do?"
                    }
                ]
            },
            {
                "id": 1731547,
                "content": [
                    {
                        "username": "Vinit_Anishkumar_Masrani",
                        "content": "When I submit, I get TLE error for the following test case:\nTime Limit Exceeded\nAnd it shows 141/141 testcases passed\nLast executed Input:\n s =\n\n\nWhat is the expected output for this testcase? And why is my code though passing big strings in testcase fails because of TLE in empty one."
                    },
                    {
                        "username": "DevPj09",
                        "content": "This is a bug. Happened with me too. I changed the browser and it worked. Might be due to network or cache.\\n"
                    },
                    {
                        "username": "TheCScience",
                        "content": "Here is problem solution in Java, Python, C++ and C programming.\\n[https://thecscience.com/leetcode-longest-palindromic-substring-problem-solution.html](https://thecscience.com/leetcode-longest-palindromic-substring-problem-solution.html)"
                    },
                    {
                        "username": "Shekhar_k_s",
                        "content": "My Solution was of O(n2) and final result is Time Limit Exceeded ( TLE ) . LOL \\uD83D\\uDE12\\n `void check(vector<vector<bool>> &v, int start, int end, string s, int &indexStart, int &indexEnd)\\n{\\n    if(s[start]==s[end])\\n    {\\n        if(v[start+1][end-1]==true)\\n        {\\n            v[start][end]=true;\\n            // cout<<start<<\" \"<<end<<endl;\\n            indexStart=start;\\n            indexEnd=end;\\n        }else\\n        {\\n            v[start][end]=false;\\n        }\\n    }\\n    else\\n    v[start][end]=false;\\n}\\n\\n\\n\\nclass Solution {\\npublic:\\n    string longestPalindrome(string s) {\\n        int len=s.length();\\n        int indexStart=0;\\n        int indexEnd=0;\\n        vector<vector<bool>> arr;\\n        for(int i=0;i<len;i++)\\n        {\\n            vector<bool> v(len);\\n            v[i]=true;\\n            arr.push_back(v);\\n        }\\n        for(int i=1;i<len;i++)\\n        {\\n            if(s[i-1]==s[i]){\\n                arr[i-1][i]=true;\\n                indexStart=i-1;\\n                indexEnd=i;\\n            }\\n            else\\n            arr[i-1][i]=false;\\n        }\\n        // cout<<indexStart<<\" \"<<indexEnd<<endl;\\n        int start=0;\\n        int end=2;\\n        while(end-start<=len)\\n        {\\n            while(end<len)\\n            {\\n                check(arr, start, end, s, indexStart, indexEnd);\\n                start++;\\n                end++;\\n            }\\n            int temp=end-start;\\n            temp++;\\n            start=0;\\n            end=temp;\\n        }\\n        string ans;\\n        for(int i=indexStart;i<=indexEnd;i++)\\n        {\\n            ans+=s[i];\\n        }\\n        // cout<<indexStart<<\" \"<<indexEnd<<endl;\\n        return ans;\\n    }\\n};`"
                    },
                    {
                        "username": "joshi248",
                        "content": "What is wrong here please tell\\n ```\\nclass Solution {\\npublic:\\n    bool isPalindrome(string strs){\\n        int n = strs.length();\\n        for(int i=0;i<n/2;++i){\\n            if(strs[i]!=strs[n-i-1]) return false;\\n        }\\n        return true;\\n    }\\n    string check(vector<string> &temp){\\n        string sruti = \"\";\\n        for(auto strs:temp){\\n            if(isPalindrome(strs)){\\n              if(strs.length() > sruti.length()) sruti = strs;\\n            }\\n        }\\n        return sruti;\\n    }\\n    string longestPalindrome(string s) {\\n        \\n        vector<string> temp;\\n        int n = s.length();\\n        if(n==1){\\n            if(isPalindrome(s)){\\n                return s;\\n            }\\n            return \"\";\\n        }\\n        for(int i=0;i<n;++i){\\n            for(int j=1;j<=n-i;++j){\\n                temp.push_back(s.substr(i,j));\\n            }\\n        }\\n        string ans = check(temp);\\n        return ans;\\n\\n\\n    }\\n};\\n```"
                    },
                    {
                        "username": "ayushi_828",
                        "content": "class Solution {\\n   int resultStart;\\n    int resultLength;\\n\\n    public String longestPalindrome(String s) {\\n        int strLength = s.length();\\n        if (strLength < 2) {\\n            return s;\\n        }\\n        for (int start = 0; start < strLength - 1; start++) {\\n            expandRange(s, start, start);\\n            expandRange(s, start, start + 1);\\n        }\\n        return s.substring(resultStart, resultStart + resultLength);\\n    }\\n\\n    private void expandRange(String str, int begin, int end) {\\n       while (begin >= 0 && end < str.length() &&\\n                    str.charAt(begin) == str.charAt(end)) {\\n            begin--;\\n            end++;\\n        }\\n       if (resultLength < end - begin - 1) {\\n            resultStart = begin + 1;\\n            resultLength = end - begin - 1;\\n        }\\n    }\\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "sukriti_sinha7",
                        "content": "class Solution {\\npublic:\\n    string longestPalindrome(string s) {\\n        string ans = \"\";\\n        for(int i = 0; i < s.length() ; i ++){\\n            string s1 = extend(s,i,i), s2 = extend(s, i, i+1);\\n\\n            if(s1.length() > ans.length()) ans = s1;\\n            if(s2.length() > ans.length()) ans = s2;\\n        }\\n\\n        return ans;\\n    }\\n\\n    string extend(string s, int left, int right){\\n        while(left >= 0 && right < s.length() && s[left] == s[right]){\\n            left--;\\n            right++;\\n        }\\n        return s.substr(left+1, right - left - 1);\\n    }\\n};"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "utkarshv2619",
                        "content": "//easy solution:\\n\\nclass Solution {\\npublic:\\n    string longestPalindrome(string s) {\\n        string res;\\n        int reslen = 0;\\n        \\n        if(s.size()<=1)\\n            return s; \\n        \\n        for(int i=0;i<s.size()-1;i++)\\n        {\\n            //odd length\\n            int l=i;\\n            int r=i;\\n            while(l>=0 && r<s.size() && s[l]==s[r])\\n            {\\n                if(r-l+1 > reslen  )\\n                {\\n                    res = s.substr(l, r-l+1);\\n                    reslen = r-l+1;\\n                }\\n                l--;\\n                r++;\\n            }\\n            //even length\\n            int L=i;\\n            int R=i+1;\\n            while(L>=0 && R<s.size() && s[L]==s[R])\\n            {\\n                if(R-L+1 > reslen)\\n                {\\n                    res = s.substr(L,R-L+1);\\n                    reslen = R-L+1;\\n                }\\n                L--;\\n                R++;\\n            }\\n        }\\n        return res;\\n    }\\n    \\n};"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "//Easy rules.\n\n💡 Discussion Rules\n1. Please don't post any solutions in this discussion.\n\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\n\n3. If you'd like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "codecat____",
                        "content": "I have \"Time Limit Exceeded\" problem here \nhow can i reduce running time in my code ?\n\ncode is given :\n\n\n\n\n\nclass Solution:\n    def longestPalindrome(self, s: str) -> str:\n        y=[]\n        x=[]\n        for i in range(len(s)):\n            for j in range(i+1,len(s)+1):\n                y.append(s[i:j])\n        for k in y:\n            if k == k[::-1]:\n                x.append(k)\n        w=[]\n        for v in x:\n            w.append(len(v))\n        if len(s)==1:\n            return s\n        for q in x:\n            if len(q)==max(w):\n                return(q)\n  "
                    },
                    {
                        "username": "noob-pika",
                        "content": "Check out the last two solutions in the solutions section of this question. The last one has a time complexity of O(n) but may take a while to understand whereas the second last one has a time complexity of O(n^2) but fairly easy"
                    },
                    {
                        "username": "Yongbi",
                        "content": "[@codecat____](/codecat____) Just use 2 pointer and reverse string that\\'s enough. I see that you have 5 loop in your algorithm!! It\\'s kind of too much, right?"
                    },
                    {
                        "username": "itanki3085",
                        "content": "Different result between LeetCode and my computer.\\nI got the result : `load of value 15, which is not a valid value for type \\'bool\\'`, but my code at that line is\\n```cpp\\ndp[from][to] = dp[from+1][to-1] && (s[from]==s[to]);\\n```\\nHow was that possible when I assign a boolean value into a address stores boolean value still get an error?\\nAt least it is not related to compiler. But what is the problem related to?"
                    },
                    {
                        "username": "Khudoyshukur",
                        "content": "Are we allowed to use class only? When I am writing without classes it is giving error: use of undeclared identifier \\'solution\\'. What should i do?"
                    }
                ]
            },
            {
                "id": 1731175,
                "content": [
                    {
                        "username": "Vinit_Anishkumar_Masrani",
                        "content": "When I submit, I get TLE error for the following test case:\nTime Limit Exceeded\nAnd it shows 141/141 testcases passed\nLast executed Input:\n s =\n\n\nWhat is the expected output for this testcase? And why is my code though passing big strings in testcase fails because of TLE in empty one."
                    },
                    {
                        "username": "DevPj09",
                        "content": "This is a bug. Happened with me too. I changed the browser and it worked. Might be due to network or cache.\\n"
                    },
                    {
                        "username": "TheCScience",
                        "content": "Here is problem solution in Java, Python, C++ and C programming.\\n[https://thecscience.com/leetcode-longest-palindromic-substring-problem-solution.html](https://thecscience.com/leetcode-longest-palindromic-substring-problem-solution.html)"
                    },
                    {
                        "username": "Shekhar_k_s",
                        "content": "My Solution was of O(n2) and final result is Time Limit Exceeded ( TLE ) . LOL \\uD83D\\uDE12\\n `void check(vector<vector<bool>> &v, int start, int end, string s, int &indexStart, int &indexEnd)\\n{\\n    if(s[start]==s[end])\\n    {\\n        if(v[start+1][end-1]==true)\\n        {\\n            v[start][end]=true;\\n            // cout<<start<<\" \"<<end<<endl;\\n            indexStart=start;\\n            indexEnd=end;\\n        }else\\n        {\\n            v[start][end]=false;\\n        }\\n    }\\n    else\\n    v[start][end]=false;\\n}\\n\\n\\n\\nclass Solution {\\npublic:\\n    string longestPalindrome(string s) {\\n        int len=s.length();\\n        int indexStart=0;\\n        int indexEnd=0;\\n        vector<vector<bool>> arr;\\n        for(int i=0;i<len;i++)\\n        {\\n            vector<bool> v(len);\\n            v[i]=true;\\n            arr.push_back(v);\\n        }\\n        for(int i=1;i<len;i++)\\n        {\\n            if(s[i-1]==s[i]){\\n                arr[i-1][i]=true;\\n                indexStart=i-1;\\n                indexEnd=i;\\n            }\\n            else\\n            arr[i-1][i]=false;\\n        }\\n        // cout<<indexStart<<\" \"<<indexEnd<<endl;\\n        int start=0;\\n        int end=2;\\n        while(end-start<=len)\\n        {\\n            while(end<len)\\n            {\\n                check(arr, start, end, s, indexStart, indexEnd);\\n                start++;\\n                end++;\\n            }\\n            int temp=end-start;\\n            temp++;\\n            start=0;\\n            end=temp;\\n        }\\n        string ans;\\n        for(int i=indexStart;i<=indexEnd;i++)\\n        {\\n            ans+=s[i];\\n        }\\n        // cout<<indexStart<<\" \"<<indexEnd<<endl;\\n        return ans;\\n    }\\n};`"
                    },
                    {
                        "username": "joshi248",
                        "content": "What is wrong here please tell\\n ```\\nclass Solution {\\npublic:\\n    bool isPalindrome(string strs){\\n        int n = strs.length();\\n        for(int i=0;i<n/2;++i){\\n            if(strs[i]!=strs[n-i-1]) return false;\\n        }\\n        return true;\\n    }\\n    string check(vector<string> &temp){\\n        string sruti = \"\";\\n        for(auto strs:temp){\\n            if(isPalindrome(strs)){\\n              if(strs.length() > sruti.length()) sruti = strs;\\n            }\\n        }\\n        return sruti;\\n    }\\n    string longestPalindrome(string s) {\\n        \\n        vector<string> temp;\\n        int n = s.length();\\n        if(n==1){\\n            if(isPalindrome(s)){\\n                return s;\\n            }\\n            return \"\";\\n        }\\n        for(int i=0;i<n;++i){\\n            for(int j=1;j<=n-i;++j){\\n                temp.push_back(s.substr(i,j));\\n            }\\n        }\\n        string ans = check(temp);\\n        return ans;\\n\\n\\n    }\\n};\\n```"
                    },
                    {
                        "username": "ayushi_828",
                        "content": "class Solution {\\n   int resultStart;\\n    int resultLength;\\n\\n    public String longestPalindrome(String s) {\\n        int strLength = s.length();\\n        if (strLength < 2) {\\n            return s;\\n        }\\n        for (int start = 0; start < strLength - 1; start++) {\\n            expandRange(s, start, start);\\n            expandRange(s, start, start + 1);\\n        }\\n        return s.substring(resultStart, resultStart + resultLength);\\n    }\\n\\n    private void expandRange(String str, int begin, int end) {\\n       while (begin >= 0 && end < str.length() &&\\n                    str.charAt(begin) == str.charAt(end)) {\\n            begin--;\\n            end++;\\n        }\\n       if (resultLength < end - begin - 1) {\\n            resultStart = begin + 1;\\n            resultLength = end - begin - 1;\\n        }\\n    }\\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "sukriti_sinha7",
                        "content": "class Solution {\\npublic:\\n    string longestPalindrome(string s) {\\n        string ans = \"\";\\n        for(int i = 0; i < s.length() ; i ++){\\n            string s1 = extend(s,i,i), s2 = extend(s, i, i+1);\\n\\n            if(s1.length() > ans.length()) ans = s1;\\n            if(s2.length() > ans.length()) ans = s2;\\n        }\\n\\n        return ans;\\n    }\\n\\n    string extend(string s, int left, int right){\\n        while(left >= 0 && right < s.length() && s[left] == s[right]){\\n            left--;\\n            right++;\\n        }\\n        return s.substr(left+1, right - left - 1);\\n    }\\n};"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "utkarshv2619",
                        "content": "//easy solution:\\n\\nclass Solution {\\npublic:\\n    string longestPalindrome(string s) {\\n        string res;\\n        int reslen = 0;\\n        \\n        if(s.size()<=1)\\n            return s; \\n        \\n        for(int i=0;i<s.size()-1;i++)\\n        {\\n            //odd length\\n            int l=i;\\n            int r=i;\\n            while(l>=0 && r<s.size() && s[l]==s[r])\\n            {\\n                if(r-l+1 > reslen  )\\n                {\\n                    res = s.substr(l, r-l+1);\\n                    reslen = r-l+1;\\n                }\\n                l--;\\n                r++;\\n            }\\n            //even length\\n            int L=i;\\n            int R=i+1;\\n            while(L>=0 && R<s.size() && s[L]==s[R])\\n            {\\n                if(R-L+1 > reslen)\\n                {\\n                    res = s.substr(L,R-L+1);\\n                    reslen = R-L+1;\\n                }\\n                L--;\\n                R++;\\n            }\\n        }\\n        return res;\\n    }\\n    \\n};"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "//Easy rules.\n\n💡 Discussion Rules\n1. Please don't post any solutions in this discussion.\n\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\n\n3. If you'd like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "codecat____",
                        "content": "I have \"Time Limit Exceeded\" problem here \nhow can i reduce running time in my code ?\n\ncode is given :\n\n\n\n\n\nclass Solution:\n    def longestPalindrome(self, s: str) -> str:\n        y=[]\n        x=[]\n        for i in range(len(s)):\n            for j in range(i+1,len(s)+1):\n                y.append(s[i:j])\n        for k in y:\n            if k == k[::-1]:\n                x.append(k)\n        w=[]\n        for v in x:\n            w.append(len(v))\n        if len(s)==1:\n            return s\n        for q in x:\n            if len(q)==max(w):\n                return(q)\n  "
                    },
                    {
                        "username": "noob-pika",
                        "content": "Check out the last two solutions in the solutions section of this question. The last one has a time complexity of O(n) but may take a while to understand whereas the second last one has a time complexity of O(n^2) but fairly easy"
                    },
                    {
                        "username": "Yongbi",
                        "content": "[@codecat____](/codecat____) Just use 2 pointer and reverse string that\\'s enough. I see that you have 5 loop in your algorithm!! It\\'s kind of too much, right?"
                    },
                    {
                        "username": "itanki3085",
                        "content": "Different result between LeetCode and my computer.\\nI got the result : `load of value 15, which is not a valid value for type \\'bool\\'`, but my code at that line is\\n```cpp\\ndp[from][to] = dp[from+1][to-1] && (s[from]==s[to]);\\n```\\nHow was that possible when I assign a boolean value into a address stores boolean value still get an error?\\nAt least it is not related to compiler. But what is the problem related to?"
                    },
                    {
                        "username": "Khudoyshukur",
                        "content": "Are we allowed to use class only? When I am writing without classes it is giving error: use of undeclared identifier \\'solution\\'. What should i do?"
                    }
                ]
            },
            {
                "id": 1727086,
                "content": [
                    {
                        "username": "Vinit_Anishkumar_Masrani",
                        "content": "When I submit, I get TLE error for the following test case:\nTime Limit Exceeded\nAnd it shows 141/141 testcases passed\nLast executed Input:\n s =\n\n\nWhat is the expected output for this testcase? And why is my code though passing big strings in testcase fails because of TLE in empty one."
                    },
                    {
                        "username": "DevPj09",
                        "content": "This is a bug. Happened with me too. I changed the browser and it worked. Might be due to network or cache.\\n"
                    },
                    {
                        "username": "TheCScience",
                        "content": "Here is problem solution in Java, Python, C++ and C programming.\\n[https://thecscience.com/leetcode-longest-palindromic-substring-problem-solution.html](https://thecscience.com/leetcode-longest-palindromic-substring-problem-solution.html)"
                    },
                    {
                        "username": "Shekhar_k_s",
                        "content": "My Solution was of O(n2) and final result is Time Limit Exceeded ( TLE ) . LOL \\uD83D\\uDE12\\n `void check(vector<vector<bool>> &v, int start, int end, string s, int &indexStart, int &indexEnd)\\n{\\n    if(s[start]==s[end])\\n    {\\n        if(v[start+1][end-1]==true)\\n        {\\n            v[start][end]=true;\\n            // cout<<start<<\" \"<<end<<endl;\\n            indexStart=start;\\n            indexEnd=end;\\n        }else\\n        {\\n            v[start][end]=false;\\n        }\\n    }\\n    else\\n    v[start][end]=false;\\n}\\n\\n\\n\\nclass Solution {\\npublic:\\n    string longestPalindrome(string s) {\\n        int len=s.length();\\n        int indexStart=0;\\n        int indexEnd=0;\\n        vector<vector<bool>> arr;\\n        for(int i=0;i<len;i++)\\n        {\\n            vector<bool> v(len);\\n            v[i]=true;\\n            arr.push_back(v);\\n        }\\n        for(int i=1;i<len;i++)\\n        {\\n            if(s[i-1]==s[i]){\\n                arr[i-1][i]=true;\\n                indexStart=i-1;\\n                indexEnd=i;\\n            }\\n            else\\n            arr[i-1][i]=false;\\n        }\\n        // cout<<indexStart<<\" \"<<indexEnd<<endl;\\n        int start=0;\\n        int end=2;\\n        while(end-start<=len)\\n        {\\n            while(end<len)\\n            {\\n                check(arr, start, end, s, indexStart, indexEnd);\\n                start++;\\n                end++;\\n            }\\n            int temp=end-start;\\n            temp++;\\n            start=0;\\n            end=temp;\\n        }\\n        string ans;\\n        for(int i=indexStart;i<=indexEnd;i++)\\n        {\\n            ans+=s[i];\\n        }\\n        // cout<<indexStart<<\" \"<<indexEnd<<endl;\\n        return ans;\\n    }\\n};`"
                    },
                    {
                        "username": "joshi248",
                        "content": "What is wrong here please tell\\n ```\\nclass Solution {\\npublic:\\n    bool isPalindrome(string strs){\\n        int n = strs.length();\\n        for(int i=0;i<n/2;++i){\\n            if(strs[i]!=strs[n-i-1]) return false;\\n        }\\n        return true;\\n    }\\n    string check(vector<string> &temp){\\n        string sruti = \"\";\\n        for(auto strs:temp){\\n            if(isPalindrome(strs)){\\n              if(strs.length() > sruti.length()) sruti = strs;\\n            }\\n        }\\n        return sruti;\\n    }\\n    string longestPalindrome(string s) {\\n        \\n        vector<string> temp;\\n        int n = s.length();\\n        if(n==1){\\n            if(isPalindrome(s)){\\n                return s;\\n            }\\n            return \"\";\\n        }\\n        for(int i=0;i<n;++i){\\n            for(int j=1;j<=n-i;++j){\\n                temp.push_back(s.substr(i,j));\\n            }\\n        }\\n        string ans = check(temp);\\n        return ans;\\n\\n\\n    }\\n};\\n```"
                    },
                    {
                        "username": "ayushi_828",
                        "content": "class Solution {\\n   int resultStart;\\n    int resultLength;\\n\\n    public String longestPalindrome(String s) {\\n        int strLength = s.length();\\n        if (strLength < 2) {\\n            return s;\\n        }\\n        for (int start = 0; start < strLength - 1; start++) {\\n            expandRange(s, start, start);\\n            expandRange(s, start, start + 1);\\n        }\\n        return s.substring(resultStart, resultStart + resultLength);\\n    }\\n\\n    private void expandRange(String str, int begin, int end) {\\n       while (begin >= 0 && end < str.length() &&\\n                    str.charAt(begin) == str.charAt(end)) {\\n            begin--;\\n            end++;\\n        }\\n       if (resultLength < end - begin - 1) {\\n            resultStart = begin + 1;\\n            resultLength = end - begin - 1;\\n        }\\n    }\\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "sukriti_sinha7",
                        "content": "class Solution {\\npublic:\\n    string longestPalindrome(string s) {\\n        string ans = \"\";\\n        for(int i = 0; i < s.length() ; i ++){\\n            string s1 = extend(s,i,i), s2 = extend(s, i, i+1);\\n\\n            if(s1.length() > ans.length()) ans = s1;\\n            if(s2.length() > ans.length()) ans = s2;\\n        }\\n\\n        return ans;\\n    }\\n\\n    string extend(string s, int left, int right){\\n        while(left >= 0 && right < s.length() && s[left] == s[right]){\\n            left--;\\n            right++;\\n        }\\n        return s.substr(left+1, right - left - 1);\\n    }\\n};"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "utkarshv2619",
                        "content": "//easy solution:\\n\\nclass Solution {\\npublic:\\n    string longestPalindrome(string s) {\\n        string res;\\n        int reslen = 0;\\n        \\n        if(s.size()<=1)\\n            return s; \\n        \\n        for(int i=0;i<s.size()-1;i++)\\n        {\\n            //odd length\\n            int l=i;\\n            int r=i;\\n            while(l>=0 && r<s.size() && s[l]==s[r])\\n            {\\n                if(r-l+1 > reslen  )\\n                {\\n                    res = s.substr(l, r-l+1);\\n                    reslen = r-l+1;\\n                }\\n                l--;\\n                r++;\\n            }\\n            //even length\\n            int L=i;\\n            int R=i+1;\\n            while(L>=0 && R<s.size() && s[L]==s[R])\\n            {\\n                if(R-L+1 > reslen)\\n                {\\n                    res = s.substr(L,R-L+1);\\n                    reslen = R-L+1;\\n                }\\n                L--;\\n                R++;\\n            }\\n        }\\n        return res;\\n    }\\n    \\n};"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "//Easy rules.\n\n💡 Discussion Rules\n1. Please don't post any solutions in this discussion.\n\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\n\n3. If you'd like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "codecat____",
                        "content": "I have \"Time Limit Exceeded\" problem here \nhow can i reduce running time in my code ?\n\ncode is given :\n\n\n\n\n\nclass Solution:\n    def longestPalindrome(self, s: str) -> str:\n        y=[]\n        x=[]\n        for i in range(len(s)):\n            for j in range(i+1,len(s)+1):\n                y.append(s[i:j])\n        for k in y:\n            if k == k[::-1]:\n                x.append(k)\n        w=[]\n        for v in x:\n            w.append(len(v))\n        if len(s)==1:\n            return s\n        for q in x:\n            if len(q)==max(w):\n                return(q)\n  "
                    },
                    {
                        "username": "noob-pika",
                        "content": "Check out the last two solutions in the solutions section of this question. The last one has a time complexity of O(n) but may take a while to understand whereas the second last one has a time complexity of O(n^2) but fairly easy"
                    },
                    {
                        "username": "Yongbi",
                        "content": "[@codecat____](/codecat____) Just use 2 pointer and reverse string that\\'s enough. I see that you have 5 loop in your algorithm!! It\\'s kind of too much, right?"
                    },
                    {
                        "username": "itanki3085",
                        "content": "Different result between LeetCode and my computer.\\nI got the result : `load of value 15, which is not a valid value for type \\'bool\\'`, but my code at that line is\\n```cpp\\ndp[from][to] = dp[from+1][to-1] && (s[from]==s[to]);\\n```\\nHow was that possible when I assign a boolean value into a address stores boolean value still get an error?\\nAt least it is not related to compiler. But what is the problem related to?"
                    },
                    {
                        "username": "Khudoyshukur",
                        "content": "Are we allowed to use class only? When I am writing without classes it is giving error: use of undeclared identifier \\'solution\\'. What should i do?"
                    }
                ]
            },
            {
                "id": 1722806,
                "content": [
                    {
                        "username": "Vinit_Anishkumar_Masrani",
                        "content": "When I submit, I get TLE error for the following test case:\nTime Limit Exceeded\nAnd it shows 141/141 testcases passed\nLast executed Input:\n s =\n\n\nWhat is the expected output for this testcase? And why is my code though passing big strings in testcase fails because of TLE in empty one."
                    },
                    {
                        "username": "DevPj09",
                        "content": "This is a bug. Happened with me too. I changed the browser and it worked. Might be due to network or cache.\\n"
                    },
                    {
                        "username": "TheCScience",
                        "content": "Here is problem solution in Java, Python, C++ and C programming.\\n[https://thecscience.com/leetcode-longest-palindromic-substring-problem-solution.html](https://thecscience.com/leetcode-longest-palindromic-substring-problem-solution.html)"
                    },
                    {
                        "username": "Shekhar_k_s",
                        "content": "My Solution was of O(n2) and final result is Time Limit Exceeded ( TLE ) . LOL \\uD83D\\uDE12\\n `void check(vector<vector<bool>> &v, int start, int end, string s, int &indexStart, int &indexEnd)\\n{\\n    if(s[start]==s[end])\\n    {\\n        if(v[start+1][end-1]==true)\\n        {\\n            v[start][end]=true;\\n            // cout<<start<<\" \"<<end<<endl;\\n            indexStart=start;\\n            indexEnd=end;\\n        }else\\n        {\\n            v[start][end]=false;\\n        }\\n    }\\n    else\\n    v[start][end]=false;\\n}\\n\\n\\n\\nclass Solution {\\npublic:\\n    string longestPalindrome(string s) {\\n        int len=s.length();\\n        int indexStart=0;\\n        int indexEnd=0;\\n        vector<vector<bool>> arr;\\n        for(int i=0;i<len;i++)\\n        {\\n            vector<bool> v(len);\\n            v[i]=true;\\n            arr.push_back(v);\\n        }\\n        for(int i=1;i<len;i++)\\n        {\\n            if(s[i-1]==s[i]){\\n                arr[i-1][i]=true;\\n                indexStart=i-1;\\n                indexEnd=i;\\n            }\\n            else\\n            arr[i-1][i]=false;\\n        }\\n        // cout<<indexStart<<\" \"<<indexEnd<<endl;\\n        int start=0;\\n        int end=2;\\n        while(end-start<=len)\\n        {\\n            while(end<len)\\n            {\\n                check(arr, start, end, s, indexStart, indexEnd);\\n                start++;\\n                end++;\\n            }\\n            int temp=end-start;\\n            temp++;\\n            start=0;\\n            end=temp;\\n        }\\n        string ans;\\n        for(int i=indexStart;i<=indexEnd;i++)\\n        {\\n            ans+=s[i];\\n        }\\n        // cout<<indexStart<<\" \"<<indexEnd<<endl;\\n        return ans;\\n    }\\n};`"
                    },
                    {
                        "username": "joshi248",
                        "content": "What is wrong here please tell\\n ```\\nclass Solution {\\npublic:\\n    bool isPalindrome(string strs){\\n        int n = strs.length();\\n        for(int i=0;i<n/2;++i){\\n            if(strs[i]!=strs[n-i-1]) return false;\\n        }\\n        return true;\\n    }\\n    string check(vector<string> &temp){\\n        string sruti = \"\";\\n        for(auto strs:temp){\\n            if(isPalindrome(strs)){\\n              if(strs.length() > sruti.length()) sruti = strs;\\n            }\\n        }\\n        return sruti;\\n    }\\n    string longestPalindrome(string s) {\\n        \\n        vector<string> temp;\\n        int n = s.length();\\n        if(n==1){\\n            if(isPalindrome(s)){\\n                return s;\\n            }\\n            return \"\";\\n        }\\n        for(int i=0;i<n;++i){\\n            for(int j=1;j<=n-i;++j){\\n                temp.push_back(s.substr(i,j));\\n            }\\n        }\\n        string ans = check(temp);\\n        return ans;\\n\\n\\n    }\\n};\\n```"
                    },
                    {
                        "username": "ayushi_828",
                        "content": "class Solution {\\n   int resultStart;\\n    int resultLength;\\n\\n    public String longestPalindrome(String s) {\\n        int strLength = s.length();\\n        if (strLength < 2) {\\n            return s;\\n        }\\n        for (int start = 0; start < strLength - 1; start++) {\\n            expandRange(s, start, start);\\n            expandRange(s, start, start + 1);\\n        }\\n        return s.substring(resultStart, resultStart + resultLength);\\n    }\\n\\n    private void expandRange(String str, int begin, int end) {\\n       while (begin >= 0 && end < str.length() &&\\n                    str.charAt(begin) == str.charAt(end)) {\\n            begin--;\\n            end++;\\n        }\\n       if (resultLength < end - begin - 1) {\\n            resultStart = begin + 1;\\n            resultLength = end - begin - 1;\\n        }\\n    }\\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "sukriti_sinha7",
                        "content": "class Solution {\\npublic:\\n    string longestPalindrome(string s) {\\n        string ans = \"\";\\n        for(int i = 0; i < s.length() ; i ++){\\n            string s1 = extend(s,i,i), s2 = extend(s, i, i+1);\\n\\n            if(s1.length() > ans.length()) ans = s1;\\n            if(s2.length() > ans.length()) ans = s2;\\n        }\\n\\n        return ans;\\n    }\\n\\n    string extend(string s, int left, int right){\\n        while(left >= 0 && right < s.length() && s[left] == s[right]){\\n            left--;\\n            right++;\\n        }\\n        return s.substr(left+1, right - left - 1);\\n    }\\n};"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "utkarshv2619",
                        "content": "//easy solution:\\n\\nclass Solution {\\npublic:\\n    string longestPalindrome(string s) {\\n        string res;\\n        int reslen = 0;\\n        \\n        if(s.size()<=1)\\n            return s; \\n        \\n        for(int i=0;i<s.size()-1;i++)\\n        {\\n            //odd length\\n            int l=i;\\n            int r=i;\\n            while(l>=0 && r<s.size() && s[l]==s[r])\\n            {\\n                if(r-l+1 > reslen  )\\n                {\\n                    res = s.substr(l, r-l+1);\\n                    reslen = r-l+1;\\n                }\\n                l--;\\n                r++;\\n            }\\n            //even length\\n            int L=i;\\n            int R=i+1;\\n            while(L>=0 && R<s.size() && s[L]==s[R])\\n            {\\n                if(R-L+1 > reslen)\\n                {\\n                    res = s.substr(L,R-L+1);\\n                    reslen = R-L+1;\\n                }\\n                L--;\\n                R++;\\n            }\\n        }\\n        return res;\\n    }\\n    \\n};"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "//Easy rules.\n\n💡 Discussion Rules\n1. Please don't post any solutions in this discussion.\n\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\n\n3. If you'd like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "codecat____",
                        "content": "I have \"Time Limit Exceeded\" problem here \nhow can i reduce running time in my code ?\n\ncode is given :\n\n\n\n\n\nclass Solution:\n    def longestPalindrome(self, s: str) -> str:\n        y=[]\n        x=[]\n        for i in range(len(s)):\n            for j in range(i+1,len(s)+1):\n                y.append(s[i:j])\n        for k in y:\n            if k == k[::-1]:\n                x.append(k)\n        w=[]\n        for v in x:\n            w.append(len(v))\n        if len(s)==1:\n            return s\n        for q in x:\n            if len(q)==max(w):\n                return(q)\n  "
                    },
                    {
                        "username": "noob-pika",
                        "content": "Check out the last two solutions in the solutions section of this question. The last one has a time complexity of O(n) but may take a while to understand whereas the second last one has a time complexity of O(n^2) but fairly easy"
                    },
                    {
                        "username": "Yongbi",
                        "content": "[@codecat____](/codecat____) Just use 2 pointer and reverse string that\\'s enough. I see that you have 5 loop in your algorithm!! It\\'s kind of too much, right?"
                    },
                    {
                        "username": "itanki3085",
                        "content": "Different result between LeetCode and my computer.\\nI got the result : `load of value 15, which is not a valid value for type \\'bool\\'`, but my code at that line is\\n```cpp\\ndp[from][to] = dp[from+1][to-1] && (s[from]==s[to]);\\n```\\nHow was that possible when I assign a boolean value into a address stores boolean value still get an error?\\nAt least it is not related to compiler. But what is the problem related to?"
                    },
                    {
                        "username": "Khudoyshukur",
                        "content": "Are we allowed to use class only? When I am writing without classes it is giving error: use of undeclared identifier \\'solution\\'. What should i do?"
                    }
                ]
            },
            {
                "id": 1722697,
                "content": [
                    {
                        "username": "Vinit_Anishkumar_Masrani",
                        "content": "When I submit, I get TLE error for the following test case:\nTime Limit Exceeded\nAnd it shows 141/141 testcases passed\nLast executed Input:\n s =\n\n\nWhat is the expected output for this testcase? And why is my code though passing big strings in testcase fails because of TLE in empty one."
                    },
                    {
                        "username": "DevPj09",
                        "content": "This is a bug. Happened with me too. I changed the browser and it worked. Might be due to network or cache.\\n"
                    },
                    {
                        "username": "TheCScience",
                        "content": "Here is problem solution in Java, Python, C++ and C programming.\\n[https://thecscience.com/leetcode-longest-palindromic-substring-problem-solution.html](https://thecscience.com/leetcode-longest-palindromic-substring-problem-solution.html)"
                    },
                    {
                        "username": "Shekhar_k_s",
                        "content": "My Solution was of O(n2) and final result is Time Limit Exceeded ( TLE ) . LOL \\uD83D\\uDE12\\n `void check(vector<vector<bool>> &v, int start, int end, string s, int &indexStart, int &indexEnd)\\n{\\n    if(s[start]==s[end])\\n    {\\n        if(v[start+1][end-1]==true)\\n        {\\n            v[start][end]=true;\\n            // cout<<start<<\" \"<<end<<endl;\\n            indexStart=start;\\n            indexEnd=end;\\n        }else\\n        {\\n            v[start][end]=false;\\n        }\\n    }\\n    else\\n    v[start][end]=false;\\n}\\n\\n\\n\\nclass Solution {\\npublic:\\n    string longestPalindrome(string s) {\\n        int len=s.length();\\n        int indexStart=0;\\n        int indexEnd=0;\\n        vector<vector<bool>> arr;\\n        for(int i=0;i<len;i++)\\n        {\\n            vector<bool> v(len);\\n            v[i]=true;\\n            arr.push_back(v);\\n        }\\n        for(int i=1;i<len;i++)\\n        {\\n            if(s[i-1]==s[i]){\\n                arr[i-1][i]=true;\\n                indexStart=i-1;\\n                indexEnd=i;\\n            }\\n            else\\n            arr[i-1][i]=false;\\n        }\\n        // cout<<indexStart<<\" \"<<indexEnd<<endl;\\n        int start=0;\\n        int end=2;\\n        while(end-start<=len)\\n        {\\n            while(end<len)\\n            {\\n                check(arr, start, end, s, indexStart, indexEnd);\\n                start++;\\n                end++;\\n            }\\n            int temp=end-start;\\n            temp++;\\n            start=0;\\n            end=temp;\\n        }\\n        string ans;\\n        for(int i=indexStart;i<=indexEnd;i++)\\n        {\\n            ans+=s[i];\\n        }\\n        // cout<<indexStart<<\" \"<<indexEnd<<endl;\\n        return ans;\\n    }\\n};`"
                    },
                    {
                        "username": "joshi248",
                        "content": "What is wrong here please tell\\n ```\\nclass Solution {\\npublic:\\n    bool isPalindrome(string strs){\\n        int n = strs.length();\\n        for(int i=0;i<n/2;++i){\\n            if(strs[i]!=strs[n-i-1]) return false;\\n        }\\n        return true;\\n    }\\n    string check(vector<string> &temp){\\n        string sruti = \"\";\\n        for(auto strs:temp){\\n            if(isPalindrome(strs)){\\n              if(strs.length() > sruti.length()) sruti = strs;\\n            }\\n        }\\n        return sruti;\\n    }\\n    string longestPalindrome(string s) {\\n        \\n        vector<string> temp;\\n        int n = s.length();\\n        if(n==1){\\n            if(isPalindrome(s)){\\n                return s;\\n            }\\n            return \"\";\\n        }\\n        for(int i=0;i<n;++i){\\n            for(int j=1;j<=n-i;++j){\\n                temp.push_back(s.substr(i,j));\\n            }\\n        }\\n        string ans = check(temp);\\n        return ans;\\n\\n\\n    }\\n};\\n```"
                    },
                    {
                        "username": "ayushi_828",
                        "content": "class Solution {\\n   int resultStart;\\n    int resultLength;\\n\\n    public String longestPalindrome(String s) {\\n        int strLength = s.length();\\n        if (strLength < 2) {\\n            return s;\\n        }\\n        for (int start = 0; start < strLength - 1; start++) {\\n            expandRange(s, start, start);\\n            expandRange(s, start, start + 1);\\n        }\\n        return s.substring(resultStart, resultStart + resultLength);\\n    }\\n\\n    private void expandRange(String str, int begin, int end) {\\n       while (begin >= 0 && end < str.length() &&\\n                    str.charAt(begin) == str.charAt(end)) {\\n            begin--;\\n            end++;\\n        }\\n       if (resultLength < end - begin - 1) {\\n            resultStart = begin + 1;\\n            resultLength = end - begin - 1;\\n        }\\n    }\\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "sukriti_sinha7",
                        "content": "class Solution {\\npublic:\\n    string longestPalindrome(string s) {\\n        string ans = \"\";\\n        for(int i = 0; i < s.length() ; i ++){\\n            string s1 = extend(s,i,i), s2 = extend(s, i, i+1);\\n\\n            if(s1.length() > ans.length()) ans = s1;\\n            if(s2.length() > ans.length()) ans = s2;\\n        }\\n\\n        return ans;\\n    }\\n\\n    string extend(string s, int left, int right){\\n        while(left >= 0 && right < s.length() && s[left] == s[right]){\\n            left--;\\n            right++;\\n        }\\n        return s.substr(left+1, right - left - 1);\\n    }\\n};"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "utkarshv2619",
                        "content": "//easy solution:\\n\\nclass Solution {\\npublic:\\n    string longestPalindrome(string s) {\\n        string res;\\n        int reslen = 0;\\n        \\n        if(s.size()<=1)\\n            return s; \\n        \\n        for(int i=0;i<s.size()-1;i++)\\n        {\\n            //odd length\\n            int l=i;\\n            int r=i;\\n            while(l>=0 && r<s.size() && s[l]==s[r])\\n            {\\n                if(r-l+1 > reslen  )\\n                {\\n                    res = s.substr(l, r-l+1);\\n                    reslen = r-l+1;\\n                }\\n                l--;\\n                r++;\\n            }\\n            //even length\\n            int L=i;\\n            int R=i+1;\\n            while(L>=0 && R<s.size() && s[L]==s[R])\\n            {\\n                if(R-L+1 > reslen)\\n                {\\n                    res = s.substr(L,R-L+1);\\n                    reslen = R-L+1;\\n                }\\n                L--;\\n                R++;\\n            }\\n        }\\n        return res;\\n    }\\n    \\n};"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "//Easy rules.\n\n💡 Discussion Rules\n1. Please don't post any solutions in this discussion.\n\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\n\n3. If you'd like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "codecat____",
                        "content": "I have \"Time Limit Exceeded\" problem here \nhow can i reduce running time in my code ?\n\ncode is given :\n\n\n\n\n\nclass Solution:\n    def longestPalindrome(self, s: str) -> str:\n        y=[]\n        x=[]\n        for i in range(len(s)):\n            for j in range(i+1,len(s)+1):\n                y.append(s[i:j])\n        for k in y:\n            if k == k[::-1]:\n                x.append(k)\n        w=[]\n        for v in x:\n            w.append(len(v))\n        if len(s)==1:\n            return s\n        for q in x:\n            if len(q)==max(w):\n                return(q)\n  "
                    },
                    {
                        "username": "noob-pika",
                        "content": "Check out the last two solutions in the solutions section of this question. The last one has a time complexity of O(n) but may take a while to understand whereas the second last one has a time complexity of O(n^2) but fairly easy"
                    },
                    {
                        "username": "Yongbi",
                        "content": "[@codecat____](/codecat____) Just use 2 pointer and reverse string that\\'s enough. I see that you have 5 loop in your algorithm!! It\\'s kind of too much, right?"
                    },
                    {
                        "username": "itanki3085",
                        "content": "Different result between LeetCode and my computer.\\nI got the result : `load of value 15, which is not a valid value for type \\'bool\\'`, but my code at that line is\\n```cpp\\ndp[from][to] = dp[from+1][to-1] && (s[from]==s[to]);\\n```\\nHow was that possible when I assign a boolean value into a address stores boolean value still get an error?\\nAt least it is not related to compiler. But what is the problem related to?"
                    },
                    {
                        "username": "Khudoyshukur",
                        "content": "Are we allowed to use class only? When I am writing without classes it is giving error: use of undeclared identifier \\'solution\\'. What should i do?"
                    }
                ]
            },
            {
                "id": 1719480,
                "content": [
                    {
                        "username": "Vinit_Anishkumar_Masrani",
                        "content": "When I submit, I get TLE error for the following test case:\nTime Limit Exceeded\nAnd it shows 141/141 testcases passed\nLast executed Input:\n s =\n\n\nWhat is the expected output for this testcase? And why is my code though passing big strings in testcase fails because of TLE in empty one."
                    },
                    {
                        "username": "DevPj09",
                        "content": "This is a bug. Happened with me too. I changed the browser and it worked. Might be due to network or cache.\\n"
                    },
                    {
                        "username": "TheCScience",
                        "content": "Here is problem solution in Java, Python, C++ and C programming.\\n[https://thecscience.com/leetcode-longest-palindromic-substring-problem-solution.html](https://thecscience.com/leetcode-longest-palindromic-substring-problem-solution.html)"
                    },
                    {
                        "username": "Shekhar_k_s",
                        "content": "My Solution was of O(n2) and final result is Time Limit Exceeded ( TLE ) . LOL \\uD83D\\uDE12\\n `void check(vector<vector<bool>> &v, int start, int end, string s, int &indexStart, int &indexEnd)\\n{\\n    if(s[start]==s[end])\\n    {\\n        if(v[start+1][end-1]==true)\\n        {\\n            v[start][end]=true;\\n            // cout<<start<<\" \"<<end<<endl;\\n            indexStart=start;\\n            indexEnd=end;\\n        }else\\n        {\\n            v[start][end]=false;\\n        }\\n    }\\n    else\\n    v[start][end]=false;\\n}\\n\\n\\n\\nclass Solution {\\npublic:\\n    string longestPalindrome(string s) {\\n        int len=s.length();\\n        int indexStart=0;\\n        int indexEnd=0;\\n        vector<vector<bool>> arr;\\n        for(int i=0;i<len;i++)\\n        {\\n            vector<bool> v(len);\\n            v[i]=true;\\n            arr.push_back(v);\\n        }\\n        for(int i=1;i<len;i++)\\n        {\\n            if(s[i-1]==s[i]){\\n                arr[i-1][i]=true;\\n                indexStart=i-1;\\n                indexEnd=i;\\n            }\\n            else\\n            arr[i-1][i]=false;\\n        }\\n        // cout<<indexStart<<\" \"<<indexEnd<<endl;\\n        int start=0;\\n        int end=2;\\n        while(end-start<=len)\\n        {\\n            while(end<len)\\n            {\\n                check(arr, start, end, s, indexStart, indexEnd);\\n                start++;\\n                end++;\\n            }\\n            int temp=end-start;\\n            temp++;\\n            start=0;\\n            end=temp;\\n        }\\n        string ans;\\n        for(int i=indexStart;i<=indexEnd;i++)\\n        {\\n            ans+=s[i];\\n        }\\n        // cout<<indexStart<<\" \"<<indexEnd<<endl;\\n        return ans;\\n    }\\n};`"
                    },
                    {
                        "username": "joshi248",
                        "content": "What is wrong here please tell\\n ```\\nclass Solution {\\npublic:\\n    bool isPalindrome(string strs){\\n        int n = strs.length();\\n        for(int i=0;i<n/2;++i){\\n            if(strs[i]!=strs[n-i-1]) return false;\\n        }\\n        return true;\\n    }\\n    string check(vector<string> &temp){\\n        string sruti = \"\";\\n        for(auto strs:temp){\\n            if(isPalindrome(strs)){\\n              if(strs.length() > sruti.length()) sruti = strs;\\n            }\\n        }\\n        return sruti;\\n    }\\n    string longestPalindrome(string s) {\\n        \\n        vector<string> temp;\\n        int n = s.length();\\n        if(n==1){\\n            if(isPalindrome(s)){\\n                return s;\\n            }\\n            return \"\";\\n        }\\n        for(int i=0;i<n;++i){\\n            for(int j=1;j<=n-i;++j){\\n                temp.push_back(s.substr(i,j));\\n            }\\n        }\\n        string ans = check(temp);\\n        return ans;\\n\\n\\n    }\\n};\\n```"
                    },
                    {
                        "username": "ayushi_828",
                        "content": "class Solution {\\n   int resultStart;\\n    int resultLength;\\n\\n    public String longestPalindrome(String s) {\\n        int strLength = s.length();\\n        if (strLength < 2) {\\n            return s;\\n        }\\n        for (int start = 0; start < strLength - 1; start++) {\\n            expandRange(s, start, start);\\n            expandRange(s, start, start + 1);\\n        }\\n        return s.substring(resultStart, resultStart + resultLength);\\n    }\\n\\n    private void expandRange(String str, int begin, int end) {\\n       while (begin >= 0 && end < str.length() &&\\n                    str.charAt(begin) == str.charAt(end)) {\\n            begin--;\\n            end++;\\n        }\\n       if (resultLength < end - begin - 1) {\\n            resultStart = begin + 1;\\n            resultLength = end - begin - 1;\\n        }\\n    }\\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "sukriti_sinha7",
                        "content": "class Solution {\\npublic:\\n    string longestPalindrome(string s) {\\n        string ans = \"\";\\n        for(int i = 0; i < s.length() ; i ++){\\n            string s1 = extend(s,i,i), s2 = extend(s, i, i+1);\\n\\n            if(s1.length() > ans.length()) ans = s1;\\n            if(s2.length() > ans.length()) ans = s2;\\n        }\\n\\n        return ans;\\n    }\\n\\n    string extend(string s, int left, int right){\\n        while(left >= 0 && right < s.length() && s[left] == s[right]){\\n            left--;\\n            right++;\\n        }\\n        return s.substr(left+1, right - left - 1);\\n    }\\n};"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "utkarshv2619",
                        "content": "//easy solution:\\n\\nclass Solution {\\npublic:\\n    string longestPalindrome(string s) {\\n        string res;\\n        int reslen = 0;\\n        \\n        if(s.size()<=1)\\n            return s; \\n        \\n        for(int i=0;i<s.size()-1;i++)\\n        {\\n            //odd length\\n            int l=i;\\n            int r=i;\\n            while(l>=0 && r<s.size() && s[l]==s[r])\\n            {\\n                if(r-l+1 > reslen  )\\n                {\\n                    res = s.substr(l, r-l+1);\\n                    reslen = r-l+1;\\n                }\\n                l--;\\n                r++;\\n            }\\n            //even length\\n            int L=i;\\n            int R=i+1;\\n            while(L>=0 && R<s.size() && s[L]==s[R])\\n            {\\n                if(R-L+1 > reslen)\\n                {\\n                    res = s.substr(L,R-L+1);\\n                    reslen = R-L+1;\\n                }\\n                L--;\\n                R++;\\n            }\\n        }\\n        return res;\\n    }\\n    \\n};"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "//Easy rules.\n\n💡 Discussion Rules\n1. Please don't post any solutions in this discussion.\n\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\n\n3. If you'd like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "codecat____",
                        "content": "I have \"Time Limit Exceeded\" problem here \nhow can i reduce running time in my code ?\n\ncode is given :\n\n\n\n\n\nclass Solution:\n    def longestPalindrome(self, s: str) -> str:\n        y=[]\n        x=[]\n        for i in range(len(s)):\n            for j in range(i+1,len(s)+1):\n                y.append(s[i:j])\n        for k in y:\n            if k == k[::-1]:\n                x.append(k)\n        w=[]\n        for v in x:\n            w.append(len(v))\n        if len(s)==1:\n            return s\n        for q in x:\n            if len(q)==max(w):\n                return(q)\n  "
                    },
                    {
                        "username": "noob-pika",
                        "content": "Check out the last two solutions in the solutions section of this question. The last one has a time complexity of O(n) but may take a while to understand whereas the second last one has a time complexity of O(n^2) but fairly easy"
                    },
                    {
                        "username": "Yongbi",
                        "content": "[@codecat____](/codecat____) Just use 2 pointer and reverse string that\\'s enough. I see that you have 5 loop in your algorithm!! It\\'s kind of too much, right?"
                    },
                    {
                        "username": "itanki3085",
                        "content": "Different result between LeetCode and my computer.\\nI got the result : `load of value 15, which is not a valid value for type \\'bool\\'`, but my code at that line is\\n```cpp\\ndp[from][to] = dp[from+1][to-1] && (s[from]==s[to]);\\n```\\nHow was that possible when I assign a boolean value into a address stores boolean value still get an error?\\nAt least it is not related to compiler. But what is the problem related to?"
                    },
                    {
                        "username": "Khudoyshukur",
                        "content": "Are we allowed to use class only? When I am writing without classes it is giving error: use of undeclared identifier \\'solution\\'. What should i do?"
                    }
                ]
            },
            {
                "id": 1719446,
                "content": [
                    {
                        "username": "divyaxreddy",
                        "content": "NICK WHITE'S code in C++ not working, can u please help?\n\n \n    string longestPalindrome(string s) {\n        int lenOfString = s.length();\n        int start = 0, end = 0;\n       for(int i = 0; i<lenOfString; i++){\n           int len1 = expandFromMid(s, i, i);\n           int len2 = expandFromMid(s, i, i+1);\n\n           int maxlength = max(len1, len2);\n           //check if maxLength is > old length\n           if(maxlength > (end - start)){\n                start = i - ((maxlength-1)/2);\n                end = i + (maxlength/2);\n           }\n       }\n       return s.substr(start, end+1);\n    }\n\n    int expandFromMid(string& s, int i, int j){\n        if( left > right) return 0;\n        int left = i, right = j;\n        while(left >=0 && right <s.length() && (s[left] == s[right])){\n            left--;\n            right++;\n        }\n\n        return right - left + 1;\n    }\n};`"
                    },
                    {
                        "username": "BaconChef",
                        "content": "[HELP]  \\nHow is \\nInput: s = \"babad\"\\nOutput: \"bab\"\\n\\n\"badab\" or \"abdba\" is both palindromic (the same read forwards and backwards) and a substring. And its obviously longer than \"bab\". For that matter, why isn\\'t \"baab\" accepted?\\n\\nMy definitions:\\nA palindrome is a string that is the same if it\\'s read forward and backward.\\nA substring is a string that rearranges or omits characters of a string."
                    },
                    {
                        "username": "Yongbi",
                        "content": "[@BaconChef](/BaconChef)\nHello, let's see your substring definition? \nGiven:\ns = \"babad\"\n\nSubstring palindromic: any characters \"a\", \"b\", \"d\", and \"bab\", \"aba\".\nBut \"baab\" is not a substring of s!"
                    },
                    {
                        "username": "zuratvaradze999",
                        "content": "swift"
                    },
                    {
                        "username": "Violet-",
                        "content": "Could anybody please explain what does this sentence mean (by an example) in the first solution with Longest common subsequence? \"To rectify this, each time we find a longest common substring candidate, we check if the substring\\u2019s indices are the same as the reversed substring\\u2019s original indices.\""
                    },
                    {
                        "username": "parialxx",
                        "content": "Does anyone understand why do I get this error message in the Longest Palindromic substring problem?\n\n\nAddressSanitizer:DEADLYSIGNAL 31\nERROR: AddressSanitizer: SEGV on unknown address 0x7ffd1cc2ec5f (pc 0x0000003447b6 bp 0x7ffc1cc2eab0 sp 0x7ffc1cc2ea90 T0)\n==31==The signal is caused by a READ memory access.\n    #4 0x7fb759d300b2  (/lib/x86_64-linux-gnu/libc.so.6+0x270b2)\nAddressSanitizer can not provide additional info.\n31 ABORTING\n\n\nThis is my code...\n\n`#include <string>\n#include <iostream>\n\nusing namespace std;\n\nclass Solution {\npublic:\n\n    string expandString(string s, unsigned int l, unsigned int r) {\n        while(l >= 0 && r < s.size() && s[l] == s[r]) {\n            l--;\n            r++;\n        }\n        return s.substr(l+1, r-(l+1));\n    }\n\n    string longestPalindrome(string s) {\n        string odd = \"\";\n        string even = \"\";\n        string res = \"\";\n\n        for(unsigned int i = 0; i < s.size(); i++) {\n            even = expandString(s, i, i+1);\n            odd = expandString(s, i, i);\n            \n            if(even.size() > res.size()) {\n                res = even;\n            }\n            if(odd.size() > res.size()) {\n                res = odd;\n            }\n        }\n        return res;\n    }\n\n};`"
                    },
                    {
                        "username": "dnd_Hyani69",
                        "content": "//Simple CPP Soluion//\\n\\nclass Solution {\\npublic:\\n    string longestPalindrome(string s) {\\n       int maxlen=1,start=0;\\n     for(int i=1;i<s.length();i++){//1 se chlao\\n         //that is even substring\\n         int l=i-1;\\n         int r=i;\\n         \\n         while(l >= 0 && r<s.length() && s[l]==s[r]){//l chota ho r bada ho and l==r ho bss\\n             if(r-l+1 > maxlen) {\\n             maxlen=r-l+1;\\n              start=l;\\n             }\\n        l--;\\n        r++;\\n         }\\n      //for odd substring \\n       l=i-1;\\n       r=i+1;\\n     \\n     while(l >=0 && r<s.length() && s[l]==s[r]){\\n         if(r-l+1 > maxlen){\\n         maxlen=r-l+1;\\n         start=l;\\n         }\\n         l--;\\n         r++;\\n     }\\n     }\\n     return s.substr(start, maxlen);\\n    }\\n}; "
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Simple rules.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "meetfarhanali",
                        "content": "The leetcode problems sucks. This is my 2nd problem and i see the description is not right. \\nFor babac the longest palindrom will be \"baba\"=\"abab\". I will switch to HRank problems as they make more sense"
                    },
                    {
                        "username": "dhtmlkitchen",
                        "content": "\"baba\" is not a palendrome.\n\nA Palendrome is a series of characters that is the same forwards and backwards.\n\n\"baba\" backwards is \"abab\". \"baba\" != \"abab\". Thus, \"baba\" is not a palendrome.\n\nTry an easier problem. 125. Valid Palindrome\nhttps://leetcode.com/problems/valid-palindrome/\n"
                    },
                    {
                        "username": "Navin152",
                        "content": "\\nmy code is not working in java can anyone explain please why this code is not working\\n\\nclass Solution {\\n    public String longestPalindrome(String s) {\\n        int n=s.length();\\n        int low,high;\\n        int st=0;\\n        int len=1;\\n        for(int i=1;i<n;i++){\\n            //Even\\n            low=i;\\n            high=i-1;\\n            while(low>=0 && high <n && s[low] == s[high]){\\n                if(high-low+1>len){\\n                    st=low;\\n                    len = high-low+1;\\n                }\\n                low--;high++;\\n                }\\n         //odd\\n            low=i-1;\\n            high=i+1;\\n            while(low>=0 && high<n &&s.charAt(low)== s.charAt(high)){\\n                {\\n                    if(high-low+1>len){\\n                        st=low;\\n                        len= high-low+1;\\n                        }\\n                     low--;\\n                     high++;\\n}\\n}\\n               return  s.substring(st,len);\\n                }   \\n            } \\n           \\n\\n    \\n        \\n\\n"
                    },
                    {
                        "username": "Rajdip_234",
                        "content": " Hi, in this program first we divide the string one is even length and another is odd length and we pass parameter using one function that is string and middle point value then we check the length in both string . If the difference between end and start is less than length of string then we should update start and end value and return the substring value. then again we pass parameter in function which we will declare as our wish and pass string , i value , j value . taking while loop the put the condition i greater than or equals to zero and j should be less than the length of string and the ith value of string is equals to the jth value of string then i will be decremented and j incremented and finally return the value that is (j-i+1)."
                    },
                    {
                        "username": "allgameaimbotall",
                        "content": "Hi I haven't studied Dynamic Programming till now but learned a littlebit about memoization. I tried to solve this problem with recursion + adding memoization .\n\nCode gives exactly what we want but off-course Time-Limit issues.\n\nJust want to ask where does this approach fail?\n\n`\ndp = {}\ndef longestPalindrome(self, s: str) -> str:\nif self.dp.get(s) != None:\n    return self.dp[s]\n\n#TRACKERS\nlenStr = len(s)\n\n#BASE\nif lenStr == 1:\n    self.dp[s] = s\n    return s\n\nif s == s[::-1]:\n    self.dp[s] = s\n    return s\nelse:\n    lp_inleft = self.longestPalindrome(s[1:])\n    lp_inright = self.longestPalindrome(s[:lenStr-1])\n    ans = max(lp_inleft,lp_inright,key=len)\n    self.dp[s] = ans\n    return ans\n        `\n\n        "
                    }
                ]
            },
            {
                "id": 1718435,
                "content": [
                    {
                        "username": "divyaxreddy",
                        "content": "NICK WHITE'S code in C++ not working, can u please help?\n\n \n    string longestPalindrome(string s) {\n        int lenOfString = s.length();\n        int start = 0, end = 0;\n       for(int i = 0; i<lenOfString; i++){\n           int len1 = expandFromMid(s, i, i);\n           int len2 = expandFromMid(s, i, i+1);\n\n           int maxlength = max(len1, len2);\n           //check if maxLength is > old length\n           if(maxlength > (end - start)){\n                start = i - ((maxlength-1)/2);\n                end = i + (maxlength/2);\n           }\n       }\n       return s.substr(start, end+1);\n    }\n\n    int expandFromMid(string& s, int i, int j){\n        if( left > right) return 0;\n        int left = i, right = j;\n        while(left >=0 && right <s.length() && (s[left] == s[right])){\n            left--;\n            right++;\n        }\n\n        return right - left + 1;\n    }\n};`"
                    },
                    {
                        "username": "BaconChef",
                        "content": "[HELP]  \\nHow is \\nInput: s = \"babad\"\\nOutput: \"bab\"\\n\\n\"badab\" or \"abdba\" is both palindromic (the same read forwards and backwards) and a substring. And its obviously longer than \"bab\". For that matter, why isn\\'t \"baab\" accepted?\\n\\nMy definitions:\\nA palindrome is a string that is the same if it\\'s read forward and backward.\\nA substring is a string that rearranges or omits characters of a string."
                    },
                    {
                        "username": "Yongbi",
                        "content": "[@BaconChef](/BaconChef)\nHello, let's see your substring definition? \nGiven:\ns = \"babad\"\n\nSubstring palindromic: any characters \"a\", \"b\", \"d\", and \"bab\", \"aba\".\nBut \"baab\" is not a substring of s!"
                    },
                    {
                        "username": "zuratvaradze999",
                        "content": "swift"
                    },
                    {
                        "username": "Violet-",
                        "content": "Could anybody please explain what does this sentence mean (by an example) in the first solution with Longest common subsequence? \"To rectify this, each time we find a longest common substring candidate, we check if the substring\\u2019s indices are the same as the reversed substring\\u2019s original indices.\""
                    },
                    {
                        "username": "parialxx",
                        "content": "Does anyone understand why do I get this error message in the Longest Palindromic substring problem?\n\n\nAddressSanitizer:DEADLYSIGNAL 31\nERROR: AddressSanitizer: SEGV on unknown address 0x7ffd1cc2ec5f (pc 0x0000003447b6 bp 0x7ffc1cc2eab0 sp 0x7ffc1cc2ea90 T0)\n==31==The signal is caused by a READ memory access.\n    #4 0x7fb759d300b2  (/lib/x86_64-linux-gnu/libc.so.6+0x270b2)\nAddressSanitizer can not provide additional info.\n31 ABORTING\n\n\nThis is my code...\n\n`#include <string>\n#include <iostream>\n\nusing namespace std;\n\nclass Solution {\npublic:\n\n    string expandString(string s, unsigned int l, unsigned int r) {\n        while(l >= 0 && r < s.size() && s[l] == s[r]) {\n            l--;\n            r++;\n        }\n        return s.substr(l+1, r-(l+1));\n    }\n\n    string longestPalindrome(string s) {\n        string odd = \"\";\n        string even = \"\";\n        string res = \"\";\n\n        for(unsigned int i = 0; i < s.size(); i++) {\n            even = expandString(s, i, i+1);\n            odd = expandString(s, i, i);\n            \n            if(even.size() > res.size()) {\n                res = even;\n            }\n            if(odd.size() > res.size()) {\n                res = odd;\n            }\n        }\n        return res;\n    }\n\n};`"
                    },
                    {
                        "username": "dnd_Hyani69",
                        "content": "//Simple CPP Soluion//\\n\\nclass Solution {\\npublic:\\n    string longestPalindrome(string s) {\\n       int maxlen=1,start=0;\\n     for(int i=1;i<s.length();i++){//1 se chlao\\n         //that is even substring\\n         int l=i-1;\\n         int r=i;\\n         \\n         while(l >= 0 && r<s.length() && s[l]==s[r]){//l chota ho r bada ho and l==r ho bss\\n             if(r-l+1 > maxlen) {\\n             maxlen=r-l+1;\\n              start=l;\\n             }\\n        l--;\\n        r++;\\n         }\\n      //for odd substring \\n       l=i-1;\\n       r=i+1;\\n     \\n     while(l >=0 && r<s.length() && s[l]==s[r]){\\n         if(r-l+1 > maxlen){\\n         maxlen=r-l+1;\\n         start=l;\\n         }\\n         l--;\\n         r++;\\n     }\\n     }\\n     return s.substr(start, maxlen);\\n    }\\n}; "
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Simple rules.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "meetfarhanali",
                        "content": "The leetcode problems sucks. This is my 2nd problem and i see the description is not right. \\nFor babac the longest palindrom will be \"baba\"=\"abab\". I will switch to HRank problems as they make more sense"
                    },
                    {
                        "username": "dhtmlkitchen",
                        "content": "\"baba\" is not a palendrome.\n\nA Palendrome is a series of characters that is the same forwards and backwards.\n\n\"baba\" backwards is \"abab\". \"baba\" != \"abab\". Thus, \"baba\" is not a palendrome.\n\nTry an easier problem. 125. Valid Palindrome\nhttps://leetcode.com/problems/valid-palindrome/\n"
                    },
                    {
                        "username": "Navin152",
                        "content": "\\nmy code is not working in java can anyone explain please why this code is not working\\n\\nclass Solution {\\n    public String longestPalindrome(String s) {\\n        int n=s.length();\\n        int low,high;\\n        int st=0;\\n        int len=1;\\n        for(int i=1;i<n;i++){\\n            //Even\\n            low=i;\\n            high=i-1;\\n            while(low>=0 && high <n && s[low] == s[high]){\\n                if(high-low+1>len){\\n                    st=low;\\n                    len = high-low+1;\\n                }\\n                low--;high++;\\n                }\\n         //odd\\n            low=i-1;\\n            high=i+1;\\n            while(low>=0 && high<n &&s.charAt(low)== s.charAt(high)){\\n                {\\n                    if(high-low+1>len){\\n                        st=low;\\n                        len= high-low+1;\\n                        }\\n                     low--;\\n                     high++;\\n}\\n}\\n               return  s.substring(st,len);\\n                }   \\n            } \\n           \\n\\n    \\n        \\n\\n"
                    },
                    {
                        "username": "Rajdip_234",
                        "content": " Hi, in this program first we divide the string one is even length and another is odd length and we pass parameter using one function that is string and middle point value then we check the length in both string . If the difference between end and start is less than length of string then we should update start and end value and return the substring value. then again we pass parameter in function which we will declare as our wish and pass string , i value , j value . taking while loop the put the condition i greater than or equals to zero and j should be less than the length of string and the ith value of string is equals to the jth value of string then i will be decremented and j incremented and finally return the value that is (j-i+1)."
                    },
                    {
                        "username": "allgameaimbotall",
                        "content": "Hi I haven't studied Dynamic Programming till now but learned a littlebit about memoization. I tried to solve this problem with recursion + adding memoization .\n\nCode gives exactly what we want but off-course Time-Limit issues.\n\nJust want to ask where does this approach fail?\n\n`\ndp = {}\ndef longestPalindrome(self, s: str) -> str:\nif self.dp.get(s) != None:\n    return self.dp[s]\n\n#TRACKERS\nlenStr = len(s)\n\n#BASE\nif lenStr == 1:\n    self.dp[s] = s\n    return s\n\nif s == s[::-1]:\n    self.dp[s] = s\n    return s\nelse:\n    lp_inleft = self.longestPalindrome(s[1:])\n    lp_inright = self.longestPalindrome(s[:lenStr-1])\n    ans = max(lp_inleft,lp_inright,key=len)\n    self.dp[s] = ans\n    return ans\n        `\n\n        "
                    }
                ]
            },
            {
                "id": 1716422,
                "content": [
                    {
                        "username": "divyaxreddy",
                        "content": "NICK WHITE'S code in C++ not working, can u please help?\n\n \n    string longestPalindrome(string s) {\n        int lenOfString = s.length();\n        int start = 0, end = 0;\n       for(int i = 0; i<lenOfString; i++){\n           int len1 = expandFromMid(s, i, i);\n           int len2 = expandFromMid(s, i, i+1);\n\n           int maxlength = max(len1, len2);\n           //check if maxLength is > old length\n           if(maxlength > (end - start)){\n                start = i - ((maxlength-1)/2);\n                end = i + (maxlength/2);\n           }\n       }\n       return s.substr(start, end+1);\n    }\n\n    int expandFromMid(string& s, int i, int j){\n        if( left > right) return 0;\n        int left = i, right = j;\n        while(left >=0 && right <s.length() && (s[left] == s[right])){\n            left--;\n            right++;\n        }\n\n        return right - left + 1;\n    }\n};`"
                    },
                    {
                        "username": "BaconChef",
                        "content": "[HELP]  \\nHow is \\nInput: s = \"babad\"\\nOutput: \"bab\"\\n\\n\"badab\" or \"abdba\" is both palindromic (the same read forwards and backwards) and a substring. And its obviously longer than \"bab\". For that matter, why isn\\'t \"baab\" accepted?\\n\\nMy definitions:\\nA palindrome is a string that is the same if it\\'s read forward and backward.\\nA substring is a string that rearranges or omits characters of a string."
                    },
                    {
                        "username": "Yongbi",
                        "content": "[@BaconChef](/BaconChef)\nHello, let's see your substring definition? \nGiven:\ns = \"babad\"\n\nSubstring palindromic: any characters \"a\", \"b\", \"d\", and \"bab\", \"aba\".\nBut \"baab\" is not a substring of s!"
                    },
                    {
                        "username": "zuratvaradze999",
                        "content": "swift"
                    },
                    {
                        "username": "Violet-",
                        "content": "Could anybody please explain what does this sentence mean (by an example) in the first solution with Longest common subsequence? \"To rectify this, each time we find a longest common substring candidate, we check if the substring\\u2019s indices are the same as the reversed substring\\u2019s original indices.\""
                    },
                    {
                        "username": "parialxx",
                        "content": "Does anyone understand why do I get this error message in the Longest Palindromic substring problem?\n\n\nAddressSanitizer:DEADLYSIGNAL 31\nERROR: AddressSanitizer: SEGV on unknown address 0x7ffd1cc2ec5f (pc 0x0000003447b6 bp 0x7ffc1cc2eab0 sp 0x7ffc1cc2ea90 T0)\n==31==The signal is caused by a READ memory access.\n    #4 0x7fb759d300b2  (/lib/x86_64-linux-gnu/libc.so.6+0x270b2)\nAddressSanitizer can not provide additional info.\n31 ABORTING\n\n\nThis is my code...\n\n`#include <string>\n#include <iostream>\n\nusing namespace std;\n\nclass Solution {\npublic:\n\n    string expandString(string s, unsigned int l, unsigned int r) {\n        while(l >= 0 && r < s.size() && s[l] == s[r]) {\n            l--;\n            r++;\n        }\n        return s.substr(l+1, r-(l+1));\n    }\n\n    string longestPalindrome(string s) {\n        string odd = \"\";\n        string even = \"\";\n        string res = \"\";\n\n        for(unsigned int i = 0; i < s.size(); i++) {\n            even = expandString(s, i, i+1);\n            odd = expandString(s, i, i);\n            \n            if(even.size() > res.size()) {\n                res = even;\n            }\n            if(odd.size() > res.size()) {\n                res = odd;\n            }\n        }\n        return res;\n    }\n\n};`"
                    },
                    {
                        "username": "dnd_Hyani69",
                        "content": "//Simple CPP Soluion//\\n\\nclass Solution {\\npublic:\\n    string longestPalindrome(string s) {\\n       int maxlen=1,start=0;\\n     for(int i=1;i<s.length();i++){//1 se chlao\\n         //that is even substring\\n         int l=i-1;\\n         int r=i;\\n         \\n         while(l >= 0 && r<s.length() && s[l]==s[r]){//l chota ho r bada ho and l==r ho bss\\n             if(r-l+1 > maxlen) {\\n             maxlen=r-l+1;\\n              start=l;\\n             }\\n        l--;\\n        r++;\\n         }\\n      //for odd substring \\n       l=i-1;\\n       r=i+1;\\n     \\n     while(l >=0 && r<s.length() && s[l]==s[r]){\\n         if(r-l+1 > maxlen){\\n         maxlen=r-l+1;\\n         start=l;\\n         }\\n         l--;\\n         r++;\\n     }\\n     }\\n     return s.substr(start, maxlen);\\n    }\\n}; "
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Simple rules.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "meetfarhanali",
                        "content": "The leetcode problems sucks. This is my 2nd problem and i see the description is not right. \\nFor babac the longest palindrom will be \"baba\"=\"abab\". I will switch to HRank problems as they make more sense"
                    },
                    {
                        "username": "dhtmlkitchen",
                        "content": "\"baba\" is not a palendrome.\n\nA Palendrome is a series of characters that is the same forwards and backwards.\n\n\"baba\" backwards is \"abab\". \"baba\" != \"abab\". Thus, \"baba\" is not a palendrome.\n\nTry an easier problem. 125. Valid Palindrome\nhttps://leetcode.com/problems/valid-palindrome/\n"
                    },
                    {
                        "username": "Navin152",
                        "content": "\\nmy code is not working in java can anyone explain please why this code is not working\\n\\nclass Solution {\\n    public String longestPalindrome(String s) {\\n        int n=s.length();\\n        int low,high;\\n        int st=0;\\n        int len=1;\\n        for(int i=1;i<n;i++){\\n            //Even\\n            low=i;\\n            high=i-1;\\n            while(low>=0 && high <n && s[low] == s[high]){\\n                if(high-low+1>len){\\n                    st=low;\\n                    len = high-low+1;\\n                }\\n                low--;high++;\\n                }\\n         //odd\\n            low=i-1;\\n            high=i+1;\\n            while(low>=0 && high<n &&s.charAt(low)== s.charAt(high)){\\n                {\\n                    if(high-low+1>len){\\n                        st=low;\\n                        len= high-low+1;\\n                        }\\n                     low--;\\n                     high++;\\n}\\n}\\n               return  s.substring(st,len);\\n                }   \\n            } \\n           \\n\\n    \\n        \\n\\n"
                    },
                    {
                        "username": "Rajdip_234",
                        "content": " Hi, in this program first we divide the string one is even length and another is odd length and we pass parameter using one function that is string and middle point value then we check the length in both string . If the difference between end and start is less than length of string then we should update start and end value and return the substring value. then again we pass parameter in function which we will declare as our wish and pass string , i value , j value . taking while loop the put the condition i greater than or equals to zero and j should be less than the length of string and the ith value of string is equals to the jth value of string then i will be decremented and j incremented and finally return the value that is (j-i+1)."
                    },
                    {
                        "username": "allgameaimbotall",
                        "content": "Hi I haven't studied Dynamic Programming till now but learned a littlebit about memoization. I tried to solve this problem with recursion + adding memoization .\n\nCode gives exactly what we want but off-course Time-Limit issues.\n\nJust want to ask where does this approach fail?\n\n`\ndp = {}\ndef longestPalindrome(self, s: str) -> str:\nif self.dp.get(s) != None:\n    return self.dp[s]\n\n#TRACKERS\nlenStr = len(s)\n\n#BASE\nif lenStr == 1:\n    self.dp[s] = s\n    return s\n\nif s == s[::-1]:\n    self.dp[s] = s\n    return s\nelse:\n    lp_inleft = self.longestPalindrome(s[1:])\n    lp_inright = self.longestPalindrome(s[:lenStr-1])\n    ans = max(lp_inleft,lp_inright,key=len)\n    self.dp[s] = ans\n    return ans\n        `\n\n        "
                    }
                ]
            },
            {
                "id": 1715631,
                "content": [
                    {
                        "username": "divyaxreddy",
                        "content": "NICK WHITE'S code in C++ not working, can u please help?\n\n \n    string longestPalindrome(string s) {\n        int lenOfString = s.length();\n        int start = 0, end = 0;\n       for(int i = 0; i<lenOfString; i++){\n           int len1 = expandFromMid(s, i, i);\n           int len2 = expandFromMid(s, i, i+1);\n\n           int maxlength = max(len1, len2);\n           //check if maxLength is > old length\n           if(maxlength > (end - start)){\n                start = i - ((maxlength-1)/2);\n                end = i + (maxlength/2);\n           }\n       }\n       return s.substr(start, end+1);\n    }\n\n    int expandFromMid(string& s, int i, int j){\n        if( left > right) return 0;\n        int left = i, right = j;\n        while(left >=0 && right <s.length() && (s[left] == s[right])){\n            left--;\n            right++;\n        }\n\n        return right - left + 1;\n    }\n};`"
                    },
                    {
                        "username": "BaconChef",
                        "content": "[HELP]  \\nHow is \\nInput: s = \"babad\"\\nOutput: \"bab\"\\n\\n\"badab\" or \"abdba\" is both palindromic (the same read forwards and backwards) and a substring. And its obviously longer than \"bab\". For that matter, why isn\\'t \"baab\" accepted?\\n\\nMy definitions:\\nA palindrome is a string that is the same if it\\'s read forward and backward.\\nA substring is a string that rearranges or omits characters of a string."
                    },
                    {
                        "username": "Yongbi",
                        "content": "[@BaconChef](/BaconChef)\nHello, let's see your substring definition? \nGiven:\ns = \"babad\"\n\nSubstring palindromic: any characters \"a\", \"b\", \"d\", and \"bab\", \"aba\".\nBut \"baab\" is not a substring of s!"
                    },
                    {
                        "username": "zuratvaradze999",
                        "content": "swift"
                    },
                    {
                        "username": "Violet-",
                        "content": "Could anybody please explain what does this sentence mean (by an example) in the first solution with Longest common subsequence? \"To rectify this, each time we find a longest common substring candidate, we check if the substring\\u2019s indices are the same as the reversed substring\\u2019s original indices.\""
                    },
                    {
                        "username": "parialxx",
                        "content": "Does anyone understand why do I get this error message in the Longest Palindromic substring problem?\n\n\nAddressSanitizer:DEADLYSIGNAL 31\nERROR: AddressSanitizer: SEGV on unknown address 0x7ffd1cc2ec5f (pc 0x0000003447b6 bp 0x7ffc1cc2eab0 sp 0x7ffc1cc2ea90 T0)\n==31==The signal is caused by a READ memory access.\n    #4 0x7fb759d300b2  (/lib/x86_64-linux-gnu/libc.so.6+0x270b2)\nAddressSanitizer can not provide additional info.\n31 ABORTING\n\n\nThis is my code...\n\n`#include <string>\n#include <iostream>\n\nusing namespace std;\n\nclass Solution {\npublic:\n\n    string expandString(string s, unsigned int l, unsigned int r) {\n        while(l >= 0 && r < s.size() && s[l] == s[r]) {\n            l--;\n            r++;\n        }\n        return s.substr(l+1, r-(l+1));\n    }\n\n    string longestPalindrome(string s) {\n        string odd = \"\";\n        string even = \"\";\n        string res = \"\";\n\n        for(unsigned int i = 0; i < s.size(); i++) {\n            even = expandString(s, i, i+1);\n            odd = expandString(s, i, i);\n            \n            if(even.size() > res.size()) {\n                res = even;\n            }\n            if(odd.size() > res.size()) {\n                res = odd;\n            }\n        }\n        return res;\n    }\n\n};`"
                    },
                    {
                        "username": "dnd_Hyani69",
                        "content": "//Simple CPP Soluion//\\n\\nclass Solution {\\npublic:\\n    string longestPalindrome(string s) {\\n       int maxlen=1,start=0;\\n     for(int i=1;i<s.length();i++){//1 se chlao\\n         //that is even substring\\n         int l=i-1;\\n         int r=i;\\n         \\n         while(l >= 0 && r<s.length() && s[l]==s[r]){//l chota ho r bada ho and l==r ho bss\\n             if(r-l+1 > maxlen) {\\n             maxlen=r-l+1;\\n              start=l;\\n             }\\n        l--;\\n        r++;\\n         }\\n      //for odd substring \\n       l=i-1;\\n       r=i+1;\\n     \\n     while(l >=0 && r<s.length() && s[l]==s[r]){\\n         if(r-l+1 > maxlen){\\n         maxlen=r-l+1;\\n         start=l;\\n         }\\n         l--;\\n         r++;\\n     }\\n     }\\n     return s.substr(start, maxlen);\\n    }\\n}; "
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Simple rules.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "meetfarhanali",
                        "content": "The leetcode problems sucks. This is my 2nd problem and i see the description is not right. \\nFor babac the longest palindrom will be \"baba\"=\"abab\". I will switch to HRank problems as they make more sense"
                    },
                    {
                        "username": "dhtmlkitchen",
                        "content": "\"baba\" is not a palendrome.\n\nA Palendrome is a series of characters that is the same forwards and backwards.\n\n\"baba\" backwards is \"abab\". \"baba\" != \"abab\". Thus, \"baba\" is not a palendrome.\n\nTry an easier problem. 125. Valid Palindrome\nhttps://leetcode.com/problems/valid-palindrome/\n"
                    },
                    {
                        "username": "Navin152",
                        "content": "\\nmy code is not working in java can anyone explain please why this code is not working\\n\\nclass Solution {\\n    public String longestPalindrome(String s) {\\n        int n=s.length();\\n        int low,high;\\n        int st=0;\\n        int len=1;\\n        for(int i=1;i<n;i++){\\n            //Even\\n            low=i;\\n            high=i-1;\\n            while(low>=0 && high <n && s[low] == s[high]){\\n                if(high-low+1>len){\\n                    st=low;\\n                    len = high-low+1;\\n                }\\n                low--;high++;\\n                }\\n         //odd\\n            low=i-1;\\n            high=i+1;\\n            while(low>=0 && high<n &&s.charAt(low)== s.charAt(high)){\\n                {\\n                    if(high-low+1>len){\\n                        st=low;\\n                        len= high-low+1;\\n                        }\\n                     low--;\\n                     high++;\\n}\\n}\\n               return  s.substring(st,len);\\n                }   \\n            } \\n           \\n\\n    \\n        \\n\\n"
                    },
                    {
                        "username": "Rajdip_234",
                        "content": " Hi, in this program first we divide the string one is even length and another is odd length and we pass parameter using one function that is string and middle point value then we check the length in both string . If the difference between end and start is less than length of string then we should update start and end value and return the substring value. then again we pass parameter in function which we will declare as our wish and pass string , i value , j value . taking while loop the put the condition i greater than or equals to zero and j should be less than the length of string and the ith value of string is equals to the jth value of string then i will be decremented and j incremented and finally return the value that is (j-i+1)."
                    },
                    {
                        "username": "allgameaimbotall",
                        "content": "Hi I haven't studied Dynamic Programming till now but learned a littlebit about memoization. I tried to solve this problem with recursion + adding memoization .\n\nCode gives exactly what we want but off-course Time-Limit issues.\n\nJust want to ask where does this approach fail?\n\n`\ndp = {}\ndef longestPalindrome(self, s: str) -> str:\nif self.dp.get(s) != None:\n    return self.dp[s]\n\n#TRACKERS\nlenStr = len(s)\n\n#BASE\nif lenStr == 1:\n    self.dp[s] = s\n    return s\n\nif s == s[::-1]:\n    self.dp[s] = s\n    return s\nelse:\n    lp_inleft = self.longestPalindrome(s[1:])\n    lp_inright = self.longestPalindrome(s[:lenStr-1])\n    ans = max(lp_inleft,lp_inright,key=len)\n    self.dp[s] = ans\n    return ans\n        `\n\n        "
                    }
                ]
            },
            {
                "id": 1714511,
                "content": [
                    {
                        "username": "divyaxreddy",
                        "content": "NICK WHITE'S code in C++ not working, can u please help?\n\n \n    string longestPalindrome(string s) {\n        int lenOfString = s.length();\n        int start = 0, end = 0;\n       for(int i = 0; i<lenOfString; i++){\n           int len1 = expandFromMid(s, i, i);\n           int len2 = expandFromMid(s, i, i+1);\n\n           int maxlength = max(len1, len2);\n           //check if maxLength is > old length\n           if(maxlength > (end - start)){\n                start = i - ((maxlength-1)/2);\n                end = i + (maxlength/2);\n           }\n       }\n       return s.substr(start, end+1);\n    }\n\n    int expandFromMid(string& s, int i, int j){\n        if( left > right) return 0;\n        int left = i, right = j;\n        while(left >=0 && right <s.length() && (s[left] == s[right])){\n            left--;\n            right++;\n        }\n\n        return right - left + 1;\n    }\n};`"
                    },
                    {
                        "username": "BaconChef",
                        "content": "[HELP]  \\nHow is \\nInput: s = \"babad\"\\nOutput: \"bab\"\\n\\n\"badab\" or \"abdba\" is both palindromic (the same read forwards and backwards) and a substring. And its obviously longer than \"bab\". For that matter, why isn\\'t \"baab\" accepted?\\n\\nMy definitions:\\nA palindrome is a string that is the same if it\\'s read forward and backward.\\nA substring is a string that rearranges or omits characters of a string."
                    },
                    {
                        "username": "Yongbi",
                        "content": "[@BaconChef](/BaconChef)\nHello, let's see your substring definition? \nGiven:\ns = \"babad\"\n\nSubstring palindromic: any characters \"a\", \"b\", \"d\", and \"bab\", \"aba\".\nBut \"baab\" is not a substring of s!"
                    },
                    {
                        "username": "zuratvaradze999",
                        "content": "swift"
                    },
                    {
                        "username": "Violet-",
                        "content": "Could anybody please explain what does this sentence mean (by an example) in the first solution with Longest common subsequence? \"To rectify this, each time we find a longest common substring candidate, we check if the substring\\u2019s indices are the same as the reversed substring\\u2019s original indices.\""
                    },
                    {
                        "username": "parialxx",
                        "content": "Does anyone understand why do I get this error message in the Longest Palindromic substring problem?\n\n\nAddressSanitizer:DEADLYSIGNAL 31\nERROR: AddressSanitizer: SEGV on unknown address 0x7ffd1cc2ec5f (pc 0x0000003447b6 bp 0x7ffc1cc2eab0 sp 0x7ffc1cc2ea90 T0)\n==31==The signal is caused by a READ memory access.\n    #4 0x7fb759d300b2  (/lib/x86_64-linux-gnu/libc.so.6+0x270b2)\nAddressSanitizer can not provide additional info.\n31 ABORTING\n\n\nThis is my code...\n\n`#include <string>\n#include <iostream>\n\nusing namespace std;\n\nclass Solution {\npublic:\n\n    string expandString(string s, unsigned int l, unsigned int r) {\n        while(l >= 0 && r < s.size() && s[l] == s[r]) {\n            l--;\n            r++;\n        }\n        return s.substr(l+1, r-(l+1));\n    }\n\n    string longestPalindrome(string s) {\n        string odd = \"\";\n        string even = \"\";\n        string res = \"\";\n\n        for(unsigned int i = 0; i < s.size(); i++) {\n            even = expandString(s, i, i+1);\n            odd = expandString(s, i, i);\n            \n            if(even.size() > res.size()) {\n                res = even;\n            }\n            if(odd.size() > res.size()) {\n                res = odd;\n            }\n        }\n        return res;\n    }\n\n};`"
                    },
                    {
                        "username": "dnd_Hyani69",
                        "content": "//Simple CPP Soluion//\\n\\nclass Solution {\\npublic:\\n    string longestPalindrome(string s) {\\n       int maxlen=1,start=0;\\n     for(int i=1;i<s.length();i++){//1 se chlao\\n         //that is even substring\\n         int l=i-1;\\n         int r=i;\\n         \\n         while(l >= 0 && r<s.length() && s[l]==s[r]){//l chota ho r bada ho and l==r ho bss\\n             if(r-l+1 > maxlen) {\\n             maxlen=r-l+1;\\n              start=l;\\n             }\\n        l--;\\n        r++;\\n         }\\n      //for odd substring \\n       l=i-1;\\n       r=i+1;\\n     \\n     while(l >=0 && r<s.length() && s[l]==s[r]){\\n         if(r-l+1 > maxlen){\\n         maxlen=r-l+1;\\n         start=l;\\n         }\\n         l--;\\n         r++;\\n     }\\n     }\\n     return s.substr(start, maxlen);\\n    }\\n}; "
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Simple rules.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "meetfarhanali",
                        "content": "The leetcode problems sucks. This is my 2nd problem and i see the description is not right. \\nFor babac the longest palindrom will be \"baba\"=\"abab\". I will switch to HRank problems as they make more sense"
                    },
                    {
                        "username": "dhtmlkitchen",
                        "content": "\"baba\" is not a palendrome.\n\nA Palendrome is a series of characters that is the same forwards and backwards.\n\n\"baba\" backwards is \"abab\". \"baba\" != \"abab\". Thus, \"baba\" is not a palendrome.\n\nTry an easier problem. 125. Valid Palindrome\nhttps://leetcode.com/problems/valid-palindrome/\n"
                    },
                    {
                        "username": "Navin152",
                        "content": "\\nmy code is not working in java can anyone explain please why this code is not working\\n\\nclass Solution {\\n    public String longestPalindrome(String s) {\\n        int n=s.length();\\n        int low,high;\\n        int st=0;\\n        int len=1;\\n        for(int i=1;i<n;i++){\\n            //Even\\n            low=i;\\n            high=i-1;\\n            while(low>=0 && high <n && s[low] == s[high]){\\n                if(high-low+1>len){\\n                    st=low;\\n                    len = high-low+1;\\n                }\\n                low--;high++;\\n                }\\n         //odd\\n            low=i-1;\\n            high=i+1;\\n            while(low>=0 && high<n &&s.charAt(low)== s.charAt(high)){\\n                {\\n                    if(high-low+1>len){\\n                        st=low;\\n                        len= high-low+1;\\n                        }\\n                     low--;\\n                     high++;\\n}\\n}\\n               return  s.substring(st,len);\\n                }   \\n            } \\n           \\n\\n    \\n        \\n\\n"
                    },
                    {
                        "username": "Rajdip_234",
                        "content": " Hi, in this program first we divide the string one is even length and another is odd length and we pass parameter using one function that is string and middle point value then we check the length in both string . If the difference between end and start is less than length of string then we should update start and end value and return the substring value. then again we pass parameter in function which we will declare as our wish and pass string , i value , j value . taking while loop the put the condition i greater than or equals to zero and j should be less than the length of string and the ith value of string is equals to the jth value of string then i will be decremented and j incremented and finally return the value that is (j-i+1)."
                    },
                    {
                        "username": "allgameaimbotall",
                        "content": "Hi I haven't studied Dynamic Programming till now but learned a littlebit about memoization. I tried to solve this problem with recursion + adding memoization .\n\nCode gives exactly what we want but off-course Time-Limit issues.\n\nJust want to ask where does this approach fail?\n\n`\ndp = {}\ndef longestPalindrome(self, s: str) -> str:\nif self.dp.get(s) != None:\n    return self.dp[s]\n\n#TRACKERS\nlenStr = len(s)\n\n#BASE\nif lenStr == 1:\n    self.dp[s] = s\n    return s\n\nif s == s[::-1]:\n    self.dp[s] = s\n    return s\nelse:\n    lp_inleft = self.longestPalindrome(s[1:])\n    lp_inright = self.longestPalindrome(s[:lenStr-1])\n    ans = max(lp_inleft,lp_inright,key=len)\n    self.dp[s] = ans\n    return ans\n        `\n\n        "
                    }
                ]
            },
            {
                "id": 1714466,
                "content": [
                    {
                        "username": "divyaxreddy",
                        "content": "NICK WHITE'S code in C++ not working, can u please help?\n\n \n    string longestPalindrome(string s) {\n        int lenOfString = s.length();\n        int start = 0, end = 0;\n       for(int i = 0; i<lenOfString; i++){\n           int len1 = expandFromMid(s, i, i);\n           int len2 = expandFromMid(s, i, i+1);\n\n           int maxlength = max(len1, len2);\n           //check if maxLength is > old length\n           if(maxlength > (end - start)){\n                start = i - ((maxlength-1)/2);\n                end = i + (maxlength/2);\n           }\n       }\n       return s.substr(start, end+1);\n    }\n\n    int expandFromMid(string& s, int i, int j){\n        if( left > right) return 0;\n        int left = i, right = j;\n        while(left >=0 && right <s.length() && (s[left] == s[right])){\n            left--;\n            right++;\n        }\n\n        return right - left + 1;\n    }\n};`"
                    },
                    {
                        "username": "BaconChef",
                        "content": "[HELP]  \\nHow is \\nInput: s = \"babad\"\\nOutput: \"bab\"\\n\\n\"badab\" or \"abdba\" is both palindromic (the same read forwards and backwards) and a substring. And its obviously longer than \"bab\". For that matter, why isn\\'t \"baab\" accepted?\\n\\nMy definitions:\\nA palindrome is a string that is the same if it\\'s read forward and backward.\\nA substring is a string that rearranges or omits characters of a string."
                    },
                    {
                        "username": "Yongbi",
                        "content": "[@BaconChef](/BaconChef)\nHello, let's see your substring definition? \nGiven:\ns = \"babad\"\n\nSubstring palindromic: any characters \"a\", \"b\", \"d\", and \"bab\", \"aba\".\nBut \"baab\" is not a substring of s!"
                    },
                    {
                        "username": "zuratvaradze999",
                        "content": "swift"
                    },
                    {
                        "username": "Violet-",
                        "content": "Could anybody please explain what does this sentence mean (by an example) in the first solution with Longest common subsequence? \"To rectify this, each time we find a longest common substring candidate, we check if the substring\\u2019s indices are the same as the reversed substring\\u2019s original indices.\""
                    },
                    {
                        "username": "parialxx",
                        "content": "Does anyone understand why do I get this error message in the Longest Palindromic substring problem?\n\n\nAddressSanitizer:DEADLYSIGNAL 31\nERROR: AddressSanitizer: SEGV on unknown address 0x7ffd1cc2ec5f (pc 0x0000003447b6 bp 0x7ffc1cc2eab0 sp 0x7ffc1cc2ea90 T0)\n==31==The signal is caused by a READ memory access.\n    #4 0x7fb759d300b2  (/lib/x86_64-linux-gnu/libc.so.6+0x270b2)\nAddressSanitizer can not provide additional info.\n31 ABORTING\n\n\nThis is my code...\n\n`#include <string>\n#include <iostream>\n\nusing namespace std;\n\nclass Solution {\npublic:\n\n    string expandString(string s, unsigned int l, unsigned int r) {\n        while(l >= 0 && r < s.size() && s[l] == s[r]) {\n            l--;\n            r++;\n        }\n        return s.substr(l+1, r-(l+1));\n    }\n\n    string longestPalindrome(string s) {\n        string odd = \"\";\n        string even = \"\";\n        string res = \"\";\n\n        for(unsigned int i = 0; i < s.size(); i++) {\n            even = expandString(s, i, i+1);\n            odd = expandString(s, i, i);\n            \n            if(even.size() > res.size()) {\n                res = even;\n            }\n            if(odd.size() > res.size()) {\n                res = odd;\n            }\n        }\n        return res;\n    }\n\n};`"
                    },
                    {
                        "username": "dnd_Hyani69",
                        "content": "//Simple CPP Soluion//\\n\\nclass Solution {\\npublic:\\n    string longestPalindrome(string s) {\\n       int maxlen=1,start=0;\\n     for(int i=1;i<s.length();i++){//1 se chlao\\n         //that is even substring\\n         int l=i-1;\\n         int r=i;\\n         \\n         while(l >= 0 && r<s.length() && s[l]==s[r]){//l chota ho r bada ho and l==r ho bss\\n             if(r-l+1 > maxlen) {\\n             maxlen=r-l+1;\\n              start=l;\\n             }\\n        l--;\\n        r++;\\n         }\\n      //for odd substring \\n       l=i-1;\\n       r=i+1;\\n     \\n     while(l >=0 && r<s.length() && s[l]==s[r]){\\n         if(r-l+1 > maxlen){\\n         maxlen=r-l+1;\\n         start=l;\\n         }\\n         l--;\\n         r++;\\n     }\\n     }\\n     return s.substr(start, maxlen);\\n    }\\n}; "
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Simple rules.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "meetfarhanali",
                        "content": "The leetcode problems sucks. This is my 2nd problem and i see the description is not right. \\nFor babac the longest palindrom will be \"baba\"=\"abab\". I will switch to HRank problems as they make more sense"
                    },
                    {
                        "username": "dhtmlkitchen",
                        "content": "\"baba\" is not a palendrome.\n\nA Palendrome is a series of characters that is the same forwards and backwards.\n\n\"baba\" backwards is \"abab\". \"baba\" != \"abab\". Thus, \"baba\" is not a palendrome.\n\nTry an easier problem. 125. Valid Palindrome\nhttps://leetcode.com/problems/valid-palindrome/\n"
                    },
                    {
                        "username": "Navin152",
                        "content": "\\nmy code is not working in java can anyone explain please why this code is not working\\n\\nclass Solution {\\n    public String longestPalindrome(String s) {\\n        int n=s.length();\\n        int low,high;\\n        int st=0;\\n        int len=1;\\n        for(int i=1;i<n;i++){\\n            //Even\\n            low=i;\\n            high=i-1;\\n            while(low>=0 && high <n && s[low] == s[high]){\\n                if(high-low+1>len){\\n                    st=low;\\n                    len = high-low+1;\\n                }\\n                low--;high++;\\n                }\\n         //odd\\n            low=i-1;\\n            high=i+1;\\n            while(low>=0 && high<n &&s.charAt(low)== s.charAt(high)){\\n                {\\n                    if(high-low+1>len){\\n                        st=low;\\n                        len= high-low+1;\\n                        }\\n                     low--;\\n                     high++;\\n}\\n}\\n               return  s.substring(st,len);\\n                }   \\n            } \\n           \\n\\n    \\n        \\n\\n"
                    },
                    {
                        "username": "Rajdip_234",
                        "content": " Hi, in this program first we divide the string one is even length and another is odd length and we pass parameter using one function that is string and middle point value then we check the length in both string . If the difference between end and start is less than length of string then we should update start and end value and return the substring value. then again we pass parameter in function which we will declare as our wish and pass string , i value , j value . taking while loop the put the condition i greater than or equals to zero and j should be less than the length of string and the ith value of string is equals to the jth value of string then i will be decremented and j incremented and finally return the value that is (j-i+1)."
                    },
                    {
                        "username": "allgameaimbotall",
                        "content": "Hi I haven't studied Dynamic Programming till now but learned a littlebit about memoization. I tried to solve this problem with recursion + adding memoization .\n\nCode gives exactly what we want but off-course Time-Limit issues.\n\nJust want to ask where does this approach fail?\n\n`\ndp = {}\ndef longestPalindrome(self, s: str) -> str:\nif self.dp.get(s) != None:\n    return self.dp[s]\n\n#TRACKERS\nlenStr = len(s)\n\n#BASE\nif lenStr == 1:\n    self.dp[s] = s\n    return s\n\nif s == s[::-1]:\n    self.dp[s] = s\n    return s\nelse:\n    lp_inleft = self.longestPalindrome(s[1:])\n    lp_inright = self.longestPalindrome(s[:lenStr-1])\n    ans = max(lp_inleft,lp_inright,key=len)\n    self.dp[s] = ans\n    return ans\n        `\n\n        "
                    }
                ]
            },
            {
                "id": 1710267,
                "content": [
                    {
                        "username": "divyaxreddy",
                        "content": "NICK WHITE'S code in C++ not working, can u please help?\n\n \n    string longestPalindrome(string s) {\n        int lenOfString = s.length();\n        int start = 0, end = 0;\n       for(int i = 0; i<lenOfString; i++){\n           int len1 = expandFromMid(s, i, i);\n           int len2 = expandFromMid(s, i, i+1);\n\n           int maxlength = max(len1, len2);\n           //check if maxLength is > old length\n           if(maxlength > (end - start)){\n                start = i - ((maxlength-1)/2);\n                end = i + (maxlength/2);\n           }\n       }\n       return s.substr(start, end+1);\n    }\n\n    int expandFromMid(string& s, int i, int j){\n        if( left > right) return 0;\n        int left = i, right = j;\n        while(left >=0 && right <s.length() && (s[left] == s[right])){\n            left--;\n            right++;\n        }\n\n        return right - left + 1;\n    }\n};`"
                    },
                    {
                        "username": "BaconChef",
                        "content": "[HELP]  \\nHow is \\nInput: s = \"babad\"\\nOutput: \"bab\"\\n\\n\"badab\" or \"abdba\" is both palindromic (the same read forwards and backwards) and a substring. And its obviously longer than \"bab\". For that matter, why isn\\'t \"baab\" accepted?\\n\\nMy definitions:\\nA palindrome is a string that is the same if it\\'s read forward and backward.\\nA substring is a string that rearranges or omits characters of a string."
                    },
                    {
                        "username": "Yongbi",
                        "content": "[@BaconChef](/BaconChef)\nHello, let's see your substring definition? \nGiven:\ns = \"babad\"\n\nSubstring palindromic: any characters \"a\", \"b\", \"d\", and \"bab\", \"aba\".\nBut \"baab\" is not a substring of s!"
                    },
                    {
                        "username": "zuratvaradze999",
                        "content": "swift"
                    },
                    {
                        "username": "Violet-",
                        "content": "Could anybody please explain what does this sentence mean (by an example) in the first solution with Longest common subsequence? \"To rectify this, each time we find a longest common substring candidate, we check if the substring\\u2019s indices are the same as the reversed substring\\u2019s original indices.\""
                    },
                    {
                        "username": "parialxx",
                        "content": "Does anyone understand why do I get this error message in the Longest Palindromic substring problem?\n\n\nAddressSanitizer:DEADLYSIGNAL 31\nERROR: AddressSanitizer: SEGV on unknown address 0x7ffd1cc2ec5f (pc 0x0000003447b6 bp 0x7ffc1cc2eab0 sp 0x7ffc1cc2ea90 T0)\n==31==The signal is caused by a READ memory access.\n    #4 0x7fb759d300b2  (/lib/x86_64-linux-gnu/libc.so.6+0x270b2)\nAddressSanitizer can not provide additional info.\n31 ABORTING\n\n\nThis is my code...\n\n`#include <string>\n#include <iostream>\n\nusing namespace std;\n\nclass Solution {\npublic:\n\n    string expandString(string s, unsigned int l, unsigned int r) {\n        while(l >= 0 && r < s.size() && s[l] == s[r]) {\n            l--;\n            r++;\n        }\n        return s.substr(l+1, r-(l+1));\n    }\n\n    string longestPalindrome(string s) {\n        string odd = \"\";\n        string even = \"\";\n        string res = \"\";\n\n        for(unsigned int i = 0; i < s.size(); i++) {\n            even = expandString(s, i, i+1);\n            odd = expandString(s, i, i);\n            \n            if(even.size() > res.size()) {\n                res = even;\n            }\n            if(odd.size() > res.size()) {\n                res = odd;\n            }\n        }\n        return res;\n    }\n\n};`"
                    },
                    {
                        "username": "dnd_Hyani69",
                        "content": "//Simple CPP Soluion//\\n\\nclass Solution {\\npublic:\\n    string longestPalindrome(string s) {\\n       int maxlen=1,start=0;\\n     for(int i=1;i<s.length();i++){//1 se chlao\\n         //that is even substring\\n         int l=i-1;\\n         int r=i;\\n         \\n         while(l >= 0 && r<s.length() && s[l]==s[r]){//l chota ho r bada ho and l==r ho bss\\n             if(r-l+1 > maxlen) {\\n             maxlen=r-l+1;\\n              start=l;\\n             }\\n        l--;\\n        r++;\\n         }\\n      //for odd substring \\n       l=i-1;\\n       r=i+1;\\n     \\n     while(l >=0 && r<s.length() && s[l]==s[r]){\\n         if(r-l+1 > maxlen){\\n         maxlen=r-l+1;\\n         start=l;\\n         }\\n         l--;\\n         r++;\\n     }\\n     }\\n     return s.substr(start, maxlen);\\n    }\\n}; "
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Simple rules.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "meetfarhanali",
                        "content": "The leetcode problems sucks. This is my 2nd problem and i see the description is not right. \\nFor babac the longest palindrom will be \"baba\"=\"abab\". I will switch to HRank problems as they make more sense"
                    },
                    {
                        "username": "dhtmlkitchen",
                        "content": "\"baba\" is not a palendrome.\n\nA Palendrome is a series of characters that is the same forwards and backwards.\n\n\"baba\" backwards is \"abab\". \"baba\" != \"abab\". Thus, \"baba\" is not a palendrome.\n\nTry an easier problem. 125. Valid Palindrome\nhttps://leetcode.com/problems/valid-palindrome/\n"
                    },
                    {
                        "username": "Navin152",
                        "content": "\\nmy code is not working in java can anyone explain please why this code is not working\\n\\nclass Solution {\\n    public String longestPalindrome(String s) {\\n        int n=s.length();\\n        int low,high;\\n        int st=0;\\n        int len=1;\\n        for(int i=1;i<n;i++){\\n            //Even\\n            low=i;\\n            high=i-1;\\n            while(low>=0 && high <n && s[low] == s[high]){\\n                if(high-low+1>len){\\n                    st=low;\\n                    len = high-low+1;\\n                }\\n                low--;high++;\\n                }\\n         //odd\\n            low=i-1;\\n            high=i+1;\\n            while(low>=0 && high<n &&s.charAt(low)== s.charAt(high)){\\n                {\\n                    if(high-low+1>len){\\n                        st=low;\\n                        len= high-low+1;\\n                        }\\n                     low--;\\n                     high++;\\n}\\n}\\n               return  s.substring(st,len);\\n                }   \\n            } \\n           \\n\\n    \\n        \\n\\n"
                    },
                    {
                        "username": "Rajdip_234",
                        "content": " Hi, in this program first we divide the string one is even length and another is odd length and we pass parameter using one function that is string and middle point value then we check the length in both string . If the difference between end and start is less than length of string then we should update start and end value and return the substring value. then again we pass parameter in function which we will declare as our wish and pass string , i value , j value . taking while loop the put the condition i greater than or equals to zero and j should be less than the length of string and the ith value of string is equals to the jth value of string then i will be decremented and j incremented and finally return the value that is (j-i+1)."
                    },
                    {
                        "username": "allgameaimbotall",
                        "content": "Hi I haven't studied Dynamic Programming till now but learned a littlebit about memoization. I tried to solve this problem with recursion + adding memoization .\n\nCode gives exactly what we want but off-course Time-Limit issues.\n\nJust want to ask where does this approach fail?\n\n`\ndp = {}\ndef longestPalindrome(self, s: str) -> str:\nif self.dp.get(s) != None:\n    return self.dp[s]\n\n#TRACKERS\nlenStr = len(s)\n\n#BASE\nif lenStr == 1:\n    self.dp[s] = s\n    return s\n\nif s == s[::-1]:\n    self.dp[s] = s\n    return s\nelse:\n    lp_inleft = self.longestPalindrome(s[1:])\n    lp_inright = self.longestPalindrome(s[:lenStr-1])\n    ans = max(lp_inleft,lp_inright,key=len)\n    self.dp[s] = ans\n    return ans\n        `\n\n        "
                    }
                ]
            },
            {
                "id": 1708425,
                "content": [
                    {
                        "username": "divyaxreddy",
                        "content": "NICK WHITE'S code in C++ not working, can u please help?\n\n \n    string longestPalindrome(string s) {\n        int lenOfString = s.length();\n        int start = 0, end = 0;\n       for(int i = 0; i<lenOfString; i++){\n           int len1 = expandFromMid(s, i, i);\n           int len2 = expandFromMid(s, i, i+1);\n\n           int maxlength = max(len1, len2);\n           //check if maxLength is > old length\n           if(maxlength > (end - start)){\n                start = i - ((maxlength-1)/2);\n                end = i + (maxlength/2);\n           }\n       }\n       return s.substr(start, end+1);\n    }\n\n    int expandFromMid(string& s, int i, int j){\n        if( left > right) return 0;\n        int left = i, right = j;\n        while(left >=0 && right <s.length() && (s[left] == s[right])){\n            left--;\n            right++;\n        }\n\n        return right - left + 1;\n    }\n};`"
                    },
                    {
                        "username": "BaconChef",
                        "content": "[HELP]  \\nHow is \\nInput: s = \"babad\"\\nOutput: \"bab\"\\n\\n\"badab\" or \"abdba\" is both palindromic (the same read forwards and backwards) and a substring. And its obviously longer than \"bab\". For that matter, why isn\\'t \"baab\" accepted?\\n\\nMy definitions:\\nA palindrome is a string that is the same if it\\'s read forward and backward.\\nA substring is a string that rearranges or omits characters of a string."
                    },
                    {
                        "username": "Yongbi",
                        "content": "[@BaconChef](/BaconChef)\nHello, let's see your substring definition? \nGiven:\ns = \"babad\"\n\nSubstring palindromic: any characters \"a\", \"b\", \"d\", and \"bab\", \"aba\".\nBut \"baab\" is not a substring of s!"
                    },
                    {
                        "username": "zuratvaradze999",
                        "content": "swift"
                    },
                    {
                        "username": "Violet-",
                        "content": "Could anybody please explain what does this sentence mean (by an example) in the first solution with Longest common subsequence? \"To rectify this, each time we find a longest common substring candidate, we check if the substring\\u2019s indices are the same as the reversed substring\\u2019s original indices.\""
                    },
                    {
                        "username": "parialxx",
                        "content": "Does anyone understand why do I get this error message in the Longest Palindromic substring problem?\n\n\nAddressSanitizer:DEADLYSIGNAL 31\nERROR: AddressSanitizer: SEGV on unknown address 0x7ffd1cc2ec5f (pc 0x0000003447b6 bp 0x7ffc1cc2eab0 sp 0x7ffc1cc2ea90 T0)\n==31==The signal is caused by a READ memory access.\n    #4 0x7fb759d300b2  (/lib/x86_64-linux-gnu/libc.so.6+0x270b2)\nAddressSanitizer can not provide additional info.\n31 ABORTING\n\n\nThis is my code...\n\n`#include <string>\n#include <iostream>\n\nusing namespace std;\n\nclass Solution {\npublic:\n\n    string expandString(string s, unsigned int l, unsigned int r) {\n        while(l >= 0 && r < s.size() && s[l] == s[r]) {\n            l--;\n            r++;\n        }\n        return s.substr(l+1, r-(l+1));\n    }\n\n    string longestPalindrome(string s) {\n        string odd = \"\";\n        string even = \"\";\n        string res = \"\";\n\n        for(unsigned int i = 0; i < s.size(); i++) {\n            even = expandString(s, i, i+1);\n            odd = expandString(s, i, i);\n            \n            if(even.size() > res.size()) {\n                res = even;\n            }\n            if(odd.size() > res.size()) {\n                res = odd;\n            }\n        }\n        return res;\n    }\n\n};`"
                    },
                    {
                        "username": "dnd_Hyani69",
                        "content": "//Simple CPP Soluion//\\n\\nclass Solution {\\npublic:\\n    string longestPalindrome(string s) {\\n       int maxlen=1,start=0;\\n     for(int i=1;i<s.length();i++){//1 se chlao\\n         //that is even substring\\n         int l=i-1;\\n         int r=i;\\n         \\n         while(l >= 0 && r<s.length() && s[l]==s[r]){//l chota ho r bada ho and l==r ho bss\\n             if(r-l+1 > maxlen) {\\n             maxlen=r-l+1;\\n              start=l;\\n             }\\n        l--;\\n        r++;\\n         }\\n      //for odd substring \\n       l=i-1;\\n       r=i+1;\\n     \\n     while(l >=0 && r<s.length() && s[l]==s[r]){\\n         if(r-l+1 > maxlen){\\n         maxlen=r-l+1;\\n         start=l;\\n         }\\n         l--;\\n         r++;\\n     }\\n     }\\n     return s.substr(start, maxlen);\\n    }\\n}; "
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Simple rules.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "meetfarhanali",
                        "content": "The leetcode problems sucks. This is my 2nd problem and i see the description is not right. \\nFor babac the longest palindrom will be \"baba\"=\"abab\". I will switch to HRank problems as they make more sense"
                    },
                    {
                        "username": "dhtmlkitchen",
                        "content": "\"baba\" is not a palendrome.\n\nA Palendrome is a series of characters that is the same forwards and backwards.\n\n\"baba\" backwards is \"abab\". \"baba\" != \"abab\". Thus, \"baba\" is not a palendrome.\n\nTry an easier problem. 125. Valid Palindrome\nhttps://leetcode.com/problems/valid-palindrome/\n"
                    },
                    {
                        "username": "Navin152",
                        "content": "\\nmy code is not working in java can anyone explain please why this code is not working\\n\\nclass Solution {\\n    public String longestPalindrome(String s) {\\n        int n=s.length();\\n        int low,high;\\n        int st=0;\\n        int len=1;\\n        for(int i=1;i<n;i++){\\n            //Even\\n            low=i;\\n            high=i-1;\\n            while(low>=0 && high <n && s[low] == s[high]){\\n                if(high-low+1>len){\\n                    st=low;\\n                    len = high-low+1;\\n                }\\n                low--;high++;\\n                }\\n         //odd\\n            low=i-1;\\n            high=i+1;\\n            while(low>=0 && high<n &&s.charAt(low)== s.charAt(high)){\\n                {\\n                    if(high-low+1>len){\\n                        st=low;\\n                        len= high-low+1;\\n                        }\\n                     low--;\\n                     high++;\\n}\\n}\\n               return  s.substring(st,len);\\n                }   \\n            } \\n           \\n\\n    \\n        \\n\\n"
                    },
                    {
                        "username": "Rajdip_234",
                        "content": " Hi, in this program first we divide the string one is even length and another is odd length and we pass parameter using one function that is string and middle point value then we check the length in both string . If the difference between end and start is less than length of string then we should update start and end value and return the substring value. then again we pass parameter in function which we will declare as our wish and pass string , i value , j value . taking while loop the put the condition i greater than or equals to zero and j should be less than the length of string and the ith value of string is equals to the jth value of string then i will be decremented and j incremented and finally return the value that is (j-i+1)."
                    },
                    {
                        "username": "allgameaimbotall",
                        "content": "Hi I haven't studied Dynamic Programming till now but learned a littlebit about memoization. I tried to solve this problem with recursion + adding memoization .\n\nCode gives exactly what we want but off-course Time-Limit issues.\n\nJust want to ask where does this approach fail?\n\n`\ndp = {}\ndef longestPalindrome(self, s: str) -> str:\nif self.dp.get(s) != None:\n    return self.dp[s]\n\n#TRACKERS\nlenStr = len(s)\n\n#BASE\nif lenStr == 1:\n    self.dp[s] = s\n    return s\n\nif s == s[::-1]:\n    self.dp[s] = s\n    return s\nelse:\n    lp_inleft = self.longestPalindrome(s[1:])\n    lp_inright = self.longestPalindrome(s[:lenStr-1])\n    ans = max(lp_inleft,lp_inright,key=len)\n    self.dp[s] = ans\n    return ans\n        `\n\n        "
                    }
                ]
            },
            {
                "id": 1704183,
                "content": [
                    {
                        "username": "divyaxreddy",
                        "content": "NICK WHITE'S code in C++ not working, can u please help?\n\n \n    string longestPalindrome(string s) {\n        int lenOfString = s.length();\n        int start = 0, end = 0;\n       for(int i = 0; i<lenOfString; i++){\n           int len1 = expandFromMid(s, i, i);\n           int len2 = expandFromMid(s, i, i+1);\n\n           int maxlength = max(len1, len2);\n           //check if maxLength is > old length\n           if(maxlength > (end - start)){\n                start = i - ((maxlength-1)/2);\n                end = i + (maxlength/2);\n           }\n       }\n       return s.substr(start, end+1);\n    }\n\n    int expandFromMid(string& s, int i, int j){\n        if( left > right) return 0;\n        int left = i, right = j;\n        while(left >=0 && right <s.length() && (s[left] == s[right])){\n            left--;\n            right++;\n        }\n\n        return right - left + 1;\n    }\n};`"
                    },
                    {
                        "username": "BaconChef",
                        "content": "[HELP]  \\nHow is \\nInput: s = \"babad\"\\nOutput: \"bab\"\\n\\n\"badab\" or \"abdba\" is both palindromic (the same read forwards and backwards) and a substring. And its obviously longer than \"bab\". For that matter, why isn\\'t \"baab\" accepted?\\n\\nMy definitions:\\nA palindrome is a string that is the same if it\\'s read forward and backward.\\nA substring is a string that rearranges or omits characters of a string."
                    },
                    {
                        "username": "Yongbi",
                        "content": "[@BaconChef](/BaconChef)\nHello, let's see your substring definition? \nGiven:\ns = \"babad\"\n\nSubstring palindromic: any characters \"a\", \"b\", \"d\", and \"bab\", \"aba\".\nBut \"baab\" is not a substring of s!"
                    },
                    {
                        "username": "zuratvaradze999",
                        "content": "swift"
                    },
                    {
                        "username": "Violet-",
                        "content": "Could anybody please explain what does this sentence mean (by an example) in the first solution with Longest common subsequence? \"To rectify this, each time we find a longest common substring candidate, we check if the substring\\u2019s indices are the same as the reversed substring\\u2019s original indices.\""
                    },
                    {
                        "username": "parialxx",
                        "content": "Does anyone understand why do I get this error message in the Longest Palindromic substring problem?\n\n\nAddressSanitizer:DEADLYSIGNAL 31\nERROR: AddressSanitizer: SEGV on unknown address 0x7ffd1cc2ec5f (pc 0x0000003447b6 bp 0x7ffc1cc2eab0 sp 0x7ffc1cc2ea90 T0)\n==31==The signal is caused by a READ memory access.\n    #4 0x7fb759d300b2  (/lib/x86_64-linux-gnu/libc.so.6+0x270b2)\nAddressSanitizer can not provide additional info.\n31 ABORTING\n\n\nThis is my code...\n\n`#include <string>\n#include <iostream>\n\nusing namespace std;\n\nclass Solution {\npublic:\n\n    string expandString(string s, unsigned int l, unsigned int r) {\n        while(l >= 0 && r < s.size() && s[l] == s[r]) {\n            l--;\n            r++;\n        }\n        return s.substr(l+1, r-(l+1));\n    }\n\n    string longestPalindrome(string s) {\n        string odd = \"\";\n        string even = \"\";\n        string res = \"\";\n\n        for(unsigned int i = 0; i < s.size(); i++) {\n            even = expandString(s, i, i+1);\n            odd = expandString(s, i, i);\n            \n            if(even.size() > res.size()) {\n                res = even;\n            }\n            if(odd.size() > res.size()) {\n                res = odd;\n            }\n        }\n        return res;\n    }\n\n};`"
                    },
                    {
                        "username": "dnd_Hyani69",
                        "content": "//Simple CPP Soluion//\\n\\nclass Solution {\\npublic:\\n    string longestPalindrome(string s) {\\n       int maxlen=1,start=0;\\n     for(int i=1;i<s.length();i++){//1 se chlao\\n         //that is even substring\\n         int l=i-1;\\n         int r=i;\\n         \\n         while(l >= 0 && r<s.length() && s[l]==s[r]){//l chota ho r bada ho and l==r ho bss\\n             if(r-l+1 > maxlen) {\\n             maxlen=r-l+1;\\n              start=l;\\n             }\\n        l--;\\n        r++;\\n         }\\n      //for odd substring \\n       l=i-1;\\n       r=i+1;\\n     \\n     while(l >=0 && r<s.length() && s[l]==s[r]){\\n         if(r-l+1 > maxlen){\\n         maxlen=r-l+1;\\n         start=l;\\n         }\\n         l--;\\n         r++;\\n     }\\n     }\\n     return s.substr(start, maxlen);\\n    }\\n}; "
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Simple rules.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "meetfarhanali",
                        "content": "The leetcode problems sucks. This is my 2nd problem and i see the description is not right. \\nFor babac the longest palindrom will be \"baba\"=\"abab\". I will switch to HRank problems as they make more sense"
                    },
                    {
                        "username": "dhtmlkitchen",
                        "content": "\"baba\" is not a palendrome.\n\nA Palendrome is a series of characters that is the same forwards and backwards.\n\n\"baba\" backwards is \"abab\". \"baba\" != \"abab\". Thus, \"baba\" is not a palendrome.\n\nTry an easier problem. 125. Valid Palindrome\nhttps://leetcode.com/problems/valid-palindrome/\n"
                    },
                    {
                        "username": "Navin152",
                        "content": "\\nmy code is not working in java can anyone explain please why this code is not working\\n\\nclass Solution {\\n    public String longestPalindrome(String s) {\\n        int n=s.length();\\n        int low,high;\\n        int st=0;\\n        int len=1;\\n        for(int i=1;i<n;i++){\\n            //Even\\n            low=i;\\n            high=i-1;\\n            while(low>=0 && high <n && s[low] == s[high]){\\n                if(high-low+1>len){\\n                    st=low;\\n                    len = high-low+1;\\n                }\\n                low--;high++;\\n                }\\n         //odd\\n            low=i-1;\\n            high=i+1;\\n            while(low>=0 && high<n &&s.charAt(low)== s.charAt(high)){\\n                {\\n                    if(high-low+1>len){\\n                        st=low;\\n                        len= high-low+1;\\n                        }\\n                     low--;\\n                     high++;\\n}\\n}\\n               return  s.substring(st,len);\\n                }   \\n            } \\n           \\n\\n    \\n        \\n\\n"
                    },
                    {
                        "username": "Rajdip_234",
                        "content": " Hi, in this program first we divide the string one is even length and another is odd length and we pass parameter using one function that is string and middle point value then we check the length in both string . If the difference between end and start is less than length of string then we should update start and end value and return the substring value. then again we pass parameter in function which we will declare as our wish and pass string , i value , j value . taking while loop the put the condition i greater than or equals to zero and j should be less than the length of string and the ith value of string is equals to the jth value of string then i will be decremented and j incremented and finally return the value that is (j-i+1)."
                    },
                    {
                        "username": "allgameaimbotall",
                        "content": "Hi I haven't studied Dynamic Programming till now but learned a littlebit about memoization. I tried to solve this problem with recursion + adding memoization .\n\nCode gives exactly what we want but off-course Time-Limit issues.\n\nJust want to ask where does this approach fail?\n\n`\ndp = {}\ndef longestPalindrome(self, s: str) -> str:\nif self.dp.get(s) != None:\n    return self.dp[s]\n\n#TRACKERS\nlenStr = len(s)\n\n#BASE\nif lenStr == 1:\n    self.dp[s] = s\n    return s\n\nif s == s[::-1]:\n    self.dp[s] = s\n    return s\nelse:\n    lp_inleft = self.longestPalindrome(s[1:])\n    lp_inright = self.longestPalindrome(s[:lenStr-1])\n    ans = max(lp_inleft,lp_inright,key=len)\n    self.dp[s] = ans\n    return ans\n        `\n\n        "
                    }
                ]
            },
            {
                "id": 1700817,
                "content": [
                    {
                        "username": "divyaxreddy",
                        "content": "NICK WHITE'S code in C++ not working, can u please help?\n\n \n    string longestPalindrome(string s) {\n        int lenOfString = s.length();\n        int start = 0, end = 0;\n       for(int i = 0; i<lenOfString; i++){\n           int len1 = expandFromMid(s, i, i);\n           int len2 = expandFromMid(s, i, i+1);\n\n           int maxlength = max(len1, len2);\n           //check if maxLength is > old length\n           if(maxlength > (end - start)){\n                start = i - ((maxlength-1)/2);\n                end = i + (maxlength/2);\n           }\n       }\n       return s.substr(start, end+1);\n    }\n\n    int expandFromMid(string& s, int i, int j){\n        if( left > right) return 0;\n        int left = i, right = j;\n        while(left >=0 && right <s.length() && (s[left] == s[right])){\n            left--;\n            right++;\n        }\n\n        return right - left + 1;\n    }\n};`"
                    },
                    {
                        "username": "BaconChef",
                        "content": "[HELP]  \\nHow is \\nInput: s = \"babad\"\\nOutput: \"bab\"\\n\\n\"badab\" or \"abdba\" is both palindromic (the same read forwards and backwards) and a substring. And its obviously longer than \"bab\". For that matter, why isn\\'t \"baab\" accepted?\\n\\nMy definitions:\\nA palindrome is a string that is the same if it\\'s read forward and backward.\\nA substring is a string that rearranges or omits characters of a string."
                    },
                    {
                        "username": "Yongbi",
                        "content": "[@BaconChef](/BaconChef)\nHello, let's see your substring definition? \nGiven:\ns = \"babad\"\n\nSubstring palindromic: any characters \"a\", \"b\", \"d\", and \"bab\", \"aba\".\nBut \"baab\" is not a substring of s!"
                    },
                    {
                        "username": "zuratvaradze999",
                        "content": "swift"
                    },
                    {
                        "username": "Violet-",
                        "content": "Could anybody please explain what does this sentence mean (by an example) in the first solution with Longest common subsequence? \"To rectify this, each time we find a longest common substring candidate, we check if the substring\\u2019s indices are the same as the reversed substring\\u2019s original indices.\""
                    },
                    {
                        "username": "parialxx",
                        "content": "Does anyone understand why do I get this error message in the Longest Palindromic substring problem?\n\n\nAddressSanitizer:DEADLYSIGNAL 31\nERROR: AddressSanitizer: SEGV on unknown address 0x7ffd1cc2ec5f (pc 0x0000003447b6 bp 0x7ffc1cc2eab0 sp 0x7ffc1cc2ea90 T0)\n==31==The signal is caused by a READ memory access.\n    #4 0x7fb759d300b2  (/lib/x86_64-linux-gnu/libc.so.6+0x270b2)\nAddressSanitizer can not provide additional info.\n31 ABORTING\n\n\nThis is my code...\n\n`#include <string>\n#include <iostream>\n\nusing namespace std;\n\nclass Solution {\npublic:\n\n    string expandString(string s, unsigned int l, unsigned int r) {\n        while(l >= 0 && r < s.size() && s[l] == s[r]) {\n            l--;\n            r++;\n        }\n        return s.substr(l+1, r-(l+1));\n    }\n\n    string longestPalindrome(string s) {\n        string odd = \"\";\n        string even = \"\";\n        string res = \"\";\n\n        for(unsigned int i = 0; i < s.size(); i++) {\n            even = expandString(s, i, i+1);\n            odd = expandString(s, i, i);\n            \n            if(even.size() > res.size()) {\n                res = even;\n            }\n            if(odd.size() > res.size()) {\n                res = odd;\n            }\n        }\n        return res;\n    }\n\n};`"
                    },
                    {
                        "username": "dnd_Hyani69",
                        "content": "//Simple CPP Soluion//\\n\\nclass Solution {\\npublic:\\n    string longestPalindrome(string s) {\\n       int maxlen=1,start=0;\\n     for(int i=1;i<s.length();i++){//1 se chlao\\n         //that is even substring\\n         int l=i-1;\\n         int r=i;\\n         \\n         while(l >= 0 && r<s.length() && s[l]==s[r]){//l chota ho r bada ho and l==r ho bss\\n             if(r-l+1 > maxlen) {\\n             maxlen=r-l+1;\\n              start=l;\\n             }\\n        l--;\\n        r++;\\n         }\\n      //for odd substring \\n       l=i-1;\\n       r=i+1;\\n     \\n     while(l >=0 && r<s.length() && s[l]==s[r]){\\n         if(r-l+1 > maxlen){\\n         maxlen=r-l+1;\\n         start=l;\\n         }\\n         l--;\\n         r++;\\n     }\\n     }\\n     return s.substr(start, maxlen);\\n    }\\n}; "
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Simple rules.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "meetfarhanali",
                        "content": "The leetcode problems sucks. This is my 2nd problem and i see the description is not right. \\nFor babac the longest palindrom will be \"baba\"=\"abab\". I will switch to HRank problems as they make more sense"
                    },
                    {
                        "username": "dhtmlkitchen",
                        "content": "\"baba\" is not a palendrome.\n\nA Palendrome is a series of characters that is the same forwards and backwards.\n\n\"baba\" backwards is \"abab\". \"baba\" != \"abab\". Thus, \"baba\" is not a palendrome.\n\nTry an easier problem. 125. Valid Palindrome\nhttps://leetcode.com/problems/valid-palindrome/\n"
                    },
                    {
                        "username": "Navin152",
                        "content": "\\nmy code is not working in java can anyone explain please why this code is not working\\n\\nclass Solution {\\n    public String longestPalindrome(String s) {\\n        int n=s.length();\\n        int low,high;\\n        int st=0;\\n        int len=1;\\n        for(int i=1;i<n;i++){\\n            //Even\\n            low=i;\\n            high=i-1;\\n            while(low>=0 && high <n && s[low] == s[high]){\\n                if(high-low+1>len){\\n                    st=low;\\n                    len = high-low+1;\\n                }\\n                low--;high++;\\n                }\\n         //odd\\n            low=i-1;\\n            high=i+1;\\n            while(low>=0 && high<n &&s.charAt(low)== s.charAt(high)){\\n                {\\n                    if(high-low+1>len){\\n                        st=low;\\n                        len= high-low+1;\\n                        }\\n                     low--;\\n                     high++;\\n}\\n}\\n               return  s.substring(st,len);\\n                }   \\n            } \\n           \\n\\n    \\n        \\n\\n"
                    },
                    {
                        "username": "Rajdip_234",
                        "content": " Hi, in this program first we divide the string one is even length and another is odd length and we pass parameter using one function that is string and middle point value then we check the length in both string . If the difference between end and start is less than length of string then we should update start and end value and return the substring value. then again we pass parameter in function which we will declare as our wish and pass string , i value , j value . taking while loop the put the condition i greater than or equals to zero and j should be less than the length of string and the ith value of string is equals to the jth value of string then i will be decremented and j incremented and finally return the value that is (j-i+1)."
                    },
                    {
                        "username": "allgameaimbotall",
                        "content": "Hi I haven't studied Dynamic Programming till now but learned a littlebit about memoization. I tried to solve this problem with recursion + adding memoization .\n\nCode gives exactly what we want but off-course Time-Limit issues.\n\nJust want to ask where does this approach fail?\n\n`\ndp = {}\ndef longestPalindrome(self, s: str) -> str:\nif self.dp.get(s) != None:\n    return self.dp[s]\n\n#TRACKERS\nlenStr = len(s)\n\n#BASE\nif lenStr == 1:\n    self.dp[s] = s\n    return s\n\nif s == s[::-1]:\n    self.dp[s] = s\n    return s\nelse:\n    lp_inleft = self.longestPalindrome(s[1:])\n    lp_inright = self.longestPalindrome(s[:lenStr-1])\n    ans = max(lp_inleft,lp_inright,key=len)\n    self.dp[s] = ans\n    return ans\n        `\n\n        "
                    }
                ]
            },
            {
                "id": 1697926,
                "content": [
                    {
                        "username": "kiu2022fallMama0africa",
                        "content": " `\\nclass Solution:\\n    def longestPalindrome(self, s: str) -> str:\\n        i = 0\\n        k = len(s) - 1\\n        bool_ = True\\n        while bool_:\\n            if checkforpalindrome(s, i, i + k):\\n                return s[i:i + k + 1]\\n            if i + k + 1 > len(s) - 1:\\n                k -= 1\\n                i = 0\\n            else:\\n                i += 1\\n\\n\\ndef checkforpalindrome(s, l, r):\\n    is_Palindrome = True\\n    while l <= r:\\n        if s[l] == s[r]:\\n            l += 1\\n            r -= 1\\n        else:\\n            is_Palindrome = False\\n            break\\n    return is_Palindrome\\n`\\nwhy does this code not working?\\n\\n\\n\\n"
                    },
                    {
                        "username": "rezahssini",
                        "content": "My code returns \"cabdkac\" for s = \"aacabdkacaa\" but expected is \"aca\", I think my code working correctly, Am I wrong ? "
                    },
                    {
                        "username": "Yongbi",
                        "content": "?? \"cabdkac\" == \"cakdbac\" \\nAre you chatting or are you serious?!"
                    },
                    {
                        "username": "ritiksingla2001",
                        "content": "Java easiest solution (beginner friendly)\\n\\n\\n\\n\\nclass Solution {\\n    public String longestPalindrome(String s) {\\n        String res = \"\";\\n        int n = s.length();\\n        int reslen=0;\\n        for (int i=0;i<n;i++){\\n            // odd length sub strings \\n            int l=i,r=i;\\n            while(l>=0 && r<n && s.charAt(l)== s.charAt(r)){\\n                if ((r-l+1)>reslen){\\n                    res=s.substring(l,r+1);\\n                    reslen=r-l+1;\\n                }\\n                l-=1;\\n                r+=1;\\n            }\\n            // even length sub strings \\n            l=i;\\n            r=i+1;\\n            while(l>=0 && r<n && s.charAt(l)== s.charAt(r)){\\n                if ((r-l+1)>reslen){\\n                    res=s.substring(l,r+1);\\n                    reslen=r-l+1;\\n                }\\n                l-=1;\\n                r+=1;\\n            }\\n\\n        }\\n        return res;\\n    }\\n}\\n"
                    },
                    {
                        "username": "klanjewar037",
                        "content": "How to solve using 2 pointers?\nclass Solution {\npublic:\n    string longestPalindrome(string s) \n    {\n            string ans=\"\";\n            int n=s.size();\n            int low=0,high=n-1;\n            int first=0,last=0,cnt=0;\n            while(low<high)\n            {\n                if(s[low]!=s[high])\n                {\n                   low++;\n                   high--;\n                }\n                else if(s[low]==s[high] && cnt<2)\n                {\n                    first=low;\n                    last=high;\n                    cnt++;\n                    low++;\n                    high--;\n                }\n                else\n                {\n                    low++;\n                    high--;\n                }\n            \n\n            }\n            if(s[first]==s[last])\n            {\n                for(int i=first;i<=last;i++)\n                {\n                    ans+=s[i];\n                }\n                return ans;\n            }\n            return ans;\n\n    }\n};"
                    },
                    {
                        "username": "TalalAhmed",
                        "content": "\n                \n`\n\nTest Case\n`\n\"tscvrnsnnwjzkynzxwcltutcvvhdivtmcvwdiwnbmdyfdvdiseyxyiiurpnhuuufarbwalzysetxbaziuuywugfzzmhoessycogxgujmgvnncwacziyybryxjagesgcmqdryfbofwxhikuauulaqyiztkpgmelnoudvlobdsgharsdkzzuxouezcycsafvpmrzanrixubvojyeuhbcpkuuhkxdvldhdtpkdhpiejshrqpgsoslbkfyraqbmrwiykggdlkgvbvrficmiignctsxeqslhzonlfekxexpvnblrfatvetwasewpglimeqemdgdgmemvdsrzpgacpnrbmomngjpiklqgbbalzxiikacwwzbzapqmatqmexxqhssggsyzpnvvpmzngtljlrhrjbnxgpcjuokgxcbzxqhmitcxlzfehwfiwcmwfliedljghrvrahlcoiescsbupitckjfkrfhhfvdlweeeverrwfkujjdwtcwbbbbwctwdjjukfwrreveeewldvfhhfrkfjkctipubscseioclharvrhgjldeilfwmcwifwhefzlxctimhqxzbcxgkoujcpgxnbjrhrljltgnzmpvvnpzysggsshqxxemqtamqpazbzwwcakiixzlabbgqlkipjgnmombrnpcagpzrsdvmemgdgdmeqemilgpwesawtevtafrlbnvpxexkeflnozhlsqexstcngiimcifrvbvgkldggkyiwrmbqaryfkblsosgpqrhsjeiphdkptdhdlvdxkhuukpcbhueyjovbuxirnazrmpvfascyczeuoxuzzkdsrahgsdbolvduonlemgpktziyqaluuaukihxwfobfyrdqmcgsegajxyrbyyizcawcnnvgmjugxgocysseohmzzfguwyuuizabxtesyzlawbrafuuuhnpruiiyxyesidvdfydmbnwidwvcmtvidhvvctutlcwxznykzjwnnsnrvcst\"\n`\n\nIt gives me error of Time Limit Exceeded kindly if someone helps me to optimize my code TIA"
                    },
                    {
                        "username": "Yongbi",
                        "content": "Using two pointer or slide windows to optimize. Kind regards."
                    },
                    {
                        "username": "yashdeora",
                        "content": "Here is problem solution in Java, Python C++ and C programming.\\n[https://www.gyangav.com/2022/11/leetcode-longest-palindromic-substring-problem-solution.html](https://www.gyangav.com/2022/11/leetcode-longest-palindromic-substring-problem-solution.html)"
                    },
                    {
                        "username": "khushal1201",
                        "content": "Any solution with O(n) complexity or lower than O(n^2) complexity?"
                    },
                    {
                        "username": "Yongbi",
                        "content": "Yes of course! "
                    },
                    {
                        "username": "fuyouwl",
                        "content": "738126387612873"
                    },
                    {
                        "username": "showtroylove",
                        "content": "If you want to solve challenging problems don\\'t waste your time here working these problems who help no one and serve no purpose.  Want real world challenges and problems that help real people with realistic problems?  If you\\'re like me an Application Developer (you code in the application stack  / space) and not a Kernel / OS Developer then head over to stackoverflow.com or similar and give those problems a crack of the whip.  Your feedback will be real, measurable, and immortalized in internet history archives to use as references on your resume and all the bloody rest of it. Cheers!"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Amen."
                    },
                    {
                        "username": "__aadi9754",
                        "content": "input string is \"aacabdkacaa\" \\nmy output is correct and it is \"aacabacaa\" it is palindromic and is longest palindromic subsequence\\nbut somehow according to the leetcode\\'s compiler the correct answer should be \"aca\""
                    },
                    {
                        "username": "showtroylove",
                        "content": "Your output is incorrect.  (intput) aacabdkacaa  != aacakdbacaa  (output) Not a palindrome. aca is in fact correct.  Check your code and try again."
                    }
                ]
            },
            {
                "id": 1695412,
                "content": [
                    {
                        "username": "kiu2022fallMama0africa",
                        "content": " `\\nclass Solution:\\n    def longestPalindrome(self, s: str) -> str:\\n        i = 0\\n        k = len(s) - 1\\n        bool_ = True\\n        while bool_:\\n            if checkforpalindrome(s, i, i + k):\\n                return s[i:i + k + 1]\\n            if i + k + 1 > len(s) - 1:\\n                k -= 1\\n                i = 0\\n            else:\\n                i += 1\\n\\n\\ndef checkforpalindrome(s, l, r):\\n    is_Palindrome = True\\n    while l <= r:\\n        if s[l] == s[r]:\\n            l += 1\\n            r -= 1\\n        else:\\n            is_Palindrome = False\\n            break\\n    return is_Palindrome\\n`\\nwhy does this code not working?\\n\\n\\n\\n"
                    },
                    {
                        "username": "rezahssini",
                        "content": "My code returns \"cabdkac\" for s = \"aacabdkacaa\" but expected is \"aca\", I think my code working correctly, Am I wrong ? "
                    },
                    {
                        "username": "Yongbi",
                        "content": "?? \"cabdkac\" == \"cakdbac\" \\nAre you chatting or are you serious?!"
                    },
                    {
                        "username": "ritiksingla2001",
                        "content": "Java easiest solution (beginner friendly)\\n\\n\\n\\n\\nclass Solution {\\n    public String longestPalindrome(String s) {\\n        String res = \"\";\\n        int n = s.length();\\n        int reslen=0;\\n        for (int i=0;i<n;i++){\\n            // odd length sub strings \\n            int l=i,r=i;\\n            while(l>=0 && r<n && s.charAt(l)== s.charAt(r)){\\n                if ((r-l+1)>reslen){\\n                    res=s.substring(l,r+1);\\n                    reslen=r-l+1;\\n                }\\n                l-=1;\\n                r+=1;\\n            }\\n            // even length sub strings \\n            l=i;\\n            r=i+1;\\n            while(l>=0 && r<n && s.charAt(l)== s.charAt(r)){\\n                if ((r-l+1)>reslen){\\n                    res=s.substring(l,r+1);\\n                    reslen=r-l+1;\\n                }\\n                l-=1;\\n                r+=1;\\n            }\\n\\n        }\\n        return res;\\n    }\\n}\\n"
                    },
                    {
                        "username": "klanjewar037",
                        "content": "How to solve using 2 pointers?\nclass Solution {\npublic:\n    string longestPalindrome(string s) \n    {\n            string ans=\"\";\n            int n=s.size();\n            int low=0,high=n-1;\n            int first=0,last=0,cnt=0;\n            while(low<high)\n            {\n                if(s[low]!=s[high])\n                {\n                   low++;\n                   high--;\n                }\n                else if(s[low]==s[high] && cnt<2)\n                {\n                    first=low;\n                    last=high;\n                    cnt++;\n                    low++;\n                    high--;\n                }\n                else\n                {\n                    low++;\n                    high--;\n                }\n            \n\n            }\n            if(s[first]==s[last])\n            {\n                for(int i=first;i<=last;i++)\n                {\n                    ans+=s[i];\n                }\n                return ans;\n            }\n            return ans;\n\n    }\n};"
                    },
                    {
                        "username": "TalalAhmed",
                        "content": "\n                \n`\n\nTest Case\n`\n\"tscvrnsnnwjzkynzxwcltutcvvhdivtmcvwdiwnbmdyfdvdiseyxyiiurpnhuuufarbwalzysetxbaziuuywugfzzmhoessycogxgujmgvnncwacziyybryxjagesgcmqdryfbofwxhikuauulaqyiztkpgmelnoudvlobdsgharsdkzzuxouezcycsafvpmrzanrixubvojyeuhbcpkuuhkxdvldhdtpkdhpiejshrqpgsoslbkfyraqbmrwiykggdlkgvbvrficmiignctsxeqslhzonlfekxexpvnblrfatvetwasewpglimeqemdgdgmemvdsrzpgacpnrbmomngjpiklqgbbalzxiikacwwzbzapqmatqmexxqhssggsyzpnvvpmzngtljlrhrjbnxgpcjuokgxcbzxqhmitcxlzfehwfiwcmwfliedljghrvrahlcoiescsbupitckjfkrfhhfvdlweeeverrwfkujjdwtcwbbbbwctwdjjukfwrreveeewldvfhhfrkfjkctipubscseioclharvrhgjldeilfwmcwifwhefzlxctimhqxzbcxgkoujcpgxnbjrhrljltgnzmpvvnpzysggsshqxxemqtamqpazbzwwcakiixzlabbgqlkipjgnmombrnpcagpzrsdvmemgdgdmeqemilgpwesawtevtafrlbnvpxexkeflnozhlsqexstcngiimcifrvbvgkldggkyiwrmbqaryfkblsosgpqrhsjeiphdkptdhdlvdxkhuukpcbhueyjovbuxirnazrmpvfascyczeuoxuzzkdsrahgsdbolvduonlemgpktziyqaluuaukihxwfobfyrdqmcgsegajxyrbyyizcawcnnvgmjugxgocysseohmzzfguwyuuizabxtesyzlawbrafuuuhnpruiiyxyesidvdfydmbnwidwvcmtvidhvvctutlcwxznykzjwnnsnrvcst\"\n`\n\nIt gives me error of Time Limit Exceeded kindly if someone helps me to optimize my code TIA"
                    },
                    {
                        "username": "Yongbi",
                        "content": "Using two pointer or slide windows to optimize. Kind regards."
                    },
                    {
                        "username": "yashdeora",
                        "content": "Here is problem solution in Java, Python C++ and C programming.\\n[https://www.gyangav.com/2022/11/leetcode-longest-palindromic-substring-problem-solution.html](https://www.gyangav.com/2022/11/leetcode-longest-palindromic-substring-problem-solution.html)"
                    },
                    {
                        "username": "khushal1201",
                        "content": "Any solution with O(n) complexity or lower than O(n^2) complexity?"
                    },
                    {
                        "username": "Yongbi",
                        "content": "Yes of course! "
                    },
                    {
                        "username": "fuyouwl",
                        "content": "738126387612873"
                    },
                    {
                        "username": "showtroylove",
                        "content": "If you want to solve challenging problems don\\'t waste your time here working these problems who help no one and serve no purpose.  Want real world challenges and problems that help real people with realistic problems?  If you\\'re like me an Application Developer (you code in the application stack  / space) and not a Kernel / OS Developer then head over to stackoverflow.com or similar and give those problems a crack of the whip.  Your feedback will be real, measurable, and immortalized in internet history archives to use as references on your resume and all the bloody rest of it. Cheers!"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Amen."
                    },
                    {
                        "username": "__aadi9754",
                        "content": "input string is \"aacabdkacaa\" \\nmy output is correct and it is \"aacabacaa\" it is palindromic and is longest palindromic subsequence\\nbut somehow according to the leetcode\\'s compiler the correct answer should be \"aca\""
                    },
                    {
                        "username": "showtroylove",
                        "content": "Your output is incorrect.  (intput) aacabdkacaa  != aacakdbacaa  (output) Not a palindrome. aca is in fact correct.  Check your code and try again."
                    }
                ]
            },
            {
                "id": 1673923,
                "content": [
                    {
                        "username": "kiu2022fallMama0africa",
                        "content": " `\\nclass Solution:\\n    def longestPalindrome(self, s: str) -> str:\\n        i = 0\\n        k = len(s) - 1\\n        bool_ = True\\n        while bool_:\\n            if checkforpalindrome(s, i, i + k):\\n                return s[i:i + k + 1]\\n            if i + k + 1 > len(s) - 1:\\n                k -= 1\\n                i = 0\\n            else:\\n                i += 1\\n\\n\\ndef checkforpalindrome(s, l, r):\\n    is_Palindrome = True\\n    while l <= r:\\n        if s[l] == s[r]:\\n            l += 1\\n            r -= 1\\n        else:\\n            is_Palindrome = False\\n            break\\n    return is_Palindrome\\n`\\nwhy does this code not working?\\n\\n\\n\\n"
                    },
                    {
                        "username": "rezahssini",
                        "content": "My code returns \"cabdkac\" for s = \"aacabdkacaa\" but expected is \"aca\", I think my code working correctly, Am I wrong ? "
                    },
                    {
                        "username": "Yongbi",
                        "content": "?? \"cabdkac\" == \"cakdbac\" \\nAre you chatting or are you serious?!"
                    },
                    {
                        "username": "ritiksingla2001",
                        "content": "Java easiest solution (beginner friendly)\\n\\n\\n\\n\\nclass Solution {\\n    public String longestPalindrome(String s) {\\n        String res = \"\";\\n        int n = s.length();\\n        int reslen=0;\\n        for (int i=0;i<n;i++){\\n            // odd length sub strings \\n            int l=i,r=i;\\n            while(l>=0 && r<n && s.charAt(l)== s.charAt(r)){\\n                if ((r-l+1)>reslen){\\n                    res=s.substring(l,r+1);\\n                    reslen=r-l+1;\\n                }\\n                l-=1;\\n                r+=1;\\n            }\\n            // even length sub strings \\n            l=i;\\n            r=i+1;\\n            while(l>=0 && r<n && s.charAt(l)== s.charAt(r)){\\n                if ((r-l+1)>reslen){\\n                    res=s.substring(l,r+1);\\n                    reslen=r-l+1;\\n                }\\n                l-=1;\\n                r+=1;\\n            }\\n\\n        }\\n        return res;\\n    }\\n}\\n"
                    },
                    {
                        "username": "klanjewar037",
                        "content": "How to solve using 2 pointers?\nclass Solution {\npublic:\n    string longestPalindrome(string s) \n    {\n            string ans=\"\";\n            int n=s.size();\n            int low=0,high=n-1;\n            int first=0,last=0,cnt=0;\n            while(low<high)\n            {\n                if(s[low]!=s[high])\n                {\n                   low++;\n                   high--;\n                }\n                else if(s[low]==s[high] && cnt<2)\n                {\n                    first=low;\n                    last=high;\n                    cnt++;\n                    low++;\n                    high--;\n                }\n                else\n                {\n                    low++;\n                    high--;\n                }\n            \n\n            }\n            if(s[first]==s[last])\n            {\n                for(int i=first;i<=last;i++)\n                {\n                    ans+=s[i];\n                }\n                return ans;\n            }\n            return ans;\n\n    }\n};"
                    },
                    {
                        "username": "TalalAhmed",
                        "content": "\n                \n`\n\nTest Case\n`\n\"tscvrnsnnwjzkynzxwcltutcvvhdivtmcvwdiwnbmdyfdvdiseyxyiiurpnhuuufarbwalzysetxbaziuuywugfzzmhoessycogxgujmgvnncwacziyybryxjagesgcmqdryfbofwxhikuauulaqyiztkpgmelnoudvlobdsgharsdkzzuxouezcycsafvpmrzanrixubvojyeuhbcpkuuhkxdvldhdtpkdhpiejshrqpgsoslbkfyraqbmrwiykggdlkgvbvrficmiignctsxeqslhzonlfekxexpvnblrfatvetwasewpglimeqemdgdgmemvdsrzpgacpnrbmomngjpiklqgbbalzxiikacwwzbzapqmatqmexxqhssggsyzpnvvpmzngtljlrhrjbnxgpcjuokgxcbzxqhmitcxlzfehwfiwcmwfliedljghrvrahlcoiescsbupitckjfkrfhhfvdlweeeverrwfkujjdwtcwbbbbwctwdjjukfwrreveeewldvfhhfrkfjkctipubscseioclharvrhgjldeilfwmcwifwhefzlxctimhqxzbcxgkoujcpgxnbjrhrljltgnzmpvvnpzysggsshqxxemqtamqpazbzwwcakiixzlabbgqlkipjgnmombrnpcagpzrsdvmemgdgdmeqemilgpwesawtevtafrlbnvpxexkeflnozhlsqexstcngiimcifrvbvgkldggkyiwrmbqaryfkblsosgpqrhsjeiphdkptdhdlvdxkhuukpcbhueyjovbuxirnazrmpvfascyczeuoxuzzkdsrahgsdbolvduonlemgpktziyqaluuaukihxwfobfyrdqmcgsegajxyrbyyizcawcnnvgmjugxgocysseohmzzfguwyuuizabxtesyzlawbrafuuuhnpruiiyxyesidvdfydmbnwidwvcmtvidhvvctutlcwxznykzjwnnsnrvcst\"\n`\n\nIt gives me error of Time Limit Exceeded kindly if someone helps me to optimize my code TIA"
                    },
                    {
                        "username": "Yongbi",
                        "content": "Using two pointer or slide windows to optimize. Kind regards."
                    },
                    {
                        "username": "yashdeora",
                        "content": "Here is problem solution in Java, Python C++ and C programming.\\n[https://www.gyangav.com/2022/11/leetcode-longest-palindromic-substring-problem-solution.html](https://www.gyangav.com/2022/11/leetcode-longest-palindromic-substring-problem-solution.html)"
                    },
                    {
                        "username": "khushal1201",
                        "content": "Any solution with O(n) complexity or lower than O(n^2) complexity?"
                    },
                    {
                        "username": "Yongbi",
                        "content": "Yes of course! "
                    },
                    {
                        "username": "fuyouwl",
                        "content": "738126387612873"
                    },
                    {
                        "username": "showtroylove",
                        "content": "If you want to solve challenging problems don\\'t waste your time here working these problems who help no one and serve no purpose.  Want real world challenges and problems that help real people with realistic problems?  If you\\'re like me an Application Developer (you code in the application stack  / space) and not a Kernel / OS Developer then head over to stackoverflow.com or similar and give those problems a crack of the whip.  Your feedback will be real, measurable, and immortalized in internet history archives to use as references on your resume and all the bloody rest of it. Cheers!"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Amen."
                    },
                    {
                        "username": "__aadi9754",
                        "content": "input string is \"aacabdkacaa\" \\nmy output is correct and it is \"aacabacaa\" it is palindromic and is longest palindromic subsequence\\nbut somehow according to the leetcode\\'s compiler the correct answer should be \"aca\""
                    },
                    {
                        "username": "showtroylove",
                        "content": "Your output is incorrect.  (intput) aacabdkacaa  != aacakdbacaa  (output) Not a palindrome. aca is in fact correct.  Check your code and try again."
                    }
                ]
            },
            {
                "id": 1673472,
                "content": [
                    {
                        "username": "kiu2022fallMama0africa",
                        "content": " `\\nclass Solution:\\n    def longestPalindrome(self, s: str) -> str:\\n        i = 0\\n        k = len(s) - 1\\n        bool_ = True\\n        while bool_:\\n            if checkforpalindrome(s, i, i + k):\\n                return s[i:i + k + 1]\\n            if i + k + 1 > len(s) - 1:\\n                k -= 1\\n                i = 0\\n            else:\\n                i += 1\\n\\n\\ndef checkforpalindrome(s, l, r):\\n    is_Palindrome = True\\n    while l <= r:\\n        if s[l] == s[r]:\\n            l += 1\\n            r -= 1\\n        else:\\n            is_Palindrome = False\\n            break\\n    return is_Palindrome\\n`\\nwhy does this code not working?\\n\\n\\n\\n"
                    },
                    {
                        "username": "rezahssini",
                        "content": "My code returns \"cabdkac\" for s = \"aacabdkacaa\" but expected is \"aca\", I think my code working correctly, Am I wrong ? "
                    },
                    {
                        "username": "Yongbi",
                        "content": "?? \"cabdkac\" == \"cakdbac\" \\nAre you chatting or are you serious?!"
                    },
                    {
                        "username": "ritiksingla2001",
                        "content": "Java easiest solution (beginner friendly)\\n\\n\\n\\n\\nclass Solution {\\n    public String longestPalindrome(String s) {\\n        String res = \"\";\\n        int n = s.length();\\n        int reslen=0;\\n        for (int i=0;i<n;i++){\\n            // odd length sub strings \\n            int l=i,r=i;\\n            while(l>=0 && r<n && s.charAt(l)== s.charAt(r)){\\n                if ((r-l+1)>reslen){\\n                    res=s.substring(l,r+1);\\n                    reslen=r-l+1;\\n                }\\n                l-=1;\\n                r+=1;\\n            }\\n            // even length sub strings \\n            l=i;\\n            r=i+1;\\n            while(l>=0 && r<n && s.charAt(l)== s.charAt(r)){\\n                if ((r-l+1)>reslen){\\n                    res=s.substring(l,r+1);\\n                    reslen=r-l+1;\\n                }\\n                l-=1;\\n                r+=1;\\n            }\\n\\n        }\\n        return res;\\n    }\\n}\\n"
                    },
                    {
                        "username": "klanjewar037",
                        "content": "How to solve using 2 pointers?\nclass Solution {\npublic:\n    string longestPalindrome(string s) \n    {\n            string ans=\"\";\n            int n=s.size();\n            int low=0,high=n-1;\n            int first=0,last=0,cnt=0;\n            while(low<high)\n            {\n                if(s[low]!=s[high])\n                {\n                   low++;\n                   high--;\n                }\n                else if(s[low]==s[high] && cnt<2)\n                {\n                    first=low;\n                    last=high;\n                    cnt++;\n                    low++;\n                    high--;\n                }\n                else\n                {\n                    low++;\n                    high--;\n                }\n            \n\n            }\n            if(s[first]==s[last])\n            {\n                for(int i=first;i<=last;i++)\n                {\n                    ans+=s[i];\n                }\n                return ans;\n            }\n            return ans;\n\n    }\n};"
                    },
                    {
                        "username": "TalalAhmed",
                        "content": "\n                \n`\n\nTest Case\n`\n\"tscvrnsnnwjzkynzxwcltutcvvhdivtmcvwdiwnbmdyfdvdiseyxyiiurpnhuuufarbwalzysetxbaziuuywugfzzmhoessycogxgujmgvnncwacziyybryxjagesgcmqdryfbofwxhikuauulaqyiztkpgmelnoudvlobdsgharsdkzzuxouezcycsafvpmrzanrixubvojyeuhbcpkuuhkxdvldhdtpkdhpiejshrqpgsoslbkfyraqbmrwiykggdlkgvbvrficmiignctsxeqslhzonlfekxexpvnblrfatvetwasewpglimeqemdgdgmemvdsrzpgacpnrbmomngjpiklqgbbalzxiikacwwzbzapqmatqmexxqhssggsyzpnvvpmzngtljlrhrjbnxgpcjuokgxcbzxqhmitcxlzfehwfiwcmwfliedljghrvrahlcoiescsbupitckjfkrfhhfvdlweeeverrwfkujjdwtcwbbbbwctwdjjukfwrreveeewldvfhhfrkfjkctipubscseioclharvrhgjldeilfwmcwifwhefzlxctimhqxzbcxgkoujcpgxnbjrhrljltgnzmpvvnpzysggsshqxxemqtamqpazbzwwcakiixzlabbgqlkipjgnmombrnpcagpzrsdvmemgdgdmeqemilgpwesawtevtafrlbnvpxexkeflnozhlsqexstcngiimcifrvbvgkldggkyiwrmbqaryfkblsosgpqrhsjeiphdkptdhdlvdxkhuukpcbhueyjovbuxirnazrmpvfascyczeuoxuzzkdsrahgsdbolvduonlemgpktziyqaluuaukihxwfobfyrdqmcgsegajxyrbyyizcawcnnvgmjugxgocysseohmzzfguwyuuizabxtesyzlawbrafuuuhnpruiiyxyesidvdfydmbnwidwvcmtvidhvvctutlcwxznykzjwnnsnrvcst\"\n`\n\nIt gives me error of Time Limit Exceeded kindly if someone helps me to optimize my code TIA"
                    },
                    {
                        "username": "Yongbi",
                        "content": "Using two pointer or slide windows to optimize. Kind regards."
                    },
                    {
                        "username": "yashdeora",
                        "content": "Here is problem solution in Java, Python C++ and C programming.\\n[https://www.gyangav.com/2022/11/leetcode-longest-palindromic-substring-problem-solution.html](https://www.gyangav.com/2022/11/leetcode-longest-palindromic-substring-problem-solution.html)"
                    },
                    {
                        "username": "khushal1201",
                        "content": "Any solution with O(n) complexity or lower than O(n^2) complexity?"
                    },
                    {
                        "username": "Yongbi",
                        "content": "Yes of course! "
                    },
                    {
                        "username": "fuyouwl",
                        "content": "738126387612873"
                    },
                    {
                        "username": "showtroylove",
                        "content": "If you want to solve challenging problems don\\'t waste your time here working these problems who help no one and serve no purpose.  Want real world challenges and problems that help real people with realistic problems?  If you\\'re like me an Application Developer (you code in the application stack  / space) and not a Kernel / OS Developer then head over to stackoverflow.com or similar and give those problems a crack of the whip.  Your feedback will be real, measurable, and immortalized in internet history archives to use as references on your resume and all the bloody rest of it. Cheers!"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Amen."
                    },
                    {
                        "username": "__aadi9754",
                        "content": "input string is \"aacabdkacaa\" \\nmy output is correct and it is \"aacabacaa\" it is palindromic and is longest palindromic subsequence\\nbut somehow according to the leetcode\\'s compiler the correct answer should be \"aca\""
                    },
                    {
                        "username": "showtroylove",
                        "content": "Your output is incorrect.  (intput) aacabdkacaa  != aacakdbacaa  (output) Not a palindrome. aca is in fact correct.  Check your code and try again."
                    }
                ]
            },
            {
                "id": 1672036,
                "content": [
                    {
                        "username": "kiu2022fallMama0africa",
                        "content": " `\\nclass Solution:\\n    def longestPalindrome(self, s: str) -> str:\\n        i = 0\\n        k = len(s) - 1\\n        bool_ = True\\n        while bool_:\\n            if checkforpalindrome(s, i, i + k):\\n                return s[i:i + k + 1]\\n            if i + k + 1 > len(s) - 1:\\n                k -= 1\\n                i = 0\\n            else:\\n                i += 1\\n\\n\\ndef checkforpalindrome(s, l, r):\\n    is_Palindrome = True\\n    while l <= r:\\n        if s[l] == s[r]:\\n            l += 1\\n            r -= 1\\n        else:\\n            is_Palindrome = False\\n            break\\n    return is_Palindrome\\n`\\nwhy does this code not working?\\n\\n\\n\\n"
                    },
                    {
                        "username": "rezahssini",
                        "content": "My code returns \"cabdkac\" for s = \"aacabdkacaa\" but expected is \"aca\", I think my code working correctly, Am I wrong ? "
                    },
                    {
                        "username": "Yongbi",
                        "content": "?? \"cabdkac\" == \"cakdbac\" \\nAre you chatting or are you serious?!"
                    },
                    {
                        "username": "ritiksingla2001",
                        "content": "Java easiest solution (beginner friendly)\\n\\n\\n\\n\\nclass Solution {\\n    public String longestPalindrome(String s) {\\n        String res = \"\";\\n        int n = s.length();\\n        int reslen=0;\\n        for (int i=0;i<n;i++){\\n            // odd length sub strings \\n            int l=i,r=i;\\n            while(l>=0 && r<n && s.charAt(l)== s.charAt(r)){\\n                if ((r-l+1)>reslen){\\n                    res=s.substring(l,r+1);\\n                    reslen=r-l+1;\\n                }\\n                l-=1;\\n                r+=1;\\n            }\\n            // even length sub strings \\n            l=i;\\n            r=i+1;\\n            while(l>=0 && r<n && s.charAt(l)== s.charAt(r)){\\n                if ((r-l+1)>reslen){\\n                    res=s.substring(l,r+1);\\n                    reslen=r-l+1;\\n                }\\n                l-=1;\\n                r+=1;\\n            }\\n\\n        }\\n        return res;\\n    }\\n}\\n"
                    },
                    {
                        "username": "klanjewar037",
                        "content": "How to solve using 2 pointers?\nclass Solution {\npublic:\n    string longestPalindrome(string s) \n    {\n            string ans=\"\";\n            int n=s.size();\n            int low=0,high=n-1;\n            int first=0,last=0,cnt=0;\n            while(low<high)\n            {\n                if(s[low]!=s[high])\n                {\n                   low++;\n                   high--;\n                }\n                else if(s[low]==s[high] && cnt<2)\n                {\n                    first=low;\n                    last=high;\n                    cnt++;\n                    low++;\n                    high--;\n                }\n                else\n                {\n                    low++;\n                    high--;\n                }\n            \n\n            }\n            if(s[first]==s[last])\n            {\n                for(int i=first;i<=last;i++)\n                {\n                    ans+=s[i];\n                }\n                return ans;\n            }\n            return ans;\n\n    }\n};"
                    },
                    {
                        "username": "TalalAhmed",
                        "content": "\n                \n`\n\nTest Case\n`\n\"tscvrnsnnwjzkynzxwcltutcvvhdivtmcvwdiwnbmdyfdvdiseyxyiiurpnhuuufarbwalzysetxbaziuuywugfzzmhoessycogxgujmgvnncwacziyybryxjagesgcmqdryfbofwxhikuauulaqyiztkpgmelnoudvlobdsgharsdkzzuxouezcycsafvpmrzanrixubvojyeuhbcpkuuhkxdvldhdtpkdhpiejshrqpgsoslbkfyraqbmrwiykggdlkgvbvrficmiignctsxeqslhzonlfekxexpvnblrfatvetwasewpglimeqemdgdgmemvdsrzpgacpnrbmomngjpiklqgbbalzxiikacwwzbzapqmatqmexxqhssggsyzpnvvpmzngtljlrhrjbnxgpcjuokgxcbzxqhmitcxlzfehwfiwcmwfliedljghrvrahlcoiescsbupitckjfkrfhhfvdlweeeverrwfkujjdwtcwbbbbwctwdjjukfwrreveeewldvfhhfrkfjkctipubscseioclharvrhgjldeilfwmcwifwhefzlxctimhqxzbcxgkoujcpgxnbjrhrljltgnzmpvvnpzysggsshqxxemqtamqpazbzwwcakiixzlabbgqlkipjgnmombrnpcagpzrsdvmemgdgdmeqemilgpwesawtevtafrlbnvpxexkeflnozhlsqexstcngiimcifrvbvgkldggkyiwrmbqaryfkblsosgpqrhsjeiphdkptdhdlvdxkhuukpcbhueyjovbuxirnazrmpvfascyczeuoxuzzkdsrahgsdbolvduonlemgpktziyqaluuaukihxwfobfyrdqmcgsegajxyrbyyizcawcnnvgmjugxgocysseohmzzfguwyuuizabxtesyzlawbrafuuuhnpruiiyxyesidvdfydmbnwidwvcmtvidhvvctutlcwxznykzjwnnsnrvcst\"\n`\n\nIt gives me error of Time Limit Exceeded kindly if someone helps me to optimize my code TIA"
                    },
                    {
                        "username": "Yongbi",
                        "content": "Using two pointer or slide windows to optimize. Kind regards."
                    },
                    {
                        "username": "yashdeora",
                        "content": "Here is problem solution in Java, Python C++ and C programming.\\n[https://www.gyangav.com/2022/11/leetcode-longest-palindromic-substring-problem-solution.html](https://www.gyangav.com/2022/11/leetcode-longest-palindromic-substring-problem-solution.html)"
                    },
                    {
                        "username": "khushal1201",
                        "content": "Any solution with O(n) complexity or lower than O(n^2) complexity?"
                    },
                    {
                        "username": "Yongbi",
                        "content": "Yes of course! "
                    },
                    {
                        "username": "fuyouwl",
                        "content": "738126387612873"
                    },
                    {
                        "username": "showtroylove",
                        "content": "If you want to solve challenging problems don\\'t waste your time here working these problems who help no one and serve no purpose.  Want real world challenges and problems that help real people with realistic problems?  If you\\'re like me an Application Developer (you code in the application stack  / space) and not a Kernel / OS Developer then head over to stackoverflow.com or similar and give those problems a crack of the whip.  Your feedback will be real, measurable, and immortalized in internet history archives to use as references on your resume and all the bloody rest of it. Cheers!"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Amen."
                    },
                    {
                        "username": "__aadi9754",
                        "content": "input string is \"aacabdkacaa\" \\nmy output is correct and it is \"aacabacaa\" it is palindromic and is longest palindromic subsequence\\nbut somehow according to the leetcode\\'s compiler the correct answer should be \"aca\""
                    },
                    {
                        "username": "showtroylove",
                        "content": "Your output is incorrect.  (intput) aacabdkacaa  != aacakdbacaa  (output) Not a palindrome. aca is in fact correct.  Check your code and try again."
                    }
                ]
            },
            {
                "id": 1671228,
                "content": [
                    {
                        "username": "kiu2022fallMama0africa",
                        "content": " `\\nclass Solution:\\n    def longestPalindrome(self, s: str) -> str:\\n        i = 0\\n        k = len(s) - 1\\n        bool_ = True\\n        while bool_:\\n            if checkforpalindrome(s, i, i + k):\\n                return s[i:i + k + 1]\\n            if i + k + 1 > len(s) - 1:\\n                k -= 1\\n                i = 0\\n            else:\\n                i += 1\\n\\n\\ndef checkforpalindrome(s, l, r):\\n    is_Palindrome = True\\n    while l <= r:\\n        if s[l] == s[r]:\\n            l += 1\\n            r -= 1\\n        else:\\n            is_Palindrome = False\\n            break\\n    return is_Palindrome\\n`\\nwhy does this code not working?\\n\\n\\n\\n"
                    },
                    {
                        "username": "rezahssini",
                        "content": "My code returns \"cabdkac\" for s = \"aacabdkacaa\" but expected is \"aca\", I think my code working correctly, Am I wrong ? "
                    },
                    {
                        "username": "Yongbi",
                        "content": "?? \"cabdkac\" == \"cakdbac\" \\nAre you chatting or are you serious?!"
                    },
                    {
                        "username": "ritiksingla2001",
                        "content": "Java easiest solution (beginner friendly)\\n\\n\\n\\n\\nclass Solution {\\n    public String longestPalindrome(String s) {\\n        String res = \"\";\\n        int n = s.length();\\n        int reslen=0;\\n        for (int i=0;i<n;i++){\\n            // odd length sub strings \\n            int l=i,r=i;\\n            while(l>=0 && r<n && s.charAt(l)== s.charAt(r)){\\n                if ((r-l+1)>reslen){\\n                    res=s.substring(l,r+1);\\n                    reslen=r-l+1;\\n                }\\n                l-=1;\\n                r+=1;\\n            }\\n            // even length sub strings \\n            l=i;\\n            r=i+1;\\n            while(l>=0 && r<n && s.charAt(l)== s.charAt(r)){\\n                if ((r-l+1)>reslen){\\n                    res=s.substring(l,r+1);\\n                    reslen=r-l+1;\\n                }\\n                l-=1;\\n                r+=1;\\n            }\\n\\n        }\\n        return res;\\n    }\\n}\\n"
                    },
                    {
                        "username": "klanjewar037",
                        "content": "How to solve using 2 pointers?\nclass Solution {\npublic:\n    string longestPalindrome(string s) \n    {\n            string ans=\"\";\n            int n=s.size();\n            int low=0,high=n-1;\n            int first=0,last=0,cnt=0;\n            while(low<high)\n            {\n                if(s[low]!=s[high])\n                {\n                   low++;\n                   high--;\n                }\n                else if(s[low]==s[high] && cnt<2)\n                {\n                    first=low;\n                    last=high;\n                    cnt++;\n                    low++;\n                    high--;\n                }\n                else\n                {\n                    low++;\n                    high--;\n                }\n            \n\n            }\n            if(s[first]==s[last])\n            {\n                for(int i=first;i<=last;i++)\n                {\n                    ans+=s[i];\n                }\n                return ans;\n            }\n            return ans;\n\n    }\n};"
                    },
                    {
                        "username": "TalalAhmed",
                        "content": "\n                \n`\n\nTest Case\n`\n\"tscvrnsnnwjzkynzxwcltutcvvhdivtmcvwdiwnbmdyfdvdiseyxyiiurpnhuuufarbwalzysetxbaziuuywugfzzmhoessycogxgujmgvnncwacziyybryxjagesgcmqdryfbofwxhikuauulaqyiztkpgmelnoudvlobdsgharsdkzzuxouezcycsafvpmrzanrixubvojyeuhbcpkuuhkxdvldhdtpkdhpiejshrqpgsoslbkfyraqbmrwiykggdlkgvbvrficmiignctsxeqslhzonlfekxexpvnblrfatvetwasewpglimeqemdgdgmemvdsrzpgacpnrbmomngjpiklqgbbalzxiikacwwzbzapqmatqmexxqhssggsyzpnvvpmzngtljlrhrjbnxgpcjuokgxcbzxqhmitcxlzfehwfiwcmwfliedljghrvrahlcoiescsbupitckjfkrfhhfvdlweeeverrwfkujjdwtcwbbbbwctwdjjukfwrreveeewldvfhhfrkfjkctipubscseioclharvrhgjldeilfwmcwifwhefzlxctimhqxzbcxgkoujcpgxnbjrhrljltgnzmpvvnpzysggsshqxxemqtamqpazbzwwcakiixzlabbgqlkipjgnmombrnpcagpzrsdvmemgdgdmeqemilgpwesawtevtafrlbnvpxexkeflnozhlsqexstcngiimcifrvbvgkldggkyiwrmbqaryfkblsosgpqrhsjeiphdkptdhdlvdxkhuukpcbhueyjovbuxirnazrmpvfascyczeuoxuzzkdsrahgsdbolvduonlemgpktziyqaluuaukihxwfobfyrdqmcgsegajxyrbyyizcawcnnvgmjugxgocysseohmzzfguwyuuizabxtesyzlawbrafuuuhnpruiiyxyesidvdfydmbnwidwvcmtvidhvvctutlcwxznykzjwnnsnrvcst\"\n`\n\nIt gives me error of Time Limit Exceeded kindly if someone helps me to optimize my code TIA"
                    },
                    {
                        "username": "Yongbi",
                        "content": "Using two pointer or slide windows to optimize. Kind regards."
                    },
                    {
                        "username": "yashdeora",
                        "content": "Here is problem solution in Java, Python C++ and C programming.\\n[https://www.gyangav.com/2022/11/leetcode-longest-palindromic-substring-problem-solution.html](https://www.gyangav.com/2022/11/leetcode-longest-palindromic-substring-problem-solution.html)"
                    },
                    {
                        "username": "khushal1201",
                        "content": "Any solution with O(n) complexity or lower than O(n^2) complexity?"
                    },
                    {
                        "username": "Yongbi",
                        "content": "Yes of course! "
                    },
                    {
                        "username": "fuyouwl",
                        "content": "738126387612873"
                    },
                    {
                        "username": "showtroylove",
                        "content": "If you want to solve challenging problems don\\'t waste your time here working these problems who help no one and serve no purpose.  Want real world challenges and problems that help real people with realistic problems?  If you\\'re like me an Application Developer (you code in the application stack  / space) and not a Kernel / OS Developer then head over to stackoverflow.com or similar and give those problems a crack of the whip.  Your feedback will be real, measurable, and immortalized in internet history archives to use as references on your resume and all the bloody rest of it. Cheers!"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Amen."
                    },
                    {
                        "username": "__aadi9754",
                        "content": "input string is \"aacabdkacaa\" \\nmy output is correct and it is \"aacabacaa\" it is palindromic and is longest palindromic subsequence\\nbut somehow according to the leetcode\\'s compiler the correct answer should be \"aca\""
                    },
                    {
                        "username": "showtroylove",
                        "content": "Your output is incorrect.  (intput) aacabdkacaa  != aacakdbacaa  (output) Not a palindrome. aca is in fact correct.  Check your code and try again."
                    }
                ]
            },
            {
                "id": 1661814,
                "content": [
                    {
                        "username": "kiu2022fallMama0africa",
                        "content": " `\\nclass Solution:\\n    def longestPalindrome(self, s: str) -> str:\\n        i = 0\\n        k = len(s) - 1\\n        bool_ = True\\n        while bool_:\\n            if checkforpalindrome(s, i, i + k):\\n                return s[i:i + k + 1]\\n            if i + k + 1 > len(s) - 1:\\n                k -= 1\\n                i = 0\\n            else:\\n                i += 1\\n\\n\\ndef checkforpalindrome(s, l, r):\\n    is_Palindrome = True\\n    while l <= r:\\n        if s[l] == s[r]:\\n            l += 1\\n            r -= 1\\n        else:\\n            is_Palindrome = False\\n            break\\n    return is_Palindrome\\n`\\nwhy does this code not working?\\n\\n\\n\\n"
                    },
                    {
                        "username": "rezahssini",
                        "content": "My code returns \"cabdkac\" for s = \"aacabdkacaa\" but expected is \"aca\", I think my code working correctly, Am I wrong ? "
                    },
                    {
                        "username": "Yongbi",
                        "content": "?? \"cabdkac\" == \"cakdbac\" \\nAre you chatting or are you serious?!"
                    },
                    {
                        "username": "ritiksingla2001",
                        "content": "Java easiest solution (beginner friendly)\\n\\n\\n\\n\\nclass Solution {\\n    public String longestPalindrome(String s) {\\n        String res = \"\";\\n        int n = s.length();\\n        int reslen=0;\\n        for (int i=0;i<n;i++){\\n            // odd length sub strings \\n            int l=i,r=i;\\n            while(l>=0 && r<n && s.charAt(l)== s.charAt(r)){\\n                if ((r-l+1)>reslen){\\n                    res=s.substring(l,r+1);\\n                    reslen=r-l+1;\\n                }\\n                l-=1;\\n                r+=1;\\n            }\\n            // even length sub strings \\n            l=i;\\n            r=i+1;\\n            while(l>=0 && r<n && s.charAt(l)== s.charAt(r)){\\n                if ((r-l+1)>reslen){\\n                    res=s.substring(l,r+1);\\n                    reslen=r-l+1;\\n                }\\n                l-=1;\\n                r+=1;\\n            }\\n\\n        }\\n        return res;\\n    }\\n}\\n"
                    },
                    {
                        "username": "klanjewar037",
                        "content": "How to solve using 2 pointers?\nclass Solution {\npublic:\n    string longestPalindrome(string s) \n    {\n            string ans=\"\";\n            int n=s.size();\n            int low=0,high=n-1;\n            int first=0,last=0,cnt=0;\n            while(low<high)\n            {\n                if(s[low]!=s[high])\n                {\n                   low++;\n                   high--;\n                }\n                else if(s[low]==s[high] && cnt<2)\n                {\n                    first=low;\n                    last=high;\n                    cnt++;\n                    low++;\n                    high--;\n                }\n                else\n                {\n                    low++;\n                    high--;\n                }\n            \n\n            }\n            if(s[first]==s[last])\n            {\n                for(int i=first;i<=last;i++)\n                {\n                    ans+=s[i];\n                }\n                return ans;\n            }\n            return ans;\n\n    }\n};"
                    },
                    {
                        "username": "TalalAhmed",
                        "content": "\n                \n`\n\nTest Case\n`\n\"tscvrnsnnwjzkynzxwcltutcvvhdivtmcvwdiwnbmdyfdvdiseyxyiiurpnhuuufarbwalzysetxbaziuuywugfzzmhoessycogxgujmgvnncwacziyybryxjagesgcmqdryfbofwxhikuauulaqyiztkpgmelnoudvlobdsgharsdkzzuxouezcycsafvpmrzanrixubvojyeuhbcpkuuhkxdvldhdtpkdhpiejshrqpgsoslbkfyraqbmrwiykggdlkgvbvrficmiignctsxeqslhzonlfekxexpvnblrfatvetwasewpglimeqemdgdgmemvdsrzpgacpnrbmomngjpiklqgbbalzxiikacwwzbzapqmatqmexxqhssggsyzpnvvpmzngtljlrhrjbnxgpcjuokgxcbzxqhmitcxlzfehwfiwcmwfliedljghrvrahlcoiescsbupitckjfkrfhhfvdlweeeverrwfkujjdwtcwbbbbwctwdjjukfwrreveeewldvfhhfrkfjkctipubscseioclharvrhgjldeilfwmcwifwhefzlxctimhqxzbcxgkoujcpgxnbjrhrljltgnzmpvvnpzysggsshqxxemqtamqpazbzwwcakiixzlabbgqlkipjgnmombrnpcagpzrsdvmemgdgdmeqemilgpwesawtevtafrlbnvpxexkeflnozhlsqexstcngiimcifrvbvgkldggkyiwrmbqaryfkblsosgpqrhsjeiphdkptdhdlvdxkhuukpcbhueyjovbuxirnazrmpvfascyczeuoxuzzkdsrahgsdbolvduonlemgpktziyqaluuaukihxwfobfyrdqmcgsegajxyrbyyizcawcnnvgmjugxgocysseohmzzfguwyuuizabxtesyzlawbrafuuuhnpruiiyxyesidvdfydmbnwidwvcmtvidhvvctutlcwxznykzjwnnsnrvcst\"\n`\n\nIt gives me error of Time Limit Exceeded kindly if someone helps me to optimize my code TIA"
                    },
                    {
                        "username": "Yongbi",
                        "content": "Using two pointer or slide windows to optimize. Kind regards."
                    },
                    {
                        "username": "yashdeora",
                        "content": "Here is problem solution in Java, Python C++ and C programming.\\n[https://www.gyangav.com/2022/11/leetcode-longest-palindromic-substring-problem-solution.html](https://www.gyangav.com/2022/11/leetcode-longest-palindromic-substring-problem-solution.html)"
                    },
                    {
                        "username": "khushal1201",
                        "content": "Any solution with O(n) complexity or lower than O(n^2) complexity?"
                    },
                    {
                        "username": "Yongbi",
                        "content": "Yes of course! "
                    },
                    {
                        "username": "fuyouwl",
                        "content": "738126387612873"
                    },
                    {
                        "username": "showtroylove",
                        "content": "If you want to solve challenging problems don\\'t waste your time here working these problems who help no one and serve no purpose.  Want real world challenges and problems that help real people with realistic problems?  If you\\'re like me an Application Developer (you code in the application stack  / space) and not a Kernel / OS Developer then head over to stackoverflow.com or similar and give those problems a crack of the whip.  Your feedback will be real, measurable, and immortalized in internet history archives to use as references on your resume and all the bloody rest of it. Cheers!"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Amen."
                    },
                    {
                        "username": "__aadi9754",
                        "content": "input string is \"aacabdkacaa\" \\nmy output is correct and it is \"aacabacaa\" it is palindromic and is longest palindromic subsequence\\nbut somehow according to the leetcode\\'s compiler the correct answer should be \"aca\""
                    },
                    {
                        "username": "showtroylove",
                        "content": "Your output is incorrect.  (intput) aacabdkacaa  != aacakdbacaa  (output) Not a palindrome. aca is in fact correct.  Check your code and try again."
                    }
                ]
            },
            {
                "id": 1660740,
                "content": [
                    {
                        "username": "kiu2022fallMama0africa",
                        "content": " `\\nclass Solution:\\n    def longestPalindrome(self, s: str) -> str:\\n        i = 0\\n        k = len(s) - 1\\n        bool_ = True\\n        while bool_:\\n            if checkforpalindrome(s, i, i + k):\\n                return s[i:i + k + 1]\\n            if i + k + 1 > len(s) - 1:\\n                k -= 1\\n                i = 0\\n            else:\\n                i += 1\\n\\n\\ndef checkforpalindrome(s, l, r):\\n    is_Palindrome = True\\n    while l <= r:\\n        if s[l] == s[r]:\\n            l += 1\\n            r -= 1\\n        else:\\n            is_Palindrome = False\\n            break\\n    return is_Palindrome\\n`\\nwhy does this code not working?\\n\\n\\n\\n"
                    },
                    {
                        "username": "rezahssini",
                        "content": "My code returns \"cabdkac\" for s = \"aacabdkacaa\" but expected is \"aca\", I think my code working correctly, Am I wrong ? "
                    },
                    {
                        "username": "Yongbi",
                        "content": "?? \"cabdkac\" == \"cakdbac\" \\nAre you chatting or are you serious?!"
                    },
                    {
                        "username": "ritiksingla2001",
                        "content": "Java easiest solution (beginner friendly)\\n\\n\\n\\n\\nclass Solution {\\n    public String longestPalindrome(String s) {\\n        String res = \"\";\\n        int n = s.length();\\n        int reslen=0;\\n        for (int i=0;i<n;i++){\\n            // odd length sub strings \\n            int l=i,r=i;\\n            while(l>=0 && r<n && s.charAt(l)== s.charAt(r)){\\n                if ((r-l+1)>reslen){\\n                    res=s.substring(l,r+1);\\n                    reslen=r-l+1;\\n                }\\n                l-=1;\\n                r+=1;\\n            }\\n            // even length sub strings \\n            l=i;\\n            r=i+1;\\n            while(l>=0 && r<n && s.charAt(l)== s.charAt(r)){\\n                if ((r-l+1)>reslen){\\n                    res=s.substring(l,r+1);\\n                    reslen=r-l+1;\\n                }\\n                l-=1;\\n                r+=1;\\n            }\\n\\n        }\\n        return res;\\n    }\\n}\\n"
                    },
                    {
                        "username": "klanjewar037",
                        "content": "How to solve using 2 pointers?\nclass Solution {\npublic:\n    string longestPalindrome(string s) \n    {\n            string ans=\"\";\n            int n=s.size();\n            int low=0,high=n-1;\n            int first=0,last=0,cnt=0;\n            while(low<high)\n            {\n                if(s[low]!=s[high])\n                {\n                   low++;\n                   high--;\n                }\n                else if(s[low]==s[high] && cnt<2)\n                {\n                    first=low;\n                    last=high;\n                    cnt++;\n                    low++;\n                    high--;\n                }\n                else\n                {\n                    low++;\n                    high--;\n                }\n            \n\n            }\n            if(s[first]==s[last])\n            {\n                for(int i=first;i<=last;i++)\n                {\n                    ans+=s[i];\n                }\n                return ans;\n            }\n            return ans;\n\n    }\n};"
                    },
                    {
                        "username": "TalalAhmed",
                        "content": "\n                \n`\n\nTest Case\n`\n\"tscvrnsnnwjzkynzxwcltutcvvhdivtmcvwdiwnbmdyfdvdiseyxyiiurpnhuuufarbwalzysetxbaziuuywugfzzmhoessycogxgujmgvnncwacziyybryxjagesgcmqdryfbofwxhikuauulaqyiztkpgmelnoudvlobdsgharsdkzzuxouezcycsafvpmrzanrixubvojyeuhbcpkuuhkxdvldhdtpkdhpiejshrqpgsoslbkfyraqbmrwiykggdlkgvbvrficmiignctsxeqslhzonlfekxexpvnblrfatvetwasewpglimeqemdgdgmemvdsrzpgacpnrbmomngjpiklqgbbalzxiikacwwzbzapqmatqmexxqhssggsyzpnvvpmzngtljlrhrjbnxgpcjuokgxcbzxqhmitcxlzfehwfiwcmwfliedljghrvrahlcoiescsbupitckjfkrfhhfvdlweeeverrwfkujjdwtcwbbbbwctwdjjukfwrreveeewldvfhhfrkfjkctipubscseioclharvrhgjldeilfwmcwifwhefzlxctimhqxzbcxgkoujcpgxnbjrhrljltgnzmpvvnpzysggsshqxxemqtamqpazbzwwcakiixzlabbgqlkipjgnmombrnpcagpzrsdvmemgdgdmeqemilgpwesawtevtafrlbnvpxexkeflnozhlsqexstcngiimcifrvbvgkldggkyiwrmbqaryfkblsosgpqrhsjeiphdkptdhdlvdxkhuukpcbhueyjovbuxirnazrmpvfascyczeuoxuzzkdsrahgsdbolvduonlemgpktziyqaluuaukihxwfobfyrdqmcgsegajxyrbyyizcawcnnvgmjugxgocysseohmzzfguwyuuizabxtesyzlawbrafuuuhnpruiiyxyesidvdfydmbnwidwvcmtvidhvvctutlcwxznykzjwnnsnrvcst\"\n`\n\nIt gives me error of Time Limit Exceeded kindly if someone helps me to optimize my code TIA"
                    },
                    {
                        "username": "Yongbi",
                        "content": "Using two pointer or slide windows to optimize. Kind regards."
                    },
                    {
                        "username": "yashdeora",
                        "content": "Here is problem solution in Java, Python C++ and C programming.\\n[https://www.gyangav.com/2022/11/leetcode-longest-palindromic-substring-problem-solution.html](https://www.gyangav.com/2022/11/leetcode-longest-palindromic-substring-problem-solution.html)"
                    },
                    {
                        "username": "khushal1201",
                        "content": "Any solution with O(n) complexity or lower than O(n^2) complexity?"
                    },
                    {
                        "username": "Yongbi",
                        "content": "Yes of course! "
                    },
                    {
                        "username": "fuyouwl",
                        "content": "738126387612873"
                    },
                    {
                        "username": "showtroylove",
                        "content": "If you want to solve challenging problems don\\'t waste your time here working these problems who help no one and serve no purpose.  Want real world challenges and problems that help real people with realistic problems?  If you\\'re like me an Application Developer (you code in the application stack  / space) and not a Kernel / OS Developer then head over to stackoverflow.com or similar and give those problems a crack of the whip.  Your feedback will be real, measurable, and immortalized in internet history archives to use as references on your resume and all the bloody rest of it. Cheers!"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Amen."
                    },
                    {
                        "username": "__aadi9754",
                        "content": "input string is \"aacabdkacaa\" \\nmy output is correct and it is \"aacabacaa\" it is palindromic and is longest palindromic subsequence\\nbut somehow according to the leetcode\\'s compiler the correct answer should be \"aca\""
                    },
                    {
                        "username": "showtroylove",
                        "content": "Your output is incorrect.  (intput) aacabdkacaa  != aacakdbacaa  (output) Not a palindrome. aca is in fact correct.  Check your code and try again."
                    }
                ]
            },
            {
                "id": 1653744,
                "content": [
                    {
                        "username": "kiu2022fallMama0africa",
                        "content": " `\\nclass Solution:\\n    def longestPalindrome(self, s: str) -> str:\\n        i = 0\\n        k = len(s) - 1\\n        bool_ = True\\n        while bool_:\\n            if checkforpalindrome(s, i, i + k):\\n                return s[i:i + k + 1]\\n            if i + k + 1 > len(s) - 1:\\n                k -= 1\\n                i = 0\\n            else:\\n                i += 1\\n\\n\\ndef checkforpalindrome(s, l, r):\\n    is_Palindrome = True\\n    while l <= r:\\n        if s[l] == s[r]:\\n            l += 1\\n            r -= 1\\n        else:\\n            is_Palindrome = False\\n            break\\n    return is_Palindrome\\n`\\nwhy does this code not working?\\n\\n\\n\\n"
                    },
                    {
                        "username": "rezahssini",
                        "content": "My code returns \"cabdkac\" for s = \"aacabdkacaa\" but expected is \"aca\", I think my code working correctly, Am I wrong ? "
                    },
                    {
                        "username": "Yongbi",
                        "content": "?? \"cabdkac\" == \"cakdbac\" \\nAre you chatting or are you serious?!"
                    },
                    {
                        "username": "ritiksingla2001",
                        "content": "Java easiest solution (beginner friendly)\\n\\n\\n\\n\\nclass Solution {\\n    public String longestPalindrome(String s) {\\n        String res = \"\";\\n        int n = s.length();\\n        int reslen=0;\\n        for (int i=0;i<n;i++){\\n            // odd length sub strings \\n            int l=i,r=i;\\n            while(l>=0 && r<n && s.charAt(l)== s.charAt(r)){\\n                if ((r-l+1)>reslen){\\n                    res=s.substring(l,r+1);\\n                    reslen=r-l+1;\\n                }\\n                l-=1;\\n                r+=1;\\n            }\\n            // even length sub strings \\n            l=i;\\n            r=i+1;\\n            while(l>=0 && r<n && s.charAt(l)== s.charAt(r)){\\n                if ((r-l+1)>reslen){\\n                    res=s.substring(l,r+1);\\n                    reslen=r-l+1;\\n                }\\n                l-=1;\\n                r+=1;\\n            }\\n\\n        }\\n        return res;\\n    }\\n}\\n"
                    },
                    {
                        "username": "klanjewar037",
                        "content": "How to solve using 2 pointers?\nclass Solution {\npublic:\n    string longestPalindrome(string s) \n    {\n            string ans=\"\";\n            int n=s.size();\n            int low=0,high=n-1;\n            int first=0,last=0,cnt=0;\n            while(low<high)\n            {\n                if(s[low]!=s[high])\n                {\n                   low++;\n                   high--;\n                }\n                else if(s[low]==s[high] && cnt<2)\n                {\n                    first=low;\n                    last=high;\n                    cnt++;\n                    low++;\n                    high--;\n                }\n                else\n                {\n                    low++;\n                    high--;\n                }\n            \n\n            }\n            if(s[first]==s[last])\n            {\n                for(int i=first;i<=last;i++)\n                {\n                    ans+=s[i];\n                }\n                return ans;\n            }\n            return ans;\n\n    }\n};"
                    },
                    {
                        "username": "TalalAhmed",
                        "content": "\n                \n`\n\nTest Case\n`\n\"tscvrnsnnwjzkynzxwcltutcvvhdivtmcvwdiwnbmdyfdvdiseyxyiiurpnhuuufarbwalzysetxbaziuuywugfzzmhoessycogxgujmgvnncwacziyybryxjagesgcmqdryfbofwxhikuauulaqyiztkpgmelnoudvlobdsgharsdkzzuxouezcycsafvpmrzanrixubvojyeuhbcpkuuhkxdvldhdtpkdhpiejshrqpgsoslbkfyraqbmrwiykggdlkgvbvrficmiignctsxeqslhzonlfekxexpvnblrfatvetwasewpglimeqemdgdgmemvdsrzpgacpnrbmomngjpiklqgbbalzxiikacwwzbzapqmatqmexxqhssggsyzpnvvpmzngtljlrhrjbnxgpcjuokgxcbzxqhmitcxlzfehwfiwcmwfliedljghrvrahlcoiescsbupitckjfkrfhhfvdlweeeverrwfkujjdwtcwbbbbwctwdjjukfwrreveeewldvfhhfrkfjkctipubscseioclharvrhgjldeilfwmcwifwhefzlxctimhqxzbcxgkoujcpgxnbjrhrljltgnzmpvvnpzysggsshqxxemqtamqpazbzwwcakiixzlabbgqlkipjgnmombrnpcagpzrsdvmemgdgdmeqemilgpwesawtevtafrlbnvpxexkeflnozhlsqexstcngiimcifrvbvgkldggkyiwrmbqaryfkblsosgpqrhsjeiphdkptdhdlvdxkhuukpcbhueyjovbuxirnazrmpvfascyczeuoxuzzkdsrahgsdbolvduonlemgpktziyqaluuaukihxwfobfyrdqmcgsegajxyrbyyizcawcnnvgmjugxgocysseohmzzfguwyuuizabxtesyzlawbrafuuuhnpruiiyxyesidvdfydmbnwidwvcmtvidhvvctutlcwxznykzjwnnsnrvcst\"\n`\n\nIt gives me error of Time Limit Exceeded kindly if someone helps me to optimize my code TIA"
                    },
                    {
                        "username": "Yongbi",
                        "content": "Using two pointer or slide windows to optimize. Kind regards."
                    },
                    {
                        "username": "yashdeora",
                        "content": "Here is problem solution in Java, Python C++ and C programming.\\n[https://www.gyangav.com/2022/11/leetcode-longest-palindromic-substring-problem-solution.html](https://www.gyangav.com/2022/11/leetcode-longest-palindromic-substring-problem-solution.html)"
                    },
                    {
                        "username": "khushal1201",
                        "content": "Any solution with O(n) complexity or lower than O(n^2) complexity?"
                    },
                    {
                        "username": "Yongbi",
                        "content": "Yes of course! "
                    },
                    {
                        "username": "fuyouwl",
                        "content": "738126387612873"
                    },
                    {
                        "username": "showtroylove",
                        "content": "If you want to solve challenging problems don\\'t waste your time here working these problems who help no one and serve no purpose.  Want real world challenges and problems that help real people with realistic problems?  If you\\'re like me an Application Developer (you code in the application stack  / space) and not a Kernel / OS Developer then head over to stackoverflow.com or similar and give those problems a crack of the whip.  Your feedback will be real, measurable, and immortalized in internet history archives to use as references on your resume and all the bloody rest of it. Cheers!"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Amen."
                    },
                    {
                        "username": "__aadi9754",
                        "content": "input string is \"aacabdkacaa\" \\nmy output is correct and it is \"aacabacaa\" it is palindromic and is longest palindromic subsequence\\nbut somehow according to the leetcode\\'s compiler the correct answer should be \"aca\""
                    },
                    {
                        "username": "showtroylove",
                        "content": "Your output is incorrect.  (intput) aacabdkacaa  != aacakdbacaa  (output) Not a palindrome. aca is in fact correct.  Check your code and try again."
                    }
                ]
            },
            {
                "id": 1643316,
                "content": [
                    {
                        "username": "kiu2022fallMama0africa",
                        "content": " `\\nclass Solution:\\n    def longestPalindrome(self, s: str) -> str:\\n        i = 0\\n        k = len(s) - 1\\n        bool_ = True\\n        while bool_:\\n            if checkforpalindrome(s, i, i + k):\\n                return s[i:i + k + 1]\\n            if i + k + 1 > len(s) - 1:\\n                k -= 1\\n                i = 0\\n            else:\\n                i += 1\\n\\n\\ndef checkforpalindrome(s, l, r):\\n    is_Palindrome = True\\n    while l <= r:\\n        if s[l] == s[r]:\\n            l += 1\\n            r -= 1\\n        else:\\n            is_Palindrome = False\\n            break\\n    return is_Palindrome\\n`\\nwhy does this code not working?\\n\\n\\n\\n"
                    },
                    {
                        "username": "rezahssini",
                        "content": "My code returns \"cabdkac\" for s = \"aacabdkacaa\" but expected is \"aca\", I think my code working correctly, Am I wrong ? "
                    },
                    {
                        "username": "Yongbi",
                        "content": "?? \"cabdkac\" == \"cakdbac\" \\nAre you chatting or are you serious?!"
                    },
                    {
                        "username": "ritiksingla2001",
                        "content": "Java easiest solution (beginner friendly)\\n\\n\\n\\n\\nclass Solution {\\n    public String longestPalindrome(String s) {\\n        String res = \"\";\\n        int n = s.length();\\n        int reslen=0;\\n        for (int i=0;i<n;i++){\\n            // odd length sub strings \\n            int l=i,r=i;\\n            while(l>=0 && r<n && s.charAt(l)== s.charAt(r)){\\n                if ((r-l+1)>reslen){\\n                    res=s.substring(l,r+1);\\n                    reslen=r-l+1;\\n                }\\n                l-=1;\\n                r+=1;\\n            }\\n            // even length sub strings \\n            l=i;\\n            r=i+1;\\n            while(l>=0 && r<n && s.charAt(l)== s.charAt(r)){\\n                if ((r-l+1)>reslen){\\n                    res=s.substring(l,r+1);\\n                    reslen=r-l+1;\\n                }\\n                l-=1;\\n                r+=1;\\n            }\\n\\n        }\\n        return res;\\n    }\\n}\\n"
                    },
                    {
                        "username": "klanjewar037",
                        "content": "How to solve using 2 pointers?\nclass Solution {\npublic:\n    string longestPalindrome(string s) \n    {\n            string ans=\"\";\n            int n=s.size();\n            int low=0,high=n-1;\n            int first=0,last=0,cnt=0;\n            while(low<high)\n            {\n                if(s[low]!=s[high])\n                {\n                   low++;\n                   high--;\n                }\n                else if(s[low]==s[high] && cnt<2)\n                {\n                    first=low;\n                    last=high;\n                    cnt++;\n                    low++;\n                    high--;\n                }\n                else\n                {\n                    low++;\n                    high--;\n                }\n            \n\n            }\n            if(s[first]==s[last])\n            {\n                for(int i=first;i<=last;i++)\n                {\n                    ans+=s[i];\n                }\n                return ans;\n            }\n            return ans;\n\n    }\n};"
                    },
                    {
                        "username": "TalalAhmed",
                        "content": "\n                \n`\n\nTest Case\n`\n\"tscvrnsnnwjzkynzxwcltutcvvhdivtmcvwdiwnbmdyfdvdiseyxyiiurpnhuuufarbwalzysetxbaziuuywugfzzmhoessycogxgujmgvnncwacziyybryxjagesgcmqdryfbofwxhikuauulaqyiztkpgmelnoudvlobdsgharsdkzzuxouezcycsafvpmrzanrixubvojyeuhbcpkuuhkxdvldhdtpkdhpiejshrqpgsoslbkfyraqbmrwiykggdlkgvbvrficmiignctsxeqslhzonlfekxexpvnblrfatvetwasewpglimeqemdgdgmemvdsrzpgacpnrbmomngjpiklqgbbalzxiikacwwzbzapqmatqmexxqhssggsyzpnvvpmzngtljlrhrjbnxgpcjuokgxcbzxqhmitcxlzfehwfiwcmwfliedljghrvrahlcoiescsbupitckjfkrfhhfvdlweeeverrwfkujjdwtcwbbbbwctwdjjukfwrreveeewldvfhhfrkfjkctipubscseioclharvrhgjldeilfwmcwifwhefzlxctimhqxzbcxgkoujcpgxnbjrhrljltgnzmpvvnpzysggsshqxxemqtamqpazbzwwcakiixzlabbgqlkipjgnmombrnpcagpzrsdvmemgdgdmeqemilgpwesawtevtafrlbnvpxexkeflnozhlsqexstcngiimcifrvbvgkldggkyiwrmbqaryfkblsosgpqrhsjeiphdkptdhdlvdxkhuukpcbhueyjovbuxirnazrmpvfascyczeuoxuzzkdsrahgsdbolvduonlemgpktziyqaluuaukihxwfobfyrdqmcgsegajxyrbyyizcawcnnvgmjugxgocysseohmzzfguwyuuizabxtesyzlawbrafuuuhnpruiiyxyesidvdfydmbnwidwvcmtvidhvvctutlcwxznykzjwnnsnrvcst\"\n`\n\nIt gives me error of Time Limit Exceeded kindly if someone helps me to optimize my code TIA"
                    },
                    {
                        "username": "Yongbi",
                        "content": "Using two pointer or slide windows to optimize. Kind regards."
                    },
                    {
                        "username": "yashdeora",
                        "content": "Here is problem solution in Java, Python C++ and C programming.\\n[https://www.gyangav.com/2022/11/leetcode-longest-palindromic-substring-problem-solution.html](https://www.gyangav.com/2022/11/leetcode-longest-palindromic-substring-problem-solution.html)"
                    },
                    {
                        "username": "khushal1201",
                        "content": "Any solution with O(n) complexity or lower than O(n^2) complexity?"
                    },
                    {
                        "username": "Yongbi",
                        "content": "Yes of course! "
                    },
                    {
                        "username": "fuyouwl",
                        "content": "738126387612873"
                    },
                    {
                        "username": "showtroylove",
                        "content": "If you want to solve challenging problems don\\'t waste your time here working these problems who help no one and serve no purpose.  Want real world challenges and problems that help real people with realistic problems?  If you\\'re like me an Application Developer (you code in the application stack  / space) and not a Kernel / OS Developer then head over to stackoverflow.com or similar and give those problems a crack of the whip.  Your feedback will be real, measurable, and immortalized in internet history archives to use as references on your resume and all the bloody rest of it. Cheers!"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Amen."
                    },
                    {
                        "username": "__aadi9754",
                        "content": "input string is \"aacabdkacaa\" \\nmy output is correct and it is \"aacabacaa\" it is palindromic and is longest palindromic subsequence\\nbut somehow according to the leetcode\\'s compiler the correct answer should be \"aca\""
                    },
                    {
                        "username": "showtroylove",
                        "content": "Your output is incorrect.  (intput) aacabdkacaa  != aacakdbacaa  (output) Not a palindrome. aca is in fact correct.  Check your code and try again."
                    }
                ]
            }
        ]
    },
    {
        "title": "Construct Binary Tree from Preorder and Inorder Traversal",
        "question_content": "<p>Given two integer arrays <code>preorder</code> and <code>inorder</code> where <code>preorder</code> is the preorder traversal of a binary tree and <code>inorder</code> is the inorder traversal of the same tree, construct and return <em>the binary tree</em>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/02/19/tree.jpg\" style=\"width: 277px; height: 302px;\" />\n<pre>\n<strong>Input:</strong> preorder = [3,9,20,15,7], inorder = [9,3,15,20,7]\n<strong>Output:</strong> [3,9,20,null,null,15,7]\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> preorder = [-1], inorder = [-1]\n<strong>Output:</strong> [-1]\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= preorder.length &lt;= 3000</code></li>\n\t<li><code>inorder.length == preorder.length</code></li>\n\t<li><code>-3000 &lt;= preorder[i], inorder[i] &lt;= 3000</code></li>\n\t<li><code>preorder</code> and <code>inorder</code> consist of <strong>unique</strong> values.</li>\n\t<li>Each value of <code>inorder</code> also appears in <code>preorder</code>.</li>\n\t<li><code>preorder</code> is <strong>guaranteed</strong> to be the preorder traversal of the tree.</li>\n\t<li><code>inorder</code> is <strong>guaranteed</strong> to be the inorder traversal of the tree.</li>\n</ul>\n",
        "solutions": [
            {
                "id": 34538,
                "title": "my-accepted-java-solution",
                "content": "Hi guys, this is my Java solution. I read this [post][1], which is very helpful.\\n\\nThe basic idea is here:\\nSay we have 2 arrays, PRE and IN.\\nPreorder traversing implies that PRE[0] is the root node.\\nThen we can find this PRE[0] in IN, say it's IN[5].\\nNow we know that IN[5] is root, so we know that IN[0] - IN[4] is on the left side, IN[6] to the end is on the right side.\\nRecursively doing this on subarrays, we can build a tree out of it :)\\n\\nHope this helps.\\n\\n    public TreeNode buildTree(int[] preorder, int[] inorder) {\\n        return helper(0, 0, inorder.length - 1, preorder, inorder);\\n    }\\n    \\n    public TreeNode helper(int preStart, int inStart, int inEnd, int[] preorder, int[] inorder) {\\n        if (preStart > preorder.length - 1 || inStart > inEnd) {\\n            return null;\\n        }\\n        TreeNode root = new TreeNode(preorder[preStart]);\\n        int inIndex = 0; // Index of current root in inorder\\n        for (int i = inStart; i <= inEnd; i++) {\\n            if (inorder[i] == root.val) {\\n                inIndex = i;\\n            }\\n        }\\n        root.left = helper(preStart + 1, inStart, inIndex - 1, preorder, inorder);\\n        root.right = helper(preStart + inIndex - inStart + 1, inIndex + 1, inEnd, preorder, inorder);\\n        return root;\\n    }\\n\\n\\n  [1]: http://leetcode.com/2011/04/construct-binary-tree-from-inorder-and-preorder-postorder-traversal.html",
                "solutionTags": [],
                "code": "Hi guys, this is my Java solution. I read this [post][1], which is very helpful.\\n\\nThe basic idea is here:\\nSay we have 2 arrays, PRE and IN.\\nPreorder traversing implies that PRE[0] is the root node.\\nThen we can find this PRE[0] in IN, say it's IN[5].\\nNow we know that IN[5] is root, so we know that IN[0] - IN[4] is on the left side, IN[6] to the end is on the right side.\\nRecursively doing this on subarrays, we can build a tree out of it :)\\n\\nHope this helps.\\n\\n    public TreeNode buildTree(int[] preorder, int[] inorder) {\\n        return helper(0, 0, inorder.length - 1, preorder, inorder);\\n    }\\n    \\n    public TreeNode helper(int preStart, int inStart, int inEnd, int[] preorder, int[] inorder) {\\n        if (preStart > preorder.length - 1 || inStart > inEnd) {\\n            return null;\\n        }\\n        TreeNode root = new TreeNode(preorder[preStart]);\\n        int inIndex = 0; // Index of current root in inorder\\n        for (int i = inStart; i <= inEnd; i++) {\\n            if (inorder[i] == root.val) {\\n                inIndex = i;\\n            }\\n        }\\n        root.left = helper(preStart + 1, inStart, inIndex - 1, preorder, inorder);\\n        root.right = helper(preStart + inIndex - inStart + 1, inIndex + 1, inEnd, preorder, inorder);\\n        return root;\\n    }\\n\\n\\n  [1]: http://leetcode.com/2011/04/construct-binary-tree-from-inorder-and-preorder-postorder-traversal.html",
                "codeTag": "Unknown"
            },
            {
                "id": 34579,
                "title": "python-short-recursive-solution",
                "content": "        \\n    def buildTree(self, preorder, inorder):\\n        if inorder:\\n            ind = inorder.index(preorder.pop(0))\\n            root = TreeNode(inorder[ind])\\n            root.left = self.buildTree(preorder, inorder[0:ind])\\n            root.right = self.buildTree(preorder, inorder[ind+1:])\\n            return root",
                "solutionTags": [
                    "Python",
                    "Recursion"
                ],
                "code": "        \\n    def buildTree(self, preorder, inorder):\\n        if inorder:\\n            ind = inorder.index(preorder.pop(0))\\n            root = TreeNode(inorder[ind])\\n            root.left = self.buildTree(preorder, inorder[0:ind])\\n            root.right = self.buildTree(preorder, inorder[ind+1:])\\n            return root",
                "codeTag": "Python3"
            },
            {
                "id": 34543,
                "title": "simple-o-n-without-map",
                "content": "**Javascript solution:**\\n\\n    var buildTree = function(preorder, inorder) {\\n        p = i = 0\\n        build = function(stop) {\\n            if (inorder[i] != stop) {\\n                var root = new TreeNode(preorder[p++])\\n                root.left = build(root.val)\\n                i++\\n                root.right = build(stop)\\n                return root\\n            }\\n            return null\\n        }\\n        return build()\\n    };\\n\\n**Python solution:**\\n\\n    def buildTree(self, preorder, inorder):\\n        def build(stop):\\n            if inorder and inorder[-1] != stop:\\n                root = TreeNode(preorder.pop())\\n                root.left = build(root.val)\\n                inorder.pop()\\n                root.right = build(stop)\\n                return root\\n        preorder.reverse()\\n        inorder.reverse()\\n        return build(None)\\n\\nNote: See [MissMary's answer](https://leetcode.com/discuss/40381/simple-o-n-without-map?show=44432#a44432) for a possible improvement and my thoughts about it.\\n\\n---\\n\\n**Explanation/Discussion:**\\n\\nConsider this input:\\n\\n    preorder: [1, 2, 4, 5, 3, 6]\\n    inorder: [4, 2, 5, 1, 6, 3]\\n\\nThe obvious way to build the tree is:\\n\\n 1. Use the first element of `preorder`, the `1`, as root.\\n 2. Search it in `inorder`.\\n 3. Split `inorder` by it, here into `[4, 2, 5]` and `[6, 3]`.\\n 4. Split the rest of  `preorder` into two parts as large as the `inorder` parts, here into `[2, 4, 5]` and `[3, 6]`.\\n 5. Use `preorder = [2, 4, 5]` and `inorder = [4, 2, 5]` to add the left subtree.\\n 6. Use `preorder = `[3, 6]` and `inorder = `[6, 3]` to add the right subtree.\\n\\nBut consider the worst case for this: A tree that's not balanced but is just a straight line to the left. Then inorder is the reverse of preorder, and already the cost of step 2, searching in `inorder`, is O(n^2) overall. Also, depending on how you \"split\" the arrays, you're looking at O(n^2) runtime and possibly O(n^2) space for that as well.\\n\\nYou can bring the runtime for searching down to O(n) by building a map from value to index before you start the main work, and I've seen several solutions do that. But that is O(n) additional space, and also the splitting problems remain. To fix those, you can use pointers into `preorder` and `inorder` instead of splitting them. And when you're doing that, you don't need the value-to-index map, either.\\n\\nConsider the example again. Instead of finding the `1` in `inorder`, splitting the arrays into parts and recursing on them, just recurse on the full remaining arrays and **stop** when you come across the `1` in `inorder`. That's what my above solution does. Each recursive call gets told where to stop, and it tells its subcalls where to stop. It gives its own root value as stopper to its left subcall and its parent`s stopper as stopper to its right subcall.\\n\\n**Language details:**\\n\\nSmall trick in my Javascript solution: The top-most call doesn't explicitly get a stopper value, so its `stop` is `undefined`. Which is good, because that's also what `inorder[i]` is when we have consumed all values, i.e., when `i` is `inorder.length`.\\n\\nAbout the Python solution: I'm not sure there's a good way to have those `p` and `i` pointers that I use in my Javascript solution, so instead I opted for popping elements from `preorder` and `inorder`. Since popping from the front with `pop(0)` is expensive O(n), I reverse them before I start so I can use the cheap O(1) popping from the back.",
                "solutionTags": [
                    "Python",
                    "JavaScript"
                ],
                "code": "**Javascript solution:**\\n\\n    var buildTree = function(preorder, inorder) {\\n        p = i = 0\\n        build = function(stop) {\\n            if (inorder[i] != stop) {\\n                var root = new TreeNode(preorder[p++])\\n                root.left = build(root.val)\\n                i++\\n                root.right = build(stop)\\n                return root\\n            }\\n            return null\\n        }\\n        return build()\\n    };\\n\\n**Python solution:**\\n\\n    def buildTree(self, preorder, inorder):\\n        def build(stop):\\n            if inorder and inorder[-1] != stop:\\n                root = TreeNode(preorder.pop())\\n                root.left = build(root.val)\\n                inorder.pop()\\n                root.right = build(stop)\\n                return root\\n        preorder.reverse()\\n        inorder.reverse()\\n        return build(None)\\n\\nNote: See [MissMary's answer](https://leetcode.com/discuss/40381/simple-o-n-without-map?show=44432#a44432) for a possible improvement and my thoughts about it.\\n\\n---\\n\\n**Explanation/Discussion:**\\n\\nConsider this input:\\n\\n    preorder: [1, 2, 4, 5, 3, 6]\\n    inorder: [4, 2, 5, 1, 6, 3]\\n\\nThe obvious way to build the tree is:\\n\\n 1. Use the first element of `preorder`, the `1`, as root.\\n 2. Search it in `inorder`.\\n 3. Split `inorder` by it, here into `[4, 2, 5]` and `[6, 3]`.\\n 4. Split the rest of  `preorder` into two parts as large as the `inorder` parts, here into `[2, 4, 5]` and `[3, 6]`.\\n 5. Use `preorder = [2, 4, 5]` and `inorder = [4, 2, 5]` to add the left subtree.\\n 6. Use `preorder = `[3, 6]` and `inorder = `[6, 3]` to add the right subtree.\\n\\nBut consider the worst case for this: A tree that's not balanced but is just a straight line to the left. Then inorder is the reverse of preorder, and already the cost of step 2, searching in `inorder`, is O(n^2) overall. Also, depending on how you \"split\" the arrays, you're looking at O(n^2) runtime and possibly O(n^2) space for that as well.\\n\\nYou can bring the runtime for searching down to O(n) by building a map from value to index before you start the main work, and I've seen several solutions do that. But that is O(n) additional space, and also the splitting problems remain. To fix those, you can use pointers into `preorder` and `inorder` instead of splitting them. And when you're doing that, you don't need the value-to-index map, either.\\n\\nConsider the example again. Instead of finding the `1` in `inorder`, splitting the arrays into parts and recursing on them, just recurse on the full remaining arrays and **stop** when you come across the `1` in `inorder`. That's what my above solution does. Each recursive call gets told where to stop, and it tells its subcalls where to stop. It gives its own root value as stopper to its left subcall and its parent`s stopper as stopper to its right subcall.\\n\\n**Language details:**\\n\\nSmall trick in my Javascript solution: The top-most call doesn't explicitly get a stopper value, so its `stop` is `undefined`. Which is good, because that's also what `inorder[i]` is when we have consumed all values, i.e., when `i` is `inorder.length`.\\n\\nAbout the Python solution: I'm not sure there's a good way to have those `p` and `i` pointers that I use in my Javascript solution, so instead I opted for popping elements from `preorder` and `inorder`. Since popping from the front with `pop(0)` is expensive O(n), I reverse them before I start so I can use the cheap O(1) popping from the back.",
                "codeTag": "Python3"
            },
            {
                "id": 3169574,
                "title": "solution",
                "content": "```C++ []\\nclass Solution {\\npublic:\\nTreeNode* constructTree(vector < int > & preorder, int preStart, int preEnd, vector \\n < int > & inorder, int inStart, int inEnd, map < int, int > & mp) {\\n  if (preStart > preEnd || inStart > inEnd) return NULL;\\n\\n  TreeNode* root = new TreeNode(preorder[preStart]);\\n  int elem = mp[root -> val];\\n  int nElem = elem - inStart;\\n\\n  root -> left = constructTree(preorder, preStart + 1, preStart + nElem, inorder,\\n  inStart, elem - 1, mp);\\n  root -> right = constructTree(preorder, preStart + nElem + 1, preEnd, inorder, \\n  elem + 1, inEnd, mp);\\n\\n  return root;\\n}\\n\\nTreeNode* buildTree(vector < int > & preorder, vector < int > & inorder) {\\n  int preStart = 0, preEnd = preorder.size() - 1;\\n  int inStart = 0, inEnd = inorder.size() - 1;\\n\\n  map < int, int > mp;\\n  for (int i = inStart; i <= inEnd; i++) {\\n    mp[inorder[i]] = i;\\n  }\\n\\n  return constructTree(preorder, preStart, preEnd, inorder, inStart, inEnd, mp);\\n}\\n};\\n```\\n\\n```Python3 []\\nclass Solution:\\n    def buildTree(self, preorder: List[int], inorder: List[int]) -> Optional[TreeNode]:\\n        VAL_TO_INORDER_IDX = {inorder[i]: i for i in range(len(inorder))}\\n\\n        def buildTreePartition(preorder, inorder_start, inorder_end):\\n            if not preorder or inorder_start < 0 or inorder_end > len(inorder):\\n                return None\\n\\n            root_val = preorder[0]\\n            root_inorder_idx = VAL_TO_INORDER_IDX[root_val]\\n            if root_inorder_idx > inorder_end or root_inorder_idx < inorder_start:\\n                return None\\n            \\n            root = TreeNode(preorder.pop(0))\\n            root.left = buildTreePartition(preorder, inorder_start, root_inorder_idx - 1)\\n            root.right = buildTreePartition(preorder, root_inorder_idx + 1, inorder_end)\\n\\n            return root\\n\\n        return buildTreePartition(preorder, 0, len(inorder) - 1)\\n```\\n\\n```Java []\\nclass Solution {\\n    private int i = 0;\\n    private int p = 0;\\n\\n    public TreeNode buildTree(int[] preorder, int[] inorder) {\\n        return build(preorder, inorder, Integer.MIN_VALUE);\\n    }\\n\\n    private TreeNode build(int[] preorder, int[] inorder, int stop) {\\n        if (p >= preorder.length) {\\n            return null;\\n        }\\n        if (inorder[i] == stop) {\\n            ++i;\\n            return null;\\n        }\\n\\n        TreeNode node = new TreeNode(preorder[p++]);\\n        node.left = build(preorder, inorder, node.val);\\n        node.right = build(preorder, inorder, stop);\\n        return node;\\n    }\\n}\\n```\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3"
                ],
                "code": "```C++ []\\nclass Solution {\\npublic:\\nTreeNode* constructTree(vector < int > & preorder, int preStart, int preEnd, vector \\n < int > & inorder, int inStart, int inEnd, map < int, int > & mp) {\\n  if (preStart > preEnd || inStart > inEnd) return NULL;\\n\\n  TreeNode* root = new TreeNode(preorder[preStart]);\\n  int elem = mp[root -> val];\\n  int nElem = elem - inStart;\\n\\n  root -> left = constructTree(preorder, preStart + 1, preStart + nElem, inorder,\\n  inStart, elem - 1, mp);\\n  root -> right = constructTree(preorder, preStart + nElem + 1, preEnd, inorder, \\n  elem + 1, inEnd, mp);\\n\\n  return root;\\n}\\n\\nTreeNode* buildTree(vector < int > & preorder, vector < int > & inorder) {\\n  int preStart = 0, preEnd = preorder.size() - 1;\\n  int inStart = 0, inEnd = inorder.size() - 1;\\n\\n  map < int, int > mp;\\n  for (int i = inStart; i <= inEnd; i++) {\\n    mp[inorder[i]] = i;\\n  }\\n\\n  return constructTree(preorder, preStart, preEnd, inorder, inStart, inEnd, mp);\\n}\\n};\\n```\n```Python3 []\\nclass Solution:\\n    def buildTree(self, preorder: List[int], inorder: List[int]) -> Optional[TreeNode]:\\n        VAL_TO_INORDER_IDX = {inorder[i]: i for i in range(len(inorder))}\\n\\n        def buildTreePartition(preorder, inorder_start, inorder_end):\\n            if not preorder or inorder_start < 0 or inorder_end > len(inorder):\\n                return None\\n\\n            root_val = preorder[0]\\n            root_inorder_idx = VAL_TO_INORDER_IDX[root_val]\\n            if root_inorder_idx > inorder_end or root_inorder_idx < inorder_start:\\n                return None\\n            \\n            root = TreeNode(preorder.pop(0))\\n            root.left = buildTreePartition(preorder, inorder_start, root_inorder_idx - 1)\\n            root.right = buildTreePartition(preorder, root_inorder_idx + 1, inorder_end)\\n\\n            return root\\n\\n        return buildTreePartition(preorder, 0, len(inorder) - 1)\\n```\n```Java []\\nclass Solution {\\n    private int i = 0;\\n    private int p = 0;\\n\\n    public TreeNode buildTree(int[] preorder, int[] inorder) {\\n        return build(preorder, inorder, Integer.MIN_VALUE);\\n    }\\n\\n    private TreeNode build(int[] preorder, int[] inorder, int stop) {\\n        if (p >= preorder.length) {\\n            return null;\\n        }\\n        if (inorder[i] == stop) {\\n            ++i;\\n            return null;\\n        }\\n\\n        TreeNode node = new TreeNode(preorder[p++]);\\n        node.left = build(preorder, inorder, node.val);\\n        node.right = build(preorder, inorder, stop);\\n        return node;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 340504,
                "title": "c-simple-recursive-detail-explanation",
                "content": "##### Solution\\nYou need to understand preorder and postorder traversal first, and then go ahead.\\n\\nBasic idea is:\\n- `preorder[0]` is the root node of the tree\\n- `preorder[x]` is a root node of a sub tree\\n- In in-order traversal\\n\\t- When `inorder[index]` is an item in the in-order traversal\\n\\t- `inorder[0]`-`inorder[index-1]` are on the left branch\\n\\t- `inorder[index+1]`-`inorder[size()-1]` are on the right branch\\n\\t- if there is nothing on the left, that means the left child of the node is `NULL`\\n\\t- if there is nothing on the right, that means the right child of the node is `NULL`\\n\\n\\nAlgorithm:\\n- Start from `rootIdx` 0\\n- Find `preorder[rootIdx]` from `inorder`, let\\'s call the index `pivot` \\n- Create a new node with `inorder[pivot]`\\n- Create its left child recursively\\n- Create its right child recursively\\n- Return the created node.\\n\\nThe implementation is self explanatory. Have a look :)\\n\\n##### Code\\n```\\nclass Solution {\\npublic:\\n    TreeNode* buildTree(vector<int>& preorder, vector<int>& inorder) {\\n        int rootIdx = 0;\\n        return build(preorder, inorder, rootIdx, 0, inorder.size()-1);\\n    }\\n    \\n    TreeNode* build(vector<int>& preorder, vector<int>& inorder, int& rootIdx, int left, int right) {\\n        if (left > right) return NULL;\\n        int pivot = left;  // find the root from inorder\\n        while(inorder[pivot] != preorder[rootIdx]) pivot++;\\n        \\n        rootIdx++;\\n        TreeNode* newNode = new TreeNode(inorder[pivot]);\\n        newNode->left = build(preorder, inorder, rootIdx, left, pivot-1);\\n        newNode->right = build(preorder, inorder, rootIdx, pivot+1, right);\\n        return newNode;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Recursion",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    TreeNode* buildTree(vector<int>& preorder, vector<int>& inorder) {\\n        int rootIdx = 0;\\n        return build(preorder, inorder, rootIdx, 0, inorder.size()-1);\\n    }\\n    \\n    TreeNode* build(vector<int>& preorder, vector<int>& inorder, int& rootIdx, int left, int right) {\\n        if (left > right) return NULL;\\n        int pivot = left;  // find the root from inorder\\n        while(inorder[pivot] != preorder[rootIdx]) pivot++;\\n        \\n        rootIdx++;\\n        TreeNode* newNode = new TreeNode(inorder[pivot]);\\n        newNode->left = build(preorder, inorder, rootIdx, left, pivot-1);\\n        newNode->right = build(preorder, inorder, rootIdx, pivot+1, right);\\n        return newNode;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 34555,
                "title": "the-iterative-solution-is-easier-than-you-think",
                "content": "I din't find iterative solutions discussed in the old Discuss. So, I thought, I will add my solution in here.\\n\\nThe idea is as follows: \\n\\n1) Keep pushing the nodes from the preorder into a stack (and keep making the tree by adding nodes to the left of the previous node) until the top of the stack matches the inorder. \\n\\n2) At this point, pop the top of the stack until the top does not equal inorder (keep a flag to note that you have made a pop). \\n\\n3) Repeat 1 and 2 until preorder is empty. The key point is that whenever the flag is set, insert a node to the right and reset the flag.\\n\\n\\n    class Solution {\\n    public:\\n        TreeNode *buildTree(vector<int> &preorder, vector<int> &inorder) {\\n            \\n            if(preorder.size()==0)\\n                return NULL;\\n            \\n            stack<int> s;\\n            stack<TreeNode *> st;\\n            TreeNode *t,*r,*root;\\n            int i,j,f;\\n            \\n            f=i=j=0;\\n            s.push(preorder[i]);\\n            \\n            root = new TreeNode(preorder[i]);\\n            st.push(root);\\n            t = root;\\n            i++;\\n            \\n            while(i<preorder.size())\\n            {\\n                if(!st.empty() && st.top()->val==inorder[j])\\n                {\\n                    t = st.top();\\n                    st.pop();\\n                    s.pop();\\n                    f = 1;\\n                    j++;\\n                }\\n                else\\n                {\\n                    if(f==0)\\n                    {\\n                        s.push(preorder[i]);\\n                        t -> left = new TreeNode(preorder[i]);\\n                        t = t -> left;\\n                        st.push(t);\\n                        i++;\\n                    }\\n                    else \\n                    {\\n                        f = 0;\\n                        s.push(preorder[i]);\\n                        t -> right = new TreeNode(preorder[i]);\\n                        t = t -> right;\\n                        st.push(t);\\n                        i++;\\n                    }\\n                }\\n            }\\n            \\n            return root;\\n        }\\n    };",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n        TreeNode *buildTree(vector<int> &preorder, vector<int> &inorder) {\\n            \\n            if(preorder.size()==0)\\n                return NULL;\\n            \\n            stack<int> s;\\n            stack<TreeNode *> st;\\n            TreeNode *t,*r,*root;\\n            int i,j,f;\\n            \\n            f=i=j=0;\\n            s.push(preorder[i]);\\n            \\n            root = new TreeNode(preorder[i]);\\n            st.push(root);\\n            t = root;\\n            i++;\\n            \\n            while(i<preorder.size())\\n            {\\n                if(!st.empty() && st.top()->val==inorder[j])\\n                {\\n                    t = st.top();\\n                    st.pop();\\n                    s.pop();\\n                    f = 1;\\n                    j++;\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 981152,
                "title": "recursion-explanation-visuals-python",
                "content": "***TL;DR*** The problem asks us to construct a binary tree from the ***perorder*** and ***inorder*** traversals of the binary tree. (full explanation + visuals below)\\n\\n* ***preorder traversal*** provides us with the placement of the root \\n* ***inorder traversal*** provides us with the placement of the left and right children \\n\\n```python\\n   def buildTree(self, preorder: List[int], inorder: List[int]) -> TreeNode:\\n        \\n        if not preorder or not inorder:\\n            return None\\n\\n        if len(preorder) == 1:\\n            return TreeNode(preorder[0])\\n        \\n        root = TreeNode(preorder[0])\\n        root_index = inorder.index(preorder[0])\\n       \\n        root.left = self.buildTree(preorder[1:root_index + 1],inorder[:root_index])\\n        root.right = self.buildTree(preorder[root_index + 1:],inorder[root_index + 1:])\\n        \\n        return root\\n```\\n\\n#### Recall Preorder and Inorder Traversal\\n\\n![image](https://assets.leetcode.com/users/images/59629522-9a6e-4e73-b729-87ca9136e2ff_1608597928.7106583.png)\\n\\n\\nThe reason we are given two types of binary tree traversals is because it is not possible to construct binary tree from a single traversal. \\n\\nThese two different trees have the same ***preorder traversal*** but are not the same tree because they have a different structure \\n\\n![image](https://assets.leetcode.com/users/images/a92e9f7b-7561-4ebf-bf6d-9c12714e0ed7_1608516446.4565628.png)\\n\\nThese two different trees have the same ***inorder traversal*** but are not the same tree because they have a different structure.\\n\\n![image](https://assets.leetcode.com/users/images/9bd76cb3-ece6-4653-b7e5-1eae9b736ad4_1608600535.8761346.png)\\n\\n\\nThus these traversals on there own are not guaranteed to map to a unique binary tree. Our solution should always create the same binary tree for a given input. To put another way, there is only one possible solution for each input.\\n\\n### Building The Tree\\nrecall preorder traversal visits nodes in the order of ***root, left, right***\\nrecall inorder an inorder traversal visits nodes in the order of  ***left, root, right***. \\n\\nThus \\n* the root of the subtree will always be the first element in preorder. \\n* to construct the left subtree, we take all the nodes to the left of the root value (from inorder)\\n* to construct the right subtree, we take all the nodes to the right of the root (from inoder) \\n\\n![image](https://assets.leetcode.com/users/images/9e99d152-f939-4e4b-940c-b77d02e9e3fc_1608589671.2400317.png)\\n\\n\\n\\n\\n### Implementation Details \\nThe tree is constructed in a recrusive depth-first manner. two seperate recursive calls are made for left and right subtree respectively. (recursion tree below) \\n\\n![image](https://assets.leetcode.com/users/images/14aa6fe1-8295-49c9-9d75-bc05e4e71c7d_1608597526.9850812.png)\\n\\n\\n\\nAt each recursive call we only look at nodes that are potential candidates for later subtrees. \\n\\nWhen we go the left, we only want nodes from both inorder and preorder that reside in the left subtree. same for when we go to the right.\\n\\n* for the inorder array \\n\\t* going to the left, we want all nodes to the left of the root. that is ```inorder[:root_index]```\\n\\t* going to the right, we want all nodes to the right of the root. that is ```inorder[root_index + 1:]```\\n* for the ```preorder``` array\\n\\t* going to the left, we want all nodes that could eventually become a root, for a left subtree.\\n\\t* going to the right, we want all nodes that could eventually become a root, for a right subtree.\\n\\n\\nwe use the ***root_index*** from the ```inorder``` array, because ```preorder``` cannot provide us with unambigous information about which nodes reside in the left and right subtrees.\\n\\nwe know excluding the root value in ```preorder (preorder[0])```, some set of nodes must belong to the right, and some set of nodes most belong to the left. \\n\\nit turns out that the ***root_index***  from ```inorder``` corresponds to the last element in the ```preorder``` array that belongs to the left subtree. this is because ***inorder traversal*** visits nodes in the order ***left, root, right*** . \\n\\n* left: ```preorder[1:root_index + 1]```\\n* right: ```preorder[root_index + 1:]```\\n\\n\\n[code courtsey of zhshuwei](https://leetcode.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal/discuss/768384/Python-solution-using-recursive)\\n\\n\\n\\n\\n\\n\\n\\n\\n",
                "solutionTags": [
                    "Python",
                    "Recursion"
                ],
                "code": "```python\\n   def buildTree(self, preorder: List[int], inorder: List[int]) -> TreeNode:\\n        \\n        if not preorder or not inorder:\\n            return None\\n\\n        if len(preorder) == 1:\\n            return TreeNode(preorder[0])\\n        \\n        root = TreeNode(preorder[0])\\n        root_index = inorder.index(preorder[0])\\n       \\n        root.left = self.buildTree(preorder[1:root_index + 1],inorder[:root_index])\\n        root.right = self.buildTree(preorder[root_index + 1:],inorder[root_index + 1:])\\n        \\n        return root\\n```\n```inorder[:root_index]```\n```inorder[root_index + 1:]```\n```preorder```\n```inorder```\n```preorder```\n```preorder (preorder[0])```\n```inorder```\n```preorder```\n```preorder[1:root_index + 1]```\n```preorder[root_index + 1:]```",
                "codeTag": "Python3"
            },
            {
                "id": 2279180,
                "title": "python-explained",
                "content": "**UPVOTE IF HELPFuuL**\\n\\n*Inorder Traversal* -> **LEFT -> ROOT ->RIGHT**\\n*PreOrder Traversal ->* **ROOT -> LEFT -> RIGHT**\\n\\nWe have two observations :\\n* The first element in ```preorder``` is the root of the tree. Let it be ```x```\\n* Elements left to ```x``` in ```inorder``` form the **LEFT** subtree.\\n\\tElements right to ```x``` in ```inorder``` forms the **RIGHT** subtree.\\n\\n![image](https://assets.leetcode.com/users/images/172d7277-5ee4-4c4f-a2aa-dec165fc83df_1657767715.2431352.png)\\n\\n\\n**Recursive Approach**\\n\\n**BASE CASE** -> If the array ```inorder``` is empty. -> RETURN\\n**SELF WORK** -> Create a new node with the value ```preorder[0]``` as first element is the root of the tree.\\n**Recursion** -> \\n* Let the ```index``` of ```preorder[0]``` in ```inorder``` be ```INDEX```.\\n* Recursivly create **left** subtree by passing -> ```preorder with first element removed``` and the part of ```inorder``` array that lies to the left of ```INDEX```. ->```inorder[:INDEX]```\\n* Recursivly create **right** subtree by passing ->  the part of ```inorder``` array that lies to the right of ```INDEX```. ->```inorder[:INDEX]```\\n\\n\\n**UPVOTE IF HELPFuuL**\\n\\n```\\nclass Solution:\\n    def buildTree(self, preorder, inorder):\\n        if inorder:\\n            INDEX = inorder.index(preorder.pop(0))\\n            root = TreeNode(inorder[INDEX])\\n            root.left = self.buildTree(preorder, inorder[:INDEX])\\n            root.right = self.buildTree(preorder, inorder[INDEX+1:])\\n\\t\\t\\t\\n            return root\\n```\\n![image](https://assets.leetcode.com/users/images/5c6a9bd7-b687-4c36-b067-6d6e02c8ce04_1657775495.3680642.jpeg)\\n",
                "solutionTags": [
                    "Python"
                ],
                "code": "```preorder```\n```x```\n```x```\n```inorder```\n```x```\n```inorder```\n```inorder```\n```preorder[0]```\n```index```\n```preorder[0]```\n```inorder```\n```INDEX```\n```preorder with first element removed```\n```inorder```\n```INDEX```\n```inorder[:INDEX]```\n```inorder```\n```INDEX```\n```inorder[:INDEX]```\n```\\nclass Solution:\\n    def buildTree(self, preorder, inorder):\\n        if inorder:\\n            INDEX = inorder.index(preorder.pop(0))\\n            root = TreeNode(inorder[INDEX])\\n            root.left = self.buildTree(preorder, inorder[:INDEX])\\n            root.right = self.buildTree(preorder, inorder[INDEX+1:])\\n\\t\\t\\t\\n            return root\\n```",
                "codeTag": "Java"
            },
            {
                "id": 34541,
                "title": "5ms-java-clean-solution-with-caching",
                "content": "In this questions, most of people just loop through `inorder[]` to find the root. However, by caching positions of `inorder[]` indices using a **HashMap**, the run time can drop from `20ms` to `5ms`. \\n\\nHere is my 5ms AC solution:\\n\\n    public TreeNode buildTree(int[] preorder, int[] inorder) {\\n        Map<Integer, Integer> inMap = new HashMap<Integer, Integer>();\\n        \\n        for(int i = 0; i < inorder.length; i++) {\\n            inMap.put(inorder[i], i);\\n        }\\n\\n        TreeNode root = buildTree(preorder, 0, preorder.length - 1, inorder, 0, inorder.length - 1, inMap);\\n        return root;\\n    }\\n    \\n    public TreeNode buildTree(int[] preorder, int preStart, int preEnd, int[] inorder, int inStart, int inEnd, Map<Integer, Integer> inMap) {\\n        if(preStart > preEnd || inStart > inEnd) return null;\\n        \\n        TreeNode root = new TreeNode(preorder[preStart]);\\n        int inRoot = inMap.get(root.val);\\n        int numsLeft = inRoot - inStart;\\n        \\n        root.left = buildTree(preorder, preStart + 1, preStart + numsLeft, inorder, inStart, inRoot - 1, inMap);\\n        root.right = buildTree(preorder, preStart + numsLeft + 1, preEnd, inorder, inRoot + 1, inEnd, inMap);\\n        \\n        return root;\\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "In this questions, most of people just loop through `inorder[]` to find the root. However, by caching positions of `inorder[]` indices using a **HashMap**, the run time can drop from `20ms` to `5ms`. \\n\\nHere is my 5ms AC solution:\\n\\n    public TreeNode buildTree(int[] preorder, int[] inorder) {\\n        Map<Integer, Integer> inMap = new HashMap<Integer, Integer>();\\n        \\n        for(int i = 0; i < inorder.length; i++) {\\n            inMap.put(inorder[i], i);\\n        }\\n\\n        TreeNode root = buildTree(preorder, 0, preorder.length - 1, inorder, 0, inorder.length - 1, inMap);\\n        return root;\\n    }\\n    \\n    public TreeNode buildTree(int[] preorder, int preStart, int preEnd, int[] inorder, int inStart, int inEnd, Map<Integer, Integer> inMap) {\\n        if(preStart > preEnd || inStart > inEnd) return null;\\n        \\n        TreeNode root = new TreeNode(preorder[preStart]);\\n        int inRoot = inMap.get(root.val);\\n        int numsLeft = inRoot - inStart;\\n        \\n        root.left = buildTree(preorder, preStart + 1, preStart + numsLeft, inorder, inStart, inRoot - 1, inMap);\\n        root.right = buildTree(preorder, preStart + numsLeft + 1, preEnd, inorder, inRoot + 1, inEnd, inMap);\\n        \\n        return root;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1028083,
                "title": "my-neat-cpp-solution-16ms",
                "content": "```\\nint preInd=0;\\nTreeNode *buildTree(vector<int> &preorder, vector<int> &inorder) {\\n    return createTree(preorder,inorder,0,inorder.size() - 1);\\n}\\nTreeNode* createTree(vector<int>& preorder, vector<int>& inorder,int start, int end){\\n    if(start > end){\\n        return NULL;\\n    }\\n    TreeNode* node=new TreeNode(preorder[preInd++]);\\n    int pos;\\n    for(int i=start;i<=end;i++){\\n        if(inorder[i]==node->val){\\n            pos=i;\\n            break;\\n        }\\n    }\\n    node->left =createTree(preorder, inorder,start,pos-1);\\n    node->right =createTree(preorder, inorder, pos+1,end);\\n    return node;\\n}\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Recursion"
                ],
                "code": "```\\nint preInd=0;\\nTreeNode *buildTree(vector<int> &preorder, vector<int> &inorder) {\\n    return createTree(preorder,inorder,0,inorder.size() - 1);\\n}\\nTreeNode* createTree(vector<int>& preorder, vector<int>& inorder,int start, int end){\\n    if(start > end){\\n        return NULL;\\n    }\\n    TreeNode* node=new TreeNode(preorder[preInd++]);\\n    int pos;\\n    for(int i=start;i<=end;i++){\\n        if(inorder[i]==node->val){\\n            pos=i;\\n            break;\\n        }\\n    }\\n    node->left =createTree(preorder, inorder,start,pos-1);\\n    node->right =createTree(preorder, inorder, pos+1,end);\\n    return node;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 34562,
                "title": "sharing-my-straightforward-recursive-solution",
                "content": "    TreeNode *buildTree(vector<int> &preorder, vector<int> &inorder) {\\n        return create(preorder, inorder, 0, preorder.size() - 1, 0, inorder.size() - 1);\\n    }\\n    \\n    TreeNode* create(vector<int>& preorder, vector<int>& inorder, int ps, int pe, int is, int ie){\\n        if(ps > pe){\\n            return nullptr;\\n        }\\n        TreeNode* node = new TreeNode(preorder[ps]);\\n        int pos;\\n        for(int i = is; i <= ie; i++){\\n            if(inorder[i] == node->val){\\n                pos = i;\\n                break;\\n            }\\n        }\\n        node->left = create(preorder, inorder, ps + 1, ps + pos - is, is, pos - 1);\\n        node->right = create(preorder, inorder, pe - ie + pos + 1, pe, pos + 1, ie);\\n        return node;\\n    }\\n\\nThe first element in preorder array can divide inorder array into two parts. Then we can divide preorder array into two parts. Make this element a node. And the left sub-tree of this node is the left part, right sub-tree of this node is the right part. This problem can be solved following this logic.",
                "solutionTags": [
                    "C++"
                ],
                "code": "    TreeNode *buildTree(vector<int> &preorder, vector<int> &inorder) {\\n        return create(preorder, inorder, 0, preorder.size() - 1, 0, inorder.size() - 1);\\n    }\\n    \\n    TreeNode* create(vector<int>& preorder, vector<int>& inorder, int ps, int pe, int is, int ie){\\n        if(ps > pe){\\n            return nullptr;\\n        }\\n        TreeNode* node = new TreeNode(preorder[ps]);\\n        int pos;\\n        for(int i = is; i <= ie; i++){\\n            if(inorder[i] == node->val){\\n                pos = i;\\n                break;\\n            }\\n        }\\n        node->left = create(preorder, inorder, ps + 1, ps + pos - is, is, pos - 1);\\n        node->right = create(preorder, inorder, pe - ie + pos + 1, pe, pos + 1, ie);\\n        return node;\\n    }\\n\\nThe first element in preorder array can divide inorder array into two parts. Then we can divide preorder array into two parts. Make this element a node. And the left sub-tree of this node is the left part, right sub-tree of this node is the right part. This problem can be solved following this logic.",
                "codeTag": "Unknown"
            },
            {
                "id": 1258712,
                "title": "js-python-java-c-easy-recursive-solution-w-explanation",
                "content": "*(Note: This is part of a series of Leetcode solution explanations. If you like this solution or find it useful,* ***please upvote*** *this post.)*\\n\\n---\\n\\n#### ***Idea:***\\n\\nFor this solution, we can take advantage of the order of nodes in the **preorder** and **inorder** traversals. A preorder traversal is **[node, left, right]** while an inorder traversal is **[left, node, right]**.\\n\\nWe know that the **root** node for a tree is the first element of the preorder array (**P**). We also know that every element to the left of the root element in the inorder array (**I**) is on the left subtree, and everything to the right of the **root** element in **I** is on the right subtree.\\n\\nSince we know the length of the left and right subtrees by finding the **root** in **I**, and since we know the order of the left and right subtrees in **P**, we can use that to determine the location of the **root** node in **P** for each of the two subtrees.\\n\\nWith this information, we can define a **recursive** helper function (**splitTree**) that will split the tree into two and then recursively do the same for each subtree.\\n\\n![Visual 1](https://i.imgur.com/qZZqFyY.gif)\\n\\nIn order to make this work, we just need to pass left and right limits (**ileft, iright**) defining the subarray of the current subtree in **I**, as well as the index (**pix**) of the **root** node of the subtree in **P**.\\n\\nAt this point, we _could_ iterate forward through **I** until we found out the location (**imid**) of the **root** node each time, but that would push this solution to a **time complexity** of **O(N^2)**.\\n\\nInstead, we can make a prelimanary **index map** (**M**) of the values in **I**, so that we can look up the value for **imid** in **O(1) time** in each recursion. This will lower the time complexity to **O(N)** at the cost of a **space complexity** of **O(N)**.\\n\\nIn the example in the graphic above, where **P = [8,2,7,1,9,3,6]** and **I = [7,2,1,8,3,9,6]**, the **root** would be **8**, so we know that **imid** (its location in **I**) is **3**, and since we still are using the full array, **ileft = 0** and **iright = I.length-1**, or **6**. This means that the left subtree is **imid - ileft = 3** elements long (**[7,2,1]** to the left of **8** in **I**) and the right subtree is **iright - imid = 3** elements long (**[3,9,6]** to the right of **8** in **I**).\\n\\nWe can apply those dimensions from **I** to figure out the ranges of those subtrees in **P**, as well. The left subtree will start right after the **root** in **P** (**pix + 1**), and the right subtree will start once the left subtree ends (**pix + 1 + (imid - ileft)**.\\n\\nAt each recursion, if **imid = ileft**, then there are no nodes in the left subtree, so we shouldn\\'t call a recursion for that side. The same applies to the right side if **imid = iright**.\\n\\n - _**Time Complexity: O(N)** where **N** is the length of **P** and **I**_\\n - _**Space Complexity: O(N)** for **M**_\\n\\n---\\n\\n#### ***Javascript Code:***\\n```javascript\\nvar buildTree = function(P, I) {\\n    let M = new Map()\\n    for (let i = 0; i < I.length; i++)\\n        M.set(I[i], i)\\n    return splitTree(P, M, 0, 0, I.length-1)\\n};\\n\\nvar splitTree = function(P, M, pix, ileft, iright) {\\n    let rval = P[pix],\\n        root = new TreeNode(rval),\\n        imid = M.get(rval)\\n    if (imid > ileft)\\n        root.left = splitTree(P, M, pix+1, ileft, imid-1)\\n    if (imid < iright)\\n        root.right = splitTree(P, M, pix+imid-ileft+1, imid+1, iright)\\n    return root\\n}\\n```\\n\\n---\\n\\n#### ***Python Code:***\\n```python\\nclass Solution:\\n    def buildTree(self, P: List[int], I: List[int]) -> TreeNode:\\n        M = {I[i]: i for i in range(len(I))}\\n        return self.splitTree(P, M, 0, 0, len(P)-1)\\n    \\n    def splitTree(self, P: List[int], M: dict, pix: int, ileft: int, iright: int) -> TreeNode:\\n        rval = P[pix]\\n        root, imid = TreeNode(rval), M[rval]\\n        if imid > ileft:\\n            root.left = self.splitTree(P, M, pix+1, ileft, imid-1)\\n        if imid < iright:\\n            root.right = self.splitTree(P, M, pix+imid-ileft+1, imid+1, iright)\\n        return root\\n```\\n\\n---\\n\\n#### ***Java Code:***\\n```java\\nclass Solution {\\n    public TreeNode buildTree(int[] P, int[] I) {\\n        Map<Integer, Integer> M = new HashMap<>();\\n        for (int i = 0; i < I.length; i++)\\n            M.put(I[i], i);\\n        return splitTree(P, M, 0, 0, I.length-1);\\n    }\\n    \\n    private TreeNode splitTree(int[] P, Map<Integer, Integer> M, int pix, int ileft, int iright) {\\n        int rval = P[pix], imid = M.get(rval);\\n        TreeNode root = new TreeNode(rval);            \\n        if (imid > ileft)\\n            root.left = splitTree(P, M, pix+1, ileft, imid-1);\\n        if (imid < iright)\\n            root.right = splitTree(P, M, pix+imid-ileft+1, imid+1, iright);\\n        return root;\\n    }\\n}\\n```\\n\\n---\\n\\n#### ***C++ Code:***\\n```c++\\nclass Solution {\\npublic:\\n    TreeNode* buildTree(vector<int>& P, vector<int>& I) {\\n        unordered_map<int, int> M;\\n        for (int i = 0; i < I.size(); i++)\\n            M[I[i]] = i;\\n        return splitTree(P, M, 0, 0, I.size()-1);\\n    }\\n    \\nprivate:\\n    TreeNode* splitTree(vector<int>& P, unordered_map<int, int>& M, int pix, int ileft, int iright) {\\n        int rval = P[pix], imid = M[rval];\\n        TreeNode* root = new TreeNode(rval);            \\n        if (imid > ileft)\\n            root->left = splitTree(P, M, pix+1, ileft, imid-1);\\n        if (imid < iright)\\n            root->right = splitTree(P, M, pix+imid-ileft+1, imid+1, iright);\\n        return root;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Java",
                    "Python",
                    "C",
                    "JavaScript"
                ],
                "code": "```javascript\\nvar buildTree = function(P, I) {\\n    let M = new Map()\\n    for (let i = 0; i < I.length; i++)\\n        M.set(I[i], i)\\n    return splitTree(P, M, 0, 0, I.length-1)\\n};\\n\\nvar splitTree = function(P, M, pix, ileft, iright) {\\n    let rval = P[pix],\\n        root = new TreeNode(rval),\\n        imid = M.get(rval)\\n    if (imid > ileft)\\n        root.left = splitTree(P, M, pix+1, ileft, imid-1)\\n    if (imid < iright)\\n        root.right = splitTree(P, M, pix+imid-ileft+1, imid+1, iright)\\n    return root\\n}\\n```\n```python\\nclass Solution:\\n    def buildTree(self, P: List[int], I: List[int]) -> TreeNode:\\n        M = {I[i]: i for i in range(len(I))}\\n        return self.splitTree(P, M, 0, 0, len(P)-1)\\n    \\n    def splitTree(self, P: List[int], M: dict, pix: int, ileft: int, iright: int) -> TreeNode:\\n        rval = P[pix]\\n        root, imid = TreeNode(rval), M[rval]\\n        if imid > ileft:\\n            root.left = self.splitTree(P, M, pix+1, ileft, imid-1)\\n        if imid < iright:\\n            root.right = self.splitTree(P, M, pix+imid-ileft+1, imid+1, iright)\\n        return root\\n```\n```java\\nclass Solution {\\n    public TreeNode buildTree(int[] P, int[] I) {\\n        Map<Integer, Integer> M = new HashMap<>();\\n        for (int i = 0; i < I.length; i++)\\n            M.put(I[i], i);\\n        return splitTree(P, M, 0, 0, I.length-1);\\n    }\\n    \\n    private TreeNode splitTree(int[] P, Map<Integer, Integer> M, int pix, int ileft, int iright) {\\n        int rval = P[pix], imid = M.get(rval);\\n        TreeNode root = new TreeNode(rval);            \\n        if (imid > ileft)\\n            root.left = splitTree(P, M, pix+1, ileft, imid-1);\\n        if (imid < iright)\\n            root.right = splitTree(P, M, pix+imid-ileft+1, imid+1, iright);\\n        return root;\\n    }\\n}\\n```\n```c++\\nclass Solution {\\npublic:\\n    TreeNode* buildTree(vector<int>& P, vector<int>& I) {\\n        unordered_map<int, int> M;\\n        for (int i = 0; i < I.size(); i++)\\n            M[I[i]] = i;\\n        return splitTree(P, M, 0, 0, I.size()-1);\\n    }\\n    \\nprivate:\\n    TreeNode* splitTree(vector<int>& P, unordered_map<int, int>& M, int pix, int ileft, int iright) {\\n        int rval = P[pix], imid = M[rval];\\n        TreeNode* root = new TreeNode(rval);            \\n        if (imid > ileft)\\n            root->left = splitTree(P, M, pix+1, ileft, imid-1);\\n        if (imid < iright)\\n            root->right = splitTree(P, M, pix+imid-ileft+1, imid+1, iright);\\n        return root;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2279613,
                "title": "c-recursive-using-map-approaches",
                "content": "**Upvote if you like the post :)**\\n\\n**Visual Demonstration Below :-**\\n![image](https://leetcode.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal/Figures/105/105-Page-2.png)\\n\\n**Recursive Approach(C++):**\\n**Intuition:** Basically we start from `Idx` 0 & find `preorder`[Idx] from `inorder`, let\\'s call it as index `pivot`.\\nThen we create a `new` `node` with `inorder`[pivot] simultaneoulsy create its `left` child `recursively` and it\\'s `right` child `recursively` and finally return the `new` node.\\n\\n```\\nclass Solution {\\npublic:\\n    TreeNode* buildTree(vector<int>& preorder, vector<int>& inorder) {\\n\\t\\tint n = inorder.size();\\n        int Idx = 0;\\n        return helper(preorder, inorder, Idx, 0, n-1);\\n    }\\n    \\n    TreeNode* helper(vector<int>& preorder, vector<int>& inorder, int& Idx, int left, int right) {\\n        if (left > right) return NULL;\\n        int pivot = left;  // find the root from inorder\\n        while(inorder[pivot] != preorder[Idx]) pivot++;\\n        \\n        Idx++;\\n        TreeNode* newNode = new TreeNode(inorder[pivot]);\\n        newNode->left = helper(preorder, inorder, Idx, left, pivot-1);\\n        newNode->right = helper(preorder, inorder, Idx, pivot+1, right);\\n        return newNode;\\n    }\\n};\\n```\\n****\\n**Time Complexity: O(N^2)**\\n**Space Complexity : O(N)**\\n****\\n**Using Map Approach(C++):**\\n```\\nclass Solution {\\npublic:\\n    TreeNode* buildTree(vector<int>& preorder, vector<int>& inorder) {\\n        map<int,int> mp;\\n        for(int i=0;i<preorder.size();i++){\\n            mp[inorder[i]]=i;\\n        }\\n        TreeNode* root = construct(preorder,0,preorder.size()-1,inorder,0,inorder.size()-1,mp);\\n        return root;\\n    }\\n    TreeNode* construct(vector<int>&preorder, int preStart, int preEnd, vector<int> &inorder,int inStart, int inEnd, map<int,int> &mp){\\n        if(preStart>preEnd || inStart>inEnd) return NULL;\\n        TreeNode* root = new TreeNode(preorder[preStart]);\\n        int inRoot = mp[root->val];\\n        int numsLeft = inRoot-inStart;\\n        \\n        root->left = construct(preorder,preStart+1,preStart+numsLeft,inorder,inStart,inRoot-1,mp);\\n        root->right = construct(preorder,preStart+numsLeft+1,preEnd,inorder,inRoot+1,inEnd,mp);\\n        return root;\\n    }\\n};\\n```\\n****\\n**Time Complexity: O(N)**\\n**Space Complexity : O(N)**\\n****",
                "solutionTags": [
                    "C++",
                    "C",
                    "Recursion",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    TreeNode* buildTree(vector<int>& preorder, vector<int>& inorder) {\\n\\t\\tint n = inorder.size();\\n        int Idx = 0;\\n        return helper(preorder, inorder, Idx, 0, n-1);\\n    }\\n    \\n    TreeNode* helper(vector<int>& preorder, vector<int>& inorder, int& Idx, int left, int right) {\\n        if (left > right) return NULL;\\n        int pivot = left;  // find the root from inorder\\n        while(inorder[pivot] != preorder[Idx]) pivot++;\\n        \\n        Idx++;\\n        TreeNode* newNode = new TreeNode(inorder[pivot]);\\n        newNode->left = helper(preorder, inorder, Idx, left, pivot-1);\\n        newNode->right = helper(preorder, inorder, Idx, pivot+1, right);\\n        return newNode;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    TreeNode* buildTree(vector<int>& preorder, vector<int>& inorder) {\\n        map<int,int> mp;\\n        for(int i=0;i<preorder.size();i++){\\n            mp[inorder[i]]=i;\\n        }\\n        TreeNode* root = construct(preorder,0,preorder.size()-1,inorder,0,inorder.size()-1,mp);\\n        return root;\\n    }\\n    TreeNode* construct(vector<int>&preorder, int preStart, int preEnd, vector<int> &inorder,int inStart, int inEnd, map<int,int> &mp){\\n        if(preStart>preEnd || inStart>inEnd) return NULL;\\n        TreeNode* root = new TreeNode(preorder[preStart]);\\n        int inRoot = mp[root->val];\\n        int numsLeft = inRoot-inStart;\\n        \\n        root->left = construct(preorder,preStart+1,preStart+numsLeft,inorder,inStart,inRoot-1,mp);\\n        root->right = construct(preorder,preStart+numsLeft+1,preEnd,inorder,inRoot+1,inEnd,mp);\\n        return root;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 34557,
                "title": "my-neat-c-solution",
                "content": "    class Solution {\\n    \\n    public:\\n        /* from Preorder and Inorder Traversal */\\n        TreeNode* buildTree(vector<int>& preorder, vector<int>& inorder) {\\n    \\n            return helper(preorder,0,preorder.size(),inorder,0,inorder.size());\\n        \\n        }\\n    \\n        TreeNode* helper(vector<int>& preorder,int i,int j,vector<int>& inorder,int ii,int jj)\\n        {\\n            // tree        8 4 5 3 7 3\\n            // preorder    8 [4 3 3 7] [5]\\n            // inorder     [3 3 4 7] 8 [5]\\n    \\n            // \\u6bcf\\u6b21\\u4ece preorder \\u5934\\u90e8\\u53d6\\u4e00\\u4e2a\\u503c mid\\uff0c\\u4f5c\\u4e3a\\u6811\\u7684\\u6839\\u8282\\u70b9\\n            // \\u68c0\\u67e5 mid \\u5728 inorder \\u4e2d \\u7684\\u4f4d\\u7f6e\\uff0c\\u5219 mid \\u524d\\u9762\\u90e8\\u5206\\u5c06\\u4f5c\\u4e3a \\u6811\\u7684\\u5de6\\u5b50\\u6811\\uff0c\\u53f3\\u90e8\\u5206\\u4f5c\\u4e3a\\u6811\\u7684\\u53f3\\u5b50\\u6811\\n    \\n            if(i >= j || ii >= j)\\n                return NULL;\\n    \\n            int mid = preorder[i];\\n            auto f = find(inorder.begin() + ii,inorder.begin() + jj,mid);\\n    \\n            int dis = f - inorder.begin() - ii;\\n    \\n            TreeNode* root = new TreeNode(mid);\\n            root -> left = helper(preorder,i + 1,i + 1 + dis,inorder,ii,ii + dis);\\n            root -> right = helper(preorder,i + 1 + dis,j,inorder,ii + dis + 1,jj);\\n            return root;\\n        }\\n    };",
                "solutionTags": [],
                "code": "class Solution {\\n    \\n    public:\\n        /* from Preorder and Inorder Traversal */\\n        TreeNode* buildTree(vector<int>& preorder, vector<int>& inorder) {\\n    \\n            return helper(preorder,0,preorder.size(),inorder,0,inorder.size());\\n        \\n        }",
                "codeTag": "Java"
            },
            {
                "id": 34553,
                "title": "simple-javascript-solution",
                "content": "The basic idea is: from the preorder array, we know that the value of the root node is the first element, since the inorder array doesn't contain duplicate values, from the inorder array, we can find out the index of the root value, with this index, we can calculate how many nodes are there in the left and right subtrees, based on these information we can recursively rebuild the whole tree.\\n\\nFor example, we have this tree below:\\n```\\n            1\\n           / \\\\\\n          2   3\\n         / \\\\   \\\\\\n        4   5   6\\n```\\nthe preorder and inorder arrays are:\\n\\npreorder: 1 2 4 5 3 6\\ninorder:  4 2 5 1 3 6\\n\\nlet's group the left nodes with ( ) and right nodes with [ ]:\\n\\npreorder: 1 (2 4 5) [3 6]\\ninorder:  (4 2 5) 1 [3 6]\\n\\nwe can then build the left subtree using the following preorder and inorder arrays:\\n\\npreorder: 2 4 5\\ninorder: 4 2 5\\n\\nand for the right subtree:\\n\\npreorder: 3 6\\ninorder: 3 6\\n\\nFollowing is the JavaScript code:\\n```\\n/**\\n * @param {number[]} preorder\\n * @param {number[]} inorder\\n * @return {TreeNode}\\n */\\nvar buildTree = function(preorder, inorder) {\\n    function helper(p1, p2, i1, i2) {\\n        if (p1 > p2 || i1 > i2) return null; // sanity check\\n\\n        var value = preorder[p1],           // get the root value\\n            index = inorder.indexOf(value), // get inorder position\\n            nLeft = index - i1,             // count nodes in left subtree\\n            root  = new TreeNode(value);    // build the root node\\n\\n        // build the left and right subtrees recursively\\n        root.left  = helper(p1 + 1, p1 + nLeft, i1, index - 1);\\n        root.right = helper(p1 + nLeft + 1, p2, index + 1, i2);\\n\\n        return root;\\n    }\\n    \\n    return helper(0, preorder.length - 1, 0, inorder.length - 1);\\n};\\n```\\nNoted that I use indexOf, this increases the time complexity, ideally we should cache the positions of the elements in the inorder array, but for the sake of simplicity, indexOf should be fine.",
                "solutionTags": [],
                "code": "```\\n            1\\n           / \\\\\\n          2   3\\n         / \\\\   \\\\\\n        4   5   6\\n```\n```\\n/**\\n * @param {number[]} preorder\\n * @param {number[]} inorder\\n * @return {TreeNode}\\n */\\nvar buildTree = function(preorder, inorder) {\\n    function helper(p1, p2, i1, i2) {\\n        if (p1 > p2 || i1 > i2) return null; // sanity check\\n\\n        var value = preorder[p1],           // get the root value\\n            index = inorder.indexOf(value), // get inorder position\\n            nLeft = index - i1,             // count nodes in left subtree\\n            root  = new TreeNode(value);    // build the root node\\n\\n        // build the left and right subtrees recursively\\n        root.left  = helper(p1 + 1, p1 + nLeft, i1, index - 1);\\n        root.right = helper(p1 + nLeft + 1, p2, index + 1, i2);\\n\\n        return root;\\n    }\\n    \\n    return helper(0, preorder.length - 1, 0, inorder.length - 1);\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 34744,
                "title": "concise-java-recursive-solution",
                "content": "    public TreeNode buildTree(int[] preorder, int[] inorder) {\\n    \\tif(preorder==null || inorder==null || inorder.length==0 || preorder.length==0) return null;\\n    \\tTreeNode root = new TreeNode(preorder[0]);\\n    \\tif(preorder.length==1) return root;\\n    \\tint breakindex = -1;\\n    \\tfor(int i=0;i<inorder.length;i++) { if(inorder[i]==preorder[0]) { breakindex=i; break;} }\\n    \\tint[] subleftpre  = Arrays.copyOfRange(preorder,1,breakindex+1);\\n    \\tint[] subleftin   = Arrays.copyOfRange(inorder,0,breakindex);\\n    \\tint[] subrightpre = Arrays.copyOfRange(preorder,breakindex+1,preorder.length);\\n    \\tint[] subrightin  = Arrays.copyOfRange(inorder,breakindex+1,inorder.length);\\n    \\troot.left  = buildTree(subleftpre,subleftin);\\n    \\troot.right = buildTree(subrightpre,subrightin);\\n    \\treturn root;\\n    }\\n\\n\\n 1. The Root of the tree is the first element in Preorder Array.\\n 2. Find the position of the Root in Inorder Array.\\n 3. Elements to the left of Root element in Inorder Array are the left\\n    subtree.\\n 4. Elements to the right of Root element in Inorder Array are the right\\n    subtree.\\n 5. Call recursively buildTree on the subarray composed by the elements\\n    in the left subtree. Attach returned left subtree root as left child\\n    of Root node.\\n 6. Call recursively buildTree on the subarray composed by the elements\\n    in the right subtree. Attach returned right subtree root as right\\n    child of Root node.\\n 7. return Root.",
                "solutionTags": [
                    "Java",
                    "Recursion"
                ],
                "code": "    public TreeNode buildTree(int[] preorder, int[] inorder) {\\n    \\tif(preorder==null || inorder==null || inorder.length==0 || preorder.length==0) return null;\\n    \\tTreeNode root = new TreeNode(preorder[0]);\\n    \\tif(preorder.length==1) return root;\\n    \\tint breakindex = -1;\\n    \\tfor(int i=0;i<inorder.length;i++) { if(inorder[i]==preorder[0]) { breakindex=i; break;} }\\n    \\tint[] subleftpre  = Arrays.copyOfRange(preorder,1,breakindex+1);\\n    \\tint[] subleftin   = Arrays.copyOfRange(inorder,0,breakindex);\\n    \\tint[] subrightpre = Arrays.copyOfRange(preorder,breakindex+1,preorder.length);\\n    \\tint[] subrightin  = Arrays.copyOfRange(inorder,breakindex+1,inorder.length);\\n    \\troot.left  = buildTree(subleftpre,subleftin);\\n    \\troot.right = buildTree(subrightpre,subrightin);\\n    \\treturn root;\\n    }\\n\\n\\n 1. The Root of the tree is the first element in Preorder Array.\\n 2. Find the position of the Root in Inorder Array.\\n 3. Elements to the left of Root element in Inorder Array are the left\\n    subtree.\\n 4. Elements to the right of Root element in Inorder Array are the right\\n    subtree.\\n 5. Call recursively buildTree on the subarray composed by the elements\\n    in the left subtree. Attach returned left subtree root as left child\\n    of Root node.\\n 6. Call recursively buildTree on the subarray composed by the elements\\n    in the right subtree. Attach returned right subtree root as right\\n    child of Root node.\\n 7. return Root.",
                "codeTag": "Unknown"
            },
            {
                "id": 401124,
                "title": "python-easy-solution-with-comments",
                "content": "```python\\n# Definition for a binary tree node.\\n# class TreeNode(object):\\n#     def __init__(self, x):\\n#         self.val = x\\n#         self.left = None\\n#         self.right = None\\n\\nclass Solution(object):\\n    def buildTree(self, preorder, inorder):\\n        \"\"\"\\n        :type preorder: List[int]\\n        :type inorder: List[int]\\n        :rtype: TreeNode\\n        \"\"\"\\n        \\n        # Recursive solution\\n        if inorder:   \\n            # Find index of root node within in-order traversal\\n            index = inorder.index(preorder.pop(0))\\n            root = TreeNode(inorder[index])\\n            \\n            # Recursively generate left subtree starting from \\n            # 0th index to root index within in-order traversal\\n            root.left = self.buildTree(preorder, inorder[:index])\\n            \\n            # Recursively generate right subtree starting from \\n            # next of root index till last index\\n            root.right = self.buildTree(preorder, inorder[index+1:])\\n            return root\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Recursion"
                ],
                "code": "```python\\n# Definition for a binary tree node.\\n# class TreeNode(object):\\n#     def __init__(self, x):\\n#         self.val = x\\n#         self.left = None\\n#         self.right = None\\n\\nclass Solution(object):\\n    def buildTree(self, preorder, inorder):\\n        \"\"\"\\n        :type preorder: List[int]\\n        :type inorder: List[int]\\n        :rtype: TreeNode\\n        \"\"\"\\n        \\n        # Recursive solution\\n        if inorder:   \\n            # Find index of root node within in-order traversal\\n            index = inorder.index(preorder.pop(0))\\n            root = TreeNode(inorder[index])\\n            \\n            # Recursively generate left subtree starting from \\n            # 0th index to root index within in-order traversal\\n            root.left = self.buildTree(preorder, inorder[:index])\\n            \\n            # Recursively generate right subtree starting from \\n            # next of root index till last index\\n            root.right = self.buildTree(preorder, inorder[index+1:])\\n            return root\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2088552,
                "title": "simple-js-recursive-solution",
                "content": "```\\nconst buildTree = (preorder, inorder) => {\\n  if (!preorder.length || !inorder.length) return null;\\n  \\n  let root = new TreeNode(preorder[0]);\\n  let mid = inorder.indexOf(preorder[0]);\\n  root.left = buildTree(preorder.slice(1, mid + 1), inorder.slice(0, mid));\\n  root.right = buildTree(preorder.slice(mid + 1), inorder.slice(mid + 1));\\n  return root;\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Recursion"
                ],
                "code": "```\\nconst buildTree = (preorder, inorder) => {\\n  if (!preorder.length || !inorder.length) return null;\\n  \\n  let root = new TreeNode(preorder[0]);\\n  let mid = inorder.indexOf(preorder[0]);\\n  root.left = buildTree(preorder.slice(1, mid + 1), inorder.slice(0, mid));\\n  root.right = buildTree(preorder.slice(mid + 1), inorder.slice(mid + 1));\\n  return root;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 565412,
                "title": "detailed-python-walkthrough-from-an-o-n-2-solution-to-o-n-faster-than-99-77",
                "content": "\\nI\\'m going to assume you know the basics of how to answer the question, the answer is more pertained to coming up with an optimised solution. \\n\\n**First Solution**\\n*T: O(N^2) where N is the number if items in either the preorder or inorder list (they both have to be the same).*\\n\\nLet\\'s start with the basic recursive approach:\\n```\\n    def buildTree(self, preorder: List[int], inorder: List[int]) -> TreeNode:\\n        preorder.reverse()\\n        return self.buildTreeRec(preorder, inorder)\\n    def buildTreeRec(self, preorder, inorder):\\n        if not inorder: return None\\n        n = TreeNode(preorder.pop())\\n        i = inorder.index(n.val)\\n        n.left = self.buildTreeRec(preorder, inorder[:i])\\n        n.right = self.buildTreeRec(preorder, inorder[i+1:])\\n        return n\\n```\\nThis approach looks great and is accepted by Leetcode, but there is one great flaw with the time complexity and that is the third line in the recursive function. In Python at least, the .index function runs in N time. It will run across the entire list (array) looking for n.val. Why is this bad?\\n\\nLet\\'s say we have a SUPER unbalanced tree. Like it basically looks like a linear, y = x function where every node has no right children but just a left child. Let\\'s say it has just four nodes: A -> B -> C -> D\\n\\nIt\\'s preorder traversal is going to be: [A, B, C, D]\\nIt\\'s inorder traversal is going to be: [D, C, B, A]\\n\\nSo let\\'s take the very first iteration of the recursive function. The root of the tree (and the answer itself) is going to be A. Simple enough, we pop the value from our preorder list (pop from the right since the list has been reversed). Now we have to find it in our inorder list, in order to know which values belong in A\\'s left and right subtree. In the current approach, that means we run across the full inorder traversal list which is N nodes.\\n\\nIn the second iteration of the recursive function, we\\'ll have to run across N-1 nodes since we slice off the A. So for N nodes, we\\'ll have to run across N, then N - 1, then N-2, then N-3 etc. items in the inorder list. \\n\\nAs we all know, that\\'s an N^2 approach. So we have to do better. The most obvious solution is to remove the .index and that idea forms the basis for the second solution.\\n\\n**Second Solution**\\n\\nThe second solution uses a dictionary to store all of the values of the inorder list. Each key-value pair is the list item\\'s value and its index. So basically, inorderList[i] : i.\\n\\nThe immediate issue with this is that we can longer slice the inorderDict like we were slicing the inorder list like in the first solution. So we have to maintain two pointers, beginning and end which represents the current subsection of the inorder list on which we are currently working. \\n\\nHere\\'s the code first, and I\\'ll try to walk through an example:\\n\\n```   \\n\\tdef buildTree(self, preorder: List[int], inorder: List[int]) -> TreeNode:\\n        preorder.reverse()\\n        inorderDict = { v:i for i,v in enumerate(inorder) }\\n        return self.buildTreeHelper(preorder, inorderDict, 0, len(preorder) - 1)\\n    def buildTreeHelper(self, preorder, inorderDict, beg, end):\\n        if beg > end: return None\\n        root = TreeNode(preorder.pop())\\n        index = inorderDict[root.val]\\n        \\n        root.left = self.buildTreeHelper(preorder, inorderDict, beg, index - 1)\\n        root.right = self.buildTreeHelper(preorder, inorderDict, index + 1, end)\\n        return root\\n```\\n\\nSo in the first function, we still reverse the preorder list and make a dictionary for the inorder list. If that syntax looks confusing to you, google \\'dictionary comprehensions\\' and the Python built-in \\'enumerate()\\' function. \\n\\nThe beg and end act as bounds for the recursion. If end ever crosses beg, that means we have no nodes left. It\\'s the equivalent in the first solution of having an empty inorder list. \\n\\nLet\\'s use the example from the question itself:\\n\\npreorder = [3,9,20,15,7]\\ninorder = [9,3,15,20,7]\\n\\nSo in the first iteration of the recursive approach, we build the root node which is 3. Beg and end are 0 and 4 respectively. The root\\'s left subtree is composed of all nodes to the left of 3 in the inorder list. So just the 9.\\n\\nWhen going to the left, we only **update the end value.** That new value will be the index of 3 in the inorder list, less 1. This is equivalent to slicing the inorder list as so: list[:i]. \\n\\nIn the second iteration of the recursive function, we\\'re building the leftsubtree for the original root 3. It\\'s pretty trivial since it\\'s just one node, 9. The beg and end values here will be 0 and 0 respectively. We build the node and pop the 9 from the preorder list. We still make the calls to *try* to make 9\\'s left and right subtree. However, we know that they don\\'t exist. When we call the recursive function in both instances, both will return None.\\n\\nFor 9\\'s left subtree, the beg and end values are 0 and -1, and for the right subtree, the beg and end values are 1 and 0. Both will cause the first if statement to be true, thus retuning None. \\n\\nGoing back to the root 3, the same logic applies for the root\\'s right subtree. Only difference is, **when going right, only update the beg.**",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\n    def buildTree(self, preorder: List[int], inorder: List[int]) -> TreeNode:\\n        preorder.reverse()\\n        return self.buildTreeRec(preorder, inorder)\\n    def buildTreeRec(self, preorder, inorder):\\n        if not inorder: return None\\n        n = TreeNode(preorder.pop())\\n        i = inorder.index(n.val)\\n        n.left = self.buildTreeRec(preorder, inorder[:i])\\n        n.right = self.buildTreeRec(preorder, inorder[i+1:])\\n        return n\\n```\n```   \\n\\tdef buildTree(self, preorder: List[int], inorder: List[int]) -> TreeNode:\\n        preorder.reverse()\\n        inorderDict = { v:i for i,v in enumerate(inorder) }\\n        return self.buildTreeHelper(preorder, inorderDict, 0, len(preorder) - 1)\\n    def buildTreeHelper(self, preorder, inorderDict, beg, end):\\n        if beg > end: return None\\n        root = TreeNode(preorder.pop())\\n        index = inorderDict[root.val]\\n        \\n        root.left = self.buildTreeHelper(preorder, inorderDict, beg, index - 1)\\n        root.right = self.buildTreeHelper(preorder, inorderDict, index + 1, end)\\n        return root\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 34613,
                "title": "a-python-recursive-solution",
                "content": "The idea is to find the root first, and then recursively build each left and right subtree\\n\\nOnly Solution 3 could pass the OJ, but theoretically they should all work ... \\n\\n**Solution 1 - clean and easy to understand, but Memory Limit Exceeded ...**\\n\\n    # Definition for a  binary tree node\\n    # class TreeNode:\\n    #     def __init__(self, x):\\n    #         self.val = x\\n    #         self.left = None\\n    #         self.right = None\\n    \\n    class Solution:\\n        # @param preorder, a list of integers\\n        # @param inorder, a list of integers\\n        # @return a tree node\\n        # 1:59\\n        def buildTree(self, preorder, inorder):\\n            if not preorder or not inorder:\\n                return None\\n            \\n            rootValue = preorder[0]\\n            root = TreeNode(rootValue)\\n            inorderIndex = inorder.index(rootValue)\\n    \\n            root.left = self.buildTree(preorder[1:inorderIndex+1], inorder[:inorderIndex])\\n            root.right = self.buildTree(preorder[inorderIndex+1:], inorder[inorderIndex+1:])\\n            \\n            return root\\n\\n\\n**Solution 2 - Same as solution one, but pass index instead of doing list slicing (and thus reduce the memory usage)**\\n\\n    class Solution:\\n        # @param preorder, a list of integers\\n        # @param inorder, a list of integers\\n        # @return a tree node\\n        # 1:59\\n        def buildTree(self, preorder, inorder, preorderStart = 0, preorderEnd = None, inorderStart = 0, inorderEnd = None):\\n            if preorderEnd is None:\\n                preorderEnd = len(preorder) - 1\\n            \\n            if inorderEnd is None:\\n                inorderEnd = len(inorder) - 1\\n    \\n            if preorderStart > len(preorder) - 1 or inorderStart > inorderEnd:\\n                return None\\n            \\n            rootValue = preorder[preorderStart]\\n            root = TreeNode(rootValue)\\n            inorderIndex = inorder.index(rootValue)\\n    \\n            root.left = self.buildTree(preorder, inorder, preorderStart+1, inorderIndex, inorderStart, inorderIndex-1)\\n            root.right = self.buildTree(preorder, inorder, preorderStart+inorderIndex+1-inorderStart, preorderEnd, inorderIndex+1, inorderEnd)\\n            \\n            return root\\n\\n**Solution 3 - Based on Solution 1, we don't necessary need to slice the preorder array, when we are done with the left tree, the left half of the preorder array should already be empty**\\n\\n    # Definition for a  binary tree node\\n    # class TreeNode:\\n    #     def __init__(self, x):\\n    #         self.val = x\\n    #         self.left = None\\n    #         self.right = None\\n    \\n    class Solution:\\n        # @param preorder, a list of integers\\n        # @param inorder, a list of integers\\n        # @return a tree node\\n        # 1:59\\n        def buildTree(self, preorder, inorder):\\n            if not preorder or not inorder:\\n                return None\\n    \\n            rootValue = preorder.pop(0)\\n            root = TreeNode(rootValue)\\n            inorderIndex = inorder.index(rootValue)\\n    \\n            root.left = self.buildTree(preorder, inorder[:inorderIndex])\\n            root.right = self.buildTree(preorder, inorder[inorderIndex+1:])\\n    \\n            return root",
                "solutionTags": [
                    "Python",
                    "Recursion"
                ],
                "code": "The idea is to find the root first, and then recursively build each left and right subtree\\n\\nOnly Solution 3 could pass the OJ, but theoretically they should all work ... \\n\\n**Solution 1 - clean and easy to understand, but Memory Limit Exceeded ...**\\n\\n    # Definition for a  binary tree node\\n    # class TreeNode:\\n    #     def __init__(self, x):\\n    #         self.val = x\\n    #         self.left = None\\n    #         self.right = None\\n    \\n    class Solution:\\n        # @param preorder, a list of integers\\n        # @param inorder, a list of integers\\n        # @return a tree node\\n        # 1:59\\n        def buildTree(self, preorder, inorder):\\n            if not preorder or not inorder:\\n                return None\\n            \\n            rootValue = preorder[0]\\n            root = TreeNode(rootValue)\\n            inorderIndex = inorder.index(rootValue)\\n    \\n            root.left = self.buildTree(preorder[1:inorderIndex+1], inorder[:inorderIndex])\\n            root.right = self.buildTree(preorder[inorderIndex+1:], inorder[inorderIndex+1:])\\n            \\n            return root\\n\\n\\n**Solution 2 - Same as solution one, but pass index instead of doing list slicing (and thus reduce the memory usage)**\\n\\n    class Solution:\\n        # @param preorder, a list of integers\\n        # @param inorder, a list of integers\\n        # @return a tree node\\n        # 1:59\\n        def buildTree(self, preorder, inorder, preorderStart = 0, preorderEnd = None, inorderStart = 0, inorderEnd = None):\\n            if preorderEnd is None:\\n                preorderEnd = len(preorder) - 1\\n            \\n            if inorderEnd is None:\\n                inorderEnd = len(inorder) - 1\\n    \\n            if preorderStart > len(preorder) - 1 or inorderStart > inorderEnd:\\n                return None\\n            \\n            rootValue = preorder[preorderStart]\\n            root = TreeNode(rootValue)\\n            inorderIndex = inorder.index(rootValue)\\n    \\n            root.left = self.buildTree(preorder, inorder, preorderStart+1, inorderIndex, inorderStart, inorderIndex-1)\\n            root.right = self.buildTree(preorder, inorder, preorderStart+inorderIndex+1-inorderStart, preorderEnd, inorderIndex+1, inorderEnd)\\n            \\n            return root\\n\\n**Solution 3 - Based on Solution 1, we don't necessary need to slice the preorder array, when we are done with the left tree, the left half of the preorder array should already be empty**\\n\\n    # Definition for a  binary tree node\\n    # class TreeNode:\\n    #     def __init__(self, x):\\n    #         self.val = x\\n    #         self.left = None\\n    #         self.right = None\\n    \\n    class Solution:\\n        # @param preorder, a list of integers\\n        # @param inorder, a list of integers\\n        # @return a tree node\\n        # 1:59\\n        def buildTree(self, preorder, inorder):\\n            if not preorder or not inorder:\\n                return None\\n    \\n            rootValue = preorder.pop(0)\\n            root = TreeNode(rootValue)\\n            inorderIndex = inorder.index(rootValue)\\n    \\n            root.left = self.buildTree(preorder, inorder[:inorderIndex])\\n            root.right = self.buildTree(preorder, inorder[inorderIndex+1:])\\n    \\n            return root",
                "codeTag": "Java"
            },
            {
                "id": 34551,
                "title": "my-o-n-19ms-solution-without-recusion-hope-help-you",
                "content": "    class Solution {\\n    public:\\n        TreeNode *buildTree(vector<int> &preorder, vector<int> &inorder) {\\n            TreeNode *root=NULL; stack<TreeNode *> MyData;\\n            if(preorder.empty()) return root;\\n            root = new TreeNode(preorder[0]);\\n            MyData.push(root); int index = 0;\\n           \\tfor(int i=1; i<=preorder.size(); i++) {\\n           \\t\\tTreeNode *cur = MyData.top();\\n           \\t\\tif((MyData.top()->val)!=inorder[index]) {\\n           \\t\\t\\tcur->left = new TreeNode(preorder[i]);\\n           \\t\\t\\tMyData.push(cur->left);\\n           \\t\\t} else {\\n           \\t\\t\\twhile(!MyData.empty() && ((MyData.top()->val)==inorder[index])) {\\n           \\t\\t\\t\\tcur=MyData.top(); MyData.pop(); index++; \\n           \\t\\t\\t}\\n           \\t\\t\\tif(index<inorder.size()) {\\n           \\t\\t\\t\\tcur->right = new TreeNode(preorder[i]);\\n           \\t\\t\\t\\tMyData.push(cur->right);\\n           \\t\\t\\t} \\n           \\t\\t}  \\n           \\t}\\n           \\treturn root;\\n        }\\n    };",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n        TreeNode *buildTree(vector<int> &preorder, vector<int> &inorder) {\\n            TreeNode *root=NULL; stack<TreeNode *> MyData;\\n            if(preorder.empty()) return root;\\n            root = new TreeNode(preorder[0]);\\n            MyData.push(root); int index = 0;\\n           \\tfor(int i=1; i<=preorder.size(); i++) {\\n           \\t\\tTreeNode *cur = MyData.top();\\n           \\t\\tif((MyData.top()->val)!=inorder[index]) {\\n           \\t\\t\\tcur->left = new TreeNode(preorder[i]);\\n           \\t\\t\\tMyData.push(cur->left);\\n           \\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 1258717,
                "title": "construct-binary-tree-from-preorder-inorder-js-python-java-c-easy-recursive-sol-w-expl",
                "content": "*(Note: This is part of a series of Leetcode solution explanations. If you like this solution or find it useful,* ***please upvote*** *this post.)*\\n\\n---\\n\\n#### ***Idea:***\\n\\nFor this solution, we can take advantage of the order of nodes in the **preorder** and **inorder** traversals. A preorder traversal is **[node, left, right]** while an inorder traversal is **[left, node, right]**.\\n\\nWe know that the **root** node for a tree is the first element of the preorder array (**P**). We also know that every element to the left of the root element in the inorder array (**I**) is on the left subtree, and everything to the right of the **root** element in **I** is on the right subtree.\\n\\nSince we know the length of the left and right subtrees by finding the **root** in **I**, and since we know the order of the left and right subtrees in **P**, we can use that to determine the location of the **root** node in **P** for each of the two subtrees.\\n\\nWith this information, we can define a **recursive** helper function (**splitTree**) that will split the tree into two and then recursively do the same for each subtree.\\n\\n![Visual 1](https://i.imgur.com/qZZqFyY.gif)\\n\\nIn order to make this work, we just need to pass left and right limits (**ileft, iright**) defining the subarray of the current subtree in **I**, as well as the index (**pix**) of the **root** node of the subtree in **P**.\\n\\nAt this point, we _could_ iterate forward through **I** until we found out the location (**imid**) of the **root** node each time, but that would push this solution to a **time complexity** of **O(N^2)**.\\n\\nInstead, we can make a prelimanary **index map** (**M**) of the values in **I**, so that we can look up the value for **imid** in **O(1) time** in each recursion. This will lower the time complexity to **O(N)** at the cost of a **space complexity** of **O(N)**.\\n\\nIn the example in the graphic above, where **P = [8,2,7,1,9,3,6]** and **I = [7,2,1,8,3,9,6]**, the **root** would be **8**, so we know that **imid** (its location in **I**) is **3**, and since we still are using the full array, **ileft = 0** and **iright = I.length-1**, or **6**. This means that the left subtree is **imid - ileft = 3** elements long (**[7,2,1]** to the left of **8** in **I**) and the right subtree is **iright - imid = 3** elements long (**[3,9,6]** to the right of **8** in **I**).\\n\\nWe can apply those dimensions from **I** to figure out the ranges of those subtrees in **P**, as well. The left subtree will start right after the **root** in **P** (**pix + 1**), and the right subtree will start once the left subtree ends (**pix + 1 + (imid - ileft)**.\\n\\nAt each recursion, if **imid = ileft**, then there are no nodes in the left subtree, so we shouldn\\'t call a recursion for that side. The same applies to the right side if **imid = iright**.\\n\\n - _**Time Complexity: O(N)** where **N** is the length of **P** and **I**_\\n - _**Space Complexity: O(N)** for **M**_\\n\\n---\\n\\n#### ***Javascript Code:***\\n```javascript\\nvar buildTree = function(P, I) {\\n    let M = new Map()\\n    for (let i = 0; i < I.length; i++)\\n        M.set(I[i], i)\\n    return splitTree(P, M, 0, 0, I.length-1)\\n};\\n\\nvar splitTree = function(P, M, pix, ileft, iright) {\\n    let rval = P[pix],\\n        root = new TreeNode(rval),\\n        imid = M.get(rval)\\n    if (imid > ileft)\\n        root.left = splitTree(P, M, pix+1, ileft, imid-1)\\n    if (imid < iright)\\n        root.right = splitTree(P, M, pix+imid-ileft+1, imid+1, iright)\\n    return root\\n}\\n```\\n\\n---\\n\\n#### ***Python Code:***\\n```python\\nclass Solution:\\n    def buildTree(self, P: List[int], I: List[int]) -> TreeNode:\\n        M = {I[i]: i for i in range(len(I))}\\n        return self.splitTree(P, M, 0, 0, len(P)-1)\\n    \\n    def splitTree(self, P: List[int], M: dict, pix: int, ileft: int, iright: int) -> TreeNode:\\n        rval = P[pix]\\n        root, imid = TreeNode(rval), M[rval]\\n        if imid > ileft:\\n            root.left = self.splitTree(P, M, pix+1, ileft, imid-1)\\n        if imid < iright:\\n            root.right = self.splitTree(P, M, pix+imid-ileft+1, imid+1, iright)\\n        return root\\n```\\n\\n---\\n\\n#### ***Java Code:***\\n```java\\nclass Solution {\\n    public TreeNode buildTree(int[] P, int[] I) {\\n        Map<Integer, Integer> M = new HashMap<>();\\n        for (int i = 0; i < I.length; i++)\\n            M.put(I[i], i);\\n        return splitTree(P, M, 0, 0, I.length-1);\\n    }\\n    \\n    private TreeNode splitTree(int[] P, Map<Integer, Integer> M, int pix, int ileft, int iright) {\\n        int rval = P[pix], imid = M.get(rval);\\n        TreeNode root = new TreeNode(rval);            \\n        if (imid > ileft)\\n            root.left = splitTree(P, M, pix+1, ileft, imid-1);\\n        if (imid < iright)\\n            root.right = splitTree(P, M, pix+imid-ileft+1, imid+1, iright);\\n        return root;\\n    }\\n}\\n```\\n\\n---\\n\\n#### ***C++ Code:***\\n```c++\\nclass Solution {\\npublic:\\n    TreeNode* buildTree(vector<int>& P, vector<int>& I) {\\n        unordered_map<int, int> M;\\n        for (int i = 0; i < I.size(); i++)\\n            M[I[i]] = i;\\n        return splitTree(P, M, 0, 0, I.size()-1);\\n    }\\n    \\nprivate:\\n    TreeNode* splitTree(vector<int>& P, unordered_map<int, int>& M, int pix, int ileft, int iright) {\\n        int rval = P[pix], imid = M[rval];\\n        TreeNode* root = new TreeNode(rval);            \\n        if (imid > ileft)\\n            root->left = splitTree(P, M, pix+1, ileft, imid-1);\\n        if (imid < iright)\\n            root->right = splitTree(P, M, pix+imid-ileft+1, imid+1, iright);\\n        return root;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```javascript\\nvar buildTree = function(P, I) {\\n    let M = new Map()\\n    for (let i = 0; i < I.length; i++)\\n        M.set(I[i], i)\\n    return splitTree(P, M, 0, 0, I.length-1)\\n};\\n\\nvar splitTree = function(P, M, pix, ileft, iright) {\\n    let rval = P[pix],\\n        root = new TreeNode(rval),\\n        imid = M.get(rval)\\n    if (imid > ileft)\\n        root.left = splitTree(P, M, pix+1, ileft, imid-1)\\n    if (imid < iright)\\n        root.right = splitTree(P, M, pix+imid-ileft+1, imid+1, iright)\\n    return root\\n}\\n```\n```python\\nclass Solution:\\n    def buildTree(self, P: List[int], I: List[int]) -> TreeNode:\\n        M = {I[i]: i for i in range(len(I))}\\n        return self.splitTree(P, M, 0, 0, len(P)-1)\\n    \\n    def splitTree(self, P: List[int], M: dict, pix: int, ileft: int, iright: int) -> TreeNode:\\n        rval = P[pix]\\n        root, imid = TreeNode(rval), M[rval]\\n        if imid > ileft:\\n            root.left = self.splitTree(P, M, pix+1, ileft, imid-1)\\n        if imid < iright:\\n            root.right = self.splitTree(P, M, pix+imid-ileft+1, imid+1, iright)\\n        return root\\n```\n```java\\nclass Solution {\\n    public TreeNode buildTree(int[] P, int[] I) {\\n        Map<Integer, Integer> M = new HashMap<>();\\n        for (int i = 0; i < I.length; i++)\\n            M.put(I[i], i);\\n        return splitTree(P, M, 0, 0, I.length-1);\\n    }\\n    \\n    private TreeNode splitTree(int[] P, Map<Integer, Integer> M, int pix, int ileft, int iright) {\\n        int rval = P[pix], imid = M.get(rval);\\n        TreeNode root = new TreeNode(rval);            \\n        if (imid > ileft)\\n            root.left = splitTree(P, M, pix+1, ileft, imid-1);\\n        if (imid < iright)\\n            root.right = splitTree(P, M, pix+imid-ileft+1, imid+1, iright);\\n        return root;\\n    }\\n}\\n```\n```c++\\nclass Solution {\\npublic:\\n    TreeNode* buildTree(vector<int>& P, vector<int>& I) {\\n        unordered_map<int, int> M;\\n        for (int i = 0; i < I.size(); i++)\\n            M[I[i]] = i;\\n        return splitTree(P, M, 0, 0, I.size()-1);\\n    }\\n    \\nprivate:\\n    TreeNode* splitTree(vector<int>& P, unordered_map<int, int>& M, int pix, int ileft, int iright) {\\n        int rval = P[pix], imid = M[rval];\\n        TreeNode* root = new TreeNode(rval);            \\n        if (imid > ileft)\\n            root->left = splitTree(P, M, pix+1, ileft, imid-1);\\n        if (imid < iright)\\n            root->right = splitTree(P, M, pix+imid-ileft+1, imid+1, iright);\\n        return root;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 34707,
                "title": "recursive-solution-in-java",
                "content": "    \\n    public class Solution {\\n        public TreeNode buildTree(int[] preorder, int[] inorder) {\\n            if (preorder.length == 0) return null;\\n            return buildTree(preorder, inorder, 0, 0, inorder.length - 1);\\n        }\\n        \\n        private TreeNode buildTree(int[] preorder, int[] inorder, int preorderIndex, int start, int end) {\\n            if (start > end) return null;\\n            TreeNode node = new TreeNode(preorder[preorderIndex]);\\n            int inorderIndex = findInorderIndex(inorder, start, end, preorder[preorderIndex]);\\n            int leftTreeSize = inorderIndex - start;\\n            int rightTreeSize = end - inorderIndex;\\n            node.left = buildTree(preorder, inorder, preorderIndex + 1, start, inorderIndex - 1);\\n            node.right = buildTree(preorder, inorder, preorderIndex + leftTreeSize + 1, inorderIndex + 1, end);\\n            return node;\\n        }\\n        \\n        private int findInorderIndex(int[] inorder, int start, int end, int key) {\\n            for (int i = start; i <= end; i++) {\\n                if (inorder[i] == key) return i;\\n            }\\n            return -1;\\n        }\\n    }\\n\\nThis question is similar to the one using postorder and inorder arrays. Once one notices that the first element of preorder is the root node, the rest is fairly straightforward.",
                "solutionTags": [
                    "Java",
                    "Recursion"
                ],
                "code": "class Solution {\\n        public TreeNode buildTree(int[] preorder, int[] inorder) {\\n            if (preorder.length == 0) return null;\\n            return buildTree(preorder, inorder, 0, 0, inorder.length - 1);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 212505,
                "title": "python-solution",
                "content": "We illustrate the algorithm with an example. Consider `preorder = [5, 2, 9, 3, 20, 15, 7]`, `inorder = [9, 2, 5, 3, 15, 20, 7]`. Since, we know that preorder traversal traverses a tree in the order `root -> left subtree -> right subtree`, and inorder traversal traverses a tree in the order `left subtree -> root -> right subtree`, `5` must be thre root of the tree, and values that come before (after) `5` in `inorder` must be in the left (right) subtree of `5`. Repeating the above procedure recursively until each subtree consists of a single node, we finish constructing the whole tree. For example, the left subtree of the root `5` consists of values `9`, `2`. Furthermore, since `2` is right next to `5`, it is the root of the left subtree. Finally, since `9` comes before `2` in `inorder`, it is the left child of `2`. The same analysis applies to the right subtree of `5`, and the binary tree in the end is given by `5(2(9))(3()(20(15)(7)))`.\\n\\nWe can implement the above algorithm in an iterative fashion. To do this, we first construct a hashmap `idx` which maps a value to its inorder index. This will give us an `O(1)` look up of the inorder indices of values of a root and its child, so that we can decide if the child is a left child or right child of the root. Then we can construct the tree with the help of a `stack`. We iterate over `preorder` and create a TreeNode `node` with the corresponding value `val`. If the head is null, we let `head = node`, and push `head` into the `stack`. Else, if the inorder index `stack[-1]` is larger than that of `val`, we assign `stack[-1].left = node`, and push `node` into the `stack`. Otherwise, we pop from `stack` to until either `stack` is empty or the inorder index of `stack[-1]` is larger than that of `node`. We assign `u.right = node` for the last popped node `u` from `stack`, and then push `node` to `stack`. After iterating over `preorder`, we return `head`. \\n\\nTime complexity: `O(n)`, space complexity: `O(n)`.\\n\\n```\\nclass Solution:\\n    def buildTree(self, preorder, inorder):\\n        \"\"\"\\n        :type preorder: List[int]\\n        :type inorder: List[int]\\n        :rtype: TreeNode\\n        \"\"\"\\n\\t# construct hashmap mapping a value to its inorder index\\n        idx = {} \\n        for i, val in enumerate(inorder):\\n            idx[val] = i \\n\\t\\t\\t\\n\\t# Iterate over preorder and construct the tree \\n        stack = []\\n        head = None\\n        for val in preorder:\\n            if not head:\\n                head = TreeNode(val)\\n                stack.append(head)\\n            else:\\n                node = TreeNode(val)\\n                if idx[val] < idx[stack[-1].val]:\\n                    stack[-1].left = node\\n                else:\\n                    while stack and idx[stack[-1].val] < idx[val]:\\n                        u = stack.pop()\\n                    u.right = node\\n                stack.append(node)\\n        return head\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def buildTree(self, preorder, inorder):\\n        \"\"\"\\n        :type preorder: List[int]\\n        :type inorder: List[int]\\n        :rtype: TreeNode\\n        \"\"\"\\n\\t# construct hashmap mapping a value to its inorder index\\n        idx = {} \\n        for i, val in enumerate(inorder):\\n            idx[val] = i \\n\\t\\t\\t\\n\\t# Iterate over preorder and construct the tree \\n        stack = []\\n        head = None\\n        for val in preorder:\\n            if not head:\\n                head = TreeNode(val)\\n                stack.append(head)\\n            else:\\n                node = TreeNode(val)\\n                if idx[val] < idx[stack[-1].val]:\\n                    stack[-1].left = node\\n                else:\\n                    while stack and idx[stack[-1].val] < idx[val]:\\n                        u = stack.pop()\\n                    u.right = node\\n                stack.append(node)\\n        return head\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1258543,
                "title": "c-java-python-simple-recursion-visualization-clean-concise",
                "content": "**Idea**\\n- `preorder` traverse nodes in Binary Tree in order: Root, Left, Right\\n- `inorder` traverse nodes in Binary Tree in order: Left, Root, Right\\n- So the first element in `preorder` is our `root`, we also need a `mapVal2Idx` (map values with their index in `inorder` array) to find the `mid` index of current `root` in `inorder` array.\\n- Increase `preIdx` by one to point to next element in `preorder`, this is the root of the next subtree.\\n- Then call recursion to find `root.left` in range `[left, mid - 1]`.\\n- Call recursion to find `root.right` in range `[mid + 1, right]`.\\n\\n**Visualize**\\n![image](https://assets.leetcode.com/users/images/826dc914-2a97-4e82-90f9-c0cb8d440735_1623138370.6728706.png)\\n\\n<iframe src=\"https://leetcode.com/playground/bgpcyhhU/shared\" frameBorder=\"0\" width=\"100%\" height=\"450\"></iframe>\\n\\nComplexity:\\n- Time: `O(N)`, where `N` is number of elements in `preorder`.\\n- Space: `O(N)`",
                "solutionTags": [],
                "code": "**Idea**\\n- `preorder` traverse nodes in Binary Tree in order: Root, Left, Right\\n- `inorder` traverse nodes in Binary Tree in order: Left, Root, Right\\n- So the first element in `preorder` is our `root`, we also need a `mapVal2Idx` (map values with their index in `inorder` array) to find the `mid` index of current `root` in `inorder` array.\\n- Increase `preIdx` by one to point to next element in `preorder`, this is the root of the next subtree.\\n- Then call recursion to find `root.left` in range `[left, mid - 1]`.\\n- Call recursion to find `root.right` in range `[mid + 1, right]`.\\n\\n**Visualize**\\n![image](https://assets.leetcode.com/users/images/826dc914-2a97-4e82-90f9-c0cb8d440735_1623138370.6728706.png)\\n\\n<iframe src=\"https://leetcode.com/playground/bgpcyhhU/shared\" frameBorder=\"0\" width=\"100%\" height=\"450\"></iframe>\\n\\nComplexity:\\n- Time: `O(N)`, where `N` is number of elements in `preorder`.\\n- Space: `O(N)`",
                "codeTag": "Unknown"
            },
            {
                "id": 3302319,
                "title": "awesome-logic-python3",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def buildTree(self, preorder: List[int], inorder: List[int]) -> Optional[TreeNode]:\\n        if not preorder or not inorder:\\n            return None\\n        root=TreeNode(preorder[0])\\n        index=inorder.index(preorder[0])\\n        root.left=self.buildTree(preorder[1:index+1],inorder[:index])\\n        root.right=self.buildTree(preorder[index+1:],inorder[index+1:])\\n        return root\\n    #please upvote me it would encourage me alot\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def buildTree(self, preorder: List[int], inorder: List[int]) -> Optional[TreeNode]:\\n        if not preorder or not inorder:\\n            return None\\n        root=TreeNode(preorder[0])\\n        index=inorder.index(preorder[0])\\n        root.left=self.buildTree(preorder[1:index+1],inorder[:index])\\n        root.right=self.buildTree(preorder[index+1:],inorder[index+1:])\\n        return root\\n    #please upvote me it would encourage me alot\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 34712,
                "title": "here-is-the-iterative-solution-in-java",
                "content": "    public TreeNode buildTree(int[] preorder, int[] inorder) {\\n            if (inorder.length==0) return null; \\n            Stack<TreeNode> stack = new Stack<TreeNode>(); \\n            TreeNode root = new TreeNode(Integer.MIN_VALUE);\\n            stack.push(root); \\n            int i=0, j=0;\\n            TreeNode node = null; \\n            TreeNode cur = root; \\n            while (j<inorder.length){\\n                if (stack.peek().val == inorder[j]){\\n                    node = stack.pop(); \\n                    j++; \\n                }\\n                else if (node!=null){\\n                    cur = new TreeNode(preorder[i]); \\n                    node.right = cur;\\n                    node=null; \\n                    stack.push(cur); \\n                    i++; \\n                }\\n                else {\\n                    cur = new TreeNode(preorder[i]); \\n                    stack.peek().left = cur; \\n                    stack.push(cur);\\n                    i++; \\n                }\\n            }\\n            return root.left; \\n        }",
                "solutionTags": [
                    "Java"
                ],
                "code": "    public TreeNode buildTree(int[] preorder, int[] inorder) {\\n            if (inorder.length==0) return null; \\n            Stack<TreeNode> stack = new Stack<TreeNode>(); \\n            TreeNode root = new TreeNode(Integer.MIN_VALUE);\\n            stack.push(root); \\n            int i=0, j=0;\\n            TreeNode node = null; \\n            TreeNode cur = root; \\n            while (j<inorder.length){\\n                if (stack.peek().val == inorder[j]){\\n                    node = stack.pop(); \\n                    j++; \\n                }\\n                else if (node!=null){\\n                    cur = new TreeNode(preorder[i]); \\n                    node.right = cur;\\n                    node=null; \\n                    stack.push(cur); \\n                    i++; \\n                }\\n                else {\\n                    cur = new TreeNode(preorder[i]); \\n                    stack.peek().left = cur; \\n                    stack.push(cur);\\n                    i++; \\n                }\\n            }\\n            return root.left; \\n        }",
                "codeTag": "Unknown"
            },
            {
                "id": 1258585,
                "title": "python-intuitive-o-n-solution-explained",
                "content": "In preorder we have `root, left, right` and in inorder we have `left, root, right`. Note that `root` is the first element in preorder traveral, we find it in the inorder traversal and hence we know number of elements in `left` and  `right` parts, and hence we do a recursion, given two new lists for each `left` and `right`. \\n\\nTo make it faster we need couple of optimizations:\\n\\n1. Be careful with memory, we need to give only 4 indexes: for beginning and end of current preorder and inorder, not full lists. In fact we will keep shifted end indexes, so for range `[a, b]` we will keep pair `(a, b+1)`.\\n2. At the moment the most expensive part is to search element in list a lot. At the moment the worst time complexity can be `O(n^2) (though `O(n log n) in average which is not so bad). To make it `O(n)` we precalculate all places for elements only once (we can not have equal elements).\\n\\nHow our recursion will work now:\\n1. If we have empty list, return `None`: non-existing node.\\n2. Find the place `ind` of the first element in our preorder list, that is `dic[preorder[pr_beg]]`.\\n3. Create root node with this element.\\n4. Recursively attach left and right children and return root. We can understand the lenghts of parts, using `ind`, and then evaluate indexes of preorder split, using this information: see diagramm below.\\n\\n`pr_beg, [pr_beg + 1, .... , pr_beg + ind - in_beg], [pr_beg + ind - in_beg + 1, ... , pr_end - 1]`\\n`[in_beg, ... , ind - 1], ind, [ind + 1, ..., in_end - 1]`\\n\\n#### Complexity\\nIn the end function `helper` will be called in total `n` times, and each time will take just `O(1)` time, alsow we have `O(n)` time to create `dic`. so overall complexity is `O(n)`. Space complexity is `O(n)` as well to keep our answer.\\n\\n#### Code\\n```python\\nclass Solution:\\n    def buildTree(self, preorder, inorder):\\n        def helper(pr_beg, pr_end, in_beg, in_end):\\n            if pr_end - pr_beg <= 0: return None\\n            ind = dic[preorder[pr_beg]]\\n            root = TreeNode(inorder[ind])  \\n            root.left  = helper(pr_beg + 1, pr_beg + 1 + ind - in_beg, in_beg, ind)\\n            root.right = helper(pr_beg + ind - in_beg + 1, pr_end, ind + 1, in_end)\\n            return root\\n        \\n        dic = {elem: it for it, elem in enumerate(inorder)}  \\n        return helper(0, len(preorder), 0, len(inorder))\\n```\\n\\nIf you have any questions, feel free to ask. If you like solution and explanations, please **Upvote!**",
                "solutionTags": [
                    "Recursion"
                ],
                "code": "```python\\nclass Solution:\\n    def buildTree(self, preorder, inorder):\\n        def helper(pr_beg, pr_end, in_beg, in_end):\\n            if pr_end - pr_beg <= 0: return None\\n            ind = dic[preorder[pr_beg]]\\n            root = TreeNode(inorder[ind])  \\n            root.left  = helper(pr_beg + 1, pr_beg + 1 + ind - in_beg, in_beg, ind)\\n            root.right = helper(pr_beg + ind - in_beg + 1, pr_end, ind + 1, in_end)\\n            return root\\n        \\n        dic = {elem: it for it, elem in enumerate(inorder)}  \\n        return helper(0, len(preorder), 0, len(inorder))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 494945,
                "title": "javascript-solution",
                "content": "### The idea\\n1. In-order `<LEFT><ROOT><RIGHT>`, pre-order `<ROOT><LEFT><RIGHT>`\\n2. The in-order array is good at telling us values in the left and right subtree.\\n3. The pre-order is good at telling us the root of a subtree which is the first element in the array.\\n5. Note that we want to build the left subtree first because of the order of pre-order, root -> left -> right\\n``` javascript\\n/**\\n * @param {number[]} preorder\\n * @param {number[]} inorder\\n * @return {TreeNode}\\n */\\nvar buildTree = function(preorder, inorder) {\\n    let hash = {};\\n    inorder.forEach((e, i)=>{hash[e] = i});\\n    \\n    let recur = function(start, end) {\\n        if (start > end) return null;\\n        let root = new TreeNode(preorder.shift());\\n        root.left = recur(start, hash[root.val] - 1);\\n        root.right = recur(hash[root.val] + 1, end);\\n        return root;\\n    }\\n    \\n    return recur(0, inorder.length - 1);    \\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "``` javascript\\n/**\\n * @param {number[]} preorder\\n * @param {number[]} inorder\\n * @return {TreeNode}\\n */\\nvar buildTree = function(preorder, inorder) {\\n    let hash = {};\\n    inorder.forEach((e, i)=>{hash[e] = i});\\n    \\n    let recur = function(start, end) {\\n        if (start > end) return null;\\n        let root = new TreeNode(preorder.shift());\\n        root.left = recur(start, hash[root.val] - 1);\\n        root.right = recur(hash[root.val] + 1, end);\\n        return root;\\n    }\\n    \\n    return recur(0, inorder.length - 1);    \\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 34572,
                "title": "less-than-10-lines-neat-c-code",
                "content": "    TreeNode* buildTree(vector<int>& preorder, vector<int>& inorder) {\\n        return builTreeHelper(preorder,0,preorder.size(),inorder,0,inorder.size());\\n    }\\n    \\n    TreeNode* builTreeHelper(vector<int>& preorder, int sp, int ep, vector<int>& inorder, int si, int ei) {\\n        if (sp == ep) return nullptr;\\n        TreeNode* root = new TreeNode(preorder[sp]);\\n        int dis = find(inorder.begin()+si,inorder.begin()+ei,preorder[sp]) - inorder.begin() - si;\\n        root->left = builTreeHelper(preorder,sp+1,sp+1+dis,inorder,si,si+dis);\\n        root->right = builTreeHelper(preorder,sp+1+dis,ep,inorder,si+dis+1,ei);\\n        return root;\\n    }",
                "solutionTags": [
                    "C++"
                ],
                "code": "    TreeNode* buildTree(vector<int>& preorder, vector<int>& inorder) {\\n        return builTreeHelper(preorder,0,preorder.size(),inorder,0,inorder.size());\\n    }\\n    \\n    TreeNode* builTreeHelper(vector<int>& preorder, int sp, int ep, vector<int>& inorder, int si, int ei) {\\n        if (sp == ep) return nullptr;\\n        TreeNode* root = new TreeNode(preorder[sp]);\\n        int dis = find(inorder.begin()+si,inorder.begin()+ei,preorder[sp]) - inorder.begin() - si;\\n        root->left = builTreeHelper(preorder,sp+1,sp+1+dis,inorder,si,si+dis);\\n        root->right = builTreeHelper(preorder,sp+1+dis,ep,inorder,si+dis+1,ei);\\n        return root;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 2153971,
                "title": "c-2-solution-map-without-map",
                "content": "```\\n//with map\\n    TreeNode* solve(vector<int>& preorder, vector<int>& inorder,int ps,int pe,int is,int ie,unordered_map<int,int>& map){\\n\\t// 4) base conditon  \\n        if(ps>pe||is>ie)return NULL;\\n\\t// 5) create root node\\n        TreeNode* root = new TreeNode(preorder[ps]);\\n\\t// 6) find postion of root in inorder vec. using map \\n        int inroot = map[root->val];\\n\\t// 7) find the left side len. eg:  [9,3,15,20,7];  root=3, left len = rootidx(1) - is(0)\\n        int left = inroot-is;\\n\\t// 8) call on left side and attach to root->left \\n        root->left = solve(preorder,inorder,ps+1,ps+left,is,inroot-1,map);\\n\\t// 9) call on right side and attach to root->right\\t\\n        root->right = solve(preorder,inorder,ps+left+1,pe,inroot+1,ie,map);\\n\\t// 10) return root\\n        return root;\\n    }\\n    TreeNode* buildTree(vector<int>& preorder, vector<int>& inorder) {\\n\\t// 1) maintain a map\\n        unordered_map<int,int> map;\\n        int m = preorder.size();\\n        int n = inorder.size();\\n   // 2) mapping in inorder to corresponding index\\n        for(int i=0;i<n;i++)map[inorder[i]] = i;\\n\\t// 3) call solve function \\t\\n         return solve(preorder,inorder,0,m-1,0,n-1,map);\\n    }\\n   \\n//without map\\n//every thing is same as above solution except, didn\\'t create a map instead\\n//find the rootindex using for loop in solve function\\n TreeNode* solve(vector<int> preorder,vector<int> inorder,int is,int ie,int ps,int pe){\\n        if(is>ie)return NULL;\\n\\tif(ps>pe)return NULL;\\n\\tint rootdata = preorder[ps];\\n\\t// for rootindex in inorder vec. //instead of map\\n    int rootindex = -1;\\n\\tfor (int i = is; i <= ie; i++) {\\n\\t\\tif (inorder[i] == rootdata) {\\n\\t\\t\\trootindex = i;\\n\\t\\t\\tbreak;\\n\\t\\t}\\n\\t}\\n\\tint lis = is;\\n\\tint lie = rootindex-1;\\n\\tint lps = ps+1;\\n\\tint lpe = lie-lis+lps;\\n\\tint ris = rootindex+1;\\n\\tint rie = ie;\\n\\tint rps = lpe+1;\\n\\tint rpe = pe;\\n\\tTreeNode* root = new TreeNode(rootdata);\\n\\troot->left = solve(preorder,inorder,lis,lie,lps,lpe);\\n\\troot->right = solve(preorder,inorder,ris,rie,rps,rpe);\\n\\treturn root;\\n    }\\n    TreeNode* buildTree(vector<int>& preorder, vector<int>& inorder) {\\n        int pl = preorder.size();\\n        int il = inorder.size();\\n        return solve(preorder,inorder,0,il-1,0,pl-1);\\n        \\n    }\\n```\\nPls Upvote\\uD83D\\uDE42 Thanks!!",
                "solutionTags": [
                    "C++",
                    "C",
                    "Recursion",
                    "Binary Tree"
                ],
                "code": "```\\n//with map\\n    TreeNode* solve(vector<int>& preorder, vector<int>& inorder,int ps,int pe,int is,int ie,unordered_map<int,int>& map){\\n\\t// 4) base conditon  \\n        if(ps>pe||is>ie)return NULL;\\n\\t// 5) create root node\\n        TreeNode* root = new TreeNode(preorder[ps]);\\n\\t// 6) find postion of root in inorder vec. using map \\n        int inroot = map[root->val];\\n\\t// 7) find the left side len. eg:  [9,3,15,20,7];  root=3, left len = rootidx(1) - is(0)\\n        int left = inroot-is;\\n\\t// 8) call on left side and attach to root->left \\n        root->left = solve(preorder,inorder,ps+1,ps+left,is,inroot-1,map);\\n\\t// 9) call on right side and attach to root->right\\t\\n        root->right = solve(preorder,inorder,ps+left+1,pe,inroot+1,ie,map);\\n\\t// 10) return root\\n        return root;\\n    }\\n    TreeNode* buildTree(vector<int>& preorder, vector<int>& inorder) {\\n\\t// 1) maintain a map\\n        unordered_map<int,int> map;\\n        int m = preorder.size();\\n        int n = inorder.size();\\n   // 2) mapping in inorder to corresponding index\\n        for(int i=0;i<n;i++)map[inorder[i]] = i;\\n\\t// 3) call solve function \\t\\n         return solve(preorder,inorder,0,m-1,0,n-1,map);\\n    }\\n   \\n//without map\\n//every thing is same as above solution except, didn\\'t create a map instead\\n//find the rootindex using for loop in solve function\\n TreeNode* solve(vector<int> preorder,vector<int> inorder,int is,int ie,int ps,int pe){\\n        if(is>ie)return NULL;\\n\\tif(ps>pe)return NULL;\\n\\tint rootdata = preorder[ps];\\n\\t// for rootindex in inorder vec. //instead of map\\n    int rootindex = -1;\\n\\tfor (int i = is; i <= ie; i++) {\\n\\t\\tif (inorder[i] == rootdata) {\\n\\t\\t\\trootindex = i;\\n\\t\\t\\tbreak;\\n\\t\\t}\\n\\t}\\n\\tint lis = is;\\n\\tint lie = rootindex-1;\\n\\tint lps = ps+1;\\n\\tint lpe = lie-lis+lps;\\n\\tint ris = rootindex+1;\\n\\tint rie = ie;\\n\\tint rps = lpe+1;\\n\\tint rpe = pe;\\n\\tTreeNode* root = new TreeNode(rootdata);\\n\\troot->left = solve(preorder,inorder,lis,lie,lps,lpe);\\n\\troot->right = solve(preorder,inorder,ris,rie,rps,rpe);\\n\\treturn root;\\n    }\\n    TreeNode* buildTree(vector<int>& preorder, vector<int>& inorder) {\\n        int pl = preorder.size();\\n        int il = inorder.size();\\n        return solve(preorder,inorder,0,il-1,0,pl-1);\\n        \\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 34680,
                "title": "python-recursion-version-and-iteration-version-easy-to-understand",
                "content": "**Recursion version:**\\n\\n    class Solution(object):\\n        preorder = []\\n        inorder = []\\n        def buildTree(self, preorder, inorder):\\n            self.preorder = preorder\\n            self.inorder = inorder\\n            return self.dfs(0, len(self.preorder), 0, len(self.inorder))\\n            \\n        def dfs(self, pre_start, pre_end, in_start, in_end): # [start, end)\\n            if pre_end - pre_start <= 0:\\n                return None\\n            root = TreeNode(self.preorder[pre_start])\\n            offset = self.inorder[in_start : in_end+1].index(self.preorder[pre_start])\\n            root.left = self.dfs(pre_start+1, pre_start+1+offset, in_start, in_start+offset)\\n            root.right = self.dfs(pre_start+1+offset, pre_end, in_start+1+offset, in_end)\\n            return root\\n\\nI wrote the recursion version below at first, which is easier to understand, but it got a MLE error:\\n\\n    class Solution(object):\\n        def buildTree(self, preorder, inorder):\\n            return self.dfs(preorder, inorder)\\n            \\n        def dfs(self, preorder, inorder):\\n            if len(preorder) == 0:\\n                return None\\n            root = TreeNode(preorder[0])\\n            root_idx = inorder.index(preorder[0])\\n            root.left = self.dfs(preorder[1 : root_idx+1], inorder[ : root_idx])\\n            root.right = self.dfs(preorder[root_idx+1 : ], inorder[root_idx+1 : ])\\n            return root\\n\\nI think the reason of the MLE error is, it generates too much list when calling `self.dfs(preorder[...], inorder[...])`. (If I am wrong, correct me plz! :P)\\n\\n**Iteration version:**\\n\\nActually, it's a trick that just use a stack to simulate recursion.\\n\\n    class Solution(object):\\n        def buildTree(self, preorder, inorder):\\n            if len(preorder) == 0:\\n                return None\\n            \\n            root = TreeNode(preorder[0])\\n            stack = [(root, preorder, inorder)]\\n            while stack:\\n                args = stack.pop()\\n                node, preorder, inorder = args[0], args[1], args[2]\\n                if len(preorder) == 0:\\n                    continue\\n                root_idx = inorder.index(preorder[0])\\n                if root_idx > 0: # There's a left subtree\\n                    node.left = TreeNode(preorder[1])\\n                    stack.append((node.left, preorder[1 : root_idx+1], inorder[ : root_idx]))\\n                if root_idx < len(inorder) - 1: # There's a right subtree\\n                    node.right = TreeNode(preorder[root_idx+1])\\n                    stack.append((node.right, preorder[root_idx+1 : ], inorder[root_idx+1 : ]))\\n                    \\n            return root\\n\\n\\nHere comes a truely iterative version, which beats **100%**. I alter it from this: [Simple C++ Iteration Solution][1].\\n\\n    # From @JieGhost\\n    class Solution(object):\\n        def buildTree(self, preorder, inorder):\\n            if len(preorder) == 0:\\n                return None\\n                \\n            head = TreeNode(preorder[0])\\n            stack = [head]\\n            i = 1\\n            j = 0\\n            \\n            while i < len(preorder):\\n                temp = None\\n                t = TreeNode(preorder[i])\\n                while stack and stack[-1].val == inorder[j]:\\n                    temp = stack.pop()\\n                    j += 1\\n                if temp:\\n                    temp.right = t\\n                else:\\n                    stack[-1].left = t\\n                stack.append(t)\\n                i += 1\\n            \\n            return head\\n\\n  [1]: https://leetcode.com/discuss/83459/simple-c-iteration-solution",
                "solutionTags": [
                    "Python"
                ],
                "code": "**Recursion version:**\\n\\n    class Solution(object):\\n        preorder = []\\n        inorder = []\\n        def buildTree(self, preorder, inorder):\\n            self.preorder = preorder\\n            self.inorder = inorder\\n            return self.dfs(0, len(self.preorder), 0, len(self.inorder))\\n            \\n        def dfs(self, pre_start, pre_end, in_start, in_end): # [start, end)\\n            if pre_end - pre_start <= 0:\\n                return None\\n            root = TreeNode(self.preorder[pre_start])\\n            offset = self.inorder[in_start : in_end+1].index(self.preorder[pre_start])\\n            root.left = self.dfs(pre_start+1, pre_start+1+offset, in_start, in_start+offset)\\n            root.right = self.dfs(pre_start+1+offset, pre_end, in_start+1+offset, in_end)\\n            return root\\n\\nI wrote the recursion version below at first, which is easier to understand, but it got a MLE error:\\n\\n    class Solution(object):\\n        def buildTree(self, preorder, inorder):\\n            return self.dfs(preorder, inorder)\\n            \\n        def dfs(self, preorder, inorder):\\n            if len(preorder) == 0:\\n                return None\\n            root = TreeNode(preorder[0])\\n            root_idx = inorder.index(preorder[0])\\n            root.left = self.dfs(preorder[1 : root_idx+1], inorder[ : root_idx])\\n            root.right = self.dfs(preorder[root_idx+1 : ], inorder[root_idx+1 : ])\\n            return root\\n\\nI think the reason of the MLE error is, it generates too much list when calling `self.dfs(preorder[...], inorder[...])`. (If I am wrong, correct me plz! :P)\\n\\n**Iteration version:**\\n\\nActually, it's a trick that just use a stack to simulate recursion.\\n\\n    class Solution(object):\\n        def buildTree(self, preorder, inorder):\\n            if len(preorder) == 0:\\n                return None\\n            \\n            root = TreeNode(preorder[0])\\n            stack = [(root, preorder, inorder)]\\n            while stack:\\n                args = stack.pop()\\n                node, preorder, inorder = args[0], args[1], args[2]\\n                if len(preorder) == 0:\\n                    continue\\n                root_idx = inorder.index(preorder[0])\\n                if root_idx > 0: # There's a left subtree\\n                    node.left = TreeNode(preorder[1])\\n                    stack.append((node.left, preorder[1 : root_idx+1], inorder[ : root_idx]))\\n                if root_idx < len(inorder) - 1: # There's a right subtree\\n                    node.right = TreeNode(preorder[root_idx+1])\\n                    stack.append((node.right, preorder[root_idx+1 : ], inorder[root_idx+1 : ]))\\n                    \\n            return root\\n\\n\\nHere comes a truely iterative version, which beats **100%**. I alter it from this: [Simple C++ Iteration Solution][1].\\n\\n    # From @JieGhost\\n    class Solution(object):\\n        def buildTree(self, preorder, inorder):\\n            if len(preorder) == 0:\\n                return None\\n                \\n            head = TreeNode(preorder[0])\\n            stack = [head]\\n            i = 1\\n            j = 0\\n            \\n            while i < len(preorder):\\n                temp = None\\n                t = TreeNode(preorder[i])\\n                while stack and stack[-1].val == inorder[j]:\\n                    temp = stack.pop()\\n                    j += 1\\n                if temp:\\n                    temp.right = t\\n                else:\\n                    stack[-1].left = t\\n                stack.append(t)\\n                i += 1\\n            \\n            return head\\n\\n  [1]: https://leetcode.com/discuss/83459/simple-c-iteration-solution",
                "codeTag": "Java"
            },
            {
                "id": 34693,
                "title": "my-recursive-c-solution",
                "content": "    struct TreeNode* buildTree(int* preorder, int preorderSize, int* inorder, int inorderSize) {\\n        if (preorderSize == 0) return NULL;\\n        \\n        struct TreeNode* root = (struct TreeNode *)malloc(sizeof(struct TreeNode));\\n        root->val = *preorder;\\n        \\n        int i = 0;\\n        while (inorder[i] != *preorder) ++i;\\n        root->left = buildTree(preorder + 1, i, inorder, i);\\n        root->right = buildTree(preorder + 1 + i, preorderSize - i - 1,\\n                                inorder + 1 + i, inorderSize - i - 1);\\n        \\n        return root;\\n    }",
                "solutionTags": [],
                "code": "    struct TreeNode* buildTree(int* preorder, int preorderSize, int* inorder, int inorderSize) {\\n        if (preorderSize == 0) return NULL;\\n        \\n        struct TreeNode* root = (struct TreeNode *)malloc(sizeof(struct TreeNode));\\n        root->val = *preorder;\\n        \\n        int i = 0;\\n        while (inorder[i] != *preorder) ++i;\\n        root->left = buildTree(preorder + 1, i, inorder, i);\\n        root->right = buildTree(preorder + 1 + i, preorderSize - i - 1,\\n                                inorder + 1 + i, inorderSize - i - 1);\\n        \\n        return root;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1928021,
                "title": "100-fastest-swift-solution",
                "content": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     public var val: Int\\n *     public var left: TreeNode?\\n *     public var right: TreeNode?\\n *     public init() { self.val = 0; self.left = nil; self.right = nil; }\\n *     public init(_ val: Int) { self.val = val; self.left = nil; self.right = nil; }\\n *     public init(_ val: Int, _ left: TreeNode?, _ right: TreeNode?) {\\n *         self.val = val\\n *         self.left = left\\n *         self.right = right\\n *     }\\n * }\\n */\\nclass Solution {\\n    func buildTree(_ preorder: [Int], _ inorder: [Int]) -> TreeNode? {\\n        guard preorder.count > 0 else { return nil }\\n        \\n        let total\\u0421ount = preorder.count\\n        let root = TreeNode(preorder[0])\\n        var rootIndex = -1\\n        \\n        for (i, val) in inorder.enumerated() {\\n            if val == root.val {\\n                rootIndex = i\\n                break\\n            } \\n        }\\n        \\n        let leftCount = rootIndex\\n        let rightCount = total\\u0421ount - leftCount - 1\\n        \\n        root.left = buildTree(Array(preorder[1..<1 + leftCount]), Array(inorder[0..<leftCount + 1]))\\n        root.right = buildTree(Array(preorder[1 + leftCount..<total\\u0421ount]), Array(inorder[1 + leftCount..<total\\u0421ount]))\\n        return root\\n    }\\n    \\n}\\n```\\n\\nLet me know in comments if you have any doubts. I will be happy to answer.\\n\\nPlease upvote if you found the solution useful.",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     public var val: Int\\n *     public var left: TreeNode?\\n *     public var right: TreeNode?\\n *     public init() { self.val = 0; self.left = nil; self.right = nil; }\\n *     public init(_ val: Int) { self.val = val; self.left = nil; self.right = nil; }\\n *     public init(_ val: Int, _ left: TreeNode?, _ right: TreeNode?) {\\n *         self.val = val\\n *         self.left = left\\n *         self.right = right\\n *     }\\n * }\\n */\\nclass Solution {\\n    func buildTree(_ preorder: [Int], _ inorder: [Int]) -> TreeNode? {\\n        guard preorder.count > 0 else { return nil }\\n        \\n        let total\\u0421ount = preorder.count\\n        let root = TreeNode(preorder[0])\\n        var rootIndex = -1\\n        \\n        for (i, val) in inorder.enumerated() {\\n            if val == root.val {\\n                rootIndex = i\\n                break\\n            } \\n        }\\n        \\n        let leftCount = rootIndex\\n        let rightCount = total\\u0421ount - leftCount - 1\\n        \\n        root.left = buildTree(Array(preorder[1..<1 + leftCount]), Array(inorder[0..<leftCount + 1]))\\n        root.right = buildTree(Array(preorder[1 + leftCount..<total\\u0421ount]), Array(inorder[1 + leftCount..<total\\u0421ount]))\\n        return root\\n    }\\n    \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 376531,
                "title": "simple-and-intuitive-python3-implementation-with-explanation",
                "content": "Objective is to construct a binary tree which satisfy both the inorder and preorder traversal sequence.\\nTo do that, in every iteration:\\n1. choose root node from preorder seq. Pop the first element in the preorder seq.\\n2. Everything to the left of that node in Inorder goes to the left node\\n3. Everything to the right of the root node in Inorder goes to the right node.\\nRepeat 1,2,3 until the end of preorder seq.\\n\\n![image](https://assets.leetcode.com/users/geekcoder1989/image_1567829520.png)\\n\\n```\\nclass Solution:\\n    def buildTree(self, preorder: List[int], inorder: List[int]) -> TreeNode:\\n        if not preorder:\\n            return None\\n        if not inorder:\\n            return None\\n        ele = preorder.pop(0)\\n        root = TreeNode(ele)\\n        idx = inorder.index(ele)\\n        root.left = self.buildTree(preorder, inorder[:idx])\\n        root.right = self.buildTree(preorder, inorder[idx+1:])\\n        return root\\n```",
                "solutionTags": [
                    "Python3",
                    "Recursion"
                ],
                "code": "```\\nclass Solution:\\n    def buildTree(self, preorder: List[int], inorder: List[int]) -> TreeNode:\\n        if not preorder:\\n            return None\\n        if not inorder:\\n            return None\\n        ele = preorder.pop(0)\\n        root = TreeNode(ele)\\n        idx = inorder.index(ele)\\n        root.left = self.buildTree(preorder, inorder[:idx])\\n        root.right = self.buildTree(preorder, inorder[idx+1:])\\n        return root\\n```",
                "codeTag": "Java"
            },
            {
                "id": 308472,
                "title": "java-recursive-iterative-explained",
                "content": ">**T/S:** O(n)/O(n) (for both the methods)\\n\\n**Method 1:** Recursive\\n ```\\n/** Note:\\n* 1. pre[0] is the root\\n* 2. In inorder array, all elements to the left of pre[i] forms its left sub-tree\\n*    and all elements to the right of pre[i] forms its right sub-tree \\n*  \\n*  build a hash of value to index by iterating through in-order array*/\\npublic TreeNode buildTree(int[] preorder, int[] inorder) {\\n\\tvar valueToIdx = new HashMap<Integer, Integer>();\\n\\tfor (var i = 0; i < inorder.length; i++)\\n\\t\\tvalueToIdx.put(inorder[i], i);\\n\\t\\t\\n\\treturn buildTree(preorder, new int[]{0}, 0, inorder.length - 1, valueToIdx);\\n}\\n\\n/**\\n * 1. Maintain a pointer that progresses through pre-order one element at time, say prePointer\\n * 2. Construct the node corresponding to prePointer\\n * 3. inStart and inEnd pointers point to the start and end of the left/right subtree in the inorder array\\n * 4. start == end implies that it\\'s a leaf node, so there\\'s no need to explore its left or right subtree as\\n * there are none. The reason it\\'s a leaf node is that start == end implies that there\\'s exactly one element to the\\n * right or to the left of its parent, which is this very node.\\n * 5. Get the index of the current element using the hash. Remember this is the index of the element in the\\n * inorder array. Use this index to get the ranges of the left and right subtrees.\\n * 6. Recurse for left and right subtrees.\\n */\\nprivate TreeNode buildTree(int[] pre, int[] prePointer, int inStart, int inEnd, Map<Integer, Integer> valueToIdx) {\\n\\tif (inStart > inEnd)\\n\\t\\treturn null;\\n\\n\\tvar nodeVal = preorder[prePointer[0]++];\\n\\tvar node = new TreeNode(nodeVal);\\n\\n\\tif (inStart == inEnd) // leaf node\\n\\t\\treturn node;\\n\\n\\tvar inIdxCurrNode = valueToIdx.get(nodeVal);\\n\\tnode.left = buildTree(preorder, prePointer, inStart, inIdxCurrNode - 1, valueToIdx);\\n\\tnode.right = buildTree(preorder, prePointer, inIdxCurrNode + 1, inEnd, valueToIdx);\\n\\treturn node;\\n}\\n```\\n\\n**Method 2:** Iterative by simply replacing functional call stack with your own stack\\n```\\n/**\\n * Idea is to keep tree nodes in a stack from preorder traversal till their counterpart (same element) is not\\n * found in inorder traversal. When found, all children in the left sub-tree of the node must have been already\\n * visited.\\n */\\npublic TreeNode buildTreeIterative(int[] preorder, int[] inorder) {\\n\\tif (preorder.length == 0)\\n\\t\\treturn null;\\n\\n\\tvar root = new TreeNode(preorder[0]);\\n\\tvar preOrderIndex = 1;\\n\\tvar inOrderIndex = 0;\\n\\n\\tfor (var stack = new ArrayDeque<>(List.of(root)); !stack.isEmpty(); ) {\\n\\t\\tvar top = stack.peek();\\n\\t\\tvar node = root;\\n\\n\\t\\tif (top.val != inorder[inOrderIndex]) {\\n\\t\\t\\t// Top node in the stack has not yet encountered its counterpart in inOrder,\\n\\t\\t\\t// so next element in pre must be left child of this node\\n\\t\\t\\tnode = new TreeNode(preorder[preOrderIndex++]);\\n\\t\\t\\ttop.left = node;\\n\\t\\t} else {\\n\\t\\t\\t// if all the elements in inOrder have been visted, we are done\\n\\t\\t\\tif (++inOrderIndex == inorder.length)\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\tstack.pop();\\n\\t\\t\\t// Check if there are still some unvisited nodes in the left sub-tree of the top node in the stack\\n\\t\\t\\tif (!stack.isEmpty() && (stack.peek().val == inorder[inOrderIndex]))\\n\\t\\t\\t\\tcontinue;\\n\\t\\t\\t// As top node in stack still has not encontered its counterpart\\n\\t\\t\\t// in inOrder, so next element in pre must be right child of the removed node\\n\\t\\t\\tnode = new TreeNode(preorder[preOrderIndex++]);\\n\\t\\t\\ttop.right = node;\\n\\t\\t}\\n\\t\\tstack.push(node);\\n\\t}\\n\\treturn root;\\n}\\n```\\n\\nP.S: *In Method 1, the first function can also be written as a 1 liner using stream like this*\\n```\\npublic TreeNode buildTree(int[] pre, int[] in) {\\n\\treturn buildTree(pre, new int[]{0}, 0, in.length - 1, IntStream.range(0, in.length)\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t   .boxed()\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t   .collect(Collectors.toMap(i -> in[i], i -> i, (a, b) -> b, HashMap::new)));\\n}\\n```\\n***Please upvote if this helps***",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n/** Note:\\n* 1. pre[0] is the root\\n* 2. In inorder array, all elements to the left of pre[i] forms its left sub-tree\\n*    and all elements to the right of pre[i] forms its right sub-tree \\n*  \\n*  build a hash of value to index by iterating through in-order array*/\\npublic TreeNode buildTree(int[] preorder, int[] inorder) {\\n\\tvar valueToIdx = new HashMap<Integer, Integer>();\\n\\tfor (var i = 0; i < inorder.length; i++)\\n\\t\\tvalueToIdx.put(inorder[i], i);\\n\\t\\t\\n\\treturn buildTree(preorder, new int[]{0}, 0, inorder.length - 1, valueToIdx);\\n}\\n\\n/**\\n * 1. Maintain a pointer that progresses through pre-order one element at time, say prePointer\\n * 2. Construct the node corresponding to prePointer\\n * 3. inStart and inEnd pointers point to the start and end of the left/right subtree in the inorder array\\n * 4. start == end implies that it\\'s a leaf node, so there\\'s no need to explore its left or right subtree as\\n * there are none. The reason it\\'s a leaf node is that start == end implies that there\\'s exactly one element to the\\n * right or to the left of its parent, which is this very node.\\n * 5. Get the index of the current element using the hash. Remember this is the index of the element in the\\n * inorder array. Use this index to get the ranges of the left and right subtrees.\\n * 6. Recurse for left and right subtrees.\\n */\\nprivate TreeNode buildTree(int[] pre, int[] prePointer, int inStart, int inEnd, Map<Integer, Integer> valueToIdx) {\\n\\tif (inStart > inEnd)\\n\\t\\treturn null;\\n\\n\\tvar nodeVal = preorder[prePointer[0]++];\\n\\tvar node = new TreeNode(nodeVal);\\n\\n\\tif (inStart == inEnd) // leaf node\\n\\t\\treturn node;\\n\\n\\tvar inIdxCurrNode = valueToIdx.get(nodeVal);\\n\\tnode.left = buildTree(preorder, prePointer, inStart, inIdxCurrNode - 1, valueToIdx);\\n\\tnode.right = buildTree(preorder, prePointer, inIdxCurrNode + 1, inEnd, valueToIdx);\\n\\treturn node;\\n}\\n```\n```\\n/**\\n * Idea is to keep tree nodes in a stack from preorder traversal till their counterpart (same element) is not\\n * found in inorder traversal. When found, all children in the left sub-tree of the node must have been already\\n * visited.\\n */\\npublic TreeNode buildTreeIterative(int[] preorder, int[] inorder) {\\n\\tif (preorder.length == 0)\\n\\t\\treturn null;\\n\\n\\tvar root = new TreeNode(preorder[0]);\\n\\tvar preOrderIndex = 1;\\n\\tvar inOrderIndex = 0;\\n\\n\\tfor (var stack = new ArrayDeque<>(List.of(root)); !stack.isEmpty(); ) {\\n\\t\\tvar top = stack.peek();\\n\\t\\tvar node = root;\\n\\n\\t\\tif (top.val != inorder[inOrderIndex]) {\\n\\t\\t\\t// Top node in the stack has not yet encountered its counterpart in inOrder,\\n\\t\\t\\t// so next element in pre must be left child of this node\\n\\t\\t\\tnode = new TreeNode(preorder[preOrderIndex++]);\\n\\t\\t\\ttop.left = node;\\n\\t\\t} else {\\n\\t\\t\\t// if all the elements in inOrder have been visted, we are done\\n\\t\\t\\tif (++inOrderIndex == inorder.length)\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\tstack.pop();\\n\\t\\t\\t// Check if there are still some unvisited nodes in the left sub-tree of the top node in the stack\\n\\t\\t\\tif (!stack.isEmpty() && (stack.peek().val == inorder[inOrderIndex]))\\n\\t\\t\\t\\tcontinue;\\n\\t\\t\\t// As top node in stack still has not encontered its counterpart\\n\\t\\t\\t// in inOrder, so next element in pre must be right child of the removed node\\n\\t\\t\\tnode = new TreeNode(preorder[preOrderIndex++]);\\n\\t\\t\\ttop.right = node;\\n\\t\\t}\\n\\t\\tstack.push(node);\\n\\t}\\n\\treturn root;\\n}\\n```\n```\\npublic TreeNode buildTree(int[] pre, int[] in) {\\n\\treturn buildTree(pre, new int[]{0}, 0, in.length - 1, IntStream.range(0, in.length)\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t   .boxed()\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t   .collect(Collectors.toMap(i -> in[i], i -> i, (a, b) -> b, HashMap::new)));\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3390479,
                "title": "fastest-and-the-most-detailed-approach",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->O(N)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->O(N)\\n![Screenshot_20230205_171246.png](https://assets.leetcode.com/users/images/229aa66f-7f24-4ab0-bcaa-d6c3e7f2b034_1680874969.1941795.png)\\n\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    public TreeNode buildTree(int[] preorder, int[] inorder) {\\n        // Create a hashmap to store the indices of values in the inorder array\\n        Map<Integer,Integer> inMap = new HashMap<>();\\n\\n        // Populate the hashmap with the indices of the values in the inorder array\\n        for(int i = 0; i < inorder.length; i++){\\n            inMap.put(inorder[i],i);\\n        }\\n\\n        // Recursively build the tree using the preorder and inorder arrays\\n        TreeNode root = buildTree(preorder, 0, preorder.length - 1, inorder, 0, inorder.length - 1, inMap);\\n\\n        // Return the root of the constructed tree\\n        return root;\\n    }\\n\\n\\n\\n    public TreeNode buildTree(int preorder[],int preStart,int preEnd,int inorder[],int inStart,int inEnd,Map<Integer,Integer> inMap){\\n        \\n        // Base case: if the start index is greater than the end index for either array, return null\\n        if(preStart > preEnd || inStart > inEnd){\\n            return null;\\n        }\\n\\n        // Create a new node with the value at the start index of the preorder array\\n        TreeNode root = new TreeNode(preorder[preStart]);\\n\\n        // Find the index of the root value in the inorder array\\n        int inRoot = inMap.get(root.val);\\n\\n        // Calculate the number of nodes in the left subtree\\n        int numsLeft = inRoot - inStart;\\n\\n        // Recursively build the left subtree using the following parameters:\\n        // - preorder array: the start index is preStart + 1 because the first node in the preorder array is the root\\n        //   and has already been used to create the current node\\n        // - preorder array: the end index is preStart + numsLeft because the number of nodes in the left subtree is\\n        //   numsLeft, so the end index of the left subtree in the preorder array is preStart + numsLeft\\n        // - inorder array: the start index is inStart because the left subtree in the inorder array is to the left of\\n        //   the current root node\\n        // - inorder array: the end index is inRoot - 1 because the root node is in the middle of the inorder array,\\n        //   so the left subtree in the inorder array goes from inStart to inRoot - 1\\n        root.left = buildTree(preorder, preStart + 1, preStart + numsLeft,\\n                             inorder, inStart, inRoot - 1, inMap);\\n\\n        // Recursively build the right subtree using the following parameters:\\n        // - preorder array: the start index is preStart + numsLeft + 1 because the nodes in the left subtree have\\n        //   already been used, so the start index of the right subtree is preStart + numsLeft + 1\\n        // - preorder array: the end index is preEnd because the last node in the preorder array is the root node\\n        // - inorder array: the start index is inRoot + 1 because the right subtree in the inorder array is to the right\\n        //   of the current root node\\n        // - inorder array: the end index is inEnd because the last node in the inorder array is the rightmost node\\n        root.right = buildTree(preorder, preStart + numsLeft + 1, preEnd,\\n                             inorder, inRoot + 1, inEnd, inMap);\\n\\n        // Return the root of the subtree\\n        return root;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Hash Table",
                    "Tree",
                    "Binary Tree"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    public TreeNode buildTree(int[] preorder, int[] inorder) {\\n        // Create a hashmap to store the indices of values in the inorder array\\n        Map<Integer,Integer> inMap = new HashMap<>();\\n\\n        // Populate the hashmap with the indices of the values in the inorder array\\n        for(int i = 0; i < inorder.length; i++){\\n            inMap.put(inorder[i],i);\\n        }\\n\\n        // Recursively build the tree using the preorder and inorder arrays\\n        TreeNode root = buildTree(preorder, 0, preorder.length - 1, inorder, 0, inorder.length - 1, inMap);\\n\\n        // Return the root of the constructed tree\\n        return root;\\n    }\\n\\n\\n\\n    public TreeNode buildTree(int preorder[],int preStart,int preEnd,int inorder[],int inStart,int inEnd,Map<Integer,Integer> inMap){\\n        \\n        // Base case: if the start index is greater than the end index for either array, return null\\n        if(preStart > preEnd || inStart > inEnd){\\n            return null;\\n        }\\n\\n        // Create a new node with the value at the start index of the preorder array\\n        TreeNode root = new TreeNode(preorder[preStart]);\\n\\n        // Find the index of the root value in the inorder array\\n        int inRoot = inMap.get(root.val);\\n\\n        // Calculate the number of nodes in the left subtree\\n        int numsLeft = inRoot - inStart;\\n\\n        // Recursively build the left subtree using the following parameters:\\n        // - preorder array: the start index is preStart + 1 because the first node in the preorder array is the root\\n        //   and has already been used to create the current node\\n        // - preorder array: the end index is preStart + numsLeft because the number of nodes in the left subtree is\\n        //   numsLeft, so the end index of the left subtree in the preorder array is preStart + numsLeft\\n        // - inorder array: the start index is inStart because the left subtree in the inorder array is to the left of\\n        //   the current root node\\n        // - inorder array: the end index is inRoot - 1 because the root node is in the middle of the inorder array,\\n        //   so the left subtree in the inorder array goes from inStart to inRoot - 1\\n        root.left = buildTree(preorder, preStart + 1, preStart + numsLeft,\\n                             inorder, inStart, inRoot - 1, inMap);\\n\\n        // Recursively build the right subtree using the following parameters:\\n        // - preorder array: the start index is preStart + numsLeft + 1 because the nodes in the left subtree have\\n        //   already been used, so the start index of the right subtree is preStart + numsLeft + 1\\n        // - preorder array: the end index is preEnd because the last node in the preorder array is the root node\\n        // - inorder array: the start index is inRoot + 1 because the right subtree in the inorder array is to the right\\n        //   of the current root node\\n        // - inorder array: the end index is inEnd because the last node in the inorder array is the rightmost node\\n        root.right = buildTree(preorder, preStart + numsLeft + 1, preEnd,\\n                             inorder, inRoot + 1, inEnd, inMap);\\n\\n        // Return the root of the subtree\\n        return root;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1120355,
                "title": "iterative-java-solution-explained-reusable-template",
                "content": "Note: I used the same template to answer the next question(106), you can find it [here](https://leetcode.com/problems/construct-binary-tree-from-inorder-and-postorder-traversal/discuss/1120416/Iterative-Java-Code-Reused-Template-from-previous-question)\\n\\nI see quite a few recursive solutions with good explanations. Posts with an iterative version though were scanty, and I couldn\\'t find many resources online either. So here\\'s how I did it:\\n\\nI took an example, this one infact, ![image](https://assets.leetcode.com/users/images/af991bd9-d8f4-4119-9e9c-334cee309e41_1616323877.107536.png)\\nwrote the inorder traversal, and then the preorder traversal, and observed the pattern and that\\'s how I got it. Cuz I see a lot of people wondering how does one arrive at such a solution, well it took me hours to figure out the pattern but here\\'s what I figured out finally.\\n\\nSo you start off with a stack, push the root into it and your inorderIndex is set to 0.\\n\\nThen you iterate from preorderIndex 1 to length of preorder traversal(because root is already in the stack, so preorderIndex 0 is taken care of).\\n\\nYou check whether the stack\\'s top and inorder[inorderIndex] are same, and while that\\'s true, you keep popping(and storing the popped TreeNode in some variable say prev, because we\\'ll need it) while incrementing inorderIndex. \\nThe point is that since they were equal, this means that you\\'re out of nodes to insert towards the left, and now you\\'re going to have to insert at the right. But right of what? The last popped node, which is stored in prev.\\n\\nSo after you\\'re done popping from the stack, you check if you actually popped anything out(by checking if prev==null). If you didn\\'t, then you\\'re still able to insert trees at the left. So you insert a new node(preorder[preorderIndex]) to the left of stack\\'s top\\'s node.\\nOtherwise, you insert to right of prev node that was popped.\\n\\nAnd then you\\'re done. Here\\'s the code to clarify further:\\n\\n```\\nclass Solution {    \\n    public TreeNode buildTree(int[] preorder, int[] inorder) {\\n        ArrayDeque<TreeNode> stack = new ArrayDeque<>();\\n        TreeNode root = new TreeNode(preorder[0]);\\n        int inorderIndex = 0;\\n        stack.push(root);\\n        \\n        for(int i = 1; i < preorder.length; i++){\\n            TreeNode prev = null;\\n            while(!stack.isEmpty() && stack.peek().val == inorder[inorderIndex]){\\n                prev = stack.pop();\\n                inorderIndex++;\\n            }\\n            TreeNode toInsert = new TreeNode(preorder[i]);\\n            if(prev == null){\\n                prev = stack.peek();\\n                prev.left = toInsert;\\n            }\\n            else{\\n                prev.right = toInsert;\\n            }\\n            stack.push(toInsert);\\n        }\\n        return root;\\n    }\\n}\\n```\\n\\nThe recursive version just for kicks, pretty similar to what everyone else has done\\n```java\\n/* Recursive\\n\\nclass Solution {\\n    int preorder[];\\n    int curr;\\n    \\n    public TreeNode buildTree(int[] preorder, int[] inorder) {\\n        curr = 0;\\n        this.preorder = preorder;\\n        Map<Integer, Integer> positions = new HashMap<>();\\n        int n = inorder.length;\\n        for(int i = 0; i < n; i++)\\n            positions.put(inorder[i], i);\\n        TreeNode root = buildTree(positions, 0, n-1);\\n        return root;\\n    }\\n    \\n    private TreeNode buildTree(Map<Integer, Integer> positions, int start, int end){\\n        if(start > end) return null;\\n        \\n        TreeNode node = new TreeNode(preorder[curr]);\\n        int pos = positions.get(preorder[curr++]);\\n        node.left = buildTree(positions, start, pos-1);\\n        node.right = buildTree(positions, pos+1, end);\\n        return node;\\n    }\\n    \\n}\\n*/\\n```\\n\\nTaking an example and running through it really helps. I hope this makes sense.",
                "solutionTags": [
                    "Java",
                    "Recursion",
                    "Iterator"
                ],
                "code": "```\\nclass Solution {    \\n    public TreeNode buildTree(int[] preorder, int[] inorder) {\\n        ArrayDeque<TreeNode> stack = new ArrayDeque<>();\\n        TreeNode root = new TreeNode(preorder[0]);\\n        int inorderIndex = 0;\\n        stack.push(root);\\n        \\n        for(int i = 1; i < preorder.length; i++){\\n            TreeNode prev = null;\\n            while(!stack.isEmpty() && stack.peek().val == inorder[inorderIndex]){\\n                prev = stack.pop();\\n                inorderIndex++;\\n            }\\n            TreeNode toInsert = new TreeNode(preorder[i]);\\n            if(prev == null){\\n                prev = stack.peek();\\n                prev.left = toInsert;\\n            }\\n            else{\\n                prev.right = toInsert;\\n            }\\n            stack.push(toInsert);\\n        }\\n        return root;\\n    }\\n}\\n```\n```java\\n/* Recursive\\n\\nclass Solution {\\n    int preorder[];\\n    int curr;\\n    \\n    public TreeNode buildTree(int[] preorder, int[] inorder) {\\n        curr = 0;\\n        this.preorder = preorder;\\n        Map<Integer, Integer> positions = new HashMap<>();\\n        int n = inorder.length;\\n        for(int i = 0; i < n; i++)\\n            positions.put(inorder[i], i);\\n        TreeNode root = buildTree(positions, 0, n-1);\\n        return root;\\n    }\\n    \\n    private TreeNode buildTree(Map<Integer, Integer> positions, int start, int end){\\n        if(start > end) return null;\\n        \\n        TreeNode node = new TreeNode(preorder[curr]);\\n        int pos = positions.get(preorder[curr++]);\\n        node.left = buildTree(positions, start, pos-1);\\n        node.right = buildTree(positions, pos+1, end);\\n        return node;\\n    }\\n    \\n}\\n*/\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1260525,
                "title": "c-simple-recursive-solution-no-map",
                "content": "```\\nclass Solution {\\npublic:\\n    TreeNode* rec(int l, int r) {\\n        if (l > r) return NULL;\\n        \\n        int i = 0;\\n        while (m_inorder[i] != m_preorder[m_curr]) {\\n            i++;\\n        }\\n\\n        m_curr++;\\n        TreeNode* node = new TreeNode(m_inorder[i]);\\n        node->left = rec(l, i-1);\\n        node->right = rec(i+1, r);\\n        return node;\\n        \\n    }\\n    TreeNode* buildTree(vector<int>& preorder, vector<int>& inorder) {\\n        m_preorder = preorder, m_inorder = inorder;\\n        return rec(0, preorder.size()-1);\\n    }\\n    \\nprivate:\\n    int m_curr = 0;\\n    vector<int> m_preorder, m_inorder;\\n};\\n```\\n**Like it? please upvote!**",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    TreeNode* rec(int l, int r) {\\n        if (l > r) return NULL;\\n        \\n        int i = 0;\\n        while (m_inorder[i] != m_preorder[m_curr]) {\\n            i++;\\n        }\\n\\n        m_curr++;\\n        TreeNode* node = new TreeNode(m_inorder[i]);\\n        node->left = rec(l, i-1);\\n        node->right = rec(i+1, r);\\n        return node;\\n        \\n    }\\n    TreeNode* buildTree(vector<int>& preorder, vector<int>& inorder) {\\n        m_preorder = preorder, m_inorder = inorder;\\n        return rec(0, preorder.size()-1);\\n    }\\n    \\nprivate:\\n    int m_curr = 0;\\n    vector<int> m_preorder, m_inorder;\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 748301,
                "title": "python3-solution-with-a-detailed-explanation-preorder-and-inorder-traversal",
                "content": "This question is very similar to [this](https://leetcode.com/problems/construct-binary-tree-from-preorder-and-postorder-traversal/discuss/748216/python3-solution-with-a-detailed-explanation-construct-binary-tree-from) one here. Makes sure to read and undersand it. Read [this](https://leetcode.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal/discuss/34579/Python-short-recursive-solution./32947) also. I\\'ve got this solution from [here](https://leetcode.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal/discuss/34579/Python-short-recursive-solution.). \\n\\n\\nI\\'ll assume you understand the above example. The idea for the solution of this problem is the same except that we\\'re breaking `inorder` into pieces while popping elements of `preorder` for each recurse. \\n\\nAfter the initial prechecking statements (line `#1` and `#2`), we `pop` first element of `preorder`, add that value to `node`. Then we do two recursions, one for `left` and one for `right` subtrees. Note that in this problem, `left` subtree will be used first. This is done due to the relation between  `inorder` and `preorder` (as opposed to `postorder` and `preorder` in the previous example).\\n\\n\\n\\n```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def buildTree(self, preorder: List[int], inorder: List[int]) -> TreeNode:\\n        # print(preorder, inorder)\\n        if len(inorder) == 0: #1\\n            return None\\n        \\n        if len(preorder) == 1: #2\\n            return TreeNode(preorder[0])\\n        \\n        ind = inorder.index(preorder.pop(0)) #3\\n        node = TreeNode(inorder[ind])\\n        \\n        node.left = self.buildTree(preorder, inorder[:ind]) #4\\n        node.right = self.buildTree(preorder, inorder[ind+1:]) #5\\n     \\n        return node\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def buildTree(self, preorder: List[int], inorder: List[int]) -> TreeNode:\\n        # print(preorder, inorder)\\n        if len(inorder) == 0: #1\\n            return None\\n        \\n        if len(preorder) == 1: #2\\n            return TreeNode(preorder[0])\\n        \\n        ind = inorder.index(preorder.pop(0)) #3\\n        node = TreeNode(inorder[ind])\\n        \\n        node.left = self.buildTree(preorder, inorder[:ind]) #4\\n        node.right = self.buildTree(preorder, inorder[ind+1:]) #5\\n     \\n        return node\\n```",
                "codeTag": "Java"
            },
            {
                "id": 34607,
                "title": "deep-understanding-on-the-iterative-solution",
                "content": "Here I provide my understanding on how the iterative solution work.\\n\\n* Let's first observe the sequence of inorder traversal. \\n\\t\\t\\t\\t1) ####$---##$---0+++\\n\\t\\t\\t\\t2) 0: The root node of a tree\\n\\t\\t\\t\\t3) #: the left child or grandchildren of root node 0, without right child\\n\\t\\t\\t\\t4) $: the left child or grandchildren  of root node 0, with a right child or subtree.\\n\\t\\t\\t\\t5) --- : represent right subtree of node $\\n\\t\\t\\t\\t6) +++: represent right subtree of root node.\\n\\n* Let's observe the sequence of preorder traveral\\n\\t\\t\\t\\t1) 0$##$###------+++\\n\\t\\t\\t\\t2) The symbols are the same.\\n\\n* Maintain two pointers: ptrin, ptrpre\\n\\t\\t\\t\\t1) ptrpre: pointer to preorder sequence, always points to the next node that is about to be created.\\n\\t\\t\\t\\t2) ptrin: pointer to inorder sequence. When we keep pushing into stack, ptrin always points to the deepest left child of a subtree. When we keeping popping out nodes, ptrin points to nodes that has no right child, until it points to the root of the right subtree of a node that is just popped out from the stack.\\n\\n* Maintain a stack\\n\\t\\t\\t\\t1) Similar with the stack in inorder traversal, it always stores the chain of left children in a subtree. \\n\\t\\t\\t\\t2) When pushing stack, we are traversing the chain of left children in a subtree, and we keeping creating new node and make it as the left child of the node at stack top.\\n\\t\\t\\t\\t3) When poping stack, we always pop out a node that has no right child, until we find a node that has right child (subtree). \\n\\n* Maintain a temp pointer, that always points to a node popped from stack, the last node that is popped out from the stack has right child (subtree). So the newly created node will be the right child of temp.\\n\\n* Procedures of my algorithm:\\n\\t\\t\\t\\t1) Create the root node of the entire tree, record the root node for the purpose of return. Push the root node into the stack.\\n\\t\\t\\t\\t2) While we has remaining node to create\\n\\t\\t\\t\\t \\n(a)  When we enter a new iteration, ptrin always points to the deepest left grandchild of a tree. So as long as we have not reached it, we can safely keep creating new left child (grandchild) for top node at stack. This actually creating the chain of left children for a tree, namely ###$#$0. The newly-created node will be pushed in the stack. So, next created node will be its left child.\\n\\t\\t\\t\\t\\t\\n(b) Now, after the previous step, we have reached the deepest left child of a tree. Remember inorder traveral, now we need to retreat from the deepest left child until we find the first node that has a right child or subtree. We use a temp pointer to record the node that has right child, than we create the right child for it. This is achievable, because ptrpre always points to the next node that will be created. In other word, now, the node pointed by ptrpre is the right child. This invariant is ensured by the characteristics of preorder traversal. Remember the symbol presentation: 0$##$###------+++. After we create the left children chain: 0$##$###, now the ptrpre points to the first -, which is the right child of the first node with right child (the second $). \\n(c) Repeat step (a) and step (c) until we create all nodes.\\n\\n```\\nTreeNode* buildTree(vector<int>& preorder, vector<int>& inorder) {\\n        if(preorder.empty()) return NULL;\\n        int ppre = 0, pin = 0;\\n        TreeNode* root = new TreeNode(preorder[ppre++]);\\n        stack<TreeNode*> stk;\\n        stk.push(root);\\n        while(true) {\\n            while(stk.top()->val != inorder[pin]) {\\n                TreeNode* newnode = new TreeNode(preorder[ppre++]);\\n                stk.top()->left = newnode;\\n                stk.push(newnode);\\n            }\\n            TreeNode* node;\\n            while(!stk.empty() && stk.top()->val == inorder[pin]) {\\n                node = stk.top();\\n                stk.pop();\\n                pin++;\\n            }\\n            if(ppre == preorder.size()) break;\\n            TreeNode* newnode = new TreeNode(preorder[ppre++]);\\n            node->right = newnode;\\n            stk.push(newnode);\\n        }\\n        return root;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\nTreeNode* buildTree(vector<int>& preorder, vector<int>& inorder) {\\n        if(preorder.empty()) return NULL;\\n        int ppre = 0, pin = 0;\\n        TreeNode* root = new TreeNode(preorder[ppre++]);\\n        stack<TreeNode*> stk;\\n        stk.push(root);\\n        while(true) {\\n            while(stk.top()->val != inorder[pin]) {\\n                TreeNode* newnode = new TreeNode(preorder[ppre++]);\\n                stk.top()->left = newnode;\\n                stk.push(newnode);\\n            }\\n            TreeNode* node;\\n            while(!stk.empty() && stk.top()->val == inorder[pin]) {\\n                node = stk.top();\\n                stk.pop();\\n                pin++;\\n            }\\n            if(ppre == preorder.size()) break;\\n            TreeNode* newnode = new TreeNode(preorder[ppre++]);\\n            node->right = newnode;\\n            stk.push(newnode);\\n        }\\n        return root;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 34675,
                "title": "clear-and-easy-c-solution",
                "content": "    TreeNode* buildTree(vector<int>& preorder, vector<int>& inorder) {\\n        return help(preorder, 0, inorder, 0, inorder.size()-1);\\n    }\\n    TreeNode* help(vector<int>& preorder, int pstart, vector<int>& inorder, int istart, int iend){\\n        if(istart>iend)\\n            return NULL;\\n        TreeNode* root = new TreeNode(preorder[pstart]);\\n        int k;\\n        for(int i=istart; i<=iend; i++){\\n            if(inorder[i] == root->val){\\n                k = i;\\n                break;\\n            }\\n        }\\n        root->left = help(preorder, pstart+1, inorder, istart, k-1);\\n        root->right = help(preorder, pstart+k-istart+1, inorder, k+1, iend);\\n        return root;\\n    }",
                "solutionTags": [],
                "code": "    TreeNode* buildTree(vector<int>& preorder, vector<int>& inorder) {\\n        return help(preorder, 0, inorder, 0, inorder.size()-1);\\n    }\\n    TreeNode* help(vector<int>& preorder, int pstart, vector<int>& inorder, int istart, int iend){\\n        if(istart>iend)\\n            return NULL;\\n        TreeNode* root = new TreeNode(preorder[pstart]);\\n        int k;\\n        for(int i=istart; i<=iend; i++){\\n            if(inorder[i] == root->val){\\n                k = i;\\n                break;\\n            }\\n        }\\n        root->left = help(preorder, pstart+1, inorder, istart, k-1);\\n        root->right = help(preorder, pstart+k-istart+1, inorder, k+1, iend);\\n        return root;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 3986683,
                "title": "easy-solution-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nInorder traversal is a special traversal that helps us to identify a node and its left and right subtree. Preorder traversal always gives us the root node as the first element. Using these properties we can construct the unique binary tree.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n![intuit-1.jpg](https://assets.leetcode.com/users/images/056d4ad6-dc2e-472c-b984-f687f126821d_1693542103.6273644.jpeg)\\n\\nHere 10 (first element of preorder) is the root element. So we can find its index in the inorder traversal(say elem). The left subtree of the root will be present to the left side of in order whereas the right subtree of root will be present on the right side of elem in the inorder traversal: \\n\\nWe can define a recursive function that creates one node at a time. First, we create the root node, and then we can take the help of recursion to create its left and right subtrees. In order to make recursion work, we need to provide the correct inorder and preorder traversal of the subtree for every recursive call.\\n\\n![intuit-2.jpg](https://assets.leetcode.com/users/images/d140e149-b12c-4b36-86f8-4628123814c5_1693542128.0225341.jpeg)\\n\\n\\nTo make more efficient function calls we can use variables (inStart, inEnd) and (preStart and preEnd) in order to point to the start and end of the inorder and preorder traversal respectively, and avoid copying of arrays. \\n\\nNext, we need to figure out how we are going to search the root index in the inorder traversal. For this, we have two options: Linear Search and Hashmaps. We will choose the second one because it will return us the index in constant time. Before making the first recursive call, we will simply add all the (value, index) pairs to a map and pass it to our recursive function.\\n\\nIf n is the size of the Inorder traversal/Preorder traversal. Then our first function call will be : \\n![intuit-3.jpg](https://assets.leetcode.com/users/images/ec87521b-6484-4111-a29f-5f9223fe291a_1693542156.7021892.jpeg)\\n\\nNow the main task left is to pass the correct preStart, preEnd, inStart, inEnd to the respective recursive calls for the left and right subtree. We can calculate the number of elements in the left subtree from the root index, say nElems (elem \\u2013 InStart, where elem is the index of root in inorder traversal). As inorder is [left, root, right] and preorder is [root, left, right] the number of elements (nElems) will easily tell us the preorder and inorder traversal of the subtrees according to the following table:\\n\\n![intuit-4.jpg](https://assets.leetcode.com/users/images/f897a49c-62d8-4975-bee3-7005ec65e768_1693542189.030922.jpeg)\\n\\n\\n1. Create a map to store the inorder indexes.\\n2. Call the function constructTree with all 7 parameters as shown above.\\n3. In the recursive function, first check the base case, if (preStart,>preEnd || inStart> inEnd) then return NULL.\\n4. Construct a node (say root) with the root value( first element of preorder). \\n5. Find the index of the root, say elem from the hashmap.\\n6. Find the number of elements ( say nElem) in the left subtree  = elem \\u2013 inStart\\n7. Call recursively for the left subtree with correct values (shown in the above table) and store the answer received in root->left.\\n8. Call recursively for the right subtree with correct values (shown in the above table) and store the answer received in root->right.\\n9. Return root\\n\\n\\n\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n    O(n)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n    O(n)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    TreeNode* buildTree(vector<int>& preorder, vector<int>& inorder) {\\n        unordered_map<int, int> mp;\\n        for (int i = 0; i < inorder.size(); i++) {\\n            mp[inorder[i]] = i;\\n        }\\n\\n        int n = preorder.size();\\n        int m = inorder.size();\\n\\n        TreeNode* root = build(preorder, 0, n - 1, inorder, 0, m - 1, mp);\\n        return root;\\n    }\\n\\n    TreeNode* build(vector<int>& preorder, int preStart, int preEnd, vector<int>& inorder, int inStart, int inEnd, unordered_map<int, int>& mp) {\\n        if (preStart > preEnd || inStart > inEnd)\\n            return nullptr;\\n\\n        TreeNode* root = new TreeNode(preorder[preStart]);\\n        int inRoot = mp[root->val];\\n        int numLeft = inRoot - inStart;\\n\\n        root->left = build(preorder, preStart + 1, preStart + numLeft, inorder, inStart, inRoot - 1, mp);\\n        root->right = build(preorder, preStart + numLeft + 1, preEnd, inorder, inRoot + 1, inEnd, mp);\\n\\n        return root;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    TreeNode* buildTree(vector<int>& preorder, vector<int>& inorder) {\\n        unordered_map<int, int> mp;\\n        for (int i = 0; i < inorder.size(); i++) {\\n            mp[inorder[i]] = i;\\n        }\\n\\n        int n = preorder.size();\\n        int m = inorder.size();\\n\\n        TreeNode* root = build(preorder, 0, n - 1, inorder, 0, m - 1, mp);\\n        return root;\\n    }\\n\\n    TreeNode* build(vector<int>& preorder, int preStart, int preEnd, vector<int>& inorder, int inStart, int inEnd, unordered_map<int, int>& mp) {\\n        if (preStart > preEnd || inStart > inEnd)\\n            return nullptr;\\n\\n        TreeNode* root = new TreeNode(preorder[preStart]);\\n        int inRoot = mp[root->val];\\n        int numLeft = inRoot - inStart;\\n\\n        root->left = build(preorder, preStart + 1, preStart + numLeft, inorder, inStart, inRoot - 1, mp);\\n        root->right = build(preorder, preStart + numLeft + 1, preEnd, inorder, inRoot + 1, inEnd, mp);\\n\\n        return root;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3660642,
                "title": "c-striver-s-approach",
                "content": "# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    map<int,int>m;\\n    TreeNode* buildTree(vector<int>& pre, vector<int>& in) {\\n        for(int i=0;i<in.size();i++){\\n            m[in[i]]=i;\\n        }\\n        TreeNode* root = build(pre,0,pre.size()-1,in,0,in.size()-1);\\n        return root;\\n    }\\n    TreeNode* build(vector<int>&pre,int preStart,int preEnd,vector<int>&in, int inStart,int inEnd){\\n        if(preStart>preEnd || inStart>inEnd)return NULL;\\n        TreeNode* root = new  TreeNode(pre[preStart]);\\n        int index = m[pre[preStart]];\\n        int len = index - inStart;\\n        root->left = build(pre,preStart+1,preStart+len,in,inStart,index-1);\\n        root->right = build(pre,preStart+len+1,preEnd,in,index+1,inEnd);\\n        return root;\\n    }\\n};\\n```\\n![upvote (2).jpg](https://assets.leetcode.com/users/images/bf7cf45a-aa9b-4579-b017-f7da28ba149c_1687249916.1140192.jpeg)\\n",
                "solutionTags": [
                    "C++",
                    "Hash Table",
                    "Divide and Conquer",
                    "Tree",
                    "Binary Tree"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    map<int,int>m;\\n    TreeNode* buildTree(vector<int>& pre, vector<int>& in) {\\n        for(int i=0;i<in.size();i++){\\n            m[in[i]]=i;\\n        }\\n        TreeNode* root = build(pre,0,pre.size()-1,in,0,in.size()-1);\\n        return root;\\n    }\\n    TreeNode* build(vector<int>&pre,int preStart,int preEnd,vector<int>&in, int inStart,int inEnd){\\n        if(preStart>preEnd || inStart>inEnd)return NULL;\\n        TreeNode* root = new  TreeNode(pre[preStart]);\\n        int index = m[pre[preStart]];\\n        int len = index - inStart;\\n        root->left = build(pre,preStart+1,preStart+len,in,inStart,index-1);\\n        root->right = build(pre,preStart+len+1,preEnd,in,index+1,inEnd);\\n        return root;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2279391,
                "title": "c-image-well-explained-clean-code-faster-than-100-ms",
                "content": "\\n![image](https://assets.leetcode.com/users/images/b73d7363-f413-4889-aa87-cdd97aa3dd01_1657769612.872725.jpeg)\\n\\n\\n\\n\\n\\nYou need to understand preorder and postorder traversal first, and then go ahead\\n\\nBasic idea is:\\n\\n1. preorder[0] is the root node of the tree\\n2. preorder[x] is a root node of a sub tree\\n3. In in-order traversal\\n4. When inorder[index] is an item in the in-order traversal\\n5. inorder[0]-inorder[index-1] are on the left branch\\n6. inorder[index+1]-inorder[size()-1] are on the right branch\\n7. if there is nothing on the left, that means the left child of the node is NULL\\n8. if there is nothing on the right, that means the right child of the node is NULL\\n\\n**Algorithm:**\\n\\n1. Start from rootIdx 0\\n2. Find preorder[rootIdx] from inorder, let\\'s call the index pivot\\n3. Create a new node with inorder[pivot]\\n4. Create its left child recursively\\n5. Create its right child recursively\\n6. Return the created node.\\n\\nThe implementation is self explanatory. Have a look :)\\n\\n```\\nclass Solution {\\npublic:\\n        TreeNode* solve(int prestart, int instart, int inend, vector<int>& preorder, vector<int>& inorder)      {\\n        if(prestart > preorder.size()-1 || instart > inend) return NULL;\\n        TreeNode* root = new TreeNode(preorder[prestart]);\\n        int index = 0;\\n        for(int i = instart; i <= inend; i++)\\n            if(root->val == inorder[i]) index = i;\\n            \\n        root->left = solve(prestart+1, instart, index-1, preorder, inorder);\\n        root->right = solve(prestart+index-instart+1, index+1, inend, preorder, inorder);\\n        return root;\\n    }\\n        TreeNode* buildTree(vector<int>& preorder, vector<int>& inorder) {\\n        return solve(0, 0, inorder.size()-1, preorder, inorder);\\n    }\\n};\\n```\\n```\\n\\nTC:O(N)\\nSC:O(N)\\n\\nIF YOU LIKED IT SOLUTION THEN PLEASE UPVOTE IT !!!!",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n        TreeNode* solve(int prestart, int instart, int inend, vector<int>& preorder, vector<int>& inorder)      {\\n        if(prestart > preorder.size()-1 || instart > inend) return NULL;\\n        TreeNode* root = new TreeNode(preorder[prestart]);\\n        int index = 0;\\n        for(int i = instart; i <= inend; i++)\\n            if(root->val == inorder[i]) index = i;\\n            \\n        root->left = solve(prestart+1, instart, index-1, preorder, inorder);\\n        root->right = solve(prestart+index-instart+1, index+1, inend, preorder, inorder);\\n        return root;\\n    }\\n        TreeNode* buildTree(vector<int>& preorder, vector<int>& inorder) {\\n        return solve(0, 0, inorder.size()-1, preorder, inorder);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 815773,
                "title": "simple-readable-solution-in-python",
                "content": "* Please note that the function has an extra argument ```tree: TreeNode = None```.\\n* The trick here is to start with ```preorder``` array. The first element of any preorder array is the root.\\n* Once we find the index of the current root in the ```inorder``` array, we can divide both the ```inorder``` and the ```preorder``` into two sub-parts. Each consist of the left and right subtree.\\n* This is clear if you see the ```inorder``` sub-parts.\\n* But with ```preorder``` sub-parts, it\\'s essential to make sure the root is discarded and both the sub-parts contains the elements of the left and right sub-tree.\\n\\n```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    \\n    def buildTree(self, preorder: List[int], inorder: List[int], tree: TreeNode = None) -> TreeNode:\\n        \\n        # Check if the root exist in inorder\\n        if len(preorder) and preorder[0] in inorder:\\n            \\n            # Find the root index\\n            root_index = inorder.index(preorder[0])\\n        \\n            # Make the root node\\n            tree = TreeNode(val=inorder[root_index])\\n\\n            # Build left subtree\\n            tree.left = self.buildTree(preorder[1:root_index+1], inorder[:root_index])\\n\\n            # Build right subtree\\n            tree.right = self.buildTree(preorder[root_index+1:], inorder[root_index+1:])\\n            \\n        return tree\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```tree: TreeNode = None```\n```preorder```\n```inorder```\n```inorder```\n```preorder```\n```inorder```\n```preorder```\n```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    \\n    def buildTree(self, preorder: List[int], inorder: List[int], tree: TreeNode = None) -> TreeNode:\\n        \\n        # Check if the root exist in inorder\\n        if len(preorder) and preorder[0] in inorder:\\n            \\n            # Find the root index\\n            root_index = inorder.index(preorder[0])\\n        \\n            # Make the root node\\n            tree = TreeNode(val=inorder[root_index])\\n\\n            # Build left subtree\\n            tree.left = self.buildTree(preorder[1:root_index+1], inorder[:root_index])\\n\\n            # Build right subtree\\n            tree.right = self.buildTree(preorder[root_index+1:], inorder[root_index+1:])\\n            \\n        return tree\\n```",
                "codeTag": "Java"
            },
            {
                "id": 764302,
                "title": "javascript-solution-w-video-explanation",
                "content": "https://www.youtube.com/watch?v=azABXElvFWg",
                "solutionTags": [
                    "JavaScript",
                    "Recursion"
                ],
                "code": "https://www.youtube.com/watch?v=azABXElvFWg",
                "codeTag": "Unknown"
            },
            {
                "id": 675687,
                "title": "java-easy-to-understand-solution",
                "content": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    Map<Integer, Integer> map;\\n    int index;\\n    public TreeNode buildTree(int[] preorder, int[] inorder) {\\n        index = 0;\\n        map = new HashMap<>();\\n        int size = inorder.length;\\n        for (int i = 0; i < size; ++i){\\n            map.put(inorder[i], i);\\n        }\\n        return helper(preorder, inorder, 0, size - 1);\\n    }\\n    \\n    private TreeNode helper(int[] preorder, int[] inorder, int lo, int hi){\\n        if (lo > hi)\\n            return null;\\n        int var = preorder[index++];\\n        TreeNode root = new TreeNode(var);\\n        int cut = map.get(var);\\n        root.left = helper(preorder, inorder, lo, cut - 1);\\n        root.right = helper(preorder, inorder, cut + 1, hi);\\n        return root;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    Map<Integer, Integer> map;\\n    int index;\\n    public TreeNode buildTree(int[] preorder, int[] inorder) {\\n        index = 0;\\n        map = new HashMap<>();\\n        int size = inorder.length;\\n        for (int i = 0; i < size; ++i){\\n            map.put(inorder[i], i);\\n        }\\n        return helper(preorder, inorder, 0, size - 1);\\n    }\\n    \\n    private TreeNode helper(int[] preorder, int[] inorder, int lo, int hi){\\n        if (lo > hi)\\n            return null;\\n        int var = preorder[index++];\\n        TreeNode root = new TreeNode(var);\\n        int cut = map.get(var);\\n        root.left = helper(preorder, inorder, lo, cut - 1);\\n        root.right = helper(preorder, inorder, cut + 1, hi);\\n        return root;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 34569,
                "title": "c-8-9-11-lines-of-recursion",
                "content": "First version:\\n```\\nclass Solution {\\npublic:\\n    TreeNode* buildTree(vector<int>& preorder, vector<int>& inorder) {\\n        if(preorder.size() == 0) return NULL;\\n        TreeNode* root = new TreeNode(preorder[0]);\\n        //Find root in inorder \\n        int i = find(inorder.begin(), inorder.end(), preorder[0]) - inorder.begin();\\n        //preorder and inorder for each left and right subtree\\n        vector<int>inorderLeft(inorder.begin(), inorder.begin() + i);\\n        vector<int>inorderRight(inorder.begin() + i + 1, inorder.end());\\n        vector<int>preorderLeft(preorder.begin() + 1, preorder.begin() + 1 + i);\\n        vector<int>preorderRight(preorder.begin() + 1 + i, preorder.end());\\n        //Build tree\\n        root->left = buildTree(preorderLeft, inorderLeft);\\n        root->right = buildTree(preorderRight, inorderRight);\\n        return root;\\n    }\\n};\\n```\\n***\\nThen I realized I don't need so much extra memory, and reduced run time from 62ms to 19ms.\\n```\\nclass Solution {\\npublic:\\n    TreeNode* buildTree(vector<int>& preorder, vector<int>& inorder) {\\n        return helper(preorder, 0, preorder.size() - 1, inorder, 0, inorder.size() - 1);\\n    }\\n    \\n    TreeNode* helper(vector<int>& preorder, int pStart, int pEnd, vector<int>& inorder, int iStart, int iEnd) {\\n        if(pStart > pEnd) return NULL;\\n        TreeNode* root = new TreeNode(preorder[pStart]);\\n        int i = find(inorder.begin(), inorder.end(), preorder[pStart]) - inorder.begin();\\n        root->left = helper(preorder, pStart + 1, pStart + i - iStart, inorder, iStart, i - 1);\\n        root->right = helper(preorder, pStart + i - iStart + 1, pEnd, inorder, i + 1, iEnd);\\n        return root;\\n    }\\n};\\n```\\n***\\nAnd it can be faster using unordered_map to store the indices first. Run time: from 19ms to 9ms.\\n```\\nclass Solution {\\npublic:\\n    TreeNode* buildTree(vector<int>& preorder, vector<int>& inorder) {\\n        unordered_map<int, int>m;\\n        for(int i = 0; i < inorder.size(); i++) m[inorder[i]] = i;\\n        return helper(preorder, 0, preorder.size() - 1, inorder, 0, inorder.size() - 1, m);\\n    }\\n    \\n    TreeNode* helper(vector<int>& preorder, int pStart, int pEnd, vector<int>& inorder, int iStart, int iEnd, unordered_map<int, int>& m) {\\n        if(pStart > pEnd) return NULL;\\n        TreeNode* root = new TreeNode(preorder[pStart]);\\n        int i = m[preorder[pStart]];\\n        root->left = helper(preorder, pStart + 1, pStart + i - iStart, inorder, iStart, i - 1, m);\\n        root->right = helper(preorder, pStart + i - iStart + 1, pEnd, inorder, i + 1, iEnd, m);\\n        return root;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    TreeNode* buildTree(vector<int>& preorder, vector<int>& inorder) {\\n        if(preorder.size() == 0) return NULL;\\n        TreeNode* root = new TreeNode(preorder[0]);\\n        //Find root in inorder \\n        int i = find(inorder.begin(), inorder.end(), preorder[0]) - inorder.begin();\\n        //preorder and inorder for each left and right subtree\\n        vector<int>inorderLeft(inorder.begin(), inorder.begin() + i);\\n        vector<int>inorderRight(inorder.begin() + i + 1, inorder.end());\\n        vector<int>preorderLeft(preorder.begin() + 1, preorder.begin() + 1 + i);\\n        vector<int>preorderRight(preorder.begin() + 1 + i, preorder.end());\\n        //Build tree\\n        root->left = buildTree(preorderLeft, inorderLeft);\\n        root->right = buildTree(preorderRight, inorderRight);\\n        return root;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    TreeNode* buildTree(vector<int>& preorder, vector<int>& inorder) {\\n        return helper(preorder, 0, preorder.size() - 1, inorder, 0, inorder.size() - 1);\\n    }\\n    \\n    TreeNode* helper(vector<int>& preorder, int pStart, int pEnd, vector<int>& inorder, int iStart, int iEnd) {\\n        if(pStart > pEnd) return NULL;\\n        TreeNode* root = new TreeNode(preorder[pStart]);\\n        int i = find(inorder.begin(), inorder.end(), preorder[pStart]) - inorder.begin();\\n        root->left = helper(preorder, pStart + 1, pStart + i - iStart, inorder, iStart, i - 1);\\n        root->right = helper(preorder, pStart + i - iStart + 1, pEnd, inorder, i + 1, iEnd);\\n        return root;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    TreeNode* buildTree(vector<int>& preorder, vector<int>& inorder) {\\n        unordered_map<int, int>m;\\n        for(int i = 0; i < inorder.size(); i++) m[inorder[i]] = i;\\n        return helper(preorder, 0, preorder.size() - 1, inorder, 0, inorder.size() - 1, m);\\n    }\\n    \\n    TreeNode* helper(vector<int>& preorder, int pStart, int pEnd, vector<int>& inorder, int iStart, int iEnd, unordered_map<int, int>& m) {\\n        if(pStart > pEnd) return NULL;\\n        TreeNode* root = new TreeNode(preorder[pStart]);\\n        int i = m[preorder[pStart]];\\n        root->left = helper(preorder, pStart + 1, pStart + i - iStart, inorder, iStart, i - 1, m);\\n        root->right = helper(preorder, pStart + i - iStart + 1, pEnd, inorder, i + 1, iEnd, m);\\n        return root;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2399533,
                "title": "c-iterative-runtime-beats-95-52-memory-beats-99-40",
                "content": "```\\n    TreeNode* buildTree(vector<int>& preorder, vector<int>& inorder)\\n    {\\n        int i = 0;\\n        int j = 0;\\n        int pre_size = preorder.size();\\n        if (pre_size == 0)\\n        {\\n            return NULL;\\n        }\\n\\n        stack<TreeNode*> s;\\n        TreeNode* root = new TreeNode(preorder[0]);\\n        s.push(root);\\n        \\n        while (i < pre_size - 1)\\n        {\\n            TreeNode* node = s.top();\\n            if (node->val != inorder[j])\\n            {\\n                ++i;\\n                node->left = new TreeNode(preorder[i]);\\n                node = node->left;\\n                s.push(node);\\n            } \\n            else\\n            {\\n                s.pop();\\n                ++j;\\n                if (s.empty() || s.top()->val != inorder[j])\\n                {\\n                    ++i;\\n                    node->right = new TreeNode(preorder[i]);\\n                    node = node->right;\\n                    s.push(node);\\n                }\\n            }\\n        }\\n        return root;\\n    }\\n```\\n\\nPlease upvote if you found this useful! :)",
                "solutionTags": [
                    "C",
                    "Iterator"
                ],
                "code": "```\\n    TreeNode* buildTree(vector<int>& preorder, vector<int>& inorder)\\n    {\\n        int i = 0;\\n        int j = 0;\\n        int pre_size = preorder.size();\\n        if (pre_size == 0)\\n        {\\n            return NULL;\\n        }\\n\\n        stack<TreeNode*> s;\\n        TreeNode* root = new TreeNode(preorder[0]);\\n        s.push(root);\\n        \\n        while (i < pre_size - 1)\\n        {\\n            TreeNode* node = s.top();\\n            if (node->val != inorder[j])\\n            {\\n                ++i;\\n                node->left = new TreeNode(preorder[i]);\\n                node = node->left;\\n                s.push(node);\\n            } \\n            else\\n            {\\n                s.pop();\\n                ++j;\\n                if (s.empty() || s.top()->val != inorder[j])\\n                {\\n                    ++i;\\n                    node->right = new TreeNode(preorder[i]);\\n                    node = node->right;\\n                    s.push(node);\\n                }\\n            }\\n        }\\n        return root;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2280942,
                "title": "easy-java-solution-with-explanation-faster-than-100-submission",
                "content": "Since we have preorder array we know that if we go from left to right we will get roots of the present sub tree, so finding roots of each subtree is easy here.\\n\\nNow comes the part of finding left and right sub tree.\\nSo if we find the position of root(j) in inoreder, then the left subtree is subarray from (start, j-1) and the right subtree is subarray from (j+1, end).\\n\\n```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    int p=0;//preorder array pointer\\n    public TreeNode buildTree(int[] preorder, int[] inorder) {\\n        return helper( 0, inorder.length-1, preorder, inorder);\\n    }\\n    public TreeNode helper( int is, int ie, int[] preorder, int[] inorder){\\n        if(is>ie) return null;//if the subarray from is to ie doesn\\'t exist then the subarray doen\\'t exist\\n        int j = find(preorder[p], inorder, is, ie);//find the root of the present subtree in inorder array\\n        TreeNode node = new TreeNode(preorder[p]);//create new node of the sub tree\\n        p++;//increase the pointer of preorder array\\n        node.left = helper( is, j-1, preorder, inorder);//build left sub tree\\n        node.right = helper( j+1, ie, preorder, inorder);//build right sub tree\\n        return node;\\n    }\\n    //find func implemented using Binary Search as it uses O(n) time complexity\\n    public int find(int val, int[] inorder,int start, int end){\\n        while(start < end && inorder[start] != val && inorder[end] != val) {\\n            start++;\\n            end--;\\n        }\\n        return inorder[start] == val ? start : end;\\n    }\\n}\\n```\\n\\nupvote if you find it helpful.",
                "solutionTags": [
                    "Java",
                    "Recursion",
                    "Binary Tree"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    int p=0;//preorder array pointer\\n    public TreeNode buildTree(int[] preorder, int[] inorder) {\\n        return helper( 0, inorder.length-1, preorder, inorder);\\n    }\\n    public TreeNode helper( int is, int ie, int[] preorder, int[] inorder){\\n        if(is>ie) return null;//if the subarray from is to ie doesn\\'t exist then the subarray doen\\'t exist\\n        int j = find(preorder[p], inorder, is, ie);//find the root of the present subtree in inorder array\\n        TreeNode node = new TreeNode(preorder[p]);//create new node of the sub tree\\n        p++;//increase the pointer of preorder array\\n        node.left = helper( is, j-1, preorder, inorder);//build left sub tree\\n        node.right = helper( j+1, ie, preorder, inorder);//build right sub tree\\n        return node;\\n    }\\n    //find func implemented using Binary Search as it uses O(n) time complexity\\n    public int find(int val, int[] inorder,int start, int end){\\n        while(start < end && inorder[start] != val && inorder[end] != val) {\\n            start++;\\n            end--;\\n        }\\n        return inorder[start] == val ? start : end;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1810477,
                "title": "c-with-detailed-example-of-tree-construction",
                "content": "```\\ne.g.                 \\n            (3) \\n           /   \\\\\\n        (9)    (20)\\n               /   \\\\\\n            (15)   (7)   \\n           \\n\\n###1###\\n        pIdx = 0                        iLeftIdx = 0       iRightIdx = 4\\n\\n        preorder = [3,9,20,15,7]       inorder = [9,3,15,20,7]\\n                    ^                             ^          ^\\n                  pIdx                     iLeftIdx          iRightIdx\\n\\n        iRootIdx = 1\\n                                        ------------------------------------\\n                                                    (3)   \\n                                        ------------------------------------\\n                                        \\n###2###                        \\n        pIdx = 1                        iLeftIdx = 0       iRightIdx = 0\\n\\n        preorder = [3,9,20,15,7]       inorder = [9,3,15,20,7]\\n                     ^                           ^^\\n                   pIdx                  iLeftIdx iRightIdx\\n\\n        iRootIdx = 0\\n                                        ------------------------------------\\n                                                   (3)\\n                                                  /\\n                                                (9)\\n                                        ------------------------------------\\n                                \\n###3###\\n        pIdx = 2                        iLeftIdx = 0       iRightIdx = -1\\n\\n        preorder = [3,9,20,15,7]       inorder = [9,3,15,20,7]\\n                         ^                      ^ ^\\n                       pIdx             iRightIdx iLeftIdx      \\n                                        ------------------------------------\\n                                                   (3)\\n                                                  /\\n                                                (9)\\n                                               /   \\n                                             null\\n                                        ------------------------------------\\n\\n###4###\\n        pIdx = 2                        iLeftIdx = 1       iRightIdx = 0\\n\\n        preorder = [3,9,20,15,7]       inorder = [9,3,15,20,7]\\n                         ^                        ^ ^\\n                       pIdx               iRightIdx iLeftIdx     \\n                                        ------------------------------------\\n                                                   (3)\\n                                                  /\\n                                                (9)\\n                                               /   \\\\\\n                                            null  null \\n                                        ------------------------------------\\n\\n###5###\\n        pIdx = 2                        iLeftIdx = 2       iRightIdx = 4\\n\\n        preorder = [3,9,20,15,7]       inorder = [9,3,15,20,7]\\n                        ^                             ^     ^\\n                      pIdx                     iLeftIdx     iRightIdx \\n\\n        iRootIdx = 3    \\n                                        ------------------------------------\\n                                                       (3) \\n                                                    /      \\\\\\n                                                (9)          (20)\\n                                               /   \\\\\\n                                            null  null \\n\\n###6###\\n        pIdx = 3                        iLeftIdx = 2       iRightIdx = 2\\n\\n        preorder = [3,9,20,15,7]       inorder = [9,3,15,20,7]\\n                           ^                          ^^\\n                         pIdx                 iLeftIdx iRightIdx \\n\\n        iRootIdx = 2\\n                                        ------------------------------------\\n                                                       (3) \\n                                                    /      \\\\\\n                                                (9)          (20)\\n                                               /   \\\\        /\\n                                            null  null   (15) \\n                                        ------------------------------------\\n\\n###7###\\n        pIdx = 4                        iLeftIdx = 2       iRightIdx = 1\\n\\n        preorder = [3,9,20,15,7]       inorder = [9,3,15,20,7]\\n                              ^                     ^  ^\\n                             pIdx           iRightIdx  iLeftIdx\\n                                        ------------------------------------\\n                                                       (3) \\n                                                    /      \\\\\\n                                                (9)          (20)\\n                                               /   \\\\        /\\n                                            null  null   (15)\\n                                                        /\\n                                                     null \\n                                        ------------------------------------\\n\\n###8###\\n        pIdx = 4                        iLeftIdx = 3       iRightIdx = 2\\n\\n        preorder = [3,9,20,15,7]       inorder = [9,3,15,20,7]\\n                              ^                       ^  ^\\n                            pIdx              iRightIdx  iLeftIdx  \\n                                        ------------------------------------\\n                                                       (3) \\n                                                    /      \\\\\\n                                                (9)          (20)\\n                                               /   \\\\        /\\n                                            null  null   (15)\\n                                                        /   \\\\\\n                                                     null  null\\n                                        ------------------------------------\\n\\n###9###\\n        pIdx = 4                        iLeftIdx = 4       iRightIdx = 4\\n\\n        preorder = [3,9,20,15,7]       inorder = [9,3,15,20,7]\\n                              ^                             ^^\\n                            pIdx                    iLeftIdx iRightIdx \\n        iRootIdx = 4\\n                                        ------------------------------------\\n                                                       (3) \\n                                                    /      \\\\\\n                                                (9)          (20)\\n                                               /   \\\\        /    \\\\\\n                                            null  null   (15)    (7)\\n                                                        /   \\\\\\n                                                     null  null\\n                                        ------------------------------------\\n\\n###10###\\n        pIdx = 5                        iLeftIdx = 4       iRightIdx = 3\\n\\n        preorder = [3,9,20,15,7]       inorder = [9,3,15,20,7]\\n                                ^                        ^  ^\\n                              pIdx               iRightIdx  iLeftIdx \\n                                        ------------------------------------\\n                                                        (3) \\n                                                    /        \\\\\\n                                                (9)            (20)\\n                                               /   \\\\        /      \\\\\\n                                            null  null   (15)      (7)\\n                                                        /   \\\\     /\\n                                                     null  null null\\n                                        ------------------------------------\\n\\n###11###\\n        pIdx = 5                        iLeftIdx = 5       iRightIdx = 4\\n\\n        preorder = [3,9,20,15,7]       inorder = [9,3,15,20,7]\\n                                ^                           ^  ^\\n                              pIdx                  iRightIdx  iLeftIdx \\n                                        ------------------------------------\\n                                                        (3) \\n                                                    /        \\\\\\n                                                (9)            (20)\\n                                               /   \\\\        /      \\\\\\n                                            null  null   (15)      (7)\\n                                                        /   \\\\     /   \\\\\\n                                                     null  null null  null\\n                                        ------------------------------------\\n\\n```\\n\\n```\\nclass Solution {\\npublic:\\n    TreeNode* buildTree(vector<int>& preorder, vector<int>& inorder) {\\n        unordered_map<int, int> inorderMap;\\n        for (int i = 0; i < inorder.size(); i++){\\n            inorderMap[inorder[i]] = i;\\n        }\\n        int pIdx = 0;\\n        return buildTreeRec(preorder, pIdx,\\n                            inorderMap, 0, inorder.size()-1);\\n    }\\n    \\n    TreeNode* buildTreeRec(vector<int>& preorder, int& pIdx,\\n                           unordered_map<int, int>& inorderMap, int iLeftIdx, int iRightIdx){\\n        \\n        if (iLeftIdx > iRightIdx){\\n            pIdx--;\\n            return nullptr;\\n        }\\n        \\n        TreeNode* rootNodePtr = new TreeNode(preorder[pIdx]);\\n        \\n        int iRootIdx = inorderMap[preorder[pIdx]];\\n        pIdx++;\\n        rootNodePtr->left = buildTreeRec(preorder, pIdx, \\n                                         inorderMap, iLeftIdx, iRootIdx-1);\\n        pIdx++;\\n        rootNodePtr->right = buildTreeRec(preorder, pIdx,\\n                                          inorderMap, iRootIdx+1, iRightIdx);\\n        return rootNodePtr;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Recursion",
                    "Binary Tree"
                ],
                "code": "```\\ne.g.                 \\n            (3) \\n           /   \\\\\\n        (9)    (20)\\n               /   \\\\\\n            (15)   (7)   \\n           \\n\\n###1###\\n        pIdx = 0                        iLeftIdx = 0       iRightIdx = 4\\n\\n        preorder = [3,9,20,15,7]       inorder = [9,3,15,20,7]\\n                    ^                             ^          ^\\n                  pIdx                     iLeftIdx          iRightIdx\\n\\n        iRootIdx = 1\\n                                        ------------------------------------\\n                                                    (3)   \\n                                        ------------------------------------\\n                                        \\n###2###                        \\n        pIdx = 1                        iLeftIdx = 0       iRightIdx = 0\\n\\n        preorder = [3,9,20,15,7]       inorder = [9,3,15,20,7]\\n                     ^                           ^^\\n                   pIdx                  iLeftIdx iRightIdx\\n\\n        iRootIdx = 0\\n                                        ------------------------------------\\n                                                   (3)\\n                                                  /\\n                                                (9)\\n                                        ------------------------------------\\n                                \\n###3###\\n        pIdx = 2                        iLeftIdx = 0       iRightIdx = -1\\n\\n        preorder = [3,9,20,15,7]       inorder = [9,3,15,20,7]\\n                         ^                      ^ ^\\n                       pIdx             iRightIdx iLeftIdx      \\n                                        ------------------------------------\\n                                                   (3)\\n                                                  /\\n                                                (9)\\n                                               /   \\n                                             null\\n                                        ------------------------------------\\n\\n###4###\\n        pIdx = 2                        iLeftIdx = 1       iRightIdx = 0\\n\\n        preorder = [3,9,20,15,7]       inorder = [9,3,15,20,7]\\n                         ^                        ^ ^\\n                       pIdx               iRightIdx iLeftIdx     \\n                                        ------------------------------------\\n                                                   (3)\\n                                                  /\\n                                                (9)\\n                                               /   \\\\\\n                                            null  null \\n                                        ------------------------------------\\n\\n###5###\\n        pIdx = 2                        iLeftIdx = 2       iRightIdx = 4\\n\\n        preorder = [3,9,20,15,7]       inorder = [9,3,15,20,7]\\n                        ^                             ^     ^\\n                      pIdx                     iLeftIdx     iRightIdx \\n\\n        iRootIdx = 3    \\n                                        ------------------------------------\\n                                                       (3) \\n                                                    /      \\\\\\n                                                (9)          (20)\\n                                               /   \\\\\\n                                            null  null \\n\\n###6###\\n        pIdx = 3                        iLeftIdx = 2       iRightIdx = 2\\n\\n        preorder = [3,9,20,15,7]       inorder = [9,3,15,20,7]\\n                           ^                          ^^\\n                         pIdx                 iLeftIdx iRightIdx \\n\\n        iRootIdx = 2\\n                                        ------------------------------------\\n                                                       (3) \\n                                                    /      \\\\\\n                                                (9)          (20)\\n                                               /   \\\\        /\\n                                            null  null   (15) \\n                                        ------------------------------------\\n\\n###7###\\n        pIdx = 4                        iLeftIdx = 2       iRightIdx = 1\\n\\n        preorder = [3,9,20,15,7]       inorder = [9,3,15,20,7]\\n                              ^                     ^  ^\\n                             pIdx           iRightIdx  iLeftIdx\\n                                        ------------------------------------\\n                                                       (3) \\n                                                    /      \\\\\\n                                                (9)          (20)\\n                                               /   \\\\        /\\n                                            null  null   (15)\\n                                                        /\\n                                                     null \\n                                        ------------------------------------\\n\\n###8###\\n        pIdx = 4                        iLeftIdx = 3       iRightIdx = 2\\n\\n        preorder = [3,9,20,15,7]       inorder = [9,3,15,20,7]\\n                              ^                       ^  ^\\n                            pIdx              iRightIdx  iLeftIdx  \\n                                        ------------------------------------\\n                                                       (3) \\n                                                    /      \\\\\\n                                                (9)          (20)\\n                                               /   \\\\        /\\n                                            null  null   (15)\\n                                                        /   \\\\\\n                                                     null  null\\n                                        ------------------------------------\\n\\n###9###\\n        pIdx = 4                        iLeftIdx = 4       iRightIdx = 4\\n\\n        preorder = [3,9,20,15,7]       inorder = [9,3,15,20,7]\\n                              ^                             ^^\\n                            pIdx                    iLeftIdx iRightIdx \\n        iRootIdx = 4\\n                                        ------------------------------------\\n                                                       (3) \\n                                                    /      \\\\\\n                                                (9)          (20)\\n                                               /   \\\\        /    \\\\\\n                                            null  null   (15)    (7)\\n                                                        /   \\\\\\n                                                     null  null\\n                                        ------------------------------------\\n\\n###10###\\n        pIdx = 5                        iLeftIdx = 4       iRightIdx = 3\\n\\n        preorder = [3,9,20,15,7]       inorder = [9,3,15,20,7]\\n                                ^                        ^  ^\\n                              pIdx               iRightIdx  iLeftIdx \\n                                        ------------------------------------\\n                                                        (3) \\n                                                    /        \\\\\\n                                                (9)            (20)\\n                                               /   \\\\        /      \\\\\\n                                            null  null   (15)      (7)\\n                                                        /   \\\\     /\\n                                                     null  null null\\n                                        ------------------------------------\\n\\n###11###\\n        pIdx = 5                        iLeftIdx = 5       iRightIdx = 4\\n\\n        preorder = [3,9,20,15,7]       inorder = [9,3,15,20,7]\\n                                ^                           ^  ^\\n                              pIdx                  iRightIdx  iLeftIdx \\n                                        ------------------------------------\\n                                                        (3) \\n                                                    /        \\\\\\n                                                (9)            (20)\\n                                               /   \\\\        /      \\\\\\n                                            null  null   (15)      (7)\\n                                                        /   \\\\     /   \\\\\\n                                                     null  null null  null\\n                                        ------------------------------------\\n\\n```\n```\\nclass Solution {\\npublic:\\n    TreeNode* buildTree(vector<int>& preorder, vector<int>& inorder) {\\n        unordered_map<int, int> inorderMap;\\n        for (int i = 0; i < inorder.size(); i++){\\n            inorderMap[inorder[i]] = i;\\n        }\\n        int pIdx = 0;\\n        return buildTreeRec(preorder, pIdx,\\n                            inorderMap, 0, inorder.size()-1);\\n    }\\n    \\n    TreeNode* buildTreeRec(vector<int>& preorder, int& pIdx,\\n                           unordered_map<int, int>& inorderMap, int iLeftIdx, int iRightIdx){\\n        \\n        if (iLeftIdx > iRightIdx){\\n            pIdx--;\\n            return nullptr;\\n        }\\n        \\n        TreeNode* rootNodePtr = new TreeNode(preorder[pIdx]);\\n        \\n        int iRootIdx = inorderMap[preorder[pIdx]];\\n        pIdx++;\\n        rootNodePtr->left = buildTreeRec(preorder, pIdx, \\n                                         inorderMap, iLeftIdx, iRootIdx-1);\\n        pIdx++;\\n        rootNodePtr->right = buildTreeRec(preorder, pIdx,\\n                                          inorderMap, iRootIdx+1, iRightIdx);\\n        return rootNodePtr;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1645970,
                "title": "easy-to-understand-javascript-solution",
                "content": "\\tvar buildTree = function(preorder, inorder) {\\n\\t\\tconst getTree = (left = 0, right = preorder.length - 1) => {\\n\\t\\t\\tif (left > right) return null;\\n\\n\\t\\t\\tconst node = preorder.shift();\\n\\t\\t\\tconst treeNode = new TreeNode(node);\\n\\t\\t\\tconst index = inorder.indexOf(node);\\n\\n\\t\\t\\ttreeNode.left = getTree(left, index - 1);\\n\\t\\t\\ttreeNode.right = getTree(index + 1, right);\\n\\t\\t\\treturn treeNode;\\n\\t\\t};\\n\\n\\t\\treturn getTree();\\n\\t};",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "\\tvar buildTree = function(preorder, inorder) {\\n\\t\\tconst getTree = (left = 0, right = preorder.length - 1) => {\\n\\t\\t\\tif (left > right) return null;\\n\\n\\t\\t\\tconst node = preorder.shift();\\n\\t\\t\\tconst treeNode = new TreeNode(node);\\n\\t\\t\\tconst index = inorder.indexOf(node);\\n\\n\\t\\t\\ttreeNode.left = getTree(left, index - 1);\\n\\t\\t\\ttreeNode.right = getTree(index + 1, right);\\n\\t\\t\\treturn treeNode;\\n\\t\\t};\\n\\n\\t\\treturn getTree();\\n\\t};",
                "codeTag": "Unknown"
            },
            {
                "id": 1259453,
                "title": "simple-go-solution-using-recursion",
                "content": "[Github link](https://github.com/evleria/leetcode-in-go/blob/main/problems/0105-construct-binary-tree-from-preorder-and-inorder-traversal/build_tree.go)\\nSimilar to [problem #106](https://leetcode.com/problems/construct-binary-tree-from-inorder-and-postorder-traversal/discuss/1597722/Simple-Go-solution-using-recursion) \\n```\\nfunc buildTree(preorder []int, inorder []int) *TreeNode {\\n\\tif len(preorder) == 0 {\\n\\t\\treturn nil\\n\\t}\\n\\n\\tidx := indexOf(inorder, preorder[0])\\n\\treturn &TreeNode{\\n\\t\\tVal:   preorder[0],\\n\\t\\tLeft:  buildTree(preorder[1:idx+1], inorder[:idx]),\\n\\t\\tRight: buildTree(preorder[idx+1:], inorder[idx+1:]),\\n\\t}\\n}\\n\\nfunc indexOf(nums []int, target int) int {\\n\\tfor i, num := range nums {\\n\\t\\tif num == target {\\n\\t\\t\\treturn i\\n\\t\\t}\\n\\t}\\n\\treturn -1\\n}\\n```",
                "solutionTags": [
                    "Go",
                    "Recursion"
                ],
                "code": "```\\nfunc buildTree(preorder []int, inorder []int) *TreeNode {\\n\\tif len(preorder) == 0 {\\n\\t\\treturn nil\\n\\t}\\n\\n\\tidx := indexOf(inorder, preorder[0])\\n\\treturn &TreeNode{\\n\\t\\tVal:   preorder[0],\\n\\t\\tLeft:  buildTree(preorder[1:idx+1], inorder[:idx]),\\n\\t\\tRight: buildTree(preorder[idx+1:], inorder[idx+1:]),\\n\\t}\\n}\\n\\nfunc indexOf(nums []int, target int) int {\\n\\tfor i, num := range nums {\\n\\t\\tif num == target {\\n\\t\\t\\treturn i\\n\\t\\t}\\n\\t}\\n\\treturn -1\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1010940,
                "title": "python-recursion-7-lines-ivy",
                "content": "```\\nclass Solution:\\n    def buildTree(self, preorder: List[int], inorder: List[int]) -> TreeNode:\\n        \\n        if len(inorder) == 0:\\n            return \\n          \\n        root_val = preorder.pop(0)\\n        root =  TreeNode(root_val)\\n        index_root = inorder.index(root_val)\\n        \\n        l_lst = inorder[:index_root:]\\n        r_lst = inorder[index_root+1::]\\n        \\n        root.left = self.buildTree(preorder, l_lst)\\n        root.right = self.buildTree(preorder, r_lst)\\n        \\n        \\n        return root\\n```",
                "solutionTags": [
                    "Python",
                    "Recursion"
                ],
                "code": "```\\nclass Solution:\\n    def buildTree(self, preorder: List[int], inorder: List[int]) -> TreeNode:\\n        \\n        if len(inorder) == 0:\\n            return \\n          \\n        root_val = preorder.pop(0)\\n        root =  TreeNode(root_val)\\n        index_root = inorder.index(root_val)\\n        \\n        l_lst = inorder[:index_root:]\\n        r_lst = inorder[index_root+1::]\\n        \\n        root.left = self.buildTree(preorder, l_lst)\\n        root.right = self.buildTree(preorder, r_lst)\\n        \\n        \\n        return root\\n```",
                "codeTag": "Java"
            },
            {
                "id": 286173,
                "title": "c-dfs",
                "content": "```\\npublic class Solution {\\n    public TreeNode BuildTree(int[] preorder, int[] inorder) {\\n        var n = preorder.Length;\\n        if (n == 0) return null;\\n\\n        return DFS(preorder, 0, n - 1, inorder, 0, n - 1);\\n    }\\n\\n    private TreeNode DFS(int[] preorder, int preLeft, int preRight, int[] inorder, int inLeft, int inRight) {\\n        if (preLeft > preRight) return null;\\n\\n        var rootValue = preorder[preLeft];\\n        var rootInIndex = -1;\\n\\n        for (int i = inLeft; i <= inRight; i++) {\\n            if (inorder[i] == rootValue) {\\n                rootInIndex = i;\\n                break;\\n            }\\n        }\\n\\n        var count = rootInIndex - inLeft;\\n\\n        var root = new TreeNode(rootValue);\\n\\n        root.left = DFS(preorder, preLeft + 1, preLeft + count, inorder, inLeft, rootInIndex - 1);\\n        root.right = DFS(preorder, preLeft + count + 1, preRight, inorder, rootInIndex + 1, inRight);\\n\\n        return root;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    public TreeNode BuildTree(int[] preorder, int[] inorder) {\\n        var n = preorder.Length;\\n        if (n == 0) return null;\\n\\n        return DFS(preorder, 0, n - 1, inorder, 0, n - 1);\\n    }\\n\\n    private TreeNode DFS(int[] preorder, int preLeft, int preRight, int[] inorder, int inLeft, int inRight) {\\n        if (preLeft > preRight) return null;\\n\\n        var rootValue = preorder[preLeft];\\n        var rootInIndex = -1;\\n\\n        for (int i = inLeft; i <= inRight; i++) {\\n            if (inorder[i] == rootValue) {\\n                rootInIndex = i;\\n                break;\\n            }\\n        }\\n\\n        var count = rootInIndex - inLeft;\\n\\n        var root = new TreeNode(rootValue);\\n\\n        root.left = DFS(preorder, preLeft + 1, preLeft + count, inorder, inLeft, rootInIndex - 1);\\n        root.right = DFS(preorder, preLeft + count + 1, preRight, inorder, rootInIndex + 1, inRight);\\n\\n        return root;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 252600,
                "title": "simple-swift-solution",
                "content": "```swift\\nclass Solution {\\n    func buildTree(_ preorder: [Int], _ inorder: [Int]) -> TreeNode? {\\n        guard let rootVal = preorder.first else { return nil }\\n        let root = TreeNode(rootVal)\\n        \\n        let i = inorder.index(of: rootVal)!\\n        let inorderL = Array(inorder[0..<i])\\n        let inorderR = Array(inorder[i+1..<inorder.count])\\n        let preorderL = Array(preorder[1..<i+1])\\n        let preorderR = Array(preorder[i+1..<preorder.count])\\n\\n        root.left = buildTree(preorderL, inorderL)\\n        root.right = buildTree(preorderR, inorderR)\\n        return root\\n    }\\n}\\n```\\n\\nArraySlice version (fewer space complexity):\\n```swift\\nclass Solution {\\n    func buildTree(_ preorder: [Int], _ inorder: [Int]) -> TreeNode? {\\n        return buildTree(preorder[0...], inorder[0...])\\n    }\\n    \\n    func buildTree(_ preorder: ArraySlice<Int>, _ inorder: ArraySlice<Int>) -> TreeNode? {\\n        guard let rootVal = preorder.first else { return nil }\\n        let root = TreeNode(rootVal)\\n\\n        let i = inorder.index(of: rootVal)!\\n        let leftCount = i - inorder.startIndex\\n        let rightCount = inorder.endIndex - i - 1\\n        \\n        root.left = buildTree(\\n            preorder[preorder.startIndex+1..<preorder.startIndex+1+leftCount],\\n            inorder[inorder.startIndex..<inorder.startIndex+leftCount]\\n        )\\n        root.right = buildTree(\\n            preorder[preorder.endIndex-rightCount..<preorder.endIndex],\\n            inorder[inorder.endIndex-rightCount..<inorder.endIndex]\\n        )\\n        return root\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```swift\\nclass Solution {\\n    func buildTree(_ preorder: [Int], _ inorder: [Int]) -> TreeNode? {\\n        guard let rootVal = preorder.first else { return nil }\\n        let root = TreeNode(rootVal)\\n        \\n        let i = inorder.index(of: rootVal)!\\n        let inorderL = Array(inorder[0..<i])\\n        let inorderR = Array(inorder[i+1..<inorder.count])\\n        let preorderL = Array(preorder[1..<i+1])\\n        let preorderR = Array(preorder[i+1..<preorder.count])\\n\\n        root.left = buildTree(preorderL, inorderL)\\n        root.right = buildTree(preorderR, inorderR)\\n        return root\\n    }\\n}\\n```\n```swift\\nclass Solution {\\n    func buildTree(_ preorder: [Int], _ inorder: [Int]) -> TreeNode? {\\n        return buildTree(preorder[0...], inorder[0...])\\n    }\\n    \\n    func buildTree(_ preorder: ArraySlice<Int>, _ inorder: ArraySlice<Int>) -> TreeNode? {\\n        guard let rootVal = preorder.first else { return nil }\\n        let root = TreeNode(rootVal)\\n\\n        let i = inorder.index(of: rootVal)!\\n        let leftCount = i - inorder.startIndex\\n        let rightCount = inorder.endIndex - i - 1\\n        \\n        root.left = buildTree(\\n            preorder[preorder.startIndex+1..<preorder.startIndex+1+leftCount],\\n            inorder[inorder.startIndex..<inorder.startIndex+leftCount]\\n        )\\n        root.right = buildTree(\\n            preorder[preorder.endIndex-rightCount..<preorder.endIndex],\\n            inorder[inorder.endIndex-rightCount..<inorder.endIndex]\\n        )\\n        return root\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3303497,
                "title": "c-detail-explain-diagram-simple-explanation-of-recursive-approach",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nBasic Recursive approach can also be used for the problem https://leetcode.com/problems/construct-binary-tree-from-inorder-and-postorder-traversal/\\nwith some minor changes.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nLet take the example \\nInput:\\npreorder = [3, 9, 20, 15, 7]\\ninorder = [9, 3, 15, 20, 7]\\n\\nThe recursive approach for constructing binary tree from preorder and inorder traversal is similar to that of constructing binary tree from inorder and postorder traversal, except for the fact that we take the first element of preorder as the root of the tree.\\n\\nThe algorithm works as follows:\\n\\n1. If the inorder array is empty, return null.\\n2. Take the first element from the preorder array and create a new node with it as the root.\\n3. Find the index of the root element in the inorder array.\\n4. Recursively construct the left subtree using the elements in the left side of the inorder array (excluding the root element), and the left portion of the preorder array.\\n5. Recursively construct the right subtree using the elements in the right side of the inorder array (excluding the root element), and the right portion of the preorder array.\\n6. Return the root of the current subtree.\\nExample\\nInput: preorder = [3, 9, 20, 15, 7], inorder = [9, 3, 15, 20, 7]\\n\\nStep 1\\nIf the inorder array is empty, return null.\\n\\nStep 2\\nTake the first element from the preorder array and create a new node with it as the root. In this case, the first element is 3, so we create a new node with 3 as the root.\\n\\n\\n      3\\n     / \\\\\\n    ?   ?\\nStep 3\\nFind the index of the root element (3) in the inorder array. In this case, the index is 1.\\n\\n\\npreorder: [3, 9, 20, 15, 7]\\n           \\u2191\\ninorder:  [9, 3, 15, 20, 7]\\n              \\u2191\\nStep 4\\nRecursively construct the left subtree using the elements in the left side of the inorder array (excluding the root element), and the left portion of the preorder array.\\n\\n\\n      3\\n     / \\\\\\n    9   ?\\n   / \\\\\\n  ?   ?\\n  \\npreorder: [3, 9, 20, 15, 7]\\n           \\u2191\\ninorder:  [9, 3, 15, 20, 7]\\n           \\u2191\\nStep 5\\nRecursively construct the right subtree using the elements in the right side of the inorder array (excluding the root element), and the right portion of the preorder array.\\n\\n\\n      3\\n     / \\\\\\n    9   20\\n   / \\\\   \\\\\\n  ?   ?   15\\n         / \\\\\\n        ?   7\\n        \\npreorder: [3, 9, 20, 15, 7]\\n               \\u2191\\ninorder:  [9, 3, 15, 20, 7]\\n               \\u2191\\nStep 6\\nReturn the root of the current subtree, which is 3.\\n\\n\\n      3\\n     / \\\\\\n    9   20\\n   / \\\\   \\\\\\n  ?   ?   15\\n         / \\\\\\n        ?   7\\n        \\npreorder: [3, 9, 20, 15, 7]\\ninorder:  [9, 3, 15, 20, 7]\\n\\n\\n\\n\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\nTreeNode *tree(vector<int> &preorder , int preLow , int preHigh, vector<int> &inorder , int inLow , int inHigh){\\n    if(preLow>preHigh or inLow > inHigh) return nullptr;\\n\\n    TreeNode *root = new TreeNode(preorder[preLow]);\\n    int inIndex = inLow;\\n\\n    while(inorder[inIndex] != root->val) inIndex++;\\n     int countLeft = inIndex - inLow;\\n\\n\\n      root->left = tree(preorder , preLow + 1 , preLow + countLeft , inorder ,inLow , inIndex - 1 );\\n      root->right = tree(preorder , preLow + countLeft + 1 , preHigh , inorder , inIndex + 1 , inHigh);\\n      return root;\\n}\\n    TreeNode* buildTree(vector<int>& preorder, vector<int>& inorder) {\\n        return tree(preorder , 0 , preorder.size() - 1 , inorder , 0 , inorder.size() -1 );\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Recursion"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\nTreeNode *tree(vector<int> &preorder , int preLow , int preHigh, vector<int> &inorder , int inLow , int inHigh){\\n    if(preLow>preHigh or inLow > inHigh) return nullptr;\\n\\n    TreeNode *root = new TreeNode(preorder[preLow]);\\n    int inIndex = inLow;\\n\\n    while(inorder[inIndex] != root->val) inIndex++;\\n     int countLeft = inIndex - inLow;\\n\\n\\n      root->left = tree(preorder , preLow + 1 , preLow + countLeft , inorder ,inLow , inIndex - 1 );\\n      root->right = tree(preorder , preLow + countLeft + 1 , preHigh , inorder , inIndex + 1 , inHigh);\\n      return root;\\n}\\n    TreeNode* buildTree(vector<int>& preorder, vector<int>& inorder) {\\n        return tree(preorder , 0 , preorder.size() - 1 , inorder , 0 , inorder.size() -1 );\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2523310,
                "title": "java-1ms-beats-100-no-map-clean-recursion",
                "content": "To avoid redundancy, I am attaching the link:\\n[[Java] 1ms, beats 100%, no map, clean recursion](https://leetcode.com/problems/construct-binary-tree-from-inorder-and-postorder-traversal/discuss/2523304/Java-1ms-beats-100-no-map-clean-recursion)",
                "solutionTags": [
                    "Java",
                    "Recursion"
                ],
                "code": "To avoid redundancy, I am attaching the link:\\n[[Java] 1ms, beats 100%, no map, clean recursion](https://leetcode.com/problems/construct-binary-tree-from-inorder-and-postorder-traversal/discuss/2523304/Java-1ms-beats-100-no-map-clean-recursion)",
                "codeTag": "Unknown"
            },
            {
                "id": 1402483,
                "title": "c-map-commented",
                "content": "```\\n// first index node of preorder will be root Node for building a Binary tree\\n// Now search for the first Index we got from preorder inside Inorder and the left of root will be the left part of the root from inorder\\n// and right to root will be the right elements from the inorder\\n\\nclass Solution {\\npublic:\\n    \\n    unordered_map<int, int> mp;\\n    int preIndex = 0; // For iterating preorder array\\n    \\n    // is is the starting index of the inorder, ie is the ending index of the inorder\\n    TreeNode*buildFromPre(vector<int>& preorder, int is, int ie)\\n    {\\n        if(is > ie) // for particular recursive call there are no left or right subtrees\\n             return NULL;\\n        \\n        TreeNode* root = new TreeNode(preorder[preIndex++]); \\n        \\n        if(is == ie)\\n            return root;\\n        \\n        int mid = mp[root->val]; // the mid will be the preorder first index \\n        \\n        root->left =  buildFromPre(preorder, is, mid-1); // recursively call for starting index to mid-1, this will be the left subtree\\n        root->right = buildFromPre(preorder, mid+1, ie); // recursively call for mid+1 to ending index, this will be our right subtree\\n        \\n        return root;\\n    }\\n    \\n    TreeNode* buildTree(vector<int>& preorder, vector<int>& inorder) \\n    {\\n        for(int i = 0; i < inorder.size(); i++)\\n            mp[inorder[i]] = i; // Map inorder elements as key to its indices as values\\n        \\n        return buildFromPre(preorder, 0, inorder.size()-1);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Recursion"
                ],
                "code": "```\\n// first index node of preorder will be root Node for building a Binary tree\\n// Now search for the first Index we got from preorder inside Inorder and the left of root will be the left part of the root from inorder\\n// and right to root will be the right elements from the inorder\\n\\nclass Solution {\\npublic:\\n    \\n    unordered_map<int, int> mp;\\n    int preIndex = 0; // For iterating preorder array\\n    \\n    // is is the starting index of the inorder, ie is the ending index of the inorder\\n    TreeNode*buildFromPre(vector<int>& preorder, int is, int ie)\\n    {\\n        if(is > ie) // for particular recursive call there are no left or right subtrees\\n             return NULL;\\n        \\n        TreeNode* root = new TreeNode(preorder[preIndex++]); \\n        \\n        if(is == ie)\\n            return root;\\n        \\n        int mid = mp[root->val]; // the mid will be the preorder first index \\n        \\n        root->left =  buildFromPre(preorder, is, mid-1); // recursively call for starting index to mid-1, this will be the left subtree\\n        root->right = buildFromPre(preorder, mid+1, ie); // recursively call for mid+1 to ending index, this will be our right subtree\\n        \\n        return root;\\n    }\\n    \\n    TreeNode* buildTree(vector<int>& preorder, vector<int>& inorder) \\n    {\\n        for(int i = 0; i < inorder.size(); i++)\\n            mp[inorder[i]] = i; // Map inorder elements as key to its indices as values\\n        \\n        return buildFromPre(preorder, 0, inorder.size()-1);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 456817,
                "title": "javascript-5-line-solution",
                "content": "```js\\nvar buildTree = function(preorder, inorder) {\\n    if(!preorder.length) return null;\\n    const index = inorder.indexOf(preorder[0]);\\n    const left = buildTree(preorder.slice(1, index + 1), inorder.slice(0, index));\\n    const right = buildTree(preorder.slice(index + 1), inorder.slice(index + 1));\\n    return {val: preorder[0], left, right};\\n};",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```js\\nvar buildTree = function(preorder, inorder) {\\n    if(!preorder.length) return null;\\n    const index = inorder.indexOf(preorder[0]);\\n    const left = buildTree(preorder.slice(1, index + 1), inorder.slice(0, index));\\n    const right = buildTree(preorder.slice(index + 1), inorder.slice(index + 1));\\n    return {val: preorder[0], left, right};\\n};",
                "codeTag": "Unknown"
            },
            {
                "id": 336250,
                "title": "o-n-iterative-python-solution-using-dictionary-and-stack",
                "content": "```\\ndef buildTree(self, preorder, inorder):\\n\\tif len(preorder) == 0:\\n\\t\\treturn None\\n\\troot = TreeNode(0)\\n\\tlo, hi = 0, len(preorder) - 1\\n\\tnodes = [(root, lo, hi)]\\n\\tlut = {inorder[i]: i for i in range(len(inorder))} \\n\\t\\t  # use a look up table to get the index\\n\\t\\t  # of an element in constant time.\\n\\tfor i in range(len(preorder)):\\n\\t\\tcurr, lo, hi = nodes.pop()\\n\\t\\tcurr.val = preorder[i]\\n\\t\\tmid = lut[curr.val]\\n\\t\\tif mid < hi:\\n\\t\\t\\tcurr.right = TreeNode(0)\\n\\t\\t\\tnodes.append((curr.right, mid + 1, hi))\\n\\t\\tif lo < mid:\\n\\t\\t\\tcurr.left = TreeNode(0)\\n\\t\\t\\tnodes.append((curr.left, lo, mid - 1))\\n\\treturn root\\n```",
                "solutionTags": [
                    "Python",
                    "Stack",
                    "Binary Tree",
                    "Iterator"
                ],
                "code": "```\\ndef buildTree(self, preorder, inorder):\\n\\tif len(preorder) == 0:\\n\\t\\treturn None\\n\\troot = TreeNode(0)\\n\\tlo, hi = 0, len(preorder) - 1\\n\\tnodes = [(root, lo, hi)]\\n\\tlut = {inorder[i]: i for i in range(len(inorder))} \\n\\t\\t  # use a look up table to get the index\\n\\t\\t  # of an element in constant time.\\n\\tfor i in range(len(preorder)):\\n\\t\\tcurr, lo, hi = nodes.pop()\\n\\t\\tcurr.val = preorder[i]\\n\\t\\tmid = lut[curr.val]\\n\\t\\tif mid < hi:\\n\\t\\t\\tcurr.right = TreeNode(0)\\n\\t\\t\\tnodes.append((curr.right, mid + 1, hi))\\n\\t\\tif lo < mid:\\n\\t\\t\\tcurr.left = TreeNode(0)\\n\\t\\t\\tnodes.append((curr.left, lo, mid - 1))\\n\\treturn root\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 214622,
                "title": "precise-one-pass-iterative-solution-o-n",
                "content": "```\\nclass Solution(object):\\n    def buildTree(self, preorder, inorder):\\n        \"\"\"\\n        :type preorder: List[int]\\n        :type inorder: List[int]\\n        :rtype: TreeNode\\n        \"\"\"\\n        if not preorder or not inorder:\\n            return None\\n        \\n        j = 0\\n        root = TreeNode(preorder[0])\\n        stack = [root]\\n        \\n        for i in preorder[1:]:\\n            parent = stack[-1]\\n            is_left = True\\n            node = TreeNode(i)\\n            \\n            while stack and inorder[j] == stack[-1].val:\\n                parent = stack.pop()\\n                is_left = False\\n                j += 1\\n                \\n            if is_left:\\n                parent.left = node\\n            else:\\n                parent.right = node\\n            \\n            stack.append(node)\\n            \\n        return root\\n                \\n            \\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def buildTree(self, preorder, inorder):\\n        \"\"\"\\n        :type preorder: List[int]\\n        :type inorder: List[int]\\n        :rtype: TreeNode\\n        \"\"\"\\n        if not preorder or not inorder:\\n            return None\\n        \\n        j = 0\\n        root = TreeNode(preorder[0])\\n        stack = [root]\\n        \\n        for i in preorder[1:]:\\n            parent = stack[-1]\\n            is_left = True\\n            node = TreeNode(i)\\n            \\n            while stack and inorder[j] == stack[-1].val:\\n                parent = stack.pop()\\n                is_left = False\\n                j += 1\\n                \\n            if is_left:\\n                parent.left = node\\n            else:\\n                parent.right = node\\n            \\n            stack.append(node)\\n            \\n        return root\\n                \\n            \\n```",
                "codeTag": "Java"
            },
            {
                "id": 34648,
                "title": "javascript-solution-with-dfs-traversal",
                "content": "    function buildTree(preorder, inorder) {\\n        return build(0, inorder.length - 1);\\n        \\n        function build(l, r) {\\n            if (l > r) {\\n                return null;\\n            }\\n            \\n            var v = preorder.shift();\\n            var i = inorder.indexOf(v);\\n            var root = new TreeNode(v);\\n            \\n            root.left = build(l, i - 1);\\n            root.right = build(i + 1, r);\\n            \\n            return root;\\n        }\\n    }",
                "solutionTags": [],
                "code": "    function buildTree(preorder, inorder) {\\n        return build(0, inorder.length - 1);\\n        \\n        function build(l, r) {\\n            if (l > r) {\\n                return null;\\n            }\\n            \\n            var v = preorder.shift();\\n            var i = inorder.indexOf(v);\\n            var root = new TreeNode(v);\\n            \\n            root.left = build(l, i - 1);\\n            root.right = build(i + 1, r);\\n            \\n            return root;\\n        }\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 34659,
                "title": "c-solution-using-hash",
                "content": "    class Solution {\\n    public:\\n        int preS = 0; // global varible to indicate the preorder array index\\n        TreeNode *buildTree(vector<int> &preorder, vector<int> &inorder) {\\n            int n = inorder.size();\\n    \\n            unordered_map<int, int> in_map;// use hashmap to improve search speed\\n            for (int i = 0; i < n; ++i) {\\n                in_map[inorder[i]] = i;\\n            }\\n    \\n            return helper(0, inorder.size()-1, preorder, in_map);\\n        }\\n    \\n        TreeNode* helper(int inStart, int inEnd,vector<int> &pre, unordered_map<int,int>& in_map) {\\n    \\n            if(inStart > inEnd) // case to return \\n                return NULL;\\n            TreeNode* root = new TreeNode(pre[preS]);\\n            int inMid = in_map[pre[preS]];\\n            preS++; // preoder traveral \\n            root->left = helper(inStart, inMid -1,pre, in_map);\\n            root->right = helper(inMid +1, inEnd,pre, in_map);\\n            return root;\\n        }\\n    };",
                "solutionTags": [
                    "C++"
                ],
                "code": "class Solution {\\n    public:\\n        int preS = 0; // global varible to indicate the preorder array index\\n        TreeNode *buildTree(vector<int> &preorder, vector<int> &inorder) {\\n            int n = inorder.size();\\n    \\n            unordered_map<int, int> in_map;// use hashmap to improve search speed\\n            for (int i = 0; i < n; ++i) {\\n                in_map[inorder[i]] = i;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 3870868,
                "title": "recursion-hashmap-beginner-friendly",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nInorder tells which is left half (left subtree) and right half (right subtree)\\nPreorder tells the order of Node processing\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nPopulate a HashMap with inorder array which stores element and index.\\nCall a function which returns TreeNode.\\nInside the calling function:\\nTraverse the preorder array and find its index in HashMap.\\nCreate a new TreeNode for every element in preorder.\\nRecursively call the function for left half and right half.\\nReturn created TreeNode.\\nBase Condition:\\nIf left index is greater right index we will return null.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n$$O(n)$$\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n$$O(n)$$\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    private int preorderIdx = 0;\\n    private TreeNode construct(int[] preorder, HashMap<Integer,Integer> map, int left, int right){\\n        if(left>right) return null;\\n        int pval = preorder[preorderIdx];\\n        int inorderIdx = map.get(pval);\\n\\n        TreeNode root = new TreeNode(pval);\\n        preorderIdx++;\\n        root.left = construct(preorder, map, left, inorderIdx-1);\\n        root.right = construct(preorder, map, inorderIdx+1, right);\\n        return root;\\n        \\n    }\\n    public TreeNode buildTree(int[] preorder, int[] inorder) {\\n        HashMap<Integer,Integer> map = new HashMap<>();\\n        int len = inorder.length;\\n        for(int i=0;i<len;i++){\\n            map.put(inorder[i],i);\\n        }\\n\\n        return construct(preorder, map, 0, len-1);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Recursion"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    private int preorderIdx = 0;\\n    private TreeNode construct(int[] preorder, HashMap<Integer,Integer> map, int left, int right){\\n        if(left>right) return null;\\n        int pval = preorder[preorderIdx];\\n        int inorderIdx = map.get(pval);\\n\\n        TreeNode root = new TreeNode(pval);\\n        preorderIdx++;\\n        root.left = construct(preorder, map, left, inorderIdx-1);\\n        root.right = construct(preorder, map, inorderIdx+1, right);\\n        return root;\\n        \\n    }\\n    public TreeNode buildTree(int[] preorder, int[] inorder) {\\n        HashMap<Integer,Integer> map = new HashMap<>();\\n        int len = inorder.length;\\n        for(int i=0;i<len;i++){\\n            map.put(inorder[i],i);\\n        }\\n\\n        return construct(preorder, map, 0, len-1);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3797961,
                "title": "easy-explanation-of-the-code-c-recursive-approach",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n***The intuition behind this solution is , as Preorder order store the root node in at starting index and on that basis I can find that element in Inorder . From  this the left part of the element in Inorder is the left subtree and right part is right subtree. Now here we have root node , left subtree and right subtree  , after connecting them we can get our Tree .***\\n\\n**--> If you have any doubt how this thing works , please create a random tree and from that tree write down it\\'s preorder and inorder and run this given below code on that and  you will get same tree as an output.**\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nI  created this explanation in Pointwise manner because it will help U to read and learn in more effective way : )\\n\\n1. The code defines a class `Solution` that contains a function `buildTree` to construct a binary tree from its preorder and inorder traversal sequences.\\n\\n2. The binary tree nodes are represented using the `TreeNode` struct, which has an integer value (`val`) and pointers to its left and right children (`left` and `right`).\\n\\n3. The `buildTree` function takes two input vectors, `preorder` and `inorder`, representing the preorder and inorder traversal sequences of the binary tree, respectively.\\n\\n4. Preorder traversal visits the root node first, followed by the left subtree, and then the right subtree. In contrast, inorder traversal visits the left subtree first, then the root node, and finally the right subtree.\\n\\n5. The `buildTree` function initializes variables `size`, `preIndex`, `start`, and `end` to keep track of the tree size, current index in the `preorder` vector, and the start and end indices of the `inorder` subarray being processed, respectively.\\n\\n6. It also uses an unordered map `mp` to store the indices of elements in the `inorder` vector. This map allows quick lookup of an element\\'s position in the `inorder` sequence.\\n\\n7. The main logic of tree construction is implemented in the `solver` function, which is a recursive helper function.\\n\\n8. The `solver` function takes the `preorder` and `inorder` vectors, along with the previously mentioned variables (`size`, `preIndex`, `start`, `end`, and `mp`), to construct the binary tree.\\n\\n9. In the `solver` function, it checks if the `preIndex` is out of bounds or if the `start` index exceeds the `end` index. If either condition is true, it means the current subtree is empty, and it returns `NULL`.\\n\\n10. Otherwise, it takes the element at `preIndex` from the `preorder` vector, creates a new node with this element, and increments `preIndex`.\\n\\n11. It then finds the position (index) of this element in the `inorder` vector using the precomputed indices stored in the `mp` map.\\n\\n12. Next, it calls `solver` recursively to build the left subtree, passing the appropriate indices for the left subarray of `inorder`.\\n\\n13. Similarly, it constructs the right subtree using recursive calls to `solver` and passing the appropriate indices for the right subarray of `inorder`.\\n\\n14. The `solver` function returns the current node, and this node becomes the left or right child of its parent node in subsequent recursive calls.\\n\\n15. Finally, the `buildTree` function returns the root of the constructed binary tree.\\n\\nIn summary, the code efficiently constructs a binary tree from its preorder and inorder traversal sequences using a recursive approach with the aid of an unordered map for faster element position lookup. The recursive `solver` function handles the tree construction for each subtree.\\n\\n# Complexity\\n- Time Complexity: O(N)\\nThe time complexity of the buildTree function is O(N), where N is the number of nodes in the binary tree. This is because the function processes each node exactly once during the tree construction process. For each node, it performs constant-time operations such as creating a new node, finding its position in the inorder vector using the unordered map, and making recursive calls to build its left and right subtrees.\\n\\n- Space complexity:O(N)\\nThe space complexity of the buildTree function is O(N) as well. During the construction process, the function uses an unordered map mp to store the indices of elements in the inorder vector. Since there can be at most N nodes in the binary tree, the space required for the unordered map is O(N). Additionally, the recursive calls to the solver function also consume space on the call stack. In the worst case scenario, the maximum depth of the call stack can be equal to the height of the binary tree, which is O(N) in the worst case for a skewed binary tree. Therefore, the overall space complexity is O(N).\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n***-----------Please upVote if find this really helpful.-----------***\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n //I commented this code because it causing extra O(N) T.C on every recursive call in solver function to find position it element in inorder so I used unorderd_map to store element with its index to retrive the position in O(1).\\n//    int findPos(vector<int> inorder,int size,int element)\\n//    {\\n//        for(int i=0;i<size;i++)\\n//        {\\n//            if(inorder[i]==element)\\n//            {\\n//                return i;\\n//            }\\n//        }\\n//        return -1;\\n//    }\\n   TreeNode* solver(vector<int> &preorder,vector<int> &inorder,int size,int &preIndex,int start,int end,unordered_map<int,int>  &mp)\\n   {\\n       if(preIndex>=size || start>end)\\n       {\\n           return NULL;\\n       }\\n\\n       int element=preorder[preIndex++];\\n       int pos= mp[element];\\n       TreeNode* root=new TreeNode(element);\\n       root->left= solver(preorder,inorder,size,preIndex,start,pos-1,mp);\\n       root->right=solver(preorder,inorder,size,preIndex,pos+1,end,mp);\\n       return root;\\n       \\n   }\\n    TreeNode* buildTree(vector<int>& preorder, vector<int>& inorder) {\\n        int size=preorder.size();\\n        int preIndex=0;\\n        int start=0;\\n        int end=size-1;\\n        unordered_map<int,int>  mp;\\n        for(int i=0;i<size;i++)\\n        {\\n            mp[inorder[i]]=i;\\n        }\\n\\n        TreeNode* root=solver(preorder,inorder,size,preIndex,start,end,mp);\\n        return root;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Tree",
                    "Binary Tree"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n //I commented this code because it causing extra O(N) T.C on every recursive call in solver function to find position it element in inorder so I used unorderd_map to store element with its index to retrive the position in O(1).\\n//    int findPos(vector<int> inorder,int size,int element)\\n//    {\\n//        for(int i=0;i<size;i++)\\n//        {\\n//            if(inorder[i]==element)\\n//            {\\n//                return i;\\n//            }\\n//        }\\n//        return -1;\\n//    }\\n   TreeNode* solver(vector<int> &preorder,vector<int> &inorder,int size,int &preIndex,int start,int end,unordered_map<int,int>  &mp)\\n   {\\n       if(preIndex>=size || start>end)\\n       {\\n           return NULL;\\n       }\\n\\n       int element=preorder[preIndex++];\\n       int pos= mp[element];\\n       TreeNode* root=new TreeNode(element);\\n       root->left= solver(preorder,inorder,size,preIndex,start,pos-1,mp);\\n       root->right=solver(preorder,inorder,size,preIndex,pos+1,end,mp);\\n       return root;\\n       \\n   }\\n    TreeNode* buildTree(vector<int>& preorder, vector<int>& inorder) {\\n        int size=preorder.size();\\n        int preIndex=0;\\n        int start=0;\\n        int end=size-1;\\n        unordered_map<int,int>  mp;\\n        for(int i=0;i<size;i++)\\n        {\\n            mp[inorder[i]]=i;\\n        }\\n\\n        TreeNode* root=solver(preorder,inorder,size,preIndex,start,end,mp);\\n        return root;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2008761,
                "title": "o-n-time-beats-99-97-memory-speed-0ms-may-2022",
                "content": "```\\n```\\n\\n(Note: This is part of a series of Leetcode solution explanations. If you like this solution or find it useful, ***please upvote*** this post.)\\n***Take care brother, peace, love!***\\n\\n```\\n```\\n\\n```\\n```\\n\\n```\\n```\\n\\nThe best result for the code below is ***0ms / 38.2MB*** (beats 92.04% / 24.00%).\\n* ***Java***\\n```\\npublic TreeNode buildTree(int[] preorder, int[] inorder) {\\n    Map<Integer, Integer> inMap = new HashMap<Integer, Integer>();\\n    \\n    for(int i = 0; i < inorder.length; i++) {\\n        inMap.put(inorder[i], i);\\n    }\\n\\n    TreeNode root = buildTree(preorder, 0, preorder.length - 1, inorder, 0, inorder.length - 1, inMap);\\n    return root;\\n}\\n\\npublic TreeNode buildTree(int[] preorder, int preStart, int preEnd, int[] inorder, int inStart, int inEnd, Map<Integer, Integer> inMap) {\\n    if(preStart > preEnd || inStart > inEnd) return null;\\n    \\n    TreeNode root = new TreeNode(preorder[preStart]);\\n    int inRoot = inMap.get(root.val);\\n    int numsLeft = inRoot - inStart;\\n    \\n    root.left = buildTree(preorder, preStart + 1, preStart + numsLeft, inorder, inStart, inRoot - 1, inMap);\\n    root.right = buildTree(preorder, preStart + numsLeft + 1, preEnd, inorder, inRoot + 1, inEnd, inMap);\\n    \\n    return root;\\n}\\n```\\n\\n```\\n```\\n\\n```\\n```\\n\\nThe best result for the code below is ***0ms / 7.0MB*** (beats 100.00% / 100.00%).\\n* ***C++***\\n```\\nint preInd=0;\\nTreeNode *buildTree(vector<int> &preorder, vector<int> &inorder) {\\n    return createTree(preorder,inorder,0,inorder.size() - 1);\\n}\\nTreeNode* createTree(vector<int>& preorder, vector<int>& inorder,int start, int end){\\n    if(start > end){\\n        return NULL;\\n    }\\n    TreeNode* node=new TreeNode(preorder[preInd++]);\\n    int pos;\\n    for(int i=start;i<=end;i++){\\n        if(inorder[i]==node->val){\\n            pos=i;\\n            break;\\n        }\\n    }\\n    node->left =createTree(preorder, inorder,start,pos-1);\\n    node->right =createTree(preorder, inorder, pos+1,end);\\n    return node;\\n}\\n```\\n\\n```\\n```\\n\\n```\\n```\\n\\n\\nThe best result for the code below is ***26ms / 12.2MB*** (beats 95.42% / 82.32%).\\n* ***Python***\\n```\\ndef buildTree(self, preorder, inorder):\\n    if inorder:\\n        ind = inorder.index(preorder.pop(0))\\n        root = TreeNode(inorder[ind])\\n        root.left = self.buildTree(preorder, inorder[0:ind])\\n        root.right = self.buildTree(preorder, inorder[ind+1:])\\n        return root\\n```\\n\\n```\\n```\\n\\n```\\n```\\n\\nThe best result for the code below is ***51ms / 34.2MB*** (beats 100.00% / 84.12%).\\n* ***JavaScript***\\n```\\nvar buildTree = function(preorder, inorder) {\\n    p = i = 0\\n    build = function(stop) {\\n        if (inorder[i] != stop) {\\n            var root = new TreeNode(preorder[p++])\\n            root.left = build(root.val)\\n            i++\\n            root.right = build(stop)\\n            return root\\n        }\\n        return null\\n    }\\n    return build()\\n};\\n```\\n\\n```\\n```\\n\\n```\\n```\\n\\nThe best result for the code below is ***68ms / 44.2MB*** (beats 100.00% / 45.25%).\\n* ***Kotlin***\\n```\\nfun buildTree(\\n        preorder: IntArray, inorder: IntArray,\\n        preLeft: Int = 0, preRight: Int = preorder.size-1,\\n        inLeft: Int = 0, inRight: Int = inorder.size-1\\n    ): TreeNode? {\\n        if(inRight<inLeft || preRight<preLeft) return null;\\n        \\n        val node = TreeNode(preorder[preLeft])\\n        \\n        var nodeIndexInInOrder = inLeft\\n        while(node.`val` != inorder[nodeIndexInInOrder]) {\\n            nodeIndexInInOrder++\\n        }\\n        \\n        val sizeOfLeftInOrder = nodeIndexInInOrder-inLeft\\n        node.left = buildTree(\\n            preorder,inorder,\\n            preLeft+1,preLeft+sizeOfLeftInOrder,\\n            inLeft,nodeIndexInInOrder-1\\n        )\\n        node.right = buildTree(\\n            preorder,inorder,\\n            preLeft+sizeOfLeftInOrder+1,preRight,\\n            nodeIndexInInOrder+1,inRight\\n        )\\n        \\n        return node\\n    }\\n```\\n\\n```\\n```\\n\\n```\\n```\\n\\nThe best result for the code below is ***12ms / 32.2MB*** (beats 95% / 84%).\\n* ***Swift***\\n```\\nclass Solution {\\n    func buildTree(_ preorder: [Int], _ inorder: [Int]) -> TreeNode? {\\n        guard preorder.count > 0 else { return nil }\\n        \\n        let total\\u0421ount = preorder.count\\n        let root = TreeNode(preorder[0])\\n        var rootIndex = -1\\n        \\n        for (i, val) in inorder.enumerated() {\\n            if val == root.val {\\n                rootIndex = i\\n                break\\n            } \\n        }\\n        \\n        let leftCount = rootIndex\\n        let rightCount = total\\u0421ount - leftCount - 1\\n        \\n        root.left = buildTree(Array(preorder[1..<1 + leftCount]), Array(inorder[0..<leftCount + 1]))\\n        root.right = buildTree(Array(preorder[1 + leftCount..<total\\u0421ount]), Array(inorder[1 + leftCount..<total\\u0421ount]))\\n        return root\\n    }\\n    \\n}\\n```\\n\\n```\\n```\\n\\n```\\n```\\n\\n***\"Open your eyes. Expect us.\" - \\uD835\\uDCD0\\uD835\\uDCF7\\uD835\\uDCF8\\uD835\\uDCF7\\uD835\\uDD02\\uD835\\uDCF6\\uD835\\uDCF8\\uD835\\uDCFE\\uD835\\uDCFC***",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "Python3",
                    "C",
                    "JavaScript",
                    "Swift",
                    "Kotlin",
                    "PHP"
                ],
                "code": "```\\n```\n```\\n```\n```\\n```\n```\\n```\n```\\npublic TreeNode buildTree(int[] preorder, int[] inorder) {\\n    Map<Integer, Integer> inMap = new HashMap<Integer, Integer>();\\n    \\n    for(int i = 0; i < inorder.length; i++) {\\n        inMap.put(inorder[i], i);\\n    }\\n\\n    TreeNode root = buildTree(preorder, 0, preorder.length - 1, inorder, 0, inorder.length - 1, inMap);\\n    return root;\\n}\\n\\npublic TreeNode buildTree(int[] preorder, int preStart, int preEnd, int[] inorder, int inStart, int inEnd, Map<Integer, Integer> inMap) {\\n    if(preStart > preEnd || inStart > inEnd) return null;\\n    \\n    TreeNode root = new TreeNode(preorder[preStart]);\\n    int inRoot = inMap.get(root.val);\\n    int numsLeft = inRoot - inStart;\\n    \\n    root.left = buildTree(preorder, preStart + 1, preStart + numsLeft, inorder, inStart, inRoot - 1, inMap);\\n    root.right = buildTree(preorder, preStart + numsLeft + 1, preEnd, inorder, inRoot + 1, inEnd, inMap);\\n    \\n    return root;\\n}\\n```\n```\\n```\n```\\n```\n```\\nint preInd=0;\\nTreeNode *buildTree(vector<int> &preorder, vector<int> &inorder) {\\n    return createTree(preorder,inorder,0,inorder.size() - 1);\\n}\\nTreeNode* createTree(vector<int>& preorder, vector<int>& inorder,int start, int end){\\n    if(start > end){\\n        return NULL;\\n    }\\n    TreeNode* node=new TreeNode(preorder[preInd++]);\\n    int pos;\\n    for(int i=start;i<=end;i++){\\n        if(inorder[i]==node->val){\\n            pos=i;\\n            break;\\n        }\\n    }\\n    node->left =createTree(preorder, inorder,start,pos-1);\\n    node->right =createTree(preorder, inorder, pos+1,end);\\n    return node;\\n}\\n```\n```\\n```\n```\\n```\n```\\ndef buildTree(self, preorder, inorder):\\n    if inorder:\\n        ind = inorder.index(preorder.pop(0))\\n        root = TreeNode(inorder[ind])\\n        root.left = self.buildTree(preorder, inorder[0:ind])\\n        root.right = self.buildTree(preorder, inorder[ind+1:])\\n        return root\\n```\n```\\n```\n```\\n```\n```\\nvar buildTree = function(preorder, inorder) {\\n    p = i = 0\\n    build = function(stop) {\\n        if (inorder[i] != stop) {\\n            var root = new TreeNode(preorder[p++])\\n            root.left = build(root.val)\\n            i++\\n            root.right = build(stop)\\n            return root\\n        }\\n        return null\\n    }\\n    return build()\\n};\\n```\n```\\n```\n```\\n```\n```\\nfun buildTree(\\n        preorder: IntArray, inorder: IntArray,\\n        preLeft: Int = 0, preRight: Int = preorder.size-1,\\n        inLeft: Int = 0, inRight: Int = inorder.size-1\\n    ): TreeNode? {\\n        if(inRight<inLeft || preRight<preLeft) return null;\\n        \\n        val node = TreeNode(preorder[preLeft])\\n        \\n        var nodeIndexInInOrder = inLeft\\n        while(node.`val` != inorder[nodeIndexInInOrder]) {\\n            nodeIndexInInOrder++\\n        }\\n        \\n        val sizeOfLeftInOrder = nodeIndexInInOrder-inLeft\\n        node.left = buildTree(\\n            preorder,inorder,\\n            preLeft+1,preLeft+sizeOfLeftInOrder,\\n            inLeft,nodeIndexInInOrder-1\\n        )\\n        node.right = buildTree(\\n            preorder,inorder,\\n            preLeft+sizeOfLeftInOrder+1,preRight,\\n            nodeIndexInInOrder+1,inRight\\n        )\\n        \\n        return node\\n    }\\n```\n```\\n```\n```\\n```\n```\\nclass Solution {\\n    func buildTree(_ preorder: [Int], _ inorder: [Int]) -> TreeNode? {\\n        guard preorder.count > 0 else { return nil }\\n        \\n        let total\\u0421ount = preorder.count\\n        let root = TreeNode(preorder[0])\\n        var rootIndex = -1\\n        \\n        for (i, val) in inorder.enumerated() {\\n            if val == root.val {\\n                rootIndex = i\\n                break\\n            } \\n        }\\n        \\n        let leftCount = rootIndex\\n        let rightCount = total\\u0421ount - leftCount - 1\\n        \\n        root.left = buildTree(Array(preorder[1..<1 + leftCount]), Array(inorder[0..<leftCount + 1]))\\n        root.right = buildTree(Array(preorder[1 + leftCount..<total\\u0421ount]), Array(inorder[1 + leftCount..<total\\u0421ount]))\\n        return root\\n    }\\n    \\n}\\n```\n```\\n```\n```\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1109233,
                "title": "morris-traversal-o-n-time-o-1-extra-space-iterative-solution",
                "content": "I didn\\'t find any iterative Morris Traversal solution for this problem in the discussion section, So I am sharing my Java solution which has O(n) time complexity and uses a O(1) extra space. Feel free to discuss anything about the approach in the comments section. Upvote if you find it useful as it would help others to find this post quickly.\\n#### **Morris Traversal Algorithm**\\nFor understanding morris traversal algorithm and about threaded binary tree, you can go through [**this leetcode article**](https://leetcode.com/problems/binary-tree-inorder-traversal/discuss/148939/CPP-Morris-Traversal), where the author has explained it nicely with figures. \\n#### **Time and Space Complexity**\\nThe time complexity is O(n), n is length of preorder array, because each node in the binary tree is visited at most two times. First time as a parent of current node, second time is when we are trying to find the correct parent whose right child is curr (current node). Auxiliary space used in this solution is also O(1) as we are not using stack or recursion or any other data structure.\\n#### **Commented Code**\\n```\\npublic TreeNode buildTreeMorris(int[] preorder, int[] inorder){\\n    var parent = new TreeNode(preorder[0]);\\n    var root = parent;\\n    for (int i = 1, j=0; i < preorder.length; i++) {\\n        var curr = new TreeNode(preorder[i]);\\n        //checking if we should continue adding nodes to the left of parent node\\n        if(parent.val != inorder[j]){\\n            parent.left = curr;\\n            // creating the thread to inorder successor so that we can return to it when we\\n            // are done creating its left subtree\\n            curr.right = parent;\\n        }else{\\n            j++;\\n\\n            //finding the correct parent whose right child is curr (current node)\\n            while(parent.right != null && parent.right.val == inorder[j]){\\n                var temp = parent;\\n                parent = parent.right;\\n                //removing the thread which is no longer reguired\\n                temp.right = null;\\n                j++;\\n            }\\n            //creating the correct thread\\n            curr.right = parent.right;\\n            //breaking the previous thread and placing the right child in place of it \\n            parent.right = curr;\\n        }\\n        parent = curr;\\n    }\\n    //removing the remaining threads\\n    while (parent.right != null) {\\n        var temp = parent.right;\\n        parent.right = null;\\n        parent = temp;\\n    }\\n    return root;\\n}\\n```\\nFor writing the code, I took help from following helpful discussion section posts:\\n1. [Link 1](https://leetcode.com/problems/construct-binary-search-tree-from-preorder-traversal/discuss/589051/Morris\\'-algorithm-(O(n)-time-O(n)-space))\\n2. [Link 2](https://leetcode.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal/discuss/34555/The-iterative-solution-is-easier-than-you-think!/32916/)",
                "solutionTags": [
                    "Java",
                    "Iterator"
                ],
                "code": "```\\npublic TreeNode buildTreeMorris(int[] preorder, int[] inorder){\\n    var parent = new TreeNode(preorder[0]);\\n    var root = parent;\\n    for (int i = 1, j=0; i < preorder.length; i++) {\\n        var curr = new TreeNode(preorder[i]);\\n        //checking if we should continue adding nodes to the left of parent node\\n        if(parent.val != inorder[j]){\\n            parent.left = curr;\\n            // creating the thread to inorder successor so that we can return to it when we\\n            // are done creating its left subtree\\n            curr.right = parent;\\n        }else{\\n            j++;\\n\\n            //finding the correct parent whose right child is curr (current node)\\n            while(parent.right != null && parent.right.val == inorder[j]){\\n                var temp = parent;\\n                parent = parent.right;\\n                //removing the thread which is no longer reguired\\n                temp.right = null;\\n                j++;\\n            }\\n            //creating the correct thread\\n            curr.right = parent.right;\\n            //breaking the previous thread and placing the right child in place of it \\n            parent.right = curr;\\n        }\\n        parent = curr;\\n    }\\n    //removing the remaining threads\\n    while (parent.right != null) {\\n        var temp = parent.right;\\n        parent.right = null;\\n        parent = temp;\\n    }\\n    return root;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 689647,
                "title": "python3-stack-o-n",
                "content": "Similar to solution in [106. Construct Binary Tree from Inorder and Postorder Traversal](https://leetcode.com/problems/construct-binary-tree-from-inorder-and-postorder-traversal/discuss/691195/Python3-recursive-solution)\\n```\\nclass Solution:\\n    def buildTree(self, preorder: List[int], inorder: List[int]) -> TreeNode:\\n        loc = {x : i for i, x in enumerate(inorder)}\\n        root = None\\n        stack = []\\n        for x in preorder: \\n            if not root: root = node = TreeNode(x)\\n            elif loc[x] < loc[node.val]: \\n                stack.append(node)\\n                node.left = node = TreeNode(x)\\n            else: \\n                while stack and loc[stack[-1].val] < loc[x]: node = stack.pop() # backtracking\\n                node.right = node = TreeNode(x)\\n        return root\\n```\\n\\n```\\nclass Solution:\\n    def buildTree(self, preorder: List[int], inorder: List[int]) -> TreeNode:\\n        loc = {x: i for i, x in enumerate(inorder)}\\n        pre = iter(preorder)\\n        \\n        def fn(lo, hi): \\n            \"\"\"Return node constructed from inorder[lo:hi].\"\"\"\\n            if lo == hi: return None\\n            k = loc[next(pre)]\\n            return TreeNode(inorder[k], fn(lo, k), fn(k+1, hi))\\n        \\n        return fn(0, len(inorder))\\n```\\n\\nEdited on 6/8/2021\\n```\\nclass Solution:\\n    def buildTree(self, preorder: List[int], inorder: List[int]) -> TreeNode:\\n        loc = {x: i for i, x in enumerate(inorder)}\\n        k = 0 \\n        \\n        def fn(lo, hi): \\n            \"\"\"Return BST constructed from inorder[lo:hi].\"\"\"\\n            nonlocal k \\n            if lo < hi: \\n                val = preorder[k]\\n                mid = loc[val]\\n                k += 1\\n                return TreeNode(val, fn(lo, mid), fn(mid+1, hi))\\n        \\n        return fn(0, len(inorder))\\n```\\n\\n**References**\\n[105. Construct Binary Tree from Preorder and Inorder Traversal](https://leetcode.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal/discuss/689647/Python3-stack-O(N))\\n[106. Construct Binary Tree from Inorder and Postorder Traversal](https://leetcode.com/problems/construct-binary-tree-from-inorder-and-postorder-traversal/discuss/691195/Python3-stack-O(N))",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def buildTree(self, preorder: List[int], inorder: List[int]) -> TreeNode:\\n        loc = {x : i for i, x in enumerate(inorder)}\\n        root = None\\n        stack = []\\n        for x in preorder: \\n            if not root: root = node = TreeNode(x)\\n            elif loc[x] < loc[node.val]: \\n                stack.append(node)\\n                node.left = node = TreeNode(x)\\n            else: \\n                while stack and loc[stack[-1].val] < loc[x]: node = stack.pop() # backtracking\\n                node.right = node = TreeNode(x)\\n        return root\\n```\n```\\nclass Solution:\\n    def buildTree(self, preorder: List[int], inorder: List[int]) -> TreeNode:\\n        loc = {x: i for i, x in enumerate(inorder)}\\n        pre = iter(preorder)\\n        \\n        def fn(lo, hi): \\n            \"\"\"Return node constructed from inorder[lo:hi].\"\"\"\\n            if lo == hi: return None\\n            k = loc[next(pre)]\\n            return TreeNode(inorder[k], fn(lo, k), fn(k+1, hi))\\n        \\n        return fn(0, len(inorder))\\n```\n```\\nclass Solution:\\n    def buildTree(self, preorder: List[int], inorder: List[int]) -> TreeNode:\\n        loc = {x: i for i, x in enumerate(inorder)}\\n        k = 0 \\n        \\n        def fn(lo, hi): \\n            \"\"\"Return BST constructed from inorder[lo:hi].\"\"\"\\n            nonlocal k \\n            if lo < hi: \\n                val = preorder[k]\\n                mid = loc[val]\\n                k += 1\\n                return TreeNode(val, fn(lo, mid), fn(mid+1, hi))\\n        \\n        return fn(0, len(inorder))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 139694,
                "title": "python-recursive-solution-6-lines",
                "content": "```\\nclass Solution(object):\\n    def buildTree(self, preorder, inorder):\\n        \"\"\"\\n        :type preorder: List[int]\\n        :type inorder: List[int]\\n        :rtype: Tree\\n        \"\"\"\\n        if len(preorder) == 0:return None\\n        root_node = TreeNode(preorder[0])\\n        j = inorder.index(preorder[0])\\n        root_node.left  = self.buildTree(preorder[1:j+1],inorder[0:j])\\n        root_node.right = self.buildTree(preorder[j+1:],inorder[j+1:])\\n        return root_node\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def buildTree(self, preorder, inorder):\\n        \"\"\"\\n        :type preorder: List[int]\\n        :type inorder: List[int]\\n        :rtype: Tree\\n        \"\"\"\\n        if len(preorder) == 0:return None\\n        root_node = TreeNode(preorder[0])\\n        j = inorder.index(preorder[0])\\n        root_node.left  = self.buildTree(preorder[1:j+1],inorder[0:j])\\n        root_node.right = self.buildTree(preorder[j+1:],inorder[j+1:])\\n        return root_node\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3394674,
                "title": "java-easy-solution-with-comments",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n$$O(n^2)$$\\n\\n- Space complexity:\\n$$O(n)$$\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    int idx = 0;\\n    public TreeNode buildTree(int[] preorder, int[] inorder) {\\n        //Approach: Using recursion\\n        //call our helper function\\n        return helper(preorder, inorder, 0, preorder.length-1);\\n\\n    }\\n    public TreeNode helper(int[] preorder,int[] inorder,int left,int right){\\n        //base case\\n        if(idx==preorder.length || left>right){\\n            return null;\\n        }\\n\\n        //obeously the 0\\'th index of preorder array is our root\\n        TreeNode root = new TreeNode(preorder[idx]);\\n\\n        //iterate the inorder array\\n        for(int i=left; i<=right;i++){\\n            //compare the iindex values between the two arrays\\n            if(preorder[idx]==inorder[i]){\\n                //increment the idx \\n                idx++;\\n\\n                //call recursion for left and right subtree \\n                root.left = helper(preorder, inorder, left, i-1);\\n                root.right = helper(preorder, inorder, i+1, right);\\n                \\n                break;\\n            }\\n        }\\n        return root;\\n\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    int idx = 0;\\n    public TreeNode buildTree(int[] preorder, int[] inorder) {\\n        //Approach: Using recursion\\n        //call our helper function\\n        return helper(preorder, inorder, 0, preorder.length-1);\\n\\n    }\\n    public TreeNode helper(int[] preorder,int[] inorder,int left,int right){\\n        //base case\\n        if(idx==preorder.length || left>right){\\n            return null;\\n        }\\n\\n        //obeously the 0\\'th index of preorder array is our root\\n        TreeNode root = new TreeNode(preorder[idx]);\\n\\n        //iterate the inorder array\\n        for(int i=left; i<=right;i++){\\n            //compare the iindex values between the two arrays\\n            if(preorder[idx]==inorder[i]){\\n                //increment the idx \\n                idx++;\\n\\n                //call recursion for left and right subtree \\n                root.left = helper(preorder, inorder, left, i-1);\\n                root.right = helper(preorder, inorder, i+1, right);\\n                \\n                break;\\n            }\\n        }\\n        return root;\\n\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3303059,
                "title": "divide-and-conquer-hash-table-easiest-beginner-friendly-sol",
                "content": "**NOTE - PLEASE READ INTUITION AND APPROACH FIRST THEN SEE THE CODE. YOU WILL DEFINITELY UNDERSTAND THE CODE LINE BY LINE AFTER SEEING THE APPROACH.**\\n\\n# Intuition of this Problem :\\nThe problem is to construct a binary tree from inorder and preorder traversals of the tree. The inorder traversal gives the order of nodes in the left subtree, root, and right subtree, while the preorder traversal gives the order of nodes in the root, left subtree, right subtree.\\n\\n**The intuition behind the algorithm is to start by identifying the root of the binary tree from the first element of the preorder traversal. Then, we can use the root to divide the inorder traversal into left and right subtrees. We can then recursively apply the same process to the left and right subtrees to construct the entire binary tree.**\\n\\nTo do this efficiently, we can use a hash map to store the indices of elements in the inorder traversal. This allows us to quickly find the position of the root in the inorder traversal and divide the traversal into left and right subtrees.\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach for this Problem :\\n1. Create an index variable \\'preorderIndex\\' to keep track of the current root node in preorder traversal.\\n2. Create an unordered map \\'inorderIndexUmp\\' to store the indices of all elements in the inorder traversal.\\n3. Define a recursive helper function \\'buildTreeHelper\\' that takes the preorder traversal vector, and the range (left and right indices) of the subtree being constructed.\\n4. If the left index is greater than the right index, return null pointer to represent an empty subtree.\\n5. Get the value of the root node from the current position of \\'preorderIndex\\' and increment it.\\n6. Create a new TreeNode with the root value and set its left and right children to null.\\n7. Find the index of the root node in the inorder traversal using the \\'inorderIndexUmp\\' map.\\n8. Recursively construct the left subtree by calling the \\'buildTreeHelper\\' function on the left range (left to inorder pivot index - 1).\\n9. Recursively construct the right subtree by calling the \\'buildTreeHelper\\' function on the right range (inorder pivot index + 1 to right).\\n10. Return the constructed tree.\\n11. In the main function \\'buildTree\\', initialize the \\'preorderIndex\\'\\nto zero and create the \\'inorderIndexUmp\\' map.\\n1. Call the \\'buildTreeHelper\\' function on the entire range of the preorder traversal vector.\\n2. Return the constructed binary tree.\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Code :\\n```C++ []\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    int preorderIndex;\\n    unordered_map<int, int> inorderIndexUmp;\\n\\n    TreeNode* buildTreeHelper(vector<int>& preorder, int left, int right) {\\n        if (left > right)\\n            return nullptr;\\n        int rootValue = preorder[preorderIndex++];\\n        TreeNode* root = new TreeNode(rootValue);\\n        int inorderPivotIndex = inorderIndexUmp[rootValue];\\n        //think about it..why I am choosing root -> left first then root -> right\\n        root -> left = buildTreeHelper(preorder, left, inorderPivotIndex - 1);\\n        root -> right = buildTreeHelper(preorder, inorderPivotIndex + 1, right);\\n        return root;\\n    }\\n\\n    TreeNode* buildTree(vector<int>& preorder, vector<int>& inorder) {\\n        preorderIndex = 0;\\n        for (int i = 0; i < inorder.size(); i++) {\\n            inorderIndexUmp[inorder[i]] = i;\\n        }\\n        return buildTreeHelper(preorder, 0, preorder.size() - 1);\\n    }\\n};\\n```\\n```Java []\\nclass Solution {\\n    int preorderIndex;\\n    Map<Integer, Integer> inorderIndexUmp;\\n\\n    public TreeNode buildTreeHelper(int[] preorder, int left, int right) {\\n        if (left > right)\\n            return null;\\n        int rootValue = preorder[preorderIndex++];\\n        TreeNode root = new TreeNode(rootValue);\\n        int inorderPivotIndex = inorderIndexUmp.get(rootValue);\\n        root.left = buildTreeHelper(preorder, left, inorderPivotIndex - 1);\\n        root.right = buildTreeHelper(preorder, inorderPivotIndex + 1, right);\\n        return root;\\n    }\\n\\n    public TreeNode buildTree(int[] preorder, int[] inorder) {\\n        preorderIndex = 0;\\n        inorderIndexUmp = new HashMap<>();\\n        for (int i = 0; i < inorder.length; i++) {\\n            inorderIndexUmp.put(inorder[i], i);\\n        }\\n        return buildTreeHelper(preorder, 0, preorder.length - 1);\\n    }\\n}\\n\\n```\\n```Python []\\nclass Solution:\\n    def buildTreeHelper(self, preorder: List[int], left: int, right: int) -> TreeNode:\\n        if left > right:\\n            return None\\n        rootValue = preorder[self.preorderIndex]\\n        self.preorderIndex += 1\\n        root = TreeNode(rootValue)\\n        inorderPivotIndex = self.inorderIndexUmp[rootValue]\\n        root.left = self.buildTreeHelper(preorder, left, inorderPivotIndex - 1)\\n        root.right = self.buildTreeHelper(preorder, inorderPivotIndex + 1, right)\\n        return root\\n    \\n    def buildTree(self, preorder: List[int], inorder: List[int]) -> TreeNode:\\n        self.preorderIndex = 0\\n        self.inorderIndexUmp = {val:idx for idx, val in enumerate(inorder)}\\n        return self.buildTreeHelper(preorder, 0, len(preorder) - 1)\\n\\n```\\n\\n# Time Complexity and Space Complexity:\\n- Time complexity : **O(n)**, The buildTreeHelper() function is called for each node in the tree exactly once, and the time complexity of each call is O(1). Therefore, the overall time complexity of the algorithm is O(n), where n is the number of nodes in the tree.\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity : **O(n)**, where n is the number of nodes in the tree. This is because we are creating a new TreeNode object for each node in the tree, and we are also using an unordered_map to store the indices of the nodes in the inorder traversal. Additionally, the recursive calls to buildTreeHelper() create a call stack of size O(n) in the worst case, where n is the number of nodes in the tree.\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n**YOU CAN ALSO TRY BELOW PROBLEM WHICH IS SIMILAR TO THIS PROBLEM :**\\n106. Construct Binary Tree from Inorder and Postorder Traversal\\n**SOLUTION :**\\nhttps://leetcode.com/problems/construct-binary-tree-from-inorder-and-postorder-traversal/solutions/3302713/day-75-divide-and-conquer-hash-table-easiest-beginner-friendly-sol/",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3",
                    "Hash Table",
                    "Divide and Conquer"
                ],
                "code": "```C++ []\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    int preorderIndex;\\n    unordered_map<int, int> inorderIndexUmp;\\n\\n    TreeNode* buildTreeHelper(vector<int>& preorder, int left, int right) {\\n        if (left > right)\\n            return nullptr;\\n        int rootValue = preorder[preorderIndex++];\\n        TreeNode* root = new TreeNode(rootValue);\\n        int inorderPivotIndex = inorderIndexUmp[rootValue];\\n        //think about it..why I am choosing root -> left first then root -> right\\n        root -> left = buildTreeHelper(preorder, left, inorderPivotIndex - 1);\\n        root -> right = buildTreeHelper(preorder, inorderPivotIndex + 1, right);\\n        return root;\\n    }\\n\\n    TreeNode* buildTree(vector<int>& preorder, vector<int>& inorder) {\\n        preorderIndex = 0;\\n        for (int i = 0; i < inorder.size(); i++) {\\n            inorderIndexUmp[inorder[i]] = i;\\n        }\\n        return buildTreeHelper(preorder, 0, preorder.size() - 1);\\n    }\\n};\\n```\n```Java []\\nclass Solution {\\n    int preorderIndex;\\n    Map<Integer, Integer> inorderIndexUmp;\\n\\n    public TreeNode buildTreeHelper(int[] preorder, int left, int right) {\\n        if (left > right)\\n            return null;\\n        int rootValue = preorder[preorderIndex++];\\n        TreeNode root = new TreeNode(rootValue);\\n        int inorderPivotIndex = inorderIndexUmp.get(rootValue);\\n        root.left = buildTreeHelper(preorder, left, inorderPivotIndex - 1);\\n        root.right = buildTreeHelper(preorder, inorderPivotIndex + 1, right);\\n        return root;\\n    }\\n\\n    public TreeNode buildTree(int[] preorder, int[] inorder) {\\n        preorderIndex = 0;\\n        inorderIndexUmp = new HashMap<>();\\n        for (int i = 0; i < inorder.length; i++) {\\n            inorderIndexUmp.put(inorder[i], i);\\n        }\\n        return buildTreeHelper(preorder, 0, preorder.length - 1);\\n    }\\n}\\n\\n```\n```Python []\\nclass Solution:\\n    def buildTreeHelper(self, preorder: List[int], left: int, right: int) -> TreeNode:\\n        if left > right:\\n            return None\\n        rootValue = preorder[self.preorderIndex]\\n        self.preorderIndex += 1\\n        root = TreeNode(rootValue)\\n        inorderPivotIndex = self.inorderIndexUmp[rootValue]\\n        root.left = self.buildTreeHelper(preorder, left, inorderPivotIndex - 1)\\n        root.right = self.buildTreeHelper(preorder, inorderPivotIndex + 1, right)\\n        return root\\n    \\n    def buildTree(self, preorder: List[int], inorder: List[int]) -> TreeNode:\\n        self.preorderIndex = 0\\n        self.inorderIndexUmp = {val:idx for idx, val in enumerate(inorder)}\\n        return self.buildTreeHelper(preorder, 0, len(preorder) - 1)\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3192136,
                "title": "c-easy-and-udnerstanding-solution",
                "content": "# Approach\\nWe will use a fact which the first element of `preorder` array is root node. Always, elements will be left subtree of the root node which are settled till this root node in `inorder` array.\\n\\n# Complexity\\n- Time complexity: O(n)\\n\\n- Space complexity: O(1)\\n\\n# Code\\n```\\npublic class Solution {\\n    public TreeNode BuildTree(int[] preorder, int[] inorder) {\\n        if(preorder is null || !preorder.Any() ||\\n           inorder is null || !inorder.Any()) return null;\\n\\n        TreeNode root = new TreeNode(preorder[0]);\\n        int middle = Array.IndexOf(inorder, preorder[0]);\\n        root.left = BuildTree(preorder[1..(middle+1)], inorder[..middle]);\\n        root.right = BuildTree(preorder[(middle+1)..], inorder[(middle+1)..]);\\n        \\n        return root;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution {\\n    public TreeNode BuildTree(int[] preorder, int[] inorder) {\\n        if(preorder is null || !preorder.Any() ||\\n           inorder is null || !inorder.Any()) return null;\\n\\n        TreeNode root = new TreeNode(preorder[0]);\\n        int middle = Array.IndexOf(inorder, preorder[0]);\\n        root.left = BuildTree(preorder[1..(middle+1)], inorder[..middle]);\\n        root.right = BuildTree(preorder[(middle+1)..], inorder[(middle+1)..]);\\n        \\n        return root;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2996719,
                "title": "efficient-solution-with-detailed-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n-  Recap:\\n   - What is Preorder traversal ?\\n    In Preorder traveral, first the parent node is processed / printed and then the process is repeated recursively for left subtree and then right subtree\\n   - What is Inorder traversal ?\\n    Here, first left subtree is processed then parent node then right subtree.\\n\\nBy this definition, if the preorder of any tree is as follows: [5, 2, 6, 8, 9] then we know by sure that 5 is the root node but we have no idea about other elements. Now lets suppose for this tree we have the following inorder = [2, 5, 8, 6, 9].\\n\\nHere,\\n1. We know 5 is the root of the tree, from preorder.\\n2. To know about its left and right subtree we will locate 5 in inorder.\\n3. All elements to the left of 5 in inorder form the left subtree.\\n4. All elements to the right of 5 in inorder form the right subtree.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. We will start with the preorder list since we know that the first node of preorder list forms the root of the tree.\\n2. Then, we will locate that node in inorder list. Once found, now we know that left subarray forms the left subtree and right subarray forms the right subtree.\\n3. Now, we need to take care of a few cases:\\na. Case #1: \\nIf there is no element to the left of a node then node does not have left subtree. Same is true for right subtree.\\nb. Case #2:\\nIf there is only one element to the left of a node then the left node is the root node. Same is true for right subtree.\\nc. Case #3:\\nIf there are many nodes to the left of a node then we process the nodes as discussed in above steps.\\n4. The next node in preorder list will be the root of the left subtree, if exists(determined from the inorder list using above cases) to track this we will use the \"current\" index in preorder list.\\n\\nTo implement this algorithm we will use two pointers, \"start\" and \"end\" which will point to the search space in inorder list and we will maintain a \"current\" index for preorder list.\\n\\n# Complexity\\n- Time complexity: $$O(n)$$\\n\\n- Space complexity: $$O(n)$$\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n\\n    // Pointer to track preorder list.\\n    public static int currentIndx = 0;\\n\\n    // Helps to find the location of node in inorder list in O(1)\\n    HashMap<Integer, Integer> cache;\\n\\n    // Function as described in pseudocode above\\n    public TreeNode constructTree(int[] preorder, int[] inorder, int start, int end) {\\n\\n        if(currentIndx >= preorder.length) return null;\\n\\n        // Creating the node from preorder\\n        int headNodeValue = preorder[currentIndx++];\\n        TreeNode head = new TreeNode(headNodeValue);\\n\\n        int targetIndx = cache.get(headNodeValue);\\n\\n        // Finding Left Subtree from inorder\\n        if(targetIndx - start > 0) {\\n            head.left = constructTree(preorder, inorder, start, targetIndx - 1);\\n        }\\n\\n        // Finding Right Subtree from inorder\\n        if(end - targetIndx > 0) {\\n            head.right = constructTree(preorder, inorder, targetIndx + 1, end);\\n        }\\n\\n        return head;\\n    }\\n\\n    public TreeNode buildTree(int[] preorder, int[] inorder) {\\n        currentIndx = 0;\\n        cache = new HashMap<Integer, Integer>();\\n        for(int i = 0; i < inorder.length; i++) {\\n            cache.put(inorder[i], i);\\n        }\\n        return constructTree(preorder, inorder, 0, preorder.length - 1);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n\\n    // Pointer to track preorder list.\\n    public static int currentIndx = 0;\\n\\n    // Helps to find the location of node in inorder list in O(1)\\n    HashMap<Integer, Integer> cache;\\n\\n    // Function as described in pseudocode above\\n    public TreeNode constructTree(int[] preorder, int[] inorder, int start, int end) {\\n\\n        if(currentIndx >= preorder.length) return null;\\n\\n        // Creating the node from preorder\\n        int headNodeValue = preorder[currentIndx++];\\n        TreeNode head = new TreeNode(headNodeValue);\\n\\n        int targetIndx = cache.get(headNodeValue);\\n\\n        // Finding Left Subtree from inorder\\n        if(targetIndx - start > 0) {\\n            head.left = constructTree(preorder, inorder, start, targetIndx - 1);\\n        }\\n\\n        // Finding Right Subtree from inorder\\n        if(end - targetIndx > 0) {\\n            head.right = constructTree(preorder, inorder, targetIndx + 1, end);\\n        }\\n\\n        return head;\\n    }\\n\\n    public TreeNode buildTree(int[] preorder, int[] inorder) {\\n        currentIndx = 0;\\n        cache = new HashMap<Integer, Integer>();\\n        for(int i = 0; i < inorder.length; i++) {\\n            cache.put(inorder[i], i);\\n        }\\n        return constructTree(preorder, inorder, 0, preorder.length - 1);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2280579,
                "title": "divide-and-conquer-fully-explained-with-image-better-than-99",
                "content": "Upvote if helpful <3\\n\\n<hr />\\n\\n# First thoughts\\nYou may think why do we need both the preorder and inorder arrays? \\n\\nBecause if we simply have only 1 of them, we don\\'t know whether the elements are left or right children. Image a preorder of: [1,2,3]\\n\\nIs 2 on the right side or left side? we don\\'t know. This is the reason for both the formats.\\n\\n# Intuition\\nWhat do we know about **inorder traversal?** \\n\\nAll the elements are traversed left to right. This property will help us with building the final tree\\n\\nWhat do we know about **preorder traversal?**\\n\\nWe first scan the \"root\" and then go to it\\'s children (left and then right). With this we know what element is the root of the current level.\\n\\nLet\\'s combine both.\\n\\nExample: \\npreorder: `[1,2,4,5,3,6,7]`\\ninorder: `[4,2,5,1,6,3,7]`\\n\\nBy looking at the first element in our preorder array, we know that 1 is the root (as discussed above).\\n\\nThe next element in the preorder array is `2` but is it on the left or right?\\n\\nRemeber that the inorder traversal is scanned left to right? so let\\'s see if 2 occurs before 1 in that array. \\n\\nIt does. It means it\\'s on the left side. Moreover, all elements that come before `1` in the inorder array are on the left side of 1, and the rest are on the right side.\\n\\nSo we can do the same logic for both sides. This leads us toward implementing a `divide and conquer` solution, since we have a repeating sub problem.\\n\\nLeft side will start with preorder element 2 (the next index after 1)\\n\\nRight side will start with preorder element of 3 is `3` - we know that the left side of 1, which is [4,2,5] is of length 3, so we skip that length from the current index.\\n\\n\\n# Visual\\nThis is a drawing of the discussed algorithm, to help you visualize the logic.\\n\\n![image](https://assets.leetcode.com/users/images/b67633af-99e0-4730-b9da-891ad1e8ddef_1657786786.6985857.png)\\n\\n\\n# Code\\n\\n```\\nclass Solution:\\n    def buildTree(self, preorder: List[int], inorder: List[int]) -> Optional[TreeNode]:\\n        self.preorder = preorder\\n        self.inorder = inorder\\n        self.inorder_value_to_index = {}\\n        \\n        for i, v in enumerate(inorder):\\n            self.inorder_value_to_index[v] = i\\n        \\n        return self.divide_and_conquer(0, 0, len(preorder) - 1)\\n    \\n    def divide_and_conquer(self, preorder_i:int, left:int, right:int):\\n        if left > right: return None\\n        \\n        root = TreeNode(self.preorder[preorder_i])\\n        inorder_index = self.inorder_value_to_index[self.preorder[preorder_i]]\\n        \\n        root.left = self.divide_and_conquer(preorder_i + 1, left, inorder_index - 1)\\n        \\n        # take (inorder_index-left) + 1 interval after preorder index. We skip all left side elements\\n        next_right_preorder_i = preorder_i + (inorder_index - left) + 1\\n        root.right = self.divide_and_conquer(next_right_preorder_i, inorder_index + 1, right)\\n        \\n        return root\\n```\\n\\n\\n# Complexity analysis\\n## Time - O(n)\\nWe traverse the whole tree once, even with the recursion, we only check each element once.\\n\\nAlso building the hashmap is O(n)\\n\\nN + N = O(n)\\n\\n## Space - O(n)\\nHashmap takes O(n) space.\\n\\nThe recursion will take O(n) in the worst case, and O(log(n)) if the tree is balanced.\\n\\nN + logn = O(n)\\n",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def buildTree(self, preorder: List[int], inorder: List[int]) -> Optional[TreeNode]:\\n        self.preorder = preorder\\n        self.inorder = inorder\\n        self.inorder_value_to_index = {}\\n        \\n        for i, v in enumerate(inorder):\\n            self.inorder_value_to_index[v] = i\\n        \\n        return self.divide_and_conquer(0, 0, len(preorder) - 1)\\n    \\n    def divide_and_conquer(self, preorder_i:int, left:int, right:int):\\n        if left > right: return None\\n        \\n        root = TreeNode(self.preorder[preorder_i])\\n        inorder_index = self.inorder_value_to_index[self.preorder[preorder_i]]\\n        \\n        root.left = self.divide_and_conquer(preorder_i + 1, left, inorder_index - 1)\\n        \\n        # take (inorder_index-left) + 1 interval after preorder index. We skip all left side elements\\n        next_right_preorder_i = preorder_i + (inorder_index - left) + 1\\n        root.right = self.divide_and_conquer(next_right_preorder_i, inorder_index + 1, right)\\n        \\n        return root\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2179676,
                "title": "c-simple-recursive-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int preind=0;\\n    TreeNode* buildTree(vector<int>& preorder, vector<int>& inorder) {\\n        return createTree(preorder,inorder,0,inorder.size()-1);\\n    }\\n    \\n    TreeNode* createTree(vector<int>& preorder,vector<int>& inorder,int start,int end)\\n    {\\n        if(start>end) return NULL;\\n        TreeNode* node=new TreeNode(preorder[preind++]);\\n        int pos;\\n        for(int i=start;i<=end;i++)\\n        {\\n            if(node->val==inorder[i])\\n            {\\n                pos=i;\\n                break;\\n            }\\n        }\\n        node->left=createTree(preorder,inorder,start,pos-1);\\n        node->right=createTree(preorder,inorder,pos+1,end);\\n        return node;\\n    }\\n};\\n```\\n\\nanother same type of problem: https://leetcode.com/problems/construct-binary-tree-from-inorder-and-postorder-traversal/\\n\\n<b>Please Upvote this solution if you like it.</b>\\n<b> if you have any doubt, ask me. I will happy to help you</b>\\n<b>happy coding. Good bye</b>",
                "solutionTags": [
                    "C++",
                    "C",
                    "Recursion",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int preind=0;\\n    TreeNode* buildTree(vector<int>& preorder, vector<int>& inorder) {\\n        return createTree(preorder,inorder,0,inorder.size()-1);\\n    }\\n    \\n    TreeNode* createTree(vector<int>& preorder,vector<int>& inorder,int start,int end)\\n    {\\n        if(start>end) return NULL;\\n        TreeNode* node=new TreeNode(preorder[preind++]);\\n        int pos;\\n        for(int i=start;i<=end;i++)\\n        {\\n            if(node->val==inorder[i])\\n            {\\n                pos=i;\\n                break;\\n            }\\n        }\\n        node->left=createTree(preorder,inorder,start,pos-1);\\n        node->right=createTree(preorder,inorder,pos+1,end);\\n        return node;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 921338,
                "title": "java-easy-to-understand-clean-and-concise",
                "content": "Follow intuition - \\n\\nPreorder first node will be root. \\nOrder property says anything left of root in array will be left subtree of root and right of root in array will be right subtree.\\nSo, fetch that, find the index of root.\\nand then recursively calculate your subarrays and place the root\\n```\\nclass Solution {\\n    public TreeNode buildTree(int[] preorder, int[] inorder) {\\n        if(preorder.length == 0) return null; //Our terminating condition\\n        TreeNode root = new TreeNode(preorder[0]);\\n        int index = -1;\\n        for(int i = 0; i < inorder.length; i++){// find the root location in inorder\\n           if(inorder[i]==root.val){\\n               index=i;\\n               break;\\n           }    \\n        }\\n\\t\\t//all the values to the left are part of left subtree\\n        int[] leftPre = Arrays.copyOfRange(preorder, 1, index + 1);  // we need this to process our root everytime we segregate and make a recursive call\\n        int[] rightPre = Arrays.copyOfRange(preorder, index + 1, preorder.length); \\n        int[] leftIn = Arrays.copyOfRange(inorder, 0, index + 1); //find the left subtree\\n        int[] rightIn = Arrays.copyOfRange(inorder, index + 1, inorder.length);//find the left subtree\\n        root.left=buildTree(leftPre, leftIn); //build the left subtree\\n        root.right=buildTree(rightPre,rightIn); // build the right subtree\\n        \\n        return root;\\n    }\\n}\\n```\\n\\n\\nThe following solution also follows the same intuition above but just does it in better time.\\n\\n```\\nclass Solution {\\n    HashMap<Integer, Integer> map ;\\n    int index;\\n    public TreeNode buildTree(int[] preorder, int[] inorder) {\\n        if(preorder.length != inorder.length){\\n            return null;\\n        }\\n        map = new HashMap<>();\\n        for(int i = 0; i < inorder.length; i++){\\n            map.put(inorder[i], i);\\n        }\\n        index = 0;\\n        return helper(0, inorder.length - 1, preorder, inorder);\\n    }\\n    private TreeNode helper(int start, int end, int[] pre, int[] in){\\n        if(start > end){\\n            return null;\\n        }\\n        int rootval = pre[index];\\n        TreeNode root = new TreeNode(rootval);\\n        index++;\\n        root.left = helper(start, map.get(root.val) - 1, pre, in );\\n        root.right = helper(map.get(root.val) + 1, end, pre, in );\\n        return root;\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Java",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n    public TreeNode buildTree(int[] preorder, int[] inorder) {\\n        if(preorder.length == 0) return null; //Our terminating condition\\n        TreeNode root = new TreeNode(preorder[0]);\\n        int index = -1;\\n        for(int i = 0; i < inorder.length; i++){// find the root location in inorder\\n           if(inorder[i]==root.val){\\n               index=i;\\n               break;\\n           }    \\n        }\\n\\t\\t//all the values to the left are part of left subtree\\n        int[] leftPre = Arrays.copyOfRange(preorder, 1, index + 1);  // we need this to process our root everytime we segregate and make a recursive call\\n        int[] rightPre = Arrays.copyOfRange(preorder, index + 1, preorder.length); \\n        int[] leftIn = Arrays.copyOfRange(inorder, 0, index + 1); //find the left subtree\\n        int[] rightIn = Arrays.copyOfRange(inorder, index + 1, inorder.length);//find the left subtree\\n        root.left=buildTree(leftPre, leftIn); //build the left subtree\\n        root.right=buildTree(rightPre,rightIn); // build the right subtree\\n        \\n        return root;\\n    }\\n}\\n```\n```\\nclass Solution {\\n    HashMap<Integer, Integer> map ;\\n    int index;\\n    public TreeNode buildTree(int[] preorder, int[] inorder) {\\n        if(preorder.length != inorder.length){\\n            return null;\\n        }\\n        map = new HashMap<>();\\n        for(int i = 0; i < inorder.length; i++){\\n            map.put(inorder[i], i);\\n        }\\n        index = 0;\\n        return helper(0, inorder.length - 1, preorder, inorder);\\n    }\\n    private TreeNode helper(int start, int end, int[] pre, int[] in){\\n        if(start > end){\\n            return null;\\n        }\\n        int rootval = pre[index];\\n        TreeNode root = new TreeNode(rootval);\\n        index++;\\n        root.left = helper(start, map.get(root.val) - 1, pre, in );\\n        root.right = helper(map.get(root.val) + 1, end, pre, in );\\n        return root;\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 663622,
                "title": "faster-than-99-easy-to-understand-simple-2-solutions-recursive-python",
                "content": "```\\n    def recursive(self, preorder, inorder):\\n        def rec(inorder, preorder):\\n            if len(inorder) and len(preorder):\\n                root_val = preorder.pop()\\n                node = TreeNode(root_val)\\n                root_index = -1\\n                for i,v in enumerate(inorder):\\n                    if v == root_val:\\n                        root_index = i\\n                        break\\n                node.left = rec(inorder[:root_index], preorder)\\n                node.right = rec(inorder[root_index + 1:], preorder)\\n                return node\\n        return rec(inorder, preorder[::-1])\\n    \\n    def recursive_optimized(self, preorder, inorder):\\n        pos = {v:i for i,v in enumerate(inorder)}\\n        preorder = preorder[::-1]\\n        def rec(left, right):\\n            if left <= right and len(preorder):\\n                root_val = preorder.pop()\\n                node = TreeNode(root_val)\\n                node.left = rec(left, pos[root_val] - 1)\\n                node.right = rec(pos[root_val] + 1, right)\\n                return node\\n        return rec(0, len(preorder) - 1)\\n                \\n  \\n```\\n\\n**I hope that you\\'ve found the solution useful.**\\n*In that case, please do upvote and encourage me to on my quest to document all leetcode problems\\uD83D\\uDE03*\\nPS: Search for **mrmagician** tag in the discussion, if I have solved it, You will find it there\\uD83D\\uDE38",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Recursion"
                ],
                "code": "```\\n    def recursive(self, preorder, inorder):\\n        def rec(inorder, preorder):\\n            if len(inorder) and len(preorder):\\n                root_val = preorder.pop()\\n                node = TreeNode(root_val)\\n                root_index = -1\\n                for i,v in enumerate(inorder):\\n                    if v == root_val:\\n                        root_index = i\\n                        break\\n                node.left = rec(inorder[:root_index], preorder)\\n                node.right = rec(inorder[root_index + 1:], preorder)\\n                return node\\n        return rec(inorder, preorder[::-1])\\n    \\n    def recursive_optimized(self, preorder, inorder):\\n        pos = {v:i for i,v in enumerate(inorder)}\\n        preorder = preorder[::-1]\\n        def rec(left, right):\\n            if left <= right and len(preorder):\\n                root_val = preorder.pop()\\n                node = TreeNode(root_val)\\n                node.left = rec(left, pos[root_val] - 1)\\n                node.right = rec(pos[root_val] + 1, right)\\n                return node\\n        return rec(0, len(preorder) - 1)\\n                \\n  \\n```",
                "codeTag": "Python3"
            },
            {
                "id": 646568,
                "title": "python-o-n-by-definition-85-w-comment",
                "content": "\\n\\n---\\nPython O(n) by definition\\n\\n---\\n\\n\\n**Implementation** by definition\\n\\n```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\n\\nclass Solution:\\n    def buildTree(self, preorder: List[int], inorder: List[int]) -> TreeNode:\\n        \\n        val_index_dict = { num:idx for idx, num in enumerate(inorder) }\\n        \\n        self.root_index = 0\\n        \\n        def helper( left, right):\\n            \\n            if left > right:\\n                # Base case:\\n                # return None as empty Node\\n                return None\\n            \\n            else:\\n                \\n                # Recall:\\n                # definition of preorder traversal: Center, Left, Right\\n                # rebuild with direction of definition\\n                root = TreeNode( preorder[self.root_index] )\\n                \\n                # update root index\\n                self.root_index += 1\\n                \\n                mid = val_index_dict[ root.val ]\\n                \\n                root.left = helper( left, mid-1 )\\n                root.right = helper( mid+1, right)\\n                \\n                return root\\n        # ----------------------------------------------------\\n        return helper( left = 0 , right = len(inorder)-1 )\\n```\\n\\n---\\n\\nReference:\\n\\n[1] [Leetcode training session: Binary Tree Traversal](https://leetcode.com/explore/learn/card/data-structure-tree/134/traverse-a-tree/992/)",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\n\\nclass Solution:\\n    def buildTree(self, preorder: List[int], inorder: List[int]) -> TreeNode:\\n        \\n        val_index_dict = { num:idx for idx, num in enumerate(inorder) }\\n        \\n        self.root_index = 0\\n        \\n        def helper( left, right):\\n            \\n            if left > right:\\n                # Base case:\\n                # return None as empty Node\\n                return None\\n            \\n            else:\\n                \\n                # Recall:\\n                # definition of preorder traversal: Center, Left, Right\\n                # rebuild with direction of definition\\n                root = TreeNode( preorder[self.root_index] )\\n                \\n                # update root index\\n                self.root_index += 1\\n                \\n                mid = val_index_dict[ root.val ]\\n                \\n                root.left = helper( left, mid-1 )\\n                root.right = helper( mid+1, right)\\n                \\n                return root\\n        # ----------------------------------------------------\\n        return helper( left = 0 , right = len(inorder)-1 )\\n```",
                "codeTag": "Java"
            },
            {
                "id": 169603,
                "title": "javascript-shortest-solution",
                "content": "```\\nvar buildTree = function(preorder, inorder) {\\n    function helper(p, i){\\n        if(!p.length || !i.length) return null;\\n        let val = p[0];\\n        let pos = i.indexOf(val);//the root position, and also the number of left nodes\\n        let root = new TreeNode(val);\\n        root.left = helper(p.slice(1, 1 + pos), i.slice(0, pos));\\n        root.right = helper(p.slice(1 + pos), i.slice(1 + pos));\\n        return root;\\n    }\\n    return helper(preorder, inorder);\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nvar buildTree = function(preorder, inorder) {\\n    function helper(p, i){\\n        if(!p.length || !i.length) return null;\\n        let val = p[0];\\n        let pos = i.indexOf(val);//the root position, and also the number of left nodes\\n        let root = new TreeNode(val);\\n        root.left = helper(p.slice(1, 1 + pos), i.slice(0, pos));\\n        root.right = helper(p.slice(1 + pos), i.slice(1 + pos));\\n        return root;\\n    }\\n    return helper(preorder, inorder);\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 139414,
                "title": "why-there-isn-t-a-question-about-construct-binary-tree-from-preorder-and-postorder-traversal",
                "content": "I just did this series of questions: 105: construct Binary Tree from Preorder and Inorder Traversal and 106: construct Binary Tree from Inorder and Postorder Traversal. Then I thought I can go on do a question like \"construct Binary Tree from Preorder and Postorder Traversal\", but there isn\\'t this question.\\n\\nIs this because that\\'s trivial or some other reasons?\\n\\nI think recusion is a natural way for me to solve this kind of questions. As long as there is no duplicated value in the Tree, we can construct the Binary Tree from any two Traversals from Preorder, Inorder and Posterorder Traversal. \\n\\nHere is a summary:\\n\\nThe procedure goes like:\\n* find the root value and build the root\\n* split the two traversal array into two, each for the left subtree and right subtree\\n* recursion: if we can built the left subtree and right subtree, then we built the whole tree\\n\\nTake the test case as an example:\\n```\\npreorder=[3,9,20,15,7]\\ninorder=[9,3,15,20,7]\\npostorder=[9,15,7,20,3]\\n```\\n1.  preorder and inorder: First find the root value, that is ```preorder[0]=3``` and build the root: ```root=TreeNode(preorder[0])```. Then find the index of  ```root.val```  in ``` inorder``` : ``` i=inorder.index(root.val)=1```. Then the inorder array for the left subtree is ```lin=inorder[:i]=[9]``` so the right part will just be the rest  ```rin=inorder[i+1:]=[15,20,7]```.  Once we split the inorder array, we can split the preorder by the length match:  ```lpre=preorder[1:i+1]=[9]``` and ```rpre=preorder[i+1:]=[20,15,7]```\\n2.  inorder and postorder: The root value is ```posterorder[-1]=3```, build the root: ```root=TreeNode(postorder[-1])``` . Then to split the inorder array, we do the same thing as above: ```i=inorder.index(root.val), lin=inorder[:i],rin=inorder[i+1:]``` Then the splited postorder array by length match is ```lpost=postorder[:i]=[9], rpost=postorder[i:-1]=[15,7,20]```\\n3.  preorder and postorder: The root value is ```preorder[0]=postorder[-1]=3```, build the root: ```root=TreeNode(postorder[-1])```. The left child value is ```preorder[1]=9``` and we find the index of that value in postorder array: ```i=postorder.index(9)=0```. Then due to the property of postorder traversal, the postorder array for the left subtree is just ```lpost=postorder[:i+1]=[9]``` Then ```rpost=postorder[i+1:-1]=[15,7,20]```. Then the preorder array can be splited by length match : ```lpre=preorder[1:i+2]=[9], rpre=[i+2:]=[20,15,7]```\\n\\nThe complete Python3 code:\\n```\\ndef buildTree1(preorder, inorder):\\n    \"\"\"\\n    :type preorder: List[int]\\n    :type inorder: List[int]\\n    :rtype: TreeNode\\n    \"\"\"\\n    if not preorder:\\n        return None\\n    root=TreeNode(preorder[0])\\n    i=inorder.index(root.val)\\n    lin=inorder[:i]\\n    rin=inorder[i+1:]\\n    lpre=preorder[1:i+1]\\n    rpre=preorder[i+1:]\\n    root.left=buildTree1(lpre,lin)\\n    root.right=buildTree1(rpre,rin)\\n    return root\\n\\t\\t\\ndef buildTree2(inorder, postorder):\\n    \"\"\"\\n    :type inorder: List[int]\\n    :type postorder: List[int]\\n    :rtype: TreeNode\\n    \"\"\"\\n    if not postorder:\\n        return None\\n    root=TreeNode(postorder[-1])\\n    i=inorder.index(root.val)\\n    lin=inorder[:i]\\n    rin=inorder[i+1:]\\n    lpost=postorder[:i]\\n    rpost=postorder[i:-1]\\n    root.left=buildTree2(lin,lpost)\\n    root.right=buildTree2(rin,rpost)\\n    return root\\n\\t\\t\\ndef buildTree3(preorder, postorder):\\n    \"\"\"\\n    :type inorder: List[int]\\n    :type postorder: List[int]\\n    :rtype: TreeNode\\n    \"\"\"\\n    if not postorder:\\n        return None\\n    root=TreeNode(postorder[-1])\\n    if len(postorder)==1:\\n        return root\\n    lval=preorder[1]\\n    i=postorder.index(lval)\\n    lpre=preorder[1:i+2]\\n    rpre=preorder[i+2:]\\n    lpost=postorder[:i+1]\\n    rpost=postorder[i+1:-1]\\n    root.left=buildTree3(lpre,lpost)\\n    root.right=buildTree3(rpre,rpost)\\n    return root\\n```\\n",
                "solutionTags": [],
                "code": "```\\npreorder=[3,9,20,15,7]\\ninorder=[9,3,15,20,7]\\npostorder=[9,15,7,20,3]\\n```\n```preorder[0]=3```\n```root=TreeNode(preorder[0])```\n```root.val```\n``` inorder```\n``` i=inorder.index(root.val)=1```\n```lin=inorder[:i]=[9]```\n```rin=inorder[i+1:]=[15,20,7]```\n```lpre=preorder[1:i+1]=[9]```\n```rpre=preorder[i+1:]=[20,15,7]```\n```posterorder[-1]=3```\n```root=TreeNode(postorder[-1])```\n```i=inorder.index(root.val), lin=inorder[:i],rin=inorder[i+1:]```\n```lpost=postorder[:i]=[9], rpost=postorder[i:-1]=[15,7,20]```\n```preorder[0]=postorder[-1]=3```\n```root=TreeNode(postorder[-1])```\n```preorder[1]=9```\n```i=postorder.index(9)=0```\n```lpost=postorder[:i+1]=[9]```\n```rpost=postorder[i+1:-1]=[15,7,20]```\n```lpre=preorder[1:i+2]=[9], rpre=[i+2:]=[20,15,7]```\n```\\ndef buildTree1(preorder, inorder):\\n    \"\"\"\\n    :type preorder: List[int]\\n    :type inorder: List[int]\\n    :rtype: TreeNode\\n    \"\"\"\\n    if not preorder:\\n        return None\\n    root=TreeNode(preorder[0])\\n    i=inorder.index(root.val)\\n    lin=inorder[:i]\\n    rin=inorder[i+1:]\\n    lpre=preorder[1:i+1]\\n    rpre=preorder[i+1:]\\n    root.left=buildTree1(lpre,lin)\\n    root.right=buildTree1(rpre,rin)\\n    return root\\n\\t\\t\\ndef buildTree2(inorder, postorder):\\n    \"\"\"\\n    :type inorder: List[int]\\n    :type postorder: List[int]\\n    :rtype: TreeNode\\n    \"\"\"\\n    if not postorder:\\n        return None\\n    root=TreeNode(postorder[-1])\\n    i=inorder.index(root.val)\\n    lin=inorder[:i]\\n    rin=inorder[i+1:]\\n    lpost=postorder[:i]\\n    rpost=postorder[i:-1]\\n    root.left=buildTree2(lin,lpost)\\n    root.right=buildTree2(rin,rpost)\\n    return root\\n\\t\\t\\ndef buildTree3(preorder, postorder):\\n    \"\"\"\\n    :type inorder: List[int]\\n    :type postorder: List[int]\\n    :rtype: TreeNode\\n    \"\"\"\\n    if not postorder:\\n        return None\\n    root=TreeNode(postorder[-1])\\n    if len(postorder)==1:\\n        return root\\n    lval=preorder[1]\\n    i=postorder.index(lval)\\n    lpre=preorder[1:i+2]\\n    rpre=preorder[i+2:]\\n    lpost=postorder[:i+1]\\n    rpost=postorder[i+1:-1]\\n    root.left=buildTree3(lpre,lpost)\\n    root.right=buildTree3(rpre,rpost)\\n    return root\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 34664,
                "title": "compact-python-solution-beats-88",
                "content": "    class Solution(object):\\n        def buildTree(self, preorder, inorder):\\n            self.preorder = preorder\\n            self.itable = {v:i for i, v in enumerate(inorder)}\\n            return self.Build(0, 0, len(preorder))\\n    \\n        def Build(self, pbegin, ibegin, size):\\n            if not size: return None\\n            imid = self.itable[self.preorder[pbegin]]\\n            lsize = imid - ibegin\\n            rsize = size - lsize - 1\\n            tree = TreeNode(self.preorder[pbegin])\\n            tree.left = self.Build(pbegin + 1, ibegin, lsize)\\n            tree.right = self.Build(pbegin + 1 + lsize, imid + 1, rsize)\\n            return tree",
                "solutionTags": [],
                "code": "class Solution(object):\\n        def buildTree(self, preorder, inorder):\\n            self.preorder = preorder\\n            self.itable = {v:i for i, v in enumerate(inorder)}",
                "codeTag": "Java"
            },
            {
                "id": 34651,
                "title": "neat-java-solution-pretty-easy-to-read",
                "content": "\\n\\n    public class Solution {\\n        public TreeNode buildTree(int[] preorder, int[] inorder) {\\n            if (preorder.length == 0) {\\n            \\treturn null;\\n            }\\n            return buildTreeHelper(preorder, inorder, 0, preorder.length-1, 0, preorder.length-1);\\n        }\\n        \\n        public TreeNode buildTreeHelper(int[] preorder, int[] inorder, int ps, int pe, int is, int ie) {\\n            if (ps > pe || is > ie) {\\n            \\treturn null;\\n            }\\n            TreeNode root = new TreeNode(preorder[ps]);\\n            if (ps == pe) {\\n            \\treturn root;\\n            }\\n            int index = 0;\\n            for (int i=is; i<=ie; i++) {\\n                if (root.val == inorder[i]) {\\n                    index = i;\\n                    break;\\n                }\\n            }\\n            root.left = buildTreeHelper(preorder, inorder, ps+1, ps+index-is, is, index-1);\\n            root.right = buildTreeHelper(preorder, inorder, ps+index-is+1, pe, index+1, ie);\\n            return root;\\n        }\\n    }",
                "solutionTags": [],
                "code": "class Solution {\\n        public TreeNode buildTree(int[] preorder, int[] inorder) {\\n            if (preorder.length == 0) {\\n            \\treturn null;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 3921063,
                "title": "python-easy-solution-100-recursion-beats-96",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:. $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:. $$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def buildTree(self, preorder: List[int], inorder: List[int]) -> Optional[TreeNode]:\\n        inorder_map={val:idx for idx, val in enumerate(inorder)}\\n        preorder_idx=0\\n\\n        def treeHelper(left, right):\\n            nonlocal preorder_idx\\n            if left>right:\\n                return None\\n\\n            node_val = preorder[preorder_idx]\\n            root=TreeNode(node_val)\\n            preorder_idx+=1\\n\\n            inorder_index=inorder_map[node_val]\\n\\n            root.left = treeHelper(left, inorder_index-1 )\\n            root.right = treeHelper(inorder_index+1, right)\\n\\n            return root\\n\\n        return treeHelper(0, len(inorder)-1)\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def buildTree(self, preorder: List[int], inorder: List[int]) -> Optional[TreeNode]:\\n        inorder_map={val:idx for idx, val in enumerate(inorder)}\\n        preorder_idx=0\\n\\n        def treeHelper(left, right):\\n            nonlocal preorder_idx\\n            if left>right:\\n                return None\\n\\n            node_val = preorder[preorder_idx]\\n            root=TreeNode(node_val)\\n            preorder_idx+=1\\n\\n            inorder_index=inorder_map[node_val]\\n\\n            root.left = treeHelper(left, inorder_index-1 )\\n            root.right = treeHelper(inorder_index+1, right)\\n\\n            return root\\n\\n        return treeHelper(0, len(inorder)-1)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3351855,
                "title": "o-n-c-very-easy-to-read-and-optimized-solution-upvote-if-you-like",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\n//FILLING MAP FOR INORDER\\nvoid fillmap(map<int ,int>&mp , vector<int>&inorder ,int n){\\n    for(int i = 0 ; i < n ; i ++){\\n        mp[inorder[i]] = i;\\n    }\\n}\\n\\nTreeNode* solve(vector<int>&pre , vector<int>&in , int &pi , int is ,int  ie , int n , map<int ,int>&mp)\\n{\\n        if(pi >= n || (is > ie)){\\n            return NULL;\\n        }\\n\\n        int element = pre[pi++];\\n\\n        TreeNode* root = new TreeNode(element);\\n\\n        int position = mp[element];\\n\\n        root->left = solve(pre, in , pi , is , position - 1 , n , mp);\\n        \\n        root->right = solve(pre, in , pi , position + 1  , ie, n , mp);\\n\\n        return root;\\n}\\n\\npublic:\\n    TreeNode* buildTree(vector<int>& preorder, vector<int>& inorder) {\\n        TreeNode* ans;\\n        int n = preorder.size();\\n        map<int , int>mp;\\n        fillmap(mp , inorder , n);\\n        int preIndex = 0;\\n\\n        return solve(preorder , inorder , preIndex , 0 , n - 1 , n , mp);\\n\\n    }\\n};\\n\\n\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\n//FILLING MAP FOR INORDER\\nvoid fillmap(map<int ,int>&mp , vector<int>&inorder ,int n){\\n    for(int i = 0 ; i < n ; i ++){\\n        mp[inorder[i]] = i;\\n    }\\n}\\n\\nTreeNode* solve(vector<int>&pre , vector<int>&in , int &pi , int is ,int  ie , int n , map<int ,int>&mp)\\n{\\n        if(pi >= n || (is > ie)){\\n            return NULL;\\n        }\\n\\n        int element = pre[pi++];\\n\\n        TreeNode* root = new TreeNode(element);\\n\\n        int position = mp[element];\\n\\n        root->left = solve(pre, in , pi , is , position - 1 , n , mp);\\n        \\n        root->right = solve(pre, in , pi , position + 1  , ie, n , mp);\\n\\n        return root;\\n}\\n\\npublic:\\n    TreeNode* buildTree(vector<int>& preorder, vector<int>& inorder) {\\n        TreeNode* ans;\\n        int n = preorder.size();\\n        map<int , int>mp;\\n        fillmap(mp , inorder , n);\\n        int preIndex = 0;\\n\\n        return solve(preorder , inorder , preIndex , 0 , n - 1 , n , mp);\\n\\n    }\\n};\\n\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3306784,
                "title": "short-sweet-easy-to-understand-c-recursion",
                "content": "```\\nclass Solution {\\npublic:\\n    int k = 0;\\n    TreeNode* solve(vector<int> &a,vector<int> &b,int s,int e){\\n        if(s>e){\\n            return NULL;\\n        }\\n        TreeNode* node = new TreeNode(a[k++]);\\n        int i;\\n        for(i = s; i<=e;i++){\\n            if(node->val == b[i]){\\n                break;\\n            }\\n        }\\n        node->left = solve(a,b,s,i-1);\\n        node->right = solve(a,b,i+1,e);\\n        return node;\\n    }\\n    TreeNode* buildTree(vector<int>& preorder, vector<int>& inorder) {\\n        k = 0;\\n        return solve(preorder,inorder,0,inorder.size()-1);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Tree",
                    "Recursion",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int k = 0;\\n    TreeNode* solve(vector<int> &a,vector<int> &b,int s,int e){\\n        if(s>e){\\n            return NULL;\\n        }\\n        TreeNode* node = new TreeNode(a[k++]);\\n        int i;\\n        for(i = s; i<=e;i++){\\n            if(node->val == b[i]){\\n                break;\\n            }\\n        }\\n        node->left = solve(a,b,s,i-1);\\n        node->right = solve(a,b,i+1,e);\\n        return node;\\n    }\\n    TreeNode* buildTree(vector<int>& preorder, vector<int>& inorder) {\\n        k = 0;\\n        return solve(preorder,inorder,0,inorder.size()-1);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3211550,
                "title": "simple-c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe left tree and right tree can also be constructed via trimed `preorder` and `inorder`.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nThe key point is how to trim?\\n1. `preorder`: root > left > right\\n    root: `preorder[0]`\\n    left: `preorder[1:i]`\\n    right: `preorder[i+1:end]`\\n2. `inorder`: left > root > right \\nsuppose the root located in `i` index in `inorder`\\n    left: `inorder[0, i-1]`\\n    right: `inorder[i+1, end]`\\n\\nWe use the combination of `Array.Skip()` and `Array.Take()` to get the subarray.\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n$$O(n)$$\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n$$O(n)$$\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     public int val;\\n *     public TreeNode left;\\n *     public TreeNode right;\\n *     public TreeNode(int val=0, TreeNode left=null, TreeNode right=null) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\npublic class Solution {\\n    public TreeNode BuildTree(int[] preorder, int[] inorder) {\\n        if(inorder.Length == 0)\\n            return null;\\n        int val = preorder[0];\\n        preorder = preorder.Skip(1).ToArray();\\n        TreeNode node = new TreeNode(val);\\n        int idx = Array.IndexOf(inorder, val);\\n        node.left = BuildTree(preorder.Take(idx).ToArray(), inorder.Take(idx).ToArray());\\n        node.right = BuildTree(preorder.Skip(idx).ToArray(), inorder.Skip(idx+1).ToArray());\\n        return node;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     public int val;\\n *     public TreeNode left;\\n *     public TreeNode right;\\n *     public TreeNode(int val=0, TreeNode left=null, TreeNode right=null) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\npublic class Solution {\\n    public TreeNode BuildTree(int[] preorder, int[] inorder) {\\n        if(inorder.Length == 0)\\n            return null;\\n        int val = preorder[0];\\n        preorder = preorder.Skip(1).ToArray();\\n        TreeNode node = new TreeNode(val);\\n        int idx = Array.IndexOf(inorder, val);\\n        node.left = BuildTree(preorder.Take(idx).ToArray(), inorder.Take(idx).ToArray());\\n        node.right = BuildTree(preorder.Skip(idx).ToArray(), inorder.Skip(idx+1).ToArray());\\n        return node;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2279149,
                "title": "daily-leetcoding-challenge-july-day-14",
                "content": "This problem is the Daily LeetCoding Challenge for July, Day 14.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Recursion\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>",
                "solutionTags": [],
                "code": "  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />",
                "codeTag": "Unknown"
            },
            {
                "id": 2098536,
                "title": "python3-o-n-time-o-1-space-recursive-solution",
                "content": "```\\nclass Solution:\\n    def buildTree(self, preorder, inorder):\\n        inorderIndexDict = {ch : i for i, ch in enumerate(inorder)}\\n        self.rootIndex = 0\\n        \\n        def solve(l, r):\\n            if l > r: return None\\n            \\n            root = TreeNode(preorder[self.rootIndex])\\n            self.rootIndex += 1\\n            \\n            i = inorderIndexDict[root.val]\\n            \\n            root.left = solve(l, i-1)\\n            root.right = solve(i+1, r)\\n            \\n            return root\\n        \\n        return solve(0, len(inorder)-1)\\n    \\n    \\n# Time: O(N)\\n# Space: O(1)\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Recursion",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution:\\n    def buildTree(self, preorder, inorder):\\n        inorderIndexDict = {ch : i for i, ch in enumerate(inorder)}\\n        self.rootIndex = 0\\n        \\n        def solve(l, r):\\n            if l > r: return None\\n            \\n            root = TreeNode(preorder[self.rootIndex])\\n            self.rootIndex += 1\\n            \\n            i = inorderIndexDict[root.val]\\n            \\n            root.left = solve(l, i-1)\\n            root.right = solve(i+1, r)\\n            \\n            return root\\n        \\n        return solve(0, len(inorder)-1)\\n    \\n    \\n# Time: O(N)\\n# Space: O(1)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1399846,
                "title": "c-recursion-without-hashmap",
                "content": "**Do upvote to encourage me!**\\n```\\nclass Solution {\\npublic:\\n    TreeNode* build(vector<int>& pre, vector<int>& in, int preIndex,  int is, int ie){\\n        if(preIndex>=pre.size() || is>ie)\\n            return NULL;\\n        TreeNode * root = new TreeNode(pre[preIndex]);\\n        int inIndex=0;\\n        for(int i=is;i<=ie;i++){\\n            if(in[i]==root->val){\\n                inIndex=i;\\n                break;\\n            }\\n        }\\n        root->left=build(pre, in, preIndex + 1, is, inIndex-1);\\n        root->right=build(pre, in, preIndex + inIndex - is + 1, inIndex+1, ie);\\n        return root;\\n    }\\n    TreeNode* buildTree(vector<int>& pre, vector<int>& in) {\\n        return build(pre, in, 0, 0, in.size()-1);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    TreeNode* build(vector<int>& pre, vector<int>& in, int preIndex,  int is, int ie){\\n        if(preIndex>=pre.size() || is>ie)\\n            return NULL;\\n        TreeNode * root = new TreeNode(pre[preIndex]);\\n        int inIndex=0;\\n        for(int i=is;i<=ie;i++){\\n            if(in[i]==root->val){\\n                inIndex=i;\\n                break;\\n            }\\n        }\\n        root->left=build(pre, in, preIndex + 1, is, inIndex-1);\\n        root->right=build(pre, in, preIndex + inIndex - is + 1, inIndex+1, ie);\\n        return root;\\n    }\\n    TreeNode* buildTree(vector<int>& pre, vector<int>& in) {\\n        return build(pre, in, 0, 0, in.size()-1);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1281777,
                "title": "simple-recursive-c-solutions-with-map-and-without-map",
                "content": "**Please upvote this post to motivate me in my quest of documenting leetcode solutions.**\\n```\\n// TC - O(N^2) SC - O(1)\\nclass Solution {\\npublic:\\n    TreeNode* solve(vector<int>& preorder, vector<int>& inorder, int preStart, int inStart, int inEnd)\\n    {\\n        if(preStart >= preorder.size() || inStart > inEnd) return NULL;\\n        TreeNode* root = new TreeNode(preorder[preStart]);\\n        int inIndex = 0;\\n        // find the index of the root node in inorder array (we can use hashmap as well)\\n        for(int i = inStart; i <= inEnd; i++)\\n        {\\n            if(inorder[i] == root->val)\\n            {\\n                inIndex = i;\\n            }\\n        }\\n        // Now left part of inIndex will be left subtree of root and right part will be right subtree\\n        root->left = solve(preorder, inorder, preStart + 1, inStart, inIndex - 1);\\n        // skip left tree (inIndex - inStart) to calculate the index of the right root node\\n        root->right = solve(preorder, inorder, preStart + inIndex - inStart + 1, inIndex + 1, inEnd);\\n        return root;\\n    }\\n    TreeNode* buildTree(vector<int>& preorder, vector<int>& inorder) {\\n        return solve(preorder, inorder, 0, 0, inorder.size() - 1);\\n    }\\n};\\n// Using hashmap TC - O(N) SC - O(N)\\nclass Solution {\\npublic:\\n    TreeNode* solve(unordered_map<int, int>& mp, vector<int>& preorder, vector<int>& inorder, int preStart, int inStart, int inEnd)\\n    {\\n        if(preStart >= preorder.size() || inStart > inEnd) return NULL;\\n        TreeNode* root = new TreeNode(preorder[preStart]);\\n        // find the index of the root node in inorder array (we can use linear search as well)\\n        int inIndex = mp[root->val];\\n        // Now left part of inIndex will be left subtree of root and right part will be right subtree\\n        root->left = solve(mp, preorder, inorder, preStart + 1, inStart, inIndex - 1);\\n        // skip left tree (inIndex - inStart) to calculate the index of the right root node\\n        root->right = solve(mp, preorder, inorder, preStart + inIndex - inStart + 1, inIndex + 1, inEnd);\\n        return root;\\n    }\\n    TreeNode* buildTree(vector<int>& preorder, vector<int>& inorder) {\\n        unordered_map<int, int> mp;\\n        for(int i = 0; i < inorder.size(); i++)\\n        {\\n            mp[inorder[i]] = i;\\n        }\\n        return solve(mp, preorder, inorder, 0, 0, inorder.size() - 1);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Recursion"
                ],
                "code": "```\\n// TC - O(N^2) SC - O(1)\\nclass Solution {\\npublic:\\n    TreeNode* solve(vector<int>& preorder, vector<int>& inorder, int preStart, int inStart, int inEnd)\\n    {\\n        if(preStart >= preorder.size() || inStart > inEnd) return NULL;\\n        TreeNode* root = new TreeNode(preorder[preStart]);\\n        int inIndex = 0;\\n        // find the index of the root node in inorder array (we can use hashmap as well)\\n        for(int i = inStart; i <= inEnd; i++)\\n        {\\n            if(inorder[i] == root->val)\\n            {\\n                inIndex = i;\\n            }\\n        }\\n        // Now left part of inIndex will be left subtree of root and right part will be right subtree\\n        root->left = solve(preorder, inorder, preStart + 1, inStart, inIndex - 1);\\n        // skip left tree (inIndex - inStart) to calculate the index of the right root node\\n        root->right = solve(preorder, inorder, preStart + inIndex - inStart + 1, inIndex + 1, inEnd);\\n        return root;\\n    }\\n    TreeNode* buildTree(vector<int>& preorder, vector<int>& inorder) {\\n        return solve(preorder, inorder, 0, 0, inorder.size() - 1);\\n    }\\n};\\n// Using hashmap TC - O(N) SC - O(N)\\nclass Solution {\\npublic:\\n    TreeNode* solve(unordered_map<int, int>& mp, vector<int>& preorder, vector<int>& inorder, int preStart, int inStart, int inEnd)\\n    {\\n        if(preStart >= preorder.size() || inStart > inEnd) return NULL;\\n        TreeNode* root = new TreeNode(preorder[preStart]);\\n        // find the index of the root node in inorder array (we can use linear search as well)\\n        int inIndex = mp[root->val];\\n        // Now left part of inIndex will be left subtree of root and right part will be right subtree\\n        root->left = solve(mp, preorder, inorder, preStart + 1, inStart, inIndex - 1);\\n        // skip left tree (inIndex - inStart) to calculate the index of the right root node\\n        root->right = solve(mp, preorder, inorder, preStart + inIndex - inStart + 1, inIndex + 1, inEnd);\\n        return root;\\n    }\\n    TreeNode* buildTree(vector<int>& preorder, vector<int>& inorder) {\\n        unordered_map<int, int> mp;\\n        for(int i = 0; i < inorder.size(); i++)\\n        {\\n            mp[inorder[i]] = i;\\n        }\\n        return solve(mp, preorder, inorder, 0, 0, inorder.size() - 1);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1260247,
                "title": "c-easy-recursive-solution-using-map-with-explanation",
                "content": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\n class Solution {\\n    unordered_map<int,int> in; //We\\'ve to traverse inorder for every index of preorder,so to reduce the time we store the elements of inorder into map\\npublic:\\n    TreeNode* buildTree(vector<int>& preorder, vector<int>& inorder) {\\n     for(int i=0;i<inorder.size();i++) in.insert({inorder[i],i}); //inserting elements of inorder to map\\n        \\n        return construct( preorder, inorder, 0, inorder.size()-1,0);\\n    }\\n    //Below is a recursive function for building the tree, i is the starting index of inorder and j is the ending index of inorder. preIndex is the index of element in preorder\\n    TreeNode* construct(vector<int>& preorder, vector<int>& inorder,int i, int j,int preIndex){\\n        if(i>j) return nullptr; //if start>end\\n        TreeNode* root= new TreeNode(preorder[preIndex]); //we create a root node and insert preorder element to it\\n        int inIndex=in[preorder[preIndex]]; //We find that element in inorder through map and store its index\\n        root->left=construct(preorder,inorder,i,inIndex-1,preIndex+1); //constructing the left subtree\\n        root->right=construct(preorder,inorder,inIndex+1,j,preIndex+ inIndex-i+1); //constructing the right subtree\\n        return root;\\n    }\\n};\\n```\\nHope you found this helpful :)",
                "solutionTags": [
                    "C",
                    "Recursion"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\n class Solution {\\n    unordered_map<int,int> in; //We\\'ve to traverse inorder for every index of preorder,so to reduce the time we store the elements of inorder into map\\npublic:\\n    TreeNode* buildTree(vector<int>& preorder, vector<int>& inorder) {\\n     for(int i=0;i<inorder.size();i++) in.insert({inorder[i],i}); //inserting elements of inorder to map\\n        \\n        return construct( preorder, inorder, 0, inorder.size()-1,0);\\n    }\\n    //Below is a recursive function for building the tree, i is the starting index of inorder and j is the ending index of inorder. preIndex is the index of element in preorder\\n    TreeNode* construct(vector<int>& preorder, vector<int>& inorder,int i, int j,int preIndex){\\n        if(i>j) return nullptr; //if start>end\\n        TreeNode* root= new TreeNode(preorder[preIndex]); //we create a root node and insert preorder element to it\\n        int inIndex=in[preorder[preIndex]]; //We find that element in inorder through map and store its index\\n        root->left=construct(preorder,inorder,i,inIndex-1,preIndex+1); //constructing the left subtree\\n        root->right=construct(preorder,inorder,inIndex+1,j,preIndex+ inIndex-i+1); //constructing the right subtree\\n        return root;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 759136,
                "title": "a-simple-and-truly-o-n-approach-in-python",
                "content": "Lots of examples here that claim `O(n)` runtime but use `.pop(0)` or `index()` or list splitting tricks. These are fine for a `n ^ 2` solution but they are improperly labeled as more efficient than they actually are. The below solution is truly `O(n)` as every operation within our recursive call is `O(1)` and all the preprocessing is done outside the loop. If we have a skewed tree where we visit every node, we can still be assured this will perform.\\n\\n* We build a map to store the indices of every time in inorder list, allowing us to avoid using `.index()` and look up the idx of any number in constant time (yes, I understand that maps are technically not constant but it\\'s close enough)\\n* We use pointers instead of list splitting to narrow down our postorder list size.\\n* We reverse the preorder list, allowing us to pop from the end in constant time. A deque would also work here. \\n\\n\\n```python\\nfrom collections import defaultdict\\n\\nclass Solution:\\n    def buildTree(self, preorder: List[int], inorder: List[int]) -> TreeNode:\\n        idxmap = defaultdict(int)\\n        \\n        for i, n in enumerate(inorder):\\n            idxmap[n] = i\\n        \\n        return self.helper(preorder[::-1], inorder, 0, len(inorder), idxmap)\\n    \\n    def helper(self, preorder, inorder, leftPointer, rightPointer, idxmap):\\n        if leftPointer < rightPointer:\\n            num = preorder.pop()\\n            root = TreeNode(num)\\n            idx = idxmap.get(num)\\n            \\n            root.left = self.helper(preorder, inorder, leftPointer, idx, idxmap)\\n            root.right = self.helper(preorder, inorder, idx + 1, rightPointer, idxmap)\\n            \\n            return root\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Recursion"
                ],
                "code": "```python\\nfrom collections import defaultdict\\n\\nclass Solution:\\n    def buildTree(self, preorder: List[int], inorder: List[int]) -> TreeNode:\\n        idxmap = defaultdict(int)\\n        \\n        for i, n in enumerate(inorder):\\n            idxmap[n] = i\\n        \\n        return self.helper(preorder[::-1], inorder, 0, len(inorder), idxmap)\\n    \\n    def helper(self, preorder, inorder, leftPointer, rightPointer, idxmap):\\n        if leftPointer < rightPointer:\\n            num = preorder.pop()\\n            root = TreeNode(num)\\n            idx = idxmap.get(num)\\n            \\n            root.left = self.helper(preorder, inorder, leftPointer, idx, idxmap)\\n            root.right = self.helper(preorder, inorder, idx + 1, rightPointer, idxmap)\\n            \\n            return root\\n```",
                "codeTag": "Java"
            },
            {
                "id": 591562,
                "title": "simple-java-solution-o-n-time-1ms-solution",
                "content": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode(int x) { val = x; }\\n * }\\n */\\nclass Solution {\\n    public TreeNode buildTree(int[] preorder, int[] inorder) {\\n        Map<Integer,Integer> map = new HashMap<>();\\n        for(int i=0;i<inorder.length;i++){\\n            map.put(inorder[i],i);\\n        }\\n        return bt(preorder,inorder,0,preorder.length-1,new int[1],map);\\n    }\\n    private TreeNode bt(int[] pre,int[] in,int l,int r,int[] c, Map<Integer,Integer> map){\\n        if(l>r) {\\n            return null;\\n        }\\n        \\n        TreeNode node = new TreeNode(pre[c[0]]);\\n        c[0]+=1;\\n        int mid = map.get(node.val);\\n        node.left=bt(pre,in,l,mid-1,c,map);\\n        node.right=bt(pre,in,mid+1,r,c,map);\\n        return node;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Recursion"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode(int x) { val = x; }\\n * }\\n */\\nclass Solution {\\n    public TreeNode buildTree(int[] preorder, int[] inorder) {\\n        Map<Integer,Integer> map = new HashMap<>();\\n        for(int i=0;i<inorder.length;i++){\\n            map.put(inorder[i],i);\\n        }\\n        return bt(preorder,inorder,0,preorder.length-1,new int[1],map);\\n    }\\n    private TreeNode bt(int[] pre,int[] in,int l,int r,int[] c, Map<Integer,Integer> map){\\n        if(l>r) {\\n            return null;\\n        }\\n        \\n        TreeNode node = new TreeNode(pre[c[0]]);\\n        c[0]+=1;\\n        int mid = map.get(node.val);\\n        node.left=bt(pre,in,l,mid-1,c,map);\\n        node.right=bt(pre,in,mid+1,r,c,map);\\n        return node;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 569757,
                "title": "c-recursive-solution-with-key-ideas-explanation",
                "content": "There are 3 main ideas:\\n1) Preorder traversal starts with the root node\\n // by definition: starting from the root returns its value first\\n2) Inorder traversal allows us to separate a given tree on two subtrees\\n // by definition too: returns root value after left  and before right subtree traversals, so the root value is between subtrees\\n3) Iterating preorder traversal will give us root values in each subtree. So we can use a queue for it.\\n\\n```\\n    public TreeNode BuildTree(int[] preorder, int[] inorder) {\\n        if (preorder == null || inorder == null || preorder.Length != inorder.Length || inorder.Length == 0)\\n            return null;\\n        \\n        var inorderIndex = inorder\\n            .Select((value, index) => (value, index))\\n            .ToDictionary(\\n                pair => pair.value,\\n                pair => pair.index);\\n        \\n        return BuildTree(inorder, 0, inorder.Length - 1, inorderIndex, new Queue<int>(preorder));\\n    }\\n    \\n    private static TreeNode BuildTree(int[] inorder, int leftPos, int rightPos, IDictionary<int, int> inorderIndex, Queue<int> preorderQueue) {\\n        if (leftPos > rightPos)\\n            return null;\\n        \\n        var rootValue = preorderQueue.Dequeue();\\n        var rootPos = inorderIndex[rootValue];\\n        \\n        return new TreeNode(rootValue) {\\n            left = BuildTree(inorder, leftPos, rootPos - 1, inorderIndex, preorderQueue),\\n            right = BuildTree(inorder, rootPos + 1, rightPos, inorderIndex, preorderQueue)\\n            };\\n    }\\n```",
                "solutionTags": [
                    "Recursion"
                ],
                "code": "```\\n    public TreeNode BuildTree(int[] preorder, int[] inorder) {\\n        if (preorder == null || inorder == null || preorder.Length != inorder.Length || inorder.Length == 0)\\n            return null;\\n        \\n        var inorderIndex = inorder\\n            .Select((value, index) => (value, index))\\n            .ToDictionary(\\n                pair => pair.value,\\n                pair => pair.index);\\n        \\n        return BuildTree(inorder, 0, inorder.Length - 1, inorderIndex, new Queue<int>(preorder));\\n    }\\n    \\n    private static TreeNode BuildTree(int[] inorder, int leftPos, int rightPos, IDictionary<int, int> inorderIndex, Queue<int> preorderQueue) {\\n        if (leftPos > rightPos)\\n            return null;\\n        \\n        var rootValue = preorderQueue.Dequeue();\\n        var rootPos = inorderIndex[rootValue];\\n        \\n        return new TreeNode(rootValue) {\\n            left = BuildTree(inorder, leftPos, rootPos - 1, inorderIndex, preorderQueue),\\n            right = BuildTree(inorder, rootPos + 1, rightPos, inorderIndex, preorderQueue)\\n            };\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 537892,
                "title": "py3-sol-very-easy-to-understand",
                "content": "```\\nclass Solution:\\n    def buildTree(self, preorder: List[int], inorder: List[int]) -> TreeNode:\\n        if len(preorder)==0 or len(inorder)==0:\\n            return None\\n        root = TreeNode()\\n#         getting head of Tree/subTree\\n\\t# preorder- HLR\\n\\t# inorder- LHR, where L = Left, H-Head, R-Right\\n        root.val = preorder.pop(0)\\n        ind = inorder.index(root.val)\\n        inOrder_left = inorder[:ind]\\n        inOrder_right = inorder[ind+1:] #leaving root\\n        preOrder_left = preorder[:len(inOrder_left)]\\n        preOrder_right = preorder[len(inOrder_left):]\\n        root.left = self.buildTree(preOrder_left,inOrder_left)\\n        root.right = self.buildTree(preOrder_right,inOrder_right)\\n        return root\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def buildTree(self, preorder: List[int], inorder: List[int]) -> TreeNode:\\n        if len(preorder)==0 or len(inorder)==0:\\n            return None\\n        root = TreeNode()\\n#         getting head of Tree/subTree\\n\\t# preorder- HLR\\n\\t# inorder- LHR, where L = Left, H-Head, R-Right\\n        root.val = preorder.pop(0)\\n        ind = inorder.index(root.val)\\n        inOrder_left = inorder[:ind]\\n        inOrder_right = inorder[ind+1:] #leaving root\\n        preOrder_left = preorder[:len(inOrder_left)]\\n        preOrder_right = preorder[len(inOrder_left):]\\n        root.left = self.buildTree(preOrder_left,inOrder_left)\\n        root.right = self.buildTree(preOrder_right,inOrder_right)\\n        return root\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3979579,
                "title": "best-o-n-solution",
                "content": "# Approach\\nOptimal\\n\\n# Complexity\\n- Time complexity:\\n$$O(n)$$\\n\\n- Space complexity:\\n$$O(n)$$\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    TreeNode* build(int preStart, int preEnd, vector<int>& preorder, \\n    int inStart, int inEnd, vector<int>& inorder, unordered_map <int, int>& mp) {\\n        if (preStart > preEnd || inStart > inEnd)\\n            return NULL;\\n        TreeNode* root = new TreeNode(preorder[preStart]);\\n        int ind = mp[preorder[preStart]];    \\n        root->left = build(preStart+1, preStart+ind-inStart, preorder, inStart, ind-1, inorder, mp);\\n        root->right = build(preStart+ind-inStart+1, preEnd, preorder, ind+1, inEnd, inorder, mp);\\n\\n        return root;   \\n    }\\n\\n    TreeNode* buildTree(vector<int>& preorder, vector<int>& inorder) {\\n        int preStart = 0, preEnd = preorder.size() - 1;\\n        int inStart = 0, inEnd = inorder.size() - 1;\\n        unordered_map <int, int> mp;\\n        for (int i = 0; i < inorder.size(); i++)\\n            mp[inorder[i]] = i;\\n\\n        return build(preStart, preEnd, preorder, inStart, inEnd, inorder, mp);    \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    TreeNode* build(int preStart, int preEnd, vector<int>& preorder, \\n    int inStart, int inEnd, vector<int>& inorder, unordered_map <int, int>& mp) {\\n        if (preStart > preEnd || inStart > inEnd)\\n            return NULL;\\n        TreeNode* root = new TreeNode(preorder[preStart]);\\n        int ind = mp[preorder[preStart]];    \\n        root->left = build(preStart+1, preStart+ind-inStart, preorder, inStart, ind-1, inorder, mp);\\n        root->right = build(preStart+ind-inStart+1, preEnd, preorder, ind+1, inEnd, inorder, mp);\\n\\n        return root;   \\n    }\\n\\n    TreeNode* buildTree(vector<int>& preorder, vector<int>& inorder) {\\n        int preStart = 0, preEnd = preorder.size() - 1;\\n        int inStart = 0, inEnd = inorder.size() - 1;\\n        unordered_map <int, int> mp;\\n        for (int i = 0; i < inorder.size(); i++)\\n            mp[inorder[i]] = i;\\n\\n        return build(preStart, preEnd, preorder, inStart, inEnd, inorder, mp);    \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3778050,
                "title": "just-say-wow",
                "content": "\\n# Complexity\\n- Time complexity:  **O(N)**\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: **O(N)**\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int idx=0;\\n    unordered_map<int,int>mp;\\n    //lb: lowerbound , ub: upperbound \\n    TreeNode* helper(vector<int>& preorder,int lb, int ub)\\n    {\\n        if(lb>ub) return NULL;\\n        TreeNode* root = new TreeNode(preorder[idx++]);\\n        int mid = mp[root->val];\\n        root->left = helper(preorder,lb,mid-1);  \\n        root->right= helper(preorder,mid+1,ub);\\n        return root;\\n    }\\n    TreeNode* buildTree(vector<int>& preorder, vector<int>& inorder) {\\n        int n = preorder.size();\\n        for(int i =0;i<n;i++) mp[inorder[i]]=i;\\n        TreeNode* root = helper(preorder,0,n-1);\\n        return root;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Hash Table",
                    "Divide and Conquer",
                    "Tree",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int idx=0;\\n    unordered_map<int,int>mp;\\n    //lb: lowerbound , ub: upperbound \\n    TreeNode* helper(vector<int>& preorder,int lb, int ub)\\n    {\\n        if(lb>ub) return NULL;\\n        TreeNode* root = new TreeNode(preorder[idx++]);\\n        int mid = mp[root->val];\\n        root->left = helper(preorder,lb,mid-1);  \\n        root->right= helper(preorder,mid+1,ub);\\n        return root;\\n    }\\n    TreeNode* buildTree(vector<int>& preorder, vector<int>& inorder) {\\n        int n = preorder.size();\\n        for(int i =0;i<n;i++) mp[inorder[i]]=i;\\n        TreeNode* root = helper(preorder,0,n-1);\\n        return root;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3130227,
                "title": "beats-98-easy-simple-solution-using-maps",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    TreeNode* build(vector<int>& preorder,int preStart,int preEnd,vector<int>& inorder,int inStart, int inEnd,unordered_map<int,int>&mp){\\n        if(preStart>preEnd || inStart>inEnd){\\n            return NULL;\\n        }\\n        TreeNode* root = new TreeNode(preorder[preStart]);\\n        int rootIndex = mp[root->val];\\n        int numsLeft = rootIndex-inStart;   \\n        root->left = build(preorder,preStart+1,preStart+numsLeft,inorder,inStart,rootIndex-1,mp);\\n        root->right=build(preorder,preStart+numsLeft+1,preEnd,inorder,rootIndex+1,inEnd,mp);\\n        return root;\\n    }\\n    TreeNode* buildTree(vector<int>& preorder, vector<int>& inorder) {\\n        unordered_map<int,int>mp;\\n        for(int i=0;i<inorder.size();i++){\\n            mp[inorder[i]]=i;\\n        }\\n        TreeNode* root = build(preorder,0,preorder.size()-1,inorder,0,inorder.size()-1,mp);\\n        return root;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    TreeNode* build(vector<int>& preorder,int preStart,int preEnd,vector<int>& inorder,int inStart, int inEnd,unordered_map<int,int>&mp){\\n        if(preStart>preEnd || inStart>inEnd){\\n            return NULL;\\n        }\\n        TreeNode* root = new TreeNode(preorder[preStart]);\\n        int rootIndex = mp[root->val];\\n        int numsLeft = rootIndex-inStart;   \\n        root->left = build(preorder,preStart+1,preStart+numsLeft,inorder,inStart,rootIndex-1,mp);\\n        root->right=build(preorder,preStart+numsLeft+1,preEnd,inorder,rootIndex+1,inEnd,mp);\\n        return root;\\n    }\\n    TreeNode* buildTree(vector<int>& preorder, vector<int>& inorder) {\\n        unordered_map<int,int>mp;\\n        for(int i=0;i<inorder.size();i++){\\n            mp[inorder[i]]=i;\\n        }\\n        TreeNode* root = build(preorder,0,preorder.size()-1,inorder,0,inorder.size()-1,mp);\\n        return root;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3128989,
                "title": "c-solution-mind-the-global-variable",
                "content": "```\\nclass Solution {\\npublic:\\n    int curr=0;  //global variable\\n    \\n    TreeNode* help(vector<int>& pre,vector<int>& in,int inLeft, int inRight){\\n        if(inLeft > inRight)return NULL;\\n        auto ans= new TreeNode(pre[curr]);\\n\\n        int ind= find(in.begin(),in.end(),pre[curr])- in.begin();\\n        curr++;\\n        \\n        ans->left= help(pre,in,inLeft, ind-1);\\n        ans->right= help(pre,in,ind+1, inRight);\\n        return ans;\\n    }\\n    \\n    TreeNode* buildTree(vector<int>& pre, vector<int>& in) {\\n        return help(pre,in,0,in.size()-1);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int curr=0;  //global variable\\n    \\n    TreeNode* help(vector<int>& pre,vector<int>& in,int inLeft, int inRight){\\n        if(inLeft > inRight)return NULL;\\n        auto ans= new TreeNode(pre[curr]);\\n\\n        int ind= find(in.begin(),in.end(),pre[curr])- in.begin();\\n        curr++;\\n        \\n        ans->left= help(pre,in,inLeft, ind-1);\\n        ans->right= help(pre,in,ind+1, inRight);\\n        return ans;\\n    }\\n    \\n    TreeNode* buildTree(vector<int>& pre, vector<int>& in) {\\n        return help(pre,in,0,in.size()-1);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2861277,
                "title": "javascript-simple-solution-without-any-helper-function",
                "content": "```\\nvar buildTree = function (preorder, inorder) {\\n  if (!preorder.length || !inorder.length) return null;\\n  const newParentNode = new TreeNode(preorder[0]);\\n  const middle = inorder.indexOf(preorder[0]);\\n  newParentNode.left = buildTree(\\n    preorder.slice(1, middle + 1),\\n    inorder.slice(0, middle)\\n  );\\n  newParentNode.right = buildTree(\\n    preorder.slice(middle + 1),\\n    inorder.slice(middle + 1)\\n  );\\n  return newParentNode;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar buildTree = function (preorder, inorder) {\\n  if (!preorder.length || !inorder.length) return null;\\n  const newParentNode = new TreeNode(preorder[0]);\\n  const middle = inorder.indexOf(preorder[0]);\\n  newParentNode.left = buildTree(\\n    preorder.slice(1, middle + 1),\\n    inorder.slice(0, middle)\\n  );\\n  newParentNode.right = buildTree(\\n    preorder.slice(middle + 1),\\n    inorder.slice(middle + 1)\\n  );\\n  return newParentNode;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2414795,
                "title": "c-recursive-solution-easy-to-understand-straight-forward",
                "content": "**Please Upvote if you found this helpful.**\\n\\n```\\n\\nclass Solution {\\npublic:\\n    int search(vector<int> inorder, int start, int end, int curr)\\n    {\\n        for(int i=start; i<=end; i++)\\n        {\\n            if(inorder[i]== curr)\\n            {\\n                return i;\\n            }\\n        }\\n        return -1;\\n    }\\n    \\n    int idx= 0;\\n    TreeNode* build(vector<int> inorder, vector<int> preorder, int start, int end)\\n    {\\n        if(start > end)\\n        {\\n            return NULL;\\n        }\\n        int curr= preorder[idx];\\n        TreeNode* root= new TreeNode(curr);\\n        idx++;\\n        int pos= search(inorder, start, end, curr);\\n        root->left= build(inorder, preorder, start, pos-1);\\n        root->right= build(inorder, preorder, pos+1, end);\\n        return root;\\n    }\\n    \\n    TreeNode* buildTree(vector<int>& preorder, vector<int>& inorder) \\n    {\\n        int n= inorder.size();\\n        return build(inorder, preorder, 0, n-1);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Recursion",
                    "Binary Tree"
                ],
                "code": "```\\n\\nclass Solution {\\npublic:\\n    int search(vector<int> inorder, int start, int end, int curr)\\n    {\\n        for(int i=start; i<=end; i++)\\n        {\\n            if(inorder[i]== curr)\\n            {\\n                return i;\\n            }\\n        }\\n        return -1;\\n    }\\n    \\n    int idx= 0;\\n    TreeNode* build(vector<int> inorder, vector<int> preorder, int start, int end)\\n    {\\n        if(start > end)\\n        {\\n            return NULL;\\n        }\\n        int curr= preorder[idx];\\n        TreeNode* root= new TreeNode(curr);\\n        idx++;\\n        int pos= search(inorder, start, end, curr);\\n        root->left= build(inorder, preorder, start, pos-1);\\n        root->right= build(inorder, preorder, pos+1, end);\\n        return root;\\n    }\\n    \\n    TreeNode* buildTree(vector<int>& preorder, vector<int>& inorder) \\n    {\\n        int n= inorder.size();\\n        return build(inorder, preorder, 0, n-1);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2349388,
                "title": "python-simple-elegant-commented-and-explained-recursion",
                "content": "```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def buildTree(self, preorder: List[int], inorder: List[int]) -> Optional[TreeNode]:\\n\\n\\n        # recursion in pre-order : conditions\\n\\n        # first value in pre-order traversal is root\\n\\n\\n        # recursion in in-order : conditions\\n\\n        # every value to the left of the in-order root will go into left sub-tree\\n\\n        # every value to the right of the in-order root will go into rigth sub-tree\\n\\n        if not preorder or not inorder:\\n            return None\\n\\n        root = TreeNode(preorder[0])\\n\\n        mid = inorder.index(preorder[0])\\n\\n        root.left = self.buildTree(preorder[1:mid+1], inorder[:mid])\\n\\n        root.right = self.buildTree(preorder[mid+1:], inorder[mid+1:])\\n\\n        return root\\n```",
                "solutionTags": [
                    "Python",
                    "Recursion"
                ],
                "code": "```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def buildTree(self, preorder: List[int], inorder: List[int]) -> Optional[TreeNode]:\\n\\n\\n        # recursion in pre-order : conditions\\n\\n        # first value in pre-order traversal is root\\n\\n\\n        # recursion in in-order : conditions\\n\\n        # every value to the left of the in-order root will go into left sub-tree\\n\\n        # every value to the right of the in-order root will go into rigth sub-tree\\n\\n        if not preorder or not inorder:\\n            return None\\n\\n        root = TreeNode(preorder[0])\\n\\n        mid = inorder.index(preorder[0])\\n\\n        root.left = self.buildTree(preorder[1:mid+1], inorder[:mid])\\n\\n        root.right = self.buildTree(preorder[mid+1:], inorder[mid+1:])\\n\\n        return root\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2283072,
                "title": "python3-8-lines-recursion-w-explanation",
                "content": "```\\nclass Solution:\\n                                # The plan:\\n                                #   \\u2022 use preorder[0] as root, then determine root\\'s left and right\\n                                #     subtrees from root\\'s index in inorder.\\n                                #   \\u2022 with the preorder and inorder for each subtree, determine that \\n                                #     subtree recursively\\n\\n                                # There\\'s an example below the code:\\n                                #          preorder = [4,6,1,7,5,2], and inorder = [1,6,7,4,5,2]\\n\\n    def buildTree(self, preorder: list[int], inorder: list[int]) -> TreeNode:\\n        if not preorder: return None                            # <- handle the base case.\\n\\n        root = TreeNode(preorder[0])                            # <- identify the root\\n        idx = inorder.index(root.val)                           # <- determine index of the root in inorder\\n   \\n        leftIn, rightIn = inorder[:idx],  inorder[idx+1:]       # <- determine inorders  for the subtrees \\n        leftPr, rightPr = preorder[1:idx+1], preorder[idx+1:]   # <- determine preorders for the subtrees\\n\\n        root.left  = self.buildTree(leftPr,  leftIn )           # <- left and right recursive calls\\n        root.right = self.buildTree(rightPr, rightIn)\\n        \\n        return root\\n\\n        # EXAMPLE\\n        # =================\\n        # LEVEL 0 CALL\\n        #           root\\n        #             |\\n        # preorder = [4, 6,1,7, 5,2]\\n        # inorder  = [1,6,7, 4, 5,2]\\n        #                    |\\n        #                   root   \\n        #                                    ___4___\\n        #                                   /       \\\\\\n        #  inorder  subtrees:         [1,6,7]       [2,5]\\n        #  preorder subtree:          [6,1,7]       [5,2]\\n        # =================\\n        # LEVEL 1 CALLS\\n        #           root           root\\n        #             |             |  \\n        # preorder = [6, 1, 7],    [5, 2]   (note each subtree\\'s preorder and inorder have same \\n        # inorder  = [1, 6, 7],    [2, 5]    elements, just different ordering.)\\n        #                |             |\\n        #               root         root \\n        #                                  ____4____\\n        #                                 /         \\\\\\n        #                               _6_          5_ \\n        #                              /   \\\\        /    \\n        #  inorder  subtrees:         [1]  [7]    [2]\\n        #  preorder subtrees:         [1]  [7]    [2]\\n        # =================\\n        # LEVEL 3 CALLS \\n        #\\n        #                                  ____4____\\n        #                                 /         \\\\\\n        #                               _6_          5\\n        #                              /   \\\\        /    \\n        #                             1     7      2",
                "solutionTags": [
                    "Python",
                    "Recursion"
                ],
                "code": "```\\nclass Solution:\\n                                # The plan:\\n                                #   \\u2022 use preorder[0] as root, then determine root\\'s left and right\\n                                #     subtrees from root\\'s index in inorder.\\n                                #   \\u2022 with the preorder and inorder for each subtree, determine that \\n                                #     subtree recursively\\n\\n                                # There\\'s an example below the code:\\n                                #          preorder = [4,6,1,7,5,2], and inorder = [1,6,7,4,5,2]\\n\\n    def buildTree(self, preorder: list[int], inorder: list[int]) -> TreeNode:\\n        if not preorder: return None                            # <- handle the base case.\\n\\n        root = TreeNode(preorder[0])                            # <- identify the root\\n        idx = inorder.index(root.val)                           # <- determine index of the root in inorder\\n   \\n        leftIn, rightIn = inorder[:idx],  inorder[idx+1:]       # <- determine inorders  for the subtrees \\n        leftPr, rightPr = preorder[1:idx+1], preorder[idx+1:]   # <- determine preorders for the subtrees\\n\\n        root.left  = self.buildTree(leftPr,  leftIn )           # <- left and right recursive calls\\n        root.right = self.buildTree(rightPr, rightIn)\\n        \\n        return root\\n\\n        # EXAMPLE\\n        # =================\\n        # LEVEL 0 CALL\\n        #           root\\n        #             |\\n        # preorder = [4, 6,1,7, 5,2]\\n        # inorder  = [1,6,7, 4, 5,2]\\n        #                    |\\n        #                   root   \\n        #                                    ___4___\\n        #                                   /       \\\\\\n        #  inorder  subtrees:         [1,6,7]       [2,5]\\n        #  preorder subtree:          [6,1,7]       [5,2]\\n        # =================\\n        # LEVEL 1 CALLS\\n        #           root           root\\n        #             |             |  \\n        # preorder = [6, 1, 7],    [5, 2]   (note each subtree\\'s preorder and inorder have same \\n        # inorder  = [1, 6, 7],    [2, 5]    elements, just different ordering.)\\n        #                |             |\\n        #               root         root \\n        #                                  ____4____\\n        #                                 /         \\\\\\n        #                               _6_          5_ \\n        #                              /   \\\\        /    \\n        #  inorder  subtrees:         [1]  [7]    [2]\\n        #  preorder subtrees:         [1]  [7]    [2]\\n        # =================\\n        # LEVEL 3 CALLS \\n        #\\n        #                                  ____4____\\n        #                                 /         \\\\\\n        #                               _6_          5\\n        #                              /   \\\\        /    \\n        #                             1     7      2",
                "codeTag": "Java"
            },
            {
                "id": 2279293,
                "title": "java-simple-easy-solution",
                "content": "\\'\\'\\'\\n class Solution {\\n    private int preStart = 0;\\n    public TreeNode buildTree(int[] preorder, int[] inorder) {\\n        return recursion(preorder, inorder, 0, preorder.length - 1);\\n    }\\n\\n    private TreeNode recursion(int[] preorder, int[] inorder, int left, int right) {\\n        if (preStart == preorder.length || left > right ) {\\n            return null;\\n        }\\n        TreeNode root = new TreeNode(preorder[preStart]);\\n        for (int i = left; i <= right; i++) {\\n            if (preorder[preStart] == inorder[i]) {\\n                preStart++;\\n                root.left = recursion(preorder, inorder, left, i - 1);\\n                root.right = recursion(preorder, inorder, i + 1, right);\\n                break;\\n            }\\n        }\\n        return root;\\n    }\\n}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    private int preStart = 0;\\n    public TreeNode buildTree(int[] preorder, int[] inorder) {\\n        return recursion(preorder, inorder, 0, preorder.length - 1);\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 2057651,
                "title": "easiest-iterative-solution",
                "content": "Found this to be very intuituve. Don\\'t think it\\'s the most efficient though. Thoughts?\\n\\n```\\npublic TreeNode buildTree(int[] pre, int[] in) {\\n        TreeNode node = new TreeNode(pre[0]);\\n        Map<Integer, Integer> pos = new HashMap<>();\\n        Stack<TreeNode> stk = new Stack<>();\\n        int len = in.length, currPos, nextPos;\\n        \\n        for(int i=0; i<len; i++) pos.put(in[i], i);\\n        \\n        stk.push(node);\\n        for(int i=1; i<len; i++){\\n            \\n            TreeNode curr = stk.peek();\\n            currPos = pos.get(curr.val);\\n            TreeNode next = new TreeNode(pre[i]);\\n            nextPos = pos.get(pre[i]);\\n            \\n            if(nextPos < currPos) {\\n                curr.left = next;\\n                stk.push(next);\\n            } else{\\n                while(!stk.isEmpty() && pos.get((stk.peek()).val) < nextPos){\\n                    curr = stk.pop();\\n                }\\n                curr.right = next;\\n                stk.push(next);\\n            }\\n        }\\n        return node;\\n    }\\n```",
                "solutionTags": [
                    "Java",
                    "Stack"
                ],
                "code": "```\\npublic TreeNode buildTree(int[] pre, int[] in) {\\n        TreeNode node = new TreeNode(pre[0]);\\n        Map<Integer, Integer> pos = new HashMap<>();\\n        Stack<TreeNode> stk = new Stack<>();\\n        int len = in.length, currPos, nextPos;\\n        \\n        for(int i=0; i<len; i++) pos.put(in[i], i);\\n        \\n        stk.push(node);\\n        for(int i=1; i<len; i++){\\n            \\n            TreeNode curr = stk.peek();\\n            currPos = pos.get(curr.val);\\n            TreeNode next = new TreeNode(pre[i]);\\n            nextPos = pos.get(pre[i]);\\n            \\n            if(nextPos < currPos) {\\n                curr.left = next;\\n                stk.push(next);\\n            } else{\\n                while(!stk.isEmpty() && pos.get((stk.peek()).val) < nextPos){\\n                    curr = stk.pop();\\n                }\\n                curr.right = next;\\n                stk.push(next);\\n            }\\n        }\\n        return node;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1786005,
                "title": "c-clean-easy-recursion",
                "content": "\\tclass Solution {\\n\\tpublic:\\n\\t\\tint findPos(vector<int> inorder,int element,int n){\\n\\t\\t\\tfor(int i=0;i<n;i++){\\n\\t\\t\\t\\tif(inorder[i] == element)\\n\\t\\t\\t\\t\\treturn i;\\n\\t\\t\\t}\\n\\t\\t\\treturn -1;\\n\\t\\t}\\n\\n\\t\\tTreeNode* solve(vector<int> preorder,vector<int> inorder,int &prestart , int instart,int inend , int n){\\n\\t\\t\\tif(prestart >= n || instart > inend){\\n\\t\\t\\t\\treturn NULL;\\n\\t\\t\\t}\\n\\n\\t\\t\\tint ele = preorder[prestart++];  //starting ele of preorder\\n\\t\\t\\tTreeNode* root = new TreeNode(ele);  //creating new node\\n\\n\\t\\t\\t//now finding ele position in inorder\\n\\t\\t\\tint pos = findPos(inorder , ele , n);\\n\\n\\t\\t\\t//recursive call\\n\\t\\t\\troot->left = solve(preorder,inorder,prestart,instart,pos-1,n);\\n\\t\\t\\troot->right = solve(preorder,inorder,prestart,pos+1,inend,n);\\n\\n\\t\\t\\treturn root;\\n\\n\\t\\t}\\n\\t\\tTreeNode* buildTree(vector<int>& preorder, vector<int>& inorder) {\\n\\t\\t\\tint n = inorder.size();\\n\\t\\t\\tint preInd = 0;\\n\\t\\t\\tTreeNode *ans = solve(preorder,inorder,preInd,0,n-1,n); //0 = start of inorder , n-1 = end of in\\n\\t\\t\\treturn ans; \\n\\t\\t}\\n\\t};\\n\\n\\tfeel free to ask your doubts :)\\n\\tand pls upvote if it was helpful :)",
                "solutionTags": [
                    "C",
                    "Recursion"
                ],
                "code": "class Solution {\\n\\tpublic:\\n\\t\\tint findPos(vector<int> inorder,int element,int n){\\n\\t\\t\\tfor(int i=0;i<n;i++){\\n\\t\\t\\t\\tif(inorder[i] == element)\\n\\t\\t\\t\\t\\treturn i;\\n\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 1588967,
                "title": "c-easy-recursive-solutions-w-and-w-o-map",
                "content": "Firstly, thanks for refering to my solution :)\\n\\n**Preorder :** ```root->left->right```\\n**Inorder :** ```left->root->right```\\n\\n* So, we start with the 0th index in \\'preorder\\' (Which is always the root of the tree) and search for it in the \\'inorder\\'. \\n* All elements to the left of it in order are in the left subtree and those in the right are in the right subtree.\\n* We recursively use the same idea by decreasing the array length to the left and right parts of the root.\\n\\n**1.** Recursion With Map\\n\\n  **Time Complexity :** O(n)\\n   \\n  **Code :**\\n```\\nclass Solution {\\nprivate:\\n    map<int, int> m;\\npublic:\\n    TreeNode* buildTree(vector<int>& preorder, vector<int>& inorder) {\\n        int n=inorder.size(), p=0;\\n        for(int i=0;i<n;i++) m[inorder[i]] = i;\\n        return makeTree(preorder, inorder, 0, n-1, p);\\n    }\\n    TreeNode* makeTree(vector<int> &pre, vector<int> &in, int l, int r, int &idx){\\n        if(l>r) return NULL;\\n        \\n        TreeNode *root = new TreeNode(pre[idx++]);\\n        \\n        int i=m[root->val];\\n        root->left = makeTree(pre, in, l, i-1, idx);\\n        root->right = makeTree(pre, in, i+1, r, idx);\\n        \\n        return root;\\n        \\n    }\\n};\\n```\\n\\n**2.** Recursion Without Map\\n\\n**Time Complexity :** O(n^2)\\n\\n**Code :**\\n```\\nclass Solution {\\nprivate:\\n    int curr;\\npublic:\\n    TreeNode* buildTree(vector<int>& preorder, vector<int>& inorder) {\\n        int n=inorder.size(), curr=0;\\n        return makeTree(preorder, inorder, 0, n-1);\\n    }\\n    TreeNode* makeTree(vector<int> &pre, vector<int> &in, int l, int r){\\n        if(l>r) return NULL;\\n        int i=find(in.begin(), in.end(), pre[curr]) - in.begin();\\n        TreeNode *root = new TreeNode(in[i]);\\n        \\n        curr--;\\n        root->left = makeTree(pre, in, l, i-1);\\n        root->right = makeTree(pre, in, i+1, r);\\n        \\n        return root;\\n        \\n    }\\n};\\n```\\n\\n**If you like my solution, please upvote!**",
                "solutionTags": [
                    "C++",
                    "C",
                    "Recursion"
                ],
                "code": "```root->left->right```\n```left->root->right```\n```\\nclass Solution {\\nprivate:\\n    map<int, int> m;\\npublic:\\n    TreeNode* buildTree(vector<int>& preorder, vector<int>& inorder) {\\n        int n=inorder.size(), p=0;\\n        for(int i=0;i<n;i++) m[inorder[i]] = i;\\n        return makeTree(preorder, inorder, 0, n-1, p);\\n    }\\n    TreeNode* makeTree(vector<int> &pre, vector<int> &in, int l, int r, int &idx){\\n        if(l>r) return NULL;\\n        \\n        TreeNode *root = new TreeNode(pre[idx++]);\\n        \\n        int i=m[root->val];\\n        root->left = makeTree(pre, in, l, i-1, idx);\\n        root->right = makeTree(pre, in, i+1, r, idx);\\n        \\n        return root;\\n        \\n    }\\n};\\n```\n```\\nclass Solution {\\nprivate:\\n    int curr;\\npublic:\\n    TreeNode* buildTree(vector<int>& preorder, vector<int>& inorder) {\\n        int n=inorder.size(), curr=0;\\n        return makeTree(preorder, inorder, 0, n-1);\\n    }\\n    TreeNode* makeTree(vector<int> &pre, vector<int> &in, int l, int r){\\n        if(l>r) return NULL;\\n        int i=find(in.begin(), in.end(), pre[curr]) - in.begin();\\n        TreeNode *root = new TreeNode(in[i]);\\n        \\n        curr--;\\n        root->left = makeTree(pre, in, l, i-1);\\n        root->right = makeTree(pre, in, i+1, r);\\n        \\n        return root;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1586265,
                "title": "easy-c-iterative-using-stack",
                "content": "While loop puts preorder values onto the stack, compares them to the inorder vector to decide whether to insert it on the left or right or insert a nullptr instead. \\n\\n```TreeNode* buildTree(vector<int>& preorder, vector<int>& inorder) {\\n        \\n        int p_size = preorder.size();\\n        if (p_size == 0){ return nullptr; }\\n        \\n        stack<TreeNode*> tree;\\n        TreeNode* root = new TreeNode(preorder[0]);\\n        tree.push(root);\\n        \\n        int i = 0;\\n        int j = 0;\\n        \\n        while ( i < p_size -1 ){\\n            \\n            TreeNode* p = tree.top();\\n            \\n            if(p->val != inorder[j]){\\n                i++;\\n                p->left = new TreeNode(preorder[i]);\\n                p = p->left;\\n                tree.push(p);\\n                \\n            }else{ \\n                \\n                tree.pop();\\n                j++;\\n                \\n                if (tree.empty() || tree.top()->val != inorder[j]){\\n                    i++;\\n                    p->right = new TreeNode(preorder[i]);\\n                    p = p->right;\\n                    tree.push(p);\\n                }\\n            }\\n        }\\n        \\n        return root;\\n    }```",
                "solutionTags": [
                    "C",
                    "Stack",
                    "Iterator"
                ],
                "code": "```TreeNode* buildTree(vector<int>& preorder, vector<int>& inorder) {\\n        \\n        int p_size = preorder.size();\\n        if (p_size == 0){ return nullptr; }\\n        \\n        stack<TreeNode*> tree;\\n        TreeNode* root = new TreeNode(preorder[0]);\\n        tree.push(root);\\n        \\n        int i = 0;\\n        int j = 0;\\n        \\n        while ( i < p_size -1 ){\\n            \\n            TreeNode* p = tree.top();\\n            \\n            if(p->val != inorder[j]){\\n                i++;\\n                p->left = new TreeNode(preorder[i]);\\n                p = p->left;\\n                tree.push(p);\\n                \\n            }else{ \\n                \\n                tree.pop();\\n                j++;\\n                \\n                if (tree.empty() || tree.top()->val != inorder[j]){\\n                    i++;\\n                    p->right = new TreeNode(preorder[i]);\\n                    p = p->right;\\n                    tree.push(p);\\n                }\\n            }\\n        }\\n        \\n        return root;\\n    }```",
                "codeTag": "Unknown"
            },
            {
                "id": 1385496,
                "title": "c-easy-solution",
                "content": "```\\nunordered_map<int,int> mp;\\n    int preIndex=0;\\n    TreeNode* buildtree(vector<int>& preorder,vector<int>&inorder,int is, int ie)\\n    {\\n        \\n        if(is>ie) return NULL;\\n        \\n        TreeNode* root = new TreeNode (preorder[preIndex++]);\\n        int inIndex = mp[root->val];\\n        \\n        root->left = buildtree(preorder,inorder,is,inIndex-1);\\n        root->right= buildtree(preorder,inorder,inIndex+1,ie);\\n        \\n        return root;\\n        \\n    }\\n    TreeNode* buildTree(vector<int>& preorder, vector<int>& inorder) \\n    {\\n        for(int i=0;i<inorder.size();i++)\\n        {\\n            mp[inorder[i]]=i;\\n        }\\n        return buildtree(preorder,inorder,0,inorder.size()-1);\\n    }\\n```\\nIf you got any help from this, please upvote :)",
                "solutionTags": [],
                "code": "```\\nunordered_map<int,int> mp;\\n    int preIndex=0;\\n    TreeNode* buildtree(vector<int>& preorder,vector<int>&inorder,int is, int ie)\\n    {\\n        \\n        if(is>ie) return NULL;\\n        \\n        TreeNode* root = new TreeNode (preorder[preIndex++]);\\n        int inIndex = mp[root->val];\\n        \\n        root->left = buildtree(preorder,inorder,is,inIndex-1);\\n        root->right= buildtree(preorder,inorder,inIndex+1,ie);\\n        \\n        return root;\\n        \\n    }\\n    TreeNode* buildTree(vector<int>& preorder, vector<int>& inorder) \\n    {\\n        for(int i=0;i<inorder.size();i++)\\n        {\\n            mp[inorder[i]]=i;\\n        }\\n        return buildtree(preorder,inorder,0,inorder.size()-1);\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1373836,
                "title": "why-static-variable-will-give-runtime-error-detailed-answer",
                "content": "Code with use of static variable\\n```\\nclass Solution {\\npublic:\\n    TreeNode* build(vector<int>& pre, vector<int>& in, int s, int e)\\n\\t{\\n        static int idx = 0;\\n        \\n        if(s>e) return NULL;\\n\\t\\t\\n        TreeNode* root = new TreeNode(pre[idx]);\\n        if(idx == 0 and pre.size()==1) return root;\\n\\t\\t\\n        int pos = -1;\\n        for(int i=s;i<=e;i++){\\n            if(in[i] == pre[idx]){\\n                pos = i;\\n                break;\\n            }\\n        }\\n\\t\\t\\n        idx++;\\n        root->left = build(pre,in,s,pos-1);\\n        root->right = build(pre,in,pos+1,e);\\n        \\n        return root;\\n    }\\n\\t\\n    TreeNode* buildTree(vector<int>& preorder, vector<int>& inorder) {\\n        return build(preorder,inorder,0,inorder.size()-1);\\n    }\\n};\\n```\\n**Static variables** are allocated memory **only once during the runtime**. I guess when multiple test cases are executed, the static variable *doesn\\'t start from 0* for each new test case and hence the index goes out of bound for the given preorder vector.\\nTo counter this we could use **Global Variable**. Whenever a new object of the class is declared, the value of the global variable will start with 0. Hence solving the purpose.\\n\\nAccepted Code with global variable\\n```\\nclass Solution {\\n\\tint idx = 0;\\npublic:\\n    TreeNode* build(vector<int>& pre, vector<int>& in, int s, int e)\\n\\t{\\n        if(s>e) return NULL;\\n\\t\\t\\n        TreeNode* root = new TreeNode(pre[idx]);\\n        if(idx == 0 and pre.size()==1) return root;\\n\\t\\t\\n        int pos = -1;\\n        for(int i=s;i<=e;i++){\\n            if(in[i] == pre[idx]){\\n                pos = i;\\n                break;\\n            }\\n        }\\n\\t\\t\\n        idx++;\\n        root->left = build(pre,in,s,pos-1);\\n        root->right = build(pre,in,pos+1,e);\\n        \\n        return root;\\n    }\\n\\t\\n    TreeNode* buildTree(vector<int>& preorder, vector<int>& inorder) {\\n        return build(preorder,inorder,0,inorder.size()-1);\\n    }\\n};\\n```\\nOne could further optimize it using chaching of the inorder array (See the solution tab for the code)\\n\\n***Do give an upvote if you find it helpful***\\n\\n.",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    TreeNode* build(vector<int>& pre, vector<int>& in, int s, int e)\\n\\t{\\n        static int idx = 0;\\n        \\n        if(s>e) return NULL;\\n\\t\\t\\n        TreeNode* root = new TreeNode(pre[idx]);\\n        if(idx == 0 and pre.size()==1) return root;\\n\\t\\t\\n        int pos = -1;\\n        for(int i=s;i<=e;i++){\\n            if(in[i] == pre[idx]){\\n                pos = i;\\n                break;\\n            }\\n        }\\n\\t\\t\\n        idx++;\\n        root->left = build(pre,in,s,pos-1);\\n        root->right = build(pre,in,pos+1,e);\\n        \\n        return root;\\n    }\\n\\t\\n    TreeNode* buildTree(vector<int>& preorder, vector<int>& inorder) {\\n        return build(preorder,inorder,0,inorder.size()-1);\\n    }\\n};\\n```\n```\\nclass Solution {\\n\\tint idx = 0;\\npublic:\\n    TreeNode* build(vector<int>& pre, vector<int>& in, int s, int e)\\n\\t{\\n        if(s>e) return NULL;\\n\\t\\t\\n        TreeNode* root = new TreeNode(pre[idx]);\\n        if(idx == 0 and pre.size()==1) return root;\\n\\t\\t\\n        int pos = -1;\\n        for(int i=s;i<=e;i++){\\n            if(in[i] == pre[idx]){\\n                pos = i;\\n                break;\\n            }\\n        }\\n\\t\\t\\n        idx++;\\n        root->left = build(pre,in,s,pos-1);\\n        root->right = build(pre,in,pos+1,e);\\n        \\n        return root;\\n    }\\n\\t\\n    TreeNode* buildTree(vector<int>& preorder, vector<int>& inorder) {\\n        return build(preorder,inorder,0,inorder.size()-1);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1259640,
                "title": "c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    TreeNode* solve(int prestart, int instart, int inend, vector<int>& preorder, vector<int>& inorder) {\\n        if(prestart > preorder.size()-1 || instart > inend) return NULL;\\n        TreeNode* root = new TreeNode(preorder[prestart]);\\n        int index = 0;\\n        for(int i = instart; i <= inend; i++)\\n            if(root->val == inorder[i]) index = i;\\n            \\n        root->left = solve(prestart+1, instart, index-1, preorder, inorder);\\n        root->right = solve(prestart+index-instart+1, index+1, inend, preorder, inorder);\\n        return root;\\n    }\\n    TreeNode* buildTree(vector<int>& preorder, vector<int>& inorder) {\\n       return solve(0, 0, inorder.size()-1, preorder, inorder);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    TreeNode* solve(int prestart, int instart, int inend, vector<int>& preorder, vector<int>& inorder) {\\n        if(prestart > preorder.size()-1 || instart > inend) return NULL;\\n        TreeNode* root = new TreeNode(preorder[prestart]);\\n        int index = 0;\\n        for(int i = instart; i <= inend; i++)\\n            if(root->val == inorder[i]) index = i;\\n            \\n        root->left = solve(prestart+1, instart, index-1, preorder, inorder);\\n        root->right = solve(prestart+index-instart+1, index+1, inend, preorder, inorder);\\n        return root;\\n    }\\n    TreeNode* buildTree(vector<int>& preorder, vector<int>& inorder) {\\n       return solve(0, 0, inorder.size()-1, preorder, inorder);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1176559,
                "title": "java-recursion-easy-to-understand",
                "content": "```\\nclass Solution {\\n    int pre_start=0;\\n    public TreeNode buildTree(int[] preorder, int[] inorder) {\\n       return buildTree(preorder,inorder,0,inorder.length-1);\\n    }\\n     public TreeNode buildTree(int[] preorder, int[] inorder,int inorder_start,int inorder_end){\\n       if(inorder_start>inorder_end)\\n            return null;\\n        TreeNode temp=new TreeNode(preorder[pre_start++]);\\n        if(inorder_start==inorder_end)\\n            return temp;\\n        int in_index= search(inorder,inorder_start,inorder_end,temp.val);\\n        temp.left=buildTree(preorder,inorder,inorder_start,in_index-1);\\n        temp.right=buildTree(preorder,inorder,in_index+1,inorder_end);\\n        return temp;\\n    }\\n    public int search(int[] arr,int start,int end,int no){\\n    for(int i=start;i<=end;i++)\\n        if(arr[i]==no)\\n            return i;\\n    return -1;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n    int pre_start=0;\\n    public TreeNode buildTree(int[] preorder, int[] inorder) {\\n       return buildTree(preorder,inorder,0,inorder.length-1);\\n    }\\n     public TreeNode buildTree(int[] preorder, int[] inorder,int inorder_start,int inorder_end){\\n       if(inorder_start>inorder_end)\\n            return null;\\n        TreeNode temp=new TreeNode(preorder[pre_start++]);\\n        if(inorder_start==inorder_end)\\n            return temp;\\n        int in_index= search(inorder,inorder_start,inorder_end,temp.val);\\n        temp.left=buildTree(preorder,inorder,inorder_start,in_index-1);\\n        temp.right=buildTree(preorder,inorder,in_index+1,inorder_end);\\n        return temp;\\n    }\\n    public int search(int[] arr,int start,int end,int no){\\n    for(int i=start;i<=end;i++)\\n        if(arr[i]==no)\\n            return i;\\n    return -1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1112147,
                "title": "python-o-n-time-space-with-hashmap",
                "content": "```\\n# Definition for a binary tree node.\\n# class TreeNode(object):\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution(object):\\n    def buildTree(self, preorder, inorder):\\n        \"\"\"\\n        :type preorder: List[int]\\n        :type inorder: List[int]\\n        :rtype: TreeNode\\n        \"\"\"\\n        hashMap = {char : idx for idx, char in enumerate(inorder)}\\n        indx = [0]\\n        \\n        def generate(start, end):\\n            if start > end:\\n                return None\\n            \\n            val = preorder[indx[0]]\\n            mid = hashMap[val]\\n            indx[0] += 1\\n            \\n            root = TreeNode(val)\\n            root.left = generate(start, mid-1)\\n            root.right = generate(mid + 1, end)\\n            \\n            return root\\n        \\n        return generate(0, len(preorder)-1)\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\n# Definition for a binary tree node.\\n# class TreeNode(object):\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution(object):\\n    def buildTree(self, preorder, inorder):\\n        \"\"\"\\n        :type preorder: List[int]\\n        :type inorder: List[int]\\n        :rtype: TreeNode\\n        \"\"\"\\n        hashMap = {char : idx for idx, char in enumerate(inorder)}\\n        indx = [0]\\n        \\n        def generate(start, end):\\n            if start > end:\\n                return None\\n            \\n            val = preorder[indx[0]]\\n            mid = hashMap[val]\\n            indx[0] += 1\\n            \\n            root = TreeNode(val)\\n            root.left = generate(start, mid-1)\\n            root.right = generate(mid + 1, end)\\n            \\n            return root\\n        \\n        return generate(0, len(preorder)-1)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 845633,
                "title": "javascript-faster-than-59-87",
                "content": "*Runtime: 108 ms, faster than 59.87% of JavaScript online submissions for Construct Binary Tree from Preorder and Inorder Traversal.\\nMemory Usage: 41.5 MB, less than 45.30% of JavaScript online submissions for Construct Binary Tree from Preorder and Inorder Traversal.*\\n\\n```javascript\\nvar buildTree = function(preorder, inorder) {\\n    if (!preorder || !inorder) return null;\\n    // get a fast access to the indexes\\n    let memory = new Map();\\n    for (let [i, e] of inorder.entries()) memory.set(e, i);\\n    // keep the current index of inserted nodes to query the preorder\\n    let index = 0;\\n    // build the actual tree\\n    let build = (l, r) => {\\n        if (r < l) return null;\\n        let node = new TreeNode(preorder[index]);\\n        // get the index of this node in the inorder\\n        let i = memory.get(preorder[index]);\\n        // increment index of inserted nodes\\n        index += 1;\\n        // build recursively\\n        node.left = build(l, i - 1);\\n        node.right = build(i + 1, r);\\n        return node;\\n    }\\n    return build(0, preorder.length - 1);\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```javascript\\nvar buildTree = function(preorder, inorder) {\\n    if (!preorder || !inorder) return null;\\n    // get a fast access to the indexes\\n    let memory = new Map();\\n    for (let [i, e] of inorder.entries()) memory.set(e, i);\\n    // keep the current index of inserted nodes to query the preorder\\n    let index = 0;\\n    // build the actual tree\\n    let build = (l, r) => {\\n        if (r < l) return null;\\n        let node = new TreeNode(preorder[index]);\\n        // get the index of this node in the inorder\\n        let i = memory.get(preorder[index]);\\n        // increment index of inserted nodes\\n        index += 1;\\n        // build recursively\\n        node.left = build(l, i - 1);\\n        node.right = build(i + 1, r);\\n        return node;\\n    }\\n    return build(0, preorder.length - 1);\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 683377,
                "title": "java-with-picture",
                "content": "\\n\\nThanks [@jiaming2](https://leetcode.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal/discuss/34538/My-Accepted-Java-Solution)  and [@tding](https://tding.top/archives/101cdf53.html#105-%E4%BB%8E%E5%89%8D%E5%BA%8F%E4%B8%8E%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86%E5%BA%8F%E5%88%97%E6%9E%84%E9%80%A0%E4%BA%8C%E5%8F%89%E6%A0%91)\\n\\n![](https://yyc-images.oss-cn-beijing.aliyuncs.com/leetcode_105_recursion.png)  \\n\\n\\n\\n``` java\\nclass Solution {\\n    public TreeNode buildTree(int[] preorder, int[] inorder) {\\n        \\n        return helper(0, 0, inorder.length - 1, preorder, inorder);\\n    }\\n\\n    public TreeNode helper(int preStart, int inStart, int inEnd, int[] preorder, int[] inorder) {\\n        \\n        // 1. Base case\\n        if (preStart > preorder.length || inStart > inEnd){\\n            return null;\\n        }\\n        \\n        // 2. Build the current node.\\n        TreeNode cur = new TreeNode(preorder[preStart]);\\n        \\n        // 3. Find the pivot in the inorder.\\n        int inPivot = 0;\\n        for (int i = 0; i < inorder.length; i++){\\n            if (inorder[i] == preorder[preStart]){\\n                inPivot = i;\\n                break;\\n            }\\n        }\\n        \\n        // 4. return root.\\n        cur.left  = helper(preStart + 1, inStart, inPivot - 1, preorder, inorder);\\n        // key\\n        cur.right = helper(preStart + inPivot - inStart + 1, inPivot + 1, inEnd, preorder, inorder);\\n        return cur;\\n    }\\n}\\n```\\n\\n`Enjoy it ! `",
                "solutionTags": [],
                "code": "``` java\\nclass Solution {\\n    public TreeNode buildTree(int[] preorder, int[] inorder) {\\n        \\n        return helper(0, 0, inorder.length - 1, preorder, inorder);\\n    }\\n\\n    public TreeNode helper(int preStart, int inStart, int inEnd, int[] preorder, int[] inorder) {\\n        \\n        // 1. Base case\\n        if (preStart > preorder.length || inStart > inEnd){\\n            return null;\\n        }\\n        \\n        // 2. Build the current node.\\n        TreeNode cur = new TreeNode(preorder[preStart]);\\n        \\n        // 3. Find the pivot in the inorder.\\n        int inPivot = 0;\\n        for (int i = 0; i < inorder.length; i++){\\n            if (inorder[i] == preorder[preStart]){\\n                inPivot = i;\\n                break;\\n            }\\n        }\\n        \\n        // 4. return root.\\n        cur.left  = helper(preStart + 1, inStart, inPivot - 1, preorder, inorder);\\n        // key\\n        cur.right = helper(preStart + inPivot - inStart + 1, inPivot + 1, inEnd, preorder, inorder);\\n        return cur;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 593286,
                "title": "c-with-iterators",
                "content": "Some people tend to represent subarrays of an array with a pair of indices. It is perfectly valid, but not very C++. I prefer to work with iterators because of the following reasons:\\n1. Your code becomes more generic. Want to change input type from `std::vector` to `std::set`? You only have to change the wrapper function, not the actual implementation.\\n2. Lots of simple algorithms are already in the STL. Want to find `preorder[0]` in `inorder`? Just call `std::find` with `inorder.begin()` and `inorder.end()`, no need to write a for loop yourself. \\n3. You can use `auto` with iterators, no need to write the typees explicitly. Saves time and boosts genericity.\\n\\n```\\ntemplate <class PreorderIterator, class InorderIterator>\\nTreeNode* buildTree(PreorderIterator pre_first, PreorderIterator pre_last,\\n\\t\\t\\t\\t\\tInorderIterator in_first, InorderIterator in_last) {\\n\\tif (pre_first == pre_last || in_first == in_last)\\n\\t\\treturn nullptr;\\n\\tauto root = new TreeNode(*pre_first);\\n\\tauto in_pivot = find(in_first, in_last, root->val);\\n\\tauto pre_pivot = next(pre_first, 1 + distance(in_first, in_pivot));\\n\\troot->left = buildTree(next(pre_first), pre_pivot, in_first, in_pivot);\\n\\troot->right = buildTree(pre_pivot, pre_last, next(in_pivot), in_last);\\n\\treturn root;\\n}\\n\\nauto buildTree(const vector<int>& preorder, const vector<int>& inorder) {\\n\\treturn buildTree(preorder.begin(), preorder.end(), inorder.begin(), inorder.end());\\n}\\n```",
                "solutionTags": [],
                "code": "```\\ntemplate <class PreorderIterator, class InorderIterator>\\nTreeNode* buildTree(PreorderIterator pre_first, PreorderIterator pre_last,\\n\\t\\t\\t\\t\\tInorderIterator in_first, InorderIterator in_last) {\\n\\tif (pre_first == pre_last || in_first == in_last)\\n\\t\\treturn nullptr;\\n\\tauto root = new TreeNode(*pre_first);\\n\\tauto in_pivot = find(in_first, in_last, root->val);\\n\\tauto pre_pivot = next(pre_first, 1 + distance(in_first, in_pivot));\\n\\troot->left = buildTree(next(pre_first), pre_pivot, in_first, in_pivot);\\n\\troot->right = buildTree(pre_pivot, pre_last, next(in_pivot), in_last);\\n\\treturn root;\\n}\\n\\nauto buildTree(const vector<int>& preorder, const vector<int>& inorder) {\\n\\treturn buildTree(preorder.begin(), preorder.end(), inorder.begin(), inorder.end());\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 508823,
                "title": "java-recursive-solution-with-explanation",
                "content": "Given the following examples:\\n```\\npreorder: [3,1,2,4,20,15,31,7]\\ninorder: [2,4,1,3,15,31,20,7]\\n```\\n\\nWe want to construct a binary tree that gives us those results.  We start by the first element in the `preorder` array that has to \\nrepresent the `root`.\\n\\nNow, by iterating the `inorder` array we can tell what nodes go to the left of the `root`, and what nodes belong to the right of the `root`.\\n\\nSo, `in:[2,4,1]` is left of parent `3`, and `in:[15,31,20,7]` are right from parent.\\n\\n\\n\\nBy doing this recursivley, it allows us to break the arrays into smaller chunks and decide at each iteration what where the current node belongs to. Or left child, or right.\\n\\nFor more clarification, ping me.\\n\\nGood luck!\\n\\n\\n```\\npublic TreeNode buildTree(int[] preorder, int[] inorder) {\\n        return buildTree(preorder, inorder, 0, preorder.length, 0, inorder.length);\\n}\\n\\npublic TreeNode buildTree(int[] preorder, int[] inorder, int i1, int j1, int i2, int j2) {\\n\\tif (i1 >= j1) return null;\\n\\tif (i2 >= j2) return null;\\n\\n\\tint counter = 0;\\n\\n\\twhile (preorder[i1] != inorder[i2+counter]) {\\n\\t\\tcounter++; \\n\\t\\tif (i2+counter >= inorder.length) break;\\n\\t}\\n\\n\\tTreeNode res = new TreeNode(preorder[i1]);\\n\\n\\tres.left = buildTree(preorder, inorder, i1+1, i1+counter+1, i2, i2+counter);\\n\\tres.right = buildTree(preorder, inorder, i1+counter+1, j1, i2+counter+1, j2);\\n\\n\\treturn res;\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npreorder: [3,1,2,4,20,15,31,7]\\ninorder: [2,4,1,3,15,31,20,7]\\n```\n```\\npublic TreeNode buildTree(int[] preorder, int[] inorder) {\\n        return buildTree(preorder, inorder, 0, preorder.length, 0, inorder.length);\\n}\\n\\npublic TreeNode buildTree(int[] preorder, int[] inorder, int i1, int j1, int i2, int j2) {\\n\\tif (i1 >= j1) return null;\\n\\tif (i2 >= j2) return null;\\n\\n\\tint counter = 0;\\n\\n\\twhile (preorder[i1] != inorder[i2+counter]) {\\n\\t\\tcounter++; \\n\\t\\tif (i2+counter >= inorder.length) break;\\n\\t}\\n\\n\\tTreeNode res = new TreeNode(preorder[i1]);\\n\\n\\tres.left = buildTree(preorder, inorder, i1+1, i1+counter+1, i2, i2+counter);\\n\\tres.right = buildTree(preorder, inorder, i1+counter+1, j1, i2+counter+1, j2);\\n\\n\\treturn res;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 497847,
                "title": "easy-understand-python-solution",
                "content": "class Solution(object):\\n\\n    def buildTree(self, preorder, inorder):\\n        \"\"\"\\n        :type preorder: List[int]\\n        :type inorder: List[int]\\n        :rtype: TreeNode\\n        \"\"\"\\n        if len(preorder) == 0:\\n            return None\\n            \\n        root = TreeNode(preorder[0])\\n        i = inorder.index(preorder.pop(0))\\n        root.left = self.buildTree(preorder[:i],inorder[:i])\\n        root.right = self.buildTree(preorder[i:],inorder[i+1:])\\n        return root\\n",
                "solutionTags": [],
                "code": "class Solution(object):\\n\\n    def buildTree(self, preorder, inorder):\\n        \"\"\"\\n        :type preorder: List[int]\\n        :type inorder: List[int]\\n        :rtype: TreeNode\\n        \"\"\"\\n        if len(preorder) == 0:\\n            return None\\n            \\n        root = TreeNode(preorder[0])\\n        i = inorder.index(preorder.pop(0))\\n        root.left = self.buildTree(preorder[:i],inorder[:i])\\n        root.right = self.buildTree(preorder[i:],inorder[i+1:])\\n        return root\\n",
                "codeTag": "Java"
            },
            {
                "id": 430519,
                "title": "python-simple-straightforward-recursive-solution-o-n",
                "content": "```\\n# Definition for a binary tree node.\\n# class TreeNode(object):\\n#     def __init__(self, x):\\n#         self.val = x\\n#         self.left = None\\n#         self.right = None\\n\\nclass Solution(object):\\n    def buildTree(self, preorder, inorder):\\n        \"\"\"\\n        :type preorder: List[int]\\n        :type inorder: List[int]\\n        :rtype: TreeNode\\n        \"\"\"\\n        if len(inorder) == 0:\\n            return None\\n        rootIdxIntoInorder = inorder.index(preorder[0])\\n        root = TreeNode(preorder[0])\\n        root.left = self.buildTree(preorder[1:], inorder[:rootIdxIntoInorder])\\n        root.right = self.buildTree(preorder[rootIdxIntoInorder + 1:], inorder[rootIdxIntoInorder + 1:])\\n        return root\\n```",
                "solutionTags": [
                    "Python",
                    "Recursion"
                ],
                "code": "```\\n# Definition for a binary tree node.\\n# class TreeNode(object):\\n#     def __init__(self, x):\\n#         self.val = x\\n#         self.left = None\\n#         self.right = None\\n\\nclass Solution(object):\\n    def buildTree(self, preorder, inorder):\\n        \"\"\"\\n        :type preorder: List[int]\\n        :type inorder: List[int]\\n        :rtype: TreeNode\\n        \"\"\"\\n        if len(inorder) == 0:\\n            return None\\n        rootIdxIntoInorder = inorder.index(preorder[0])\\n        root = TreeNode(preorder[0])\\n        root.left = self.buildTree(preorder[1:], inorder[:rootIdxIntoInorder])\\n        root.right = self.buildTree(preorder[rootIdxIntoInorder + 1:], inorder[rootIdxIntoInorder + 1:])\\n        return root\\n```",
                "codeTag": "Java"
            },
            {
                "id": 413214,
                "title": "python-recursive-solutions",
                "content": "Core ideas for these recursive solution:\\n* Preorder traversal: `root [left child] [right child]`\\n* Inorder traversal: `[left child] root [right child]`\\n* It\\'s easy to find the root in `preorder` since it always comes first and the left child always on the left of root in `inorder`\\n\\n\\n**Solution 1: List Slicing**\\n* It doesn\\'t matter to construct left or right child first\\n```\\nclass Solution:\\n    def buildTree(self, preorder: List[int], inorder: List[int]) -> TreeNode:\\n        if not inorder and not preorder:\\n            return None\\n\\n        root = TreeNode(preorder[0])\\n        idx = inorder.index(preorder[0])\\n        root.left = self.buildTree(preorder[1:idx+1], inorder[:idx])\\n        root.right = self.buildTree(preorder[idx+1:], inorder[idx+1:])\\n        return root\\n```\\n\\n**Solution 2: Pop**\\n* Left child must be constructed first since it\\'s closer to root than its right counterpart\\n```\\nclass Solution:\\n    def buildTree(self, preorder: List[int], inorder: List[int]) -> TreeNode:\\n        if not inorder:\\n            return None\\n        \\n        root = TreeNode(preorder.pop(0))\\n        idx = inorder.index(root.val)\\n        root.left = self.buildTree(preorder, inorder[:idx])\\n        root.right = self.buildTree(preorder, inorder[idx+1:])\\n        return root\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def buildTree(self, preorder: List[int], inorder: List[int]) -> TreeNode:\\n        if not inorder and not preorder:\\n            return None\\n\\n        root = TreeNode(preorder[0])\\n        idx = inorder.index(preorder[0])\\n        root.left = self.buildTree(preorder[1:idx+1], inorder[:idx])\\n        root.right = self.buildTree(preorder[idx+1:], inorder[idx+1:])\\n        return root\\n```\n```\\nclass Solution:\\n    def buildTree(self, preorder: List[int], inorder: List[int]) -> TreeNode:\\n        if not inorder:\\n            return None\\n        \\n        root = TreeNode(preorder.pop(0))\\n        idx = inorder.index(root.val)\\n        root.left = self.buildTree(preorder, inorder[:idx])\\n        root.right = self.buildTree(preorder, inorder[idx+1:])\\n        return root\\n```",
                "codeTag": "Java"
            },
            {
                "id": 267763,
                "title": "golang",
                "content": "```\\nfunc buildTree(preorder []int, inorder []int) *TreeNode {\\n\\tif len(preorder) == 0 {\\n\\t\\treturn nil\\n\\t}\\n\\n\\tindex := search(preorder[0], inorder)\\n\\tnode := &TreeNode{\\n\\t\\tVal:   preorder[0],\\n\\t\\tLeft:  buildTree(preorder[1:1+index], inorder[:index]),\\n\\t\\tRight: buildTree(preorder[1+index:], inorder[index+1:]),\\n\\t}\\n\\n\\treturn node\\n}\\n\\nfunc search(val int, array []int) int {\\n\\tfor i := 0; i < len(array); i++ {\\n\\t\\tif val == array[i] {\\n\\t\\t\\treturn i\\n\\t\\t}\\n\\t}\\n\\n\\treturn 0\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nfunc buildTree(preorder []int, inorder []int) *TreeNode {\\n\\tif len(preorder) == 0 {\\n\\t\\treturn nil\\n\\t}\\n\\n\\tindex := search(preorder[0], inorder)\\n\\tnode := &TreeNode{\\n\\t\\tVal:   preorder[0],\\n\\t\\tLeft:  buildTree(preorder[1:1+index], inorder[:index]),\\n\\t\\tRight: buildTree(preorder[1+index:], inorder[index+1:]),\\n\\t}\\n\\n\\treturn node\\n}\\n\\nfunc search(val int, array []int) int {\\n\\tfor i := 0; i < len(array); i++ {\\n\\t\\tif val == array[i] {\\n\\t\\t\\treturn i\\n\\t\\t}\\n\\t}\\n\\n\\treturn 0\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 244094,
                "title": "c-recursive-beats-100-with-explanation",
                "content": "The idea is similar to binary search; \\n\\n1. We know preorder[0] is root;\\n2. Search preorder[0] in inorder and get the index x;\\n3. Find left in 0 to x-1, if left exists it shoud be preorder[0+1];(preorder);\\n4. Find right in x+1 to end, if right exists it shoud be preorder[0+x-0+1];(preorder);\\n\\nrepeat \\n\\n* x-0 = numberof nodes in left suntree;\\n* 0 + x-0 + 1 = index of next right node in prev order(if exist);s solution is the same as the most voted discussion.\\n\\n```\\npublic class Solution {\\n  public TreeNode BuildTree(int[] preorder, int[] inorder) {\\n\\n    return Helper(preorder, inorder,0, inorder.Length-1, 0);\\n  }\\n\\n\\n  public TreeNode Helper(int[] preorder, int[] inorder, int inStart, int inEnd, int prevStart)\\n  {\\n      if(prevStart >= preorder.Length || inStart > inEnd) return null;\\n\\n\\n      var inIndex = 0;\\n      for(int i=inStart;i<=inEnd;i++)\\n      {\\n        if(inorder[i] == preorder[prevStart]) inIndex = i;  \\n      }\\n      var root = new TreeNode(preorder[prevStart]);\\n\\n      root.left = Helper(preorder,inorder, inStart, inIndex-1,prevStart+1);\\n      root.right = Helper(preorder,inorder, inIndex+1, inEnd,prevStart+inIndex-inStart+1);\\n      \\n      return root;\\n  }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n  public TreeNode BuildTree(int[] preorder, int[] inorder) {\\n\\n    return Helper(preorder, inorder,0, inorder.Length-1, 0);\\n  }\\n\\n\\n  public TreeNode Helper(int[] preorder, int[] inorder, int inStart, int inEnd, int prevStart)\\n  {\\n      if(prevStart >= preorder.Length || inStart > inEnd) return null;\\n\\n\\n      var inIndex = 0;\\n      for(int i=inStart;i<=inEnd;i++)\\n      {\\n        if(inorder[i] == preorder[prevStart]) inIndex = i;  \\n      }\\n      var root = new TreeNode(preorder[prevStart]);\\n\\n      root.left = Helper(preorder,inorder, inStart, inIndex-1,prevStart+1);\\n      root.right = Helper(preorder,inorder, inIndex+1, inEnd,prevStart+inIndex-inStart+1);\\n      \\n      return root;\\n  }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 193566,
                "title": "simple-javascript-solution-with-comments",
                "content": "```\\n// this solution manipulates the preorder variable itself and uses the inorder variable to keep track of when to stop the recursive calls\\n\\nvar buildTree = function(preorder, inorder) {\\n\\tif (!inorder.length) {\\n\\t\\treturn null;\\n\\t}\\n    \\n\\tvar root = new TreeNode(preorder.shift());\\n\\tvar inorderIndex = inorder.indexOf(root.val);\\n    \\n\\t// divide the inorder list into left side\\n\\troot.left = buildTree(preorder, inorder.slice(0, inorderIndex));\\n\\t// divide the inorder list into right side\\n\\troot.right = buildTree(preorder, inorder.slice(inorderIndex+1));\\n    \\n\\treturn root;\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n// this solution manipulates the preorder variable itself and uses the inorder variable to keep track of when to stop the recursive calls\\n\\nvar buildTree = function(preorder, inorder) {\\n\\tif (!inorder.length) {\\n\\t\\treturn null;\\n\\t}\\n    \\n\\tvar root = new TreeNode(preorder.shift());\\n\\tvar inorderIndex = inorder.indexOf(root.val);\\n    \\n\\t// divide the inorder list into left side\\n\\troot.left = buildTree(preorder, inorder.slice(0, inorderIndex));\\n\\t// divide the inorder list into right side\\n\\troot.right = buildTree(preorder, inorder.slice(inorderIndex+1));\\n    \\n\\treturn root;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 34604,
                "title": "1ms-java-recursive-solution-beats-99-83",
                "content": "    public TreeNode buildTree(int[] preorder, int[] inorder) {\\n            return buildTree(preorder, 0, inorder, inorder.length - 1, 0);\\n        }\\n        \\n        private TreeNode buildTree(int[] preorder, int idx, int[] inorder, int end, int start) {\\n            if (idx >= preorder.length || start > end) {\\n                return null;\\n            }\\n            TreeNode root = new TreeNode(preorder[idx]);\\n            int i;\\n            for (i = end; i >= start; i--) {\\n                if (preorder[idx] == inorder[i]) {\\n                    break;\\n                }\\n            }\\n            root.left = buildTree(preorder, idx + 1, inorder, i - 1, start);\\n            root.right = buildTree(preorder, idx + i - start + 1, inorder, end, i+1);\\n            return root;\\n        }",
                "solutionTags": [],
                "code": "    public TreeNode buildTree(int[] preorder, int[] inorder) {\\n            return buildTree(preorder, 0, inorder, inorder.length - 1, 0);\\n        }\\n        \\n        private TreeNode buildTree(int[] preorder, int idx, int[] inorder, int end, int start) {\\n            if (idx >= preorder.length || start > end) {\\n                return null;\\n            }\\n            TreeNode root = new TreeNode(preorder[idx]);\\n            int i;\\n            for (i = end; i >= start; i--) {\\n                if (preorder[idx] == inorder[i]) {\\n                    break;\\n                }\\n            }\\n            root.left = buildTree(preorder, idx + 1, inorder, i - 1, start);\\n            root.right = buildTree(preorder, idx + i - start + 1, inorder, end, i+1);\\n            return root;\\n        }",
                "codeTag": "Unknown"
            },
            {
                "id": 34716,
                "title": "share-my-recursive-and-iterative-python-solutions-o-n-70-ms",
                "content": "Both solutions use dictionary to create mapping between value and index of in-order traversal.\\n\\nRecursive one: use deque for efficient popleft()\\n\\n    from collections import deque\\n    class Solution:\\n        # @param {integer[]} preorder\\n        # @param {integer[]} inorder\\n        # @return {TreeNode}\\n        def buildTree(self, preorder, inorder):\\n            def _buildTreeHelper(preorder, inorder, start, end, inorderMapping):\\n                # escape condition\\n                if start > end:\\n                    return None\\n    \\n                # root is the first one in pre-order\\n                root = TreeNode(preorder.popleft())\\n                # get root's index in in-order\\n                index = inorderMapping[root.val]\\n                # build left / right sub-trees\\n                root.left = _buildTreeHelper(preorder, inorder, start, index-1, inorderMapping)\\n                root.right = _buildTreeHelper(preorder, inorder, index+1, end, inorderMapping)\\n                return root\\n    \\n            # generate mapping from value to index\\n            inorderMapping = {inorder[index] : index for index in range(len(inorder))}\\n            preorder = deque(preorder)\\n            return _buildTreeHelper(preorder, inorder, 0, len(inorder)-1, inorderMapping)\\n\\nIterative one: I could use deque too. Instead, I just reverse inorder and use pop() instead of pop(0)\\nUse stack to store start / end index of inorder, as well as parent and indicator of left child or right child.\\n\\n    class Solution:\\n        # @param {integer[]} preorder\\n        # @param {integer[]} inorder\\n        # @return {TreeNode}\\n        def buildTree(self, preorder, inorder):\\n            dummy = TreeNode(0)\\n            if inorder:\\n                # generate mapping from value to index\\n                inorderMapping = {inorder[index] : index for index in range(len(inorder))}\\n                preorder = preorder[::-1]\\n                stack = [(0, len(inorder)-1, dummy, True)]\\n                while stack:\\n                    start, end, parent, left = stack.pop()\\n                    node = TreeNode(preorder.pop())\\n                    if left:\\n                        parent.left = node\\n                    else:\\n                        parent.right = node\\n                    index = inorderMapping[node.val]\\n                    if index < end:\\n                        stack.append((index+1, end, node, False))\\n                    if index > start:\\n                        stack.append((start, index-1, node, True))\\n    \\n            return dummy.left",
                "solutionTags": [
                    "Python",
                    "Recursion",
                    "Iterator"
                ],
                "code": "class Solution:\\n        # @param {integer[]}",
                "codeTag": "Java"
            },
            {
                "id": 3853582,
                "title": "recursion-c-easy-to-understand",
                "content": "# Intuition : First take a node from preorder, We know that for pre order traversal D-L-R and for inorder L-D-R. \\nFor this we have to build a tree according to preorder traversal one by one (by making that element as pivot) and by using inorder we have to find how many elements are left or right to that pivot element accordingly.\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach : Simple Recursion \\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: \\n- 1) For making a tree in recursive function we\\'ll required O(n).\\n- 2) For finding element in inorder traversal we\\'ll required again O(n).\\n- Overall Complexity will be O(n^2)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int find(vector<int>& inorder, int k) {\\n        for (int i = 0; i < inorder.size(); i++) if (inorder[i] == k) return i;\\n        return -1;\\n    }\\n\\n    TreeNode* buildTree(vector<int>& preorder, vector<int>& inorder) {\\n        int preIndex = 0, inStart = 0, inend = inorder.size() - 1;\\n        return build(preorder, inorder, preIndex, inStart, inend);\\n    }\\n\\n    TreeNode* build(vector<int>& preorder, vector<int>& inorder, int& preIndex, int inStart, int inend) {\\n        if (inStart > inend) {\\n            return NULL;\\n        }\\n\\n        int ele = preorder[preIndex++];\\n        TreeNode* root = new TreeNode(ele);\\n        int pos_in_inorder = find(inorder, ele);\\n\\n        root->left = build(preorder, inorder, preIndex, inStart, pos_in_inorder - 1);\\n        root->right = build(preorder, inorder, preIndex, pos_in_inorder + 1, inend);\\n        return root;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int find(vector<int>& inorder, int k) {\\n        for (int i = 0; i < inorder.size(); i++) if (inorder[i] == k) return i;\\n        return -1;\\n    }\\n\\n    TreeNode* buildTree(vector<int>& preorder, vector<int>& inorder) {\\n        int preIndex = 0, inStart = 0, inend = inorder.size() - 1;\\n        return build(preorder, inorder, preIndex, inStart, inend);\\n    }\\n\\n    TreeNode* build(vector<int>& preorder, vector<int>& inorder, int& preIndex, int inStart, int inend) {\\n        if (inStart > inend) {\\n            return NULL;\\n        }\\n\\n        int ele = preorder[preIndex++];\\n        TreeNode* root = new TreeNode(ele);\\n        int pos_in_inorder = find(inorder, ele);\\n\\n        root->left = build(preorder, inorder, preIndex, inStart, pos_in_inorder - 1);\\n        root->right = build(preorder, inorder, preIndex, pos_in_inorder + 1, inend);\\n        return root;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3835872,
                "title": "easy-to-understand-solution-in-java-using-recursion-beats-100",
                "content": "\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    public TreeNode buildTree(int[] preorder, int[] inorder) {\\n        HashMap<Integer,Integer>  map = new HashMap();\\n        for(int i=0;i<inorder.length;i++)\\n        {\\n            map.put(inorder[i],i);\\n        }\\n        return rec(map,preorder,0,preorder.length-1,inorder,0,inorder.length-1);\\n    }\\n\\n    TreeNode rec(HashMap<Integer,Integer> map, int[] preorder,int preStart, int preEnd, int[] inorder , int inStart, int inEnd)\\n    {\\n        if(preStart>preEnd || inStart >inEnd) return null;\\n        int index = map.get(preorder[preStart]);\\n        int numsLeft = index-inStart;\\n        TreeNode root= new TreeNode(preorder[preStart]);\\n\\n        root.left = rec(map,preorder, preStart+1, preStart+numsLeft, inorder, inStart, index-1);\\n\\n        root.right =  rec(map ,preorder, preStart+numsLeft+1,preEnd,inorder,index+1,inEnd);\\n        return root;\\n\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    public TreeNode buildTree(int[] preorder, int[] inorder) {\\n        HashMap<Integer,Integer>  map = new HashMap();\\n        for(int i=0;i<inorder.length;i++)\\n        {\\n            map.put(inorder[i],i);\\n        }\\n        return rec(map,preorder,0,preorder.length-1,inorder,0,inorder.length-1);\\n    }\\n\\n    TreeNode rec(HashMap<Integer,Integer> map, int[] preorder,int preStart, int preEnd, int[] inorder , int inStart, int inEnd)\\n    {\\n        if(preStart>preEnd || inStart >inEnd) return null;\\n        int index = map.get(preorder[preStart]);\\n        int numsLeft = index-inStart;\\n        TreeNode root= new TreeNode(preorder[preStart]);\\n\\n        root.left = rec(map,preorder, preStart+1, preStart+numsLeft, inorder, inStart, index-1);\\n\\n        root.right =  rec(map ,preorder, preStart+numsLeft+1,preEnd,inorder,index+1,inEnd);\\n        return root;\\n\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3646845,
                "title": "construct-a-binary-tree-from-preorder-and-inorder-traversal-c",
                "content": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    TreeNode* buildTree(vector<int>& preorder, vector<int>& inorder) {\\n        map<int,int> mp;\\n        for(int i=0;i<inorder.size();i++){\\n            mp[inorder[i]] = i;\\n        }\\n        \\n        TreeNode* root = solve(preorder,0,preorder.size()-1,\\n                              inorder, 0, inorder.size()-1, mp);\\n        \\n        return root;\\n    }\\n    \\n    TreeNode* solve(vector<int> &preorder,int pStart,int pEnd,\\n                              vector<int> &inorder,int iStart, int iEnd,map<int,int> mp){\\n        if(pStart>pEnd || iStart>iEnd)\\n            return NULL;\\n        \\n        TreeNode* root = new TreeNode(preorder[pStart]);\\n        int inRoot = mp[root->val];\\n        int numsLeft = inRoot - iStart;\\n        \\n        root->left = solve(preorder,pStart+1,pStart+numsLeft,\\n                          inorder,iStart,inRoot-1,mp);\\n        root->right = solve(preorder,pStart+numsLeft+1,pEnd,\\n                          inorder,inRoot+1,iEnd,mp);\\n        \\n        return root;\\n        \\n    }\\n};\\n```\\n\\n**Please upvote!! if you like**\\ncomment below!\\uD83D\\uDC47",
                "solutionTags": [
                    "C",
                    "Recursion",
                    "Binary Tree"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    TreeNode* buildTree(vector<int>& preorder, vector<int>& inorder) {\\n        map<int,int> mp;\\n        for(int i=0;i<inorder.size();i++){\\n            mp[inorder[i]] = i;\\n        }\\n        \\n        TreeNode* root = solve(preorder,0,preorder.size()-1,\\n                              inorder, 0, inorder.size()-1, mp);\\n        \\n        return root;\\n    }\\n    \\n    TreeNode* solve(vector<int> &preorder,int pStart,int pEnd,\\n                              vector<int> &inorder,int iStart, int iEnd,map<int,int> mp){\\n        if(pStart>pEnd || iStart>iEnd)\\n            return NULL;\\n        \\n        TreeNode* root = new TreeNode(preorder[pStart]);\\n        int inRoot = mp[root->val];\\n        int numsLeft = inRoot - iStart;\\n        \\n        root->left = solve(preorder,pStart+1,pStart+numsLeft,\\n                          inorder,iStart,inRoot-1,mp);\\n        root->right = solve(preorder,pStart+numsLeft+1,pEnd,\\n                          inorder,inRoot+1,iEnd,mp);\\n        \\n        return root;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3646058,
                "title": "c-easiest-recursive-solution",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    TreeNode* construct(int prestart,int preend, vector<int> &preorder, int instart, int inend, vector<int> &inorder, map<int,int> &mp){\\n        if(prestart>preend || instart>inend) return NULL;\\n        TreeNode* root=new TreeNode(preorder[prestart]);\\n        int root_idx=mp[root->val];\\n        int nelements=root_idx-instart;\\n        root->left=construct(prestart+1,prestart+nelements,preorder,instart,root_idx-1,inorder,mp);\\n        root->right=construct(prestart+nelements+1,preend,preorder,root_idx+1,inend,inorder,mp);\\n        return root;\\n    }\\n    TreeNode* buildTree(vector<int>& preorder, vector<int>& inorder) {\\n        map<int,int> mp;\\n        for(int i=0;i<inorder.size();i++) mp[inorder[i]]=i;\\n        TreeNode* root= construct(0,preorder.size()-1,preorder,0,inorder.size()-1,inorder,mp);\\n        return root;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    TreeNode* construct(int prestart,int preend, vector<int> &preorder, int instart, int inend, vector<int> &inorder, map<int,int> &mp){\\n        if(prestart>preend || instart>inend) return NULL;\\n        TreeNode* root=new TreeNode(preorder[prestart]);\\n        int root_idx=mp[root->val];\\n        int nelements=root_idx-instart;\\n        root->left=construct(prestart+1,prestart+nelements,preorder,instart,root_idx-1,inorder,mp);\\n        root->right=construct(prestart+nelements+1,preend,preorder,root_idx+1,inend,inorder,mp);\\n        return root;\\n    }\\n    TreeNode* buildTree(vector<int>& preorder, vector<int>& inorder) {\\n        map<int,int> mp;\\n        for(int i=0;i<inorder.size();i++) mp[inorder[i]]=i;\\n        TreeNode* root= construct(0,preorder.size()-1,preorder,0,inorder.size()-1,inorder,mp);\\n        return root;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3614388,
                "title": "easy-recursive-solution-using-hashmap-c-best-simple",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n* first appoach is just to think \\uD83E\\uDD14 how you can find it is root eleement and how many nodes come on left side and how many child node belongs to its right now follow this approch for each node\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n* we know that first element of \\'PREORDER\\' is root of the tree and now \\n* you need to find the place of root element in \\'INORDER\\'  \\n* if we normally traverse in array to find place of root element then it take $$o(n)$$  time so for get this information in $$o(1)$$ we use unordered map\\n* and now use recurstion bcz every element is root for its child \\uD83E\\uDDD2 \\n* so call recursion to do make left tree and right  by passing  information\\n* like you do for next preorder element  and by telling them to find in small inverval for left \\uD83D\\uDC48 and right \\uD83D\\uDC49 tree\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->$$O(n)$$\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->$$O(n)$$\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\nTreeNode * build(unordered_map<int,int>&mp,vector<int>&pre,int &nd,int s,int e)\\n{\\n    \\n    TreeNode* node  = new TreeNode(pre[nd]);\\n\\n    int ind  = mp[pre[nd]];\\n    nd++;\\n      if(s==e)return node;\\n      if(nd<pre.size()&&s<=ind-1)\\n    node->left = build(mp,pre,nd,s,ind-1);\\n    if(nd<pre.size()&&ind+1<=e)\\n    node->right = build(mp,pre,nd,ind+1,e);\\n    return node;\\n}\\n    TreeNode* buildTree(vector<int>& pre, vector<int>& in) {\\n  unordered_map<int,int>mp;\\n    for(int i=0;i<in.size();i++)\\n    mp[in[i]]=i;\\n\\n    int x=0;\\n     return build(mp,pre,x,0,in.size()-1);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Tree",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\nTreeNode * build(unordered_map<int,int>&mp,vector<int>&pre,int &nd,int s,int e)\\n{\\n    \\n    TreeNode* node  = new TreeNode(pre[nd]);\\n\\n    int ind  = mp[pre[nd]];\\n    nd++;\\n      if(s==e)return node;\\n      if(nd<pre.size()&&s<=ind-1)\\n    node->left = build(mp,pre,nd,s,ind-1);\\n    if(nd<pre.size()&&ind+1<=e)\\n    node->right = build(mp,pre,nd,ind+1,e);\\n    return node;\\n}\\n    TreeNode* buildTree(vector<int>& pre, vector<int>& in) {\\n  unordered_map<int,int>mp;\\n    for(int i=0;i<in.size();i++)\\n    mp[in[i]]=i;\\n\\n    int x=0;\\n     return build(mp,pre,x,0,in.size()-1);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3527625,
                "title": "solution-with-explanation-c-java",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nPreorder traversal:$$ \\\\hspace{0.1cm}root --> left \\\\hspace{0.1cm} subtree --> right \\\\hspace{0.1cm} subtree $$\\nInorder traversal:$$ \\\\hspace{0.1cm}left \\\\hspace{0.1cm} subtree --> root --> right \\\\hspace{0.1cm} subtree $$\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n> In preorder array, start index is the root node.\\n\\nIn preorder the start index is the root node, so create the node and find that key index in inorder array, let\\'s say that index is `inorder_index`.\\nEvery element in inorder array to the left of inorder_index is part of left sub-tree. And every element to the right of inorder_index is part of right sub-tree.\\nCall recursion on both left and right sub-tree.\\n\\nNote: Dry run the solution once for better understanding.\\n\\n# Optimizations\\n- Use hashmap to find `inorder_index`.\\n- Pass start and end index of arrays as parameters.\\n\\n# Common errors\\n- Calculating start and end index of preorder array, for left and right subtree.\\n- Handling base case.\\n\\n# Complexity\\nLength of array or number of nodes in tree is $$ n $$.\\n- Time complexity: $$ O(n) $$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n    $$ Worst \\\\hspace{0.2cm} case: O(n) $$\\n    $$ Best \\\\hspace{0.2cm} case: O(log_2n) $$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n\\n```C++ []\\nclass Solution {\\nprivate:\\n    map<int, int> m;\\n\\n    TreeNode* helper(vector<int>& preorder, int ps, int pe, vector<int>& inorder, int is, int ie) {\\n        if (ps > pe || is > ie || ps >= preorder.size() || pe >= preorder.size() || ps < 0 || pe < 0) {\\n            return NULL;\\n        }\\n\\n        TreeNode* newNode = new TreeNode(preorder[ps]);\\n\\n        int inorder_index = m[preorder[ps]];\\n        int left_size = inorder_index - is;\\n        \\n\\n        TreeNode* left = helper(preorder, ps + 1, ps + left_size, inorder, is, inorder_index - 1);\\n        TreeNode* right = helper(preorder, ps + left_size + 1, pe, inorder, inorder_index + 1, ie);\\n\\n        newNode->left = left;\\n        newNode->right = right;\\n        return newNode;\\n    }\\npublic:\\n    TreeNode* buildTree(vector<int>& preorder, vector<int>& inorder) {\\n        int n = inorder.size();\\n        if (n == 0) return NULL;\\n        for (int i = 0; i < n; ++i) {\\n            m[inorder[i]] = i;\\n        }\\n        return helper(preorder, 0, n - 1, inorder, 0, n - 1);\\n    }\\n};\\n```\\n```Java []\\nclass Solution {\\n\\n    HashMap<Integer, Integer> map = new HashMap<>();\\n\\n    TreeNode helper(int[] preorder, int[] inorder, int pS, int pE, int iS, int iE) {\\n        if (iS > iE || iS < 0 || iS >= inorder.length || iE < 0 || iE >= inorder.length) {\\n            return null;\\n        }\\n        if (pS >= preorder.length || pE >= preorder.length || pS > pE) {\\n            return null;\\n        }\\n\\n        TreeNode root = new TreeNode(preorder[pS]);\\n\\n        int inIndex = map.get(preorder[pS]);\\n        int size = inIndex - iS;\\n\\n        TreeNode left = helper(preorder, inorder, pS + 1, pS + size, iS, inIndex - 1);\\n        TreeNode right = helper(preorder, inorder, pS + size + 1, pE, inIndex + 1, iE);\\n\\n        root.left = left;\\n        root.right = right;\\n        return root;\\n    }\\n\\n    public TreeNode buildTree(int[] preorder, int[] inorder) {\\n        int n = preorder.length;\\n        if (n == 0) return null;\\n        for (int i = 0; i < n; ++i) {\\n            map.put(inorder[i], i);\\n        }\\n        return helper(preorder, inorder, 0, n - 1, 0, n - 1);\\n    }\\n}\\n```\\n\\n**Will you upvote if you like the solution?**",
                "solutionTags": [
                    "Array",
                    "Hash Table",
                    "Divide and Conquer",
                    "Tree",
                    "Binary Tree"
                ],
                "code": "```C++ []\\nclass Solution {\\nprivate:\\n    map<int, int> m;\\n\\n    TreeNode* helper(vector<int>& preorder, int ps, int pe, vector<int>& inorder, int is, int ie) {\\n        if (ps > pe || is > ie || ps >= preorder.size() || pe >= preorder.size() || ps < 0 || pe < 0) {\\n            return NULL;\\n        }\\n\\n        TreeNode* newNode = new TreeNode(preorder[ps]);\\n\\n        int inorder_index = m[preorder[ps]];\\n        int left_size = inorder_index - is;\\n        \\n\\n        TreeNode* left = helper(preorder, ps + 1, ps + left_size, inorder, is, inorder_index - 1);\\n        TreeNode* right = helper(preorder, ps + left_size + 1, pe, inorder, inorder_index + 1, ie);\\n\\n        newNode->left = left;\\n        newNode->right = right;\\n        return newNode;\\n    }\\npublic:\\n    TreeNode* buildTree(vector<int>& preorder, vector<int>& inorder) {\\n        int n = inorder.size();\\n        if (n == 0) return NULL;\\n        for (int i = 0; i < n; ++i) {\\n            m[inorder[i]] = i;\\n        }\\n        return helper(preorder, 0, n - 1, inorder, 0, n - 1);\\n    }\\n};\\n```\n```Java []\\nclass Solution {\\n\\n    HashMap<Integer, Integer> map = new HashMap<>();\\n\\n    TreeNode helper(int[] preorder, int[] inorder, int pS, int pE, int iS, int iE) {\\n        if (iS > iE || iS < 0 || iS >= inorder.length || iE < 0 || iE >= inorder.length) {\\n            return null;\\n        }\\n        if (pS >= preorder.length || pE >= preorder.length || pS > pE) {\\n            return null;\\n        }\\n\\n        TreeNode root = new TreeNode(preorder[pS]);\\n\\n        int inIndex = map.get(preorder[pS]);\\n        int size = inIndex - iS;\\n\\n        TreeNode left = helper(preorder, inorder, pS + 1, pS + size, iS, inIndex - 1);\\n        TreeNode right = helper(preorder, inorder, pS + size + 1, pE, inIndex + 1, iE);\\n\\n        root.left = left;\\n        root.right = right;\\n        return root;\\n    }\\n\\n    public TreeNode buildTree(int[] preorder, int[] inorder) {\\n        int n = preorder.length;\\n        if (n == 0) return null;\\n        for (int i = 0; i < n; ++i) {\\n            map.put(inorder[i], i);\\n        }\\n        return helper(preorder, inorder, 0, n - 1, 0, n - 1);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3496777,
                "title": "typescript-solution-using-recursion",
                "content": "# Code\\n```\\nfunction buildTree(preorder: number[], inorder: number[]): TreeNode | null {\\n\\tif (!inorder.length) return null;\\n\\n\\tconst root = preorder.shift()!;\\n\\tconst inOrderRootIndex = inorder.findIndex((val) => val === root);\\n\\tconst inOrderLeftBranch = inorder.slice(0, inOrderRootIndex);\\n\\tconst inOrderRightBranch = inorder.slice(inOrderRootIndex + 1);\\n\\n\\tconst tree = new TreeNode(root);\\n\\ttree.left = buildTree(preorder, inOrderLeftBranch);\\n\\ttree.right = buildTree(preorder, inOrderRightBranch);\\n\\n\\treturn tree;\\n}\\n```",
                "solutionTags": [
                    "TypeScript"
                ],
                "code": "```\\nfunction buildTree(preorder: number[], inorder: number[]): TreeNode | null {\\n\\tif (!inorder.length) return null;\\n\\n\\tconst root = preorder.shift()!;\\n\\tconst inOrderRootIndex = inorder.findIndex((val) => val === root);\\n\\tconst inOrderLeftBranch = inorder.slice(0, inOrderRootIndex);\\n\\tconst inOrderRightBranch = inorder.slice(inOrderRootIndex + 1);\\n\\n\\tconst tree = new TreeNode(root);\\n\\ttree.left = buildTree(preorder, inOrderLeftBranch);\\n\\ttree.right = buildTree(preorder, inOrderRightBranch);\\n\\n\\treturn tree;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3451834,
                "title": "simple-python-solution-beats-98-9-and-memory-beats-86-31",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nRecursion\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n$$O(n)$$\\n- Space complexity:\\n$$O(n)$$\\nBecause of recursion and dictionary\\n\\n# Code\\n```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def buildTree(self, preorder: List[int], inorder: List[int]) -> Optional[TreeNode]:\\n        self.root_index = {}\\n        self.index = 0\\n        for i,num in enumerate(inorder):\\n            self.root_index[num] = i\\n        \\n        def construct(left,right):\\n            if left > right:\\n                return None\\n            root = preorder[self.index]\\n            i = self.root_index[root]\\n            self.index += 1\\n            head = TreeNode(root)\\n            head.left = construct(left,i - 1)\\n            head.right = construct(i + 1, right)\\n            return head\\n        \\n        n = len(preorder) - 1\\n        return construct(0,n)\\n        \\n```",
                "solutionTags": [
                    "Python3",
                    "Recursion"
                ],
                "code": "```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def buildTree(self, preorder: List[int], inorder: List[int]) -> Optional[TreeNode]:\\n        self.root_index = {}\\n        self.index = 0\\n        for i,num in enumerate(inorder):\\n            self.root_index[num] = i\\n        \\n        def construct(left,right):\\n            if left > right:\\n                return None\\n            root = preorder[self.index]\\n            i = self.root_index[root]\\n            self.index += 1\\n            head = TreeNode(root)\\n            head.left = construct(left,i - 1)\\n            head.right = construct(i + 1, right)\\n            return head\\n        \\n        n = len(preorder) - 1\\n        return construct(0,n)\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3397115,
                "title": "detailed-java-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    public TreeNode buildTree(int[] preorder, int[] inorder) {\\n        // Create a map of element-to-index mapping for inorder traversal\\n        Map<Integer,Integer> inMap=new TreeMap<>();\\n        for(int i=0;i<inorder.length;i++){\\n            inMap.put(inorder[i],i);\\n        }\\n        // Recursively construct the binary tree from preorder and inorder traversals\\n        TreeNode root=buildTree(preorder,0,preorder.length-1,inorder,0,inorder.length-1,inMap);\\n        return root;\\n    }\\n    \\n    private TreeNode buildTree(int[] preorder, int preStart, int preEnd, int[] inorder, int inStart, int inEnd, Map<Integer,Integer> inMap) {\\n        // Base case: the subtree is empty, return null\\n        if(preStart > preEnd || inStart > inEnd) return null;\\n\\n        // Construct the root node with the first element in the preorder traversal\\n        TreeNode root = new TreeNode(preorder[preStart]);\\n        \\n        // Find the index of the root element in the inorder traversal using the map\\n        int inroot = inMap.get(root.val);\\n        \\n        // Calculate the number of elements in the left subtree\\n        int numLeft = inroot - inStart;\\n\\n        // Recursively construct the left subtree\\n        root.left = buildTree(preorder, preStart+1, preStart+numLeft, inorder, inStart, inroot-1, inMap);\\n\\n        // Recursively construct the right subtree\\n        root.right = buildTree(preorder, preStart+numLeft+1, preEnd, inorder, inroot+1, inEnd, inMap);\\n\\n        // Return the root node of the constructed subtree\\n        return root;\\n    }\\n}\\n\\n```\\n#### **Upvote if it is helpful**",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Hash Table",
                    "Tree",
                    "Binary Tree"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    public TreeNode buildTree(int[] preorder, int[] inorder) {\\n        // Create a map of element-to-index mapping for inorder traversal\\n        Map<Integer,Integer> inMap=new TreeMap<>();\\n        for(int i=0;i<inorder.length;i++){\\n            inMap.put(inorder[i],i);\\n        }\\n        // Recursively construct the binary tree from preorder and inorder traversals\\n        TreeNode root=buildTree(preorder,0,preorder.length-1,inorder,0,inorder.length-1,inMap);\\n        return root;\\n    }\\n    \\n    private TreeNode buildTree(int[] preorder, int preStart, int preEnd, int[] inorder, int inStart, int inEnd, Map<Integer,Integer> inMap) {\\n        // Base case: the subtree is empty, return null\\n        if(preStart > preEnd || inStart > inEnd) return null;\\n\\n        // Construct the root node with the first element in the preorder traversal\\n        TreeNode root = new TreeNode(preorder[preStart]);\\n        \\n        // Find the index of the root element in the inorder traversal using the map\\n        int inroot = inMap.get(root.val);\\n        \\n        // Calculate the number of elements in the left subtree\\n        int numLeft = inroot - inStart;\\n\\n        // Recursively construct the left subtree\\n        root.left = buildTree(preorder, preStart+1, preStart+numLeft, inorder, inStart, inroot-1, inMap);\\n\\n        // Recursively construct the right subtree\\n        root.right = buildTree(preorder, preStart+numLeft+1, preEnd, inorder, inroot+1, inEnd, inMap);\\n\\n        // Return the root node of the constructed subtree\\n        return root;\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3274503,
                "title": "easy-2ms-java",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    public TreeNode buildTree(int[] preorder, int[] inorder) {\\n    Map<Integer,Integer>inMap=new HashMap<>();\\n    for (int i = 0; i < inorder.length; i++) {\\n      inMap.put(inorder[i], i);\\n    }\\n    TreeNode root = build(preorder, 0, preorder.length - 1, inorder, 0,inorder.length - 1, inMap);\\n    return root;\\n    }\\n    static TreeNode build(int[] preorder, int preStart, int preEnd, int[]inorder, int inStart, int inEnd, Map<Integer,Integer>inMap){\\n        if(preStart>preEnd || inStart>inEnd) return  null;\\n        TreeNode root=new TreeNode(preorder[preStart]);\\n        int inRoot = inMap.get(root.val);\\n        int numsLeft = inRoot - inStart;\\n        root.left = build(preorder, preStart + 1, preStart + numsLeft, inorder,inStart, inRoot - 1, inMap);\\n        root.right = build(preorder, preStart + numsLeft + 1, preEnd, inorder,inRoot + 1, inEnd, inMap);\\n        return root;\\n\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    public TreeNode buildTree(int[] preorder, int[] inorder) {\\n    Map<Integer,Integer>inMap=new HashMap<>();\\n    for (int i = 0; i < inorder.length; i++) {\\n      inMap.put(inorder[i], i);\\n    }\\n    TreeNode root = build(preorder, 0, preorder.length - 1, inorder, 0,inorder.length - 1, inMap);\\n    return root;\\n    }\\n    static TreeNode build(int[] preorder, int preStart, int preEnd, int[]inorder, int inStart, int inEnd, Map<Integer,Integer>inMap){\\n        if(preStart>preEnd || inStart>inEnd) return  null;\\n        TreeNode root=new TreeNode(preorder[preStart]);\\n        int inRoot = inMap.get(root.val);\\n        int numsLeft = inRoot - inStart;\\n        root.left = build(preorder, preStart + 1, preStart + numsLeft, inorder,inStart, inRoot - 1, inMap);\\n        root.right = build(preorder, preStart + numsLeft + 1, preEnd, inorder,inRoot + 1, inEnd, inMap);\\n        return root;\\n\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3191834,
                "title": "construct-binary-tree-from-preorder-and-inorder-traversal-with-step-by-step-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nThis solution also uses a recursive approach to construct the binary tree. However, instead of passing around the indices of the preorder and inorder lists, it uses four separate variables to keep track of the current ranges of indices for both lists. It also uses a dictionary to map the elements of the inorder list to their indices, which makes it easier to locate the root node in the list.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def buildTree(self, preorder: List[int], inorder: List[int]) -> TreeNode:\\n        # Create a dictionary to store the index of each element in the inorder list\\n        inorder_map = {}\\n        for i, val in enumerate(inorder):\\n            inorder_map[val] = i\\n        \\n        # Recursively build the tree using the preorder and inorder lists\\n        def build_tree(pre_start, pre_end, in_start, in_end):\\n            if pre_start > pre_end:\\n                return None\\n            \\n            # Create a new node using the first element in the preorder list\\n            root_val = preorder[pre_start]\\n            root = TreeNode(root_val)\\n            \\n            # Find the index of the root element in the inorder list\\n            root_index = inorder_map[root_val]\\n            \\n            # Calculate the size of the left subtree\\n            left_size = root_index - in_start\\n            \\n            # Recursively build the left and right subtrees\\n            root.left = build_tree(pre_start+1, pre_start+left_size, in_start, root_index-1)\\n            root.right = build_tree(pre_start+left_size+1, pre_end, root_index+1, in_end)\\n            \\n            return root\\n        \\n        # Call the build_tree function with the initial indices\\n        return build_tree(0, len(preorder)-1, 0, len(inorder)-1)\\n\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Array",
                    "Hash Table",
                    "Divide and Conquer"
                ],
                "code": "```\\nclass Solution:\\n    def buildTree(self, preorder: List[int], inorder: List[int]) -> TreeNode:\\n        # Create a dictionary to store the index of each element in the inorder list\\n        inorder_map = {}\\n        for i, val in enumerate(inorder):\\n            inorder_map[val] = i\\n        \\n        # Recursively build the tree using the preorder and inorder lists\\n        def build_tree(pre_start, pre_end, in_start, in_end):\\n            if pre_start > pre_end:\\n                return None\\n            \\n            # Create a new node using the first element in the preorder list\\n            root_val = preorder[pre_start]\\n            root = TreeNode(root_val)\\n            \\n            # Find the index of the root element in the inorder list\\n            root_index = inorder_map[root_val]\\n            \\n            # Calculate the size of the left subtree\\n            left_size = root_index - in_start\\n            \\n            # Recursively build the left and right subtrees\\n            root.left = build_tree(pre_start+1, pre_start+left_size, in_start, root_index-1)\\n            root.right = build_tree(pre_start+left_size+1, pre_end, root_index+1, in_end)\\n            \\n            return root\\n        \\n        # Call the build_tree function with the initial indices\\n        return build_tree(0, len(preorder)-1, 0, len(inorder)-1)\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3060017,
                "title": "c-simple-and-easy-recursive-approach",
                "content": "# Approach\\nUsing Recursion we will construct the root node and call the function to construct the left and right node. We will find the root from PreOrder vector and left part from InOrder vector.\\n\\n# Complexity\\n- Time complexity : O(N)\\nFaster than 42.94%\\n\\n- Space complexity: O(N)\\nBeats 80.53% submissions.\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    TreeNode* fun(vector<int>& pre , vector<int>& in ,int inS ,int inE ,int preS ,int preE)\\n    {\\n        if(inS>inE || preS>preE) return NULL; //base case\\n        int rootData=pre[preS]; /* PreOrder Traversal -> ROOT , LEFT RIGHT so root will be present at preS index*/\\n        int i=0;\\n        for(;i<pre.size();i++)\\n        {\\n            if(in[i]==rootData) break; //find where root is in inorder vector\\n        }\\n        int leftInOrderStart=inS;  \\n        int leftInOrderEnd=i-1; \\n        int leftPreOrderStart=preS+1;\\n        int leftPreOrderEnd=leftInOrderEnd+leftPreOrderStart-leftInOrderStart;\\n\\n        int rightInOrderStart=i+1;\\n        int rightInOrderEnd=inE;\\n        int rightPreOrderStart=leftPreOrderEnd+1;\\n        int rightPreOrderEnd=preE;\\n\\n        TreeNode* root=new TreeNode(rootData);\\n        // call recursion for left and right subtree\\n        root->left=fun(pre,in,leftInOrderStart,leftInOrderEnd,leftPreOrderStart,leftPreOrderEnd);\\n        root->right=fun(pre,in,rightInOrderStart,rightInOrderEnd,rightPreOrderStart,rightPreOrderEnd);\\n        return root;\\n    }\\n    TreeNode* buildTree(vector<int>& preorder, vector<int>& inorder) {\\n        int n=preorder.size();\\n        return fun(preorder,inorder,0,n-1,0,n-1);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    TreeNode* fun(vector<int>& pre , vector<int>& in ,int inS ,int inE ,int preS ,int preE)\\n    {\\n        if(inS>inE || preS>preE) return NULL; //base case\\n        int rootData=pre[preS]; /* PreOrder Traversal -> ROOT , LEFT RIGHT so root will be present at preS index*/\\n        int i=0;\\n        for(;i<pre.size();i++)\\n        {\\n            if(in[i]==rootData) break; //find where root is in inorder vector\\n        }\\n        int leftInOrderStart=inS;  \\n        int leftInOrderEnd=i-1; \\n        int leftPreOrderStart=preS+1;\\n        int leftPreOrderEnd=leftInOrderEnd+leftPreOrderStart-leftInOrderStart;\\n\\n        int rightInOrderStart=i+1;\\n        int rightInOrderEnd=inE;\\n        int rightPreOrderStart=leftPreOrderEnd+1;\\n        int rightPreOrderEnd=preE;\\n\\n        TreeNode* root=new TreeNode(rootData);\\n        // call recursion for left and right subtree\\n        root->left=fun(pre,in,leftInOrderStart,leftInOrderEnd,leftPreOrderStart,leftPreOrderEnd);\\n        root->right=fun(pre,in,rightInOrderStart,rightInOrderEnd,rightPreOrderStart,rightPreOrderEnd);\\n        return root;\\n    }\\n    TreeNode* buildTree(vector<int>& preorder, vector<int>& inorder) {\\n        int n=preorder.size();\\n        return fun(preorder,inorder,0,n-1,0,n-1);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2950615,
                "title": "c-easy-to-understand-clean-code",
                "content": "![image](https://assets.leetcode.com/users/images/22f44d99-7e59-45e1-a51b-b91ce8cd23e1_1671987726.1112716.png)\\n\\n**N=Number of Nodes**\\n**T->O(N) && S->O(N)[For map] + O(N) [ASS]**\\n\\n\\tclass Solution {\\n\\tpublic:\\n\\t\\tTreeNode* tree(vector<int>& pre,int preStart,int preEnd,vector<int>& in,int inStart,int inEnd,map<int,int>& ind){\\n\\t\\t\\tif(preStart>preEnd || inStart>inEnd) return NULL;\\n\\t\\t\\tTreeNode* root=new TreeNode(pre[preStart]);\\n\\t\\t\\tint inRoot=ind[root->val];\\n\\t\\t\\tint numsleft=inRoot-inStart;\\n\\t\\t\\troot->left=tree(pre,preStart+1,preStart+numsleft,in,inStart,inRoot-1,ind);\\n\\t\\t\\troot->right=tree(pre,preStart+numsleft+1,preEnd,in,inRoot+1,inEnd,ind);\\n\\t\\t\\treturn root;\\n\\t\\t}\\n\\n\\t\\tTreeNode* buildTree(vector<int>& pre,vector<int>& in) {\\n\\t\\t\\tmap<int,int>ind;\\n\\t\\t\\tfor(int i=0;i<in.size();i++) ind[in[i]]=i;\\n\\t\\t\\treturn tree(pre,0,pre.size()-1,in,0,in.size()-1,ind);\\n\\t\\t}\\n\\t};",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "class Solution {\\n\\tpublic:\\n\\t\\tTreeNode* tree(vector<int>& pre,int preStart,int preEnd,vector<int>& in,int inStart,int inEnd,map<int,int>& ind){\\n\\t\\t\\tif(preStart>preEnd || inStart>inEnd) return NULL;\\n\\t\\t\\tTreeNode* root=new TreeNode(pre[preStart]);\\n\\t\\t\\tint inRoot=ind[root->val];\\n\\t\\t\\tint numsleft=inRoot-inStart;\\n\\t\\t\\troot->left=tree(pre,preStart+1,preStart+numsleft,in,inStart,inRoot-1,ind);\\n\\t\\t\\troot->right=tree(pre,preStart+numsleft+1,preEnd,in,inRoot+1,inEnd,ind);\\n\\t\\t\\treturn root;\\n\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 2920212,
                "title": "easy-solution-short-simple-best-method-easy-to-understand",
                "content": "\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    TreeNode* f(vector<int>& p, vector<int>& i, int& id, int l, int r)\\n    {\\n        if(l>r)\\n            return NULL;\\n        int pt=l;\\n        while(i[pt]!=p[id])\\n            pt++;\\n        id++;\\n        TreeNode* t=new TreeNode(i[pt]);\\n        t->left=f(p,i,id,l,pt-1);\\n        t->right=f(p,i,id,pt+1,r);\\n        return t;\\n    }\\n    TreeNode* buildTree(vector<int>& preorder, vector<int>& inorder) {\\n        int id=0;\\n        return f(preorder,inorder, id, 0, inorder.size()-1);\\n    }\\n    \\n};\\n```\\nPlease **UPVOTE** if it helps \\u2764\\uFE0F\\uD83D\\uDE0A\\nThank You and Happy To Help You!!",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    TreeNode* f(vector<int>& p, vector<int>& i, int& id, int l, int r)\\n    {\\n        if(l>r)\\n            return NULL;\\n        int pt=l;\\n        while(i[pt]!=p[id])\\n            pt++;\\n        id++;\\n        TreeNode* t=new TreeNode(i[pt]);\\n        t->left=f(p,i,id,l,pt-1);\\n        t->right=f(p,i,id,pt+1,r);\\n        return t;\\n    }\\n    TreeNode* buildTree(vector<int>& preorder, vector<int>& inorder) {\\n        int id=0;\\n        return f(preorder,inorder, id, 0, inorder.size()-1);\\n    }\\n    \\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2719212,
                "title": "python-easy-beginners-friendly",
                "content": "# Code\\n```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def buildTree(self, preorder: List[int], inorder: List[int]) -> Optional[TreeNode]:\\n\\n        def build(preorder,inorder,ist,ien,d):\\n            if ist>ien or len(preorder)==0:\\n                return None\\n            ele = preorder.pop(0)\\n            root = TreeNode(ele)\\n            idx = d[ele]\\n            root.left = build(preorder,inorder,ist,idx-1,d)\\n            root.right = build(preorder,inorder,idx+1,ien,d)\\n            return root\\n\\n\\n        d,n = {},len(preorder)\\n        for i in range(len(inorder)):\\n            d[inorder[i]] = i\\n        root = build(preorder,inorder,0,n-1,d)\\n        return root\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def buildTree(self, preorder: List[int], inorder: List[int]) -> Optional[TreeNode]:\\n\\n        def build(preorder,inorder,ist,ien,d):\\n            if ist>ien or len(preorder)==0:\\n                return None\\n            ele = preorder.pop(0)\\n            root = TreeNode(ele)\\n            idx = d[ele]\\n            root.left = build(preorder,inorder,ist,idx-1,d)\\n            root.right = build(preorder,inorder,idx+1,ien,d)\\n            return root\\n\\n\\n        d,n = {},len(preorder)\\n        for i in range(len(inorder)):\\n            d[inorder[i]] = i\\n        root = build(preorder,inorder,0,n-1,d)\\n        return root\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2661589,
                "title": "python-construct-binary-tree-from-preorder-and-inorder-traversal",
                "content": "In order to solve this question, you first need to understand how to construct a preorder tree and inorder tree independently. \\n1. You need to understand that while creating a binary tree from pre and in order traversal. The first Node of preorder traversal is always gonna be the root. \\n2. You need to find the index position of the first node of pre-order in the in-order traversal list and anything towards the left of that value in the inorder traversal is gonna be left subtree of the main tree that we wanna build and anything right of that value in the list is gonna be in the right of subtree that we wanna build. \\nApply this logic recursively and you are done.\\n\\nTry solving this no a piece of peper 2/3 times and you will understand it. \\n\\n```\\nclass Solution:\\n    def buildTree(self, preorder: List[int], inorder: List[int]) -> Optional[TreeNode]:\\n        if not preorder or not inorder:\\n            return None\\n        \\n        \\n        root=TreeNode(preorder[0])\\n        mid=inorder.index(preorder[0])\\n        \\n        root.left=self.buildTree(preorder[1:mid+1],inorder[:mid])\\n        root.right=self.buildTree(preorder[mid+1:],inorder[mid+1:])\\n        \\n        return root",
                "solutionTags": [
                    "Python",
                    "Recursion"
                ],
                "code": "In order to solve this question, you first need to understand how to construct a preorder tree and inorder tree independently. \\n1. You need to understand that while creating a binary tree from pre and in order traversal. The first Node of preorder traversal is always gonna be the root. \\n2. You need to find the index position of the first node of pre-order in the in-order traversal list and anything towards the left of that value in the inorder traversal is gonna be left subtree of the main tree that we wanna build and anything right of that value in the list is gonna be in the right of subtree that we wanna build. \\nApply this logic recursively and you are done.\\n\\nTry solving this no a piece of peper 2/3 times and you will understand it. \\n\\n```\\nclass Solution:\\n    def buildTree(self, preorder: List[int], inorder: List[int]) -> Optional[TreeNode]:\\n        if not preorder or not inorder:\\n            return None\\n        \\n        \\n        root=TreeNode(preorder[0])\\n        mid=inorder.index(preorder[0])\\n        \\n        root.left=self.buildTree(preorder[1:mid+1],inorder[:mid])\\n        root.right=self.buildTree(preorder[mid+1:],inorder[mid+1:])\\n        \\n        return root",
                "codeTag": "Java"
            },
            {
                "id": 2558300,
                "title": "short-python-recursive-solution",
                "content": "```\\nclass Solution:\\n    def buildTree(self, preorder: List[int], inorder: List[int]) -> Optional[TreeNode]:\\n        if not preorder or not inorder: return\\n        root = TreeNode(preorder.pop(0))\\n        mid = inorder.index(root.val)\\n        \\n        root.left = self.buildTree(preorder, inorder[0:mid])\\n        root.right = self.buildTree(preorder, inorder[mid+1:])\\n\\n        return root\\n```",
                "solutionTags": [
                    "Python",
                    "Recursion"
                ],
                "code": "```\\nclass Solution:\\n    def buildTree(self, preorder: List[int], inorder: List[int]) -> Optional[TreeNode]:\\n        if not preorder or not inorder: return\\n        root = TreeNode(preorder.pop(0))\\n        mid = inorder.index(root.val)\\n        \\n        root.left = self.buildTree(preorder, inorder[0:mid])\\n        root.right = self.buildTree(preorder, inorder[mid+1:])\\n\\n        return root\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2536016,
                "title": "almighty-c-easy-solution",
                "content": "**Jai Shree Ram**\\n\\n```\\nint pos(vector<int> arr , int x){\\n        for(int i = 0;i<arr.size();i++) {\\n            if(arr[i]==x) return i;\\n        }\\n        return -1;\\n    }\\n    TreeNode* solve(vector<int> pre, vector<int> in,int& index,int start,int end){\\n        if(index>in.size()||start>end) return NULL;\\n        \\n        int element = pre[index++];\\n        TreeNode* root = new TreeNode(element);\\n        int posi =  pos(in,element);\\n        \\n        root->left = solve(pre,in,index,start,posi-1);\\n        root->right = solve(pre,in,index,posi+1,end);\\n        \\n        return root;\\n    }\\n    TreeNode* buildTree(vector<int>& preorder, vector<int>& inorder) {\\n        int index = 0;\\n        TreeNode* ans = solve(preorder,inorder , index,0,preorder.size()-1);\\n        return ans;\\n    }\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nint pos(vector<int> arr , int x){\\n        for(int i = 0;i<arr.size();i++) {\\n            if(arr[i]==x) return i;\\n        }\\n        return -1;\\n    }\\n    TreeNode* solve(vector<int> pre, vector<int> in,int& index,int start,int end){\\n        if(index>in.size()||start>end) return NULL;\\n        \\n        int element = pre[index++];\\n        TreeNode* root = new TreeNode(element);\\n        int posi =  pos(in,element);\\n        \\n        root->left = solve(pre,in,index,start,posi-1);\\n        root->right = solve(pre,in,index,posi+1,end);\\n        \\n        return root;\\n    }\\n    TreeNode* buildTree(vector<int>& preorder, vector<int>& inorder) {\\n        int index = 0;\\n        TreeNode* ans = solve(preorder,inorder , index,0,preorder.size()-1);\\n        return ans;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2280911,
                "title": "c-recursive-solution-easy-to-understand-faster",
                "content": "```\\nclass Solution {\\npublic:\\n    unordered_map<int, int> mp;\\n    int p=0;\\n    TreeNode* buildTree(vector<int>& preorder, vector<int>& inorder) {\\n        for(int i=0; i<inorder.size(); ++i) mp[inorder[i]]=i;\\n        return tree(preorder, 0, preorder.size()-1, inorder, 0, inorder.size()-1);\\n    }\\n    \\n    TreeNode* tree(vector<int>& pre, int lpre, int hpre, vector<int>& in, int lin, int hin) {\\n        if(lin>hin) return NULL;\\n        TreeNode* root=new TreeNode(pre[p++]);\\n        int index=mp[root->val];\\n        root->left=tree(pre, lpre+1, lpre+index, in, lin, index-1);\\n        root->right=tree(pre, lpre+index+1, hpre, in, index+1, hin);\\n     return root;\\n    }\\n};\\n/**\\nif(find helpful) {\\ndo upvote(); // thanks:)\\n}\\n*/\\n```",
                "solutionTags": [
                    "C",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    unordered_map<int, int> mp;\\n    int p=0;\\n    TreeNode* buildTree(vector<int>& preorder, vector<int>& inorder) {\\n        for(int i=0; i<inorder.size(); ++i) mp[inorder[i]]=i;\\n        return tree(preorder, 0, preorder.size()-1, inorder, 0, inorder.size()-1);\\n    }\\n    \\n    TreeNode* tree(vector<int>& pre, int lpre, int hpre, vector<int>& in, int lin, int hin) {\\n        if(lin>hin) return NULL;\\n        TreeNode* root=new TreeNode(pre[p++]);\\n        int index=mp[root->val];\\n        root->left=tree(pre, lpre+1, lpre+index, in, lin, index-1);\\n        root->right=tree(pre, lpre+index+1, hpre, in, index+1, hin);\\n     return root;\\n    }\\n};\\n/**\\nif(find helpful) {\\ndo upvote(); // thanks:)\\n}\\n*/\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2279893,
                "title": "c-simple-code-95-better-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    TreeNode* buildTree(vector<int>& p, vector<int>& q) {\\n        if(p.size()==0) return NULL;\\n        else if(p.size()==1) return new TreeNode(p[0]);\\n        TreeNode* x= new TreeNode(p[0]);\\n        vector<int> v1,v2,v3,v4;\\n        int i=0;\\n        while(i<q.size()&&q[i]!=p[0]) v3.push_back(q[i]),v1.push_back(p[i+1]),i++;;\\n        i++;\\n        while(i<q.size()) v4.push_back(q[i]),v2.push_back(p[i]),i++;\\n        x->left = buildTree(v1,v3);\\n        x->right = buildTree(v2,v4);\\n        return x;\\n    }\\n};\\n```\\n",
                "solutionTags": [
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    TreeNode* buildTree(vector<int>& p, vector<int>& q) {\\n        if(p.size()==0) return NULL;\\n        else if(p.size()==1) return new TreeNode(p[0]);\\n        TreeNode* x= new TreeNode(p[0]);\\n        vector<int> v1,v2,v3,v4;\\n        int i=0;\\n        while(i<q.size()&&q[i]!=p[0]) v3.push_back(q[i]),v1.push_back(p[i+1]),i++;;\\n        i++;\\n        while(i<q.size()) v4.push_back(q[i]),v2.push_back(p[i]),i++;\\n        x->left = buildTree(v1,v3);\\n        x->right = buildTree(v2,v4);\\n        return x;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2279848,
                "title": "easy-c-solution-recursion",
                "content": "```\\nclass Solution {\\n    TreeNode* helper(vector<int>&preorder, int pre_start, int pre_end, vector<int>&inorder, int in_start, int in_end){\\n        \\n        if(pre_start>pre_end) return nullptr;\\n        if(pre_start==pre_end) return new TreeNode(preorder[pre_start]);\\n        \\n        TreeNode* root = new TreeNode(preorder[pre_start]);\\n        int inorder_mid,preorder_mid;\\n        \\n        for(inorder_mid=in_start; inorder_mid<=in_end; ++inorder_mid)\\n            if(inorder[inorder_mid]==preorder[pre_start]) break;\\n        preorder_mid = pre_start+inorder_mid-in_start;\\n            \\n        root->left = helper(preorder,pre_start+1,preorder_mid,inorder,in_start,inorder_mid-1);\\n        root->right= helper(preorder,preorder_mid+1,pre_end,inorder,inorder_mid+1,in_end);\\n        \\n        return root;\\n    }\\npublic:\\n    TreeNode* buildTree(vector<int>& preorder, vector<int>& inorder) {\\n        return helper(preorder,0,preorder.size()-1, inorder, 0, inorder.size()-1);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\n    TreeNode* helper(vector<int>&preorder, int pre_start, int pre_end, vector<int>&inorder, int in_start, int in_end){\\n        \\n        if(pre_start>pre_end) return nullptr;\\n        if(pre_start==pre_end) return new TreeNode(preorder[pre_start]);\\n        \\n        TreeNode* root = new TreeNode(preorder[pre_start]);\\n        int inorder_mid,preorder_mid;\\n        \\n        for(inorder_mid=in_start; inorder_mid<=in_end; ++inorder_mid)\\n            if(inorder[inorder_mid]==preorder[pre_start]) break;\\n        preorder_mid = pre_start+inorder_mid-in_start;\\n            \\n        root->left = helper(preorder,pre_start+1,preorder_mid,inorder,in_start,inorder_mid-1);\\n        root->right= helper(preorder,preorder_mid+1,pre_end,inorder,inorder_mid+1,in_end);\\n        \\n        return root;\\n    }\\npublic:\\n    TreeNode* buildTree(vector<int>& preorder, vector<int>& inorder) {\\n        return helper(preorder,0,preorder.size()-1, inorder, 0, inorder.size()-1);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2104738,
                "title": "c-simple-and-efficient-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int idx;\\n    \\n    TreeNode* solve(vector<int>& preorder, vector<int>& inorder, int inStart, int inEnd, unordered_map<int,int> &inMap)\\n    {\\n        if(inStart > inEnd) return 0;\\n        TreeNode* root = new TreeNode(preorder[idx++]);\\n        \\n        if(inStart == inEnd) return root;\\n        \\n        int mid = inMap[root->val];\\n        \\n        root->left = solve(preorder,inorder,inStart,mid-1,inMap);\\n        root->right = solve(preorder,inorder,mid+1,inEnd,inMap);\\n        return root;   \\n    }\\n    \\n    TreeNode* buildTree(vector<int>& preorder, vector<int>& inorder) \\n    {\\n        int n=inorder.size();\\n        idx = 0;\\n        unordered_map<int,int> inMap;\\n        \\n        for(int i=0; i<n; i++) inMap[inorder[i]]=i;\\n        TreeNode* root = solve(preorder,inorder,0,n-1,inMap);\\n        return root;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int idx;\\n    \\n    TreeNode* solve(vector<int>& preorder, vector<int>& inorder, int inStart, int inEnd, unordered_map<int,int> &inMap)\\n    {\\n        if(inStart > inEnd) return 0;\\n        TreeNode* root = new TreeNode(preorder[idx++]);\\n        \\n        if(inStart == inEnd) return root;\\n        \\n        int mid = inMap[root->val];\\n        \\n        root->left = solve(preorder,inorder,inStart,mid-1,inMap);\\n        root->right = solve(preorder,inorder,mid+1,inEnd,inMap);\\n        return root;   \\n    }\\n    \\n    TreeNode* buildTree(vector<int>& preorder, vector<int>& inorder) \\n    {\\n        int n=inorder.size();\\n        idx = 0;\\n        unordered_map<int,int> inMap;\\n        \\n        for(int i=0; i<n; i++) inMap[inorder[i]]=i;\\n        TreeNode* root = solve(preorder,inorder,0,n-1,inMap);\\n        return root;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2030561,
                "title": "python-iterative-solution",
                "content": "```\\n    def buildTree(self, preorder: List[int], inorder: List[int]) -> Optional[TreeNode]:\\n        if not preorder or not inorder: return None\\n        \\n        result = TreeNode(preorder[0])\\n        stack = [result]\\n        \\n        p = 1 # Preorder list pointer\\n        i = 0 # Inorder list pointer\\n        \\n        while True:\\n            # Iterate through all left nodes and add them to the stack\\n            # until meet the last (bottom) node\\n            while stack[-1].val != inorder[i]:\\n                curr = TreeNode(preorder[p])\\n                stack[-1].left = curr\\n                stack.append(curr)\\n                p += 1\\n\\n            # Quit the loop if all elemens are processed\\n            if p == len(preorder):\\n                break                \\n                \\n            # Pop nodes from the stack until meet the node with the right child\\n            while stack and stack[-1].val == inorder[i]:\\n                last = stack.pop()\\n                i += 1\\n            \\n            # Create the right node\\n            curr = TreeNode(preorder[p])\\n            last.right = curr\\n            stack.append(curr)\\n            \\n            # Move the list pointer to the first left node\\n            p += 1            \\n        \\n        return result\\n```",
                "solutionTags": [
                    "Python",
                    "Iterator"
                ],
                "code": "```\\n    def buildTree(self, preorder: List[int], inorder: List[int]) -> Optional[TreeNode]:\\n        if not preorder or not inorder: return None\\n        \\n        result = TreeNode(preorder[0])\\n        stack = [result]\\n        \\n        p = 1 # Preorder list pointer\\n        i = 0 # Inorder list pointer\\n        \\n        while True:\\n            # Iterate through all left nodes and add them to the stack\\n            # until meet the last (bottom) node\\n            while stack[-1].val != inorder[i]:\\n                curr = TreeNode(preorder[p])\\n                stack[-1].left = curr\\n                stack.append(curr)\\n                p += 1\\n\\n            # Quit the loop if all elemens are processed\\n            if p == len(preorder):\\n                break                \\n                \\n            # Pop nodes from the stack until meet the node with the right child\\n            while stack and stack[-1].val == inorder[i]:\\n                last = stack.pop()\\n                i += 1\\n            \\n            # Create the right node\\n            curr = TreeNode(preorder[p])\\n            last.right = curr\\n            stack.append(curr)\\n            \\n            # Move the list pointer to the first left node\\n            p += 1            \\n        \\n        return result\\n```",
                "codeTag": "Python3"
            }
        ],
        "discussions": [
            {
                "id": 1717092,
                "content": [
                    {
                        "username": "mohamed_waseela",
                        "content": "if you get this question, they do not want to hire you."
                    },
                    {
                        "username": "taroTown",
                        "content": "LMFAO"
                    },
                    {
                        "username": "user8143P",
                        "content": "hahaha, that's why I like the discussion module in Leetcode"
                    },
                    {
                        "username": "JosephHauter",
                        "content": "LMAOOO "
                    },
                    {
                        "username": "mochiball",
                        "content": "lmfaoooooo you\\'re not wrong "
                    },
                    {
                        "username": "omakovsk",
                        "content": "ahaha"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "If you can\\'t do this, they probably shouldn\\'t :P. JK, just keep practicing, if you do a bunch of tree problems, this one really is quite doable. https://leetcode.com/problems/convert-sorted-array-to-binary-search-tree/ is a good stepping stone to this one. "
                    },
                    {
                        "username": "studshubham",
                        "content": "I think this question should put in Hard category."
                    },
                    {
                        "username": "marks716",
                        "content": "I agree, on the easier spectrum of hard but still above medium. This is not the same as Binary Tree Level Order Traversal which is marked as being the same level."
                    },
                    {
                        "username": "Kashyap2502",
                        "content": "[@Mister_CK](/Mister_CK)\\n That\\'s really helpful thanks a lot"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "disagree, it\\'s quite straightforward, compared to the hard tree problems this is very doable. It builds on this Easy problem: https://leetcode.com/problems/convert-sorted-array-to-binary-search-tree/, it\\'s the same recursive build pattern but a bit more tricky due to the fact that you have to use the combination of two traversal arrays. But not that hard. "
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "[@imbobnewbie](/imbobnewbie) I think they tagged this a medium because this is something they teach in college (at least they taught us in our college) how to do, didn\\'t made us write program, but asked us this question in our exam - \\ndraw the tree and/or find the postorder if preorder and inorder is given for a binary tree."
                    },
                    {
                        "username": "davidtn",
                        "content": "For once I disagree. You only need to practice this once. The visualization comes wayyyy easier if you have a pen and paper. \n\nThere are 2 main tricks based on the concept of the most basic traversals.\n1) Know what is given for each, what isn't given. \n2) For those that aren't given, use the other givens to derive the unknowns.\n\nIf you somehow know this is about subproblems, then cutting up the arrays into small chunks each time is doable.\n\nCombining 2 concepts is standard for Medium. I solved this in 22', aiming for 15."
                    },
                    {
                        "username": "imbobnewbie",
                        "content": "[@RafeeqM](/RafeeqM) I'm going through mediums now and agree. This one requires several observations that would be fairly difficult to make during an interview unless you've solved this or numerous similar problems before. Coding portion isn't bad, but the logic is a challenge."
                    },
                    {
                        "username": "Skios",
                        "content": "i agree it\\'s pretty hard to wrap your head around. I wish there were four categories: easy, medium, hard, very hard. this is one of the hardest medium i\\'ve done"
                    },
                    {
                        "username": "davidtn",
                        "content": "Keep trying guys! I struggled with a similar problem a year ago. But today, with a piece of PEN and PAPER also vaguely remembering the \"tricks\", I solved it in 22 minutes. (Solving medium in 15\\' is standard in big tech interviews, according to a friend of mine who had done 300+ problems)\\n\\nTRICKS:\\n- preorder ALWAYS has the node first. But you don\\'t know the size of either branch.\\n- inorder ALWAYS has the left branch to the left of the node, and right branch right of the node. So now you know the size of each branch.\\n\\nTake those information and break the arrays into subproblems, based on the size.\\n"
                    },
                    {
                        "username": "PrimeDispenser",
                        "content": "Great tip, thanks!"
                    },
                    {
                        "username": "rreocode",
                        "content": "good tip many thanks "
                    },
                    {
                        "username": "mystiquecoder",
                        "content": "this question played with my emotions"
                    },
                    {
                        "username": "mochiball",
                        "content": "Good lord this question is hard af "
                    },
                    {
                        "username": "eaglesky",
                        "content": "I'm thinking about one possible follow-up question: what if duplicates are allowed in the binary tree? Can we modify the original recursive solution to get it work?"
                    },
                    {
                        "username": "SanskarGoyal_14",
                        "content": "YES, there is GFG Question for duplicates. The only difference is in finding index of element in inorder array.\\nTo solve that issue,\\n1. We can create a visited vector and pass it by reference.\\n2. Now, when searching for index, also check if visited[i] == 0, only then enter if block, change visited[i] to 1 and return i.\\n3. By doing this, we can easily skip elements that have same value as target-element but have been visited.\\n\\nCheers.. ^_^"
                    },
                    {
                        "username": "Kunal_101",
                        "content": "[@adis176](/adis176) There is a question in gfg considering duplicates.."
                    },
                    {
                        "username": "adis176",
                        "content": "Then it would not be possible to judge how many nodes actually make up the left subtree, or how many to include in the right subtree.\\nDifferent arrangement of trees can have the same inorder and preorder if duplicates are allowed, which would then render this question null."
                    },
                    {
                        "username": "puneets2811",
                        "content": "What if we have only 1 symbol repeated n times for both traversals?"
                    },
                    {
                        "username": "kharemohit786",
                        "content": "For input \\n[-1]\\n[-1]\\nIt is giving error while submitting the code but with custom input it is working fine."
                    },
                    {
                        "username": "Vikasgupta6",
                        "content": "Just reinitialized the value of your \\nstatic preOrder Index to 0, after end of the programme."
                    },
                    {
                        "username": "deadbeat253",
                        "content": "I am curious why in the example there are no nodes added to the initial left subtree (9) and the tree is continuing to be built from the initial right subtree. For example why is [3,9,20,null,null,15,7] correct but [3,9,20,15,7,null,null] is incorrect? They are both valid binary trees. How is one supposed to know which subtrees are null if the initial arrays (preorder and inorder) don\\'t contain null values?"
                    },
                    {
                        "username": "Sahil_Lohan",
                        "content": "thats why, They provided two arrays"
                    },
                    {
                        "username": "hopeNoPip",
                        "content": "So.. why do we need preorder and inorder to the same tree to build a Tree? why are both needed? "
                    },
                    {
                        "username": "anmolp476",
                        "content": "Do you still need help?"
                    },
                    {
                        "username": "MeloWang0308",
                        "content": "Awesome question. Based on my understand, you can build up multiple trees based on the same pre-order or in-order list. However, if we have two of them, we only have one solution. "
                    },
                    {
                        "username": "asong641",
                        "content": "You can't fully determine the shape of a tree with just 1 of them. \nFor example, the preorder example [3,9,20,15,7] can look like the tree given in the question or it can look like one long tree consisting of only left branches and a depth of 5 nodes. There are a couple different possibilities on how the preorder array can look as a binary tree. How do we know which one is correct? You have to use the inorder to verify."
                    },
                    {
                        "username": "roovent",
                        "content": "I simply put `return nil`, but it shows **Compile Error**. Soooo annoying!"
                    }
                ]
            },
            {
                "id": 1688749,
                "content": [
                    {
                        "username": "mohamed_waseela",
                        "content": "if you get this question, they do not want to hire you."
                    },
                    {
                        "username": "taroTown",
                        "content": "LMFAO"
                    },
                    {
                        "username": "user8143P",
                        "content": "hahaha, that's why I like the discussion module in Leetcode"
                    },
                    {
                        "username": "JosephHauter",
                        "content": "LMAOOO "
                    },
                    {
                        "username": "mochiball",
                        "content": "lmfaoooooo you\\'re not wrong "
                    },
                    {
                        "username": "omakovsk",
                        "content": "ahaha"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "If you can\\'t do this, they probably shouldn\\'t :P. JK, just keep practicing, if you do a bunch of tree problems, this one really is quite doable. https://leetcode.com/problems/convert-sorted-array-to-binary-search-tree/ is a good stepping stone to this one. "
                    },
                    {
                        "username": "studshubham",
                        "content": "I think this question should put in Hard category."
                    },
                    {
                        "username": "marks716",
                        "content": "I agree, on the easier spectrum of hard but still above medium. This is not the same as Binary Tree Level Order Traversal which is marked as being the same level."
                    },
                    {
                        "username": "Kashyap2502",
                        "content": "[@Mister_CK](/Mister_CK)\\n That\\'s really helpful thanks a lot"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "disagree, it\\'s quite straightforward, compared to the hard tree problems this is very doable. It builds on this Easy problem: https://leetcode.com/problems/convert-sorted-array-to-binary-search-tree/, it\\'s the same recursive build pattern but a bit more tricky due to the fact that you have to use the combination of two traversal arrays. But not that hard. "
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "[@imbobnewbie](/imbobnewbie) I think they tagged this a medium because this is something they teach in college (at least they taught us in our college) how to do, didn\\'t made us write program, but asked us this question in our exam - \\ndraw the tree and/or find the postorder if preorder and inorder is given for a binary tree."
                    },
                    {
                        "username": "davidtn",
                        "content": "For once I disagree. You only need to practice this once. The visualization comes wayyyy easier if you have a pen and paper. \n\nThere are 2 main tricks based on the concept of the most basic traversals.\n1) Know what is given for each, what isn't given. \n2) For those that aren't given, use the other givens to derive the unknowns.\n\nIf you somehow know this is about subproblems, then cutting up the arrays into small chunks each time is doable.\n\nCombining 2 concepts is standard for Medium. I solved this in 22', aiming for 15."
                    },
                    {
                        "username": "imbobnewbie",
                        "content": "[@RafeeqM](/RafeeqM) I'm going through mediums now and agree. This one requires several observations that would be fairly difficult to make during an interview unless you've solved this or numerous similar problems before. Coding portion isn't bad, but the logic is a challenge."
                    },
                    {
                        "username": "Skios",
                        "content": "i agree it\\'s pretty hard to wrap your head around. I wish there were four categories: easy, medium, hard, very hard. this is one of the hardest medium i\\'ve done"
                    },
                    {
                        "username": "davidtn",
                        "content": "Keep trying guys! I struggled with a similar problem a year ago. But today, with a piece of PEN and PAPER also vaguely remembering the \"tricks\", I solved it in 22 minutes. (Solving medium in 15\\' is standard in big tech interviews, according to a friend of mine who had done 300+ problems)\\n\\nTRICKS:\\n- preorder ALWAYS has the node first. But you don\\'t know the size of either branch.\\n- inorder ALWAYS has the left branch to the left of the node, and right branch right of the node. So now you know the size of each branch.\\n\\nTake those information and break the arrays into subproblems, based on the size.\\n"
                    },
                    {
                        "username": "PrimeDispenser",
                        "content": "Great tip, thanks!"
                    },
                    {
                        "username": "rreocode",
                        "content": "good tip many thanks "
                    },
                    {
                        "username": "mystiquecoder",
                        "content": "this question played with my emotions"
                    },
                    {
                        "username": "mochiball",
                        "content": "Good lord this question is hard af "
                    },
                    {
                        "username": "eaglesky",
                        "content": "I'm thinking about one possible follow-up question: what if duplicates are allowed in the binary tree? Can we modify the original recursive solution to get it work?"
                    },
                    {
                        "username": "SanskarGoyal_14",
                        "content": "YES, there is GFG Question for duplicates. The only difference is in finding index of element in inorder array.\\nTo solve that issue,\\n1. We can create a visited vector and pass it by reference.\\n2. Now, when searching for index, also check if visited[i] == 0, only then enter if block, change visited[i] to 1 and return i.\\n3. By doing this, we can easily skip elements that have same value as target-element but have been visited.\\n\\nCheers.. ^_^"
                    },
                    {
                        "username": "Kunal_101",
                        "content": "[@adis176](/adis176) There is a question in gfg considering duplicates.."
                    },
                    {
                        "username": "adis176",
                        "content": "Then it would not be possible to judge how many nodes actually make up the left subtree, or how many to include in the right subtree.\\nDifferent arrangement of trees can have the same inorder and preorder if duplicates are allowed, which would then render this question null."
                    },
                    {
                        "username": "puneets2811",
                        "content": "What if we have only 1 symbol repeated n times for both traversals?"
                    },
                    {
                        "username": "kharemohit786",
                        "content": "For input \\n[-1]\\n[-1]\\nIt is giving error while submitting the code but with custom input it is working fine."
                    },
                    {
                        "username": "Vikasgupta6",
                        "content": "Just reinitialized the value of your \\nstatic preOrder Index to 0, after end of the programme."
                    },
                    {
                        "username": "deadbeat253",
                        "content": "I am curious why in the example there are no nodes added to the initial left subtree (9) and the tree is continuing to be built from the initial right subtree. For example why is [3,9,20,null,null,15,7] correct but [3,9,20,15,7,null,null] is incorrect? They are both valid binary trees. How is one supposed to know which subtrees are null if the initial arrays (preorder and inorder) don\\'t contain null values?"
                    },
                    {
                        "username": "Sahil_Lohan",
                        "content": "thats why, They provided two arrays"
                    },
                    {
                        "username": "hopeNoPip",
                        "content": "So.. why do we need preorder and inorder to the same tree to build a Tree? why are both needed? "
                    },
                    {
                        "username": "anmolp476",
                        "content": "Do you still need help?"
                    },
                    {
                        "username": "MeloWang0308",
                        "content": "Awesome question. Based on my understand, you can build up multiple trees based on the same pre-order or in-order list. However, if we have two of them, we only have one solution. "
                    },
                    {
                        "username": "asong641",
                        "content": "You can't fully determine the shape of a tree with just 1 of them. \nFor example, the preorder example [3,9,20,15,7] can look like the tree given in the question or it can look like one long tree consisting of only left branches and a depth of 5 nodes. There are a couple different possibilities on how the preorder array can look as a binary tree. How do we know which one is correct? You have to use the inorder to verify."
                    },
                    {
                        "username": "roovent",
                        "content": "I simply put `return nil`, but it shows **Compile Error**. Soooo annoying!"
                    }
                ]
            },
            {
                "id": 1715862,
                "content": [
                    {
                        "username": "mohamed_waseela",
                        "content": "if you get this question, they do not want to hire you."
                    },
                    {
                        "username": "taroTown",
                        "content": "LMFAO"
                    },
                    {
                        "username": "user8143P",
                        "content": "hahaha, that's why I like the discussion module in Leetcode"
                    },
                    {
                        "username": "JosephHauter",
                        "content": "LMAOOO "
                    },
                    {
                        "username": "mochiball",
                        "content": "lmfaoooooo you\\'re not wrong "
                    },
                    {
                        "username": "omakovsk",
                        "content": "ahaha"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "If you can\\'t do this, they probably shouldn\\'t :P. JK, just keep practicing, if you do a bunch of tree problems, this one really is quite doable. https://leetcode.com/problems/convert-sorted-array-to-binary-search-tree/ is a good stepping stone to this one. "
                    },
                    {
                        "username": "studshubham",
                        "content": "I think this question should put in Hard category."
                    },
                    {
                        "username": "marks716",
                        "content": "I agree, on the easier spectrum of hard but still above medium. This is not the same as Binary Tree Level Order Traversal which is marked as being the same level."
                    },
                    {
                        "username": "Kashyap2502",
                        "content": "[@Mister_CK](/Mister_CK)\\n That\\'s really helpful thanks a lot"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "disagree, it\\'s quite straightforward, compared to the hard tree problems this is very doable. It builds on this Easy problem: https://leetcode.com/problems/convert-sorted-array-to-binary-search-tree/, it\\'s the same recursive build pattern but a bit more tricky due to the fact that you have to use the combination of two traversal arrays. But not that hard. "
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "[@imbobnewbie](/imbobnewbie) I think they tagged this a medium because this is something they teach in college (at least they taught us in our college) how to do, didn\\'t made us write program, but asked us this question in our exam - \\ndraw the tree and/or find the postorder if preorder and inorder is given for a binary tree."
                    },
                    {
                        "username": "davidtn",
                        "content": "For once I disagree. You only need to practice this once. The visualization comes wayyyy easier if you have a pen and paper. \n\nThere are 2 main tricks based on the concept of the most basic traversals.\n1) Know what is given for each, what isn't given. \n2) For those that aren't given, use the other givens to derive the unknowns.\n\nIf you somehow know this is about subproblems, then cutting up the arrays into small chunks each time is doable.\n\nCombining 2 concepts is standard for Medium. I solved this in 22', aiming for 15."
                    },
                    {
                        "username": "imbobnewbie",
                        "content": "[@RafeeqM](/RafeeqM) I'm going through mediums now and agree. This one requires several observations that would be fairly difficult to make during an interview unless you've solved this or numerous similar problems before. Coding portion isn't bad, but the logic is a challenge."
                    },
                    {
                        "username": "Skios",
                        "content": "i agree it\\'s pretty hard to wrap your head around. I wish there were four categories: easy, medium, hard, very hard. this is one of the hardest medium i\\'ve done"
                    },
                    {
                        "username": "davidtn",
                        "content": "Keep trying guys! I struggled with a similar problem a year ago. But today, with a piece of PEN and PAPER also vaguely remembering the \"tricks\", I solved it in 22 minutes. (Solving medium in 15\\' is standard in big tech interviews, according to a friend of mine who had done 300+ problems)\\n\\nTRICKS:\\n- preorder ALWAYS has the node first. But you don\\'t know the size of either branch.\\n- inorder ALWAYS has the left branch to the left of the node, and right branch right of the node. So now you know the size of each branch.\\n\\nTake those information and break the arrays into subproblems, based on the size.\\n"
                    },
                    {
                        "username": "PrimeDispenser",
                        "content": "Great tip, thanks!"
                    },
                    {
                        "username": "rreocode",
                        "content": "good tip many thanks "
                    },
                    {
                        "username": "mystiquecoder",
                        "content": "this question played with my emotions"
                    },
                    {
                        "username": "mochiball",
                        "content": "Good lord this question is hard af "
                    },
                    {
                        "username": "eaglesky",
                        "content": "I'm thinking about one possible follow-up question: what if duplicates are allowed in the binary tree? Can we modify the original recursive solution to get it work?"
                    },
                    {
                        "username": "SanskarGoyal_14",
                        "content": "YES, there is GFG Question for duplicates. The only difference is in finding index of element in inorder array.\\nTo solve that issue,\\n1. We can create a visited vector and pass it by reference.\\n2. Now, when searching for index, also check if visited[i] == 0, only then enter if block, change visited[i] to 1 and return i.\\n3. By doing this, we can easily skip elements that have same value as target-element but have been visited.\\n\\nCheers.. ^_^"
                    },
                    {
                        "username": "Kunal_101",
                        "content": "[@adis176](/adis176) There is a question in gfg considering duplicates.."
                    },
                    {
                        "username": "adis176",
                        "content": "Then it would not be possible to judge how many nodes actually make up the left subtree, or how many to include in the right subtree.\\nDifferent arrangement of trees can have the same inorder and preorder if duplicates are allowed, which would then render this question null."
                    },
                    {
                        "username": "puneets2811",
                        "content": "What if we have only 1 symbol repeated n times for both traversals?"
                    },
                    {
                        "username": "kharemohit786",
                        "content": "For input \\n[-1]\\n[-1]\\nIt is giving error while submitting the code but with custom input it is working fine."
                    },
                    {
                        "username": "Vikasgupta6",
                        "content": "Just reinitialized the value of your \\nstatic preOrder Index to 0, after end of the programme."
                    },
                    {
                        "username": "deadbeat253",
                        "content": "I am curious why in the example there are no nodes added to the initial left subtree (9) and the tree is continuing to be built from the initial right subtree. For example why is [3,9,20,null,null,15,7] correct but [3,9,20,15,7,null,null] is incorrect? They are both valid binary trees. How is one supposed to know which subtrees are null if the initial arrays (preorder and inorder) don\\'t contain null values?"
                    },
                    {
                        "username": "Sahil_Lohan",
                        "content": "thats why, They provided two arrays"
                    },
                    {
                        "username": "hopeNoPip",
                        "content": "So.. why do we need preorder and inorder to the same tree to build a Tree? why are both needed? "
                    },
                    {
                        "username": "anmolp476",
                        "content": "Do you still need help?"
                    },
                    {
                        "username": "MeloWang0308",
                        "content": "Awesome question. Based on my understand, you can build up multiple trees based on the same pre-order or in-order list. However, if we have two of them, we only have one solution. "
                    },
                    {
                        "username": "asong641",
                        "content": "You can't fully determine the shape of a tree with just 1 of them. \nFor example, the preorder example [3,9,20,15,7] can look like the tree given in the question or it can look like one long tree consisting of only left branches and a depth of 5 nodes. There are a couple different possibilities on how the preorder array can look as a binary tree. How do we know which one is correct? You have to use the inorder to verify."
                    },
                    {
                        "username": "roovent",
                        "content": "I simply put `return nil`, but it shows **Compile Error**. Soooo annoying!"
                    }
                ]
            },
            {
                "id": 1905602,
                "content": [
                    {
                        "username": "mohamed_waseela",
                        "content": "if you get this question, they do not want to hire you."
                    },
                    {
                        "username": "taroTown",
                        "content": "LMFAO"
                    },
                    {
                        "username": "user8143P",
                        "content": "hahaha, that's why I like the discussion module in Leetcode"
                    },
                    {
                        "username": "JosephHauter",
                        "content": "LMAOOO "
                    },
                    {
                        "username": "mochiball",
                        "content": "lmfaoooooo you\\'re not wrong "
                    },
                    {
                        "username": "omakovsk",
                        "content": "ahaha"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "If you can\\'t do this, they probably shouldn\\'t :P. JK, just keep practicing, if you do a bunch of tree problems, this one really is quite doable. https://leetcode.com/problems/convert-sorted-array-to-binary-search-tree/ is a good stepping stone to this one. "
                    },
                    {
                        "username": "studshubham",
                        "content": "I think this question should put in Hard category."
                    },
                    {
                        "username": "marks716",
                        "content": "I agree, on the easier spectrum of hard but still above medium. This is not the same as Binary Tree Level Order Traversal which is marked as being the same level."
                    },
                    {
                        "username": "Kashyap2502",
                        "content": "[@Mister_CK](/Mister_CK)\\n That\\'s really helpful thanks a lot"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "disagree, it\\'s quite straightforward, compared to the hard tree problems this is very doable. It builds on this Easy problem: https://leetcode.com/problems/convert-sorted-array-to-binary-search-tree/, it\\'s the same recursive build pattern but a bit more tricky due to the fact that you have to use the combination of two traversal arrays. But not that hard. "
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "[@imbobnewbie](/imbobnewbie) I think they tagged this a medium because this is something they teach in college (at least they taught us in our college) how to do, didn\\'t made us write program, but asked us this question in our exam - \\ndraw the tree and/or find the postorder if preorder and inorder is given for a binary tree."
                    },
                    {
                        "username": "davidtn",
                        "content": "For once I disagree. You only need to practice this once. The visualization comes wayyyy easier if you have a pen and paper. \n\nThere are 2 main tricks based on the concept of the most basic traversals.\n1) Know what is given for each, what isn't given. \n2) For those that aren't given, use the other givens to derive the unknowns.\n\nIf you somehow know this is about subproblems, then cutting up the arrays into small chunks each time is doable.\n\nCombining 2 concepts is standard for Medium. I solved this in 22', aiming for 15."
                    },
                    {
                        "username": "imbobnewbie",
                        "content": "[@RafeeqM](/RafeeqM) I'm going through mediums now and agree. This one requires several observations that would be fairly difficult to make during an interview unless you've solved this or numerous similar problems before. Coding portion isn't bad, but the logic is a challenge."
                    },
                    {
                        "username": "Skios",
                        "content": "i agree it\\'s pretty hard to wrap your head around. I wish there were four categories: easy, medium, hard, very hard. this is one of the hardest medium i\\'ve done"
                    },
                    {
                        "username": "davidtn",
                        "content": "Keep trying guys! I struggled with a similar problem a year ago. But today, with a piece of PEN and PAPER also vaguely remembering the \"tricks\", I solved it in 22 minutes. (Solving medium in 15\\' is standard in big tech interviews, according to a friend of mine who had done 300+ problems)\\n\\nTRICKS:\\n- preorder ALWAYS has the node first. But you don\\'t know the size of either branch.\\n- inorder ALWAYS has the left branch to the left of the node, and right branch right of the node. So now you know the size of each branch.\\n\\nTake those information and break the arrays into subproblems, based on the size.\\n"
                    },
                    {
                        "username": "PrimeDispenser",
                        "content": "Great tip, thanks!"
                    },
                    {
                        "username": "rreocode",
                        "content": "good tip many thanks "
                    },
                    {
                        "username": "mystiquecoder",
                        "content": "this question played with my emotions"
                    },
                    {
                        "username": "mochiball",
                        "content": "Good lord this question is hard af "
                    },
                    {
                        "username": "eaglesky",
                        "content": "I'm thinking about one possible follow-up question: what if duplicates are allowed in the binary tree? Can we modify the original recursive solution to get it work?"
                    },
                    {
                        "username": "SanskarGoyal_14",
                        "content": "YES, there is GFG Question for duplicates. The only difference is in finding index of element in inorder array.\\nTo solve that issue,\\n1. We can create a visited vector and pass it by reference.\\n2. Now, when searching for index, also check if visited[i] == 0, only then enter if block, change visited[i] to 1 and return i.\\n3. By doing this, we can easily skip elements that have same value as target-element but have been visited.\\n\\nCheers.. ^_^"
                    },
                    {
                        "username": "Kunal_101",
                        "content": "[@adis176](/adis176) There is a question in gfg considering duplicates.."
                    },
                    {
                        "username": "adis176",
                        "content": "Then it would not be possible to judge how many nodes actually make up the left subtree, or how many to include in the right subtree.\\nDifferent arrangement of trees can have the same inorder and preorder if duplicates are allowed, which would then render this question null."
                    },
                    {
                        "username": "puneets2811",
                        "content": "What if we have only 1 symbol repeated n times for both traversals?"
                    },
                    {
                        "username": "kharemohit786",
                        "content": "For input \\n[-1]\\n[-1]\\nIt is giving error while submitting the code but with custom input it is working fine."
                    },
                    {
                        "username": "Vikasgupta6",
                        "content": "Just reinitialized the value of your \\nstatic preOrder Index to 0, after end of the programme."
                    },
                    {
                        "username": "deadbeat253",
                        "content": "I am curious why in the example there are no nodes added to the initial left subtree (9) and the tree is continuing to be built from the initial right subtree. For example why is [3,9,20,null,null,15,7] correct but [3,9,20,15,7,null,null] is incorrect? They are both valid binary trees. How is one supposed to know which subtrees are null if the initial arrays (preorder and inorder) don\\'t contain null values?"
                    },
                    {
                        "username": "Sahil_Lohan",
                        "content": "thats why, They provided two arrays"
                    },
                    {
                        "username": "hopeNoPip",
                        "content": "So.. why do we need preorder and inorder to the same tree to build a Tree? why are both needed? "
                    },
                    {
                        "username": "anmolp476",
                        "content": "Do you still need help?"
                    },
                    {
                        "username": "MeloWang0308",
                        "content": "Awesome question. Based on my understand, you can build up multiple trees based on the same pre-order or in-order list. However, if we have two of them, we only have one solution. "
                    },
                    {
                        "username": "asong641",
                        "content": "You can't fully determine the shape of a tree with just 1 of them. \nFor example, the preorder example [3,9,20,15,7] can look like the tree given in the question or it can look like one long tree consisting of only left branches and a depth of 5 nodes. There are a couple different possibilities on how the preorder array can look as a binary tree. How do we know which one is correct? You have to use the inorder to verify."
                    },
                    {
                        "username": "roovent",
                        "content": "I simply put `return nil`, but it shows **Compile Error**. Soooo annoying!"
                    }
                ]
            },
            {
                "id": 1935086,
                "content": [
                    {
                        "username": "mohamed_waseela",
                        "content": "if you get this question, they do not want to hire you."
                    },
                    {
                        "username": "taroTown",
                        "content": "LMFAO"
                    },
                    {
                        "username": "user8143P",
                        "content": "hahaha, that's why I like the discussion module in Leetcode"
                    },
                    {
                        "username": "JosephHauter",
                        "content": "LMAOOO "
                    },
                    {
                        "username": "mochiball",
                        "content": "lmfaoooooo you\\'re not wrong "
                    },
                    {
                        "username": "omakovsk",
                        "content": "ahaha"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "If you can\\'t do this, they probably shouldn\\'t :P. JK, just keep practicing, if you do a bunch of tree problems, this one really is quite doable. https://leetcode.com/problems/convert-sorted-array-to-binary-search-tree/ is a good stepping stone to this one. "
                    },
                    {
                        "username": "studshubham",
                        "content": "I think this question should put in Hard category."
                    },
                    {
                        "username": "marks716",
                        "content": "I agree, on the easier spectrum of hard but still above medium. This is not the same as Binary Tree Level Order Traversal which is marked as being the same level."
                    },
                    {
                        "username": "Kashyap2502",
                        "content": "[@Mister_CK](/Mister_CK)\\n That\\'s really helpful thanks a lot"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "disagree, it\\'s quite straightforward, compared to the hard tree problems this is very doable. It builds on this Easy problem: https://leetcode.com/problems/convert-sorted-array-to-binary-search-tree/, it\\'s the same recursive build pattern but a bit more tricky due to the fact that you have to use the combination of two traversal arrays. But not that hard. "
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "[@imbobnewbie](/imbobnewbie) I think they tagged this a medium because this is something they teach in college (at least they taught us in our college) how to do, didn\\'t made us write program, but asked us this question in our exam - \\ndraw the tree and/or find the postorder if preorder and inorder is given for a binary tree."
                    },
                    {
                        "username": "davidtn",
                        "content": "For once I disagree. You only need to practice this once. The visualization comes wayyyy easier if you have a pen and paper. \n\nThere are 2 main tricks based on the concept of the most basic traversals.\n1) Know what is given for each, what isn't given. \n2) For those that aren't given, use the other givens to derive the unknowns.\n\nIf you somehow know this is about subproblems, then cutting up the arrays into small chunks each time is doable.\n\nCombining 2 concepts is standard for Medium. I solved this in 22', aiming for 15."
                    },
                    {
                        "username": "imbobnewbie",
                        "content": "[@RafeeqM](/RafeeqM) I'm going through mediums now and agree. This one requires several observations that would be fairly difficult to make during an interview unless you've solved this or numerous similar problems before. Coding portion isn't bad, but the logic is a challenge."
                    },
                    {
                        "username": "Skios",
                        "content": "i agree it\\'s pretty hard to wrap your head around. I wish there were four categories: easy, medium, hard, very hard. this is one of the hardest medium i\\'ve done"
                    },
                    {
                        "username": "davidtn",
                        "content": "Keep trying guys! I struggled with a similar problem a year ago. But today, with a piece of PEN and PAPER also vaguely remembering the \"tricks\", I solved it in 22 minutes. (Solving medium in 15\\' is standard in big tech interviews, according to a friend of mine who had done 300+ problems)\\n\\nTRICKS:\\n- preorder ALWAYS has the node first. But you don\\'t know the size of either branch.\\n- inorder ALWAYS has the left branch to the left of the node, and right branch right of the node. So now you know the size of each branch.\\n\\nTake those information and break the arrays into subproblems, based on the size.\\n"
                    },
                    {
                        "username": "PrimeDispenser",
                        "content": "Great tip, thanks!"
                    },
                    {
                        "username": "rreocode",
                        "content": "good tip many thanks "
                    },
                    {
                        "username": "mystiquecoder",
                        "content": "this question played with my emotions"
                    },
                    {
                        "username": "mochiball",
                        "content": "Good lord this question is hard af "
                    },
                    {
                        "username": "eaglesky",
                        "content": "I'm thinking about one possible follow-up question: what if duplicates are allowed in the binary tree? Can we modify the original recursive solution to get it work?"
                    },
                    {
                        "username": "SanskarGoyal_14",
                        "content": "YES, there is GFG Question for duplicates. The only difference is in finding index of element in inorder array.\\nTo solve that issue,\\n1. We can create a visited vector and pass it by reference.\\n2. Now, when searching for index, also check if visited[i] == 0, only then enter if block, change visited[i] to 1 and return i.\\n3. By doing this, we can easily skip elements that have same value as target-element but have been visited.\\n\\nCheers.. ^_^"
                    },
                    {
                        "username": "Kunal_101",
                        "content": "[@adis176](/adis176) There is a question in gfg considering duplicates.."
                    },
                    {
                        "username": "adis176",
                        "content": "Then it would not be possible to judge how many nodes actually make up the left subtree, or how many to include in the right subtree.\\nDifferent arrangement of trees can have the same inorder and preorder if duplicates are allowed, which would then render this question null."
                    },
                    {
                        "username": "puneets2811",
                        "content": "What if we have only 1 symbol repeated n times for both traversals?"
                    },
                    {
                        "username": "kharemohit786",
                        "content": "For input \\n[-1]\\n[-1]\\nIt is giving error while submitting the code but with custom input it is working fine."
                    },
                    {
                        "username": "Vikasgupta6",
                        "content": "Just reinitialized the value of your \\nstatic preOrder Index to 0, after end of the programme."
                    },
                    {
                        "username": "deadbeat253",
                        "content": "I am curious why in the example there are no nodes added to the initial left subtree (9) and the tree is continuing to be built from the initial right subtree. For example why is [3,9,20,null,null,15,7] correct but [3,9,20,15,7,null,null] is incorrect? They are both valid binary trees. How is one supposed to know which subtrees are null if the initial arrays (preorder and inorder) don\\'t contain null values?"
                    },
                    {
                        "username": "Sahil_Lohan",
                        "content": "thats why, They provided two arrays"
                    },
                    {
                        "username": "hopeNoPip",
                        "content": "So.. why do we need preorder and inorder to the same tree to build a Tree? why are both needed? "
                    },
                    {
                        "username": "anmolp476",
                        "content": "Do you still need help?"
                    },
                    {
                        "username": "MeloWang0308",
                        "content": "Awesome question. Based on my understand, you can build up multiple trees based on the same pre-order or in-order list. However, if we have two of them, we only have one solution. "
                    },
                    {
                        "username": "asong641",
                        "content": "You can't fully determine the shape of a tree with just 1 of them. \nFor example, the preorder example [3,9,20,15,7] can look like the tree given in the question or it can look like one long tree consisting of only left branches and a depth of 5 nodes. There are a couple different possibilities on how the preorder array can look as a binary tree. How do we know which one is correct? You have to use the inorder to verify."
                    },
                    {
                        "username": "roovent",
                        "content": "I simply put `return nil`, but it shows **Compile Error**. Soooo annoying!"
                    }
                ]
            },
            {
                "id": 1568928,
                "content": [
                    {
                        "username": "mohamed_waseela",
                        "content": "if you get this question, they do not want to hire you."
                    },
                    {
                        "username": "taroTown",
                        "content": "LMFAO"
                    },
                    {
                        "username": "user8143P",
                        "content": "hahaha, that's why I like the discussion module in Leetcode"
                    },
                    {
                        "username": "JosephHauter",
                        "content": "LMAOOO "
                    },
                    {
                        "username": "mochiball",
                        "content": "lmfaoooooo you\\'re not wrong "
                    },
                    {
                        "username": "omakovsk",
                        "content": "ahaha"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "If you can\\'t do this, they probably shouldn\\'t :P. JK, just keep practicing, if you do a bunch of tree problems, this one really is quite doable. https://leetcode.com/problems/convert-sorted-array-to-binary-search-tree/ is a good stepping stone to this one. "
                    },
                    {
                        "username": "studshubham",
                        "content": "I think this question should put in Hard category."
                    },
                    {
                        "username": "marks716",
                        "content": "I agree, on the easier spectrum of hard but still above medium. This is not the same as Binary Tree Level Order Traversal which is marked as being the same level."
                    },
                    {
                        "username": "Kashyap2502",
                        "content": "[@Mister_CK](/Mister_CK)\\n That\\'s really helpful thanks a lot"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "disagree, it\\'s quite straightforward, compared to the hard tree problems this is very doable. It builds on this Easy problem: https://leetcode.com/problems/convert-sorted-array-to-binary-search-tree/, it\\'s the same recursive build pattern but a bit more tricky due to the fact that you have to use the combination of two traversal arrays. But not that hard. "
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "[@imbobnewbie](/imbobnewbie) I think they tagged this a medium because this is something they teach in college (at least they taught us in our college) how to do, didn\\'t made us write program, but asked us this question in our exam - \\ndraw the tree and/or find the postorder if preorder and inorder is given for a binary tree."
                    },
                    {
                        "username": "davidtn",
                        "content": "For once I disagree. You only need to practice this once. The visualization comes wayyyy easier if you have a pen and paper. \n\nThere are 2 main tricks based on the concept of the most basic traversals.\n1) Know what is given for each, what isn't given. \n2) For those that aren't given, use the other givens to derive the unknowns.\n\nIf you somehow know this is about subproblems, then cutting up the arrays into small chunks each time is doable.\n\nCombining 2 concepts is standard for Medium. I solved this in 22', aiming for 15."
                    },
                    {
                        "username": "imbobnewbie",
                        "content": "[@RafeeqM](/RafeeqM) I'm going through mediums now and agree. This one requires several observations that would be fairly difficult to make during an interview unless you've solved this or numerous similar problems before. Coding portion isn't bad, but the logic is a challenge."
                    },
                    {
                        "username": "Skios",
                        "content": "i agree it\\'s pretty hard to wrap your head around. I wish there were four categories: easy, medium, hard, very hard. this is one of the hardest medium i\\'ve done"
                    },
                    {
                        "username": "davidtn",
                        "content": "Keep trying guys! I struggled with a similar problem a year ago. But today, with a piece of PEN and PAPER also vaguely remembering the \"tricks\", I solved it in 22 minutes. (Solving medium in 15\\' is standard in big tech interviews, according to a friend of mine who had done 300+ problems)\\n\\nTRICKS:\\n- preorder ALWAYS has the node first. But you don\\'t know the size of either branch.\\n- inorder ALWAYS has the left branch to the left of the node, and right branch right of the node. So now you know the size of each branch.\\n\\nTake those information and break the arrays into subproblems, based on the size.\\n"
                    },
                    {
                        "username": "PrimeDispenser",
                        "content": "Great tip, thanks!"
                    },
                    {
                        "username": "rreocode",
                        "content": "good tip many thanks "
                    },
                    {
                        "username": "mystiquecoder",
                        "content": "this question played with my emotions"
                    },
                    {
                        "username": "mochiball",
                        "content": "Good lord this question is hard af "
                    },
                    {
                        "username": "eaglesky",
                        "content": "I'm thinking about one possible follow-up question: what if duplicates are allowed in the binary tree? Can we modify the original recursive solution to get it work?"
                    },
                    {
                        "username": "SanskarGoyal_14",
                        "content": "YES, there is GFG Question for duplicates. The only difference is in finding index of element in inorder array.\\nTo solve that issue,\\n1. We can create a visited vector and pass it by reference.\\n2. Now, when searching for index, also check if visited[i] == 0, only then enter if block, change visited[i] to 1 and return i.\\n3. By doing this, we can easily skip elements that have same value as target-element but have been visited.\\n\\nCheers.. ^_^"
                    },
                    {
                        "username": "Kunal_101",
                        "content": "[@adis176](/adis176) There is a question in gfg considering duplicates.."
                    },
                    {
                        "username": "adis176",
                        "content": "Then it would not be possible to judge how many nodes actually make up the left subtree, or how many to include in the right subtree.\\nDifferent arrangement of trees can have the same inorder and preorder if duplicates are allowed, which would then render this question null."
                    },
                    {
                        "username": "puneets2811",
                        "content": "What if we have only 1 symbol repeated n times for both traversals?"
                    },
                    {
                        "username": "kharemohit786",
                        "content": "For input \\n[-1]\\n[-1]\\nIt is giving error while submitting the code but with custom input it is working fine."
                    },
                    {
                        "username": "Vikasgupta6",
                        "content": "Just reinitialized the value of your \\nstatic preOrder Index to 0, after end of the programme."
                    },
                    {
                        "username": "deadbeat253",
                        "content": "I am curious why in the example there are no nodes added to the initial left subtree (9) and the tree is continuing to be built from the initial right subtree. For example why is [3,9,20,null,null,15,7] correct but [3,9,20,15,7,null,null] is incorrect? They are both valid binary trees. How is one supposed to know which subtrees are null if the initial arrays (preorder and inorder) don\\'t contain null values?"
                    },
                    {
                        "username": "Sahil_Lohan",
                        "content": "thats why, They provided two arrays"
                    },
                    {
                        "username": "hopeNoPip",
                        "content": "So.. why do we need preorder and inorder to the same tree to build a Tree? why are both needed? "
                    },
                    {
                        "username": "anmolp476",
                        "content": "Do you still need help?"
                    },
                    {
                        "username": "MeloWang0308",
                        "content": "Awesome question. Based on my understand, you can build up multiple trees based on the same pre-order or in-order list. However, if we have two of them, we only have one solution. "
                    },
                    {
                        "username": "asong641",
                        "content": "You can't fully determine the shape of a tree with just 1 of them. \nFor example, the preorder example [3,9,20,15,7] can look like the tree given in the question or it can look like one long tree consisting of only left branches and a depth of 5 nodes. There are a couple different possibilities on how the preorder array can look as a binary tree. How do we know which one is correct? You have to use the inorder to verify."
                    },
                    {
                        "username": "roovent",
                        "content": "I simply put `return nil`, but it shows **Compile Error**. Soooo annoying!"
                    }
                ]
            },
            {
                "id": 1572690,
                "content": [
                    {
                        "username": "mohamed_waseela",
                        "content": "if you get this question, they do not want to hire you."
                    },
                    {
                        "username": "taroTown",
                        "content": "LMFAO"
                    },
                    {
                        "username": "user8143P",
                        "content": "hahaha, that's why I like the discussion module in Leetcode"
                    },
                    {
                        "username": "JosephHauter",
                        "content": "LMAOOO "
                    },
                    {
                        "username": "mochiball",
                        "content": "lmfaoooooo you\\'re not wrong "
                    },
                    {
                        "username": "omakovsk",
                        "content": "ahaha"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "If you can\\'t do this, they probably shouldn\\'t :P. JK, just keep practicing, if you do a bunch of tree problems, this one really is quite doable. https://leetcode.com/problems/convert-sorted-array-to-binary-search-tree/ is a good stepping stone to this one. "
                    },
                    {
                        "username": "studshubham",
                        "content": "I think this question should put in Hard category."
                    },
                    {
                        "username": "marks716",
                        "content": "I agree, on the easier spectrum of hard but still above medium. This is not the same as Binary Tree Level Order Traversal which is marked as being the same level."
                    },
                    {
                        "username": "Kashyap2502",
                        "content": "[@Mister_CK](/Mister_CK)\\n That\\'s really helpful thanks a lot"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "disagree, it\\'s quite straightforward, compared to the hard tree problems this is very doable. It builds on this Easy problem: https://leetcode.com/problems/convert-sorted-array-to-binary-search-tree/, it\\'s the same recursive build pattern but a bit more tricky due to the fact that you have to use the combination of two traversal arrays. But not that hard. "
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "[@imbobnewbie](/imbobnewbie) I think they tagged this a medium because this is something they teach in college (at least they taught us in our college) how to do, didn\\'t made us write program, but asked us this question in our exam - \\ndraw the tree and/or find the postorder if preorder and inorder is given for a binary tree."
                    },
                    {
                        "username": "davidtn",
                        "content": "For once I disagree. You only need to practice this once. The visualization comes wayyyy easier if you have a pen and paper. \n\nThere are 2 main tricks based on the concept of the most basic traversals.\n1) Know what is given for each, what isn't given. \n2) For those that aren't given, use the other givens to derive the unknowns.\n\nIf you somehow know this is about subproblems, then cutting up the arrays into small chunks each time is doable.\n\nCombining 2 concepts is standard for Medium. I solved this in 22', aiming for 15."
                    },
                    {
                        "username": "imbobnewbie",
                        "content": "[@RafeeqM](/RafeeqM) I'm going through mediums now and agree. This one requires several observations that would be fairly difficult to make during an interview unless you've solved this or numerous similar problems before. Coding portion isn't bad, but the logic is a challenge."
                    },
                    {
                        "username": "Skios",
                        "content": "i agree it\\'s pretty hard to wrap your head around. I wish there were four categories: easy, medium, hard, very hard. this is one of the hardest medium i\\'ve done"
                    },
                    {
                        "username": "davidtn",
                        "content": "Keep trying guys! I struggled with a similar problem a year ago. But today, with a piece of PEN and PAPER also vaguely remembering the \"tricks\", I solved it in 22 minutes. (Solving medium in 15\\' is standard in big tech interviews, according to a friend of mine who had done 300+ problems)\\n\\nTRICKS:\\n- preorder ALWAYS has the node first. But you don\\'t know the size of either branch.\\n- inorder ALWAYS has the left branch to the left of the node, and right branch right of the node. So now you know the size of each branch.\\n\\nTake those information and break the arrays into subproblems, based on the size.\\n"
                    },
                    {
                        "username": "PrimeDispenser",
                        "content": "Great tip, thanks!"
                    },
                    {
                        "username": "rreocode",
                        "content": "good tip many thanks "
                    },
                    {
                        "username": "mystiquecoder",
                        "content": "this question played with my emotions"
                    },
                    {
                        "username": "mochiball",
                        "content": "Good lord this question is hard af "
                    },
                    {
                        "username": "eaglesky",
                        "content": "I'm thinking about one possible follow-up question: what if duplicates are allowed in the binary tree? Can we modify the original recursive solution to get it work?"
                    },
                    {
                        "username": "SanskarGoyal_14",
                        "content": "YES, there is GFG Question for duplicates. The only difference is in finding index of element in inorder array.\\nTo solve that issue,\\n1. We can create a visited vector and pass it by reference.\\n2. Now, when searching for index, also check if visited[i] == 0, only then enter if block, change visited[i] to 1 and return i.\\n3. By doing this, we can easily skip elements that have same value as target-element but have been visited.\\n\\nCheers.. ^_^"
                    },
                    {
                        "username": "Kunal_101",
                        "content": "[@adis176](/adis176) There is a question in gfg considering duplicates.."
                    },
                    {
                        "username": "adis176",
                        "content": "Then it would not be possible to judge how many nodes actually make up the left subtree, or how many to include in the right subtree.\\nDifferent arrangement of trees can have the same inorder and preorder if duplicates are allowed, which would then render this question null."
                    },
                    {
                        "username": "puneets2811",
                        "content": "What if we have only 1 symbol repeated n times for both traversals?"
                    },
                    {
                        "username": "kharemohit786",
                        "content": "For input \\n[-1]\\n[-1]\\nIt is giving error while submitting the code but with custom input it is working fine."
                    },
                    {
                        "username": "Vikasgupta6",
                        "content": "Just reinitialized the value of your \\nstatic preOrder Index to 0, after end of the programme."
                    },
                    {
                        "username": "deadbeat253",
                        "content": "I am curious why in the example there are no nodes added to the initial left subtree (9) and the tree is continuing to be built from the initial right subtree. For example why is [3,9,20,null,null,15,7] correct but [3,9,20,15,7,null,null] is incorrect? They are both valid binary trees. How is one supposed to know which subtrees are null if the initial arrays (preorder and inorder) don\\'t contain null values?"
                    },
                    {
                        "username": "Sahil_Lohan",
                        "content": "thats why, They provided two arrays"
                    },
                    {
                        "username": "hopeNoPip",
                        "content": "So.. why do we need preorder and inorder to the same tree to build a Tree? why are both needed? "
                    },
                    {
                        "username": "anmolp476",
                        "content": "Do you still need help?"
                    },
                    {
                        "username": "MeloWang0308",
                        "content": "Awesome question. Based on my understand, you can build up multiple trees based on the same pre-order or in-order list. However, if we have two of them, we only have one solution. "
                    },
                    {
                        "username": "asong641",
                        "content": "You can't fully determine the shape of a tree with just 1 of them. \nFor example, the preorder example [3,9,20,15,7] can look like the tree given in the question or it can look like one long tree consisting of only left branches and a depth of 5 nodes. There are a couple different possibilities on how the preorder array can look as a binary tree. How do we know which one is correct? You have to use the inorder to verify."
                    },
                    {
                        "username": "roovent",
                        "content": "I simply put `return nil`, but it shows **Compile Error**. Soooo annoying!"
                    }
                ]
            },
            {
                "id": 1573070,
                "content": [
                    {
                        "username": "mohamed_waseela",
                        "content": "if you get this question, they do not want to hire you."
                    },
                    {
                        "username": "taroTown",
                        "content": "LMFAO"
                    },
                    {
                        "username": "user8143P",
                        "content": "hahaha, that's why I like the discussion module in Leetcode"
                    },
                    {
                        "username": "JosephHauter",
                        "content": "LMAOOO "
                    },
                    {
                        "username": "mochiball",
                        "content": "lmfaoooooo you\\'re not wrong "
                    },
                    {
                        "username": "omakovsk",
                        "content": "ahaha"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "If you can\\'t do this, they probably shouldn\\'t :P. JK, just keep practicing, if you do a bunch of tree problems, this one really is quite doable. https://leetcode.com/problems/convert-sorted-array-to-binary-search-tree/ is a good stepping stone to this one. "
                    },
                    {
                        "username": "studshubham",
                        "content": "I think this question should put in Hard category."
                    },
                    {
                        "username": "marks716",
                        "content": "I agree, on the easier spectrum of hard but still above medium. This is not the same as Binary Tree Level Order Traversal which is marked as being the same level."
                    },
                    {
                        "username": "Kashyap2502",
                        "content": "[@Mister_CK](/Mister_CK)\\n That\\'s really helpful thanks a lot"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "disagree, it\\'s quite straightforward, compared to the hard tree problems this is very doable. It builds on this Easy problem: https://leetcode.com/problems/convert-sorted-array-to-binary-search-tree/, it\\'s the same recursive build pattern but a bit more tricky due to the fact that you have to use the combination of two traversal arrays. But not that hard. "
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "[@imbobnewbie](/imbobnewbie) I think they tagged this a medium because this is something they teach in college (at least they taught us in our college) how to do, didn\\'t made us write program, but asked us this question in our exam - \\ndraw the tree and/or find the postorder if preorder and inorder is given for a binary tree."
                    },
                    {
                        "username": "davidtn",
                        "content": "For once I disagree. You only need to practice this once. The visualization comes wayyyy easier if you have a pen and paper. \n\nThere are 2 main tricks based on the concept of the most basic traversals.\n1) Know what is given for each, what isn't given. \n2) For those that aren't given, use the other givens to derive the unknowns.\n\nIf you somehow know this is about subproblems, then cutting up the arrays into small chunks each time is doable.\n\nCombining 2 concepts is standard for Medium. I solved this in 22', aiming for 15."
                    },
                    {
                        "username": "imbobnewbie",
                        "content": "[@RafeeqM](/RafeeqM) I'm going through mediums now and agree. This one requires several observations that would be fairly difficult to make during an interview unless you've solved this or numerous similar problems before. Coding portion isn't bad, but the logic is a challenge."
                    },
                    {
                        "username": "Skios",
                        "content": "i agree it\\'s pretty hard to wrap your head around. I wish there were four categories: easy, medium, hard, very hard. this is one of the hardest medium i\\'ve done"
                    },
                    {
                        "username": "davidtn",
                        "content": "Keep trying guys! I struggled with a similar problem a year ago. But today, with a piece of PEN and PAPER also vaguely remembering the \"tricks\", I solved it in 22 minutes. (Solving medium in 15\\' is standard in big tech interviews, according to a friend of mine who had done 300+ problems)\\n\\nTRICKS:\\n- preorder ALWAYS has the node first. But you don\\'t know the size of either branch.\\n- inorder ALWAYS has the left branch to the left of the node, and right branch right of the node. So now you know the size of each branch.\\n\\nTake those information and break the arrays into subproblems, based on the size.\\n"
                    },
                    {
                        "username": "PrimeDispenser",
                        "content": "Great tip, thanks!"
                    },
                    {
                        "username": "rreocode",
                        "content": "good tip many thanks "
                    },
                    {
                        "username": "mystiquecoder",
                        "content": "this question played with my emotions"
                    },
                    {
                        "username": "mochiball",
                        "content": "Good lord this question is hard af "
                    },
                    {
                        "username": "eaglesky",
                        "content": "I'm thinking about one possible follow-up question: what if duplicates are allowed in the binary tree? Can we modify the original recursive solution to get it work?"
                    },
                    {
                        "username": "SanskarGoyal_14",
                        "content": "YES, there is GFG Question for duplicates. The only difference is in finding index of element in inorder array.\\nTo solve that issue,\\n1. We can create a visited vector and pass it by reference.\\n2. Now, when searching for index, also check if visited[i] == 0, only then enter if block, change visited[i] to 1 and return i.\\n3. By doing this, we can easily skip elements that have same value as target-element but have been visited.\\n\\nCheers.. ^_^"
                    },
                    {
                        "username": "Kunal_101",
                        "content": "[@adis176](/adis176) There is a question in gfg considering duplicates.."
                    },
                    {
                        "username": "adis176",
                        "content": "Then it would not be possible to judge how many nodes actually make up the left subtree, or how many to include in the right subtree.\\nDifferent arrangement of trees can have the same inorder and preorder if duplicates are allowed, which would then render this question null."
                    },
                    {
                        "username": "puneets2811",
                        "content": "What if we have only 1 symbol repeated n times for both traversals?"
                    },
                    {
                        "username": "kharemohit786",
                        "content": "For input \\n[-1]\\n[-1]\\nIt is giving error while submitting the code but with custom input it is working fine."
                    },
                    {
                        "username": "Vikasgupta6",
                        "content": "Just reinitialized the value of your \\nstatic preOrder Index to 0, after end of the programme."
                    },
                    {
                        "username": "deadbeat253",
                        "content": "I am curious why in the example there are no nodes added to the initial left subtree (9) and the tree is continuing to be built from the initial right subtree. For example why is [3,9,20,null,null,15,7] correct but [3,9,20,15,7,null,null] is incorrect? They are both valid binary trees. How is one supposed to know which subtrees are null if the initial arrays (preorder and inorder) don\\'t contain null values?"
                    },
                    {
                        "username": "Sahil_Lohan",
                        "content": "thats why, They provided two arrays"
                    },
                    {
                        "username": "hopeNoPip",
                        "content": "So.. why do we need preorder and inorder to the same tree to build a Tree? why are both needed? "
                    },
                    {
                        "username": "anmolp476",
                        "content": "Do you still need help?"
                    },
                    {
                        "username": "MeloWang0308",
                        "content": "Awesome question. Based on my understand, you can build up multiple trees based on the same pre-order or in-order list. However, if we have two of them, we only have one solution. "
                    },
                    {
                        "username": "asong641",
                        "content": "You can't fully determine the shape of a tree with just 1 of them. \nFor example, the preorder example [3,9,20,15,7] can look like the tree given in the question or it can look like one long tree consisting of only left branches and a depth of 5 nodes. There are a couple different possibilities on how the preorder array can look as a binary tree. How do we know which one is correct? You have to use the inorder to verify."
                    },
                    {
                        "username": "roovent",
                        "content": "I simply put `return nil`, but it shows **Compile Error**. Soooo annoying!"
                    }
                ]
            },
            {
                "id": 1729910,
                "content": [
                    {
                        "username": "mohamed_waseela",
                        "content": "if you get this question, they do not want to hire you."
                    },
                    {
                        "username": "taroTown",
                        "content": "LMFAO"
                    },
                    {
                        "username": "user8143P",
                        "content": "hahaha, that's why I like the discussion module in Leetcode"
                    },
                    {
                        "username": "JosephHauter",
                        "content": "LMAOOO "
                    },
                    {
                        "username": "mochiball",
                        "content": "lmfaoooooo you\\'re not wrong "
                    },
                    {
                        "username": "omakovsk",
                        "content": "ahaha"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "If you can\\'t do this, they probably shouldn\\'t :P. JK, just keep practicing, if you do a bunch of tree problems, this one really is quite doable. https://leetcode.com/problems/convert-sorted-array-to-binary-search-tree/ is a good stepping stone to this one. "
                    },
                    {
                        "username": "studshubham",
                        "content": "I think this question should put in Hard category."
                    },
                    {
                        "username": "marks716",
                        "content": "I agree, on the easier spectrum of hard but still above medium. This is not the same as Binary Tree Level Order Traversal which is marked as being the same level."
                    },
                    {
                        "username": "Kashyap2502",
                        "content": "[@Mister_CK](/Mister_CK)\\n That\\'s really helpful thanks a lot"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "disagree, it\\'s quite straightforward, compared to the hard tree problems this is very doable. It builds on this Easy problem: https://leetcode.com/problems/convert-sorted-array-to-binary-search-tree/, it\\'s the same recursive build pattern but a bit more tricky due to the fact that you have to use the combination of two traversal arrays. But not that hard. "
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "[@imbobnewbie](/imbobnewbie) I think they tagged this a medium because this is something they teach in college (at least they taught us in our college) how to do, didn\\'t made us write program, but asked us this question in our exam - \\ndraw the tree and/or find the postorder if preorder and inorder is given for a binary tree."
                    },
                    {
                        "username": "davidtn",
                        "content": "For once I disagree. You only need to practice this once. The visualization comes wayyyy easier if you have a pen and paper. \n\nThere are 2 main tricks based on the concept of the most basic traversals.\n1) Know what is given for each, what isn't given. \n2) For those that aren't given, use the other givens to derive the unknowns.\n\nIf you somehow know this is about subproblems, then cutting up the arrays into small chunks each time is doable.\n\nCombining 2 concepts is standard for Medium. I solved this in 22', aiming for 15."
                    },
                    {
                        "username": "imbobnewbie",
                        "content": "[@RafeeqM](/RafeeqM) I'm going through mediums now and agree. This one requires several observations that would be fairly difficult to make during an interview unless you've solved this or numerous similar problems before. Coding portion isn't bad, but the logic is a challenge."
                    },
                    {
                        "username": "Skios",
                        "content": "i agree it\\'s pretty hard to wrap your head around. I wish there were four categories: easy, medium, hard, very hard. this is one of the hardest medium i\\'ve done"
                    },
                    {
                        "username": "davidtn",
                        "content": "Keep trying guys! I struggled with a similar problem a year ago. But today, with a piece of PEN and PAPER also vaguely remembering the \"tricks\", I solved it in 22 minutes. (Solving medium in 15\\' is standard in big tech interviews, according to a friend of mine who had done 300+ problems)\\n\\nTRICKS:\\n- preorder ALWAYS has the node first. But you don\\'t know the size of either branch.\\n- inorder ALWAYS has the left branch to the left of the node, and right branch right of the node. So now you know the size of each branch.\\n\\nTake those information and break the arrays into subproblems, based on the size.\\n"
                    },
                    {
                        "username": "PrimeDispenser",
                        "content": "Great tip, thanks!"
                    },
                    {
                        "username": "rreocode",
                        "content": "good tip many thanks "
                    },
                    {
                        "username": "mystiquecoder",
                        "content": "this question played with my emotions"
                    },
                    {
                        "username": "mochiball",
                        "content": "Good lord this question is hard af "
                    },
                    {
                        "username": "eaglesky",
                        "content": "I'm thinking about one possible follow-up question: what if duplicates are allowed in the binary tree? Can we modify the original recursive solution to get it work?"
                    },
                    {
                        "username": "SanskarGoyal_14",
                        "content": "YES, there is GFG Question for duplicates. The only difference is in finding index of element in inorder array.\\nTo solve that issue,\\n1. We can create a visited vector and pass it by reference.\\n2. Now, when searching for index, also check if visited[i] == 0, only then enter if block, change visited[i] to 1 and return i.\\n3. By doing this, we can easily skip elements that have same value as target-element but have been visited.\\n\\nCheers.. ^_^"
                    },
                    {
                        "username": "Kunal_101",
                        "content": "[@adis176](/adis176) There is a question in gfg considering duplicates.."
                    },
                    {
                        "username": "adis176",
                        "content": "Then it would not be possible to judge how many nodes actually make up the left subtree, or how many to include in the right subtree.\\nDifferent arrangement of trees can have the same inorder and preorder if duplicates are allowed, which would then render this question null."
                    },
                    {
                        "username": "puneets2811",
                        "content": "What if we have only 1 symbol repeated n times for both traversals?"
                    },
                    {
                        "username": "kharemohit786",
                        "content": "For input \\n[-1]\\n[-1]\\nIt is giving error while submitting the code but with custom input it is working fine."
                    },
                    {
                        "username": "Vikasgupta6",
                        "content": "Just reinitialized the value of your \\nstatic preOrder Index to 0, after end of the programme."
                    },
                    {
                        "username": "deadbeat253",
                        "content": "I am curious why in the example there are no nodes added to the initial left subtree (9) and the tree is continuing to be built from the initial right subtree. For example why is [3,9,20,null,null,15,7] correct but [3,9,20,15,7,null,null] is incorrect? They are both valid binary trees. How is one supposed to know which subtrees are null if the initial arrays (preorder and inorder) don\\'t contain null values?"
                    },
                    {
                        "username": "Sahil_Lohan",
                        "content": "thats why, They provided two arrays"
                    },
                    {
                        "username": "hopeNoPip",
                        "content": "So.. why do we need preorder and inorder to the same tree to build a Tree? why are both needed? "
                    },
                    {
                        "username": "anmolp476",
                        "content": "Do you still need help?"
                    },
                    {
                        "username": "MeloWang0308",
                        "content": "Awesome question. Based on my understand, you can build up multiple trees based on the same pre-order or in-order list. However, if we have two of them, we only have one solution. "
                    },
                    {
                        "username": "asong641",
                        "content": "You can't fully determine the shape of a tree with just 1 of them. \nFor example, the preorder example [3,9,20,15,7] can look like the tree given in the question or it can look like one long tree consisting of only left branches and a depth of 5 nodes. There are a couple different possibilities on how the preorder array can look as a binary tree. How do we know which one is correct? You have to use the inorder to verify."
                    },
                    {
                        "username": "roovent",
                        "content": "I simply put `return nil`, but it shows **Compile Error**. Soooo annoying!"
                    }
                ]
            },
            {
                "id": 1567311,
                "content": [
                    {
                        "username": "mohamed_waseela",
                        "content": "if you get this question, they do not want to hire you."
                    },
                    {
                        "username": "taroTown",
                        "content": "LMFAO"
                    },
                    {
                        "username": "user8143P",
                        "content": "hahaha, that's why I like the discussion module in Leetcode"
                    },
                    {
                        "username": "JosephHauter",
                        "content": "LMAOOO "
                    },
                    {
                        "username": "mochiball",
                        "content": "lmfaoooooo you\\'re not wrong "
                    },
                    {
                        "username": "omakovsk",
                        "content": "ahaha"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "If you can\\'t do this, they probably shouldn\\'t :P. JK, just keep practicing, if you do a bunch of tree problems, this one really is quite doable. https://leetcode.com/problems/convert-sorted-array-to-binary-search-tree/ is a good stepping stone to this one. "
                    },
                    {
                        "username": "studshubham",
                        "content": "I think this question should put in Hard category."
                    },
                    {
                        "username": "marks716",
                        "content": "I agree, on the easier spectrum of hard but still above medium. This is not the same as Binary Tree Level Order Traversal which is marked as being the same level."
                    },
                    {
                        "username": "Kashyap2502",
                        "content": "[@Mister_CK](/Mister_CK)\\n That\\'s really helpful thanks a lot"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "disagree, it\\'s quite straightforward, compared to the hard tree problems this is very doable. It builds on this Easy problem: https://leetcode.com/problems/convert-sorted-array-to-binary-search-tree/, it\\'s the same recursive build pattern but a bit more tricky due to the fact that you have to use the combination of two traversal arrays. But not that hard. "
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "[@imbobnewbie](/imbobnewbie) I think they tagged this a medium because this is something they teach in college (at least they taught us in our college) how to do, didn\\'t made us write program, but asked us this question in our exam - \\ndraw the tree and/or find the postorder if preorder and inorder is given for a binary tree."
                    },
                    {
                        "username": "davidtn",
                        "content": "For once I disagree. You only need to practice this once. The visualization comes wayyyy easier if you have a pen and paper. \n\nThere are 2 main tricks based on the concept of the most basic traversals.\n1) Know what is given for each, what isn't given. \n2) For those that aren't given, use the other givens to derive the unknowns.\n\nIf you somehow know this is about subproblems, then cutting up the arrays into small chunks each time is doable.\n\nCombining 2 concepts is standard for Medium. I solved this in 22', aiming for 15."
                    },
                    {
                        "username": "imbobnewbie",
                        "content": "[@RafeeqM](/RafeeqM) I'm going through mediums now and agree. This one requires several observations that would be fairly difficult to make during an interview unless you've solved this or numerous similar problems before. Coding portion isn't bad, but the logic is a challenge."
                    },
                    {
                        "username": "Skios",
                        "content": "i agree it\\'s pretty hard to wrap your head around. I wish there were four categories: easy, medium, hard, very hard. this is one of the hardest medium i\\'ve done"
                    },
                    {
                        "username": "davidtn",
                        "content": "Keep trying guys! I struggled with a similar problem a year ago. But today, with a piece of PEN and PAPER also vaguely remembering the \"tricks\", I solved it in 22 minutes. (Solving medium in 15\\' is standard in big tech interviews, according to a friend of mine who had done 300+ problems)\\n\\nTRICKS:\\n- preorder ALWAYS has the node first. But you don\\'t know the size of either branch.\\n- inorder ALWAYS has the left branch to the left of the node, and right branch right of the node. So now you know the size of each branch.\\n\\nTake those information and break the arrays into subproblems, based on the size.\\n"
                    },
                    {
                        "username": "PrimeDispenser",
                        "content": "Great tip, thanks!"
                    },
                    {
                        "username": "rreocode",
                        "content": "good tip many thanks "
                    },
                    {
                        "username": "mystiquecoder",
                        "content": "this question played with my emotions"
                    },
                    {
                        "username": "mochiball",
                        "content": "Good lord this question is hard af "
                    },
                    {
                        "username": "eaglesky",
                        "content": "I'm thinking about one possible follow-up question: what if duplicates are allowed in the binary tree? Can we modify the original recursive solution to get it work?"
                    },
                    {
                        "username": "SanskarGoyal_14",
                        "content": "YES, there is GFG Question for duplicates. The only difference is in finding index of element in inorder array.\\nTo solve that issue,\\n1. We can create a visited vector and pass it by reference.\\n2. Now, when searching for index, also check if visited[i] == 0, only then enter if block, change visited[i] to 1 and return i.\\n3. By doing this, we can easily skip elements that have same value as target-element but have been visited.\\n\\nCheers.. ^_^"
                    },
                    {
                        "username": "Kunal_101",
                        "content": "[@adis176](/adis176) There is a question in gfg considering duplicates.."
                    },
                    {
                        "username": "adis176",
                        "content": "Then it would not be possible to judge how many nodes actually make up the left subtree, or how many to include in the right subtree.\\nDifferent arrangement of trees can have the same inorder and preorder if duplicates are allowed, which would then render this question null."
                    },
                    {
                        "username": "puneets2811",
                        "content": "What if we have only 1 symbol repeated n times for both traversals?"
                    },
                    {
                        "username": "kharemohit786",
                        "content": "For input \\n[-1]\\n[-1]\\nIt is giving error while submitting the code but with custom input it is working fine."
                    },
                    {
                        "username": "Vikasgupta6",
                        "content": "Just reinitialized the value of your \\nstatic preOrder Index to 0, after end of the programme."
                    },
                    {
                        "username": "deadbeat253",
                        "content": "I am curious why in the example there are no nodes added to the initial left subtree (9) and the tree is continuing to be built from the initial right subtree. For example why is [3,9,20,null,null,15,7] correct but [3,9,20,15,7,null,null] is incorrect? They are both valid binary trees. How is one supposed to know which subtrees are null if the initial arrays (preorder and inorder) don\\'t contain null values?"
                    },
                    {
                        "username": "Sahil_Lohan",
                        "content": "thats why, They provided two arrays"
                    },
                    {
                        "username": "hopeNoPip",
                        "content": "So.. why do we need preorder and inorder to the same tree to build a Tree? why are both needed? "
                    },
                    {
                        "username": "anmolp476",
                        "content": "Do you still need help?"
                    },
                    {
                        "username": "MeloWang0308",
                        "content": "Awesome question. Based on my understand, you can build up multiple trees based on the same pre-order or in-order list. However, if we have two of them, we only have one solution. "
                    },
                    {
                        "username": "asong641",
                        "content": "You can't fully determine the shape of a tree with just 1 of them. \nFor example, the preorder example [3,9,20,15,7] can look like the tree given in the question or it can look like one long tree consisting of only left branches and a depth of 5 nodes. There are a couple different possibilities on how the preorder array can look as a binary tree. How do we know which one is correct? You have to use the inorder to verify."
                    },
                    {
                        "username": "roovent",
                        "content": "I simply put `return nil`, but it shows **Compile Error**. Soooo annoying!"
                    }
                ]
            },
            {
                "id": 1717092,
                "content": [
                    {
                        "username": "mohamed_waseela",
                        "content": "if you get this question, they do not want to hire you."
                    },
                    {
                        "username": "taroTown",
                        "content": "LMFAO"
                    },
                    {
                        "username": "user8143P",
                        "content": "hahaha, that's why I like the discussion module in Leetcode"
                    },
                    {
                        "username": "JosephHauter",
                        "content": "LMAOOO "
                    },
                    {
                        "username": "mochiball",
                        "content": "lmfaoooooo you\\'re not wrong "
                    },
                    {
                        "username": "omakovsk",
                        "content": "ahaha"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "If you can\\'t do this, they probably shouldn\\'t :P. JK, just keep practicing, if you do a bunch of tree problems, this one really is quite doable. https://leetcode.com/problems/convert-sorted-array-to-binary-search-tree/ is a good stepping stone to this one. "
                    },
                    {
                        "username": "studshubham",
                        "content": "I think this question should put in Hard category."
                    },
                    {
                        "username": "marks716",
                        "content": "I agree, on the easier spectrum of hard but still above medium. This is not the same as Binary Tree Level Order Traversal which is marked as being the same level."
                    },
                    {
                        "username": "Kashyap2502",
                        "content": "[@Mister_CK](/Mister_CK)\\n That\\'s really helpful thanks a lot"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "disagree, it\\'s quite straightforward, compared to the hard tree problems this is very doable. It builds on this Easy problem: https://leetcode.com/problems/convert-sorted-array-to-binary-search-tree/, it\\'s the same recursive build pattern but a bit more tricky due to the fact that you have to use the combination of two traversal arrays. But not that hard. "
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "[@imbobnewbie](/imbobnewbie) I think they tagged this a medium because this is something they teach in college (at least they taught us in our college) how to do, didn\\'t made us write program, but asked us this question in our exam - \\ndraw the tree and/or find the postorder if preorder and inorder is given for a binary tree."
                    },
                    {
                        "username": "davidtn",
                        "content": "For once I disagree. You only need to practice this once. The visualization comes wayyyy easier if you have a pen and paper. \n\nThere are 2 main tricks based on the concept of the most basic traversals.\n1) Know what is given for each, what isn't given. \n2) For those that aren't given, use the other givens to derive the unknowns.\n\nIf you somehow know this is about subproblems, then cutting up the arrays into small chunks each time is doable.\n\nCombining 2 concepts is standard for Medium. I solved this in 22', aiming for 15."
                    },
                    {
                        "username": "imbobnewbie",
                        "content": "[@RafeeqM](/RafeeqM) I'm going through mediums now and agree. This one requires several observations that would be fairly difficult to make during an interview unless you've solved this or numerous similar problems before. Coding portion isn't bad, but the logic is a challenge."
                    },
                    {
                        "username": "Skios",
                        "content": "i agree it\\'s pretty hard to wrap your head around. I wish there were four categories: easy, medium, hard, very hard. this is one of the hardest medium i\\'ve done"
                    },
                    {
                        "username": "davidtn",
                        "content": "Keep trying guys! I struggled with a similar problem a year ago. But today, with a piece of PEN and PAPER also vaguely remembering the \"tricks\", I solved it in 22 minutes. (Solving medium in 15\\' is standard in big tech interviews, according to a friend of mine who had done 300+ problems)\\n\\nTRICKS:\\n- preorder ALWAYS has the node first. But you don\\'t know the size of either branch.\\n- inorder ALWAYS has the left branch to the left of the node, and right branch right of the node. So now you know the size of each branch.\\n\\nTake those information and break the arrays into subproblems, based on the size.\\n"
                    },
                    {
                        "username": "PrimeDispenser",
                        "content": "Great tip, thanks!"
                    },
                    {
                        "username": "rreocode",
                        "content": "good tip many thanks "
                    },
                    {
                        "username": "mystiquecoder",
                        "content": "this question played with my emotions"
                    },
                    {
                        "username": "mochiball",
                        "content": "Good lord this question is hard af "
                    },
                    {
                        "username": "eaglesky",
                        "content": "I'm thinking about one possible follow-up question: what if duplicates are allowed in the binary tree? Can we modify the original recursive solution to get it work?"
                    },
                    {
                        "username": "SanskarGoyal_14",
                        "content": "YES, there is GFG Question for duplicates. The only difference is in finding index of element in inorder array.\\nTo solve that issue,\\n1. We can create a visited vector and pass it by reference.\\n2. Now, when searching for index, also check if visited[i] == 0, only then enter if block, change visited[i] to 1 and return i.\\n3. By doing this, we can easily skip elements that have same value as target-element but have been visited.\\n\\nCheers.. ^_^"
                    },
                    {
                        "username": "Kunal_101",
                        "content": "[@adis176](/adis176) There is a question in gfg considering duplicates.."
                    },
                    {
                        "username": "adis176",
                        "content": "Then it would not be possible to judge how many nodes actually make up the left subtree, or how many to include in the right subtree.\\nDifferent arrangement of trees can have the same inorder and preorder if duplicates are allowed, which would then render this question null."
                    },
                    {
                        "username": "puneets2811",
                        "content": "What if we have only 1 symbol repeated n times for both traversals?"
                    },
                    {
                        "username": "kharemohit786",
                        "content": "For input \\n[-1]\\n[-1]\\nIt is giving error while submitting the code but with custom input it is working fine."
                    },
                    {
                        "username": "Vikasgupta6",
                        "content": "Just reinitialized the value of your \\nstatic preOrder Index to 0, after end of the programme."
                    },
                    {
                        "username": "deadbeat253",
                        "content": "I am curious why in the example there are no nodes added to the initial left subtree (9) and the tree is continuing to be built from the initial right subtree. For example why is [3,9,20,null,null,15,7] correct but [3,9,20,15,7,null,null] is incorrect? They are both valid binary trees. How is one supposed to know which subtrees are null if the initial arrays (preorder and inorder) don\\'t contain null values?"
                    },
                    {
                        "username": "Sahil_Lohan",
                        "content": "thats why, They provided two arrays"
                    },
                    {
                        "username": "hopeNoPip",
                        "content": "So.. why do we need preorder and inorder to the same tree to build a Tree? why are both needed? "
                    },
                    {
                        "username": "anmolp476",
                        "content": "Do you still need help?"
                    },
                    {
                        "username": "MeloWang0308",
                        "content": "Awesome question. Based on my understand, you can build up multiple trees based on the same pre-order or in-order list. However, if we have two of them, we only have one solution. "
                    },
                    {
                        "username": "asong641",
                        "content": "You can't fully determine the shape of a tree with just 1 of them. \nFor example, the preorder example [3,9,20,15,7] can look like the tree given in the question or it can look like one long tree consisting of only left branches and a depth of 5 nodes. There are a couple different possibilities on how the preorder array can look as a binary tree. How do we know which one is correct? You have to use the inorder to verify."
                    },
                    {
                        "username": "roovent",
                        "content": "I simply put `return nil`, but it shows **Compile Error**. Soooo annoying!"
                    }
                ]
            },
            {
                "id": 1688749,
                "content": [
                    {
                        "username": "mohamed_waseela",
                        "content": "if you get this question, they do not want to hire you."
                    },
                    {
                        "username": "taroTown",
                        "content": "LMFAO"
                    },
                    {
                        "username": "user8143P",
                        "content": "hahaha, that's why I like the discussion module in Leetcode"
                    },
                    {
                        "username": "JosephHauter",
                        "content": "LMAOOO "
                    },
                    {
                        "username": "mochiball",
                        "content": "lmfaoooooo you\\'re not wrong "
                    },
                    {
                        "username": "omakovsk",
                        "content": "ahaha"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "If you can\\'t do this, they probably shouldn\\'t :P. JK, just keep practicing, if you do a bunch of tree problems, this one really is quite doable. https://leetcode.com/problems/convert-sorted-array-to-binary-search-tree/ is a good stepping stone to this one. "
                    },
                    {
                        "username": "studshubham",
                        "content": "I think this question should put in Hard category."
                    },
                    {
                        "username": "marks716",
                        "content": "I agree, on the easier spectrum of hard but still above medium. This is not the same as Binary Tree Level Order Traversal which is marked as being the same level."
                    },
                    {
                        "username": "Kashyap2502",
                        "content": "[@Mister_CK](/Mister_CK)\\n That\\'s really helpful thanks a lot"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "disagree, it\\'s quite straightforward, compared to the hard tree problems this is very doable. It builds on this Easy problem: https://leetcode.com/problems/convert-sorted-array-to-binary-search-tree/, it\\'s the same recursive build pattern but a bit more tricky due to the fact that you have to use the combination of two traversal arrays. But not that hard. "
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "[@imbobnewbie](/imbobnewbie) I think they tagged this a medium because this is something they teach in college (at least they taught us in our college) how to do, didn\\'t made us write program, but asked us this question in our exam - \\ndraw the tree and/or find the postorder if preorder and inorder is given for a binary tree."
                    },
                    {
                        "username": "davidtn",
                        "content": "For once I disagree. You only need to practice this once. The visualization comes wayyyy easier if you have a pen and paper. \n\nThere are 2 main tricks based on the concept of the most basic traversals.\n1) Know what is given for each, what isn't given. \n2) For those that aren't given, use the other givens to derive the unknowns.\n\nIf you somehow know this is about subproblems, then cutting up the arrays into small chunks each time is doable.\n\nCombining 2 concepts is standard for Medium. I solved this in 22', aiming for 15."
                    },
                    {
                        "username": "imbobnewbie",
                        "content": "[@RafeeqM](/RafeeqM) I'm going through mediums now and agree. This one requires several observations that would be fairly difficult to make during an interview unless you've solved this or numerous similar problems before. Coding portion isn't bad, but the logic is a challenge."
                    },
                    {
                        "username": "Skios",
                        "content": "i agree it\\'s pretty hard to wrap your head around. I wish there were four categories: easy, medium, hard, very hard. this is one of the hardest medium i\\'ve done"
                    },
                    {
                        "username": "davidtn",
                        "content": "Keep trying guys! I struggled with a similar problem a year ago. But today, with a piece of PEN and PAPER also vaguely remembering the \"tricks\", I solved it in 22 minutes. (Solving medium in 15\\' is standard in big tech interviews, according to a friend of mine who had done 300+ problems)\\n\\nTRICKS:\\n- preorder ALWAYS has the node first. But you don\\'t know the size of either branch.\\n- inorder ALWAYS has the left branch to the left of the node, and right branch right of the node. So now you know the size of each branch.\\n\\nTake those information and break the arrays into subproblems, based on the size.\\n"
                    },
                    {
                        "username": "PrimeDispenser",
                        "content": "Great tip, thanks!"
                    },
                    {
                        "username": "rreocode",
                        "content": "good tip many thanks "
                    },
                    {
                        "username": "mystiquecoder",
                        "content": "this question played with my emotions"
                    },
                    {
                        "username": "mochiball",
                        "content": "Good lord this question is hard af "
                    },
                    {
                        "username": "eaglesky",
                        "content": "I'm thinking about one possible follow-up question: what if duplicates are allowed in the binary tree? Can we modify the original recursive solution to get it work?"
                    },
                    {
                        "username": "SanskarGoyal_14",
                        "content": "YES, there is GFG Question for duplicates. The only difference is in finding index of element in inorder array.\\nTo solve that issue,\\n1. We can create a visited vector and pass it by reference.\\n2. Now, when searching for index, also check if visited[i] == 0, only then enter if block, change visited[i] to 1 and return i.\\n3. By doing this, we can easily skip elements that have same value as target-element but have been visited.\\n\\nCheers.. ^_^"
                    },
                    {
                        "username": "Kunal_101",
                        "content": "[@adis176](/adis176) There is a question in gfg considering duplicates.."
                    },
                    {
                        "username": "adis176",
                        "content": "Then it would not be possible to judge how many nodes actually make up the left subtree, or how many to include in the right subtree.\\nDifferent arrangement of trees can have the same inorder and preorder if duplicates are allowed, which would then render this question null."
                    },
                    {
                        "username": "puneets2811",
                        "content": "What if we have only 1 symbol repeated n times for both traversals?"
                    },
                    {
                        "username": "kharemohit786",
                        "content": "For input \\n[-1]\\n[-1]\\nIt is giving error while submitting the code but with custom input it is working fine."
                    },
                    {
                        "username": "Vikasgupta6",
                        "content": "Just reinitialized the value of your \\nstatic preOrder Index to 0, after end of the programme."
                    },
                    {
                        "username": "deadbeat253",
                        "content": "I am curious why in the example there are no nodes added to the initial left subtree (9) and the tree is continuing to be built from the initial right subtree. For example why is [3,9,20,null,null,15,7] correct but [3,9,20,15,7,null,null] is incorrect? They are both valid binary trees. How is one supposed to know which subtrees are null if the initial arrays (preorder and inorder) don\\'t contain null values?"
                    },
                    {
                        "username": "Sahil_Lohan",
                        "content": "thats why, They provided two arrays"
                    },
                    {
                        "username": "hopeNoPip",
                        "content": "So.. why do we need preorder and inorder to the same tree to build a Tree? why are both needed? "
                    },
                    {
                        "username": "anmolp476",
                        "content": "Do you still need help?"
                    },
                    {
                        "username": "MeloWang0308",
                        "content": "Awesome question. Based on my understand, you can build up multiple trees based on the same pre-order or in-order list. However, if we have two of them, we only have one solution. "
                    },
                    {
                        "username": "asong641",
                        "content": "You can't fully determine the shape of a tree with just 1 of them. \nFor example, the preorder example [3,9,20,15,7] can look like the tree given in the question or it can look like one long tree consisting of only left branches and a depth of 5 nodes. There are a couple different possibilities on how the preorder array can look as a binary tree. How do we know which one is correct? You have to use the inorder to verify."
                    },
                    {
                        "username": "roovent",
                        "content": "I simply put `return nil`, but it shows **Compile Error**. Soooo annoying!"
                    }
                ]
            },
            {
                "id": 1715862,
                "content": [
                    {
                        "username": "mohamed_waseela",
                        "content": "if you get this question, they do not want to hire you."
                    },
                    {
                        "username": "taroTown",
                        "content": "LMFAO"
                    },
                    {
                        "username": "user8143P",
                        "content": "hahaha, that's why I like the discussion module in Leetcode"
                    },
                    {
                        "username": "JosephHauter",
                        "content": "LMAOOO "
                    },
                    {
                        "username": "mochiball",
                        "content": "lmfaoooooo you\\'re not wrong "
                    },
                    {
                        "username": "omakovsk",
                        "content": "ahaha"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "If you can\\'t do this, they probably shouldn\\'t :P. JK, just keep practicing, if you do a bunch of tree problems, this one really is quite doable. https://leetcode.com/problems/convert-sorted-array-to-binary-search-tree/ is a good stepping stone to this one. "
                    },
                    {
                        "username": "studshubham",
                        "content": "I think this question should put in Hard category."
                    },
                    {
                        "username": "marks716",
                        "content": "I agree, on the easier spectrum of hard but still above medium. This is not the same as Binary Tree Level Order Traversal which is marked as being the same level."
                    },
                    {
                        "username": "Kashyap2502",
                        "content": "[@Mister_CK](/Mister_CK)\\n That\\'s really helpful thanks a lot"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "disagree, it\\'s quite straightforward, compared to the hard tree problems this is very doable. It builds on this Easy problem: https://leetcode.com/problems/convert-sorted-array-to-binary-search-tree/, it\\'s the same recursive build pattern but a bit more tricky due to the fact that you have to use the combination of two traversal arrays. But not that hard. "
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "[@imbobnewbie](/imbobnewbie) I think they tagged this a medium because this is something they teach in college (at least they taught us in our college) how to do, didn\\'t made us write program, but asked us this question in our exam - \\ndraw the tree and/or find the postorder if preorder and inorder is given for a binary tree."
                    },
                    {
                        "username": "davidtn",
                        "content": "For once I disagree. You only need to practice this once. The visualization comes wayyyy easier if you have a pen and paper. \n\nThere are 2 main tricks based on the concept of the most basic traversals.\n1) Know what is given for each, what isn't given. \n2) For those that aren't given, use the other givens to derive the unknowns.\n\nIf you somehow know this is about subproblems, then cutting up the arrays into small chunks each time is doable.\n\nCombining 2 concepts is standard for Medium. I solved this in 22', aiming for 15."
                    },
                    {
                        "username": "imbobnewbie",
                        "content": "[@RafeeqM](/RafeeqM) I'm going through mediums now and agree. This one requires several observations that would be fairly difficult to make during an interview unless you've solved this or numerous similar problems before. Coding portion isn't bad, but the logic is a challenge."
                    },
                    {
                        "username": "Skios",
                        "content": "i agree it\\'s pretty hard to wrap your head around. I wish there were four categories: easy, medium, hard, very hard. this is one of the hardest medium i\\'ve done"
                    },
                    {
                        "username": "davidtn",
                        "content": "Keep trying guys! I struggled with a similar problem a year ago. But today, with a piece of PEN and PAPER also vaguely remembering the \"tricks\", I solved it in 22 minutes. (Solving medium in 15\\' is standard in big tech interviews, according to a friend of mine who had done 300+ problems)\\n\\nTRICKS:\\n- preorder ALWAYS has the node first. But you don\\'t know the size of either branch.\\n- inorder ALWAYS has the left branch to the left of the node, and right branch right of the node. So now you know the size of each branch.\\n\\nTake those information and break the arrays into subproblems, based on the size.\\n"
                    },
                    {
                        "username": "PrimeDispenser",
                        "content": "Great tip, thanks!"
                    },
                    {
                        "username": "rreocode",
                        "content": "good tip many thanks "
                    },
                    {
                        "username": "mystiquecoder",
                        "content": "this question played with my emotions"
                    },
                    {
                        "username": "mochiball",
                        "content": "Good lord this question is hard af "
                    },
                    {
                        "username": "eaglesky",
                        "content": "I'm thinking about one possible follow-up question: what if duplicates are allowed in the binary tree? Can we modify the original recursive solution to get it work?"
                    },
                    {
                        "username": "SanskarGoyal_14",
                        "content": "YES, there is GFG Question for duplicates. The only difference is in finding index of element in inorder array.\\nTo solve that issue,\\n1. We can create a visited vector and pass it by reference.\\n2. Now, when searching for index, also check if visited[i] == 0, only then enter if block, change visited[i] to 1 and return i.\\n3. By doing this, we can easily skip elements that have same value as target-element but have been visited.\\n\\nCheers.. ^_^"
                    },
                    {
                        "username": "Kunal_101",
                        "content": "[@adis176](/adis176) There is a question in gfg considering duplicates.."
                    },
                    {
                        "username": "adis176",
                        "content": "Then it would not be possible to judge how many nodes actually make up the left subtree, or how many to include in the right subtree.\\nDifferent arrangement of trees can have the same inorder and preorder if duplicates are allowed, which would then render this question null."
                    },
                    {
                        "username": "puneets2811",
                        "content": "What if we have only 1 symbol repeated n times for both traversals?"
                    },
                    {
                        "username": "kharemohit786",
                        "content": "For input \\n[-1]\\n[-1]\\nIt is giving error while submitting the code but with custom input it is working fine."
                    },
                    {
                        "username": "Vikasgupta6",
                        "content": "Just reinitialized the value of your \\nstatic preOrder Index to 0, after end of the programme."
                    },
                    {
                        "username": "deadbeat253",
                        "content": "I am curious why in the example there are no nodes added to the initial left subtree (9) and the tree is continuing to be built from the initial right subtree. For example why is [3,9,20,null,null,15,7] correct but [3,9,20,15,7,null,null] is incorrect? They are both valid binary trees. How is one supposed to know which subtrees are null if the initial arrays (preorder and inorder) don\\'t contain null values?"
                    },
                    {
                        "username": "Sahil_Lohan",
                        "content": "thats why, They provided two arrays"
                    },
                    {
                        "username": "hopeNoPip",
                        "content": "So.. why do we need preorder and inorder to the same tree to build a Tree? why are both needed? "
                    },
                    {
                        "username": "anmolp476",
                        "content": "Do you still need help?"
                    },
                    {
                        "username": "MeloWang0308",
                        "content": "Awesome question. Based on my understand, you can build up multiple trees based on the same pre-order or in-order list. However, if we have two of them, we only have one solution. "
                    },
                    {
                        "username": "asong641",
                        "content": "You can't fully determine the shape of a tree with just 1 of them. \nFor example, the preorder example [3,9,20,15,7] can look like the tree given in the question or it can look like one long tree consisting of only left branches and a depth of 5 nodes. There are a couple different possibilities on how the preorder array can look as a binary tree. How do we know which one is correct? You have to use the inorder to verify."
                    },
                    {
                        "username": "roovent",
                        "content": "I simply put `return nil`, but it shows **Compile Error**. Soooo annoying!"
                    }
                ]
            },
            {
                "id": 1905602,
                "content": [
                    {
                        "username": "mohamed_waseela",
                        "content": "if you get this question, they do not want to hire you."
                    },
                    {
                        "username": "taroTown",
                        "content": "LMFAO"
                    },
                    {
                        "username": "user8143P",
                        "content": "hahaha, that's why I like the discussion module in Leetcode"
                    },
                    {
                        "username": "JosephHauter",
                        "content": "LMAOOO "
                    },
                    {
                        "username": "mochiball",
                        "content": "lmfaoooooo you\\'re not wrong "
                    },
                    {
                        "username": "omakovsk",
                        "content": "ahaha"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "If you can\\'t do this, they probably shouldn\\'t :P. JK, just keep practicing, if you do a bunch of tree problems, this one really is quite doable. https://leetcode.com/problems/convert-sorted-array-to-binary-search-tree/ is a good stepping stone to this one. "
                    },
                    {
                        "username": "studshubham",
                        "content": "I think this question should put in Hard category."
                    },
                    {
                        "username": "marks716",
                        "content": "I agree, on the easier spectrum of hard but still above medium. This is not the same as Binary Tree Level Order Traversal which is marked as being the same level."
                    },
                    {
                        "username": "Kashyap2502",
                        "content": "[@Mister_CK](/Mister_CK)\\n That\\'s really helpful thanks a lot"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "disagree, it\\'s quite straightforward, compared to the hard tree problems this is very doable. It builds on this Easy problem: https://leetcode.com/problems/convert-sorted-array-to-binary-search-tree/, it\\'s the same recursive build pattern but a bit more tricky due to the fact that you have to use the combination of two traversal arrays. But not that hard. "
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "[@imbobnewbie](/imbobnewbie) I think they tagged this a medium because this is something they teach in college (at least they taught us in our college) how to do, didn\\'t made us write program, but asked us this question in our exam - \\ndraw the tree and/or find the postorder if preorder and inorder is given for a binary tree."
                    },
                    {
                        "username": "davidtn",
                        "content": "For once I disagree. You only need to practice this once. The visualization comes wayyyy easier if you have a pen and paper. \n\nThere are 2 main tricks based on the concept of the most basic traversals.\n1) Know what is given for each, what isn't given. \n2) For those that aren't given, use the other givens to derive the unknowns.\n\nIf you somehow know this is about subproblems, then cutting up the arrays into small chunks each time is doable.\n\nCombining 2 concepts is standard for Medium. I solved this in 22', aiming for 15."
                    },
                    {
                        "username": "imbobnewbie",
                        "content": "[@RafeeqM](/RafeeqM) I'm going through mediums now and agree. This one requires several observations that would be fairly difficult to make during an interview unless you've solved this or numerous similar problems before. Coding portion isn't bad, but the logic is a challenge."
                    },
                    {
                        "username": "Skios",
                        "content": "i agree it\\'s pretty hard to wrap your head around. I wish there were four categories: easy, medium, hard, very hard. this is one of the hardest medium i\\'ve done"
                    },
                    {
                        "username": "davidtn",
                        "content": "Keep trying guys! I struggled with a similar problem a year ago. But today, with a piece of PEN and PAPER also vaguely remembering the \"tricks\", I solved it in 22 minutes. (Solving medium in 15\\' is standard in big tech interviews, according to a friend of mine who had done 300+ problems)\\n\\nTRICKS:\\n- preorder ALWAYS has the node first. But you don\\'t know the size of either branch.\\n- inorder ALWAYS has the left branch to the left of the node, and right branch right of the node. So now you know the size of each branch.\\n\\nTake those information and break the arrays into subproblems, based on the size.\\n"
                    },
                    {
                        "username": "PrimeDispenser",
                        "content": "Great tip, thanks!"
                    },
                    {
                        "username": "rreocode",
                        "content": "good tip many thanks "
                    },
                    {
                        "username": "mystiquecoder",
                        "content": "this question played with my emotions"
                    },
                    {
                        "username": "mochiball",
                        "content": "Good lord this question is hard af "
                    },
                    {
                        "username": "eaglesky",
                        "content": "I'm thinking about one possible follow-up question: what if duplicates are allowed in the binary tree? Can we modify the original recursive solution to get it work?"
                    },
                    {
                        "username": "SanskarGoyal_14",
                        "content": "YES, there is GFG Question for duplicates. The only difference is in finding index of element in inorder array.\\nTo solve that issue,\\n1. We can create a visited vector and pass it by reference.\\n2. Now, when searching for index, also check if visited[i] == 0, only then enter if block, change visited[i] to 1 and return i.\\n3. By doing this, we can easily skip elements that have same value as target-element but have been visited.\\n\\nCheers.. ^_^"
                    },
                    {
                        "username": "Kunal_101",
                        "content": "[@adis176](/adis176) There is a question in gfg considering duplicates.."
                    },
                    {
                        "username": "adis176",
                        "content": "Then it would not be possible to judge how many nodes actually make up the left subtree, or how many to include in the right subtree.\\nDifferent arrangement of trees can have the same inorder and preorder if duplicates are allowed, which would then render this question null."
                    },
                    {
                        "username": "puneets2811",
                        "content": "What if we have only 1 symbol repeated n times for both traversals?"
                    },
                    {
                        "username": "kharemohit786",
                        "content": "For input \\n[-1]\\n[-1]\\nIt is giving error while submitting the code but with custom input it is working fine."
                    },
                    {
                        "username": "Vikasgupta6",
                        "content": "Just reinitialized the value of your \\nstatic preOrder Index to 0, after end of the programme."
                    },
                    {
                        "username": "deadbeat253",
                        "content": "I am curious why in the example there are no nodes added to the initial left subtree (9) and the tree is continuing to be built from the initial right subtree. For example why is [3,9,20,null,null,15,7] correct but [3,9,20,15,7,null,null] is incorrect? They are both valid binary trees. How is one supposed to know which subtrees are null if the initial arrays (preorder and inorder) don\\'t contain null values?"
                    },
                    {
                        "username": "Sahil_Lohan",
                        "content": "thats why, They provided two arrays"
                    },
                    {
                        "username": "hopeNoPip",
                        "content": "So.. why do we need preorder and inorder to the same tree to build a Tree? why are both needed? "
                    },
                    {
                        "username": "anmolp476",
                        "content": "Do you still need help?"
                    },
                    {
                        "username": "MeloWang0308",
                        "content": "Awesome question. Based on my understand, you can build up multiple trees based on the same pre-order or in-order list. However, if we have two of them, we only have one solution. "
                    },
                    {
                        "username": "asong641",
                        "content": "You can't fully determine the shape of a tree with just 1 of them. \nFor example, the preorder example [3,9,20,15,7] can look like the tree given in the question or it can look like one long tree consisting of only left branches and a depth of 5 nodes. There are a couple different possibilities on how the preorder array can look as a binary tree. How do we know which one is correct? You have to use the inorder to verify."
                    },
                    {
                        "username": "roovent",
                        "content": "I simply put `return nil`, but it shows **Compile Error**. Soooo annoying!"
                    }
                ]
            },
            {
                "id": 1935086,
                "content": [
                    {
                        "username": "mohamed_waseela",
                        "content": "if you get this question, they do not want to hire you."
                    },
                    {
                        "username": "taroTown",
                        "content": "LMFAO"
                    },
                    {
                        "username": "user8143P",
                        "content": "hahaha, that's why I like the discussion module in Leetcode"
                    },
                    {
                        "username": "JosephHauter",
                        "content": "LMAOOO "
                    },
                    {
                        "username": "mochiball",
                        "content": "lmfaoooooo you\\'re not wrong "
                    },
                    {
                        "username": "omakovsk",
                        "content": "ahaha"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "If you can\\'t do this, they probably shouldn\\'t :P. JK, just keep practicing, if you do a bunch of tree problems, this one really is quite doable. https://leetcode.com/problems/convert-sorted-array-to-binary-search-tree/ is a good stepping stone to this one. "
                    },
                    {
                        "username": "studshubham",
                        "content": "I think this question should put in Hard category."
                    },
                    {
                        "username": "marks716",
                        "content": "I agree, on the easier spectrum of hard but still above medium. This is not the same as Binary Tree Level Order Traversal which is marked as being the same level."
                    },
                    {
                        "username": "Kashyap2502",
                        "content": "[@Mister_CK](/Mister_CK)\\n That\\'s really helpful thanks a lot"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "disagree, it\\'s quite straightforward, compared to the hard tree problems this is very doable. It builds on this Easy problem: https://leetcode.com/problems/convert-sorted-array-to-binary-search-tree/, it\\'s the same recursive build pattern but a bit more tricky due to the fact that you have to use the combination of two traversal arrays. But not that hard. "
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "[@imbobnewbie](/imbobnewbie) I think they tagged this a medium because this is something they teach in college (at least they taught us in our college) how to do, didn\\'t made us write program, but asked us this question in our exam - \\ndraw the tree and/or find the postorder if preorder and inorder is given for a binary tree."
                    },
                    {
                        "username": "davidtn",
                        "content": "For once I disagree. You only need to practice this once. The visualization comes wayyyy easier if you have a pen and paper. \n\nThere are 2 main tricks based on the concept of the most basic traversals.\n1) Know what is given for each, what isn't given. \n2) For those that aren't given, use the other givens to derive the unknowns.\n\nIf you somehow know this is about subproblems, then cutting up the arrays into small chunks each time is doable.\n\nCombining 2 concepts is standard for Medium. I solved this in 22', aiming for 15."
                    },
                    {
                        "username": "imbobnewbie",
                        "content": "[@RafeeqM](/RafeeqM) I'm going through mediums now and agree. This one requires several observations that would be fairly difficult to make during an interview unless you've solved this or numerous similar problems before. Coding portion isn't bad, but the logic is a challenge."
                    },
                    {
                        "username": "Skios",
                        "content": "i agree it\\'s pretty hard to wrap your head around. I wish there were four categories: easy, medium, hard, very hard. this is one of the hardest medium i\\'ve done"
                    },
                    {
                        "username": "davidtn",
                        "content": "Keep trying guys! I struggled with a similar problem a year ago. But today, with a piece of PEN and PAPER also vaguely remembering the \"tricks\", I solved it in 22 minutes. (Solving medium in 15\\' is standard in big tech interviews, according to a friend of mine who had done 300+ problems)\\n\\nTRICKS:\\n- preorder ALWAYS has the node first. But you don\\'t know the size of either branch.\\n- inorder ALWAYS has the left branch to the left of the node, and right branch right of the node. So now you know the size of each branch.\\n\\nTake those information and break the arrays into subproblems, based on the size.\\n"
                    },
                    {
                        "username": "PrimeDispenser",
                        "content": "Great tip, thanks!"
                    },
                    {
                        "username": "rreocode",
                        "content": "good tip many thanks "
                    },
                    {
                        "username": "mystiquecoder",
                        "content": "this question played with my emotions"
                    },
                    {
                        "username": "mochiball",
                        "content": "Good lord this question is hard af "
                    },
                    {
                        "username": "eaglesky",
                        "content": "I'm thinking about one possible follow-up question: what if duplicates are allowed in the binary tree? Can we modify the original recursive solution to get it work?"
                    },
                    {
                        "username": "SanskarGoyal_14",
                        "content": "YES, there is GFG Question for duplicates. The only difference is in finding index of element in inorder array.\\nTo solve that issue,\\n1. We can create a visited vector and pass it by reference.\\n2. Now, when searching for index, also check if visited[i] == 0, only then enter if block, change visited[i] to 1 and return i.\\n3. By doing this, we can easily skip elements that have same value as target-element but have been visited.\\n\\nCheers.. ^_^"
                    },
                    {
                        "username": "Kunal_101",
                        "content": "[@adis176](/adis176) There is a question in gfg considering duplicates.."
                    },
                    {
                        "username": "adis176",
                        "content": "Then it would not be possible to judge how many nodes actually make up the left subtree, or how many to include in the right subtree.\\nDifferent arrangement of trees can have the same inorder and preorder if duplicates are allowed, which would then render this question null."
                    },
                    {
                        "username": "puneets2811",
                        "content": "What if we have only 1 symbol repeated n times for both traversals?"
                    },
                    {
                        "username": "kharemohit786",
                        "content": "For input \\n[-1]\\n[-1]\\nIt is giving error while submitting the code but with custom input it is working fine."
                    },
                    {
                        "username": "Vikasgupta6",
                        "content": "Just reinitialized the value of your \\nstatic preOrder Index to 0, after end of the programme."
                    },
                    {
                        "username": "deadbeat253",
                        "content": "I am curious why in the example there are no nodes added to the initial left subtree (9) and the tree is continuing to be built from the initial right subtree. For example why is [3,9,20,null,null,15,7] correct but [3,9,20,15,7,null,null] is incorrect? They are both valid binary trees. How is one supposed to know which subtrees are null if the initial arrays (preorder and inorder) don\\'t contain null values?"
                    },
                    {
                        "username": "Sahil_Lohan",
                        "content": "thats why, They provided two arrays"
                    },
                    {
                        "username": "hopeNoPip",
                        "content": "So.. why do we need preorder and inorder to the same tree to build a Tree? why are both needed? "
                    },
                    {
                        "username": "anmolp476",
                        "content": "Do you still need help?"
                    },
                    {
                        "username": "MeloWang0308",
                        "content": "Awesome question. Based on my understand, you can build up multiple trees based on the same pre-order or in-order list. However, if we have two of them, we only have one solution. "
                    },
                    {
                        "username": "asong641",
                        "content": "You can't fully determine the shape of a tree with just 1 of them. \nFor example, the preorder example [3,9,20,15,7] can look like the tree given in the question or it can look like one long tree consisting of only left branches and a depth of 5 nodes. There are a couple different possibilities on how the preorder array can look as a binary tree. How do we know which one is correct? You have to use the inorder to verify."
                    },
                    {
                        "username": "roovent",
                        "content": "I simply put `return nil`, but it shows **Compile Error**. Soooo annoying!"
                    }
                ]
            },
            {
                "id": 1568928,
                "content": [
                    {
                        "username": "mohamed_waseela",
                        "content": "if you get this question, they do not want to hire you."
                    },
                    {
                        "username": "taroTown",
                        "content": "LMFAO"
                    },
                    {
                        "username": "user8143P",
                        "content": "hahaha, that's why I like the discussion module in Leetcode"
                    },
                    {
                        "username": "JosephHauter",
                        "content": "LMAOOO "
                    },
                    {
                        "username": "mochiball",
                        "content": "lmfaoooooo you\\'re not wrong "
                    },
                    {
                        "username": "omakovsk",
                        "content": "ahaha"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "If you can\\'t do this, they probably shouldn\\'t :P. JK, just keep practicing, if you do a bunch of tree problems, this one really is quite doable. https://leetcode.com/problems/convert-sorted-array-to-binary-search-tree/ is a good stepping stone to this one. "
                    },
                    {
                        "username": "studshubham",
                        "content": "I think this question should put in Hard category."
                    },
                    {
                        "username": "marks716",
                        "content": "I agree, on the easier spectrum of hard but still above medium. This is not the same as Binary Tree Level Order Traversal which is marked as being the same level."
                    },
                    {
                        "username": "Kashyap2502",
                        "content": "[@Mister_CK](/Mister_CK)\\n That\\'s really helpful thanks a lot"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "disagree, it\\'s quite straightforward, compared to the hard tree problems this is very doable. It builds on this Easy problem: https://leetcode.com/problems/convert-sorted-array-to-binary-search-tree/, it\\'s the same recursive build pattern but a bit more tricky due to the fact that you have to use the combination of two traversal arrays. But not that hard. "
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "[@imbobnewbie](/imbobnewbie) I think they tagged this a medium because this is something they teach in college (at least they taught us in our college) how to do, didn\\'t made us write program, but asked us this question in our exam - \\ndraw the tree and/or find the postorder if preorder and inorder is given for a binary tree."
                    },
                    {
                        "username": "davidtn",
                        "content": "For once I disagree. You only need to practice this once. The visualization comes wayyyy easier if you have a pen and paper. \n\nThere are 2 main tricks based on the concept of the most basic traversals.\n1) Know what is given for each, what isn't given. \n2) For those that aren't given, use the other givens to derive the unknowns.\n\nIf you somehow know this is about subproblems, then cutting up the arrays into small chunks each time is doable.\n\nCombining 2 concepts is standard for Medium. I solved this in 22', aiming for 15."
                    },
                    {
                        "username": "imbobnewbie",
                        "content": "[@RafeeqM](/RafeeqM) I'm going through mediums now and agree. This one requires several observations that would be fairly difficult to make during an interview unless you've solved this or numerous similar problems before. Coding portion isn't bad, but the logic is a challenge."
                    },
                    {
                        "username": "Skios",
                        "content": "i agree it\\'s pretty hard to wrap your head around. I wish there were four categories: easy, medium, hard, very hard. this is one of the hardest medium i\\'ve done"
                    },
                    {
                        "username": "davidtn",
                        "content": "Keep trying guys! I struggled with a similar problem a year ago. But today, with a piece of PEN and PAPER also vaguely remembering the \"tricks\", I solved it in 22 minutes. (Solving medium in 15\\' is standard in big tech interviews, according to a friend of mine who had done 300+ problems)\\n\\nTRICKS:\\n- preorder ALWAYS has the node first. But you don\\'t know the size of either branch.\\n- inorder ALWAYS has the left branch to the left of the node, and right branch right of the node. So now you know the size of each branch.\\n\\nTake those information and break the arrays into subproblems, based on the size.\\n"
                    },
                    {
                        "username": "PrimeDispenser",
                        "content": "Great tip, thanks!"
                    },
                    {
                        "username": "rreocode",
                        "content": "good tip many thanks "
                    },
                    {
                        "username": "mystiquecoder",
                        "content": "this question played with my emotions"
                    },
                    {
                        "username": "mochiball",
                        "content": "Good lord this question is hard af "
                    },
                    {
                        "username": "eaglesky",
                        "content": "I'm thinking about one possible follow-up question: what if duplicates are allowed in the binary tree? Can we modify the original recursive solution to get it work?"
                    },
                    {
                        "username": "SanskarGoyal_14",
                        "content": "YES, there is GFG Question for duplicates. The only difference is in finding index of element in inorder array.\\nTo solve that issue,\\n1. We can create a visited vector and pass it by reference.\\n2. Now, when searching for index, also check if visited[i] == 0, only then enter if block, change visited[i] to 1 and return i.\\n3. By doing this, we can easily skip elements that have same value as target-element but have been visited.\\n\\nCheers.. ^_^"
                    },
                    {
                        "username": "Kunal_101",
                        "content": "[@adis176](/adis176) There is a question in gfg considering duplicates.."
                    },
                    {
                        "username": "adis176",
                        "content": "Then it would not be possible to judge how many nodes actually make up the left subtree, or how many to include in the right subtree.\\nDifferent arrangement of trees can have the same inorder and preorder if duplicates are allowed, which would then render this question null."
                    },
                    {
                        "username": "puneets2811",
                        "content": "What if we have only 1 symbol repeated n times for both traversals?"
                    },
                    {
                        "username": "kharemohit786",
                        "content": "For input \\n[-1]\\n[-1]\\nIt is giving error while submitting the code but with custom input it is working fine."
                    },
                    {
                        "username": "Vikasgupta6",
                        "content": "Just reinitialized the value of your \\nstatic preOrder Index to 0, after end of the programme."
                    },
                    {
                        "username": "deadbeat253",
                        "content": "I am curious why in the example there are no nodes added to the initial left subtree (9) and the tree is continuing to be built from the initial right subtree. For example why is [3,9,20,null,null,15,7] correct but [3,9,20,15,7,null,null] is incorrect? They are both valid binary trees. How is one supposed to know which subtrees are null if the initial arrays (preorder and inorder) don\\'t contain null values?"
                    },
                    {
                        "username": "Sahil_Lohan",
                        "content": "thats why, They provided two arrays"
                    },
                    {
                        "username": "hopeNoPip",
                        "content": "So.. why do we need preorder and inorder to the same tree to build a Tree? why are both needed? "
                    },
                    {
                        "username": "anmolp476",
                        "content": "Do you still need help?"
                    },
                    {
                        "username": "MeloWang0308",
                        "content": "Awesome question. Based on my understand, you can build up multiple trees based on the same pre-order or in-order list. However, if we have two of them, we only have one solution. "
                    },
                    {
                        "username": "asong641",
                        "content": "You can't fully determine the shape of a tree with just 1 of them. \nFor example, the preorder example [3,9,20,15,7] can look like the tree given in the question or it can look like one long tree consisting of only left branches and a depth of 5 nodes. There are a couple different possibilities on how the preorder array can look as a binary tree. How do we know which one is correct? You have to use the inorder to verify."
                    },
                    {
                        "username": "roovent",
                        "content": "I simply put `return nil`, but it shows **Compile Error**. Soooo annoying!"
                    }
                ]
            },
            {
                "id": 1572690,
                "content": [
                    {
                        "username": "mohamed_waseela",
                        "content": "if you get this question, they do not want to hire you."
                    },
                    {
                        "username": "taroTown",
                        "content": "LMFAO"
                    },
                    {
                        "username": "user8143P",
                        "content": "hahaha, that's why I like the discussion module in Leetcode"
                    },
                    {
                        "username": "JosephHauter",
                        "content": "LMAOOO "
                    },
                    {
                        "username": "mochiball",
                        "content": "lmfaoooooo you\\'re not wrong "
                    },
                    {
                        "username": "omakovsk",
                        "content": "ahaha"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "If you can\\'t do this, they probably shouldn\\'t :P. JK, just keep practicing, if you do a bunch of tree problems, this one really is quite doable. https://leetcode.com/problems/convert-sorted-array-to-binary-search-tree/ is a good stepping stone to this one. "
                    },
                    {
                        "username": "studshubham",
                        "content": "I think this question should put in Hard category."
                    },
                    {
                        "username": "marks716",
                        "content": "I agree, on the easier spectrum of hard but still above medium. This is not the same as Binary Tree Level Order Traversal which is marked as being the same level."
                    },
                    {
                        "username": "Kashyap2502",
                        "content": "[@Mister_CK](/Mister_CK)\\n That\\'s really helpful thanks a lot"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "disagree, it\\'s quite straightforward, compared to the hard tree problems this is very doable. It builds on this Easy problem: https://leetcode.com/problems/convert-sorted-array-to-binary-search-tree/, it\\'s the same recursive build pattern but a bit more tricky due to the fact that you have to use the combination of two traversal arrays. But not that hard. "
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "[@imbobnewbie](/imbobnewbie) I think they tagged this a medium because this is something they teach in college (at least they taught us in our college) how to do, didn\\'t made us write program, but asked us this question in our exam - \\ndraw the tree and/or find the postorder if preorder and inorder is given for a binary tree."
                    },
                    {
                        "username": "davidtn",
                        "content": "For once I disagree. You only need to practice this once. The visualization comes wayyyy easier if you have a pen and paper. \n\nThere are 2 main tricks based on the concept of the most basic traversals.\n1) Know what is given for each, what isn't given. \n2) For those that aren't given, use the other givens to derive the unknowns.\n\nIf you somehow know this is about subproblems, then cutting up the arrays into small chunks each time is doable.\n\nCombining 2 concepts is standard for Medium. I solved this in 22', aiming for 15."
                    },
                    {
                        "username": "imbobnewbie",
                        "content": "[@RafeeqM](/RafeeqM) I'm going through mediums now and agree. This one requires several observations that would be fairly difficult to make during an interview unless you've solved this or numerous similar problems before. Coding portion isn't bad, but the logic is a challenge."
                    },
                    {
                        "username": "Skios",
                        "content": "i agree it\\'s pretty hard to wrap your head around. I wish there were four categories: easy, medium, hard, very hard. this is one of the hardest medium i\\'ve done"
                    },
                    {
                        "username": "davidtn",
                        "content": "Keep trying guys! I struggled with a similar problem a year ago. But today, with a piece of PEN and PAPER also vaguely remembering the \"tricks\", I solved it in 22 minutes. (Solving medium in 15\\' is standard in big tech interviews, according to a friend of mine who had done 300+ problems)\\n\\nTRICKS:\\n- preorder ALWAYS has the node first. But you don\\'t know the size of either branch.\\n- inorder ALWAYS has the left branch to the left of the node, and right branch right of the node. So now you know the size of each branch.\\n\\nTake those information and break the arrays into subproblems, based on the size.\\n"
                    },
                    {
                        "username": "PrimeDispenser",
                        "content": "Great tip, thanks!"
                    },
                    {
                        "username": "rreocode",
                        "content": "good tip many thanks "
                    },
                    {
                        "username": "mystiquecoder",
                        "content": "this question played with my emotions"
                    },
                    {
                        "username": "mochiball",
                        "content": "Good lord this question is hard af "
                    },
                    {
                        "username": "eaglesky",
                        "content": "I'm thinking about one possible follow-up question: what if duplicates are allowed in the binary tree? Can we modify the original recursive solution to get it work?"
                    },
                    {
                        "username": "SanskarGoyal_14",
                        "content": "YES, there is GFG Question for duplicates. The only difference is in finding index of element in inorder array.\\nTo solve that issue,\\n1. We can create a visited vector and pass it by reference.\\n2. Now, when searching for index, also check if visited[i] == 0, only then enter if block, change visited[i] to 1 and return i.\\n3. By doing this, we can easily skip elements that have same value as target-element but have been visited.\\n\\nCheers.. ^_^"
                    },
                    {
                        "username": "Kunal_101",
                        "content": "[@adis176](/adis176) There is a question in gfg considering duplicates.."
                    },
                    {
                        "username": "adis176",
                        "content": "Then it would not be possible to judge how many nodes actually make up the left subtree, or how many to include in the right subtree.\\nDifferent arrangement of trees can have the same inorder and preorder if duplicates are allowed, which would then render this question null."
                    },
                    {
                        "username": "puneets2811",
                        "content": "What if we have only 1 symbol repeated n times for both traversals?"
                    },
                    {
                        "username": "kharemohit786",
                        "content": "For input \\n[-1]\\n[-1]\\nIt is giving error while submitting the code but with custom input it is working fine."
                    },
                    {
                        "username": "Vikasgupta6",
                        "content": "Just reinitialized the value of your \\nstatic preOrder Index to 0, after end of the programme."
                    },
                    {
                        "username": "deadbeat253",
                        "content": "I am curious why in the example there are no nodes added to the initial left subtree (9) and the tree is continuing to be built from the initial right subtree. For example why is [3,9,20,null,null,15,7] correct but [3,9,20,15,7,null,null] is incorrect? They are both valid binary trees. How is one supposed to know which subtrees are null if the initial arrays (preorder and inorder) don\\'t contain null values?"
                    },
                    {
                        "username": "Sahil_Lohan",
                        "content": "thats why, They provided two arrays"
                    },
                    {
                        "username": "hopeNoPip",
                        "content": "So.. why do we need preorder and inorder to the same tree to build a Tree? why are both needed? "
                    },
                    {
                        "username": "anmolp476",
                        "content": "Do you still need help?"
                    },
                    {
                        "username": "MeloWang0308",
                        "content": "Awesome question. Based on my understand, you can build up multiple trees based on the same pre-order or in-order list. However, if we have two of them, we only have one solution. "
                    },
                    {
                        "username": "asong641",
                        "content": "You can't fully determine the shape of a tree with just 1 of them. \nFor example, the preorder example [3,9,20,15,7] can look like the tree given in the question or it can look like one long tree consisting of only left branches and a depth of 5 nodes. There are a couple different possibilities on how the preorder array can look as a binary tree. How do we know which one is correct? You have to use the inorder to verify."
                    },
                    {
                        "username": "roovent",
                        "content": "I simply put `return nil`, but it shows **Compile Error**. Soooo annoying!"
                    }
                ]
            },
            {
                "id": 1573070,
                "content": [
                    {
                        "username": "mohamed_waseela",
                        "content": "if you get this question, they do not want to hire you."
                    },
                    {
                        "username": "taroTown",
                        "content": "LMFAO"
                    },
                    {
                        "username": "user8143P",
                        "content": "hahaha, that's why I like the discussion module in Leetcode"
                    },
                    {
                        "username": "JosephHauter",
                        "content": "LMAOOO "
                    },
                    {
                        "username": "mochiball",
                        "content": "lmfaoooooo you\\'re not wrong "
                    },
                    {
                        "username": "omakovsk",
                        "content": "ahaha"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "If you can\\'t do this, they probably shouldn\\'t :P. JK, just keep practicing, if you do a bunch of tree problems, this one really is quite doable. https://leetcode.com/problems/convert-sorted-array-to-binary-search-tree/ is a good stepping stone to this one. "
                    },
                    {
                        "username": "studshubham",
                        "content": "I think this question should put in Hard category."
                    },
                    {
                        "username": "marks716",
                        "content": "I agree, on the easier spectrum of hard but still above medium. This is not the same as Binary Tree Level Order Traversal which is marked as being the same level."
                    },
                    {
                        "username": "Kashyap2502",
                        "content": "[@Mister_CK](/Mister_CK)\\n That\\'s really helpful thanks a lot"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "disagree, it\\'s quite straightforward, compared to the hard tree problems this is very doable. It builds on this Easy problem: https://leetcode.com/problems/convert-sorted-array-to-binary-search-tree/, it\\'s the same recursive build pattern but a bit more tricky due to the fact that you have to use the combination of two traversal arrays. But not that hard. "
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "[@imbobnewbie](/imbobnewbie) I think they tagged this a medium because this is something they teach in college (at least they taught us in our college) how to do, didn\\'t made us write program, but asked us this question in our exam - \\ndraw the tree and/or find the postorder if preorder and inorder is given for a binary tree."
                    },
                    {
                        "username": "davidtn",
                        "content": "For once I disagree. You only need to practice this once. The visualization comes wayyyy easier if you have a pen and paper. \n\nThere are 2 main tricks based on the concept of the most basic traversals.\n1) Know what is given for each, what isn't given. \n2) For those that aren't given, use the other givens to derive the unknowns.\n\nIf you somehow know this is about subproblems, then cutting up the arrays into small chunks each time is doable.\n\nCombining 2 concepts is standard for Medium. I solved this in 22', aiming for 15."
                    },
                    {
                        "username": "imbobnewbie",
                        "content": "[@RafeeqM](/RafeeqM) I'm going through mediums now and agree. This one requires several observations that would be fairly difficult to make during an interview unless you've solved this or numerous similar problems before. Coding portion isn't bad, but the logic is a challenge."
                    },
                    {
                        "username": "Skios",
                        "content": "i agree it\\'s pretty hard to wrap your head around. I wish there were four categories: easy, medium, hard, very hard. this is one of the hardest medium i\\'ve done"
                    },
                    {
                        "username": "davidtn",
                        "content": "Keep trying guys! I struggled with a similar problem a year ago. But today, with a piece of PEN and PAPER also vaguely remembering the \"tricks\", I solved it in 22 minutes. (Solving medium in 15\\' is standard in big tech interviews, according to a friend of mine who had done 300+ problems)\\n\\nTRICKS:\\n- preorder ALWAYS has the node first. But you don\\'t know the size of either branch.\\n- inorder ALWAYS has the left branch to the left of the node, and right branch right of the node. So now you know the size of each branch.\\n\\nTake those information and break the arrays into subproblems, based on the size.\\n"
                    },
                    {
                        "username": "PrimeDispenser",
                        "content": "Great tip, thanks!"
                    },
                    {
                        "username": "rreocode",
                        "content": "good tip many thanks "
                    },
                    {
                        "username": "mystiquecoder",
                        "content": "this question played with my emotions"
                    },
                    {
                        "username": "mochiball",
                        "content": "Good lord this question is hard af "
                    },
                    {
                        "username": "eaglesky",
                        "content": "I'm thinking about one possible follow-up question: what if duplicates are allowed in the binary tree? Can we modify the original recursive solution to get it work?"
                    },
                    {
                        "username": "SanskarGoyal_14",
                        "content": "YES, there is GFG Question for duplicates. The only difference is in finding index of element in inorder array.\\nTo solve that issue,\\n1. We can create a visited vector and pass it by reference.\\n2. Now, when searching for index, also check if visited[i] == 0, only then enter if block, change visited[i] to 1 and return i.\\n3. By doing this, we can easily skip elements that have same value as target-element but have been visited.\\n\\nCheers.. ^_^"
                    },
                    {
                        "username": "Kunal_101",
                        "content": "[@adis176](/adis176) There is a question in gfg considering duplicates.."
                    },
                    {
                        "username": "adis176",
                        "content": "Then it would not be possible to judge how many nodes actually make up the left subtree, or how many to include in the right subtree.\\nDifferent arrangement of trees can have the same inorder and preorder if duplicates are allowed, which would then render this question null."
                    },
                    {
                        "username": "puneets2811",
                        "content": "What if we have only 1 symbol repeated n times for both traversals?"
                    },
                    {
                        "username": "kharemohit786",
                        "content": "For input \\n[-1]\\n[-1]\\nIt is giving error while submitting the code but with custom input it is working fine."
                    },
                    {
                        "username": "Vikasgupta6",
                        "content": "Just reinitialized the value of your \\nstatic preOrder Index to 0, after end of the programme."
                    },
                    {
                        "username": "deadbeat253",
                        "content": "I am curious why in the example there are no nodes added to the initial left subtree (9) and the tree is continuing to be built from the initial right subtree. For example why is [3,9,20,null,null,15,7] correct but [3,9,20,15,7,null,null] is incorrect? They are both valid binary trees. How is one supposed to know which subtrees are null if the initial arrays (preorder and inorder) don\\'t contain null values?"
                    },
                    {
                        "username": "Sahil_Lohan",
                        "content": "thats why, They provided two arrays"
                    },
                    {
                        "username": "hopeNoPip",
                        "content": "So.. why do we need preorder and inorder to the same tree to build a Tree? why are both needed? "
                    },
                    {
                        "username": "anmolp476",
                        "content": "Do you still need help?"
                    },
                    {
                        "username": "MeloWang0308",
                        "content": "Awesome question. Based on my understand, you can build up multiple trees based on the same pre-order or in-order list. However, if we have two of them, we only have one solution. "
                    },
                    {
                        "username": "asong641",
                        "content": "You can't fully determine the shape of a tree with just 1 of them. \nFor example, the preorder example [3,9,20,15,7] can look like the tree given in the question or it can look like one long tree consisting of only left branches and a depth of 5 nodes. There are a couple different possibilities on how the preorder array can look as a binary tree. How do we know which one is correct? You have to use the inorder to verify."
                    },
                    {
                        "username": "roovent",
                        "content": "I simply put `return nil`, but it shows **Compile Error**. Soooo annoying!"
                    }
                ]
            },
            {
                "id": 1729910,
                "content": [
                    {
                        "username": "mohamed_waseela",
                        "content": "if you get this question, they do not want to hire you."
                    },
                    {
                        "username": "taroTown",
                        "content": "LMFAO"
                    },
                    {
                        "username": "user8143P",
                        "content": "hahaha, that's why I like the discussion module in Leetcode"
                    },
                    {
                        "username": "JosephHauter",
                        "content": "LMAOOO "
                    },
                    {
                        "username": "mochiball",
                        "content": "lmfaoooooo you\\'re not wrong "
                    },
                    {
                        "username": "omakovsk",
                        "content": "ahaha"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "If you can\\'t do this, they probably shouldn\\'t :P. JK, just keep practicing, if you do a bunch of tree problems, this one really is quite doable. https://leetcode.com/problems/convert-sorted-array-to-binary-search-tree/ is a good stepping stone to this one. "
                    },
                    {
                        "username": "studshubham",
                        "content": "I think this question should put in Hard category."
                    },
                    {
                        "username": "marks716",
                        "content": "I agree, on the easier spectrum of hard but still above medium. This is not the same as Binary Tree Level Order Traversal which is marked as being the same level."
                    },
                    {
                        "username": "Kashyap2502",
                        "content": "[@Mister_CK](/Mister_CK)\\n That\\'s really helpful thanks a lot"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "disagree, it\\'s quite straightforward, compared to the hard tree problems this is very doable. It builds on this Easy problem: https://leetcode.com/problems/convert-sorted-array-to-binary-search-tree/, it\\'s the same recursive build pattern but a bit more tricky due to the fact that you have to use the combination of two traversal arrays. But not that hard. "
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "[@imbobnewbie](/imbobnewbie) I think they tagged this a medium because this is something they teach in college (at least they taught us in our college) how to do, didn\\'t made us write program, but asked us this question in our exam - \\ndraw the tree and/or find the postorder if preorder and inorder is given for a binary tree."
                    },
                    {
                        "username": "davidtn",
                        "content": "For once I disagree. You only need to practice this once. The visualization comes wayyyy easier if you have a pen and paper. \n\nThere are 2 main tricks based on the concept of the most basic traversals.\n1) Know what is given for each, what isn't given. \n2) For those that aren't given, use the other givens to derive the unknowns.\n\nIf you somehow know this is about subproblems, then cutting up the arrays into small chunks each time is doable.\n\nCombining 2 concepts is standard for Medium. I solved this in 22', aiming for 15."
                    },
                    {
                        "username": "imbobnewbie",
                        "content": "[@RafeeqM](/RafeeqM) I'm going through mediums now and agree. This one requires several observations that would be fairly difficult to make during an interview unless you've solved this or numerous similar problems before. Coding portion isn't bad, but the logic is a challenge."
                    },
                    {
                        "username": "Skios",
                        "content": "i agree it\\'s pretty hard to wrap your head around. I wish there were four categories: easy, medium, hard, very hard. this is one of the hardest medium i\\'ve done"
                    },
                    {
                        "username": "davidtn",
                        "content": "Keep trying guys! I struggled with a similar problem a year ago. But today, with a piece of PEN and PAPER also vaguely remembering the \"tricks\", I solved it in 22 minutes. (Solving medium in 15\\' is standard in big tech interviews, according to a friend of mine who had done 300+ problems)\\n\\nTRICKS:\\n- preorder ALWAYS has the node first. But you don\\'t know the size of either branch.\\n- inorder ALWAYS has the left branch to the left of the node, and right branch right of the node. So now you know the size of each branch.\\n\\nTake those information and break the arrays into subproblems, based on the size.\\n"
                    },
                    {
                        "username": "PrimeDispenser",
                        "content": "Great tip, thanks!"
                    },
                    {
                        "username": "rreocode",
                        "content": "good tip many thanks "
                    },
                    {
                        "username": "mystiquecoder",
                        "content": "this question played with my emotions"
                    },
                    {
                        "username": "mochiball",
                        "content": "Good lord this question is hard af "
                    },
                    {
                        "username": "eaglesky",
                        "content": "I'm thinking about one possible follow-up question: what if duplicates are allowed in the binary tree? Can we modify the original recursive solution to get it work?"
                    },
                    {
                        "username": "SanskarGoyal_14",
                        "content": "YES, there is GFG Question for duplicates. The only difference is in finding index of element in inorder array.\\nTo solve that issue,\\n1. We can create a visited vector and pass it by reference.\\n2. Now, when searching for index, also check if visited[i] == 0, only then enter if block, change visited[i] to 1 and return i.\\n3. By doing this, we can easily skip elements that have same value as target-element but have been visited.\\n\\nCheers.. ^_^"
                    },
                    {
                        "username": "Kunal_101",
                        "content": "[@adis176](/adis176) There is a question in gfg considering duplicates.."
                    },
                    {
                        "username": "adis176",
                        "content": "Then it would not be possible to judge how many nodes actually make up the left subtree, or how many to include in the right subtree.\\nDifferent arrangement of trees can have the same inorder and preorder if duplicates are allowed, which would then render this question null."
                    },
                    {
                        "username": "puneets2811",
                        "content": "What if we have only 1 symbol repeated n times for both traversals?"
                    },
                    {
                        "username": "kharemohit786",
                        "content": "For input \\n[-1]\\n[-1]\\nIt is giving error while submitting the code but with custom input it is working fine."
                    },
                    {
                        "username": "Vikasgupta6",
                        "content": "Just reinitialized the value of your \\nstatic preOrder Index to 0, after end of the programme."
                    },
                    {
                        "username": "deadbeat253",
                        "content": "I am curious why in the example there are no nodes added to the initial left subtree (9) and the tree is continuing to be built from the initial right subtree. For example why is [3,9,20,null,null,15,7] correct but [3,9,20,15,7,null,null] is incorrect? They are both valid binary trees. How is one supposed to know which subtrees are null if the initial arrays (preorder and inorder) don\\'t contain null values?"
                    },
                    {
                        "username": "Sahil_Lohan",
                        "content": "thats why, They provided two arrays"
                    },
                    {
                        "username": "hopeNoPip",
                        "content": "So.. why do we need preorder and inorder to the same tree to build a Tree? why are both needed? "
                    },
                    {
                        "username": "anmolp476",
                        "content": "Do you still need help?"
                    },
                    {
                        "username": "MeloWang0308",
                        "content": "Awesome question. Based on my understand, you can build up multiple trees based on the same pre-order or in-order list. However, if we have two of them, we only have one solution. "
                    },
                    {
                        "username": "asong641",
                        "content": "You can't fully determine the shape of a tree with just 1 of them. \nFor example, the preorder example [3,9,20,15,7] can look like the tree given in the question or it can look like one long tree consisting of only left branches and a depth of 5 nodes. There are a couple different possibilities on how the preorder array can look as a binary tree. How do we know which one is correct? You have to use the inorder to verify."
                    },
                    {
                        "username": "roovent",
                        "content": "I simply put `return nil`, but it shows **Compile Error**. Soooo annoying!"
                    }
                ]
            },
            {
                "id": 1567311,
                "content": [
                    {
                        "username": "mohamed_waseela",
                        "content": "if you get this question, they do not want to hire you."
                    },
                    {
                        "username": "taroTown",
                        "content": "LMFAO"
                    },
                    {
                        "username": "user8143P",
                        "content": "hahaha, that's why I like the discussion module in Leetcode"
                    },
                    {
                        "username": "JosephHauter",
                        "content": "LMAOOO "
                    },
                    {
                        "username": "mochiball",
                        "content": "lmfaoooooo you\\'re not wrong "
                    },
                    {
                        "username": "omakovsk",
                        "content": "ahaha"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "If you can\\'t do this, they probably shouldn\\'t :P. JK, just keep practicing, if you do a bunch of tree problems, this one really is quite doable. https://leetcode.com/problems/convert-sorted-array-to-binary-search-tree/ is a good stepping stone to this one. "
                    },
                    {
                        "username": "studshubham",
                        "content": "I think this question should put in Hard category."
                    },
                    {
                        "username": "marks716",
                        "content": "I agree, on the easier spectrum of hard but still above medium. This is not the same as Binary Tree Level Order Traversal which is marked as being the same level."
                    },
                    {
                        "username": "Kashyap2502",
                        "content": "[@Mister_CK](/Mister_CK)\\n That\\'s really helpful thanks a lot"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "disagree, it\\'s quite straightforward, compared to the hard tree problems this is very doable. It builds on this Easy problem: https://leetcode.com/problems/convert-sorted-array-to-binary-search-tree/, it\\'s the same recursive build pattern but a bit more tricky due to the fact that you have to use the combination of two traversal arrays. But not that hard. "
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "[@imbobnewbie](/imbobnewbie) I think they tagged this a medium because this is something they teach in college (at least they taught us in our college) how to do, didn\\'t made us write program, but asked us this question in our exam - \\ndraw the tree and/or find the postorder if preorder and inorder is given for a binary tree."
                    },
                    {
                        "username": "davidtn",
                        "content": "For once I disagree. You only need to practice this once. The visualization comes wayyyy easier if you have a pen and paper. \n\nThere are 2 main tricks based on the concept of the most basic traversals.\n1) Know what is given for each, what isn't given. \n2) For those that aren't given, use the other givens to derive the unknowns.\n\nIf you somehow know this is about subproblems, then cutting up the arrays into small chunks each time is doable.\n\nCombining 2 concepts is standard for Medium. I solved this in 22', aiming for 15."
                    },
                    {
                        "username": "imbobnewbie",
                        "content": "[@RafeeqM](/RafeeqM) I'm going through mediums now and agree. This one requires several observations that would be fairly difficult to make during an interview unless you've solved this or numerous similar problems before. Coding portion isn't bad, but the logic is a challenge."
                    },
                    {
                        "username": "Skios",
                        "content": "i agree it\\'s pretty hard to wrap your head around. I wish there were four categories: easy, medium, hard, very hard. this is one of the hardest medium i\\'ve done"
                    },
                    {
                        "username": "davidtn",
                        "content": "Keep trying guys! I struggled with a similar problem a year ago. But today, with a piece of PEN and PAPER also vaguely remembering the \"tricks\", I solved it in 22 minutes. (Solving medium in 15\\' is standard in big tech interviews, according to a friend of mine who had done 300+ problems)\\n\\nTRICKS:\\n- preorder ALWAYS has the node first. But you don\\'t know the size of either branch.\\n- inorder ALWAYS has the left branch to the left of the node, and right branch right of the node. So now you know the size of each branch.\\n\\nTake those information and break the arrays into subproblems, based on the size.\\n"
                    },
                    {
                        "username": "PrimeDispenser",
                        "content": "Great tip, thanks!"
                    },
                    {
                        "username": "rreocode",
                        "content": "good tip many thanks "
                    },
                    {
                        "username": "mystiquecoder",
                        "content": "this question played with my emotions"
                    },
                    {
                        "username": "mochiball",
                        "content": "Good lord this question is hard af "
                    },
                    {
                        "username": "eaglesky",
                        "content": "I'm thinking about one possible follow-up question: what if duplicates are allowed in the binary tree? Can we modify the original recursive solution to get it work?"
                    },
                    {
                        "username": "SanskarGoyal_14",
                        "content": "YES, there is GFG Question for duplicates. The only difference is in finding index of element in inorder array.\\nTo solve that issue,\\n1. We can create a visited vector and pass it by reference.\\n2. Now, when searching for index, also check if visited[i] == 0, only then enter if block, change visited[i] to 1 and return i.\\n3. By doing this, we can easily skip elements that have same value as target-element but have been visited.\\n\\nCheers.. ^_^"
                    },
                    {
                        "username": "Kunal_101",
                        "content": "[@adis176](/adis176) There is a question in gfg considering duplicates.."
                    },
                    {
                        "username": "adis176",
                        "content": "Then it would not be possible to judge how many nodes actually make up the left subtree, or how many to include in the right subtree.\\nDifferent arrangement of trees can have the same inorder and preorder if duplicates are allowed, which would then render this question null."
                    },
                    {
                        "username": "puneets2811",
                        "content": "What if we have only 1 symbol repeated n times for both traversals?"
                    },
                    {
                        "username": "kharemohit786",
                        "content": "For input \\n[-1]\\n[-1]\\nIt is giving error while submitting the code but with custom input it is working fine."
                    },
                    {
                        "username": "Vikasgupta6",
                        "content": "Just reinitialized the value of your \\nstatic preOrder Index to 0, after end of the programme."
                    },
                    {
                        "username": "deadbeat253",
                        "content": "I am curious why in the example there are no nodes added to the initial left subtree (9) and the tree is continuing to be built from the initial right subtree. For example why is [3,9,20,null,null,15,7] correct but [3,9,20,15,7,null,null] is incorrect? They are both valid binary trees. How is one supposed to know which subtrees are null if the initial arrays (preorder and inorder) don\\'t contain null values?"
                    },
                    {
                        "username": "Sahil_Lohan",
                        "content": "thats why, They provided two arrays"
                    },
                    {
                        "username": "hopeNoPip",
                        "content": "So.. why do we need preorder and inorder to the same tree to build a Tree? why are both needed? "
                    },
                    {
                        "username": "anmolp476",
                        "content": "Do you still need help?"
                    },
                    {
                        "username": "MeloWang0308",
                        "content": "Awesome question. Based on my understand, you can build up multiple trees based on the same pre-order or in-order list. However, if we have two of them, we only have one solution. "
                    },
                    {
                        "username": "asong641",
                        "content": "You can't fully determine the shape of a tree with just 1 of them. \nFor example, the preorder example [3,9,20,15,7] can look like the tree given in the question or it can look like one long tree consisting of only left branches and a depth of 5 nodes. There are a couple different possibilities on how the preorder array can look as a binary tree. How do we know which one is correct? You have to use the inorder to verify."
                    },
                    {
                        "username": "roovent",
                        "content": "I simply put `return nil`, but it shows **Compile Error**. Soooo annoying!"
                    }
                ]
            },
            {
                "id": 1945357,
                "content": [
                    {
                        "username": "aayusht4736",
                        "content": "I have seen many comments facing TLE for 202 testcase. Make sure to pass fixed parameters:  as a pass be 'reference' instead of pass by 'value'. "
                    },
                    {
                        "username": "johnnzhao",
                        "content": "upvote if you solved this without any help"
                    },
                    {
                        "username": "syamavarma",
                        "content": "When I do \"Run Code\", the output is correct for the input. But when I submit, the same input gives me exception. Any ideas?\\n\\nThanks in advance."
                    },
                    {
                        "username": "zhukov",
                        "content": "My recursive solution failed for this test case [1, 2], [2, 1]. The expected output is {1, 2} where 2 is the left child of 1. This violates one basic property of BST:\\n\\nThe common properties of binary search trees are as follows:[1]\\n\\n    The left subtree of a node contains only nodes with keys **less than** the node's key.\\n\\n[http://en.wikipedia.org/wiki/Binary_search_tree][1]\\n\\n\\n  [1]: http://en.wikipedia.org/wiki/Binary_search_tree"
                    },
                    {
                        "username": "jeraldy",
                        "content": "The questions asks about a Binary Tree and not a Binary Search Tree"
                    },
                    {
                        "username": "cagils",
                        "content": "Code golfy 1-line fast javascript I have come up with after messing with my proper solution for fun:\\n```js\\nvar buildTree = function (preorder, inorder) {\\n    p = i = v = 0\\n    const f = x => inorder[i] == x ? null : (v = preorder[p++], new TreeNode(v, f(v), f(x, ++i)))\\n    return f()\\n};\\n```"
                    },
                    {
                        "username": "harryshil926",
                        "content": "Is it possible to solve this if values in the tree are not unique?"
                    },
                    {
                        "username": "adis176",
                        "content": "Then it would not be possible to judge how many nodes actually make up the left subtree, or how many to include in the right subtree.\\nDifferent arrangement of trees can have the same inorder and preorder if duplicates are allowed, which would then render this question null."
                    },
                    {
                        "username": "anish_patro",
                        "content": "202/203 passed\n\nclass Solution {\npublic:\n    TreeNode* buildTree(vector<int>& preorder, vector<int>& inorder) {\n        map<int, int> inMap;\n        for(int i=0;i<inorder.size();++i){\n            inMap[inorder[i]]=i;\n        }\n        TreeNode* root= buildTree(preorder,0,preorder.size()-1, inorder, 0, inorder.size()-1,inMap);\n        return root;\n    }\n    TreeNode* buildTree(vector<int>& preorder, int preStart, int preEnd, vector<int>& inorder, int inStart, int inEnd, map<int,int> inMap){\n        if ( preStart> preEnd || inStart > inEnd )\n        return NULL;\n        TreeNode* root= new TreeNode(preorder[preStart]);\n        int inRoot= inMap[root->val];\n        int numsLeft = inRoot- inStart;\n        root->left =  buildTree(preorder, preStart+1, preStart + numsLeft, inorder, inStart,inRoot-1, inMap);\n root->right =  buildTree(preorder, preStart+numsLeft+1, preEnd, inorder, inRoot+1, inEnd,inMap);\n return root;\n    }\n};"
                    },
                    {
                        "username": "likith__rg",
                        "content": " pass the map in function with refernce"
                    },
                    {
                        "username": "ayalasomayaula",
                        "content": "Is it a perfect binary tree?  Does not look like it."
                    },
                    {
                        "username": "leetcancode",
                        "content": "I was almost going to give up, then I came to discussion.\\n\\nMy solution got accepted in the first submission.\\n\\nThanks guys for the motivation!"
                    },
                    {
                        "username": "calicoder",
                        "content": "Test case 122:\\n\\nInput\\npreorder =\\n[3,1,2,4]\\ninorder =\\n[1,2,3,4]\\nExpected\\n[3,1,4,null,2]\\n\\nThe \"expected\" is not valid, right?"
                    },
                    {
                        "username": "sjames8888",
                        "content": "seems ok ?\\n\\n```txt\\n           3\\n        /       \\\\\\n       1         4\\n        \\\\\\n         2\\n\\nBUILD SUCCESSFUL in 2s\\n3 actionable tasks: 2 executed, 1 up-to-date\\n22:02:34: Execution finished \\':test --tests \"leet.ConstructBinaryTreePreorderInorderTraversalTest.case7\"\\'.\\n```\\n\\n```java\\n @Test\\n    void case7() {\\n        final var root = new ConstructBinaryTreePreorderInorderTraversal().buildTree(new int[]{3,1,2,4}, new int[]{1,2,3,4});\\n        final var arr = root.toArray();\\n        Assertions.assertArrayEquals(new Integer[]{3,1,4,null,2}, arr);\\n        System.out.println(root.prettyPrint());\\n    }\\n```"
                    }
                ]
            },
            {
                "id": 1769115,
                "content": [
                    {
                        "username": "aayusht4736",
                        "content": "I have seen many comments facing TLE for 202 testcase. Make sure to pass fixed parameters:  as a pass be 'reference' instead of pass by 'value'. "
                    },
                    {
                        "username": "johnnzhao",
                        "content": "upvote if you solved this without any help"
                    },
                    {
                        "username": "syamavarma",
                        "content": "When I do \"Run Code\", the output is correct for the input. But when I submit, the same input gives me exception. Any ideas?\\n\\nThanks in advance."
                    },
                    {
                        "username": "zhukov",
                        "content": "My recursive solution failed for this test case [1, 2], [2, 1]. The expected output is {1, 2} where 2 is the left child of 1. This violates one basic property of BST:\\n\\nThe common properties of binary search trees are as follows:[1]\\n\\n    The left subtree of a node contains only nodes with keys **less than** the node's key.\\n\\n[http://en.wikipedia.org/wiki/Binary_search_tree][1]\\n\\n\\n  [1]: http://en.wikipedia.org/wiki/Binary_search_tree"
                    },
                    {
                        "username": "jeraldy",
                        "content": "The questions asks about a Binary Tree and not a Binary Search Tree"
                    },
                    {
                        "username": "cagils",
                        "content": "Code golfy 1-line fast javascript I have come up with after messing with my proper solution for fun:\\n```js\\nvar buildTree = function (preorder, inorder) {\\n    p = i = v = 0\\n    const f = x => inorder[i] == x ? null : (v = preorder[p++], new TreeNode(v, f(v), f(x, ++i)))\\n    return f()\\n};\\n```"
                    },
                    {
                        "username": "harryshil926",
                        "content": "Is it possible to solve this if values in the tree are not unique?"
                    },
                    {
                        "username": "adis176",
                        "content": "Then it would not be possible to judge how many nodes actually make up the left subtree, or how many to include in the right subtree.\\nDifferent arrangement of trees can have the same inorder and preorder if duplicates are allowed, which would then render this question null."
                    },
                    {
                        "username": "anish_patro",
                        "content": "202/203 passed\n\nclass Solution {\npublic:\n    TreeNode* buildTree(vector<int>& preorder, vector<int>& inorder) {\n        map<int, int> inMap;\n        for(int i=0;i<inorder.size();++i){\n            inMap[inorder[i]]=i;\n        }\n        TreeNode* root= buildTree(preorder,0,preorder.size()-1, inorder, 0, inorder.size()-1,inMap);\n        return root;\n    }\n    TreeNode* buildTree(vector<int>& preorder, int preStart, int preEnd, vector<int>& inorder, int inStart, int inEnd, map<int,int> inMap){\n        if ( preStart> preEnd || inStart > inEnd )\n        return NULL;\n        TreeNode* root= new TreeNode(preorder[preStart]);\n        int inRoot= inMap[root->val];\n        int numsLeft = inRoot- inStart;\n        root->left =  buildTree(preorder, preStart+1, preStart + numsLeft, inorder, inStart,inRoot-1, inMap);\n root->right =  buildTree(preorder, preStart+numsLeft+1, preEnd, inorder, inRoot+1, inEnd,inMap);\n return root;\n    }\n};"
                    },
                    {
                        "username": "likith__rg",
                        "content": " pass the map in function with refernce"
                    },
                    {
                        "username": "ayalasomayaula",
                        "content": "Is it a perfect binary tree?  Does not look like it."
                    },
                    {
                        "username": "leetcancode",
                        "content": "I was almost going to give up, then I came to discussion.\\n\\nMy solution got accepted in the first submission.\\n\\nThanks guys for the motivation!"
                    },
                    {
                        "username": "calicoder",
                        "content": "Test case 122:\\n\\nInput\\npreorder =\\n[3,1,2,4]\\ninorder =\\n[1,2,3,4]\\nExpected\\n[3,1,4,null,2]\\n\\nThe \"expected\" is not valid, right?"
                    },
                    {
                        "username": "sjames8888",
                        "content": "seems ok ?\\n\\n```txt\\n           3\\n        /       \\\\\\n       1         4\\n        \\\\\\n         2\\n\\nBUILD SUCCESSFUL in 2s\\n3 actionable tasks: 2 executed, 1 up-to-date\\n22:02:34: Execution finished \\':test --tests \"leet.ConstructBinaryTreePreorderInorderTraversalTest.case7\"\\'.\\n```\\n\\n```java\\n @Test\\n    void case7() {\\n        final var root = new ConstructBinaryTreePreorderInorderTraversal().buildTree(new int[]{3,1,2,4}, new int[]{1,2,3,4});\\n        final var arr = root.toArray();\\n        Assertions.assertArrayEquals(new Integer[]{3,1,4,null,2}, arr);\\n        System.out.println(root.prettyPrint());\\n    }\\n```"
                    }
                ]
            },
            {
                "id": 1572957,
                "content": [
                    {
                        "username": "aayusht4736",
                        "content": "I have seen many comments facing TLE for 202 testcase. Make sure to pass fixed parameters:  as a pass be 'reference' instead of pass by 'value'. "
                    },
                    {
                        "username": "johnnzhao",
                        "content": "upvote if you solved this without any help"
                    },
                    {
                        "username": "syamavarma",
                        "content": "When I do \"Run Code\", the output is correct for the input. But when I submit, the same input gives me exception. Any ideas?\\n\\nThanks in advance."
                    },
                    {
                        "username": "zhukov",
                        "content": "My recursive solution failed for this test case [1, 2], [2, 1]. The expected output is {1, 2} where 2 is the left child of 1. This violates one basic property of BST:\\n\\nThe common properties of binary search trees are as follows:[1]\\n\\n    The left subtree of a node contains only nodes with keys **less than** the node's key.\\n\\n[http://en.wikipedia.org/wiki/Binary_search_tree][1]\\n\\n\\n  [1]: http://en.wikipedia.org/wiki/Binary_search_tree"
                    },
                    {
                        "username": "jeraldy",
                        "content": "The questions asks about a Binary Tree and not a Binary Search Tree"
                    },
                    {
                        "username": "cagils",
                        "content": "Code golfy 1-line fast javascript I have come up with after messing with my proper solution for fun:\\n```js\\nvar buildTree = function (preorder, inorder) {\\n    p = i = v = 0\\n    const f = x => inorder[i] == x ? null : (v = preorder[p++], new TreeNode(v, f(v), f(x, ++i)))\\n    return f()\\n};\\n```"
                    },
                    {
                        "username": "harryshil926",
                        "content": "Is it possible to solve this if values in the tree are not unique?"
                    },
                    {
                        "username": "adis176",
                        "content": "Then it would not be possible to judge how many nodes actually make up the left subtree, or how many to include in the right subtree.\\nDifferent arrangement of trees can have the same inorder and preorder if duplicates are allowed, which would then render this question null."
                    },
                    {
                        "username": "anish_patro",
                        "content": "202/203 passed\n\nclass Solution {\npublic:\n    TreeNode* buildTree(vector<int>& preorder, vector<int>& inorder) {\n        map<int, int> inMap;\n        for(int i=0;i<inorder.size();++i){\n            inMap[inorder[i]]=i;\n        }\n        TreeNode* root= buildTree(preorder,0,preorder.size()-1, inorder, 0, inorder.size()-1,inMap);\n        return root;\n    }\n    TreeNode* buildTree(vector<int>& preorder, int preStart, int preEnd, vector<int>& inorder, int inStart, int inEnd, map<int,int> inMap){\n        if ( preStart> preEnd || inStart > inEnd )\n        return NULL;\n        TreeNode* root= new TreeNode(preorder[preStart]);\n        int inRoot= inMap[root->val];\n        int numsLeft = inRoot- inStart;\n        root->left =  buildTree(preorder, preStart+1, preStart + numsLeft, inorder, inStart,inRoot-1, inMap);\n root->right =  buildTree(preorder, preStart+numsLeft+1, preEnd, inorder, inRoot+1, inEnd,inMap);\n return root;\n    }\n};"
                    },
                    {
                        "username": "likith__rg",
                        "content": " pass the map in function with refernce"
                    },
                    {
                        "username": "ayalasomayaula",
                        "content": "Is it a perfect binary tree?  Does not look like it."
                    },
                    {
                        "username": "leetcancode",
                        "content": "I was almost going to give up, then I came to discussion.\\n\\nMy solution got accepted in the first submission.\\n\\nThanks guys for the motivation!"
                    },
                    {
                        "username": "calicoder",
                        "content": "Test case 122:\\n\\nInput\\npreorder =\\n[3,1,2,4]\\ninorder =\\n[1,2,3,4]\\nExpected\\n[3,1,4,null,2]\\n\\nThe \"expected\" is not valid, right?"
                    },
                    {
                        "username": "sjames8888",
                        "content": "seems ok ?\\n\\n```txt\\n           3\\n        /       \\\\\\n       1         4\\n        \\\\\\n         2\\n\\nBUILD SUCCESSFUL in 2s\\n3 actionable tasks: 2 executed, 1 up-to-date\\n22:02:34: Execution finished \\':test --tests \"leet.ConstructBinaryTreePreorderInorderTraversalTest.case7\"\\'.\\n```\\n\\n```java\\n @Test\\n    void case7() {\\n        final var root = new ConstructBinaryTreePreorderInorderTraversal().buildTree(new int[]{3,1,2,4}, new int[]{1,2,3,4});\\n        final var arr = root.toArray();\\n        Assertions.assertArrayEquals(new Integer[]{3,1,4,null,2}, arr);\\n        System.out.println(root.prettyPrint());\\n    }\\n```"
                    }
                ]
            },
            {
                "id": 1571224,
                "content": [
                    {
                        "username": "aayusht4736",
                        "content": "I have seen many comments facing TLE for 202 testcase. Make sure to pass fixed parameters:  as a pass be 'reference' instead of pass by 'value'. "
                    },
                    {
                        "username": "johnnzhao",
                        "content": "upvote if you solved this without any help"
                    },
                    {
                        "username": "syamavarma",
                        "content": "When I do \"Run Code\", the output is correct for the input. But when I submit, the same input gives me exception. Any ideas?\\n\\nThanks in advance."
                    },
                    {
                        "username": "zhukov",
                        "content": "My recursive solution failed for this test case [1, 2], [2, 1]. The expected output is {1, 2} where 2 is the left child of 1. This violates one basic property of BST:\\n\\nThe common properties of binary search trees are as follows:[1]\\n\\n    The left subtree of a node contains only nodes with keys **less than** the node's key.\\n\\n[http://en.wikipedia.org/wiki/Binary_search_tree][1]\\n\\n\\n  [1]: http://en.wikipedia.org/wiki/Binary_search_tree"
                    },
                    {
                        "username": "jeraldy",
                        "content": "The questions asks about a Binary Tree and not a Binary Search Tree"
                    },
                    {
                        "username": "cagils",
                        "content": "Code golfy 1-line fast javascript I have come up with after messing with my proper solution for fun:\\n```js\\nvar buildTree = function (preorder, inorder) {\\n    p = i = v = 0\\n    const f = x => inorder[i] == x ? null : (v = preorder[p++], new TreeNode(v, f(v), f(x, ++i)))\\n    return f()\\n};\\n```"
                    },
                    {
                        "username": "harryshil926",
                        "content": "Is it possible to solve this if values in the tree are not unique?"
                    },
                    {
                        "username": "adis176",
                        "content": "Then it would not be possible to judge how many nodes actually make up the left subtree, or how many to include in the right subtree.\\nDifferent arrangement of trees can have the same inorder and preorder if duplicates are allowed, which would then render this question null."
                    },
                    {
                        "username": "anish_patro",
                        "content": "202/203 passed\n\nclass Solution {\npublic:\n    TreeNode* buildTree(vector<int>& preorder, vector<int>& inorder) {\n        map<int, int> inMap;\n        for(int i=0;i<inorder.size();++i){\n            inMap[inorder[i]]=i;\n        }\n        TreeNode* root= buildTree(preorder,0,preorder.size()-1, inorder, 0, inorder.size()-1,inMap);\n        return root;\n    }\n    TreeNode* buildTree(vector<int>& preorder, int preStart, int preEnd, vector<int>& inorder, int inStart, int inEnd, map<int,int> inMap){\n        if ( preStart> preEnd || inStart > inEnd )\n        return NULL;\n        TreeNode* root= new TreeNode(preorder[preStart]);\n        int inRoot= inMap[root->val];\n        int numsLeft = inRoot- inStart;\n        root->left =  buildTree(preorder, preStart+1, preStart + numsLeft, inorder, inStart,inRoot-1, inMap);\n root->right =  buildTree(preorder, preStart+numsLeft+1, preEnd, inorder, inRoot+1, inEnd,inMap);\n return root;\n    }\n};"
                    },
                    {
                        "username": "likith__rg",
                        "content": " pass the map in function with refernce"
                    },
                    {
                        "username": "ayalasomayaula",
                        "content": "Is it a perfect binary tree?  Does not look like it."
                    },
                    {
                        "username": "leetcancode",
                        "content": "I was almost going to give up, then I came to discussion.\\n\\nMy solution got accepted in the first submission.\\n\\nThanks guys for the motivation!"
                    },
                    {
                        "username": "calicoder",
                        "content": "Test case 122:\\n\\nInput\\npreorder =\\n[3,1,2,4]\\ninorder =\\n[1,2,3,4]\\nExpected\\n[3,1,4,null,2]\\n\\nThe \"expected\" is not valid, right?"
                    },
                    {
                        "username": "sjames8888",
                        "content": "seems ok ?\\n\\n```txt\\n           3\\n        /       \\\\\\n       1         4\\n        \\\\\\n         2\\n\\nBUILD SUCCESSFUL in 2s\\n3 actionable tasks: 2 executed, 1 up-to-date\\n22:02:34: Execution finished \\':test --tests \"leet.ConstructBinaryTreePreorderInorderTraversalTest.case7\"\\'.\\n```\\n\\n```java\\n @Test\\n    void case7() {\\n        final var root = new ConstructBinaryTreePreorderInorderTraversal().buildTree(new int[]{3,1,2,4}, new int[]{1,2,3,4});\\n        final var arr = root.toArray();\\n        Assertions.assertArrayEquals(new Integer[]{3,1,4,null,2}, arr);\\n        System.out.println(root.prettyPrint());\\n    }\\n```"
                    }
                ]
            },
            {
                "id": 1835213,
                "content": [
                    {
                        "username": "aayusht4736",
                        "content": "I have seen many comments facing TLE for 202 testcase. Make sure to pass fixed parameters:  as a pass be 'reference' instead of pass by 'value'. "
                    },
                    {
                        "username": "johnnzhao",
                        "content": "upvote if you solved this without any help"
                    },
                    {
                        "username": "syamavarma",
                        "content": "When I do \"Run Code\", the output is correct for the input. But when I submit, the same input gives me exception. Any ideas?\\n\\nThanks in advance."
                    },
                    {
                        "username": "zhukov",
                        "content": "My recursive solution failed for this test case [1, 2], [2, 1]. The expected output is {1, 2} where 2 is the left child of 1. This violates one basic property of BST:\\n\\nThe common properties of binary search trees are as follows:[1]\\n\\n    The left subtree of a node contains only nodes with keys **less than** the node's key.\\n\\n[http://en.wikipedia.org/wiki/Binary_search_tree][1]\\n\\n\\n  [1]: http://en.wikipedia.org/wiki/Binary_search_tree"
                    },
                    {
                        "username": "jeraldy",
                        "content": "The questions asks about a Binary Tree and not a Binary Search Tree"
                    },
                    {
                        "username": "cagils",
                        "content": "Code golfy 1-line fast javascript I have come up with after messing with my proper solution for fun:\\n```js\\nvar buildTree = function (preorder, inorder) {\\n    p = i = v = 0\\n    const f = x => inorder[i] == x ? null : (v = preorder[p++], new TreeNode(v, f(v), f(x, ++i)))\\n    return f()\\n};\\n```"
                    },
                    {
                        "username": "harryshil926",
                        "content": "Is it possible to solve this if values in the tree are not unique?"
                    },
                    {
                        "username": "adis176",
                        "content": "Then it would not be possible to judge how many nodes actually make up the left subtree, or how many to include in the right subtree.\\nDifferent arrangement of trees can have the same inorder and preorder if duplicates are allowed, which would then render this question null."
                    },
                    {
                        "username": "anish_patro",
                        "content": "202/203 passed\n\nclass Solution {\npublic:\n    TreeNode* buildTree(vector<int>& preorder, vector<int>& inorder) {\n        map<int, int> inMap;\n        for(int i=0;i<inorder.size();++i){\n            inMap[inorder[i]]=i;\n        }\n        TreeNode* root= buildTree(preorder,0,preorder.size()-1, inorder, 0, inorder.size()-1,inMap);\n        return root;\n    }\n    TreeNode* buildTree(vector<int>& preorder, int preStart, int preEnd, vector<int>& inorder, int inStart, int inEnd, map<int,int> inMap){\n        if ( preStart> preEnd || inStart > inEnd )\n        return NULL;\n        TreeNode* root= new TreeNode(preorder[preStart]);\n        int inRoot= inMap[root->val];\n        int numsLeft = inRoot- inStart;\n        root->left =  buildTree(preorder, preStart+1, preStart + numsLeft, inorder, inStart,inRoot-1, inMap);\n root->right =  buildTree(preorder, preStart+numsLeft+1, preEnd, inorder, inRoot+1, inEnd,inMap);\n return root;\n    }\n};"
                    },
                    {
                        "username": "likith__rg",
                        "content": " pass the map in function with refernce"
                    },
                    {
                        "username": "ayalasomayaula",
                        "content": "Is it a perfect binary tree?  Does not look like it."
                    },
                    {
                        "username": "leetcancode",
                        "content": "I was almost going to give up, then I came to discussion.\\n\\nMy solution got accepted in the first submission.\\n\\nThanks guys for the motivation!"
                    },
                    {
                        "username": "calicoder",
                        "content": "Test case 122:\\n\\nInput\\npreorder =\\n[3,1,2,4]\\ninorder =\\n[1,2,3,4]\\nExpected\\n[3,1,4,null,2]\\n\\nThe \"expected\" is not valid, right?"
                    },
                    {
                        "username": "sjames8888",
                        "content": "seems ok ?\\n\\n```txt\\n           3\\n        /       \\\\\\n       1         4\\n        \\\\\\n         2\\n\\nBUILD SUCCESSFUL in 2s\\n3 actionable tasks: 2 executed, 1 up-to-date\\n22:02:34: Execution finished \\':test --tests \"leet.ConstructBinaryTreePreorderInorderTraversalTest.case7\"\\'.\\n```\\n\\n```java\\n @Test\\n    void case7() {\\n        final var root = new ConstructBinaryTreePreorderInorderTraversal().buildTree(new int[]{3,1,2,4}, new int[]{1,2,3,4});\\n        final var arr = root.toArray();\\n        Assertions.assertArrayEquals(new Integer[]{3,1,4,null,2}, arr);\\n        System.out.println(root.prettyPrint());\\n    }\\n```"
                    }
                ]
            },
            {
                "id": 1779884,
                "content": [
                    {
                        "username": "aayusht4736",
                        "content": "I have seen many comments facing TLE for 202 testcase. Make sure to pass fixed parameters:  as a pass be 'reference' instead of pass by 'value'. "
                    },
                    {
                        "username": "johnnzhao",
                        "content": "upvote if you solved this without any help"
                    },
                    {
                        "username": "syamavarma",
                        "content": "When I do \"Run Code\", the output is correct for the input. But when I submit, the same input gives me exception. Any ideas?\\n\\nThanks in advance."
                    },
                    {
                        "username": "zhukov",
                        "content": "My recursive solution failed for this test case [1, 2], [2, 1]. The expected output is {1, 2} where 2 is the left child of 1. This violates one basic property of BST:\\n\\nThe common properties of binary search trees are as follows:[1]\\n\\n    The left subtree of a node contains only nodes with keys **less than** the node's key.\\n\\n[http://en.wikipedia.org/wiki/Binary_search_tree][1]\\n\\n\\n  [1]: http://en.wikipedia.org/wiki/Binary_search_tree"
                    },
                    {
                        "username": "jeraldy",
                        "content": "The questions asks about a Binary Tree and not a Binary Search Tree"
                    },
                    {
                        "username": "cagils",
                        "content": "Code golfy 1-line fast javascript I have come up with after messing with my proper solution for fun:\\n```js\\nvar buildTree = function (preorder, inorder) {\\n    p = i = v = 0\\n    const f = x => inorder[i] == x ? null : (v = preorder[p++], new TreeNode(v, f(v), f(x, ++i)))\\n    return f()\\n};\\n```"
                    },
                    {
                        "username": "harryshil926",
                        "content": "Is it possible to solve this if values in the tree are not unique?"
                    },
                    {
                        "username": "adis176",
                        "content": "Then it would not be possible to judge how many nodes actually make up the left subtree, or how many to include in the right subtree.\\nDifferent arrangement of trees can have the same inorder and preorder if duplicates are allowed, which would then render this question null."
                    },
                    {
                        "username": "anish_patro",
                        "content": "202/203 passed\n\nclass Solution {\npublic:\n    TreeNode* buildTree(vector<int>& preorder, vector<int>& inorder) {\n        map<int, int> inMap;\n        for(int i=0;i<inorder.size();++i){\n            inMap[inorder[i]]=i;\n        }\n        TreeNode* root= buildTree(preorder,0,preorder.size()-1, inorder, 0, inorder.size()-1,inMap);\n        return root;\n    }\n    TreeNode* buildTree(vector<int>& preorder, int preStart, int preEnd, vector<int>& inorder, int inStart, int inEnd, map<int,int> inMap){\n        if ( preStart> preEnd || inStart > inEnd )\n        return NULL;\n        TreeNode* root= new TreeNode(preorder[preStart]);\n        int inRoot= inMap[root->val];\n        int numsLeft = inRoot- inStart;\n        root->left =  buildTree(preorder, preStart+1, preStart + numsLeft, inorder, inStart,inRoot-1, inMap);\n root->right =  buildTree(preorder, preStart+numsLeft+1, preEnd, inorder, inRoot+1, inEnd,inMap);\n return root;\n    }\n};"
                    },
                    {
                        "username": "likith__rg",
                        "content": " pass the map in function with refernce"
                    },
                    {
                        "username": "ayalasomayaula",
                        "content": "Is it a perfect binary tree?  Does not look like it."
                    },
                    {
                        "username": "leetcancode",
                        "content": "I was almost going to give up, then I came to discussion.\\n\\nMy solution got accepted in the first submission.\\n\\nThanks guys for the motivation!"
                    },
                    {
                        "username": "calicoder",
                        "content": "Test case 122:\\n\\nInput\\npreorder =\\n[3,1,2,4]\\ninorder =\\n[1,2,3,4]\\nExpected\\n[3,1,4,null,2]\\n\\nThe \"expected\" is not valid, right?"
                    },
                    {
                        "username": "sjames8888",
                        "content": "seems ok ?\\n\\n```txt\\n           3\\n        /       \\\\\\n       1         4\\n        \\\\\\n         2\\n\\nBUILD SUCCESSFUL in 2s\\n3 actionable tasks: 2 executed, 1 up-to-date\\n22:02:34: Execution finished \\':test --tests \"leet.ConstructBinaryTreePreorderInorderTraversalTest.case7\"\\'.\\n```\\n\\n```java\\n @Test\\n    void case7() {\\n        final var root = new ConstructBinaryTreePreorderInorderTraversal().buildTree(new int[]{3,1,2,4}, new int[]{1,2,3,4});\\n        final var arr = root.toArray();\\n        Assertions.assertArrayEquals(new Integer[]{3,1,4,null,2}, arr);\\n        System.out.println(root.prettyPrint());\\n    }\\n```"
                    }
                ]
            },
            {
                "id": 1834411,
                "content": [
                    {
                        "username": "aayusht4736",
                        "content": "I have seen many comments facing TLE for 202 testcase. Make sure to pass fixed parameters:  as a pass be 'reference' instead of pass by 'value'. "
                    },
                    {
                        "username": "johnnzhao",
                        "content": "upvote if you solved this without any help"
                    },
                    {
                        "username": "syamavarma",
                        "content": "When I do \"Run Code\", the output is correct for the input. But when I submit, the same input gives me exception. Any ideas?\\n\\nThanks in advance."
                    },
                    {
                        "username": "zhukov",
                        "content": "My recursive solution failed for this test case [1, 2], [2, 1]. The expected output is {1, 2} where 2 is the left child of 1. This violates one basic property of BST:\\n\\nThe common properties of binary search trees are as follows:[1]\\n\\n    The left subtree of a node contains only nodes with keys **less than** the node's key.\\n\\n[http://en.wikipedia.org/wiki/Binary_search_tree][1]\\n\\n\\n  [1]: http://en.wikipedia.org/wiki/Binary_search_tree"
                    },
                    {
                        "username": "jeraldy",
                        "content": "The questions asks about a Binary Tree and not a Binary Search Tree"
                    },
                    {
                        "username": "cagils",
                        "content": "Code golfy 1-line fast javascript I have come up with after messing with my proper solution for fun:\\n```js\\nvar buildTree = function (preorder, inorder) {\\n    p = i = v = 0\\n    const f = x => inorder[i] == x ? null : (v = preorder[p++], new TreeNode(v, f(v), f(x, ++i)))\\n    return f()\\n};\\n```"
                    },
                    {
                        "username": "harryshil926",
                        "content": "Is it possible to solve this if values in the tree are not unique?"
                    },
                    {
                        "username": "adis176",
                        "content": "Then it would not be possible to judge how many nodes actually make up the left subtree, or how many to include in the right subtree.\\nDifferent arrangement of trees can have the same inorder and preorder if duplicates are allowed, which would then render this question null."
                    },
                    {
                        "username": "anish_patro",
                        "content": "202/203 passed\n\nclass Solution {\npublic:\n    TreeNode* buildTree(vector<int>& preorder, vector<int>& inorder) {\n        map<int, int> inMap;\n        for(int i=0;i<inorder.size();++i){\n            inMap[inorder[i]]=i;\n        }\n        TreeNode* root= buildTree(preorder,0,preorder.size()-1, inorder, 0, inorder.size()-1,inMap);\n        return root;\n    }\n    TreeNode* buildTree(vector<int>& preorder, int preStart, int preEnd, vector<int>& inorder, int inStart, int inEnd, map<int,int> inMap){\n        if ( preStart> preEnd || inStart > inEnd )\n        return NULL;\n        TreeNode* root= new TreeNode(preorder[preStart]);\n        int inRoot= inMap[root->val];\n        int numsLeft = inRoot- inStart;\n        root->left =  buildTree(preorder, preStart+1, preStart + numsLeft, inorder, inStart,inRoot-1, inMap);\n root->right =  buildTree(preorder, preStart+numsLeft+1, preEnd, inorder, inRoot+1, inEnd,inMap);\n return root;\n    }\n};"
                    },
                    {
                        "username": "likith__rg",
                        "content": " pass the map in function with refernce"
                    },
                    {
                        "username": "ayalasomayaula",
                        "content": "Is it a perfect binary tree?  Does not look like it."
                    },
                    {
                        "username": "leetcancode",
                        "content": "I was almost going to give up, then I came to discussion.\\n\\nMy solution got accepted in the first submission.\\n\\nThanks guys for the motivation!"
                    },
                    {
                        "username": "calicoder",
                        "content": "Test case 122:\\n\\nInput\\npreorder =\\n[3,1,2,4]\\ninorder =\\n[1,2,3,4]\\nExpected\\n[3,1,4,null,2]\\n\\nThe \"expected\" is not valid, right?"
                    },
                    {
                        "username": "sjames8888",
                        "content": "seems ok ?\\n\\n```txt\\n           3\\n        /       \\\\\\n       1         4\\n        \\\\\\n         2\\n\\nBUILD SUCCESSFUL in 2s\\n3 actionable tasks: 2 executed, 1 up-to-date\\n22:02:34: Execution finished \\':test --tests \"leet.ConstructBinaryTreePreorderInorderTraversalTest.case7\"\\'.\\n```\\n\\n```java\\n @Test\\n    void case7() {\\n        final var root = new ConstructBinaryTreePreorderInorderTraversal().buildTree(new int[]{3,1,2,4}, new int[]{1,2,3,4});\\n        final var arr = root.toArray();\\n        Assertions.assertArrayEquals(new Integer[]{3,1,4,null,2}, arr);\\n        System.out.println(root.prettyPrint());\\n    }\\n```"
                    }
                ]
            },
            {
                "id": 2046961,
                "content": [
                    {
                        "username": "aayusht4736",
                        "content": "I have seen many comments facing TLE for 202 testcase. Make sure to pass fixed parameters:  as a pass be 'reference' instead of pass by 'value'. "
                    },
                    {
                        "username": "johnnzhao",
                        "content": "upvote if you solved this without any help"
                    },
                    {
                        "username": "syamavarma",
                        "content": "When I do \"Run Code\", the output is correct for the input. But when I submit, the same input gives me exception. Any ideas?\\n\\nThanks in advance."
                    },
                    {
                        "username": "zhukov",
                        "content": "My recursive solution failed for this test case [1, 2], [2, 1]. The expected output is {1, 2} where 2 is the left child of 1. This violates one basic property of BST:\\n\\nThe common properties of binary search trees are as follows:[1]\\n\\n    The left subtree of a node contains only nodes with keys **less than** the node's key.\\n\\n[http://en.wikipedia.org/wiki/Binary_search_tree][1]\\n\\n\\n  [1]: http://en.wikipedia.org/wiki/Binary_search_tree"
                    },
                    {
                        "username": "jeraldy",
                        "content": "The questions asks about a Binary Tree and not a Binary Search Tree"
                    },
                    {
                        "username": "cagils",
                        "content": "Code golfy 1-line fast javascript I have come up with after messing with my proper solution for fun:\\n```js\\nvar buildTree = function (preorder, inorder) {\\n    p = i = v = 0\\n    const f = x => inorder[i] == x ? null : (v = preorder[p++], new TreeNode(v, f(v), f(x, ++i)))\\n    return f()\\n};\\n```"
                    },
                    {
                        "username": "harryshil926",
                        "content": "Is it possible to solve this if values in the tree are not unique?"
                    },
                    {
                        "username": "adis176",
                        "content": "Then it would not be possible to judge how many nodes actually make up the left subtree, or how many to include in the right subtree.\\nDifferent arrangement of trees can have the same inorder and preorder if duplicates are allowed, which would then render this question null."
                    },
                    {
                        "username": "anish_patro",
                        "content": "202/203 passed\n\nclass Solution {\npublic:\n    TreeNode* buildTree(vector<int>& preorder, vector<int>& inorder) {\n        map<int, int> inMap;\n        for(int i=0;i<inorder.size();++i){\n            inMap[inorder[i]]=i;\n        }\n        TreeNode* root= buildTree(preorder,0,preorder.size()-1, inorder, 0, inorder.size()-1,inMap);\n        return root;\n    }\n    TreeNode* buildTree(vector<int>& preorder, int preStart, int preEnd, vector<int>& inorder, int inStart, int inEnd, map<int,int> inMap){\n        if ( preStart> preEnd || inStart > inEnd )\n        return NULL;\n        TreeNode* root= new TreeNode(preorder[preStart]);\n        int inRoot= inMap[root->val];\n        int numsLeft = inRoot- inStart;\n        root->left =  buildTree(preorder, preStart+1, preStart + numsLeft, inorder, inStart,inRoot-1, inMap);\n root->right =  buildTree(preorder, preStart+numsLeft+1, preEnd, inorder, inRoot+1, inEnd,inMap);\n return root;\n    }\n};"
                    },
                    {
                        "username": "likith__rg",
                        "content": " pass the map in function with refernce"
                    },
                    {
                        "username": "ayalasomayaula",
                        "content": "Is it a perfect binary tree?  Does not look like it."
                    },
                    {
                        "username": "leetcancode",
                        "content": "I was almost going to give up, then I came to discussion.\\n\\nMy solution got accepted in the first submission.\\n\\nThanks guys for the motivation!"
                    },
                    {
                        "username": "calicoder",
                        "content": "Test case 122:\\n\\nInput\\npreorder =\\n[3,1,2,4]\\ninorder =\\n[1,2,3,4]\\nExpected\\n[3,1,4,null,2]\\n\\nThe \"expected\" is not valid, right?"
                    },
                    {
                        "username": "sjames8888",
                        "content": "seems ok ?\\n\\n```txt\\n           3\\n        /       \\\\\\n       1         4\\n        \\\\\\n         2\\n\\nBUILD SUCCESSFUL in 2s\\n3 actionable tasks: 2 executed, 1 up-to-date\\n22:02:34: Execution finished \\':test --tests \"leet.ConstructBinaryTreePreorderInorderTraversalTest.case7\"\\'.\\n```\\n\\n```java\\n @Test\\n    void case7() {\\n        final var root = new ConstructBinaryTreePreorderInorderTraversal().buildTree(new int[]{3,1,2,4}, new int[]{1,2,3,4});\\n        final var arr = root.toArray();\\n        Assertions.assertArrayEquals(new Integer[]{3,1,4,null,2}, arr);\\n        System.out.println(root.prettyPrint());\\n    }\\n```"
                    }
                ]
            },
            {
                "id": 2031448,
                "content": [
                    {
                        "username": "aayusht4736",
                        "content": "I have seen many comments facing TLE for 202 testcase. Make sure to pass fixed parameters:  as a pass be 'reference' instead of pass by 'value'. "
                    },
                    {
                        "username": "johnnzhao",
                        "content": "upvote if you solved this without any help"
                    },
                    {
                        "username": "syamavarma",
                        "content": "When I do \"Run Code\", the output is correct for the input. But when I submit, the same input gives me exception. Any ideas?\\n\\nThanks in advance."
                    },
                    {
                        "username": "zhukov",
                        "content": "My recursive solution failed for this test case [1, 2], [2, 1]. The expected output is {1, 2} where 2 is the left child of 1. This violates one basic property of BST:\\n\\nThe common properties of binary search trees are as follows:[1]\\n\\n    The left subtree of a node contains only nodes with keys **less than** the node's key.\\n\\n[http://en.wikipedia.org/wiki/Binary_search_tree][1]\\n\\n\\n  [1]: http://en.wikipedia.org/wiki/Binary_search_tree"
                    },
                    {
                        "username": "jeraldy",
                        "content": "The questions asks about a Binary Tree and not a Binary Search Tree"
                    },
                    {
                        "username": "cagils",
                        "content": "Code golfy 1-line fast javascript I have come up with after messing with my proper solution for fun:\\n```js\\nvar buildTree = function (preorder, inorder) {\\n    p = i = v = 0\\n    const f = x => inorder[i] == x ? null : (v = preorder[p++], new TreeNode(v, f(v), f(x, ++i)))\\n    return f()\\n};\\n```"
                    },
                    {
                        "username": "harryshil926",
                        "content": "Is it possible to solve this if values in the tree are not unique?"
                    },
                    {
                        "username": "adis176",
                        "content": "Then it would not be possible to judge how many nodes actually make up the left subtree, or how many to include in the right subtree.\\nDifferent arrangement of trees can have the same inorder and preorder if duplicates are allowed, which would then render this question null."
                    },
                    {
                        "username": "anish_patro",
                        "content": "202/203 passed\n\nclass Solution {\npublic:\n    TreeNode* buildTree(vector<int>& preorder, vector<int>& inorder) {\n        map<int, int> inMap;\n        for(int i=0;i<inorder.size();++i){\n            inMap[inorder[i]]=i;\n        }\n        TreeNode* root= buildTree(preorder,0,preorder.size()-1, inorder, 0, inorder.size()-1,inMap);\n        return root;\n    }\n    TreeNode* buildTree(vector<int>& preorder, int preStart, int preEnd, vector<int>& inorder, int inStart, int inEnd, map<int,int> inMap){\n        if ( preStart> preEnd || inStart > inEnd )\n        return NULL;\n        TreeNode* root= new TreeNode(preorder[preStart]);\n        int inRoot= inMap[root->val];\n        int numsLeft = inRoot- inStart;\n        root->left =  buildTree(preorder, preStart+1, preStart + numsLeft, inorder, inStart,inRoot-1, inMap);\n root->right =  buildTree(preorder, preStart+numsLeft+1, preEnd, inorder, inRoot+1, inEnd,inMap);\n return root;\n    }\n};"
                    },
                    {
                        "username": "likith__rg",
                        "content": " pass the map in function with refernce"
                    },
                    {
                        "username": "ayalasomayaula",
                        "content": "Is it a perfect binary tree?  Does not look like it."
                    },
                    {
                        "username": "leetcancode",
                        "content": "I was almost going to give up, then I came to discussion.\\n\\nMy solution got accepted in the first submission.\\n\\nThanks guys for the motivation!"
                    },
                    {
                        "username": "calicoder",
                        "content": "Test case 122:\\n\\nInput\\npreorder =\\n[3,1,2,4]\\ninorder =\\n[1,2,3,4]\\nExpected\\n[3,1,4,null,2]\\n\\nThe \"expected\" is not valid, right?"
                    },
                    {
                        "username": "sjames8888",
                        "content": "seems ok ?\\n\\n```txt\\n           3\\n        /       \\\\\\n       1         4\\n        \\\\\\n         2\\n\\nBUILD SUCCESSFUL in 2s\\n3 actionable tasks: 2 executed, 1 up-to-date\\n22:02:34: Execution finished \\':test --tests \"leet.ConstructBinaryTreePreorderInorderTraversalTest.case7\"\\'.\\n```\\n\\n```java\\n @Test\\n    void case7() {\\n        final var root = new ConstructBinaryTreePreorderInorderTraversal().buildTree(new int[]{3,1,2,4}, new int[]{1,2,3,4});\\n        final var arr = root.toArray();\\n        Assertions.assertArrayEquals(new Integer[]{3,1,4,null,2}, arr);\\n        System.out.println(root.prettyPrint());\\n    }\\n```"
                    }
                ]
            },
            {
                "id": 2016257,
                "content": [
                    {
                        "username": "aayusht4736",
                        "content": "I have seen many comments facing TLE for 202 testcase. Make sure to pass fixed parameters:  as a pass be 'reference' instead of pass by 'value'. "
                    },
                    {
                        "username": "johnnzhao",
                        "content": "upvote if you solved this without any help"
                    },
                    {
                        "username": "syamavarma",
                        "content": "When I do \"Run Code\", the output is correct for the input. But when I submit, the same input gives me exception. Any ideas?\\n\\nThanks in advance."
                    },
                    {
                        "username": "zhukov",
                        "content": "My recursive solution failed for this test case [1, 2], [2, 1]. The expected output is {1, 2} where 2 is the left child of 1. This violates one basic property of BST:\\n\\nThe common properties of binary search trees are as follows:[1]\\n\\n    The left subtree of a node contains only nodes with keys **less than** the node's key.\\n\\n[http://en.wikipedia.org/wiki/Binary_search_tree][1]\\n\\n\\n  [1]: http://en.wikipedia.org/wiki/Binary_search_tree"
                    },
                    {
                        "username": "jeraldy",
                        "content": "The questions asks about a Binary Tree and not a Binary Search Tree"
                    },
                    {
                        "username": "cagils",
                        "content": "Code golfy 1-line fast javascript I have come up with after messing with my proper solution for fun:\\n```js\\nvar buildTree = function (preorder, inorder) {\\n    p = i = v = 0\\n    const f = x => inorder[i] == x ? null : (v = preorder[p++], new TreeNode(v, f(v), f(x, ++i)))\\n    return f()\\n};\\n```"
                    },
                    {
                        "username": "harryshil926",
                        "content": "Is it possible to solve this if values in the tree are not unique?"
                    },
                    {
                        "username": "adis176",
                        "content": "Then it would not be possible to judge how many nodes actually make up the left subtree, or how many to include in the right subtree.\\nDifferent arrangement of trees can have the same inorder and preorder if duplicates are allowed, which would then render this question null."
                    },
                    {
                        "username": "anish_patro",
                        "content": "202/203 passed\n\nclass Solution {\npublic:\n    TreeNode* buildTree(vector<int>& preorder, vector<int>& inorder) {\n        map<int, int> inMap;\n        for(int i=0;i<inorder.size();++i){\n            inMap[inorder[i]]=i;\n        }\n        TreeNode* root= buildTree(preorder,0,preorder.size()-1, inorder, 0, inorder.size()-1,inMap);\n        return root;\n    }\n    TreeNode* buildTree(vector<int>& preorder, int preStart, int preEnd, vector<int>& inorder, int inStart, int inEnd, map<int,int> inMap){\n        if ( preStart> preEnd || inStart > inEnd )\n        return NULL;\n        TreeNode* root= new TreeNode(preorder[preStart]);\n        int inRoot= inMap[root->val];\n        int numsLeft = inRoot- inStart;\n        root->left =  buildTree(preorder, preStart+1, preStart + numsLeft, inorder, inStart,inRoot-1, inMap);\n root->right =  buildTree(preorder, preStart+numsLeft+1, preEnd, inorder, inRoot+1, inEnd,inMap);\n return root;\n    }\n};"
                    },
                    {
                        "username": "likith__rg",
                        "content": " pass the map in function with refernce"
                    },
                    {
                        "username": "ayalasomayaula",
                        "content": "Is it a perfect binary tree?  Does not look like it."
                    },
                    {
                        "username": "leetcancode",
                        "content": "I was almost going to give up, then I came to discussion.\\n\\nMy solution got accepted in the first submission.\\n\\nThanks guys for the motivation!"
                    },
                    {
                        "username": "calicoder",
                        "content": "Test case 122:\\n\\nInput\\npreorder =\\n[3,1,2,4]\\ninorder =\\n[1,2,3,4]\\nExpected\\n[3,1,4,null,2]\\n\\nThe \"expected\" is not valid, right?"
                    },
                    {
                        "username": "sjames8888",
                        "content": "seems ok ?\\n\\n```txt\\n           3\\n        /       \\\\\\n       1         4\\n        \\\\\\n         2\\n\\nBUILD SUCCESSFUL in 2s\\n3 actionable tasks: 2 executed, 1 up-to-date\\n22:02:34: Execution finished \\':test --tests \"leet.ConstructBinaryTreePreorderInorderTraversalTest.case7\"\\'.\\n```\\n\\n```java\\n @Test\\n    void case7() {\\n        final var root = new ConstructBinaryTreePreorderInorderTraversal().buildTree(new int[]{3,1,2,4}, new int[]{1,2,3,4});\\n        final var arr = root.toArray();\\n        Assertions.assertArrayEquals(new Integer[]{3,1,4,null,2}, arr);\\n        System.out.println(root.prettyPrint());\\n    }\\n```"
                    }
                ]
            },
            {
                "id": 1967178,
                "content": [
                    {
                        "username": "sjames8888",
                        "content": "pretty print Java and a few hints\\n\\nhere is a few hints on what I did - I have not looked at other solutions but this is just a few lines of code and runs in 97% of so performance rankings.  It took me a lot of thinking about and head scratching.\\n\\n1. a lookup map on both arrays is useful i.e. node value to position in array.\\n2. recursion is a natural choice where if we have a construct function taking above maps the root value for the given sub tree, the preorder array and bounds of the sub tree (initially 0 and preorder.length - 1.  left is a call to this recursive function on left bound tree to left of the root and right similar.\\n3. if (start >= end) we have no subtree so create return a node with that value at current root and return left, right are null in this case.\\n4. get 2 indices lookup the above maps we will call them inOrderIndex and preOrderIndex.\\n5. looking at the preorder array our left root in next recursive call is always next in preorder list i.e. we call outr recursive function with preorder[preOrderIndex + 1]\\n6. on right the root is preorder[preOrderIndex + nodesOnLeft + 1]\\n7. nodesOnLeft = inOrderIndex - start;\\n8. nodesOnRight = end - inOrderIndex;\\n9. on left recurive call start, end are inOrderIndex - nodesOnLeft, inOrderIndex - 1\\n10 on right recursive call inOrderIndex + 1, inOrderIndex + nodesOnRight)\\n\\n\\n\\nI wrote this to visualise the tree which you may find handy - this is a rush job so I am sure someone can do better, feel free to improve and repost.\\n\\n                3\\n            /       \\\\\\n           9        20\\n                   /   \\\\\\n                 15     7\\n                 / \\\\   / \\\\\\n               21  14 8   5\\n\\n ` @Test\\n    void case3() {\\n        final var root = new ConstructBinaryTreePreorderInorderTraversal().buildTree(new int[]{3,9,20,15,21,14,7,8,5}, new int[]{9,3,21,15,14,20,8,7,5});\\n        final var arr = root.toArray();\\n        System.out.println(root.prettyPrint());\\n    }`\\n\\n\\n  `\\n  /*\\n  place on TreeNode class\\n\\n\\n*/\\n\\n\\n   private int depth(TreeNode root, int level) {\\n        if (root == null) {\\n            return level;\\n        }\\n\\n        return Math.max(depth(root.left, level + 1), depth(root.right, level + 1));\\n    }\\n    \\n    public String prettyPrint() {\\n        return printToGrid(this);\\n    }\\n\\n    public String printToGrid(TreeNode root) {\\n        if (root == null) {\\n            return \"\";\\n        }\\n        final var depth = depth(this, 0);\\n        final var n = 2 * depth * depth;\\n        final var ca = new char[n][n];\\n        final var whiteLine = \" \".repeat(n);\\n        for (var i = 0; i < n; ++i) {\\n            ca[i] = whiteLine.toCharArray();\\n        }\\n        printToGrid(ca, root, 0, ca[0].length / 2);\\n        var sb = new StringBuilder();\\n        for (var r : ca) {\\n            final var s = new String(r).stripTrailing();\\n            if (s.equals(\"\")) {\\n                break;\\n            }\\n            sb.append(s).append(\"\\\\n\");\\n        }\\n        return sb.toString();\\n    }\\n\\n    public void printToGrid( char[][] grid, TreeNode root, int row, int col) {\\n        if (root == null) {\\n            return;\\n        }\\n        final var depth = depth(root,0);\\n        final var v = root.val;\\n        final var s = Integer.toString(v);\\n        var writeCol = col - s.length() / 2;\\n        while (writeCol < grid.length - s.length() && grid[row][writeCol] != \\' \\'\\n                || grid[row][writeCol - 1] != \\' \\') {\\n            ++writeCol;\\n        }\\n        for (var i = 0; i < s.length(); ++i) {\\n            grid[row][writeCol + i] = s.charAt(i);\\n        }\\n        final var spacing = Math.max(2, depth - (row/2) + 1);\\n        if (root.left != null) {\\n            grid[row + 1][col - spacing + 1] = \\'/\\';\\n            printToGrid(grid, root.left, row + 2, col - spacing);\\n        }\\n        if (root.right != null) {\\n            grid[row + 1][col + spacing - 1] = \\'\\\\\\\\\\';\\n            printToGrid(grid, root.right, row + 2, col + spacing);\\n        }\\n    }\\n`"
                    },
                    {
                        "username": "shaamray",
                        "content": "Can anyone clarify why Output: [3,9,20,null,null,15,7] has two null values :\\') ?"
                    },
                    {
                        "username": "sjames8888",
                        "content": "looks as below\n\n```txt\n           3\n        /       \\\n       9        20\n               /   \\\n             15     7\n```\n\n```java\n @Test\n    void case8() {\n        final var root = TreeNode.from(new Integer[]{3,9,20,null,null,15,7});\n        System.out.println(root.prettyPrint());\n    }\n```"
                    },
                    {
                        "username": "codepiyush1",
                        "content": "# Intuition\\nC++ DFS. Easy Recursive, Proper time and space complexity\\n\\n# Approach\\n\\n1. Define a function `makeTree` that takes the following parameters:\\n   - `preorder`: The preorder traversal of the tree.\\n   - `pL`: The lower index of the current range of the preorder traversal.\\n   - `pH`: The upper index of the current range of the preorder traversal.\\n   - `inorder`: The inorder traversal of the tree.\\n   - `iL`: The lower index of the current range of the inorder traversal.\\n   - `iH`: The upper index of the current range of the inorder traversal.\\n   - `mp`: An unordered map to store the mapping of values to their indices in the inorder traversal.\\n\\n2. Check if the range of indices is invalid, i.e., `pL` is greater than `pH` or `iL` is greater than `iH`. If so, return `NULL` indicating an empty subtree.\\n\\n3. Create a new `TreeNode` with the value at index `pL` in the preorder traversal as its value.\\n\\n4. Get the current index (`currInd`) of the value in the inorder traversal by looking it up in the unordered map `mp`.\\n\\n5. Calculate the number of nodes in the left subtree by subtracting `iL` from `currInd`.\\n\\n6. Recursively call the `makeTree` function to construct the left subtree by passing the following parameters:\\n   - `preorder`: Same as the input.\\n   - `pL+1`: Increment the lower index of the preorder traversal by 1.\\n   - `pL+leftNodes`: Set the upper index of the preorder traversal to `pL+leftNodes`.\\n   - `inorder`: Same as the input.\\n   - `iL`: Same as the input.\\n   - `currInd-1`: Set the upper index of the inorder traversal to `currInd-1`.\\n\\n7. Assign the returned subtree to the `left` pointer of the current node.\\n\\n8. Recursively call the `makeTree` function to construct the right subtree by passing the following parameters:\\n   - `preorder`: Same as the input.\\n   - `pL+leftNodes+1`: Set the lower index of the preorder traversal to `pL+leftNodes+1`.\\n   - `pH`: Same as the input.\\n   - `inorder`: Same as the input.\\n   - `currInd+1`: Set the lower index of the inorder traversal to `currInd+1`.\\n   - `iH`: Same as the input.\\n\\n9. Assign the returned subtree to the `right` pointer of the current node.\\n\\n10. Return the root of the constructed binary tree.\\n\\n11. Define a function `buildTree` that takes the following parameters:\\n    - `preorder`: The preorder traversal of the tree.\\n    - `inorder`: The inorder traversal of the tree.\\n\\n12. Create an unordered map `mp` to store the mapping of values to their indices in the inorder traversal.\\n\\n13. Get the size of the inorder traversal and store it in variable `n`.\\n\\n14. Iterate over the values and indices in the inorder traversal, and populate the unordered map `mp`.\\n\\n15. Call the `makeTree` function with the initial parameters:\\n    - `preorder`: Same as the input.\\n    - `0`: Set the lower index of the preorder traversal to 0.\\n    - `n-1`: Set the upper index of the preorder traversal to `n-1`.\\n    - `inorder`: Same as the input.\\n    - `0`: Set the lower index of the inorder traversal\\n\\n------------------------------------\\n# Complexity\\n- Time complexity:\\nT.C=O(n) in each recursive call one node created.\\n- Space complexity:\\nS.C=O(2n) == O(n) , n for unordered_map and n for recursive stack.\\n---------------------------------\\nPlease Upvote. If understand the concept.\\nSolution link:\\nhttps://leetcode.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal/solutions/3707300/c-dfs-easy-recursive-proper-time-and-space-complexity/\\n"
                    },
                    {
                        "username": "mochiball",
                        "content": " I struggled a lot with this problem. Felt pretty good about trees until I came to this one. It was my first divide and conquer problem but I think we can learn a lot from this problem. \\n\\nThis problem focuses on divide and conquer + recursion. Very important ! "
                    },
                    {
                        "username": "dmitriysin",
                        "content": "Example 1 `[3,9,20,null,null,15,7]` is not a binary tree since:\n1) 3 is less than 9\n2) 7 is less than 9"
                    },
                    {
                        "username": "mochiball",
                        "content": "Question is binary tree, NOT binary search tree "
                    },
                    {
                        "username": "meteahmetyakar",
                        "content": "if every node have 2 child we calls it binary tree, I think you mixed with binary search tree. In binary trees there is no value relation between nodes."
                    },
                    {
                        "username": "adgjl30102005",
                        "content": "Please help, I use the code in Editorial with this test case: pre= [4,1,3,6,8]; inorder = [6,1,8,4,3]\\nand it doesn\\'t work.\\nThe tree should look like this:\\n           4\\n        /     \\\\\\n       1       3\\n      /\\\\\\n    6    8\\nHand Calculating:\\npreorder = [4, 1, 3, 6, 8]\\nHashmap: {6:0 ; 1:1 ; 8:2 ; 4:3 ; 3:4 }\\npreorderindex = 0\\nloop 1:\\nleft = 0 right = 3\\npreorderindex = 0 => root value = 4 => new right = 2\\ntree : 4\\nloop 2:\\nleft = 0 right = 2\\npreorderindex = 1 => root value = 1 => new right = 0\\ntree: 4\\n      1\\nloop 3: \\nleft =0 right = 0\\npreorderindex = 2 => root value = 3 => new right = 3\\ntree: 4\\n      1\\n    3\\nat this step, there is already an error, and I really wonder where is the mistake?\\n"
                    },
                    {
                        "username": "Sashi_sharma",
                        "content": "This code shows Runtime Error.\\nCan anyone help!!!!!\\n\\n int preindex=0;\\n    TreeNode* Ctree(vector<int> &preorder, vector<int> &inorder,int is,int ie){\\n        if(is>ie)   return NULL;\\n        TreeNode* root=new TreeNode(preorder[preindex++]);\\n        int inIndex;\\n        for(int i=is;i<=ie;i++){\\n            if(inorder[i]==root->val){\\n                inIndex=i;\\n                break;\\n            }\\n        }\\n        root->left=Ctree(preorder,inorder,is,inIndex-1);\\n        root->right=Ctree(preorder,inorder,inIndex,ie);\\n        return root;\\n    }\\n    TreeNode* buildTree(vector<int>& preorder, vector<int>& inorder) {\\n        int n=inorder.size();\\n        int is=0;\\n        int ie=n-1;\\n        return Ctree(preorder,inorder,is,ie);\\n    }"
                    },
                    {
                        "username": "SeaShanty",
                        "content": "PLS HELP. why is my code giving an indexoutofbounds Exception for  `TreeNode root= new TreeNode(preorder[preIndex++]);`\\n\\n\\nalso, here is my complete code\\n\\n``` \\nclass Solution {\\n    int preIndex=0;\\n    int inIndex=0;\\n    public TreeNode buildTree(int[] preorder, int[] inorder) {\\n        int inorderStart=0;\\n        int inorderEnd=inorder.length-1;\\n        return solve(preorder, inorder, inorderStart, inorderEnd);\\n    }\\n    public TreeNode solve(int[] preorder, int[] inorder, int inorderStart, int inorderEnd)\\n    {\\n        //FIRST ,  BASE CONDITION\\n        if(inorderStart>inorderEnd)\\n        {\\n            return null;\\n        }\\n        \\n\\n            //int node=;\\n            //create a node/root now\\n            TreeNode root= new TreeNode(preorder[preIndex++]);\\n\\n            //locate this root value in the inorder array\\n         inIndex=inorderStart;        // saw this in gfg code\\n         for(int i=inorderStart; i<inorder.length; i++)\\n         {\\n             if(inorder[i] == root.val)\\n             {\\n                 inIndex=i;\\n                 break;\\n             }\\n         }\\n\\n         root.left=solve(preorder, inorder, inorderStart, inIndex-1);\\n         root.right=solve(preorder, inorder, inIndex+1, inorderEnd);\\n\\n         return root;\\n    }\\n}\\n\\n```"
                    },
                    {
                        "username": "catchups",
                        "content": "will there be [2, 2, 2, 2, 2] and [2, 2, 2, 2, 2] case?"
                    },
                    {
                        "username": "catchups",
                        "content": "why there is test case like 202? "
                    },
                    {
                        "username": "lakshya05",
                        "content": "Is everyone getting a TLE at the last test case?\\nMy solution worked for 202 test cases and I couldn\\'t find the error. \\nI also compared with one of the published solutions and the logic looked sound.\\nDoesn\\'t work even upon using any of the published codes."
                    }
                ]
            },
            {
                "id": 1963089,
                "content": [
                    {
                        "username": "sjames8888",
                        "content": "pretty print Java and a few hints\\n\\nhere is a few hints on what I did - I have not looked at other solutions but this is just a few lines of code and runs in 97% of so performance rankings.  It took me a lot of thinking about and head scratching.\\n\\n1. a lookup map on both arrays is useful i.e. node value to position in array.\\n2. recursion is a natural choice where if we have a construct function taking above maps the root value for the given sub tree, the preorder array and bounds of the sub tree (initially 0 and preorder.length - 1.  left is a call to this recursive function on left bound tree to left of the root and right similar.\\n3. if (start >= end) we have no subtree so create return a node with that value at current root and return left, right are null in this case.\\n4. get 2 indices lookup the above maps we will call them inOrderIndex and preOrderIndex.\\n5. looking at the preorder array our left root in next recursive call is always next in preorder list i.e. we call outr recursive function with preorder[preOrderIndex + 1]\\n6. on right the root is preorder[preOrderIndex + nodesOnLeft + 1]\\n7. nodesOnLeft = inOrderIndex - start;\\n8. nodesOnRight = end - inOrderIndex;\\n9. on left recurive call start, end are inOrderIndex - nodesOnLeft, inOrderIndex - 1\\n10 on right recursive call inOrderIndex + 1, inOrderIndex + nodesOnRight)\\n\\n\\n\\nI wrote this to visualise the tree which you may find handy - this is a rush job so I am sure someone can do better, feel free to improve and repost.\\n\\n                3\\n            /       \\\\\\n           9        20\\n                   /   \\\\\\n                 15     7\\n                 / \\\\   / \\\\\\n               21  14 8   5\\n\\n ` @Test\\n    void case3() {\\n        final var root = new ConstructBinaryTreePreorderInorderTraversal().buildTree(new int[]{3,9,20,15,21,14,7,8,5}, new int[]{9,3,21,15,14,20,8,7,5});\\n        final var arr = root.toArray();\\n        System.out.println(root.prettyPrint());\\n    }`\\n\\n\\n  `\\n  /*\\n  place on TreeNode class\\n\\n\\n*/\\n\\n\\n   private int depth(TreeNode root, int level) {\\n        if (root == null) {\\n            return level;\\n        }\\n\\n        return Math.max(depth(root.left, level + 1), depth(root.right, level + 1));\\n    }\\n    \\n    public String prettyPrint() {\\n        return printToGrid(this);\\n    }\\n\\n    public String printToGrid(TreeNode root) {\\n        if (root == null) {\\n            return \"\";\\n        }\\n        final var depth = depth(this, 0);\\n        final var n = 2 * depth * depth;\\n        final var ca = new char[n][n];\\n        final var whiteLine = \" \".repeat(n);\\n        for (var i = 0; i < n; ++i) {\\n            ca[i] = whiteLine.toCharArray();\\n        }\\n        printToGrid(ca, root, 0, ca[0].length / 2);\\n        var sb = new StringBuilder();\\n        for (var r : ca) {\\n            final var s = new String(r).stripTrailing();\\n            if (s.equals(\"\")) {\\n                break;\\n            }\\n            sb.append(s).append(\"\\\\n\");\\n        }\\n        return sb.toString();\\n    }\\n\\n    public void printToGrid( char[][] grid, TreeNode root, int row, int col) {\\n        if (root == null) {\\n            return;\\n        }\\n        final var depth = depth(root,0);\\n        final var v = root.val;\\n        final var s = Integer.toString(v);\\n        var writeCol = col - s.length() / 2;\\n        while (writeCol < grid.length - s.length() && grid[row][writeCol] != \\' \\'\\n                || grid[row][writeCol - 1] != \\' \\') {\\n            ++writeCol;\\n        }\\n        for (var i = 0; i < s.length(); ++i) {\\n            grid[row][writeCol + i] = s.charAt(i);\\n        }\\n        final var spacing = Math.max(2, depth - (row/2) + 1);\\n        if (root.left != null) {\\n            grid[row + 1][col - spacing + 1] = \\'/\\';\\n            printToGrid(grid, root.left, row + 2, col - spacing);\\n        }\\n        if (root.right != null) {\\n            grid[row + 1][col + spacing - 1] = \\'\\\\\\\\\\';\\n            printToGrid(grid, root.right, row + 2, col + spacing);\\n        }\\n    }\\n`"
                    },
                    {
                        "username": "shaamray",
                        "content": "Can anyone clarify why Output: [3,9,20,null,null,15,7] has two null values :\\') ?"
                    },
                    {
                        "username": "sjames8888",
                        "content": "looks as below\n\n```txt\n           3\n        /       \\\n       9        20\n               /   \\\n             15     7\n```\n\n```java\n @Test\n    void case8() {\n        final var root = TreeNode.from(new Integer[]{3,9,20,null,null,15,7});\n        System.out.println(root.prettyPrint());\n    }\n```"
                    },
                    {
                        "username": "codepiyush1",
                        "content": "# Intuition\\nC++ DFS. Easy Recursive, Proper time and space complexity\\n\\n# Approach\\n\\n1. Define a function `makeTree` that takes the following parameters:\\n   - `preorder`: The preorder traversal of the tree.\\n   - `pL`: The lower index of the current range of the preorder traversal.\\n   - `pH`: The upper index of the current range of the preorder traversal.\\n   - `inorder`: The inorder traversal of the tree.\\n   - `iL`: The lower index of the current range of the inorder traversal.\\n   - `iH`: The upper index of the current range of the inorder traversal.\\n   - `mp`: An unordered map to store the mapping of values to their indices in the inorder traversal.\\n\\n2. Check if the range of indices is invalid, i.e., `pL` is greater than `pH` or `iL` is greater than `iH`. If so, return `NULL` indicating an empty subtree.\\n\\n3. Create a new `TreeNode` with the value at index `pL` in the preorder traversal as its value.\\n\\n4. Get the current index (`currInd`) of the value in the inorder traversal by looking it up in the unordered map `mp`.\\n\\n5. Calculate the number of nodes in the left subtree by subtracting `iL` from `currInd`.\\n\\n6. Recursively call the `makeTree` function to construct the left subtree by passing the following parameters:\\n   - `preorder`: Same as the input.\\n   - `pL+1`: Increment the lower index of the preorder traversal by 1.\\n   - `pL+leftNodes`: Set the upper index of the preorder traversal to `pL+leftNodes`.\\n   - `inorder`: Same as the input.\\n   - `iL`: Same as the input.\\n   - `currInd-1`: Set the upper index of the inorder traversal to `currInd-1`.\\n\\n7. Assign the returned subtree to the `left` pointer of the current node.\\n\\n8. Recursively call the `makeTree` function to construct the right subtree by passing the following parameters:\\n   - `preorder`: Same as the input.\\n   - `pL+leftNodes+1`: Set the lower index of the preorder traversal to `pL+leftNodes+1`.\\n   - `pH`: Same as the input.\\n   - `inorder`: Same as the input.\\n   - `currInd+1`: Set the lower index of the inorder traversal to `currInd+1`.\\n   - `iH`: Same as the input.\\n\\n9. Assign the returned subtree to the `right` pointer of the current node.\\n\\n10. Return the root of the constructed binary tree.\\n\\n11. Define a function `buildTree` that takes the following parameters:\\n    - `preorder`: The preorder traversal of the tree.\\n    - `inorder`: The inorder traversal of the tree.\\n\\n12. Create an unordered map `mp` to store the mapping of values to their indices in the inorder traversal.\\n\\n13. Get the size of the inorder traversal and store it in variable `n`.\\n\\n14. Iterate over the values and indices in the inorder traversal, and populate the unordered map `mp`.\\n\\n15. Call the `makeTree` function with the initial parameters:\\n    - `preorder`: Same as the input.\\n    - `0`: Set the lower index of the preorder traversal to 0.\\n    - `n-1`: Set the upper index of the preorder traversal to `n-1`.\\n    - `inorder`: Same as the input.\\n    - `0`: Set the lower index of the inorder traversal\\n\\n------------------------------------\\n# Complexity\\n- Time complexity:\\nT.C=O(n) in each recursive call one node created.\\n- Space complexity:\\nS.C=O(2n) == O(n) , n for unordered_map and n for recursive stack.\\n---------------------------------\\nPlease Upvote. If understand the concept.\\nSolution link:\\nhttps://leetcode.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal/solutions/3707300/c-dfs-easy-recursive-proper-time-and-space-complexity/\\n"
                    },
                    {
                        "username": "mochiball",
                        "content": " I struggled a lot with this problem. Felt pretty good about trees until I came to this one. It was my first divide and conquer problem but I think we can learn a lot from this problem. \\n\\nThis problem focuses on divide and conquer + recursion. Very important ! "
                    },
                    {
                        "username": "dmitriysin",
                        "content": "Example 1 `[3,9,20,null,null,15,7]` is not a binary tree since:\n1) 3 is less than 9\n2) 7 is less than 9"
                    },
                    {
                        "username": "mochiball",
                        "content": "Question is binary tree, NOT binary search tree "
                    },
                    {
                        "username": "meteahmetyakar",
                        "content": "if every node have 2 child we calls it binary tree, I think you mixed with binary search tree. In binary trees there is no value relation between nodes."
                    },
                    {
                        "username": "adgjl30102005",
                        "content": "Please help, I use the code in Editorial with this test case: pre= [4,1,3,6,8]; inorder = [6,1,8,4,3]\\nand it doesn\\'t work.\\nThe tree should look like this:\\n           4\\n        /     \\\\\\n       1       3\\n      /\\\\\\n    6    8\\nHand Calculating:\\npreorder = [4, 1, 3, 6, 8]\\nHashmap: {6:0 ; 1:1 ; 8:2 ; 4:3 ; 3:4 }\\npreorderindex = 0\\nloop 1:\\nleft = 0 right = 3\\npreorderindex = 0 => root value = 4 => new right = 2\\ntree : 4\\nloop 2:\\nleft = 0 right = 2\\npreorderindex = 1 => root value = 1 => new right = 0\\ntree: 4\\n      1\\nloop 3: \\nleft =0 right = 0\\npreorderindex = 2 => root value = 3 => new right = 3\\ntree: 4\\n      1\\n    3\\nat this step, there is already an error, and I really wonder where is the mistake?\\n"
                    },
                    {
                        "username": "Sashi_sharma",
                        "content": "This code shows Runtime Error.\\nCan anyone help!!!!!\\n\\n int preindex=0;\\n    TreeNode* Ctree(vector<int> &preorder, vector<int> &inorder,int is,int ie){\\n        if(is>ie)   return NULL;\\n        TreeNode* root=new TreeNode(preorder[preindex++]);\\n        int inIndex;\\n        for(int i=is;i<=ie;i++){\\n            if(inorder[i]==root->val){\\n                inIndex=i;\\n                break;\\n            }\\n        }\\n        root->left=Ctree(preorder,inorder,is,inIndex-1);\\n        root->right=Ctree(preorder,inorder,inIndex,ie);\\n        return root;\\n    }\\n    TreeNode* buildTree(vector<int>& preorder, vector<int>& inorder) {\\n        int n=inorder.size();\\n        int is=0;\\n        int ie=n-1;\\n        return Ctree(preorder,inorder,is,ie);\\n    }"
                    },
                    {
                        "username": "SeaShanty",
                        "content": "PLS HELP. why is my code giving an indexoutofbounds Exception for  `TreeNode root= new TreeNode(preorder[preIndex++]);`\\n\\n\\nalso, here is my complete code\\n\\n``` \\nclass Solution {\\n    int preIndex=0;\\n    int inIndex=0;\\n    public TreeNode buildTree(int[] preorder, int[] inorder) {\\n        int inorderStart=0;\\n        int inorderEnd=inorder.length-1;\\n        return solve(preorder, inorder, inorderStart, inorderEnd);\\n    }\\n    public TreeNode solve(int[] preorder, int[] inorder, int inorderStart, int inorderEnd)\\n    {\\n        //FIRST ,  BASE CONDITION\\n        if(inorderStart>inorderEnd)\\n        {\\n            return null;\\n        }\\n        \\n\\n            //int node=;\\n            //create a node/root now\\n            TreeNode root= new TreeNode(preorder[preIndex++]);\\n\\n            //locate this root value in the inorder array\\n         inIndex=inorderStart;        // saw this in gfg code\\n         for(int i=inorderStart; i<inorder.length; i++)\\n         {\\n             if(inorder[i] == root.val)\\n             {\\n                 inIndex=i;\\n                 break;\\n             }\\n         }\\n\\n         root.left=solve(preorder, inorder, inorderStart, inIndex-1);\\n         root.right=solve(preorder, inorder, inIndex+1, inorderEnd);\\n\\n         return root;\\n    }\\n}\\n\\n```"
                    },
                    {
                        "username": "catchups",
                        "content": "will there be [2, 2, 2, 2, 2] and [2, 2, 2, 2, 2] case?"
                    },
                    {
                        "username": "catchups",
                        "content": "why there is test case like 202? "
                    },
                    {
                        "username": "lakshya05",
                        "content": "Is everyone getting a TLE at the last test case?\\nMy solution worked for 202 test cases and I couldn\\'t find the error. \\nI also compared with one of the published solutions and the logic looked sound.\\nDoesn\\'t work even upon using any of the published codes."
                    }
                ]
            },
            {
                "id": 1952936,
                "content": [
                    {
                        "username": "sjames8888",
                        "content": "pretty print Java and a few hints\\n\\nhere is a few hints on what I did - I have not looked at other solutions but this is just a few lines of code and runs in 97% of so performance rankings.  It took me a lot of thinking about and head scratching.\\n\\n1. a lookup map on both arrays is useful i.e. node value to position in array.\\n2. recursion is a natural choice where if we have a construct function taking above maps the root value for the given sub tree, the preorder array and bounds of the sub tree (initially 0 and preorder.length - 1.  left is a call to this recursive function on left bound tree to left of the root and right similar.\\n3. if (start >= end) we have no subtree so create return a node with that value at current root and return left, right are null in this case.\\n4. get 2 indices lookup the above maps we will call them inOrderIndex and preOrderIndex.\\n5. looking at the preorder array our left root in next recursive call is always next in preorder list i.e. we call outr recursive function with preorder[preOrderIndex + 1]\\n6. on right the root is preorder[preOrderIndex + nodesOnLeft + 1]\\n7. nodesOnLeft = inOrderIndex - start;\\n8. nodesOnRight = end - inOrderIndex;\\n9. on left recurive call start, end are inOrderIndex - nodesOnLeft, inOrderIndex - 1\\n10 on right recursive call inOrderIndex + 1, inOrderIndex + nodesOnRight)\\n\\n\\n\\nI wrote this to visualise the tree which you may find handy - this is a rush job so I am sure someone can do better, feel free to improve and repost.\\n\\n                3\\n            /       \\\\\\n           9        20\\n                   /   \\\\\\n                 15     7\\n                 / \\\\   / \\\\\\n               21  14 8   5\\n\\n ` @Test\\n    void case3() {\\n        final var root = new ConstructBinaryTreePreorderInorderTraversal().buildTree(new int[]{3,9,20,15,21,14,7,8,5}, new int[]{9,3,21,15,14,20,8,7,5});\\n        final var arr = root.toArray();\\n        System.out.println(root.prettyPrint());\\n    }`\\n\\n\\n  `\\n  /*\\n  place on TreeNode class\\n\\n\\n*/\\n\\n\\n   private int depth(TreeNode root, int level) {\\n        if (root == null) {\\n            return level;\\n        }\\n\\n        return Math.max(depth(root.left, level + 1), depth(root.right, level + 1));\\n    }\\n    \\n    public String prettyPrint() {\\n        return printToGrid(this);\\n    }\\n\\n    public String printToGrid(TreeNode root) {\\n        if (root == null) {\\n            return \"\";\\n        }\\n        final var depth = depth(this, 0);\\n        final var n = 2 * depth * depth;\\n        final var ca = new char[n][n];\\n        final var whiteLine = \" \".repeat(n);\\n        for (var i = 0; i < n; ++i) {\\n            ca[i] = whiteLine.toCharArray();\\n        }\\n        printToGrid(ca, root, 0, ca[0].length / 2);\\n        var sb = new StringBuilder();\\n        for (var r : ca) {\\n            final var s = new String(r).stripTrailing();\\n            if (s.equals(\"\")) {\\n                break;\\n            }\\n            sb.append(s).append(\"\\\\n\");\\n        }\\n        return sb.toString();\\n    }\\n\\n    public void printToGrid( char[][] grid, TreeNode root, int row, int col) {\\n        if (root == null) {\\n            return;\\n        }\\n        final var depth = depth(root,0);\\n        final var v = root.val;\\n        final var s = Integer.toString(v);\\n        var writeCol = col - s.length() / 2;\\n        while (writeCol < grid.length - s.length() && grid[row][writeCol] != \\' \\'\\n                || grid[row][writeCol - 1] != \\' \\') {\\n            ++writeCol;\\n        }\\n        for (var i = 0; i < s.length(); ++i) {\\n            grid[row][writeCol + i] = s.charAt(i);\\n        }\\n        final var spacing = Math.max(2, depth - (row/2) + 1);\\n        if (root.left != null) {\\n            grid[row + 1][col - spacing + 1] = \\'/\\';\\n            printToGrid(grid, root.left, row + 2, col - spacing);\\n        }\\n        if (root.right != null) {\\n            grid[row + 1][col + spacing - 1] = \\'\\\\\\\\\\';\\n            printToGrid(grid, root.right, row + 2, col + spacing);\\n        }\\n    }\\n`"
                    },
                    {
                        "username": "shaamray",
                        "content": "Can anyone clarify why Output: [3,9,20,null,null,15,7] has two null values :\\') ?"
                    },
                    {
                        "username": "sjames8888",
                        "content": "looks as below\n\n```txt\n           3\n        /       \\\n       9        20\n               /   \\\n             15     7\n```\n\n```java\n @Test\n    void case8() {\n        final var root = TreeNode.from(new Integer[]{3,9,20,null,null,15,7});\n        System.out.println(root.prettyPrint());\n    }\n```"
                    },
                    {
                        "username": "codepiyush1",
                        "content": "# Intuition\\nC++ DFS. Easy Recursive, Proper time and space complexity\\n\\n# Approach\\n\\n1. Define a function `makeTree` that takes the following parameters:\\n   - `preorder`: The preorder traversal of the tree.\\n   - `pL`: The lower index of the current range of the preorder traversal.\\n   - `pH`: The upper index of the current range of the preorder traversal.\\n   - `inorder`: The inorder traversal of the tree.\\n   - `iL`: The lower index of the current range of the inorder traversal.\\n   - `iH`: The upper index of the current range of the inorder traversal.\\n   - `mp`: An unordered map to store the mapping of values to their indices in the inorder traversal.\\n\\n2. Check if the range of indices is invalid, i.e., `pL` is greater than `pH` or `iL` is greater than `iH`. If so, return `NULL` indicating an empty subtree.\\n\\n3. Create a new `TreeNode` with the value at index `pL` in the preorder traversal as its value.\\n\\n4. Get the current index (`currInd`) of the value in the inorder traversal by looking it up in the unordered map `mp`.\\n\\n5. Calculate the number of nodes in the left subtree by subtracting `iL` from `currInd`.\\n\\n6. Recursively call the `makeTree` function to construct the left subtree by passing the following parameters:\\n   - `preorder`: Same as the input.\\n   - `pL+1`: Increment the lower index of the preorder traversal by 1.\\n   - `pL+leftNodes`: Set the upper index of the preorder traversal to `pL+leftNodes`.\\n   - `inorder`: Same as the input.\\n   - `iL`: Same as the input.\\n   - `currInd-1`: Set the upper index of the inorder traversal to `currInd-1`.\\n\\n7. Assign the returned subtree to the `left` pointer of the current node.\\n\\n8. Recursively call the `makeTree` function to construct the right subtree by passing the following parameters:\\n   - `preorder`: Same as the input.\\n   - `pL+leftNodes+1`: Set the lower index of the preorder traversal to `pL+leftNodes+1`.\\n   - `pH`: Same as the input.\\n   - `inorder`: Same as the input.\\n   - `currInd+1`: Set the lower index of the inorder traversal to `currInd+1`.\\n   - `iH`: Same as the input.\\n\\n9. Assign the returned subtree to the `right` pointer of the current node.\\n\\n10. Return the root of the constructed binary tree.\\n\\n11. Define a function `buildTree` that takes the following parameters:\\n    - `preorder`: The preorder traversal of the tree.\\n    - `inorder`: The inorder traversal of the tree.\\n\\n12. Create an unordered map `mp` to store the mapping of values to their indices in the inorder traversal.\\n\\n13. Get the size of the inorder traversal and store it in variable `n`.\\n\\n14. Iterate over the values and indices in the inorder traversal, and populate the unordered map `mp`.\\n\\n15. Call the `makeTree` function with the initial parameters:\\n    - `preorder`: Same as the input.\\n    - `0`: Set the lower index of the preorder traversal to 0.\\n    - `n-1`: Set the upper index of the preorder traversal to `n-1`.\\n    - `inorder`: Same as the input.\\n    - `0`: Set the lower index of the inorder traversal\\n\\n------------------------------------\\n# Complexity\\n- Time complexity:\\nT.C=O(n) in each recursive call one node created.\\n- Space complexity:\\nS.C=O(2n) == O(n) , n for unordered_map and n for recursive stack.\\n---------------------------------\\nPlease Upvote. If understand the concept.\\nSolution link:\\nhttps://leetcode.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal/solutions/3707300/c-dfs-easy-recursive-proper-time-and-space-complexity/\\n"
                    },
                    {
                        "username": "mochiball",
                        "content": " I struggled a lot with this problem. Felt pretty good about trees until I came to this one. It was my first divide and conquer problem but I think we can learn a lot from this problem. \\n\\nThis problem focuses on divide and conquer + recursion. Very important ! "
                    },
                    {
                        "username": "dmitriysin",
                        "content": "Example 1 `[3,9,20,null,null,15,7]` is not a binary tree since:\n1) 3 is less than 9\n2) 7 is less than 9"
                    },
                    {
                        "username": "mochiball",
                        "content": "Question is binary tree, NOT binary search tree "
                    },
                    {
                        "username": "meteahmetyakar",
                        "content": "if every node have 2 child we calls it binary tree, I think you mixed with binary search tree. In binary trees there is no value relation between nodes."
                    },
                    {
                        "username": "adgjl30102005",
                        "content": "Please help, I use the code in Editorial with this test case: pre= [4,1,3,6,8]; inorder = [6,1,8,4,3]\\nand it doesn\\'t work.\\nThe tree should look like this:\\n           4\\n        /     \\\\\\n       1       3\\n      /\\\\\\n    6    8\\nHand Calculating:\\npreorder = [4, 1, 3, 6, 8]\\nHashmap: {6:0 ; 1:1 ; 8:2 ; 4:3 ; 3:4 }\\npreorderindex = 0\\nloop 1:\\nleft = 0 right = 3\\npreorderindex = 0 => root value = 4 => new right = 2\\ntree : 4\\nloop 2:\\nleft = 0 right = 2\\npreorderindex = 1 => root value = 1 => new right = 0\\ntree: 4\\n      1\\nloop 3: \\nleft =0 right = 0\\npreorderindex = 2 => root value = 3 => new right = 3\\ntree: 4\\n      1\\n    3\\nat this step, there is already an error, and I really wonder where is the mistake?\\n"
                    },
                    {
                        "username": "Sashi_sharma",
                        "content": "This code shows Runtime Error.\\nCan anyone help!!!!!\\n\\n int preindex=0;\\n    TreeNode* Ctree(vector<int> &preorder, vector<int> &inorder,int is,int ie){\\n        if(is>ie)   return NULL;\\n        TreeNode* root=new TreeNode(preorder[preindex++]);\\n        int inIndex;\\n        for(int i=is;i<=ie;i++){\\n            if(inorder[i]==root->val){\\n                inIndex=i;\\n                break;\\n            }\\n        }\\n        root->left=Ctree(preorder,inorder,is,inIndex-1);\\n        root->right=Ctree(preorder,inorder,inIndex,ie);\\n        return root;\\n    }\\n    TreeNode* buildTree(vector<int>& preorder, vector<int>& inorder) {\\n        int n=inorder.size();\\n        int is=0;\\n        int ie=n-1;\\n        return Ctree(preorder,inorder,is,ie);\\n    }"
                    },
                    {
                        "username": "SeaShanty",
                        "content": "PLS HELP. why is my code giving an indexoutofbounds Exception for  `TreeNode root= new TreeNode(preorder[preIndex++]);`\\n\\n\\nalso, here is my complete code\\n\\n``` \\nclass Solution {\\n    int preIndex=0;\\n    int inIndex=0;\\n    public TreeNode buildTree(int[] preorder, int[] inorder) {\\n        int inorderStart=0;\\n        int inorderEnd=inorder.length-1;\\n        return solve(preorder, inorder, inorderStart, inorderEnd);\\n    }\\n    public TreeNode solve(int[] preorder, int[] inorder, int inorderStart, int inorderEnd)\\n    {\\n        //FIRST ,  BASE CONDITION\\n        if(inorderStart>inorderEnd)\\n        {\\n            return null;\\n        }\\n        \\n\\n            //int node=;\\n            //create a node/root now\\n            TreeNode root= new TreeNode(preorder[preIndex++]);\\n\\n            //locate this root value in the inorder array\\n         inIndex=inorderStart;        // saw this in gfg code\\n         for(int i=inorderStart; i<inorder.length; i++)\\n         {\\n             if(inorder[i] == root.val)\\n             {\\n                 inIndex=i;\\n                 break;\\n             }\\n         }\\n\\n         root.left=solve(preorder, inorder, inorderStart, inIndex-1);\\n         root.right=solve(preorder, inorder, inIndex+1, inorderEnd);\\n\\n         return root;\\n    }\\n}\\n\\n```"
                    },
                    {
                        "username": "catchups",
                        "content": "will there be [2, 2, 2, 2, 2] and [2, 2, 2, 2, 2] case?"
                    },
                    {
                        "username": "catchups",
                        "content": "why there is test case like 202? "
                    },
                    {
                        "username": "lakshya05",
                        "content": "Is everyone getting a TLE at the last test case?\\nMy solution worked for 202 test cases and I couldn\\'t find the error. \\nI also compared with one of the published solutions and the logic looked sound.\\nDoesn\\'t work even upon using any of the published codes."
                    }
                ]
            },
            {
                "id": 1936205,
                "content": [
                    {
                        "username": "sjames8888",
                        "content": "pretty print Java and a few hints\\n\\nhere is a few hints on what I did - I have not looked at other solutions but this is just a few lines of code and runs in 97% of so performance rankings.  It took me a lot of thinking about and head scratching.\\n\\n1. a lookup map on both arrays is useful i.e. node value to position in array.\\n2. recursion is a natural choice where if we have a construct function taking above maps the root value for the given sub tree, the preorder array and bounds of the sub tree (initially 0 and preorder.length - 1.  left is a call to this recursive function on left bound tree to left of the root and right similar.\\n3. if (start >= end) we have no subtree so create return a node with that value at current root and return left, right are null in this case.\\n4. get 2 indices lookup the above maps we will call them inOrderIndex and preOrderIndex.\\n5. looking at the preorder array our left root in next recursive call is always next in preorder list i.e. we call outr recursive function with preorder[preOrderIndex + 1]\\n6. on right the root is preorder[preOrderIndex + nodesOnLeft + 1]\\n7. nodesOnLeft = inOrderIndex - start;\\n8. nodesOnRight = end - inOrderIndex;\\n9. on left recurive call start, end are inOrderIndex - nodesOnLeft, inOrderIndex - 1\\n10 on right recursive call inOrderIndex + 1, inOrderIndex + nodesOnRight)\\n\\n\\n\\nI wrote this to visualise the tree which you may find handy - this is a rush job so I am sure someone can do better, feel free to improve and repost.\\n\\n                3\\n            /       \\\\\\n           9        20\\n                   /   \\\\\\n                 15     7\\n                 / \\\\   / \\\\\\n               21  14 8   5\\n\\n ` @Test\\n    void case3() {\\n        final var root = new ConstructBinaryTreePreorderInorderTraversal().buildTree(new int[]{3,9,20,15,21,14,7,8,5}, new int[]{9,3,21,15,14,20,8,7,5});\\n        final var arr = root.toArray();\\n        System.out.println(root.prettyPrint());\\n    }`\\n\\n\\n  `\\n  /*\\n  place on TreeNode class\\n\\n\\n*/\\n\\n\\n   private int depth(TreeNode root, int level) {\\n        if (root == null) {\\n            return level;\\n        }\\n\\n        return Math.max(depth(root.left, level + 1), depth(root.right, level + 1));\\n    }\\n    \\n    public String prettyPrint() {\\n        return printToGrid(this);\\n    }\\n\\n    public String printToGrid(TreeNode root) {\\n        if (root == null) {\\n            return \"\";\\n        }\\n        final var depth = depth(this, 0);\\n        final var n = 2 * depth * depth;\\n        final var ca = new char[n][n];\\n        final var whiteLine = \" \".repeat(n);\\n        for (var i = 0; i < n; ++i) {\\n            ca[i] = whiteLine.toCharArray();\\n        }\\n        printToGrid(ca, root, 0, ca[0].length / 2);\\n        var sb = new StringBuilder();\\n        for (var r : ca) {\\n            final var s = new String(r).stripTrailing();\\n            if (s.equals(\"\")) {\\n                break;\\n            }\\n            sb.append(s).append(\"\\\\n\");\\n        }\\n        return sb.toString();\\n    }\\n\\n    public void printToGrid( char[][] grid, TreeNode root, int row, int col) {\\n        if (root == null) {\\n            return;\\n        }\\n        final var depth = depth(root,0);\\n        final var v = root.val;\\n        final var s = Integer.toString(v);\\n        var writeCol = col - s.length() / 2;\\n        while (writeCol < grid.length - s.length() && grid[row][writeCol] != \\' \\'\\n                || grid[row][writeCol - 1] != \\' \\') {\\n            ++writeCol;\\n        }\\n        for (var i = 0; i < s.length(); ++i) {\\n            grid[row][writeCol + i] = s.charAt(i);\\n        }\\n        final var spacing = Math.max(2, depth - (row/2) + 1);\\n        if (root.left != null) {\\n            grid[row + 1][col - spacing + 1] = \\'/\\';\\n            printToGrid(grid, root.left, row + 2, col - spacing);\\n        }\\n        if (root.right != null) {\\n            grid[row + 1][col + spacing - 1] = \\'\\\\\\\\\\';\\n            printToGrid(grid, root.right, row + 2, col + spacing);\\n        }\\n    }\\n`"
                    },
                    {
                        "username": "shaamray",
                        "content": "Can anyone clarify why Output: [3,9,20,null,null,15,7] has two null values :\\') ?"
                    },
                    {
                        "username": "sjames8888",
                        "content": "looks as below\n\n```txt\n           3\n        /       \\\n       9        20\n               /   \\\n             15     7\n```\n\n```java\n @Test\n    void case8() {\n        final var root = TreeNode.from(new Integer[]{3,9,20,null,null,15,7});\n        System.out.println(root.prettyPrint());\n    }\n```"
                    },
                    {
                        "username": "codepiyush1",
                        "content": "# Intuition\\nC++ DFS. Easy Recursive, Proper time and space complexity\\n\\n# Approach\\n\\n1. Define a function `makeTree` that takes the following parameters:\\n   - `preorder`: The preorder traversal of the tree.\\n   - `pL`: The lower index of the current range of the preorder traversal.\\n   - `pH`: The upper index of the current range of the preorder traversal.\\n   - `inorder`: The inorder traversal of the tree.\\n   - `iL`: The lower index of the current range of the inorder traversal.\\n   - `iH`: The upper index of the current range of the inorder traversal.\\n   - `mp`: An unordered map to store the mapping of values to their indices in the inorder traversal.\\n\\n2. Check if the range of indices is invalid, i.e., `pL` is greater than `pH` or `iL` is greater than `iH`. If so, return `NULL` indicating an empty subtree.\\n\\n3. Create a new `TreeNode` with the value at index `pL` in the preorder traversal as its value.\\n\\n4. Get the current index (`currInd`) of the value in the inorder traversal by looking it up in the unordered map `mp`.\\n\\n5. Calculate the number of nodes in the left subtree by subtracting `iL` from `currInd`.\\n\\n6. Recursively call the `makeTree` function to construct the left subtree by passing the following parameters:\\n   - `preorder`: Same as the input.\\n   - `pL+1`: Increment the lower index of the preorder traversal by 1.\\n   - `pL+leftNodes`: Set the upper index of the preorder traversal to `pL+leftNodes`.\\n   - `inorder`: Same as the input.\\n   - `iL`: Same as the input.\\n   - `currInd-1`: Set the upper index of the inorder traversal to `currInd-1`.\\n\\n7. Assign the returned subtree to the `left` pointer of the current node.\\n\\n8. Recursively call the `makeTree` function to construct the right subtree by passing the following parameters:\\n   - `preorder`: Same as the input.\\n   - `pL+leftNodes+1`: Set the lower index of the preorder traversal to `pL+leftNodes+1`.\\n   - `pH`: Same as the input.\\n   - `inorder`: Same as the input.\\n   - `currInd+1`: Set the lower index of the inorder traversal to `currInd+1`.\\n   - `iH`: Same as the input.\\n\\n9. Assign the returned subtree to the `right` pointer of the current node.\\n\\n10. Return the root of the constructed binary tree.\\n\\n11. Define a function `buildTree` that takes the following parameters:\\n    - `preorder`: The preorder traversal of the tree.\\n    - `inorder`: The inorder traversal of the tree.\\n\\n12. Create an unordered map `mp` to store the mapping of values to their indices in the inorder traversal.\\n\\n13. Get the size of the inorder traversal and store it in variable `n`.\\n\\n14. Iterate over the values and indices in the inorder traversal, and populate the unordered map `mp`.\\n\\n15. Call the `makeTree` function with the initial parameters:\\n    - `preorder`: Same as the input.\\n    - `0`: Set the lower index of the preorder traversal to 0.\\n    - `n-1`: Set the upper index of the preorder traversal to `n-1`.\\n    - `inorder`: Same as the input.\\n    - `0`: Set the lower index of the inorder traversal\\n\\n------------------------------------\\n# Complexity\\n- Time complexity:\\nT.C=O(n) in each recursive call one node created.\\n- Space complexity:\\nS.C=O(2n) == O(n) , n for unordered_map and n for recursive stack.\\n---------------------------------\\nPlease Upvote. If understand the concept.\\nSolution link:\\nhttps://leetcode.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal/solutions/3707300/c-dfs-easy-recursive-proper-time-and-space-complexity/\\n"
                    },
                    {
                        "username": "mochiball",
                        "content": " I struggled a lot with this problem. Felt pretty good about trees until I came to this one. It was my first divide and conquer problem but I think we can learn a lot from this problem. \\n\\nThis problem focuses on divide and conquer + recursion. Very important ! "
                    },
                    {
                        "username": "dmitriysin",
                        "content": "Example 1 `[3,9,20,null,null,15,7]` is not a binary tree since:\n1) 3 is less than 9\n2) 7 is less than 9"
                    },
                    {
                        "username": "mochiball",
                        "content": "Question is binary tree, NOT binary search tree "
                    },
                    {
                        "username": "meteahmetyakar",
                        "content": "if every node have 2 child we calls it binary tree, I think you mixed with binary search tree. In binary trees there is no value relation between nodes."
                    },
                    {
                        "username": "adgjl30102005",
                        "content": "Please help, I use the code in Editorial with this test case: pre= [4,1,3,6,8]; inorder = [6,1,8,4,3]\\nand it doesn\\'t work.\\nThe tree should look like this:\\n           4\\n        /     \\\\\\n       1       3\\n      /\\\\\\n    6    8\\nHand Calculating:\\npreorder = [4, 1, 3, 6, 8]\\nHashmap: {6:0 ; 1:1 ; 8:2 ; 4:3 ; 3:4 }\\npreorderindex = 0\\nloop 1:\\nleft = 0 right = 3\\npreorderindex = 0 => root value = 4 => new right = 2\\ntree : 4\\nloop 2:\\nleft = 0 right = 2\\npreorderindex = 1 => root value = 1 => new right = 0\\ntree: 4\\n      1\\nloop 3: \\nleft =0 right = 0\\npreorderindex = 2 => root value = 3 => new right = 3\\ntree: 4\\n      1\\n    3\\nat this step, there is already an error, and I really wonder where is the mistake?\\n"
                    },
                    {
                        "username": "Sashi_sharma",
                        "content": "This code shows Runtime Error.\\nCan anyone help!!!!!\\n\\n int preindex=0;\\n    TreeNode* Ctree(vector<int> &preorder, vector<int> &inorder,int is,int ie){\\n        if(is>ie)   return NULL;\\n        TreeNode* root=new TreeNode(preorder[preindex++]);\\n        int inIndex;\\n        for(int i=is;i<=ie;i++){\\n            if(inorder[i]==root->val){\\n                inIndex=i;\\n                break;\\n            }\\n        }\\n        root->left=Ctree(preorder,inorder,is,inIndex-1);\\n        root->right=Ctree(preorder,inorder,inIndex,ie);\\n        return root;\\n    }\\n    TreeNode* buildTree(vector<int>& preorder, vector<int>& inorder) {\\n        int n=inorder.size();\\n        int is=0;\\n        int ie=n-1;\\n        return Ctree(preorder,inorder,is,ie);\\n    }"
                    },
                    {
                        "username": "SeaShanty",
                        "content": "PLS HELP. why is my code giving an indexoutofbounds Exception for  `TreeNode root= new TreeNode(preorder[preIndex++]);`\\n\\n\\nalso, here is my complete code\\n\\n``` \\nclass Solution {\\n    int preIndex=0;\\n    int inIndex=0;\\n    public TreeNode buildTree(int[] preorder, int[] inorder) {\\n        int inorderStart=0;\\n        int inorderEnd=inorder.length-1;\\n        return solve(preorder, inorder, inorderStart, inorderEnd);\\n    }\\n    public TreeNode solve(int[] preorder, int[] inorder, int inorderStart, int inorderEnd)\\n    {\\n        //FIRST ,  BASE CONDITION\\n        if(inorderStart>inorderEnd)\\n        {\\n            return null;\\n        }\\n        \\n\\n            //int node=;\\n            //create a node/root now\\n            TreeNode root= new TreeNode(preorder[preIndex++]);\\n\\n            //locate this root value in the inorder array\\n         inIndex=inorderStart;        // saw this in gfg code\\n         for(int i=inorderStart; i<inorder.length; i++)\\n         {\\n             if(inorder[i] == root.val)\\n             {\\n                 inIndex=i;\\n                 break;\\n             }\\n         }\\n\\n         root.left=solve(preorder, inorder, inorderStart, inIndex-1);\\n         root.right=solve(preorder, inorder, inIndex+1, inorderEnd);\\n\\n         return root;\\n    }\\n}\\n\\n```"
                    },
                    {
                        "username": "catchups",
                        "content": "will there be [2, 2, 2, 2, 2] and [2, 2, 2, 2, 2] case?"
                    },
                    {
                        "username": "catchups",
                        "content": "why there is test case like 202? "
                    },
                    {
                        "username": "lakshya05",
                        "content": "Is everyone getting a TLE at the last test case?\\nMy solution worked for 202 test cases and I couldn\\'t find the error. \\nI also compared with one of the published solutions and the logic looked sound.\\nDoesn\\'t work even upon using any of the published codes."
                    }
                ]
            },
            {
                "id": 1894470,
                "content": [
                    {
                        "username": "sjames8888",
                        "content": "pretty print Java and a few hints\\n\\nhere is a few hints on what I did - I have not looked at other solutions but this is just a few lines of code and runs in 97% of so performance rankings.  It took me a lot of thinking about and head scratching.\\n\\n1. a lookup map on both arrays is useful i.e. node value to position in array.\\n2. recursion is a natural choice where if we have a construct function taking above maps the root value for the given sub tree, the preorder array and bounds of the sub tree (initially 0 and preorder.length - 1.  left is a call to this recursive function on left bound tree to left of the root and right similar.\\n3. if (start >= end) we have no subtree so create return a node with that value at current root and return left, right are null in this case.\\n4. get 2 indices lookup the above maps we will call them inOrderIndex and preOrderIndex.\\n5. looking at the preorder array our left root in next recursive call is always next in preorder list i.e. we call outr recursive function with preorder[preOrderIndex + 1]\\n6. on right the root is preorder[preOrderIndex + nodesOnLeft + 1]\\n7. nodesOnLeft = inOrderIndex - start;\\n8. nodesOnRight = end - inOrderIndex;\\n9. on left recurive call start, end are inOrderIndex - nodesOnLeft, inOrderIndex - 1\\n10 on right recursive call inOrderIndex + 1, inOrderIndex + nodesOnRight)\\n\\n\\n\\nI wrote this to visualise the tree which you may find handy - this is a rush job so I am sure someone can do better, feel free to improve and repost.\\n\\n                3\\n            /       \\\\\\n           9        20\\n                   /   \\\\\\n                 15     7\\n                 / \\\\   / \\\\\\n               21  14 8   5\\n\\n ` @Test\\n    void case3() {\\n        final var root = new ConstructBinaryTreePreorderInorderTraversal().buildTree(new int[]{3,9,20,15,21,14,7,8,5}, new int[]{9,3,21,15,14,20,8,7,5});\\n        final var arr = root.toArray();\\n        System.out.println(root.prettyPrint());\\n    }`\\n\\n\\n  `\\n  /*\\n  place on TreeNode class\\n\\n\\n*/\\n\\n\\n   private int depth(TreeNode root, int level) {\\n        if (root == null) {\\n            return level;\\n        }\\n\\n        return Math.max(depth(root.left, level + 1), depth(root.right, level + 1));\\n    }\\n    \\n    public String prettyPrint() {\\n        return printToGrid(this);\\n    }\\n\\n    public String printToGrid(TreeNode root) {\\n        if (root == null) {\\n            return \"\";\\n        }\\n        final var depth = depth(this, 0);\\n        final var n = 2 * depth * depth;\\n        final var ca = new char[n][n];\\n        final var whiteLine = \" \".repeat(n);\\n        for (var i = 0; i < n; ++i) {\\n            ca[i] = whiteLine.toCharArray();\\n        }\\n        printToGrid(ca, root, 0, ca[0].length / 2);\\n        var sb = new StringBuilder();\\n        for (var r : ca) {\\n            final var s = new String(r).stripTrailing();\\n            if (s.equals(\"\")) {\\n                break;\\n            }\\n            sb.append(s).append(\"\\\\n\");\\n        }\\n        return sb.toString();\\n    }\\n\\n    public void printToGrid( char[][] grid, TreeNode root, int row, int col) {\\n        if (root == null) {\\n            return;\\n        }\\n        final var depth = depth(root,0);\\n        final var v = root.val;\\n        final var s = Integer.toString(v);\\n        var writeCol = col - s.length() / 2;\\n        while (writeCol < grid.length - s.length() && grid[row][writeCol] != \\' \\'\\n                || grid[row][writeCol - 1] != \\' \\') {\\n            ++writeCol;\\n        }\\n        for (var i = 0; i < s.length(); ++i) {\\n            grid[row][writeCol + i] = s.charAt(i);\\n        }\\n        final var spacing = Math.max(2, depth - (row/2) + 1);\\n        if (root.left != null) {\\n            grid[row + 1][col - spacing + 1] = \\'/\\';\\n            printToGrid(grid, root.left, row + 2, col - spacing);\\n        }\\n        if (root.right != null) {\\n            grid[row + 1][col + spacing - 1] = \\'\\\\\\\\\\';\\n            printToGrid(grid, root.right, row + 2, col + spacing);\\n        }\\n    }\\n`"
                    },
                    {
                        "username": "shaamray",
                        "content": "Can anyone clarify why Output: [3,9,20,null,null,15,7] has two null values :\\') ?"
                    },
                    {
                        "username": "sjames8888",
                        "content": "looks as below\n\n```txt\n           3\n        /       \\\n       9        20\n               /   \\\n             15     7\n```\n\n```java\n @Test\n    void case8() {\n        final var root = TreeNode.from(new Integer[]{3,9,20,null,null,15,7});\n        System.out.println(root.prettyPrint());\n    }\n```"
                    },
                    {
                        "username": "codepiyush1",
                        "content": "# Intuition\\nC++ DFS. Easy Recursive, Proper time and space complexity\\n\\n# Approach\\n\\n1. Define a function `makeTree` that takes the following parameters:\\n   - `preorder`: The preorder traversal of the tree.\\n   - `pL`: The lower index of the current range of the preorder traversal.\\n   - `pH`: The upper index of the current range of the preorder traversal.\\n   - `inorder`: The inorder traversal of the tree.\\n   - `iL`: The lower index of the current range of the inorder traversal.\\n   - `iH`: The upper index of the current range of the inorder traversal.\\n   - `mp`: An unordered map to store the mapping of values to their indices in the inorder traversal.\\n\\n2. Check if the range of indices is invalid, i.e., `pL` is greater than `pH` or `iL` is greater than `iH`. If so, return `NULL` indicating an empty subtree.\\n\\n3. Create a new `TreeNode` with the value at index `pL` in the preorder traversal as its value.\\n\\n4. Get the current index (`currInd`) of the value in the inorder traversal by looking it up in the unordered map `mp`.\\n\\n5. Calculate the number of nodes in the left subtree by subtracting `iL` from `currInd`.\\n\\n6. Recursively call the `makeTree` function to construct the left subtree by passing the following parameters:\\n   - `preorder`: Same as the input.\\n   - `pL+1`: Increment the lower index of the preorder traversal by 1.\\n   - `pL+leftNodes`: Set the upper index of the preorder traversal to `pL+leftNodes`.\\n   - `inorder`: Same as the input.\\n   - `iL`: Same as the input.\\n   - `currInd-1`: Set the upper index of the inorder traversal to `currInd-1`.\\n\\n7. Assign the returned subtree to the `left` pointer of the current node.\\n\\n8. Recursively call the `makeTree` function to construct the right subtree by passing the following parameters:\\n   - `preorder`: Same as the input.\\n   - `pL+leftNodes+1`: Set the lower index of the preorder traversal to `pL+leftNodes+1`.\\n   - `pH`: Same as the input.\\n   - `inorder`: Same as the input.\\n   - `currInd+1`: Set the lower index of the inorder traversal to `currInd+1`.\\n   - `iH`: Same as the input.\\n\\n9. Assign the returned subtree to the `right` pointer of the current node.\\n\\n10. Return the root of the constructed binary tree.\\n\\n11. Define a function `buildTree` that takes the following parameters:\\n    - `preorder`: The preorder traversal of the tree.\\n    - `inorder`: The inorder traversal of the tree.\\n\\n12. Create an unordered map `mp` to store the mapping of values to their indices in the inorder traversal.\\n\\n13. Get the size of the inorder traversal and store it in variable `n`.\\n\\n14. Iterate over the values and indices in the inorder traversal, and populate the unordered map `mp`.\\n\\n15. Call the `makeTree` function with the initial parameters:\\n    - `preorder`: Same as the input.\\n    - `0`: Set the lower index of the preorder traversal to 0.\\n    - `n-1`: Set the upper index of the preorder traversal to `n-1`.\\n    - `inorder`: Same as the input.\\n    - `0`: Set the lower index of the inorder traversal\\n\\n------------------------------------\\n# Complexity\\n- Time complexity:\\nT.C=O(n) in each recursive call one node created.\\n- Space complexity:\\nS.C=O(2n) == O(n) , n for unordered_map and n for recursive stack.\\n---------------------------------\\nPlease Upvote. If understand the concept.\\nSolution link:\\nhttps://leetcode.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal/solutions/3707300/c-dfs-easy-recursive-proper-time-and-space-complexity/\\n"
                    },
                    {
                        "username": "mochiball",
                        "content": " I struggled a lot with this problem. Felt pretty good about trees until I came to this one. It was my first divide and conquer problem but I think we can learn a lot from this problem. \\n\\nThis problem focuses on divide and conquer + recursion. Very important ! "
                    },
                    {
                        "username": "dmitriysin",
                        "content": "Example 1 `[3,9,20,null,null,15,7]` is not a binary tree since:\n1) 3 is less than 9\n2) 7 is less than 9"
                    },
                    {
                        "username": "mochiball",
                        "content": "Question is binary tree, NOT binary search tree "
                    },
                    {
                        "username": "meteahmetyakar",
                        "content": "if every node have 2 child we calls it binary tree, I think you mixed with binary search tree. In binary trees there is no value relation between nodes."
                    },
                    {
                        "username": "adgjl30102005",
                        "content": "Please help, I use the code in Editorial with this test case: pre= [4,1,3,6,8]; inorder = [6,1,8,4,3]\\nand it doesn\\'t work.\\nThe tree should look like this:\\n           4\\n        /     \\\\\\n       1       3\\n      /\\\\\\n    6    8\\nHand Calculating:\\npreorder = [4, 1, 3, 6, 8]\\nHashmap: {6:0 ; 1:1 ; 8:2 ; 4:3 ; 3:4 }\\npreorderindex = 0\\nloop 1:\\nleft = 0 right = 3\\npreorderindex = 0 => root value = 4 => new right = 2\\ntree : 4\\nloop 2:\\nleft = 0 right = 2\\npreorderindex = 1 => root value = 1 => new right = 0\\ntree: 4\\n      1\\nloop 3: \\nleft =0 right = 0\\npreorderindex = 2 => root value = 3 => new right = 3\\ntree: 4\\n      1\\n    3\\nat this step, there is already an error, and I really wonder where is the mistake?\\n"
                    },
                    {
                        "username": "Sashi_sharma",
                        "content": "This code shows Runtime Error.\\nCan anyone help!!!!!\\n\\n int preindex=0;\\n    TreeNode* Ctree(vector<int> &preorder, vector<int> &inorder,int is,int ie){\\n        if(is>ie)   return NULL;\\n        TreeNode* root=new TreeNode(preorder[preindex++]);\\n        int inIndex;\\n        for(int i=is;i<=ie;i++){\\n            if(inorder[i]==root->val){\\n                inIndex=i;\\n                break;\\n            }\\n        }\\n        root->left=Ctree(preorder,inorder,is,inIndex-1);\\n        root->right=Ctree(preorder,inorder,inIndex,ie);\\n        return root;\\n    }\\n    TreeNode* buildTree(vector<int>& preorder, vector<int>& inorder) {\\n        int n=inorder.size();\\n        int is=0;\\n        int ie=n-1;\\n        return Ctree(preorder,inorder,is,ie);\\n    }"
                    },
                    {
                        "username": "SeaShanty",
                        "content": "PLS HELP. why is my code giving an indexoutofbounds Exception for  `TreeNode root= new TreeNode(preorder[preIndex++]);`\\n\\n\\nalso, here is my complete code\\n\\n``` \\nclass Solution {\\n    int preIndex=0;\\n    int inIndex=0;\\n    public TreeNode buildTree(int[] preorder, int[] inorder) {\\n        int inorderStart=0;\\n        int inorderEnd=inorder.length-1;\\n        return solve(preorder, inorder, inorderStart, inorderEnd);\\n    }\\n    public TreeNode solve(int[] preorder, int[] inorder, int inorderStart, int inorderEnd)\\n    {\\n        //FIRST ,  BASE CONDITION\\n        if(inorderStart>inorderEnd)\\n        {\\n            return null;\\n        }\\n        \\n\\n            //int node=;\\n            //create a node/root now\\n            TreeNode root= new TreeNode(preorder[preIndex++]);\\n\\n            //locate this root value in the inorder array\\n         inIndex=inorderStart;        // saw this in gfg code\\n         for(int i=inorderStart; i<inorder.length; i++)\\n         {\\n             if(inorder[i] == root.val)\\n             {\\n                 inIndex=i;\\n                 break;\\n             }\\n         }\\n\\n         root.left=solve(preorder, inorder, inorderStart, inIndex-1);\\n         root.right=solve(preorder, inorder, inIndex+1, inorderEnd);\\n\\n         return root;\\n    }\\n}\\n\\n```"
                    },
                    {
                        "username": "catchups",
                        "content": "will there be [2, 2, 2, 2, 2] and [2, 2, 2, 2, 2] case?"
                    },
                    {
                        "username": "catchups",
                        "content": "why there is test case like 202? "
                    },
                    {
                        "username": "lakshya05",
                        "content": "Is everyone getting a TLE at the last test case?\\nMy solution worked for 202 test cases and I couldn\\'t find the error. \\nI also compared with one of the published solutions and the logic looked sound.\\nDoesn\\'t work even upon using any of the published codes."
                    }
                ]
            },
            {
                "id": 1872363,
                "content": [
                    {
                        "username": "sjames8888",
                        "content": "pretty print Java and a few hints\\n\\nhere is a few hints on what I did - I have not looked at other solutions but this is just a few lines of code and runs in 97% of so performance rankings.  It took me a lot of thinking about and head scratching.\\n\\n1. a lookup map on both arrays is useful i.e. node value to position in array.\\n2. recursion is a natural choice where if we have a construct function taking above maps the root value for the given sub tree, the preorder array and bounds of the sub tree (initially 0 and preorder.length - 1.  left is a call to this recursive function on left bound tree to left of the root and right similar.\\n3. if (start >= end) we have no subtree so create return a node with that value at current root and return left, right are null in this case.\\n4. get 2 indices lookup the above maps we will call them inOrderIndex and preOrderIndex.\\n5. looking at the preorder array our left root in next recursive call is always next in preorder list i.e. we call outr recursive function with preorder[preOrderIndex + 1]\\n6. on right the root is preorder[preOrderIndex + nodesOnLeft + 1]\\n7. nodesOnLeft = inOrderIndex - start;\\n8. nodesOnRight = end - inOrderIndex;\\n9. on left recurive call start, end are inOrderIndex - nodesOnLeft, inOrderIndex - 1\\n10 on right recursive call inOrderIndex + 1, inOrderIndex + nodesOnRight)\\n\\n\\n\\nI wrote this to visualise the tree which you may find handy - this is a rush job so I am sure someone can do better, feel free to improve and repost.\\n\\n                3\\n            /       \\\\\\n           9        20\\n                   /   \\\\\\n                 15     7\\n                 / \\\\   / \\\\\\n               21  14 8   5\\n\\n ` @Test\\n    void case3() {\\n        final var root = new ConstructBinaryTreePreorderInorderTraversal().buildTree(new int[]{3,9,20,15,21,14,7,8,5}, new int[]{9,3,21,15,14,20,8,7,5});\\n        final var arr = root.toArray();\\n        System.out.println(root.prettyPrint());\\n    }`\\n\\n\\n  `\\n  /*\\n  place on TreeNode class\\n\\n\\n*/\\n\\n\\n   private int depth(TreeNode root, int level) {\\n        if (root == null) {\\n            return level;\\n        }\\n\\n        return Math.max(depth(root.left, level + 1), depth(root.right, level + 1));\\n    }\\n    \\n    public String prettyPrint() {\\n        return printToGrid(this);\\n    }\\n\\n    public String printToGrid(TreeNode root) {\\n        if (root == null) {\\n            return \"\";\\n        }\\n        final var depth = depth(this, 0);\\n        final var n = 2 * depth * depth;\\n        final var ca = new char[n][n];\\n        final var whiteLine = \" \".repeat(n);\\n        for (var i = 0; i < n; ++i) {\\n            ca[i] = whiteLine.toCharArray();\\n        }\\n        printToGrid(ca, root, 0, ca[0].length / 2);\\n        var sb = new StringBuilder();\\n        for (var r : ca) {\\n            final var s = new String(r).stripTrailing();\\n            if (s.equals(\"\")) {\\n                break;\\n            }\\n            sb.append(s).append(\"\\\\n\");\\n        }\\n        return sb.toString();\\n    }\\n\\n    public void printToGrid( char[][] grid, TreeNode root, int row, int col) {\\n        if (root == null) {\\n            return;\\n        }\\n        final var depth = depth(root,0);\\n        final var v = root.val;\\n        final var s = Integer.toString(v);\\n        var writeCol = col - s.length() / 2;\\n        while (writeCol < grid.length - s.length() && grid[row][writeCol] != \\' \\'\\n                || grid[row][writeCol - 1] != \\' \\') {\\n            ++writeCol;\\n        }\\n        for (var i = 0; i < s.length(); ++i) {\\n            grid[row][writeCol + i] = s.charAt(i);\\n        }\\n        final var spacing = Math.max(2, depth - (row/2) + 1);\\n        if (root.left != null) {\\n            grid[row + 1][col - spacing + 1] = \\'/\\';\\n            printToGrid(grid, root.left, row + 2, col - spacing);\\n        }\\n        if (root.right != null) {\\n            grid[row + 1][col + spacing - 1] = \\'\\\\\\\\\\';\\n            printToGrid(grid, root.right, row + 2, col + spacing);\\n        }\\n    }\\n`"
                    },
                    {
                        "username": "shaamray",
                        "content": "Can anyone clarify why Output: [3,9,20,null,null,15,7] has two null values :\\') ?"
                    },
                    {
                        "username": "sjames8888",
                        "content": "looks as below\n\n```txt\n           3\n        /       \\\n       9        20\n               /   \\\n             15     7\n```\n\n```java\n @Test\n    void case8() {\n        final var root = TreeNode.from(new Integer[]{3,9,20,null,null,15,7});\n        System.out.println(root.prettyPrint());\n    }\n```"
                    },
                    {
                        "username": "codepiyush1",
                        "content": "# Intuition\\nC++ DFS. Easy Recursive, Proper time and space complexity\\n\\n# Approach\\n\\n1. Define a function `makeTree` that takes the following parameters:\\n   - `preorder`: The preorder traversal of the tree.\\n   - `pL`: The lower index of the current range of the preorder traversal.\\n   - `pH`: The upper index of the current range of the preorder traversal.\\n   - `inorder`: The inorder traversal of the tree.\\n   - `iL`: The lower index of the current range of the inorder traversal.\\n   - `iH`: The upper index of the current range of the inorder traversal.\\n   - `mp`: An unordered map to store the mapping of values to their indices in the inorder traversal.\\n\\n2. Check if the range of indices is invalid, i.e., `pL` is greater than `pH` or `iL` is greater than `iH`. If so, return `NULL` indicating an empty subtree.\\n\\n3. Create a new `TreeNode` with the value at index `pL` in the preorder traversal as its value.\\n\\n4. Get the current index (`currInd`) of the value in the inorder traversal by looking it up in the unordered map `mp`.\\n\\n5. Calculate the number of nodes in the left subtree by subtracting `iL` from `currInd`.\\n\\n6. Recursively call the `makeTree` function to construct the left subtree by passing the following parameters:\\n   - `preorder`: Same as the input.\\n   - `pL+1`: Increment the lower index of the preorder traversal by 1.\\n   - `pL+leftNodes`: Set the upper index of the preorder traversal to `pL+leftNodes`.\\n   - `inorder`: Same as the input.\\n   - `iL`: Same as the input.\\n   - `currInd-1`: Set the upper index of the inorder traversal to `currInd-1`.\\n\\n7. Assign the returned subtree to the `left` pointer of the current node.\\n\\n8. Recursively call the `makeTree` function to construct the right subtree by passing the following parameters:\\n   - `preorder`: Same as the input.\\n   - `pL+leftNodes+1`: Set the lower index of the preorder traversal to `pL+leftNodes+1`.\\n   - `pH`: Same as the input.\\n   - `inorder`: Same as the input.\\n   - `currInd+1`: Set the lower index of the inorder traversal to `currInd+1`.\\n   - `iH`: Same as the input.\\n\\n9. Assign the returned subtree to the `right` pointer of the current node.\\n\\n10. Return the root of the constructed binary tree.\\n\\n11. Define a function `buildTree` that takes the following parameters:\\n    - `preorder`: The preorder traversal of the tree.\\n    - `inorder`: The inorder traversal of the tree.\\n\\n12. Create an unordered map `mp` to store the mapping of values to their indices in the inorder traversal.\\n\\n13. Get the size of the inorder traversal and store it in variable `n`.\\n\\n14. Iterate over the values and indices in the inorder traversal, and populate the unordered map `mp`.\\n\\n15. Call the `makeTree` function with the initial parameters:\\n    - `preorder`: Same as the input.\\n    - `0`: Set the lower index of the preorder traversal to 0.\\n    - `n-1`: Set the upper index of the preorder traversal to `n-1`.\\n    - `inorder`: Same as the input.\\n    - `0`: Set the lower index of the inorder traversal\\n\\n------------------------------------\\n# Complexity\\n- Time complexity:\\nT.C=O(n) in each recursive call one node created.\\n- Space complexity:\\nS.C=O(2n) == O(n) , n for unordered_map and n for recursive stack.\\n---------------------------------\\nPlease Upvote. If understand the concept.\\nSolution link:\\nhttps://leetcode.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal/solutions/3707300/c-dfs-easy-recursive-proper-time-and-space-complexity/\\n"
                    },
                    {
                        "username": "mochiball",
                        "content": " I struggled a lot with this problem. Felt pretty good about trees until I came to this one. It was my first divide and conquer problem but I think we can learn a lot from this problem. \\n\\nThis problem focuses on divide and conquer + recursion. Very important ! "
                    },
                    {
                        "username": "dmitriysin",
                        "content": "Example 1 `[3,9,20,null,null,15,7]` is not a binary tree since:\n1) 3 is less than 9\n2) 7 is less than 9"
                    },
                    {
                        "username": "mochiball",
                        "content": "Question is binary tree, NOT binary search tree "
                    },
                    {
                        "username": "meteahmetyakar",
                        "content": "if every node have 2 child we calls it binary tree, I think you mixed with binary search tree. In binary trees there is no value relation between nodes."
                    },
                    {
                        "username": "adgjl30102005",
                        "content": "Please help, I use the code in Editorial with this test case: pre= [4,1,3,6,8]; inorder = [6,1,8,4,3]\\nand it doesn\\'t work.\\nThe tree should look like this:\\n           4\\n        /     \\\\\\n       1       3\\n      /\\\\\\n    6    8\\nHand Calculating:\\npreorder = [4, 1, 3, 6, 8]\\nHashmap: {6:0 ; 1:1 ; 8:2 ; 4:3 ; 3:4 }\\npreorderindex = 0\\nloop 1:\\nleft = 0 right = 3\\npreorderindex = 0 => root value = 4 => new right = 2\\ntree : 4\\nloop 2:\\nleft = 0 right = 2\\npreorderindex = 1 => root value = 1 => new right = 0\\ntree: 4\\n      1\\nloop 3: \\nleft =0 right = 0\\npreorderindex = 2 => root value = 3 => new right = 3\\ntree: 4\\n      1\\n    3\\nat this step, there is already an error, and I really wonder where is the mistake?\\n"
                    },
                    {
                        "username": "Sashi_sharma",
                        "content": "This code shows Runtime Error.\\nCan anyone help!!!!!\\n\\n int preindex=0;\\n    TreeNode* Ctree(vector<int> &preorder, vector<int> &inorder,int is,int ie){\\n        if(is>ie)   return NULL;\\n        TreeNode* root=new TreeNode(preorder[preindex++]);\\n        int inIndex;\\n        for(int i=is;i<=ie;i++){\\n            if(inorder[i]==root->val){\\n                inIndex=i;\\n                break;\\n            }\\n        }\\n        root->left=Ctree(preorder,inorder,is,inIndex-1);\\n        root->right=Ctree(preorder,inorder,inIndex,ie);\\n        return root;\\n    }\\n    TreeNode* buildTree(vector<int>& preorder, vector<int>& inorder) {\\n        int n=inorder.size();\\n        int is=0;\\n        int ie=n-1;\\n        return Ctree(preorder,inorder,is,ie);\\n    }"
                    },
                    {
                        "username": "SeaShanty",
                        "content": "PLS HELP. why is my code giving an indexoutofbounds Exception for  `TreeNode root= new TreeNode(preorder[preIndex++]);`\\n\\n\\nalso, here is my complete code\\n\\n``` \\nclass Solution {\\n    int preIndex=0;\\n    int inIndex=0;\\n    public TreeNode buildTree(int[] preorder, int[] inorder) {\\n        int inorderStart=0;\\n        int inorderEnd=inorder.length-1;\\n        return solve(preorder, inorder, inorderStart, inorderEnd);\\n    }\\n    public TreeNode solve(int[] preorder, int[] inorder, int inorderStart, int inorderEnd)\\n    {\\n        //FIRST ,  BASE CONDITION\\n        if(inorderStart>inorderEnd)\\n        {\\n            return null;\\n        }\\n        \\n\\n            //int node=;\\n            //create a node/root now\\n            TreeNode root= new TreeNode(preorder[preIndex++]);\\n\\n            //locate this root value in the inorder array\\n         inIndex=inorderStart;        // saw this in gfg code\\n         for(int i=inorderStart; i<inorder.length; i++)\\n         {\\n             if(inorder[i] == root.val)\\n             {\\n                 inIndex=i;\\n                 break;\\n             }\\n         }\\n\\n         root.left=solve(preorder, inorder, inorderStart, inIndex-1);\\n         root.right=solve(preorder, inorder, inIndex+1, inorderEnd);\\n\\n         return root;\\n    }\\n}\\n\\n```"
                    },
                    {
                        "username": "catchups",
                        "content": "will there be [2, 2, 2, 2, 2] and [2, 2, 2, 2, 2] case?"
                    },
                    {
                        "username": "catchups",
                        "content": "why there is test case like 202? "
                    },
                    {
                        "username": "lakshya05",
                        "content": "Is everyone getting a TLE at the last test case?\\nMy solution worked for 202 test cases and I couldn\\'t find the error. \\nI also compared with one of the published solutions and the logic looked sound.\\nDoesn\\'t work even upon using any of the published codes."
                    }
                ]
            },
            {
                "id": 1857354,
                "content": [
                    {
                        "username": "sjames8888",
                        "content": "pretty print Java and a few hints\\n\\nhere is a few hints on what I did - I have not looked at other solutions but this is just a few lines of code and runs in 97% of so performance rankings.  It took me a lot of thinking about and head scratching.\\n\\n1. a lookup map on both arrays is useful i.e. node value to position in array.\\n2. recursion is a natural choice where if we have a construct function taking above maps the root value for the given sub tree, the preorder array and bounds of the sub tree (initially 0 and preorder.length - 1.  left is a call to this recursive function on left bound tree to left of the root and right similar.\\n3. if (start >= end) we have no subtree so create return a node with that value at current root and return left, right are null in this case.\\n4. get 2 indices lookup the above maps we will call them inOrderIndex and preOrderIndex.\\n5. looking at the preorder array our left root in next recursive call is always next in preorder list i.e. we call outr recursive function with preorder[preOrderIndex + 1]\\n6. on right the root is preorder[preOrderIndex + nodesOnLeft + 1]\\n7. nodesOnLeft = inOrderIndex - start;\\n8. nodesOnRight = end - inOrderIndex;\\n9. on left recurive call start, end are inOrderIndex - nodesOnLeft, inOrderIndex - 1\\n10 on right recursive call inOrderIndex + 1, inOrderIndex + nodesOnRight)\\n\\n\\n\\nI wrote this to visualise the tree which you may find handy - this is a rush job so I am sure someone can do better, feel free to improve and repost.\\n\\n                3\\n            /       \\\\\\n           9        20\\n                   /   \\\\\\n                 15     7\\n                 / \\\\   / \\\\\\n               21  14 8   5\\n\\n ` @Test\\n    void case3() {\\n        final var root = new ConstructBinaryTreePreorderInorderTraversal().buildTree(new int[]{3,9,20,15,21,14,7,8,5}, new int[]{9,3,21,15,14,20,8,7,5});\\n        final var arr = root.toArray();\\n        System.out.println(root.prettyPrint());\\n    }`\\n\\n\\n  `\\n  /*\\n  place on TreeNode class\\n\\n\\n*/\\n\\n\\n   private int depth(TreeNode root, int level) {\\n        if (root == null) {\\n            return level;\\n        }\\n\\n        return Math.max(depth(root.left, level + 1), depth(root.right, level + 1));\\n    }\\n    \\n    public String prettyPrint() {\\n        return printToGrid(this);\\n    }\\n\\n    public String printToGrid(TreeNode root) {\\n        if (root == null) {\\n            return \"\";\\n        }\\n        final var depth = depth(this, 0);\\n        final var n = 2 * depth * depth;\\n        final var ca = new char[n][n];\\n        final var whiteLine = \" \".repeat(n);\\n        for (var i = 0; i < n; ++i) {\\n            ca[i] = whiteLine.toCharArray();\\n        }\\n        printToGrid(ca, root, 0, ca[0].length / 2);\\n        var sb = new StringBuilder();\\n        for (var r : ca) {\\n            final var s = new String(r).stripTrailing();\\n            if (s.equals(\"\")) {\\n                break;\\n            }\\n            sb.append(s).append(\"\\\\n\");\\n        }\\n        return sb.toString();\\n    }\\n\\n    public void printToGrid( char[][] grid, TreeNode root, int row, int col) {\\n        if (root == null) {\\n            return;\\n        }\\n        final var depth = depth(root,0);\\n        final var v = root.val;\\n        final var s = Integer.toString(v);\\n        var writeCol = col - s.length() / 2;\\n        while (writeCol < grid.length - s.length() && grid[row][writeCol] != \\' \\'\\n                || grid[row][writeCol - 1] != \\' \\') {\\n            ++writeCol;\\n        }\\n        for (var i = 0; i < s.length(); ++i) {\\n            grid[row][writeCol + i] = s.charAt(i);\\n        }\\n        final var spacing = Math.max(2, depth - (row/2) + 1);\\n        if (root.left != null) {\\n            grid[row + 1][col - spacing + 1] = \\'/\\';\\n            printToGrid(grid, root.left, row + 2, col - spacing);\\n        }\\n        if (root.right != null) {\\n            grid[row + 1][col + spacing - 1] = \\'\\\\\\\\\\';\\n            printToGrid(grid, root.right, row + 2, col + spacing);\\n        }\\n    }\\n`"
                    },
                    {
                        "username": "shaamray",
                        "content": "Can anyone clarify why Output: [3,9,20,null,null,15,7] has two null values :\\') ?"
                    },
                    {
                        "username": "sjames8888",
                        "content": "looks as below\n\n```txt\n           3\n        /       \\\n       9        20\n               /   \\\n             15     7\n```\n\n```java\n @Test\n    void case8() {\n        final var root = TreeNode.from(new Integer[]{3,9,20,null,null,15,7});\n        System.out.println(root.prettyPrint());\n    }\n```"
                    },
                    {
                        "username": "codepiyush1",
                        "content": "# Intuition\\nC++ DFS. Easy Recursive, Proper time and space complexity\\n\\n# Approach\\n\\n1. Define a function `makeTree` that takes the following parameters:\\n   - `preorder`: The preorder traversal of the tree.\\n   - `pL`: The lower index of the current range of the preorder traversal.\\n   - `pH`: The upper index of the current range of the preorder traversal.\\n   - `inorder`: The inorder traversal of the tree.\\n   - `iL`: The lower index of the current range of the inorder traversal.\\n   - `iH`: The upper index of the current range of the inorder traversal.\\n   - `mp`: An unordered map to store the mapping of values to their indices in the inorder traversal.\\n\\n2. Check if the range of indices is invalid, i.e., `pL` is greater than `pH` or `iL` is greater than `iH`. If so, return `NULL` indicating an empty subtree.\\n\\n3. Create a new `TreeNode` with the value at index `pL` in the preorder traversal as its value.\\n\\n4. Get the current index (`currInd`) of the value in the inorder traversal by looking it up in the unordered map `mp`.\\n\\n5. Calculate the number of nodes in the left subtree by subtracting `iL` from `currInd`.\\n\\n6. Recursively call the `makeTree` function to construct the left subtree by passing the following parameters:\\n   - `preorder`: Same as the input.\\n   - `pL+1`: Increment the lower index of the preorder traversal by 1.\\n   - `pL+leftNodes`: Set the upper index of the preorder traversal to `pL+leftNodes`.\\n   - `inorder`: Same as the input.\\n   - `iL`: Same as the input.\\n   - `currInd-1`: Set the upper index of the inorder traversal to `currInd-1`.\\n\\n7. Assign the returned subtree to the `left` pointer of the current node.\\n\\n8. Recursively call the `makeTree` function to construct the right subtree by passing the following parameters:\\n   - `preorder`: Same as the input.\\n   - `pL+leftNodes+1`: Set the lower index of the preorder traversal to `pL+leftNodes+1`.\\n   - `pH`: Same as the input.\\n   - `inorder`: Same as the input.\\n   - `currInd+1`: Set the lower index of the inorder traversal to `currInd+1`.\\n   - `iH`: Same as the input.\\n\\n9. Assign the returned subtree to the `right` pointer of the current node.\\n\\n10. Return the root of the constructed binary tree.\\n\\n11. Define a function `buildTree` that takes the following parameters:\\n    - `preorder`: The preorder traversal of the tree.\\n    - `inorder`: The inorder traversal of the tree.\\n\\n12. Create an unordered map `mp` to store the mapping of values to their indices in the inorder traversal.\\n\\n13. Get the size of the inorder traversal and store it in variable `n`.\\n\\n14. Iterate over the values and indices in the inorder traversal, and populate the unordered map `mp`.\\n\\n15. Call the `makeTree` function with the initial parameters:\\n    - `preorder`: Same as the input.\\n    - `0`: Set the lower index of the preorder traversal to 0.\\n    - `n-1`: Set the upper index of the preorder traversal to `n-1`.\\n    - `inorder`: Same as the input.\\n    - `0`: Set the lower index of the inorder traversal\\n\\n------------------------------------\\n# Complexity\\n- Time complexity:\\nT.C=O(n) in each recursive call one node created.\\n- Space complexity:\\nS.C=O(2n) == O(n) , n for unordered_map and n for recursive stack.\\n---------------------------------\\nPlease Upvote. If understand the concept.\\nSolution link:\\nhttps://leetcode.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal/solutions/3707300/c-dfs-easy-recursive-proper-time-and-space-complexity/\\n"
                    },
                    {
                        "username": "mochiball",
                        "content": " I struggled a lot with this problem. Felt pretty good about trees until I came to this one. It was my first divide and conquer problem but I think we can learn a lot from this problem. \\n\\nThis problem focuses on divide and conquer + recursion. Very important ! "
                    },
                    {
                        "username": "dmitriysin",
                        "content": "Example 1 `[3,9,20,null,null,15,7]` is not a binary tree since:\n1) 3 is less than 9\n2) 7 is less than 9"
                    },
                    {
                        "username": "mochiball",
                        "content": "Question is binary tree, NOT binary search tree "
                    },
                    {
                        "username": "meteahmetyakar",
                        "content": "if every node have 2 child we calls it binary tree, I think you mixed with binary search tree. In binary trees there is no value relation between nodes."
                    },
                    {
                        "username": "adgjl30102005",
                        "content": "Please help, I use the code in Editorial with this test case: pre= [4,1,3,6,8]; inorder = [6,1,8,4,3]\\nand it doesn\\'t work.\\nThe tree should look like this:\\n           4\\n        /     \\\\\\n       1       3\\n      /\\\\\\n    6    8\\nHand Calculating:\\npreorder = [4, 1, 3, 6, 8]\\nHashmap: {6:0 ; 1:1 ; 8:2 ; 4:3 ; 3:4 }\\npreorderindex = 0\\nloop 1:\\nleft = 0 right = 3\\npreorderindex = 0 => root value = 4 => new right = 2\\ntree : 4\\nloop 2:\\nleft = 0 right = 2\\npreorderindex = 1 => root value = 1 => new right = 0\\ntree: 4\\n      1\\nloop 3: \\nleft =0 right = 0\\npreorderindex = 2 => root value = 3 => new right = 3\\ntree: 4\\n      1\\n    3\\nat this step, there is already an error, and I really wonder where is the mistake?\\n"
                    },
                    {
                        "username": "Sashi_sharma",
                        "content": "This code shows Runtime Error.\\nCan anyone help!!!!!\\n\\n int preindex=0;\\n    TreeNode* Ctree(vector<int> &preorder, vector<int> &inorder,int is,int ie){\\n        if(is>ie)   return NULL;\\n        TreeNode* root=new TreeNode(preorder[preindex++]);\\n        int inIndex;\\n        for(int i=is;i<=ie;i++){\\n            if(inorder[i]==root->val){\\n                inIndex=i;\\n                break;\\n            }\\n        }\\n        root->left=Ctree(preorder,inorder,is,inIndex-1);\\n        root->right=Ctree(preorder,inorder,inIndex,ie);\\n        return root;\\n    }\\n    TreeNode* buildTree(vector<int>& preorder, vector<int>& inorder) {\\n        int n=inorder.size();\\n        int is=0;\\n        int ie=n-1;\\n        return Ctree(preorder,inorder,is,ie);\\n    }"
                    },
                    {
                        "username": "SeaShanty",
                        "content": "PLS HELP. why is my code giving an indexoutofbounds Exception for  `TreeNode root= new TreeNode(preorder[preIndex++]);`\\n\\n\\nalso, here is my complete code\\n\\n``` \\nclass Solution {\\n    int preIndex=0;\\n    int inIndex=0;\\n    public TreeNode buildTree(int[] preorder, int[] inorder) {\\n        int inorderStart=0;\\n        int inorderEnd=inorder.length-1;\\n        return solve(preorder, inorder, inorderStart, inorderEnd);\\n    }\\n    public TreeNode solve(int[] preorder, int[] inorder, int inorderStart, int inorderEnd)\\n    {\\n        //FIRST ,  BASE CONDITION\\n        if(inorderStart>inorderEnd)\\n        {\\n            return null;\\n        }\\n        \\n\\n            //int node=;\\n            //create a node/root now\\n            TreeNode root= new TreeNode(preorder[preIndex++]);\\n\\n            //locate this root value in the inorder array\\n         inIndex=inorderStart;        // saw this in gfg code\\n         for(int i=inorderStart; i<inorder.length; i++)\\n         {\\n             if(inorder[i] == root.val)\\n             {\\n                 inIndex=i;\\n                 break;\\n             }\\n         }\\n\\n         root.left=solve(preorder, inorder, inorderStart, inIndex-1);\\n         root.right=solve(preorder, inorder, inIndex+1, inorderEnd);\\n\\n         return root;\\n    }\\n}\\n\\n```"
                    },
                    {
                        "username": "catchups",
                        "content": "will there be [2, 2, 2, 2, 2] and [2, 2, 2, 2, 2] case?"
                    },
                    {
                        "username": "catchups",
                        "content": "why there is test case like 202? "
                    },
                    {
                        "username": "lakshya05",
                        "content": "Is everyone getting a TLE at the last test case?\\nMy solution worked for 202 test cases and I couldn\\'t find the error. \\nI also compared with one of the published solutions and the logic looked sound.\\nDoesn\\'t work even upon using any of the published codes."
                    }
                ]
            },
            {
                "id": 1834424,
                "content": [
                    {
                        "username": "sjames8888",
                        "content": "pretty print Java and a few hints\\n\\nhere is a few hints on what I did - I have not looked at other solutions but this is just a few lines of code and runs in 97% of so performance rankings.  It took me a lot of thinking about and head scratching.\\n\\n1. a lookup map on both arrays is useful i.e. node value to position in array.\\n2. recursion is a natural choice where if we have a construct function taking above maps the root value for the given sub tree, the preorder array and bounds of the sub tree (initially 0 and preorder.length - 1.  left is a call to this recursive function on left bound tree to left of the root and right similar.\\n3. if (start >= end) we have no subtree so create return a node with that value at current root and return left, right are null in this case.\\n4. get 2 indices lookup the above maps we will call them inOrderIndex and preOrderIndex.\\n5. looking at the preorder array our left root in next recursive call is always next in preorder list i.e. we call outr recursive function with preorder[preOrderIndex + 1]\\n6. on right the root is preorder[preOrderIndex + nodesOnLeft + 1]\\n7. nodesOnLeft = inOrderIndex - start;\\n8. nodesOnRight = end - inOrderIndex;\\n9. on left recurive call start, end are inOrderIndex - nodesOnLeft, inOrderIndex - 1\\n10 on right recursive call inOrderIndex + 1, inOrderIndex + nodesOnRight)\\n\\n\\n\\nI wrote this to visualise the tree which you may find handy - this is a rush job so I am sure someone can do better, feel free to improve and repost.\\n\\n                3\\n            /       \\\\\\n           9        20\\n                   /   \\\\\\n                 15     7\\n                 / \\\\   / \\\\\\n               21  14 8   5\\n\\n ` @Test\\n    void case3() {\\n        final var root = new ConstructBinaryTreePreorderInorderTraversal().buildTree(new int[]{3,9,20,15,21,14,7,8,5}, new int[]{9,3,21,15,14,20,8,7,5});\\n        final var arr = root.toArray();\\n        System.out.println(root.prettyPrint());\\n    }`\\n\\n\\n  `\\n  /*\\n  place on TreeNode class\\n\\n\\n*/\\n\\n\\n   private int depth(TreeNode root, int level) {\\n        if (root == null) {\\n            return level;\\n        }\\n\\n        return Math.max(depth(root.left, level + 1), depth(root.right, level + 1));\\n    }\\n    \\n    public String prettyPrint() {\\n        return printToGrid(this);\\n    }\\n\\n    public String printToGrid(TreeNode root) {\\n        if (root == null) {\\n            return \"\";\\n        }\\n        final var depth = depth(this, 0);\\n        final var n = 2 * depth * depth;\\n        final var ca = new char[n][n];\\n        final var whiteLine = \" \".repeat(n);\\n        for (var i = 0; i < n; ++i) {\\n            ca[i] = whiteLine.toCharArray();\\n        }\\n        printToGrid(ca, root, 0, ca[0].length / 2);\\n        var sb = new StringBuilder();\\n        for (var r : ca) {\\n            final var s = new String(r).stripTrailing();\\n            if (s.equals(\"\")) {\\n                break;\\n            }\\n            sb.append(s).append(\"\\\\n\");\\n        }\\n        return sb.toString();\\n    }\\n\\n    public void printToGrid( char[][] grid, TreeNode root, int row, int col) {\\n        if (root == null) {\\n            return;\\n        }\\n        final var depth = depth(root,0);\\n        final var v = root.val;\\n        final var s = Integer.toString(v);\\n        var writeCol = col - s.length() / 2;\\n        while (writeCol < grid.length - s.length() && grid[row][writeCol] != \\' \\'\\n                || grid[row][writeCol - 1] != \\' \\') {\\n            ++writeCol;\\n        }\\n        for (var i = 0; i < s.length(); ++i) {\\n            grid[row][writeCol + i] = s.charAt(i);\\n        }\\n        final var spacing = Math.max(2, depth - (row/2) + 1);\\n        if (root.left != null) {\\n            grid[row + 1][col - spacing + 1] = \\'/\\';\\n            printToGrid(grid, root.left, row + 2, col - spacing);\\n        }\\n        if (root.right != null) {\\n            grid[row + 1][col + spacing - 1] = \\'\\\\\\\\\\';\\n            printToGrid(grid, root.right, row + 2, col + spacing);\\n        }\\n    }\\n`"
                    },
                    {
                        "username": "shaamray",
                        "content": "Can anyone clarify why Output: [3,9,20,null,null,15,7] has two null values :\\') ?"
                    },
                    {
                        "username": "sjames8888",
                        "content": "looks as below\n\n```txt\n           3\n        /       \\\n       9        20\n               /   \\\n             15     7\n```\n\n```java\n @Test\n    void case8() {\n        final var root = TreeNode.from(new Integer[]{3,9,20,null,null,15,7});\n        System.out.println(root.prettyPrint());\n    }\n```"
                    },
                    {
                        "username": "codepiyush1",
                        "content": "# Intuition\\nC++ DFS. Easy Recursive, Proper time and space complexity\\n\\n# Approach\\n\\n1. Define a function `makeTree` that takes the following parameters:\\n   - `preorder`: The preorder traversal of the tree.\\n   - `pL`: The lower index of the current range of the preorder traversal.\\n   - `pH`: The upper index of the current range of the preorder traversal.\\n   - `inorder`: The inorder traversal of the tree.\\n   - `iL`: The lower index of the current range of the inorder traversal.\\n   - `iH`: The upper index of the current range of the inorder traversal.\\n   - `mp`: An unordered map to store the mapping of values to their indices in the inorder traversal.\\n\\n2. Check if the range of indices is invalid, i.e., `pL` is greater than `pH` or `iL` is greater than `iH`. If so, return `NULL` indicating an empty subtree.\\n\\n3. Create a new `TreeNode` with the value at index `pL` in the preorder traversal as its value.\\n\\n4. Get the current index (`currInd`) of the value in the inorder traversal by looking it up in the unordered map `mp`.\\n\\n5. Calculate the number of nodes in the left subtree by subtracting `iL` from `currInd`.\\n\\n6. Recursively call the `makeTree` function to construct the left subtree by passing the following parameters:\\n   - `preorder`: Same as the input.\\n   - `pL+1`: Increment the lower index of the preorder traversal by 1.\\n   - `pL+leftNodes`: Set the upper index of the preorder traversal to `pL+leftNodes`.\\n   - `inorder`: Same as the input.\\n   - `iL`: Same as the input.\\n   - `currInd-1`: Set the upper index of the inorder traversal to `currInd-1`.\\n\\n7. Assign the returned subtree to the `left` pointer of the current node.\\n\\n8. Recursively call the `makeTree` function to construct the right subtree by passing the following parameters:\\n   - `preorder`: Same as the input.\\n   - `pL+leftNodes+1`: Set the lower index of the preorder traversal to `pL+leftNodes+1`.\\n   - `pH`: Same as the input.\\n   - `inorder`: Same as the input.\\n   - `currInd+1`: Set the lower index of the inorder traversal to `currInd+1`.\\n   - `iH`: Same as the input.\\n\\n9. Assign the returned subtree to the `right` pointer of the current node.\\n\\n10. Return the root of the constructed binary tree.\\n\\n11. Define a function `buildTree` that takes the following parameters:\\n    - `preorder`: The preorder traversal of the tree.\\n    - `inorder`: The inorder traversal of the tree.\\n\\n12. Create an unordered map `mp` to store the mapping of values to their indices in the inorder traversal.\\n\\n13. Get the size of the inorder traversal and store it in variable `n`.\\n\\n14. Iterate over the values and indices in the inorder traversal, and populate the unordered map `mp`.\\n\\n15. Call the `makeTree` function with the initial parameters:\\n    - `preorder`: Same as the input.\\n    - `0`: Set the lower index of the preorder traversal to 0.\\n    - `n-1`: Set the upper index of the preorder traversal to `n-1`.\\n    - `inorder`: Same as the input.\\n    - `0`: Set the lower index of the inorder traversal\\n\\n------------------------------------\\n# Complexity\\n- Time complexity:\\nT.C=O(n) in each recursive call one node created.\\n- Space complexity:\\nS.C=O(2n) == O(n) , n for unordered_map and n for recursive stack.\\n---------------------------------\\nPlease Upvote. If understand the concept.\\nSolution link:\\nhttps://leetcode.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal/solutions/3707300/c-dfs-easy-recursive-proper-time-and-space-complexity/\\n"
                    },
                    {
                        "username": "mochiball",
                        "content": " I struggled a lot with this problem. Felt pretty good about trees until I came to this one. It was my first divide and conquer problem but I think we can learn a lot from this problem. \\n\\nThis problem focuses on divide and conquer + recursion. Very important ! "
                    },
                    {
                        "username": "dmitriysin",
                        "content": "Example 1 `[3,9,20,null,null,15,7]` is not a binary tree since:\n1) 3 is less than 9\n2) 7 is less than 9"
                    },
                    {
                        "username": "mochiball",
                        "content": "Question is binary tree, NOT binary search tree "
                    },
                    {
                        "username": "meteahmetyakar",
                        "content": "if every node have 2 child we calls it binary tree, I think you mixed with binary search tree. In binary trees there is no value relation between nodes."
                    },
                    {
                        "username": "adgjl30102005",
                        "content": "Please help, I use the code in Editorial with this test case: pre= [4,1,3,6,8]; inorder = [6,1,8,4,3]\\nand it doesn\\'t work.\\nThe tree should look like this:\\n           4\\n        /     \\\\\\n       1       3\\n      /\\\\\\n    6    8\\nHand Calculating:\\npreorder = [4, 1, 3, 6, 8]\\nHashmap: {6:0 ; 1:1 ; 8:2 ; 4:3 ; 3:4 }\\npreorderindex = 0\\nloop 1:\\nleft = 0 right = 3\\npreorderindex = 0 => root value = 4 => new right = 2\\ntree : 4\\nloop 2:\\nleft = 0 right = 2\\npreorderindex = 1 => root value = 1 => new right = 0\\ntree: 4\\n      1\\nloop 3: \\nleft =0 right = 0\\npreorderindex = 2 => root value = 3 => new right = 3\\ntree: 4\\n      1\\n    3\\nat this step, there is already an error, and I really wonder where is the mistake?\\n"
                    },
                    {
                        "username": "Sashi_sharma",
                        "content": "This code shows Runtime Error.\\nCan anyone help!!!!!\\n\\n int preindex=0;\\n    TreeNode* Ctree(vector<int> &preorder, vector<int> &inorder,int is,int ie){\\n        if(is>ie)   return NULL;\\n        TreeNode* root=new TreeNode(preorder[preindex++]);\\n        int inIndex;\\n        for(int i=is;i<=ie;i++){\\n            if(inorder[i]==root->val){\\n                inIndex=i;\\n                break;\\n            }\\n        }\\n        root->left=Ctree(preorder,inorder,is,inIndex-1);\\n        root->right=Ctree(preorder,inorder,inIndex,ie);\\n        return root;\\n    }\\n    TreeNode* buildTree(vector<int>& preorder, vector<int>& inorder) {\\n        int n=inorder.size();\\n        int is=0;\\n        int ie=n-1;\\n        return Ctree(preorder,inorder,is,ie);\\n    }"
                    },
                    {
                        "username": "SeaShanty",
                        "content": "PLS HELP. why is my code giving an indexoutofbounds Exception for  `TreeNode root= new TreeNode(preorder[preIndex++]);`\\n\\n\\nalso, here is my complete code\\n\\n``` \\nclass Solution {\\n    int preIndex=0;\\n    int inIndex=0;\\n    public TreeNode buildTree(int[] preorder, int[] inorder) {\\n        int inorderStart=0;\\n        int inorderEnd=inorder.length-1;\\n        return solve(preorder, inorder, inorderStart, inorderEnd);\\n    }\\n    public TreeNode solve(int[] preorder, int[] inorder, int inorderStart, int inorderEnd)\\n    {\\n        //FIRST ,  BASE CONDITION\\n        if(inorderStart>inorderEnd)\\n        {\\n            return null;\\n        }\\n        \\n\\n            //int node=;\\n            //create a node/root now\\n            TreeNode root= new TreeNode(preorder[preIndex++]);\\n\\n            //locate this root value in the inorder array\\n         inIndex=inorderStart;        // saw this in gfg code\\n         for(int i=inorderStart; i<inorder.length; i++)\\n         {\\n             if(inorder[i] == root.val)\\n             {\\n                 inIndex=i;\\n                 break;\\n             }\\n         }\\n\\n         root.left=solve(preorder, inorder, inorderStart, inIndex-1);\\n         root.right=solve(preorder, inorder, inIndex+1, inorderEnd);\\n\\n         return root;\\n    }\\n}\\n\\n```"
                    },
                    {
                        "username": "catchups",
                        "content": "will there be [2, 2, 2, 2, 2] and [2, 2, 2, 2, 2] case?"
                    },
                    {
                        "username": "catchups",
                        "content": "why there is test case like 202? "
                    },
                    {
                        "username": "lakshya05",
                        "content": "Is everyone getting a TLE at the last test case?\\nMy solution worked for 202 test cases and I couldn\\'t find the error. \\nI also compared with one of the published solutions and the logic looked sound.\\nDoesn\\'t work even upon using any of the published codes."
                    }
                ]
            },
            {
                "id": 1832216,
                "content": [
                    {
                        "username": "sjames8888",
                        "content": "pretty print Java and a few hints\\n\\nhere is a few hints on what I did - I have not looked at other solutions but this is just a few lines of code and runs in 97% of so performance rankings.  It took me a lot of thinking about and head scratching.\\n\\n1. a lookup map on both arrays is useful i.e. node value to position in array.\\n2. recursion is a natural choice where if we have a construct function taking above maps the root value for the given sub tree, the preorder array and bounds of the sub tree (initially 0 and preorder.length - 1.  left is a call to this recursive function on left bound tree to left of the root and right similar.\\n3. if (start >= end) we have no subtree so create return a node with that value at current root and return left, right are null in this case.\\n4. get 2 indices lookup the above maps we will call them inOrderIndex and preOrderIndex.\\n5. looking at the preorder array our left root in next recursive call is always next in preorder list i.e. we call outr recursive function with preorder[preOrderIndex + 1]\\n6. on right the root is preorder[preOrderIndex + nodesOnLeft + 1]\\n7. nodesOnLeft = inOrderIndex - start;\\n8. nodesOnRight = end - inOrderIndex;\\n9. on left recurive call start, end are inOrderIndex - nodesOnLeft, inOrderIndex - 1\\n10 on right recursive call inOrderIndex + 1, inOrderIndex + nodesOnRight)\\n\\n\\n\\nI wrote this to visualise the tree which you may find handy - this is a rush job so I am sure someone can do better, feel free to improve and repost.\\n\\n                3\\n            /       \\\\\\n           9        20\\n                   /   \\\\\\n                 15     7\\n                 / \\\\   / \\\\\\n               21  14 8   5\\n\\n ` @Test\\n    void case3() {\\n        final var root = new ConstructBinaryTreePreorderInorderTraversal().buildTree(new int[]{3,9,20,15,21,14,7,8,5}, new int[]{9,3,21,15,14,20,8,7,5});\\n        final var arr = root.toArray();\\n        System.out.println(root.prettyPrint());\\n    }`\\n\\n\\n  `\\n  /*\\n  place on TreeNode class\\n\\n\\n*/\\n\\n\\n   private int depth(TreeNode root, int level) {\\n        if (root == null) {\\n            return level;\\n        }\\n\\n        return Math.max(depth(root.left, level + 1), depth(root.right, level + 1));\\n    }\\n    \\n    public String prettyPrint() {\\n        return printToGrid(this);\\n    }\\n\\n    public String printToGrid(TreeNode root) {\\n        if (root == null) {\\n            return \"\";\\n        }\\n        final var depth = depth(this, 0);\\n        final var n = 2 * depth * depth;\\n        final var ca = new char[n][n];\\n        final var whiteLine = \" \".repeat(n);\\n        for (var i = 0; i < n; ++i) {\\n            ca[i] = whiteLine.toCharArray();\\n        }\\n        printToGrid(ca, root, 0, ca[0].length / 2);\\n        var sb = new StringBuilder();\\n        for (var r : ca) {\\n            final var s = new String(r).stripTrailing();\\n            if (s.equals(\"\")) {\\n                break;\\n            }\\n            sb.append(s).append(\"\\\\n\");\\n        }\\n        return sb.toString();\\n    }\\n\\n    public void printToGrid( char[][] grid, TreeNode root, int row, int col) {\\n        if (root == null) {\\n            return;\\n        }\\n        final var depth = depth(root,0);\\n        final var v = root.val;\\n        final var s = Integer.toString(v);\\n        var writeCol = col - s.length() / 2;\\n        while (writeCol < grid.length - s.length() && grid[row][writeCol] != \\' \\'\\n                || grid[row][writeCol - 1] != \\' \\') {\\n            ++writeCol;\\n        }\\n        for (var i = 0; i < s.length(); ++i) {\\n            grid[row][writeCol + i] = s.charAt(i);\\n        }\\n        final var spacing = Math.max(2, depth - (row/2) + 1);\\n        if (root.left != null) {\\n            grid[row + 1][col - spacing + 1] = \\'/\\';\\n            printToGrid(grid, root.left, row + 2, col - spacing);\\n        }\\n        if (root.right != null) {\\n            grid[row + 1][col + spacing - 1] = \\'\\\\\\\\\\';\\n            printToGrid(grid, root.right, row + 2, col + spacing);\\n        }\\n    }\\n`"
                    },
                    {
                        "username": "shaamray",
                        "content": "Can anyone clarify why Output: [3,9,20,null,null,15,7] has two null values :\\') ?"
                    },
                    {
                        "username": "sjames8888",
                        "content": "looks as below\n\n```txt\n           3\n        /       \\\n       9        20\n               /   \\\n             15     7\n```\n\n```java\n @Test\n    void case8() {\n        final var root = TreeNode.from(new Integer[]{3,9,20,null,null,15,7});\n        System.out.println(root.prettyPrint());\n    }\n```"
                    },
                    {
                        "username": "codepiyush1",
                        "content": "# Intuition\\nC++ DFS. Easy Recursive, Proper time and space complexity\\n\\n# Approach\\n\\n1. Define a function `makeTree` that takes the following parameters:\\n   - `preorder`: The preorder traversal of the tree.\\n   - `pL`: The lower index of the current range of the preorder traversal.\\n   - `pH`: The upper index of the current range of the preorder traversal.\\n   - `inorder`: The inorder traversal of the tree.\\n   - `iL`: The lower index of the current range of the inorder traversal.\\n   - `iH`: The upper index of the current range of the inorder traversal.\\n   - `mp`: An unordered map to store the mapping of values to their indices in the inorder traversal.\\n\\n2. Check if the range of indices is invalid, i.e., `pL` is greater than `pH` or `iL` is greater than `iH`. If so, return `NULL` indicating an empty subtree.\\n\\n3. Create a new `TreeNode` with the value at index `pL` in the preorder traversal as its value.\\n\\n4. Get the current index (`currInd`) of the value in the inorder traversal by looking it up in the unordered map `mp`.\\n\\n5. Calculate the number of nodes in the left subtree by subtracting `iL` from `currInd`.\\n\\n6. Recursively call the `makeTree` function to construct the left subtree by passing the following parameters:\\n   - `preorder`: Same as the input.\\n   - `pL+1`: Increment the lower index of the preorder traversal by 1.\\n   - `pL+leftNodes`: Set the upper index of the preorder traversal to `pL+leftNodes`.\\n   - `inorder`: Same as the input.\\n   - `iL`: Same as the input.\\n   - `currInd-1`: Set the upper index of the inorder traversal to `currInd-1`.\\n\\n7. Assign the returned subtree to the `left` pointer of the current node.\\n\\n8. Recursively call the `makeTree` function to construct the right subtree by passing the following parameters:\\n   - `preorder`: Same as the input.\\n   - `pL+leftNodes+1`: Set the lower index of the preorder traversal to `pL+leftNodes+1`.\\n   - `pH`: Same as the input.\\n   - `inorder`: Same as the input.\\n   - `currInd+1`: Set the lower index of the inorder traversal to `currInd+1`.\\n   - `iH`: Same as the input.\\n\\n9. Assign the returned subtree to the `right` pointer of the current node.\\n\\n10. Return the root of the constructed binary tree.\\n\\n11. Define a function `buildTree` that takes the following parameters:\\n    - `preorder`: The preorder traversal of the tree.\\n    - `inorder`: The inorder traversal of the tree.\\n\\n12. Create an unordered map `mp` to store the mapping of values to their indices in the inorder traversal.\\n\\n13. Get the size of the inorder traversal and store it in variable `n`.\\n\\n14. Iterate over the values and indices in the inorder traversal, and populate the unordered map `mp`.\\n\\n15. Call the `makeTree` function with the initial parameters:\\n    - `preorder`: Same as the input.\\n    - `0`: Set the lower index of the preorder traversal to 0.\\n    - `n-1`: Set the upper index of the preorder traversal to `n-1`.\\n    - `inorder`: Same as the input.\\n    - `0`: Set the lower index of the inorder traversal\\n\\n------------------------------------\\n# Complexity\\n- Time complexity:\\nT.C=O(n) in each recursive call one node created.\\n- Space complexity:\\nS.C=O(2n) == O(n) , n for unordered_map and n for recursive stack.\\n---------------------------------\\nPlease Upvote. If understand the concept.\\nSolution link:\\nhttps://leetcode.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal/solutions/3707300/c-dfs-easy-recursive-proper-time-and-space-complexity/\\n"
                    },
                    {
                        "username": "mochiball",
                        "content": " I struggled a lot with this problem. Felt pretty good about trees until I came to this one. It was my first divide and conquer problem but I think we can learn a lot from this problem. \\n\\nThis problem focuses on divide and conquer + recursion. Very important ! "
                    },
                    {
                        "username": "dmitriysin",
                        "content": "Example 1 `[3,9,20,null,null,15,7]` is not a binary tree since:\n1) 3 is less than 9\n2) 7 is less than 9"
                    },
                    {
                        "username": "mochiball",
                        "content": "Question is binary tree, NOT binary search tree "
                    },
                    {
                        "username": "meteahmetyakar",
                        "content": "if every node have 2 child we calls it binary tree, I think you mixed with binary search tree. In binary trees there is no value relation between nodes."
                    },
                    {
                        "username": "adgjl30102005",
                        "content": "Please help, I use the code in Editorial with this test case: pre= [4,1,3,6,8]; inorder = [6,1,8,4,3]\\nand it doesn\\'t work.\\nThe tree should look like this:\\n           4\\n        /     \\\\\\n       1       3\\n      /\\\\\\n    6    8\\nHand Calculating:\\npreorder = [4, 1, 3, 6, 8]\\nHashmap: {6:0 ; 1:1 ; 8:2 ; 4:3 ; 3:4 }\\npreorderindex = 0\\nloop 1:\\nleft = 0 right = 3\\npreorderindex = 0 => root value = 4 => new right = 2\\ntree : 4\\nloop 2:\\nleft = 0 right = 2\\npreorderindex = 1 => root value = 1 => new right = 0\\ntree: 4\\n      1\\nloop 3: \\nleft =0 right = 0\\npreorderindex = 2 => root value = 3 => new right = 3\\ntree: 4\\n      1\\n    3\\nat this step, there is already an error, and I really wonder where is the mistake?\\n"
                    },
                    {
                        "username": "Sashi_sharma",
                        "content": "This code shows Runtime Error.\\nCan anyone help!!!!!\\n\\n int preindex=0;\\n    TreeNode* Ctree(vector<int> &preorder, vector<int> &inorder,int is,int ie){\\n        if(is>ie)   return NULL;\\n        TreeNode* root=new TreeNode(preorder[preindex++]);\\n        int inIndex;\\n        for(int i=is;i<=ie;i++){\\n            if(inorder[i]==root->val){\\n                inIndex=i;\\n                break;\\n            }\\n        }\\n        root->left=Ctree(preorder,inorder,is,inIndex-1);\\n        root->right=Ctree(preorder,inorder,inIndex,ie);\\n        return root;\\n    }\\n    TreeNode* buildTree(vector<int>& preorder, vector<int>& inorder) {\\n        int n=inorder.size();\\n        int is=0;\\n        int ie=n-1;\\n        return Ctree(preorder,inorder,is,ie);\\n    }"
                    },
                    {
                        "username": "SeaShanty",
                        "content": "PLS HELP. why is my code giving an indexoutofbounds Exception for  `TreeNode root= new TreeNode(preorder[preIndex++]);`\\n\\n\\nalso, here is my complete code\\n\\n``` \\nclass Solution {\\n    int preIndex=0;\\n    int inIndex=0;\\n    public TreeNode buildTree(int[] preorder, int[] inorder) {\\n        int inorderStart=0;\\n        int inorderEnd=inorder.length-1;\\n        return solve(preorder, inorder, inorderStart, inorderEnd);\\n    }\\n    public TreeNode solve(int[] preorder, int[] inorder, int inorderStart, int inorderEnd)\\n    {\\n        //FIRST ,  BASE CONDITION\\n        if(inorderStart>inorderEnd)\\n        {\\n            return null;\\n        }\\n        \\n\\n            //int node=;\\n            //create a node/root now\\n            TreeNode root= new TreeNode(preorder[preIndex++]);\\n\\n            //locate this root value in the inorder array\\n         inIndex=inorderStart;        // saw this in gfg code\\n         for(int i=inorderStart; i<inorder.length; i++)\\n         {\\n             if(inorder[i] == root.val)\\n             {\\n                 inIndex=i;\\n                 break;\\n             }\\n         }\\n\\n         root.left=solve(preorder, inorder, inorderStart, inIndex-1);\\n         root.right=solve(preorder, inorder, inIndex+1, inorderEnd);\\n\\n         return root;\\n    }\\n}\\n\\n```"
                    },
                    {
                        "username": "catchups",
                        "content": "will there be [2, 2, 2, 2, 2] and [2, 2, 2, 2, 2] case?"
                    },
                    {
                        "username": "catchups",
                        "content": "why there is test case like 202? "
                    },
                    {
                        "username": "lakshya05",
                        "content": "Is everyone getting a TLE at the last test case?\\nMy solution worked for 202 test cases and I couldn\\'t find the error. \\nI also compared with one of the published solutions and the logic looked sound.\\nDoesn\\'t work even upon using any of the published codes."
                    }
                ]
            },
            {
                "id": 1830674,
                "content": [
                    {
                        "username": "sjames8888",
                        "content": "pretty print Java and a few hints\\n\\nhere is a few hints on what I did - I have not looked at other solutions but this is just a few lines of code and runs in 97% of so performance rankings.  It took me a lot of thinking about and head scratching.\\n\\n1. a lookup map on both arrays is useful i.e. node value to position in array.\\n2. recursion is a natural choice where if we have a construct function taking above maps the root value for the given sub tree, the preorder array and bounds of the sub tree (initially 0 and preorder.length - 1.  left is a call to this recursive function on left bound tree to left of the root and right similar.\\n3. if (start >= end) we have no subtree so create return a node with that value at current root and return left, right are null in this case.\\n4. get 2 indices lookup the above maps we will call them inOrderIndex and preOrderIndex.\\n5. looking at the preorder array our left root in next recursive call is always next in preorder list i.e. we call outr recursive function with preorder[preOrderIndex + 1]\\n6. on right the root is preorder[preOrderIndex + nodesOnLeft + 1]\\n7. nodesOnLeft = inOrderIndex - start;\\n8. nodesOnRight = end - inOrderIndex;\\n9. on left recurive call start, end are inOrderIndex - nodesOnLeft, inOrderIndex - 1\\n10 on right recursive call inOrderIndex + 1, inOrderIndex + nodesOnRight)\\n\\n\\n\\nI wrote this to visualise the tree which you may find handy - this is a rush job so I am sure someone can do better, feel free to improve and repost.\\n\\n                3\\n            /       \\\\\\n           9        20\\n                   /   \\\\\\n                 15     7\\n                 / \\\\   / \\\\\\n               21  14 8   5\\n\\n ` @Test\\n    void case3() {\\n        final var root = new ConstructBinaryTreePreorderInorderTraversal().buildTree(new int[]{3,9,20,15,21,14,7,8,5}, new int[]{9,3,21,15,14,20,8,7,5});\\n        final var arr = root.toArray();\\n        System.out.println(root.prettyPrint());\\n    }`\\n\\n\\n  `\\n  /*\\n  place on TreeNode class\\n\\n\\n*/\\n\\n\\n   private int depth(TreeNode root, int level) {\\n        if (root == null) {\\n            return level;\\n        }\\n\\n        return Math.max(depth(root.left, level + 1), depth(root.right, level + 1));\\n    }\\n    \\n    public String prettyPrint() {\\n        return printToGrid(this);\\n    }\\n\\n    public String printToGrid(TreeNode root) {\\n        if (root == null) {\\n            return \"\";\\n        }\\n        final var depth = depth(this, 0);\\n        final var n = 2 * depth * depth;\\n        final var ca = new char[n][n];\\n        final var whiteLine = \" \".repeat(n);\\n        for (var i = 0; i < n; ++i) {\\n            ca[i] = whiteLine.toCharArray();\\n        }\\n        printToGrid(ca, root, 0, ca[0].length / 2);\\n        var sb = new StringBuilder();\\n        for (var r : ca) {\\n            final var s = new String(r).stripTrailing();\\n            if (s.equals(\"\")) {\\n                break;\\n            }\\n            sb.append(s).append(\"\\\\n\");\\n        }\\n        return sb.toString();\\n    }\\n\\n    public void printToGrid( char[][] grid, TreeNode root, int row, int col) {\\n        if (root == null) {\\n            return;\\n        }\\n        final var depth = depth(root,0);\\n        final var v = root.val;\\n        final var s = Integer.toString(v);\\n        var writeCol = col - s.length() / 2;\\n        while (writeCol < grid.length - s.length() && grid[row][writeCol] != \\' \\'\\n                || grid[row][writeCol - 1] != \\' \\') {\\n            ++writeCol;\\n        }\\n        for (var i = 0; i < s.length(); ++i) {\\n            grid[row][writeCol + i] = s.charAt(i);\\n        }\\n        final var spacing = Math.max(2, depth - (row/2) + 1);\\n        if (root.left != null) {\\n            grid[row + 1][col - spacing + 1] = \\'/\\';\\n            printToGrid(grid, root.left, row + 2, col - spacing);\\n        }\\n        if (root.right != null) {\\n            grid[row + 1][col + spacing - 1] = \\'\\\\\\\\\\';\\n            printToGrid(grid, root.right, row + 2, col + spacing);\\n        }\\n    }\\n`"
                    },
                    {
                        "username": "shaamray",
                        "content": "Can anyone clarify why Output: [3,9,20,null,null,15,7] has two null values :\\') ?"
                    },
                    {
                        "username": "sjames8888",
                        "content": "looks as below\n\n```txt\n           3\n        /       \\\n       9        20\n               /   \\\n             15     7\n```\n\n```java\n @Test\n    void case8() {\n        final var root = TreeNode.from(new Integer[]{3,9,20,null,null,15,7});\n        System.out.println(root.prettyPrint());\n    }\n```"
                    },
                    {
                        "username": "codepiyush1",
                        "content": "# Intuition\\nC++ DFS. Easy Recursive, Proper time and space complexity\\n\\n# Approach\\n\\n1. Define a function `makeTree` that takes the following parameters:\\n   - `preorder`: The preorder traversal of the tree.\\n   - `pL`: The lower index of the current range of the preorder traversal.\\n   - `pH`: The upper index of the current range of the preorder traversal.\\n   - `inorder`: The inorder traversal of the tree.\\n   - `iL`: The lower index of the current range of the inorder traversal.\\n   - `iH`: The upper index of the current range of the inorder traversal.\\n   - `mp`: An unordered map to store the mapping of values to their indices in the inorder traversal.\\n\\n2. Check if the range of indices is invalid, i.e., `pL` is greater than `pH` or `iL` is greater than `iH`. If so, return `NULL` indicating an empty subtree.\\n\\n3. Create a new `TreeNode` with the value at index `pL` in the preorder traversal as its value.\\n\\n4. Get the current index (`currInd`) of the value in the inorder traversal by looking it up in the unordered map `mp`.\\n\\n5. Calculate the number of nodes in the left subtree by subtracting `iL` from `currInd`.\\n\\n6. Recursively call the `makeTree` function to construct the left subtree by passing the following parameters:\\n   - `preorder`: Same as the input.\\n   - `pL+1`: Increment the lower index of the preorder traversal by 1.\\n   - `pL+leftNodes`: Set the upper index of the preorder traversal to `pL+leftNodes`.\\n   - `inorder`: Same as the input.\\n   - `iL`: Same as the input.\\n   - `currInd-1`: Set the upper index of the inorder traversal to `currInd-1`.\\n\\n7. Assign the returned subtree to the `left` pointer of the current node.\\n\\n8. Recursively call the `makeTree` function to construct the right subtree by passing the following parameters:\\n   - `preorder`: Same as the input.\\n   - `pL+leftNodes+1`: Set the lower index of the preorder traversal to `pL+leftNodes+1`.\\n   - `pH`: Same as the input.\\n   - `inorder`: Same as the input.\\n   - `currInd+1`: Set the lower index of the inorder traversal to `currInd+1`.\\n   - `iH`: Same as the input.\\n\\n9. Assign the returned subtree to the `right` pointer of the current node.\\n\\n10. Return the root of the constructed binary tree.\\n\\n11. Define a function `buildTree` that takes the following parameters:\\n    - `preorder`: The preorder traversal of the tree.\\n    - `inorder`: The inorder traversal of the tree.\\n\\n12. Create an unordered map `mp` to store the mapping of values to their indices in the inorder traversal.\\n\\n13. Get the size of the inorder traversal and store it in variable `n`.\\n\\n14. Iterate over the values and indices in the inorder traversal, and populate the unordered map `mp`.\\n\\n15. Call the `makeTree` function with the initial parameters:\\n    - `preorder`: Same as the input.\\n    - `0`: Set the lower index of the preorder traversal to 0.\\n    - `n-1`: Set the upper index of the preorder traversal to `n-1`.\\n    - `inorder`: Same as the input.\\n    - `0`: Set the lower index of the inorder traversal\\n\\n------------------------------------\\n# Complexity\\n- Time complexity:\\nT.C=O(n) in each recursive call one node created.\\n- Space complexity:\\nS.C=O(2n) == O(n) , n for unordered_map and n for recursive stack.\\n---------------------------------\\nPlease Upvote. If understand the concept.\\nSolution link:\\nhttps://leetcode.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal/solutions/3707300/c-dfs-easy-recursive-proper-time-and-space-complexity/\\n"
                    },
                    {
                        "username": "mochiball",
                        "content": " I struggled a lot with this problem. Felt pretty good about trees until I came to this one. It was my first divide and conquer problem but I think we can learn a lot from this problem. \\n\\nThis problem focuses on divide and conquer + recursion. Very important ! "
                    },
                    {
                        "username": "dmitriysin",
                        "content": "Example 1 `[3,9,20,null,null,15,7]` is not a binary tree since:\n1) 3 is less than 9\n2) 7 is less than 9"
                    },
                    {
                        "username": "mochiball",
                        "content": "Question is binary tree, NOT binary search tree "
                    },
                    {
                        "username": "meteahmetyakar",
                        "content": "if every node have 2 child we calls it binary tree, I think you mixed with binary search tree. In binary trees there is no value relation between nodes."
                    },
                    {
                        "username": "adgjl30102005",
                        "content": "Please help, I use the code in Editorial with this test case: pre= [4,1,3,6,8]; inorder = [6,1,8,4,3]\\nand it doesn\\'t work.\\nThe tree should look like this:\\n           4\\n        /     \\\\\\n       1       3\\n      /\\\\\\n    6    8\\nHand Calculating:\\npreorder = [4, 1, 3, 6, 8]\\nHashmap: {6:0 ; 1:1 ; 8:2 ; 4:3 ; 3:4 }\\npreorderindex = 0\\nloop 1:\\nleft = 0 right = 3\\npreorderindex = 0 => root value = 4 => new right = 2\\ntree : 4\\nloop 2:\\nleft = 0 right = 2\\npreorderindex = 1 => root value = 1 => new right = 0\\ntree: 4\\n      1\\nloop 3: \\nleft =0 right = 0\\npreorderindex = 2 => root value = 3 => new right = 3\\ntree: 4\\n      1\\n    3\\nat this step, there is already an error, and I really wonder where is the mistake?\\n"
                    },
                    {
                        "username": "Sashi_sharma",
                        "content": "This code shows Runtime Error.\\nCan anyone help!!!!!\\n\\n int preindex=0;\\n    TreeNode* Ctree(vector<int> &preorder, vector<int> &inorder,int is,int ie){\\n        if(is>ie)   return NULL;\\n        TreeNode* root=new TreeNode(preorder[preindex++]);\\n        int inIndex;\\n        for(int i=is;i<=ie;i++){\\n            if(inorder[i]==root->val){\\n                inIndex=i;\\n                break;\\n            }\\n        }\\n        root->left=Ctree(preorder,inorder,is,inIndex-1);\\n        root->right=Ctree(preorder,inorder,inIndex,ie);\\n        return root;\\n    }\\n    TreeNode* buildTree(vector<int>& preorder, vector<int>& inorder) {\\n        int n=inorder.size();\\n        int is=0;\\n        int ie=n-1;\\n        return Ctree(preorder,inorder,is,ie);\\n    }"
                    },
                    {
                        "username": "SeaShanty",
                        "content": "PLS HELP. why is my code giving an indexoutofbounds Exception for  `TreeNode root= new TreeNode(preorder[preIndex++]);`\\n\\n\\nalso, here is my complete code\\n\\n``` \\nclass Solution {\\n    int preIndex=0;\\n    int inIndex=0;\\n    public TreeNode buildTree(int[] preorder, int[] inorder) {\\n        int inorderStart=0;\\n        int inorderEnd=inorder.length-1;\\n        return solve(preorder, inorder, inorderStart, inorderEnd);\\n    }\\n    public TreeNode solve(int[] preorder, int[] inorder, int inorderStart, int inorderEnd)\\n    {\\n        //FIRST ,  BASE CONDITION\\n        if(inorderStart>inorderEnd)\\n        {\\n            return null;\\n        }\\n        \\n\\n            //int node=;\\n            //create a node/root now\\n            TreeNode root= new TreeNode(preorder[preIndex++]);\\n\\n            //locate this root value in the inorder array\\n         inIndex=inorderStart;        // saw this in gfg code\\n         for(int i=inorderStart; i<inorder.length; i++)\\n         {\\n             if(inorder[i] == root.val)\\n             {\\n                 inIndex=i;\\n                 break;\\n             }\\n         }\\n\\n         root.left=solve(preorder, inorder, inorderStart, inIndex-1);\\n         root.right=solve(preorder, inorder, inIndex+1, inorderEnd);\\n\\n         return root;\\n    }\\n}\\n\\n```"
                    },
                    {
                        "username": "catchups",
                        "content": "will there be [2, 2, 2, 2, 2] and [2, 2, 2, 2, 2] case?"
                    },
                    {
                        "username": "catchups",
                        "content": "why there is test case like 202? "
                    },
                    {
                        "username": "lakshya05",
                        "content": "Is everyone getting a TLE at the last test case?\\nMy solution worked for 202 test cases and I couldn\\'t find the error. \\nI also compared with one of the published solutions and the logic looked sound.\\nDoesn\\'t work even upon using any of the published codes."
                    }
                ]
            },
            {
                "id": 1821866,
                "content": [
                    {
                        "username": "odinlake",
                        "content": "I had missed this crucial information, which is not generally in the definition of a binary tree but without which the problem wouldn\\'t always have a unique solutmion: \"preorder and inorder consist of unique values.\"  Now it became rather easy."
                    },
                    {
                        "username": "hitchens23",
                        "content": "does anyone know why this custom testcase returns invalid tree?\\n\\npreorder: ```[1,2,3,4,5,6,7]```\\ninorder: ```[2,1,6,4,7,3,5]```"
                    },
                    {
                        "username": "steeewtOverflow",
                        "content": " TreeNode* construct(vector<int>& preorder,int lowerl,int upperl,int &preorderIndex,map<int,int> mp)\\n    {\\n        if(upperl<lowerl)   return NULL;\\n        int val=preorder[preorderIndex++];\\n        TreeNode* root=new TreeNode(val);\\n        root->left=construct(preorder,lowerl,mp[val]-1,preorderIndex,mp);\\n        root->right=construct(preorder,mp[val]+1,upperl,preorderIndex,mp);\\n\\n        return root;\\n    }\\n\\n    TreeNode* buildTree(vector<int>& preorder, vector<int>& inorder) {\\n        int preorderIndex=0;\\n        map<int,int> mp;\\n        for(int i=0;i<inorder.size();i++)\\n        {\\n            mp.insert({inorder[i],i});\\n        }\\n        return construct(preorder,0,inorder.size()-1,preorderIndex,mp);\\n        \\n    }\\n\\nthe code gives TLE at 202/203 test cases. Help"
                    },
                    {
                        "username": "hdrwilkinson",
                        "content": "I\\'m admittedly not that good at these LeetCode puzzles and so am really happy to have solved this one. What really helped me was using pen and paper to map out what was happening. Take the example preorder = [3,9,20,15,7] and experiment with different tree structures, noting down the inorder for each structure. Then try to work out if there is a pattern. Once you find it, write it out in full and then code it."
                    },
                    {
                        "username": "jacksonyyy",
                        "content": "honestly, I don\\'t see the difficult of this question, its just using  the template of creating tree, if you r familiar with the 3 types (2 in this question) traversal, it\\'s about to be obvious to you  "
                    },
                    {
                        "username": "naararouter",
                        "content": "Maybe I don't understand something...but the next input looks like correct:\npreorder: [3,9,20,2,15,7]\ninorder: [9,2,3,15,20,7]\nBut the Leetcode throws TLE despite I return null at the first line of the solution, obviously I expect just wrong answer:\n```javascript\nvar buildTree = function(preorder, inorder) {\n    return null;\n}\n```\nWhat am I missing?"
                    },
                    {
                        "username": "c4tdog",
                        "content": "for inorder [9,2,3,15,20,7] preopder must be [3,9,2,20,15,7]\nso, your input in invalid"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/61i-qpZSfyg"
                    },
                    {
                        "username": "aggarwalmukul96",
                        "content": "202 TEST CASES PASSED OUT SHOWING TLE ON LAST CASE CAN ANYONE HELP????    : -/\n\n\n\nclass Solution {\npublic:\n    TreeNode* buildTree(vector<int>& preorder, vector<int>& inorder) {\n        unordered_map<int,int>m;\n        for(int i=0;i<inorder.size();i++)\n        m[inorder[i]]=i;\n        TreeNode*root=buildTree(preorder,0,preorder.size()-1,inorder,0,inorder.size()-1,m);\n        return root;\n    }\n    TreeNode*buildTree(vector<int>pre,int pstart,int pend,vector<int>in,int instart,int inend,unordered_map<int,int>m)\n    {\n        if(pstart>pend ||instart>inend)\n        return NULL;\n        TreeNode*root= new TreeNode(pre[pstart]);\n        int inroot=m[root->val];\n        int numleft=inroot-instart;\n        root->left=buildTree(pre,pstart+1,pstart+numleft,in,instart,inroot-1,m);\n        root->right=buildTree(pre,pstart+numleft+1,pend,in,inroot+1,inend,m);\n        return root;\n    }\n};"
                    },
                    {
                        "username": "its_me_3011ar",
                        "content": "[@aggarwalmukul96](/aggarwalmukul96)  welcome bro .. solutions he upvote krdo mere ;) lol"
                    },
                    {
                        "username": "aggarwalmukul96",
                        "content": "[@rayusahil](/rayusahil) thanx buddy"
                    },
                    {
                        "username": "its_me_3011ar",
                        "content": "pass map by reference  it will work"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "mgeek",
                        "content": "Simple O(n) Java solution without pre-Index calculation\\n\\n ` public TreeNode buildTree(int[] pre, int[] in) {\\n\\n       Map<Integer, Integer> map = new HashMap<>();\\n       for(int i =0; i < in.length; i++ ){\\n           map.put(in[i], i);\\n       } \\n        int preStart [] = new int[1];\\n       return build(in, pre, 0, in.length-1, preStart, map);\\n    }\\n\\n    private TreeNode build(int[] in, int[] pre, int inStart, int inEnd, int preStart [], Map<Integer, Integer> map) {\\n        if(inStart > inEnd){\\n            return null;\\n        }\\n        int preIndex = preStart[0]++;\\n        if( preIndex >= pre.length){\\n            return null;\\n        }\\n        int x = pre[preIndex];\\n        int index = map.get(x);\\n        TreeNode node = new TreeNode(x);\\n        if(inStart == inEnd){\\n            return node;\\n        }\\n        node.left = build(in, pre, inStart, index-1, preStart, map);\\n        node.right = build(in, pre, index+1, inEnd, preStart, map);\\n        return node;\\n    }`"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Simple Leetcode rules.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    }
                ]
            },
            {
                "id": 1803294,
                "content": [
                    {
                        "username": "odinlake",
                        "content": "I had missed this crucial information, which is not generally in the definition of a binary tree but without which the problem wouldn\\'t always have a unique solutmion: \"preorder and inorder consist of unique values.\"  Now it became rather easy."
                    },
                    {
                        "username": "hitchens23",
                        "content": "does anyone know why this custom testcase returns invalid tree?\\n\\npreorder: ```[1,2,3,4,5,6,7]```\\ninorder: ```[2,1,6,4,7,3,5]```"
                    },
                    {
                        "username": "steeewtOverflow",
                        "content": " TreeNode* construct(vector<int>& preorder,int lowerl,int upperl,int &preorderIndex,map<int,int> mp)\\n    {\\n        if(upperl<lowerl)   return NULL;\\n        int val=preorder[preorderIndex++];\\n        TreeNode* root=new TreeNode(val);\\n        root->left=construct(preorder,lowerl,mp[val]-1,preorderIndex,mp);\\n        root->right=construct(preorder,mp[val]+1,upperl,preorderIndex,mp);\\n\\n        return root;\\n    }\\n\\n    TreeNode* buildTree(vector<int>& preorder, vector<int>& inorder) {\\n        int preorderIndex=0;\\n        map<int,int> mp;\\n        for(int i=0;i<inorder.size();i++)\\n        {\\n            mp.insert({inorder[i],i});\\n        }\\n        return construct(preorder,0,inorder.size()-1,preorderIndex,mp);\\n        \\n    }\\n\\nthe code gives TLE at 202/203 test cases. Help"
                    },
                    {
                        "username": "hdrwilkinson",
                        "content": "I\\'m admittedly not that good at these LeetCode puzzles and so am really happy to have solved this one. What really helped me was using pen and paper to map out what was happening. Take the example preorder = [3,9,20,15,7] and experiment with different tree structures, noting down the inorder for each structure. Then try to work out if there is a pattern. Once you find it, write it out in full and then code it."
                    },
                    {
                        "username": "jacksonyyy",
                        "content": "honestly, I don\\'t see the difficult of this question, its just using  the template of creating tree, if you r familiar with the 3 types (2 in this question) traversal, it\\'s about to be obvious to you  "
                    },
                    {
                        "username": "naararouter",
                        "content": "Maybe I don't understand something...but the next input looks like correct:\npreorder: [3,9,20,2,15,7]\ninorder: [9,2,3,15,20,7]\nBut the Leetcode throws TLE despite I return null at the first line of the solution, obviously I expect just wrong answer:\n```javascript\nvar buildTree = function(preorder, inorder) {\n    return null;\n}\n```\nWhat am I missing?"
                    },
                    {
                        "username": "c4tdog",
                        "content": "for inorder [9,2,3,15,20,7] preopder must be [3,9,2,20,15,7]\nso, your input in invalid"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/61i-qpZSfyg"
                    },
                    {
                        "username": "aggarwalmukul96",
                        "content": "202 TEST CASES PASSED OUT SHOWING TLE ON LAST CASE CAN ANYONE HELP????    : -/\n\n\n\nclass Solution {\npublic:\n    TreeNode* buildTree(vector<int>& preorder, vector<int>& inorder) {\n        unordered_map<int,int>m;\n        for(int i=0;i<inorder.size();i++)\n        m[inorder[i]]=i;\n        TreeNode*root=buildTree(preorder,0,preorder.size()-1,inorder,0,inorder.size()-1,m);\n        return root;\n    }\n    TreeNode*buildTree(vector<int>pre,int pstart,int pend,vector<int>in,int instart,int inend,unordered_map<int,int>m)\n    {\n        if(pstart>pend ||instart>inend)\n        return NULL;\n        TreeNode*root= new TreeNode(pre[pstart]);\n        int inroot=m[root->val];\n        int numleft=inroot-instart;\n        root->left=buildTree(pre,pstart+1,pstart+numleft,in,instart,inroot-1,m);\n        root->right=buildTree(pre,pstart+numleft+1,pend,in,inroot+1,inend,m);\n        return root;\n    }\n};"
                    },
                    {
                        "username": "its_me_3011ar",
                        "content": "[@aggarwalmukul96](/aggarwalmukul96)  welcome bro .. solutions he upvote krdo mere ;) lol"
                    },
                    {
                        "username": "aggarwalmukul96",
                        "content": "[@rayusahil](/rayusahil) thanx buddy"
                    },
                    {
                        "username": "its_me_3011ar",
                        "content": "pass map by reference  it will work"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "mgeek",
                        "content": "Simple O(n) Java solution without pre-Index calculation\\n\\n ` public TreeNode buildTree(int[] pre, int[] in) {\\n\\n       Map<Integer, Integer> map = new HashMap<>();\\n       for(int i =0; i < in.length; i++ ){\\n           map.put(in[i], i);\\n       } \\n        int preStart [] = new int[1];\\n       return build(in, pre, 0, in.length-1, preStart, map);\\n    }\\n\\n    private TreeNode build(int[] in, int[] pre, int inStart, int inEnd, int preStart [], Map<Integer, Integer> map) {\\n        if(inStart > inEnd){\\n            return null;\\n        }\\n        int preIndex = preStart[0]++;\\n        if( preIndex >= pre.length){\\n            return null;\\n        }\\n        int x = pre[preIndex];\\n        int index = map.get(x);\\n        TreeNode node = new TreeNode(x);\\n        if(inStart == inEnd){\\n            return node;\\n        }\\n        node.left = build(in, pre, inStart, index-1, preStart, map);\\n        node.right = build(in, pre, index+1, inEnd, preStart, map);\\n        return node;\\n    }`"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Simple Leetcode rules.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    }
                ]
            },
            {
                "id": 1803287,
                "content": [
                    {
                        "username": "odinlake",
                        "content": "I had missed this crucial information, which is not generally in the definition of a binary tree but without which the problem wouldn\\'t always have a unique solutmion: \"preorder and inorder consist of unique values.\"  Now it became rather easy."
                    },
                    {
                        "username": "hitchens23",
                        "content": "does anyone know why this custom testcase returns invalid tree?\\n\\npreorder: ```[1,2,3,4,5,6,7]```\\ninorder: ```[2,1,6,4,7,3,5]```"
                    },
                    {
                        "username": "steeewtOverflow",
                        "content": " TreeNode* construct(vector<int>& preorder,int lowerl,int upperl,int &preorderIndex,map<int,int> mp)\\n    {\\n        if(upperl<lowerl)   return NULL;\\n        int val=preorder[preorderIndex++];\\n        TreeNode* root=new TreeNode(val);\\n        root->left=construct(preorder,lowerl,mp[val]-1,preorderIndex,mp);\\n        root->right=construct(preorder,mp[val]+1,upperl,preorderIndex,mp);\\n\\n        return root;\\n    }\\n\\n    TreeNode* buildTree(vector<int>& preorder, vector<int>& inorder) {\\n        int preorderIndex=0;\\n        map<int,int> mp;\\n        for(int i=0;i<inorder.size();i++)\\n        {\\n            mp.insert({inorder[i],i});\\n        }\\n        return construct(preorder,0,inorder.size()-1,preorderIndex,mp);\\n        \\n    }\\n\\nthe code gives TLE at 202/203 test cases. Help"
                    },
                    {
                        "username": "hdrwilkinson",
                        "content": "I\\'m admittedly not that good at these LeetCode puzzles and so am really happy to have solved this one. What really helped me was using pen and paper to map out what was happening. Take the example preorder = [3,9,20,15,7] and experiment with different tree structures, noting down the inorder for each structure. Then try to work out if there is a pattern. Once you find it, write it out in full and then code it."
                    },
                    {
                        "username": "jacksonyyy",
                        "content": "honestly, I don\\'t see the difficult of this question, its just using  the template of creating tree, if you r familiar with the 3 types (2 in this question) traversal, it\\'s about to be obvious to you  "
                    },
                    {
                        "username": "naararouter",
                        "content": "Maybe I don't understand something...but the next input looks like correct:\npreorder: [3,9,20,2,15,7]\ninorder: [9,2,3,15,20,7]\nBut the Leetcode throws TLE despite I return null at the first line of the solution, obviously I expect just wrong answer:\n```javascript\nvar buildTree = function(preorder, inorder) {\n    return null;\n}\n```\nWhat am I missing?"
                    },
                    {
                        "username": "c4tdog",
                        "content": "for inorder [9,2,3,15,20,7] preopder must be [3,9,2,20,15,7]\nso, your input in invalid"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/61i-qpZSfyg"
                    },
                    {
                        "username": "aggarwalmukul96",
                        "content": "202 TEST CASES PASSED OUT SHOWING TLE ON LAST CASE CAN ANYONE HELP????    : -/\n\n\n\nclass Solution {\npublic:\n    TreeNode* buildTree(vector<int>& preorder, vector<int>& inorder) {\n        unordered_map<int,int>m;\n        for(int i=0;i<inorder.size();i++)\n        m[inorder[i]]=i;\n        TreeNode*root=buildTree(preorder,0,preorder.size()-1,inorder,0,inorder.size()-1,m);\n        return root;\n    }\n    TreeNode*buildTree(vector<int>pre,int pstart,int pend,vector<int>in,int instart,int inend,unordered_map<int,int>m)\n    {\n        if(pstart>pend ||instart>inend)\n        return NULL;\n        TreeNode*root= new TreeNode(pre[pstart]);\n        int inroot=m[root->val];\n        int numleft=inroot-instart;\n        root->left=buildTree(pre,pstart+1,pstart+numleft,in,instart,inroot-1,m);\n        root->right=buildTree(pre,pstart+numleft+1,pend,in,inroot+1,inend,m);\n        return root;\n    }\n};"
                    },
                    {
                        "username": "its_me_3011ar",
                        "content": "[@aggarwalmukul96](/aggarwalmukul96)  welcome bro .. solutions he upvote krdo mere ;) lol"
                    },
                    {
                        "username": "aggarwalmukul96",
                        "content": "[@rayusahil](/rayusahil) thanx buddy"
                    },
                    {
                        "username": "its_me_3011ar",
                        "content": "pass map by reference  it will work"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "mgeek",
                        "content": "Simple O(n) Java solution without pre-Index calculation\\n\\n ` public TreeNode buildTree(int[] pre, int[] in) {\\n\\n       Map<Integer, Integer> map = new HashMap<>();\\n       for(int i =0; i < in.length; i++ ){\\n           map.put(in[i], i);\\n       } \\n        int preStart [] = new int[1];\\n       return build(in, pre, 0, in.length-1, preStart, map);\\n    }\\n\\n    private TreeNode build(int[] in, int[] pre, int inStart, int inEnd, int preStart [], Map<Integer, Integer> map) {\\n        if(inStart > inEnd){\\n            return null;\\n        }\\n        int preIndex = preStart[0]++;\\n        if( preIndex >= pre.length){\\n            return null;\\n        }\\n        int x = pre[preIndex];\\n        int index = map.get(x);\\n        TreeNode node = new TreeNode(x);\\n        if(inStart == inEnd){\\n            return node;\\n        }\\n        node.left = build(in, pre, inStart, index-1, preStart, map);\\n        node.right = build(in, pre, index+1, inEnd, preStart, map);\\n        return node;\\n    }`"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Simple Leetcode rules.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    }
                ]
            },
            {
                "id": 1800861,
                "content": [
                    {
                        "username": "odinlake",
                        "content": "I had missed this crucial information, which is not generally in the definition of a binary tree but without which the problem wouldn\\'t always have a unique solutmion: \"preorder and inorder consist of unique values.\"  Now it became rather easy."
                    },
                    {
                        "username": "hitchens23",
                        "content": "does anyone know why this custom testcase returns invalid tree?\\n\\npreorder: ```[1,2,3,4,5,6,7]```\\ninorder: ```[2,1,6,4,7,3,5]```"
                    },
                    {
                        "username": "steeewtOverflow",
                        "content": " TreeNode* construct(vector<int>& preorder,int lowerl,int upperl,int &preorderIndex,map<int,int> mp)\\n    {\\n        if(upperl<lowerl)   return NULL;\\n        int val=preorder[preorderIndex++];\\n        TreeNode* root=new TreeNode(val);\\n        root->left=construct(preorder,lowerl,mp[val]-1,preorderIndex,mp);\\n        root->right=construct(preorder,mp[val]+1,upperl,preorderIndex,mp);\\n\\n        return root;\\n    }\\n\\n    TreeNode* buildTree(vector<int>& preorder, vector<int>& inorder) {\\n        int preorderIndex=0;\\n        map<int,int> mp;\\n        for(int i=0;i<inorder.size();i++)\\n        {\\n            mp.insert({inorder[i],i});\\n        }\\n        return construct(preorder,0,inorder.size()-1,preorderIndex,mp);\\n        \\n    }\\n\\nthe code gives TLE at 202/203 test cases. Help"
                    },
                    {
                        "username": "hdrwilkinson",
                        "content": "I\\'m admittedly not that good at these LeetCode puzzles and so am really happy to have solved this one. What really helped me was using pen and paper to map out what was happening. Take the example preorder = [3,9,20,15,7] and experiment with different tree structures, noting down the inorder for each structure. Then try to work out if there is a pattern. Once you find it, write it out in full and then code it."
                    },
                    {
                        "username": "jacksonyyy",
                        "content": "honestly, I don\\'t see the difficult of this question, its just using  the template of creating tree, if you r familiar with the 3 types (2 in this question) traversal, it\\'s about to be obvious to you  "
                    },
                    {
                        "username": "naararouter",
                        "content": "Maybe I don't understand something...but the next input looks like correct:\npreorder: [3,9,20,2,15,7]\ninorder: [9,2,3,15,20,7]\nBut the Leetcode throws TLE despite I return null at the first line of the solution, obviously I expect just wrong answer:\n```javascript\nvar buildTree = function(preorder, inorder) {\n    return null;\n}\n```\nWhat am I missing?"
                    },
                    {
                        "username": "c4tdog",
                        "content": "for inorder [9,2,3,15,20,7] preopder must be [3,9,2,20,15,7]\nso, your input in invalid"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/61i-qpZSfyg"
                    },
                    {
                        "username": "aggarwalmukul96",
                        "content": "202 TEST CASES PASSED OUT SHOWING TLE ON LAST CASE CAN ANYONE HELP????    : -/\n\n\n\nclass Solution {\npublic:\n    TreeNode* buildTree(vector<int>& preorder, vector<int>& inorder) {\n        unordered_map<int,int>m;\n        for(int i=0;i<inorder.size();i++)\n        m[inorder[i]]=i;\n        TreeNode*root=buildTree(preorder,0,preorder.size()-1,inorder,0,inorder.size()-1,m);\n        return root;\n    }\n    TreeNode*buildTree(vector<int>pre,int pstart,int pend,vector<int>in,int instart,int inend,unordered_map<int,int>m)\n    {\n        if(pstart>pend ||instart>inend)\n        return NULL;\n        TreeNode*root= new TreeNode(pre[pstart]);\n        int inroot=m[root->val];\n        int numleft=inroot-instart;\n        root->left=buildTree(pre,pstart+1,pstart+numleft,in,instart,inroot-1,m);\n        root->right=buildTree(pre,pstart+numleft+1,pend,in,inroot+1,inend,m);\n        return root;\n    }\n};"
                    },
                    {
                        "username": "its_me_3011ar",
                        "content": "[@aggarwalmukul96](/aggarwalmukul96)  welcome bro .. solutions he upvote krdo mere ;) lol"
                    },
                    {
                        "username": "aggarwalmukul96",
                        "content": "[@rayusahil](/rayusahil) thanx buddy"
                    },
                    {
                        "username": "its_me_3011ar",
                        "content": "pass map by reference  it will work"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "mgeek",
                        "content": "Simple O(n) Java solution without pre-Index calculation\\n\\n ` public TreeNode buildTree(int[] pre, int[] in) {\\n\\n       Map<Integer, Integer> map = new HashMap<>();\\n       for(int i =0; i < in.length; i++ ){\\n           map.put(in[i], i);\\n       } \\n        int preStart [] = new int[1];\\n       return build(in, pre, 0, in.length-1, preStart, map);\\n    }\\n\\n    private TreeNode build(int[] in, int[] pre, int inStart, int inEnd, int preStart [], Map<Integer, Integer> map) {\\n        if(inStart > inEnd){\\n            return null;\\n        }\\n        int preIndex = preStart[0]++;\\n        if( preIndex >= pre.length){\\n            return null;\\n        }\\n        int x = pre[preIndex];\\n        int index = map.get(x);\\n        TreeNode node = new TreeNode(x);\\n        if(inStart == inEnd){\\n            return node;\\n        }\\n        node.left = build(in, pre, inStart, index-1, preStart, map);\\n        node.right = build(in, pre, index+1, inEnd, preStart, map);\\n        return node;\\n    }`"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Simple Leetcode rules.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    }
                ]
            },
            {
                "id": 1768518,
                "content": [
                    {
                        "username": "odinlake",
                        "content": "I had missed this crucial information, which is not generally in the definition of a binary tree but without which the problem wouldn\\'t always have a unique solutmion: \"preorder and inorder consist of unique values.\"  Now it became rather easy."
                    },
                    {
                        "username": "hitchens23",
                        "content": "does anyone know why this custom testcase returns invalid tree?\\n\\npreorder: ```[1,2,3,4,5,6,7]```\\ninorder: ```[2,1,6,4,7,3,5]```"
                    },
                    {
                        "username": "steeewtOverflow",
                        "content": " TreeNode* construct(vector<int>& preorder,int lowerl,int upperl,int &preorderIndex,map<int,int> mp)\\n    {\\n        if(upperl<lowerl)   return NULL;\\n        int val=preorder[preorderIndex++];\\n        TreeNode* root=new TreeNode(val);\\n        root->left=construct(preorder,lowerl,mp[val]-1,preorderIndex,mp);\\n        root->right=construct(preorder,mp[val]+1,upperl,preorderIndex,mp);\\n\\n        return root;\\n    }\\n\\n    TreeNode* buildTree(vector<int>& preorder, vector<int>& inorder) {\\n        int preorderIndex=0;\\n        map<int,int> mp;\\n        for(int i=0;i<inorder.size();i++)\\n        {\\n            mp.insert({inorder[i],i});\\n        }\\n        return construct(preorder,0,inorder.size()-1,preorderIndex,mp);\\n        \\n    }\\n\\nthe code gives TLE at 202/203 test cases. Help"
                    },
                    {
                        "username": "hdrwilkinson",
                        "content": "I\\'m admittedly not that good at these LeetCode puzzles and so am really happy to have solved this one. What really helped me was using pen and paper to map out what was happening. Take the example preorder = [3,9,20,15,7] and experiment with different tree structures, noting down the inorder for each structure. Then try to work out if there is a pattern. Once you find it, write it out in full and then code it."
                    },
                    {
                        "username": "jacksonyyy",
                        "content": "honestly, I don\\'t see the difficult of this question, its just using  the template of creating tree, if you r familiar with the 3 types (2 in this question) traversal, it\\'s about to be obvious to you  "
                    },
                    {
                        "username": "naararouter",
                        "content": "Maybe I don't understand something...but the next input looks like correct:\npreorder: [3,9,20,2,15,7]\ninorder: [9,2,3,15,20,7]\nBut the Leetcode throws TLE despite I return null at the first line of the solution, obviously I expect just wrong answer:\n```javascript\nvar buildTree = function(preorder, inorder) {\n    return null;\n}\n```\nWhat am I missing?"
                    },
                    {
                        "username": "c4tdog",
                        "content": "for inorder [9,2,3,15,20,7] preopder must be [3,9,2,20,15,7]\nso, your input in invalid"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/61i-qpZSfyg"
                    },
                    {
                        "username": "aggarwalmukul96",
                        "content": "202 TEST CASES PASSED OUT SHOWING TLE ON LAST CASE CAN ANYONE HELP????    : -/\n\n\n\nclass Solution {\npublic:\n    TreeNode* buildTree(vector<int>& preorder, vector<int>& inorder) {\n        unordered_map<int,int>m;\n        for(int i=0;i<inorder.size();i++)\n        m[inorder[i]]=i;\n        TreeNode*root=buildTree(preorder,0,preorder.size()-1,inorder,0,inorder.size()-1,m);\n        return root;\n    }\n    TreeNode*buildTree(vector<int>pre,int pstart,int pend,vector<int>in,int instart,int inend,unordered_map<int,int>m)\n    {\n        if(pstart>pend ||instart>inend)\n        return NULL;\n        TreeNode*root= new TreeNode(pre[pstart]);\n        int inroot=m[root->val];\n        int numleft=inroot-instart;\n        root->left=buildTree(pre,pstart+1,pstart+numleft,in,instart,inroot-1,m);\n        root->right=buildTree(pre,pstart+numleft+1,pend,in,inroot+1,inend,m);\n        return root;\n    }\n};"
                    },
                    {
                        "username": "its_me_3011ar",
                        "content": "[@aggarwalmukul96](/aggarwalmukul96)  welcome bro .. solutions he upvote krdo mere ;) lol"
                    },
                    {
                        "username": "aggarwalmukul96",
                        "content": "[@rayusahil](/rayusahil) thanx buddy"
                    },
                    {
                        "username": "its_me_3011ar",
                        "content": "pass map by reference  it will work"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "mgeek",
                        "content": "Simple O(n) Java solution without pre-Index calculation\\n\\n ` public TreeNode buildTree(int[] pre, int[] in) {\\n\\n       Map<Integer, Integer> map = new HashMap<>();\\n       for(int i =0; i < in.length; i++ ){\\n           map.put(in[i], i);\\n       } \\n        int preStart [] = new int[1];\\n       return build(in, pre, 0, in.length-1, preStart, map);\\n    }\\n\\n    private TreeNode build(int[] in, int[] pre, int inStart, int inEnd, int preStart [], Map<Integer, Integer> map) {\\n        if(inStart > inEnd){\\n            return null;\\n        }\\n        int preIndex = preStart[0]++;\\n        if( preIndex >= pre.length){\\n            return null;\\n        }\\n        int x = pre[preIndex];\\n        int index = map.get(x);\\n        TreeNode node = new TreeNode(x);\\n        if(inStart == inEnd){\\n            return node;\\n        }\\n        node.left = build(in, pre, inStart, index-1, preStart, map);\\n        node.right = build(in, pre, index+1, inEnd, preStart, map);\\n        return node;\\n    }`"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Simple Leetcode rules.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    }
                ]
            },
            {
                "id": 1768482,
                "content": [
                    {
                        "username": "odinlake",
                        "content": "I had missed this crucial information, which is not generally in the definition of a binary tree but without which the problem wouldn\\'t always have a unique solutmion: \"preorder and inorder consist of unique values.\"  Now it became rather easy."
                    },
                    {
                        "username": "hitchens23",
                        "content": "does anyone know why this custom testcase returns invalid tree?\\n\\npreorder: ```[1,2,3,4,5,6,7]```\\ninorder: ```[2,1,6,4,7,3,5]```"
                    },
                    {
                        "username": "steeewtOverflow",
                        "content": " TreeNode* construct(vector<int>& preorder,int lowerl,int upperl,int &preorderIndex,map<int,int> mp)\\n    {\\n        if(upperl<lowerl)   return NULL;\\n        int val=preorder[preorderIndex++];\\n        TreeNode* root=new TreeNode(val);\\n        root->left=construct(preorder,lowerl,mp[val]-1,preorderIndex,mp);\\n        root->right=construct(preorder,mp[val]+1,upperl,preorderIndex,mp);\\n\\n        return root;\\n    }\\n\\n    TreeNode* buildTree(vector<int>& preorder, vector<int>& inorder) {\\n        int preorderIndex=0;\\n        map<int,int> mp;\\n        for(int i=0;i<inorder.size();i++)\\n        {\\n            mp.insert({inorder[i],i});\\n        }\\n        return construct(preorder,0,inorder.size()-1,preorderIndex,mp);\\n        \\n    }\\n\\nthe code gives TLE at 202/203 test cases. Help"
                    },
                    {
                        "username": "hdrwilkinson",
                        "content": "I\\'m admittedly not that good at these LeetCode puzzles and so am really happy to have solved this one. What really helped me was using pen and paper to map out what was happening. Take the example preorder = [3,9,20,15,7] and experiment with different tree structures, noting down the inorder for each structure. Then try to work out if there is a pattern. Once you find it, write it out in full and then code it."
                    },
                    {
                        "username": "jacksonyyy",
                        "content": "honestly, I don\\'t see the difficult of this question, its just using  the template of creating tree, if you r familiar with the 3 types (2 in this question) traversal, it\\'s about to be obvious to you  "
                    },
                    {
                        "username": "naararouter",
                        "content": "Maybe I don't understand something...but the next input looks like correct:\npreorder: [3,9,20,2,15,7]\ninorder: [9,2,3,15,20,7]\nBut the Leetcode throws TLE despite I return null at the first line of the solution, obviously I expect just wrong answer:\n```javascript\nvar buildTree = function(preorder, inorder) {\n    return null;\n}\n```\nWhat am I missing?"
                    },
                    {
                        "username": "c4tdog",
                        "content": "for inorder [9,2,3,15,20,7] preopder must be [3,9,2,20,15,7]\nso, your input in invalid"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/61i-qpZSfyg"
                    },
                    {
                        "username": "aggarwalmukul96",
                        "content": "202 TEST CASES PASSED OUT SHOWING TLE ON LAST CASE CAN ANYONE HELP????    : -/\n\n\n\nclass Solution {\npublic:\n    TreeNode* buildTree(vector<int>& preorder, vector<int>& inorder) {\n        unordered_map<int,int>m;\n        for(int i=0;i<inorder.size();i++)\n        m[inorder[i]]=i;\n        TreeNode*root=buildTree(preorder,0,preorder.size()-1,inorder,0,inorder.size()-1,m);\n        return root;\n    }\n    TreeNode*buildTree(vector<int>pre,int pstart,int pend,vector<int>in,int instart,int inend,unordered_map<int,int>m)\n    {\n        if(pstart>pend ||instart>inend)\n        return NULL;\n        TreeNode*root= new TreeNode(pre[pstart]);\n        int inroot=m[root->val];\n        int numleft=inroot-instart;\n        root->left=buildTree(pre,pstart+1,pstart+numleft,in,instart,inroot-1,m);\n        root->right=buildTree(pre,pstart+numleft+1,pend,in,inroot+1,inend,m);\n        return root;\n    }\n};"
                    },
                    {
                        "username": "its_me_3011ar",
                        "content": "[@aggarwalmukul96](/aggarwalmukul96)  welcome bro .. solutions he upvote krdo mere ;) lol"
                    },
                    {
                        "username": "aggarwalmukul96",
                        "content": "[@rayusahil](/rayusahil) thanx buddy"
                    },
                    {
                        "username": "its_me_3011ar",
                        "content": "pass map by reference  it will work"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "mgeek",
                        "content": "Simple O(n) Java solution without pre-Index calculation\\n\\n ` public TreeNode buildTree(int[] pre, int[] in) {\\n\\n       Map<Integer, Integer> map = new HashMap<>();\\n       for(int i =0; i < in.length; i++ ){\\n           map.put(in[i], i);\\n       } \\n        int preStart [] = new int[1];\\n       return build(in, pre, 0, in.length-1, preStart, map);\\n    }\\n\\n    private TreeNode build(int[] in, int[] pre, int inStart, int inEnd, int preStart [], Map<Integer, Integer> map) {\\n        if(inStart > inEnd){\\n            return null;\\n        }\\n        int preIndex = preStart[0]++;\\n        if( preIndex >= pre.length){\\n            return null;\\n        }\\n        int x = pre[preIndex];\\n        int index = map.get(x);\\n        TreeNode node = new TreeNode(x);\\n        if(inStart == inEnd){\\n            return node;\\n        }\\n        node.left = build(in, pre, inStart, index-1, preStart, map);\\n        node.right = build(in, pre, index+1, inEnd, preStart, map);\\n        return node;\\n    }`"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Simple Leetcode rules.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    }
                ]
            },
            {
                "id": 1768453,
                "content": [
                    {
                        "username": "odinlake",
                        "content": "I had missed this crucial information, which is not generally in the definition of a binary tree but without which the problem wouldn\\'t always have a unique solutmion: \"preorder and inorder consist of unique values.\"  Now it became rather easy."
                    },
                    {
                        "username": "hitchens23",
                        "content": "does anyone know why this custom testcase returns invalid tree?\\n\\npreorder: ```[1,2,3,4,5,6,7]```\\ninorder: ```[2,1,6,4,7,3,5]```"
                    },
                    {
                        "username": "steeewtOverflow",
                        "content": " TreeNode* construct(vector<int>& preorder,int lowerl,int upperl,int &preorderIndex,map<int,int> mp)\\n    {\\n        if(upperl<lowerl)   return NULL;\\n        int val=preorder[preorderIndex++];\\n        TreeNode* root=new TreeNode(val);\\n        root->left=construct(preorder,lowerl,mp[val]-1,preorderIndex,mp);\\n        root->right=construct(preorder,mp[val]+1,upperl,preorderIndex,mp);\\n\\n        return root;\\n    }\\n\\n    TreeNode* buildTree(vector<int>& preorder, vector<int>& inorder) {\\n        int preorderIndex=0;\\n        map<int,int> mp;\\n        for(int i=0;i<inorder.size();i++)\\n        {\\n            mp.insert({inorder[i],i});\\n        }\\n        return construct(preorder,0,inorder.size()-1,preorderIndex,mp);\\n        \\n    }\\n\\nthe code gives TLE at 202/203 test cases. Help"
                    },
                    {
                        "username": "hdrwilkinson",
                        "content": "I\\'m admittedly not that good at these LeetCode puzzles and so am really happy to have solved this one. What really helped me was using pen and paper to map out what was happening. Take the example preorder = [3,9,20,15,7] and experiment with different tree structures, noting down the inorder for each structure. Then try to work out if there is a pattern. Once you find it, write it out in full and then code it."
                    },
                    {
                        "username": "jacksonyyy",
                        "content": "honestly, I don\\'t see the difficult of this question, its just using  the template of creating tree, if you r familiar with the 3 types (2 in this question) traversal, it\\'s about to be obvious to you  "
                    },
                    {
                        "username": "naararouter",
                        "content": "Maybe I don't understand something...but the next input looks like correct:\npreorder: [3,9,20,2,15,7]\ninorder: [9,2,3,15,20,7]\nBut the Leetcode throws TLE despite I return null at the first line of the solution, obviously I expect just wrong answer:\n```javascript\nvar buildTree = function(preorder, inorder) {\n    return null;\n}\n```\nWhat am I missing?"
                    },
                    {
                        "username": "c4tdog",
                        "content": "for inorder [9,2,3,15,20,7] preopder must be [3,9,2,20,15,7]\nso, your input in invalid"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/61i-qpZSfyg"
                    },
                    {
                        "username": "aggarwalmukul96",
                        "content": "202 TEST CASES PASSED OUT SHOWING TLE ON LAST CASE CAN ANYONE HELP????    : -/\n\n\n\nclass Solution {\npublic:\n    TreeNode* buildTree(vector<int>& preorder, vector<int>& inorder) {\n        unordered_map<int,int>m;\n        for(int i=0;i<inorder.size();i++)\n        m[inorder[i]]=i;\n        TreeNode*root=buildTree(preorder,0,preorder.size()-1,inorder,0,inorder.size()-1,m);\n        return root;\n    }\n    TreeNode*buildTree(vector<int>pre,int pstart,int pend,vector<int>in,int instart,int inend,unordered_map<int,int>m)\n    {\n        if(pstart>pend ||instart>inend)\n        return NULL;\n        TreeNode*root= new TreeNode(pre[pstart]);\n        int inroot=m[root->val];\n        int numleft=inroot-instart;\n        root->left=buildTree(pre,pstart+1,pstart+numleft,in,instart,inroot-1,m);\n        root->right=buildTree(pre,pstart+numleft+1,pend,in,inroot+1,inend,m);\n        return root;\n    }\n};"
                    },
                    {
                        "username": "its_me_3011ar",
                        "content": "[@aggarwalmukul96](/aggarwalmukul96)  welcome bro .. solutions he upvote krdo mere ;) lol"
                    },
                    {
                        "username": "aggarwalmukul96",
                        "content": "[@rayusahil](/rayusahil) thanx buddy"
                    },
                    {
                        "username": "its_me_3011ar",
                        "content": "pass map by reference  it will work"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "mgeek",
                        "content": "Simple O(n) Java solution without pre-Index calculation\\n\\n ` public TreeNode buildTree(int[] pre, int[] in) {\\n\\n       Map<Integer, Integer> map = new HashMap<>();\\n       for(int i =0; i < in.length; i++ ){\\n           map.put(in[i], i);\\n       } \\n        int preStart [] = new int[1];\\n       return build(in, pre, 0, in.length-1, preStart, map);\\n    }\\n\\n    private TreeNode build(int[] in, int[] pre, int inStart, int inEnd, int preStart [], Map<Integer, Integer> map) {\\n        if(inStart > inEnd){\\n            return null;\\n        }\\n        int preIndex = preStart[0]++;\\n        if( preIndex >= pre.length){\\n            return null;\\n        }\\n        int x = pre[preIndex];\\n        int index = map.get(x);\\n        TreeNode node = new TreeNode(x);\\n        if(inStart == inEnd){\\n            return node;\\n        }\\n        node.left = build(in, pre, inStart, index-1, preStart, map);\\n        node.right = build(in, pre, index+1, inEnd, preStart, map);\\n        return node;\\n    }`"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Simple Leetcode rules.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    }
                ]
            },
            {
                "id": 1768191,
                "content": [
                    {
                        "username": "odinlake",
                        "content": "I had missed this crucial information, which is not generally in the definition of a binary tree but without which the problem wouldn\\'t always have a unique solutmion: \"preorder and inorder consist of unique values.\"  Now it became rather easy."
                    },
                    {
                        "username": "hitchens23",
                        "content": "does anyone know why this custom testcase returns invalid tree?\\n\\npreorder: ```[1,2,3,4,5,6,7]```\\ninorder: ```[2,1,6,4,7,3,5]```"
                    },
                    {
                        "username": "steeewtOverflow",
                        "content": " TreeNode* construct(vector<int>& preorder,int lowerl,int upperl,int &preorderIndex,map<int,int> mp)\\n    {\\n        if(upperl<lowerl)   return NULL;\\n        int val=preorder[preorderIndex++];\\n        TreeNode* root=new TreeNode(val);\\n        root->left=construct(preorder,lowerl,mp[val]-1,preorderIndex,mp);\\n        root->right=construct(preorder,mp[val]+1,upperl,preorderIndex,mp);\\n\\n        return root;\\n    }\\n\\n    TreeNode* buildTree(vector<int>& preorder, vector<int>& inorder) {\\n        int preorderIndex=0;\\n        map<int,int> mp;\\n        for(int i=0;i<inorder.size();i++)\\n        {\\n            mp.insert({inorder[i],i});\\n        }\\n        return construct(preorder,0,inorder.size()-1,preorderIndex,mp);\\n        \\n    }\\n\\nthe code gives TLE at 202/203 test cases. Help"
                    },
                    {
                        "username": "hdrwilkinson",
                        "content": "I\\'m admittedly not that good at these LeetCode puzzles and so am really happy to have solved this one. What really helped me was using pen and paper to map out what was happening. Take the example preorder = [3,9,20,15,7] and experiment with different tree structures, noting down the inorder for each structure. Then try to work out if there is a pattern. Once you find it, write it out in full and then code it."
                    },
                    {
                        "username": "jacksonyyy",
                        "content": "honestly, I don\\'t see the difficult of this question, its just using  the template of creating tree, if you r familiar with the 3 types (2 in this question) traversal, it\\'s about to be obvious to you  "
                    },
                    {
                        "username": "naararouter",
                        "content": "Maybe I don't understand something...but the next input looks like correct:\npreorder: [3,9,20,2,15,7]\ninorder: [9,2,3,15,20,7]\nBut the Leetcode throws TLE despite I return null at the first line of the solution, obviously I expect just wrong answer:\n```javascript\nvar buildTree = function(preorder, inorder) {\n    return null;\n}\n```\nWhat am I missing?"
                    },
                    {
                        "username": "c4tdog",
                        "content": "for inorder [9,2,3,15,20,7] preopder must be [3,9,2,20,15,7]\nso, your input in invalid"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/61i-qpZSfyg"
                    },
                    {
                        "username": "aggarwalmukul96",
                        "content": "202 TEST CASES PASSED OUT SHOWING TLE ON LAST CASE CAN ANYONE HELP????    : -/\n\n\n\nclass Solution {\npublic:\n    TreeNode* buildTree(vector<int>& preorder, vector<int>& inorder) {\n        unordered_map<int,int>m;\n        for(int i=0;i<inorder.size();i++)\n        m[inorder[i]]=i;\n        TreeNode*root=buildTree(preorder,0,preorder.size()-1,inorder,0,inorder.size()-1,m);\n        return root;\n    }\n    TreeNode*buildTree(vector<int>pre,int pstart,int pend,vector<int>in,int instart,int inend,unordered_map<int,int>m)\n    {\n        if(pstart>pend ||instart>inend)\n        return NULL;\n        TreeNode*root= new TreeNode(pre[pstart]);\n        int inroot=m[root->val];\n        int numleft=inroot-instart;\n        root->left=buildTree(pre,pstart+1,pstart+numleft,in,instart,inroot-1,m);\n        root->right=buildTree(pre,pstart+numleft+1,pend,in,inroot+1,inend,m);\n        return root;\n    }\n};"
                    },
                    {
                        "username": "its_me_3011ar",
                        "content": "[@aggarwalmukul96](/aggarwalmukul96)  welcome bro .. solutions he upvote krdo mere ;) lol"
                    },
                    {
                        "username": "aggarwalmukul96",
                        "content": "[@rayusahil](/rayusahil) thanx buddy"
                    },
                    {
                        "username": "its_me_3011ar",
                        "content": "pass map by reference  it will work"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "mgeek",
                        "content": "Simple O(n) Java solution without pre-Index calculation\\n\\n ` public TreeNode buildTree(int[] pre, int[] in) {\\n\\n       Map<Integer, Integer> map = new HashMap<>();\\n       for(int i =0; i < in.length; i++ ){\\n           map.put(in[i], i);\\n       } \\n        int preStart [] = new int[1];\\n       return build(in, pre, 0, in.length-1, preStart, map);\\n    }\\n\\n    private TreeNode build(int[] in, int[] pre, int inStart, int inEnd, int preStart [], Map<Integer, Integer> map) {\\n        if(inStart > inEnd){\\n            return null;\\n        }\\n        int preIndex = preStart[0]++;\\n        if( preIndex >= pre.length){\\n            return null;\\n        }\\n        int x = pre[preIndex];\\n        int index = map.get(x);\\n        TreeNode node = new TreeNode(x);\\n        if(inStart == inEnd){\\n            return node;\\n        }\\n        node.left = build(in, pre, inStart, index-1, preStart, map);\\n        node.right = build(in, pre, index+1, inEnd, preStart, map);\\n        return node;\\n    }`"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Simple Leetcode rules.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    }
                ]
            },
            {
                "id": 1754153,
                "content": [
                    {
                        "username": "odinlake",
                        "content": "I had missed this crucial information, which is not generally in the definition of a binary tree but without which the problem wouldn\\'t always have a unique solutmion: \"preorder and inorder consist of unique values.\"  Now it became rather easy."
                    },
                    {
                        "username": "hitchens23",
                        "content": "does anyone know why this custom testcase returns invalid tree?\\n\\npreorder: ```[1,2,3,4,5,6,7]```\\ninorder: ```[2,1,6,4,7,3,5]```"
                    },
                    {
                        "username": "steeewtOverflow",
                        "content": " TreeNode* construct(vector<int>& preorder,int lowerl,int upperl,int &preorderIndex,map<int,int> mp)\\n    {\\n        if(upperl<lowerl)   return NULL;\\n        int val=preorder[preorderIndex++];\\n        TreeNode* root=new TreeNode(val);\\n        root->left=construct(preorder,lowerl,mp[val]-1,preorderIndex,mp);\\n        root->right=construct(preorder,mp[val]+1,upperl,preorderIndex,mp);\\n\\n        return root;\\n    }\\n\\n    TreeNode* buildTree(vector<int>& preorder, vector<int>& inorder) {\\n        int preorderIndex=0;\\n        map<int,int> mp;\\n        for(int i=0;i<inorder.size();i++)\\n        {\\n            mp.insert({inorder[i],i});\\n        }\\n        return construct(preorder,0,inorder.size()-1,preorderIndex,mp);\\n        \\n    }\\n\\nthe code gives TLE at 202/203 test cases. Help"
                    },
                    {
                        "username": "hdrwilkinson",
                        "content": "I\\'m admittedly not that good at these LeetCode puzzles and so am really happy to have solved this one. What really helped me was using pen and paper to map out what was happening. Take the example preorder = [3,9,20,15,7] and experiment with different tree structures, noting down the inorder for each structure. Then try to work out if there is a pattern. Once you find it, write it out in full and then code it."
                    },
                    {
                        "username": "jacksonyyy",
                        "content": "honestly, I don\\'t see the difficult of this question, its just using  the template of creating tree, if you r familiar with the 3 types (2 in this question) traversal, it\\'s about to be obvious to you  "
                    },
                    {
                        "username": "naararouter",
                        "content": "Maybe I don't understand something...but the next input looks like correct:\npreorder: [3,9,20,2,15,7]\ninorder: [9,2,3,15,20,7]\nBut the Leetcode throws TLE despite I return null at the first line of the solution, obviously I expect just wrong answer:\n```javascript\nvar buildTree = function(preorder, inorder) {\n    return null;\n}\n```\nWhat am I missing?"
                    },
                    {
                        "username": "c4tdog",
                        "content": "for inorder [9,2,3,15,20,7] preopder must be [3,9,2,20,15,7]\nso, your input in invalid"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/61i-qpZSfyg"
                    },
                    {
                        "username": "aggarwalmukul96",
                        "content": "202 TEST CASES PASSED OUT SHOWING TLE ON LAST CASE CAN ANYONE HELP????    : -/\n\n\n\nclass Solution {\npublic:\n    TreeNode* buildTree(vector<int>& preorder, vector<int>& inorder) {\n        unordered_map<int,int>m;\n        for(int i=0;i<inorder.size();i++)\n        m[inorder[i]]=i;\n        TreeNode*root=buildTree(preorder,0,preorder.size()-1,inorder,0,inorder.size()-1,m);\n        return root;\n    }\n    TreeNode*buildTree(vector<int>pre,int pstart,int pend,vector<int>in,int instart,int inend,unordered_map<int,int>m)\n    {\n        if(pstart>pend ||instart>inend)\n        return NULL;\n        TreeNode*root= new TreeNode(pre[pstart]);\n        int inroot=m[root->val];\n        int numleft=inroot-instart;\n        root->left=buildTree(pre,pstart+1,pstart+numleft,in,instart,inroot-1,m);\n        root->right=buildTree(pre,pstart+numleft+1,pend,in,inroot+1,inend,m);\n        return root;\n    }\n};"
                    },
                    {
                        "username": "its_me_3011ar",
                        "content": "[@aggarwalmukul96](/aggarwalmukul96)  welcome bro .. solutions he upvote krdo mere ;) lol"
                    },
                    {
                        "username": "aggarwalmukul96",
                        "content": "[@rayusahil](/rayusahil) thanx buddy"
                    },
                    {
                        "username": "its_me_3011ar",
                        "content": "pass map by reference  it will work"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "mgeek",
                        "content": "Simple O(n) Java solution without pre-Index calculation\\n\\n ` public TreeNode buildTree(int[] pre, int[] in) {\\n\\n       Map<Integer, Integer> map = new HashMap<>();\\n       for(int i =0; i < in.length; i++ ){\\n           map.put(in[i], i);\\n       } \\n        int preStart [] = new int[1];\\n       return build(in, pre, 0, in.length-1, preStart, map);\\n    }\\n\\n    private TreeNode build(int[] in, int[] pre, int inStart, int inEnd, int preStart [], Map<Integer, Integer> map) {\\n        if(inStart > inEnd){\\n            return null;\\n        }\\n        int preIndex = preStart[0]++;\\n        if( preIndex >= pre.length){\\n            return null;\\n        }\\n        int x = pre[preIndex];\\n        int index = map.get(x);\\n        TreeNode node = new TreeNode(x);\\n        if(inStart == inEnd){\\n            return node;\\n        }\\n        node.left = build(in, pre, inStart, index-1, preStart, map);\\n        node.right = build(in, pre, index+1, inEnd, preStart, map);\\n        return node;\\n    }`"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Simple Leetcode rules.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    }
                ]
            },
            {
                "id": 1735486,
                "content": [
                    {
                        "username": "odinlake",
                        "content": "I had missed this crucial information, which is not generally in the definition of a binary tree but without which the problem wouldn\\'t always have a unique solutmion: \"preorder and inorder consist of unique values.\"  Now it became rather easy."
                    },
                    {
                        "username": "hitchens23",
                        "content": "does anyone know why this custom testcase returns invalid tree?\\n\\npreorder: ```[1,2,3,4,5,6,7]```\\ninorder: ```[2,1,6,4,7,3,5]```"
                    },
                    {
                        "username": "steeewtOverflow",
                        "content": " TreeNode* construct(vector<int>& preorder,int lowerl,int upperl,int &preorderIndex,map<int,int> mp)\\n    {\\n        if(upperl<lowerl)   return NULL;\\n        int val=preorder[preorderIndex++];\\n        TreeNode* root=new TreeNode(val);\\n        root->left=construct(preorder,lowerl,mp[val]-1,preorderIndex,mp);\\n        root->right=construct(preorder,mp[val]+1,upperl,preorderIndex,mp);\\n\\n        return root;\\n    }\\n\\n    TreeNode* buildTree(vector<int>& preorder, vector<int>& inorder) {\\n        int preorderIndex=0;\\n        map<int,int> mp;\\n        for(int i=0;i<inorder.size();i++)\\n        {\\n            mp.insert({inorder[i],i});\\n        }\\n        return construct(preorder,0,inorder.size()-1,preorderIndex,mp);\\n        \\n    }\\n\\nthe code gives TLE at 202/203 test cases. Help"
                    },
                    {
                        "username": "hdrwilkinson",
                        "content": "I\\'m admittedly not that good at these LeetCode puzzles and so am really happy to have solved this one. What really helped me was using pen and paper to map out what was happening. Take the example preorder = [3,9,20,15,7] and experiment with different tree structures, noting down the inorder for each structure. Then try to work out if there is a pattern. Once you find it, write it out in full and then code it."
                    },
                    {
                        "username": "jacksonyyy",
                        "content": "honestly, I don\\'t see the difficult of this question, its just using  the template of creating tree, if you r familiar with the 3 types (2 in this question) traversal, it\\'s about to be obvious to you  "
                    },
                    {
                        "username": "naararouter",
                        "content": "Maybe I don't understand something...but the next input looks like correct:\npreorder: [3,9,20,2,15,7]\ninorder: [9,2,3,15,20,7]\nBut the Leetcode throws TLE despite I return null at the first line of the solution, obviously I expect just wrong answer:\n```javascript\nvar buildTree = function(preorder, inorder) {\n    return null;\n}\n```\nWhat am I missing?"
                    },
                    {
                        "username": "c4tdog",
                        "content": "for inorder [9,2,3,15,20,7] preopder must be [3,9,2,20,15,7]\nso, your input in invalid"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/61i-qpZSfyg"
                    },
                    {
                        "username": "aggarwalmukul96",
                        "content": "202 TEST CASES PASSED OUT SHOWING TLE ON LAST CASE CAN ANYONE HELP????    : -/\n\n\n\nclass Solution {\npublic:\n    TreeNode* buildTree(vector<int>& preorder, vector<int>& inorder) {\n        unordered_map<int,int>m;\n        for(int i=0;i<inorder.size();i++)\n        m[inorder[i]]=i;\n        TreeNode*root=buildTree(preorder,0,preorder.size()-1,inorder,0,inorder.size()-1,m);\n        return root;\n    }\n    TreeNode*buildTree(vector<int>pre,int pstart,int pend,vector<int>in,int instart,int inend,unordered_map<int,int>m)\n    {\n        if(pstart>pend ||instart>inend)\n        return NULL;\n        TreeNode*root= new TreeNode(pre[pstart]);\n        int inroot=m[root->val];\n        int numleft=inroot-instart;\n        root->left=buildTree(pre,pstart+1,pstart+numleft,in,instart,inroot-1,m);\n        root->right=buildTree(pre,pstart+numleft+1,pend,in,inroot+1,inend,m);\n        return root;\n    }\n};"
                    },
                    {
                        "username": "its_me_3011ar",
                        "content": "[@aggarwalmukul96](/aggarwalmukul96)  welcome bro .. solutions he upvote krdo mere ;) lol"
                    },
                    {
                        "username": "aggarwalmukul96",
                        "content": "[@rayusahil](/rayusahil) thanx buddy"
                    },
                    {
                        "username": "its_me_3011ar",
                        "content": "pass map by reference  it will work"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "mgeek",
                        "content": "Simple O(n) Java solution without pre-Index calculation\\n\\n ` public TreeNode buildTree(int[] pre, int[] in) {\\n\\n       Map<Integer, Integer> map = new HashMap<>();\\n       for(int i =0; i < in.length; i++ ){\\n           map.put(in[i], i);\\n       } \\n        int preStart [] = new int[1];\\n       return build(in, pre, 0, in.length-1, preStart, map);\\n    }\\n\\n    private TreeNode build(int[] in, int[] pre, int inStart, int inEnd, int preStart [], Map<Integer, Integer> map) {\\n        if(inStart > inEnd){\\n            return null;\\n        }\\n        int preIndex = preStart[0]++;\\n        if( preIndex >= pre.length){\\n            return null;\\n        }\\n        int x = pre[preIndex];\\n        int index = map.get(x);\\n        TreeNode node = new TreeNode(x);\\n        if(inStart == inEnd){\\n            return node;\\n        }\\n        node.left = build(in, pre, inStart, index-1, preStart, map);\\n        node.right = build(in, pre, index+1, inEnd, preStart, map);\\n        return node;\\n    }`"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Simple Leetcode rules.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    }
                ]
            }
        ]
    }
]