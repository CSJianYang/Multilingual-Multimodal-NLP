[
    {
        "title": "Longest ZigZag Path in a Binary Tree",
        "question_content": "You are given the root of a binary tree.\nA ZigZag path for a binary tree is defined as follow:\n\n\tChoose any node in the binary tree and a direction (right or left).\n\tIf the current direction is right, move to the right child of the current node; otherwise, move to the left child.\n\tChange the direction from right to left or from left to right.\n\tRepeat the second and third steps until you can't move in the tree.\n\nZigzag length is defined as the number of nodes visited - 1. (A single node has a length of 0).\nReturn the longest ZigZag path contained in that tree.\n&nbsp;\nExample 1:\n\nInput: root = [1,null,1,1,1,null,null,1,1,null,1,null,null,null,1]\nOutput: 3\nExplanation: Longest ZigZag path in blue nodes (right -> left -> right).\n\nExample 2:\n\nInput: root = [1,1,1,null,1,null,null,1,1,null,1]\nOutput: 4\nExplanation: Longest ZigZag path in blue nodes (left -> right -> left -> right).\n\nExample 3:\n\nInput: root = [1]\nOutput: 0\n\n&nbsp;\nConstraints:\n\n\tThe number of nodes in the tree is in the range [1, 5 * 104].\n\t1 <= Node.val <= 100",
        "solutions": [
            {
                "id": 531867,
                "title": "java-python-dfs-solution",
                "content": "## **Explanation**\\nRecursive return `[left, right, result]`, where:\\n`left` is the maximum length in direction of `root.left`\\n`right` is the maximum length in direction of `root.right`\\n`result` is the maximum length in the whole sub tree.\\n<br>\\n\\n## **Complexity**\\nTime `O(N)`\\nSpace `O(height)`\\n<br>\\n\\n**Java**\\n```java\\n    public int longestZigZag(TreeNode root) {\\n        return dfs(root)[2];\\n    }\\n\\n    private int[] dfs(TreeNode root) {\\n        if (root == null) return new int[]{-1, -1, -1};\\n        int[] left = dfs(root.left), right = dfs(root.right);\\n        int res = Math.max(Math.max(left[1], right[0]) + 1, Math.max(left[2], right[2]));\\n        return new int[]{left[1] + 1, right[0] + 1, res};\\n    }\\n```\\n**C++**\\nby @SuperWhw\\n```cpp\\n    int longestZigZag(TreeNode* root) {\\n        return dfs(root)[2];\\n    }\\n\\n    vector<int> dfs(TreeNode* root) {\\n        if (!root) return { -1, -1, -1};\\n        vector<int> left = dfs(root->left), right = dfs(root->right);\\n        int res = max(max(left[1], right[0]) + 1, max(left[2], right[2]));\\n        return {left[1] + 1, right[0] + 1, res};\\n    }\\n```\\n**Python:**\\n```py\\n    def longestZigZag(self, root):\\n        def dfs(root):\\n            if not root: return [-1, -1, -1]\\n            left, right = dfs(root.left), dfs(root.right)\\n            return [left[1] + 1, right[0] + 1, max(left[1] + 1, right[0] + 1, left[2], right[2])]\\n        return dfs(root)[-1]\\n```\\n",
                "solutionTags": [],
                "code": "```java\\n    public int longestZigZag(TreeNode root) {\\n        return dfs(root)[2];\\n    }\\n\\n    private int[] dfs(TreeNode root) {\\n        if (root == null) return new int[]{-1, -1, -1};\\n        int[] left = dfs(root.left), right = dfs(root.right);\\n        int res = Math.max(Math.max(left[1], right[0]) + 1, Math.max(left[2], right[2]));\\n        return new int[]{left[1] + 1, right[0] + 1, res};\\n    }\\n```\n```cpp\\n    int longestZigZag(TreeNode* root) {\\n        return dfs(root)[2];\\n    }\\n\\n    vector<int> dfs(TreeNode* root) {\\n        if (!root) return { -1, -1, -1};\\n        vector<int> left = dfs(root->left), right = dfs(root->right);\\n        int res = max(max(left[1], right[0]) + 1, max(left[2], right[2]));\\n        return {left[1] + 1, right[0] + 1, res};\\n    }\\n```\n```py\\n    def longestZigZag(self, root):\\n        def dfs(root):\\n            if not root: return [-1, -1, -1]\\n            left, right = dfs(root.left), dfs(root.right)\\n            return [left[1] + 1, right[0] + 1, max(left[1] + 1, right[0] + 1, left[2], right[2])]\\n        return dfs(root)[-1]\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 534418,
                "title": "java-c-dfs-solution-with-comment-o-n-clean-code",
                "content": "**Java**\\n```java\\nclass Solution {\\n    int maxStep = 0;\\n    public int longestZigZag(TreeNode root) {\\n        dfs(root, true, 0);\\n        dfs(root, false, 0);\\n        return maxStep;\\n    }\\n    private void dfs(TreeNode root, boolean isLeft, int step) {\\n        if (root == null) return;\\n        maxStep = Math.max(maxStep, step); // update max step sofar\\n        if (isLeft) {\\n            dfs(root.left, false, step + 1); // keep going from root to left\\n            dfs(root.right, true, 1); // restart going from root to right\\n        } else {\\n            dfs(root.right, true, step + 1); // keep going from root to right\\n            dfs(root.left, false, 1); // restart going from root to left\\n        }\\n    }\\n}\\n```\\n**C++**\\n```c++\\nclass Solution {\\npublic:\\n    int maxStep = 0;\\n    int longestZigZag(TreeNode* root) {\\n        dfs(root, true, 0);\\n        dfs(root, false, 0);\\n        return maxStep;\\n    }\\n    void dfs(TreeNode* root, bool isLeft, int step) {\\n        if (!root) return;\\n        maxStep = max(maxStep, step); // update max step sofar\\n        if (isLeft) {\\n            dfs(root->left, false, step + 1); // keep going from root to left\\n            dfs(root->right, true, 1); // restart going from root to right\\n        } else {\\n            dfs(root->right, true, step + 1); // keep going from root to right\\n            dfs(root->left, false, 1); // restart going from root to left\\n        }\\n    }\\n};\\n```\\nComplexity:\\n- Time: `O(n)`, it will visit all the nodes and each node once.\\n- Space: `O(h)`",
                "solutionTags": [],
                "code": "```java\\nclass Solution {\\n    int maxStep = 0;\\n    public int longestZigZag(TreeNode root) {\\n        dfs(root, true, 0);\\n        dfs(root, false, 0);\\n        return maxStep;\\n    }\\n    private void dfs(TreeNode root, boolean isLeft, int step) {\\n        if (root == null) return;\\n        maxStep = Math.max(maxStep, step); // update max step sofar\\n        if (isLeft) {\\n            dfs(root.left, false, step + 1); // keep going from root to left\\n            dfs(root.right, true, 1); // restart going from root to right\\n        } else {\\n            dfs(root.right, true, step + 1); // keep going from root to right\\n            dfs(root.left, false, 1); // restart going from root to left\\n        }\\n    }\\n}\\n```\n```c++\\nclass Solution {\\npublic:\\n    int maxStep = 0;\\n    int longestZigZag(TreeNode* root) {\\n        dfs(root, true, 0);\\n        dfs(root, false, 0);\\n        return maxStep;\\n    }\\n    void dfs(TreeNode* root, bool isLeft, int step) {\\n        if (!root) return;\\n        maxStep = max(maxStep, step); // update max step sofar\\n        if (isLeft) {\\n            dfs(root->left, false, step + 1); // keep going from root to left\\n            dfs(root->right, true, 1); // restart going from root to right\\n        } else {\\n            dfs(root->right, true, step + 1); // keep going from root to right\\n            dfs(root->left, false, 1); // restart going from root to left\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1159847,
                "title": "c-easy-simple-traversal",
                "content": "Parameters:\\nl = count of max zigzag which reaches current Node by moving LEFT  from par  Node.\\nr = count of max zigzag which reaches current Node by moving RIGHT from par Node.\\n- Now update ans upto current node\\n- then send l+1 to RIGHT\\n- and r+1 to LEFT\\nPlease \\uD83D\\uDE4F  do upvote \\uD83D\\uDC4D if you find my solution apt\\uD83E\\uDD18\\n```\\nvoid ziggy(TreeNode* root, int l , int r, int& ans){\\n        if(!root) return;\\n         ans = max(ans, l);\\n         ans = max(ans, r);\\n        ziggy(root->left, 0, l+1, ans);\\n        \\n        ziggy(root->right, r+1, 0, ans);\\n        \\n        return;\\n    }\\n    int longestZigZag(TreeNode* root) {\\n        int l=0;\\n        int r=0;\\n        int ans=0;\\n        ziggy(root, l,r,ans);\\n        return ans;\\n    }\\n```",
                "solutionTags": [
                    "C",
                    "Tree"
                ],
                "code": "```\\nvoid ziggy(TreeNode* root, int l , int r, int& ans){\\n        if(!root) return;\\n         ans = max(ans, l);\\n         ans = max(ans, r);\\n        ziggy(root->left, 0, l+1, ans);\\n        \\n        ziggy(root->right, r+1, 0, ans);\\n        \\n        return;\\n    }\\n    int longestZigZag(TreeNode* root) {\\n        int l=0;\\n        int r=0;\\n        int ans=0;\\n        ziggy(root, l,r,ans);\\n        return ans;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3433060,
                "title": "image-explanation-easy-complete-intuition-c-java-python",
                "content": "# Video Solution (`Aryan Mittal`) - Link in LeetCode Profile\\n`Longest ZigZag Path in a Binary Tree` by `Aryan Mittal`\\n![Microsoft5.png](https://assets.leetcode.com/users/images/95f272ac-7e6c-4122-a4f2-eee277eae354_1681870513.1834931.png)\\n\\n\\n# Approach & Intution\\n![image.png](https://assets.leetcode.com/users/images/dc700053-7e28-4c89-9ccb-9b8eea23527b_1681866335.4239633.png)\\n![image.png](https://assets.leetcode.com/users/images/8408a910-3d92-4f43-9ea9-93bad63ae219_1681866345.8971014.png)\\n![image.png](https://assets.leetcode.com/users/images/4d52de15-84e1-4195-b926-a32a5a9a9263_1681866360.3134615.png)\\n![image.png](https://assets.leetcode.com/users/images/cb3f3fb3-3880-4d9b-b53f-a17dcb8c4c69_1681866371.5972638.png)\\n![image.png](https://assets.leetcode.com/users/images/3ae64e23-b322-4456-84fe-2ee3afc519bc_1681866383.361797.png)\\n![image.png](https://assets.leetcode.com/users/images/ef889cfa-8a54-45d7-ab07-cce747455a6a_1681866390.8031855.png)\\n\\n\\n# Code\\n```C++ []\\nclass Solution {\\n    public:\\n    int maxLength=0;\\n\\n    void solve(TreeNode* root,int dir,int currLength){\\n        if(!root) return;\\n        maxLength=max(maxLength,currLength);\\n        solve(root->left,0,dir?currLength+1:1);\\n        solve(root->right,1,dir?1:currLength+1);\\n    }\\n\\n    int longestZigZag(TreeNode* root) {\\n        solve(root,0,0);\\n        solve(root,1,0);\\n        return maxLength;\\n    }\\n};\\n```\\n```Java []\\nclass Solution {\\n    public int maxLength=0;\\n    public void solve(TreeNode root,int dir,int currLength){\\n        if(root==null) return;\\n        maxLength=Math.max(maxLength,currLength);\\n        if(dir==1){\\n            solve(root.left,0,currLength+1);\\n            solve(root.right,1,1);\\n        }\\n        else{\\n            solve(root.right,1,currLength+1);\\n            solve(root.left,0,1);\\n        }\\n    }\\n\\n    public int longestZigZag(TreeNode root) {\\n        solve(root,0,0);\\n        solve(root,1,0);\\n        return maxLength;\\n    }\\n}\\n```\\n```Python []\\nclass Solution:\\n    def longestZigZag(self, root: Optional[TreeNode]) -> int:\\n        self.maxLength = 0\\n        def solve(node, deep, dir):\\n            self.maxLength = max(self.maxLength, deep)\\n\\n            if node.left is not None:\\n                solve(node.left, deep+1,\\'left\\') if dir != \\'left\\' else solve(node.left, 1, \\'left\\')\\n            if node.right is not None:\\n                solve(node.right, deep+1, \\'right\\') if dir != \\'right\\' else solve(node.right, 1, \\'right\\')\\n        solve(root, 0, \\'\\')\\n        return self.maxLength\\n```\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3",
                    "Tree",
                    "Depth-First Search"
                ],
                "code": "```C++ []\\nclass Solution {\\n    public:\\n    int maxLength=0;\\n\\n    void solve(TreeNode* root,int dir,int currLength){\\n        if(!root) return;\\n        maxLength=max(maxLength,currLength);\\n        solve(root->left,0,dir?currLength+1:1);\\n        solve(root->right,1,dir?1:currLength+1);\\n    }\\n\\n    int longestZigZag(TreeNode* root) {\\n        solve(root,0,0);\\n        solve(root,1,0);\\n        return maxLength;\\n    }\\n};\\n```\n```Java []\\nclass Solution {\\n    public int maxLength=0;\\n    public void solve(TreeNode root,int dir,int currLength){\\n        if(root==null) return;\\n        maxLength=Math.max(maxLength,currLength);\\n        if(dir==1){\\n            solve(root.left,0,currLength+1);\\n            solve(root.right,1,1);\\n        }\\n        else{\\n            solve(root.right,1,currLength+1);\\n            solve(root.left,0,1);\\n        }\\n    }\\n\\n    public int longestZigZag(TreeNode root) {\\n        solve(root,0,0);\\n        solve(root,1,0);\\n        return maxLength;\\n    }\\n}\\n```\n```Python []\\nclass Solution:\\n    def longestZigZag(self, root: Optional[TreeNode]) -> int:\\n        self.maxLength = 0\\n        def solve(node, deep, dir):\\n            self.maxLength = max(self.maxLength, deep)\\n\\n            if node.left is not None:\\n                solve(node.left, deep+1,\\'left\\') if dir != \\'left\\' else solve(node.left, 1, \\'left\\')\\n            if node.right is not None:\\n                solve(node.right, deep+1, \\'right\\') if dir != \\'right\\' else solve(node.right, 1, \\'right\\')\\n        solve(root, 0, \\'\\')\\n        return self.maxLength\\n```",
                "codeTag": "Java"
            },
            {
                "id": 531880,
                "title": "simple-java-code-with-comments",
                "content": "```\\nstatic int max = 0;\\npublic static int longestZigZag(TreeNode root) {\\n        if (root == null) return -1;// if null return -1\\n        max = 0;\\n        helper(root.right, 1, true);// go right\\n        helper(root.left, 1, false);// go left\\n        return max;\\n    }\\n\\n    private static void helper(TreeNode root, int step, boolean isRight) {\\n        if (root == null) return;\\n        max = Math.max(max, step);\\n        if (isRight) {// if coming from right go left\\n            helper(root.left, step + 1, false);\\n            helper(root.right, 1, true);//try again from start\\n        } else {// else coming from left then go right\\n            helper(root.right, step + 1, true);\\n            helper(root.left, 1, false);\\n        }\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\nstatic int max = 0;\\npublic static int longestZigZag(TreeNode root) {\\n        if (root == null) return -1;// if null return -1\\n        max = 0;\\n        helper(root.right, 1, true);// go right\\n        helper(root.left, 1, false);// go left\\n        return max;\\n    }\\n\\n    private static void helper(TreeNode root, int step, boolean isRight) {\\n        if (root == null) return;\\n        max = Math.max(max, step);\\n        if (isRight) {// if coming from right go left\\n            helper(root.left, step + 1, false);\\n            helper(root.right, 1, true);//try again from start\\n        } else {// else coming from left then go right\\n            helper(root.right, step + 1, true);\\n            helper(root.left, 1, false);\\n        }\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3433417,
                "title": "easy-solutions-in-java-python-and-c-look-at-once-with-exaplanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n>To find the longest zigzag path in a binary tree, we can traverse the tree using DFS (Depth-First-Search) and at each node, keep track of the maximum length of the zigzag path seen so far.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n>1. Initialize a variable ans to 0 to keep track of the maximum length of the zigzag path seen so far.\\n>2. Initialize a stack with the root node and two additional values n (the length of the zigzag path seen so far) and left (a boolean value indicating if the last traversal was to the left or not, where None represents the root node).\\n>3. Pop a node, n, and left from the stack.\\n>4. If the node is not None, update ans to max(ans, n).\\n>5. Add the left child to the stack with n + 1 as the new length and set left to 1 (indicating the last traversal was to the left) if the previous node was to the left or None, else set left to 0 (indicating the last traversal was to the right).\\n>6. Add the right child to the stack with n + 1 as the new length and set left to 0 (indicating the last traversal was to the right) if the previous node was to the right or None, else set left to 1 (indicating the last traversal was to the left).\\n>7. Repeat steps 3-6 until the stack is empty.\\n>8. Return ans\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n >O(N) where N is the number of nodes in the tree, as we visit every node exactly once.\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n>O(N) as we need to store all the nodes in the worst case (i.e., a skewed tree).\\n\\n![image.png](https://assets.leetcode.com/users/images/b427e686-2e5d-469a-8e7a-db5140022a6b_1677715904.0948765.png)\\n\\n\\n# Please Upvote\\uD83D\\uDC4D\\uD83D\\uDC4D\\n```\\nThanks for visiting my solution.\\uD83D\\uDE0A Keep Learning\\nPlease give my solution an upvote! \\uD83D\\uDC4D\\nIt\\'s a simple way to show your appreciation and\\nkeep me motivated. Thank you! \\uD83D\\uDE0A\\n```\\n# Code\\n```java []\\nclass Solution {\\n    public int longestZigZag(TreeNode root) {\\n        int ans = 0;\\n        Stack<Triplet> stack = new Stack<>();\\n        stack.push(new Triplet(root, 0, null));\\n        while (!stack.isEmpty()) {\\n            Triplet triplet = stack.pop();\\n            TreeNode node = triplet.node;\\n            int n = triplet.n;\\n            Integer left = triplet.left;\\n            if (node != null) {\\n                ans = Math.max(ans, n);\\n                stack.push(new Triplet(node.left, left != null && left == 0 ? n + 1 : 1, 1));\\n                stack.push(new Triplet(node.right, left != null && left == 1 ? n + 1 : 1, 0));\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n\\nclass Triplet {\\n    TreeNode node;\\n    int n;\\n    Integer left;\\n    \\n    public Triplet(TreeNode node, int n, Integer left) {\\n        this.node = node;\\n        this.n = n;\\n        this.left = left;\\n    }\\n}\\n\\n```\\n```python []\\n# Definition for a binary tree node.\\n# class TreeNode(object):\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\n\\nclass Solution(object):\\n    def longestZigZag(self, root):\\n        \"\"\"\\n        :type root: TreeNode\\n        :rtype: int\\n        \"\"\"\\n        ans = 0\\n        stack = [(root, 0, None)]\\n        while stack:\\n            node, n, left = stack.pop()\\n            if node:\\n                ans = max(ans, n)\\n                stack.append((node.left, 1 if left else n + 1, 1))\\n                stack.append((node.right, n + 1 if left else 1, 0))\\n        return ans\\n\\n```\\n\\n\\n```javascript []\\n/**\\n * Definition for a binary tree node.\\n * function TreeNode(val, left, right) {\\n *     this.val = (val===undefined ? 0 : val)\\n *     this.left = (left===undefined ? null : left)\\n *     this.right = (right===undefined ? null : right)\\n * }\\n */\\n/**\\n * @param {TreeNode} root\\n * @return {number}\\n */\\nvar longestZigZag = function(root) {\\n    let ans = 0;\\n    const stack = [[root, 0, null]];\\n    while (stack.length > 0) {\\n        const [node, n, left] = stack.pop();\\n        if (node) {\\n            ans = Math.max(ans, n);\\n            stack.push([node.left, left != null && left == 0 ? n + 1 : 1, 1]);\\n            stack.push([node.right, left != null && left == 1 ? n + 1 : 1, 0]);\\n        }\\n    }\\n    return ans;\\n};\\n\\n```\\n# Please Comment\\uD83D\\uDC4D\\uD83D\\uDC4D\\n```\\nThanks for visiting my solution comment below if you like it.\\uD83D\\uDE0A\\n```",
                "solutionTags": [
                    "Java",
                    "Python",
                    "JavaScript",
                    "Tree"
                ],
                "code": "```\\nThanks for visiting my solution.\\uD83D\\uDE0A Keep Learning\\nPlease give my solution an upvote! \\uD83D\\uDC4D\\nIt\\'s a simple way to show your appreciation and\\nkeep me motivated. Thank you! \\uD83D\\uDE0A\\n```\n```java []\\nclass Solution {\\n    public int longestZigZag(TreeNode root) {\\n        int ans = 0;\\n        Stack<Triplet> stack = new Stack<>();\\n        stack.push(new Triplet(root, 0, null));\\n        while (!stack.isEmpty()) {\\n            Triplet triplet = stack.pop();\\n            TreeNode node = triplet.node;\\n            int n = triplet.n;\\n            Integer left = triplet.left;\\n            if (node != null) {\\n                ans = Math.max(ans, n);\\n                stack.push(new Triplet(node.left, left != null && left == 0 ? n + 1 : 1, 1));\\n                stack.push(new Triplet(node.right, left != null && left == 1 ? n + 1 : 1, 0));\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n\\nclass Triplet {\\n    TreeNode node;\\n    int n;\\n    Integer left;\\n    \\n    public Triplet(TreeNode node, int n, Integer left) {\\n        this.node = node;\\n        this.n = n;\\n        this.left = left;\\n    }\\n}\\n\\n```\n```python []\\n# Definition for a binary tree node.\\n# class TreeNode(object):\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\n\\nclass Solution(object):\\n    def longestZigZag(self, root):\\n        \"\"\"\\n        :type root: TreeNode\\n        :rtype: int\\n        \"\"\"\\n        ans = 0\\n        stack = [(root, 0, None)]\\n        while stack:\\n            node, n, left = stack.pop()\\n            if node:\\n                ans = max(ans, n)\\n                stack.append((node.left, 1 if left else n + 1, 1))\\n                stack.append((node.right, n + 1 if left else 1, 0))\\n        return ans\\n\\n```\n```javascript []\\n/**\\n * Definition for a binary tree node.\\n * function TreeNode(val, left, right) {\\n *     this.val = (val===undefined ? 0 : val)\\n *     this.left = (left===undefined ? null : left)\\n *     this.right = (right===undefined ? null : right)\\n * }\\n */\\n/**\\n * @param {TreeNode} root\\n * @return {number}\\n */\\nvar longestZigZag = function(root) {\\n    let ans = 0;\\n    const stack = [[root, 0, null]];\\n    while (stack.length > 0) {\\n        const [node, n, left] = stack.pop();\\n        if (node) {\\n            ans = Math.max(ans, n);\\n            stack.push([node.left, left != null && left == 0 ? n + 1 : 1, 1]);\\n            stack.push([node.right, left != null && left == 1 ? n + 1 : 1, 0]);\\n        }\\n    }\\n    return ans;\\n};\\n\\n```\n```\\nThanks for visiting my solution comment below if you like it.\\uD83D\\uDE0A\\n```",
                "codeTag": "Java"
            },
            {
                "id": 531990,
                "title": "python-bfs-solution",
                "content": "BFS with queue\\nMain structure is `[node, from_, zigzag_len]`, where\\n`node` - is a current node,\\n`from_` - string with info about previous move (may be \\'l\\' if I came to current node from left or \\'r\\' if I came from left)\\n`zigzag_len` - length of zigzag path\\n\\nUPDATE: Thank you, @bunnyd! I updated code.\\n\\n```Python\\nfrom collections import deque\\n\\nclass Solution:\\n    def longestZigZag(self, root: TreeNode) -> int:\\n        if not root:\\n            return 0   \\n        \\n        deq = deque()\\n        max_zigzag_size = 0\\n        \\n        if root.left:\\n            deq.append((root.left, \\'l\\', 1))\\n        if root.right:\\n            deq.append((root.right, \\'r\\', 1))\\n\\n        while deq:\\n            node, from_, zigzag_size = deq.popleft()\\n            max_zigzag_size = max(zigzag_size, max_zigzag_size) # update max len of zigzag path\\n            if node.left:\\n                if from_ == \\'l\\':  # if came from left\\n                    deq.append((node.left, \"l\", 1)) # set length of zigzag path to 1\\n                if from_ == \\'r\\':  # if came from right\\n                    deq.append((node.left, \"l\", zigzag_size + 1)) # increase length of zigzag path \\n            if node.right:\\n                if from_ == \\'l\\':\\n                    deq.append((node.right, \"r\", zigzag_size + 1))\\n                if from_ == \\'r\\':\\n                    deq.append((node.right, \"r\", 1))\\n        return max_zigzag_size  \\n```",
                "solutionTags": [
                    "Python3",
                    "Breadth-First Search"
                ],
                "code": "```Python\\nfrom collections import deque\\n\\nclass Solution:\\n    def longestZigZag(self, root: TreeNode) -> int:\\n        if not root:\\n            return 0   \\n        \\n        deq = deque()\\n        max_zigzag_size = 0\\n        \\n        if root.left:\\n            deq.append((root.left, \\'l\\', 1))\\n        if root.right:\\n            deq.append((root.right, \\'r\\', 1))\\n\\n        while deq:\\n            node, from_, zigzag_size = deq.popleft()\\n            max_zigzag_size = max(zigzag_size, max_zigzag_size) # update max len of zigzag path\\n            if node.left:\\n                if from_ == \\'l\\':  # if came from left\\n                    deq.append((node.left, \"l\", 1)) # set length of zigzag path to 1\\n                if from_ == \\'r\\':  # if came from right\\n                    deq.append((node.left, \"l\", zigzag_size + 1)) # increase length of zigzag path \\n            if node.right:\\n                if from_ == \\'l\\':\\n                    deq.append((node.right, \"r\", zigzag_size + 1))\\n                if from_ == \\'r\\':\\n                    deq.append((node.right, \"r\", 1))\\n        return max_zigzag_size  \\n```",
                "codeTag": "Java"
            },
            {
                "id": 531808,
                "title": "java-recursion-try-each-node-as-a-zigzag-root-then-return-valid-sum-to-parent",
                "content": "```java\\nclass Solution {\\n    int result = 0;\\n    public int longestZigZag(TreeNode root) {\\n        dfs(root, true);\\n        return result;\\n    }\\n    \\n    public int dfs(TreeNode node, boolean isLeft){\\n        if(node == null){\\n            return 0;\\n        }\\n        //try start here\\n        int l = dfs(node.left, false);\\n        int r = dfs(node.right, true);\\n        result = Math.max(result, l);\\n        result = Math.max(result, r);\\n        //return sum for parent\\n        return 1 + (isLeft ? l : r);\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```java\\nclass Solution {\\n    int result = 0;\\n    public int longestZigZag(TreeNode root) {\\n        dfs(root, true);\\n        return result;\\n    }\\n    \\n    public int dfs(TreeNode node, boolean isLeft){\\n        if(node == null){\\n            return 0;\\n        }\\n        //try start here\\n        int l = dfs(node.left, false);\\n        int r = dfs(node.right, true);\\n        result = Math.max(result, l);\\n        result = Math.max(result, r);\\n        //return sum for parent\\n        return 1 + (isLeft ? l : r);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 534863,
                "title": "c-minimalizm",
                "content": "Traverse the tree tracking whether we come from `left` or not.\\n- Continue traversing in the oposite direction and increment `depth`.\\n- Or, start a new traversal in the same direction, resetting `depth` to zero. \\n\\n```cpp\\nint dfs(TreeNode* n, bool left, int depth) {\\n    return n == nullptr ? depth : \\n        max(dfs(left ? n->left : n->right, !left, depth + 1),\\n            dfs(left ? n->right : n->left, left, 0));\\n}\\nint longestZigZag(TreeNode* root) {\\n    return max(dfs(root, true, -1), dfs(root, false, -1));\\n}\\n```",
                "solutionTags": [],
                "code": "```cpp\\nint dfs(TreeNode* n, bool left, int depth) {\\n    return n == nullptr ? depth : \\n        max(dfs(left ? n->left : n->right, !left, depth + 1),\\n            dfs(left ? n->right : n->left, left, 0));\\n}\\nint longestZigZag(TreeNode* root) {\\n    return max(dfs(root, true, -1), dfs(root, false, -1));\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3433160,
                "title": "leetcode-the-hard-way-dfs-explained-line-by-line",
                "content": "```cpp\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\n \\n // TC: O(n)\\n // SC: O(n)\\nclass Solution {\\npublic:\\n    int dfs(TreeNode* root, int isLeft, int cnt) {\\n        // root is nullptr, we can return `cnt`\\n        if (!root) return cnt;\\n        // if `isLeft` is true, we have two choices\\n        // 1. go to right making a zipzag path - increase the cnt by 1 \\n        // 2. still go to left - starting a new zigzag path - hence cnt is set to 0\\n        if (isLeft) return max(dfs(root->right, 0, cnt + 1), dfs(root->left, 1, 0));\\n        // similarly, we apply the same logic for the opposite direction\\n        return max(dfs(root->left, 1, cnt + 1), dfs(root->right, 0, 0));\\n    }\\n    int longestZigZag(TreeNode* root) {\\n        // go through left-subtree and right-subtree\\n        // get the max result\\n        return max(dfs(root->left, 1, 0), dfs(root->right, 0, 0));\\n    }\\n};\\n```\\n\\n```py\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def longestZigZag(self, root: Optional[TreeNode]) -> int:\\n        def dfs(node, isLeft, cnt):\\n            # root is None, we can return `cnt`\\n            if node is None: return cnt\\n            # if `isLeft` is true, we have two choices\\n            # 1. go to right making a zipzag path - increase the cnt by 1\\n            # 2. still go to left - starting a new zigzag path - hence cnt is set to 0\\n            if isLeft:  return max(dfs(node.right, 0, cnt + 1), dfs(node.left, 1, 0))\\n            # similarly, we apply the same logic for the opposite direction\\n            return max(dfs(node.left, 1, cnt + 1), dfs(node.right, 0, 0))\\n        # go through left-subtree and right-subtree and get the max result\\n        return max(dfs(root.left, 1, 0), dfs(root.right, 0, 0))\\n```",
                "solutionTags": [
                    "C++",
                    "Python",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```cpp\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\n \\n // TC: O(n)\\n // SC: O(n)\\nclass Solution {\\npublic:\\n    int dfs(TreeNode* root, int isLeft, int cnt) {\\n        // root is nullptr, we can return `cnt`\\n        if (!root) return cnt;\\n        // if `isLeft` is true, we have two choices\\n        // 1. go to right making a zipzag path - increase the cnt by 1 \\n        // 2. still go to left - starting a new zigzag path - hence cnt is set to 0\\n        if (isLeft) return max(dfs(root->right, 0, cnt + 1), dfs(root->left, 1, 0));\\n        // similarly, we apply the same logic for the opposite direction\\n        return max(dfs(root->left, 1, cnt + 1), dfs(root->right, 0, 0));\\n    }\\n    int longestZigZag(TreeNode* root) {\\n        // go through left-subtree and right-subtree\\n        // get the max result\\n        return max(dfs(root->left, 1, 0), dfs(root->right, 0, 0));\\n    }\\n};\\n```\n```py\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def longestZigZag(self, root: Optional[TreeNode]) -> int:\\n        def dfs(node, isLeft, cnt):\\n            # root is None, we can return `cnt`\\n            if node is None: return cnt\\n            # if `isLeft` is true, we have two choices\\n            # 1. go to right making a zipzag path - increase the cnt by 1\\n            # 2. still go to left - starting a new zigzag path - hence cnt is set to 0\\n            if isLeft:  return max(dfs(node.right, 0, cnt + 1), dfs(node.left, 1, 0))\\n            # similarly, we apply the same logic for the opposite direction\\n            return max(dfs(node.left, 1, cnt + 1), dfs(node.right, 0, 0))\\n        # go through left-subtree and right-subtree and get the max result\\n        return max(dfs(root.left, 1, 0), dfs(root.right, 0, 0))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3433646,
                "title": "c-easy-recursion-approach-beats-97",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int longestZigZag(TreeNode* root) {\\n        if(!root->right && !root->left)\\n            return 0;\\n        return solve(root, 0, false);\\n    }\\n    int solve(TreeNode* root, int length, bool shouldGoLeft) {\\n        if(!root)\\n            return length;\\n\\n        int left = 0;\\n        int right = 0;\\n        int tmp = 0;\\n\\n        if(shouldGoLeft && !root->left) {\\n            tmp = length;\\n            length = 0;\\n        } else if(!shouldGoLeft && !root->right) {\\n            tmp = length;\\n            length = 0;\\n        }\\n\\n        right = solve(root->right, shouldGoLeft ? 1: length + 1, true);\\n        left = solve(root->left, shouldGoLeft ? length + 1 : 1, false);\\n\\n        return std::max({left, right, tmp});\\n    }\\n};\\n```\\n![_za_kompom_yapfiles.ru-min (online-video-cutter.com).gif](https://assets.leetcode.com/users/images/255a229e-59b8-4d7a-b910-87108c171e71_1681884320.5500047.gif)\\n\\n",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int longestZigZag(TreeNode* root) {\\n        if(!root->right && !root->left)\\n            return 0;\\n        return solve(root, 0, false);\\n    }\\n    int solve(TreeNode* root, int length, bool shouldGoLeft) {\\n        if(!root)\\n            return length;\\n\\n        int left = 0;\\n        int right = 0;\\n        int tmp = 0;\\n\\n        if(shouldGoLeft && !root->left) {\\n            tmp = length;\\n            length = 0;\\n        } else if(!shouldGoLeft && !root->right) {\\n            tmp = length;\\n            length = 0;\\n        }\\n\\n        right = solve(root->right, shouldGoLeft ? 1: length + 1, true);\\n        left = solve(root->left, shouldGoLeft ? length + 1 : 1, false);\\n\\n        return std::max({left, right, tmp});\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3433024,
                "title": "c-recursion",
                "content": "# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    int res = 0;\\n\\n    void solve(TreeNode* node, bool goLeft, int currPathLen) {\\n        if (!node) return;\\n        res = max(res, currPathLen);\\n        if (goLeft) {\\n            solve(node->left, false, currPathLen + 1);\\n            solve(node->right, true, 1);\\n        } else {\\n            solve(node->right, true, currPathLen + 1);\\n            solve(node->left, false, 1);\\n        }\\n    }\\n\\n    int longestZigZag(TreeNode* root) {\\n        solve(root, true, 0);\\n        solve(root, false, 0);\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Recursion"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    int res = 0;\\n\\n    void solve(TreeNode* node, bool goLeft, int currPathLen) {\\n        if (!node) return;\\n        res = max(res, currPathLen);\\n        if (goLeft) {\\n            solve(node->left, false, currPathLen + 1);\\n            solve(node->right, true, 1);\\n        } else {\\n            solve(node->right, true, currPathLen + 1);\\n            solve(node->left, false, 1);\\n        }\\n    }\\n\\n    int longestZigZag(TreeNode* root) {\\n        solve(root, true, 0);\\n        solve(root, false, 0);\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3432989,
                "title": "dfs-solution-with-explanation-c-go",
                "content": "My approach is DFS. My `DFS` function takes `TreeNode`(current node), `bool`(direction), `int`(ZigZag count).\\nWe have two options:\\n1. We continue with direction (if previous was right, we go to left, else we go to right) and increment count. \\n2. We coutinue with another direction (if previous was right, we go to right, else we go to left) and reset count.\\n\\nAnd we choose maximum from this two options.\\n\\n# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(depth)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\nC#\\n```\\npublic class Solution {\\n    public int LongestZigZag(TreeNode root) {\\n        return Math.Max(DFS(root.left, true, 0), DFS(root.right, false, 0));\\n    }\\n\\n    int DFS(TreeNode node, bool isLeft, int count) {\\n        if (node == null) {\\n            return count;\\n        }\\n\\n        if (isLeft) {\\n            return Math.Max(DFS(node.left, true, 0), DFS(node.right, false, count+1));\\n        }\\n        return Math.Max(DFS(node.left, true, count+1), DFS(node.right, false, 0));\\n    }\\n}\\n```\\nGo\\n```\\nfunc longestZigZag(root *TreeNode) int {\\n\\treturn max(dfs(root.Left, true, 0), dfs(root.Right, false, 0))\\n}\\n\\nfunc dfs(node *TreeNode, isLeft bool, count int) int {\\n\\tif node == nil {\\n\\t\\treturn count\\n\\t}\\n\\n\\tif isLeft {\\n\\t\\treturn max(dfs(node.Left, true, 0), dfs(node.Right, false, count+1))\\n\\t}\\n\\n\\treturn max(dfs(node.Left, true, count+1), dfs(node.Right, false, 0))\\n}\\n\\nfunc max(a, b int) int {\\n\\tif a > b {\\n\\t\\treturn a\\n\\t}\\n\\treturn b\\n}\\n```\\n![a6c83c54-1d1a-4f26-8273-b687d119dd5b_1679889261.1494205.png](https://assets.leetcode.com/users/images/cc82e8aa-dc98-4f10-af4c-64b1528c0fb6_1680844232.130332.png)",
                "solutionTags": [
                    "C#",
                    "Go",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```\\npublic class Solution {\\n    public int LongestZigZag(TreeNode root) {\\n        return Math.Max(DFS(root.left, true, 0), DFS(root.right, false, 0));\\n    }\\n\\n    int DFS(TreeNode node, bool isLeft, int count) {\\n        if (node == null) {\\n            return count;\\n        }\\n\\n        if (isLeft) {\\n            return Math.Max(DFS(node.left, true, 0), DFS(node.right, false, count+1));\\n        }\\n        return Math.Max(DFS(node.left, true, count+1), DFS(node.right, false, 0));\\n    }\\n}\\n```\n```\\nfunc longestZigZag(root *TreeNode) int {\\n\\treturn max(dfs(root.Left, true, 0), dfs(root.Right, false, 0))\\n}\\n\\nfunc dfs(node *TreeNode, isLeft bool, count int) int {\\n\\tif node == nil {\\n\\t\\treturn count\\n\\t}\\n\\n\\tif isLeft {\\n\\t\\treturn max(dfs(node.Left, true, 0), dfs(node.Right, false, count+1))\\n\\t}\\n\\n\\treturn max(dfs(node.Left, true, count+1), dfs(node.Right, false, 0))\\n}\\n\\nfunc max(a, b int) int {\\n\\tif a > b {\\n\\t\\treturn a\\n\\t}\\n\\treturn b\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 532399,
                "title": "java-beats-100-percent-with-explanation",
                "content": "I never liked a code which is succint but hard to understand. Specially you need to remember there will be others too who will look at that code and may need to do refactoring. Always liked a code which is easy to understand.\\n\\n```\\npublic int longestZigZag(TreeNode root) {\\n        return longestZigZagHelper(root, 0, 0, true, true);\\n    }\\n\\n    /**\\n\\t * max - current max as we go down to traverse the tree, while coming up it becomes the max possible in that branch \\n\\t * curMax - current max as we go down to travere the tree\\n     * fromLeft - did we land on node as left child\\n     * fromRight - did we land on node as right child\\n     */\\n    private int longestZigZagHelper(TreeNode node, int curMax, int max, boolean fromLeft, boolean fromRight) {\\n        if (node == null) {\\n            return 0;\\n        }\\n        if (node.left == null && node.right == null) {\\n            /**\\n             * when we hit a child node, return the max to upper node.\\n             */\\n            return max;\\n        }\\n        int leftMax = Integer.MIN_VALUE;\\n        if (node.left != null) {\\n            if (fromLeft) {\\n                /**\\n                 * To handle cases like\\n                 *         1\\n                 *        / \\\\      at least max should be 1.\\n                 *       1   1\\n                 */\\n                max = Math.max(max, 1);\\n                leftMax = longestZigZagHelper(node.left, 1, max, true, false);\\n            } else {\\n                /**\\n                 * we are moving on zigzag path as we landed on node being a right child and our next step\\n                 * will be on left child.\\n                 */\\n                max = Math.max(max, curMax + 1);\\n                leftMax = longestZigZagHelper(node.left, curMax + 1, max, true, false);\\n            }\\n        }\\n        int rightMax = Integer.MIN_VALUE;\\n        if (node.right != null) {\\n            if (fromRight) {\\n                /**\\n                 * as mention in above to handle cases\\n                 */\\n                max = Math.max(max, 1);\\n                rightMax = longestZigZagHelper(node.right, 1, max, false, true);\\n            } else {\\n                /**\\n                 * we are moving on zigzag path as we landed on node being a right child and our next step\\n                 * will be on left child.\\n                 */\\n                max = Math.max(max, curMax + 1);\\n                rightMax = longestZigZagHelper(node.right, curMax + 1, max, false, true);\\n            }\\n        }\\n        /**\\n         * return the max zigzag from right child or from left child whatever is max\\n         */\\n        return Math.max(leftMax, rightMax);\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\npublic int longestZigZag(TreeNode root) {\\n        return longestZigZagHelper(root, 0, 0, true, true);\\n    }\\n\\n    /**\\n\\t * max - current max as we go down to traverse the tree, while coming up it becomes the max possible in that branch \\n\\t * curMax - current max as we go down to travere the tree\\n     * fromLeft - did we land on node as left child\\n     * fromRight - did we land on node as right child\\n     */\\n    private int longestZigZagHelper(TreeNode node, int curMax, int max, boolean fromLeft, boolean fromRight) {\\n        if (node == null) {\\n            return 0;\\n        }\\n        if (node.left == null && node.right == null) {\\n            /**\\n             * when we hit a child node, return the max to upper node.\\n             */\\n            return max;\\n        }\\n        int leftMax = Integer.MIN_VALUE;\\n        if (node.left != null) {\\n            if (fromLeft) {\\n                /**\\n                 * To handle cases like\\n                 *         1\\n                 *        / \\\\      at least max should be 1.\\n                 *       1   1\\n                 */\\n                max = Math.max(max, 1);\\n                leftMax = longestZigZagHelper(node.left, 1, max, true, false);\\n            } else {\\n                /**\\n                 * we are moving on zigzag path as we landed on node being a right child and our next step\\n                 * will be on left child.\\n                 */\\n                max = Math.max(max, curMax + 1);\\n                leftMax = longestZigZagHelper(node.left, curMax + 1, max, true, false);\\n            }\\n        }\\n        int rightMax = Integer.MIN_VALUE;\\n        if (node.right != null) {\\n            if (fromRight) {\\n                /**\\n                 * as mention in above to handle cases\\n                 */\\n                max = Math.max(max, 1);\\n                rightMax = longestZigZagHelper(node.right, 1, max, false, true);\\n            } else {\\n                /**\\n                 * we are moving on zigzag path as we landed on node being a right child and our next step\\n                 * will be on left child.\\n                 */\\n                max = Math.max(max, curMax + 1);\\n                rightMax = longestZigZagHelper(node.right, curMax + 1, max, false, true);\\n            }\\n        }\\n        /**\\n         * return the max zigzag from right child or from left child whatever is max\\n         */\\n        return Math.max(leftMax, rightMax);\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3433067,
                "title": "python3-good-enough",
                "content": "``` Python3 []\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def longestZigZag(self, root: Optional[TreeNode]) -> int:\\n        def helper(root, right, total):\\n            if not root:\\n                return total\\n            \\n            l = helper(root.left, False, total+1 if right else 1)\\n            r = helper(root.right, True, total+1 if not right else 1)\\n\\n            return max(l,r)\\n        \\n        return helper(root, None, 0) - 1\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "``` Python3 []\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def longestZigZag(self, root: Optional[TreeNode]) -> int:\\n        def helper(root, right, total):\\n            if not root:\\n                return total\\n            \\n            l = helper(root.left, False, total+1 if right else 1)\\n            r = helper(root.right, True, total+1 if not right else 1)\\n\\n            return max(l,r)\\n        \\n        return helper(root, None, 0) - 1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 531869,
                "title": "python-simple-recursion",
                "content": "```\\nclass Solution:\\n    def longestZigZag(self, root: TreeNode) -> int:\\n        res=0\\n        def helper(root,direction):\\n            nonlocal res\\n            if not root:\\n                return 0\\n            left=helper(root.left,\\'left\\')\\n            right=helper(root.right,\\'right\\')\\n            res=max(res,left+1,right+1)\\n            return right+1 if direction==\\'left\\' else left+1\\n         \\n        if not root:\\n            return 0\\n        helper(root,\\'left\\')\\n        helper(root,\\'right\\')\\n        return res-1\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def longestZigZag(self, root: TreeNode) -> int:\\n        res=0\\n        def helper(root,direction):\\n            nonlocal res\\n            if not root:\\n                return 0\\n            left=helper(root.left,\\'left\\')\\n            right=helper(root.right,\\'right\\')\\n            res=max(res,left+1,right+1)\\n            return right+1 if direction==\\'left\\' else left+1\\n         \\n        if not root:\\n            return 0\\n        helper(root,\\'left\\')\\n        helper(root,\\'right\\')\\n        return res-1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3862418,
                "title": "python-clean-solution-without-pain-image-and-explanation-beats-98",
                "content": "# Intuition\\nMany solutions to this problem on LeetCode can lead to eye strain due to their convoluted logic or excessive code. Here, we\\'re aiming to provide a simple and clean solution, which doesn\\'t compromise on efficiency or readability.\\n\\nTo understand the approach, consider the test case: \\n\\n```[1,1,1,1,1,null,1,null,null,null,null,1,1,null,1]```\\n\\nOn the associated tree diagram, we have highlighted two significant ZigZag paths. An orange path, of length 2, proceeds leftwards from the root, and a green path, of length 3, originates from the right branch of the root.\\n![image.png](https://assets.leetcode.com/users/images/75227891-a05a-4f54-9e55-c8b979c54ec4_1691146564.682754.png)\\n\\n# Approach\\nOur algorithm is rooted in the idea of tracking the length of the ZigZag paths as we traverse the tree, using depth-first search (DFS). The current path length is maintained in two variables - `left` and `right`. At each node, if we go left, we update `left` by adding 1 to `right` and reset `right` to 0. Conversely, if we go right, we add 1 to `left` and reset `left` to 0. This way, we always start a new path with either (0,1) or (1,0).\\n\\nEach ZigZag path length is continuously compared to a global maximum (`self.maxi`), and `self.maxi` is updated whenever a larger ZigZag path is found. At the end, `self.maxi` holds the length of the longest ZigZag path in the tree.\\n\\n# Complexity\\n- Time complexity: : O(n), where n is the number of nodes in the tree. This is because we are doing a single DFS traversal of the tree.\\n\\n- Space complexity: O(h), where h is the height of the tree. This accounts for the maximum size of the implicit call stack for the DFS traversal.\\n\\n---\\n\\nThis solution manages to achieve excellent performance without resorting to eye-gouging code, providing an accessible and elegant approach to a potentially complex problem.\\n\\n# Code\\n```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def longestZigZag(self, root: Optional[TreeNode]) -> int:\\n        self.maxi = 0\\n\\n        def dfs(node, left, right):\\n            self.maxi = max(self.maxi, left, right)\\n\\n            if node.left:\\n                dfs(node.left, right + 1, 0)\\n\\n            if node.right:\\n                dfs(node.right, 0, left + 1)\\n\\n        dfs(root, 0, 0)\\n        return self.maxi\\n\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Depth-First Search"
                ],
                "code": "```[1,1,1,1,1,null,1,null,null,null,null,1,1,null,1]```\n```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def longestZigZag(self, root: Optional[TreeNode]) -> int:\\n        self.maxi = 0\\n\\n        def dfs(node, left, right):\\n            self.maxi = max(self.maxi, left, right)\\n\\n            if node.left:\\n                dfs(node.left, right + 1, 0)\\n\\n            if node.right:\\n                dfs(node.right, 0, left + 1)\\n\\n        dfs(root, 0, 0)\\n        return self.maxi\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3433364,
                "title": "java-solution-easy-steps",
                "content": "```\\nclass Solution {\\n    int max=0;\\n    public int longestZigZag(TreeNode root) {\\n       if (root == null) return -1;\\n        max = 0;\\n        helper(root.right, 1, true);\\n        helper(root.left, 1, false);\\n        return max;   \\n    }\\n     private  void helper(TreeNode root, int step, boolean isRight) {\\n        if (root == null) return;\\n        max = Math.max(max, step);\\n        if (isRight) {\\n            helper(root.left, step + 1, false);\\n            helper(root.right, 1, true);\\n        } else {\\n            helper(root.right, step + 1, true);\\n            helper(root.left, 1, false);\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\n    int max=0;\\n    public int longestZigZag(TreeNode root) {\\n       if (root == null) return -1;\\n        max = 0;\\n        helper(root.right, 1, true);\\n        helper(root.left, 1, false);\\n        return max;   \\n    }\\n     private  void helper(TreeNode root, int step, boolean isRight) {\\n        if (root == null) return;\\n        max = Math.max(max, step);\\n        if (isRight) {\\n            helper(root.left, step + 1, false);\\n            helper(root.right, 1, true);\\n        } else {\\n            helper(root.right, step + 1, true);\\n            helper(root.left, 1, false);\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3433028,
                "title": "easy-solution-of-java-c-with-explanation-beginner-friendly",
                "content": "\\n\\n# Code\\nPLEASE UPVOTE IF YOU LIKE.\\n```\\n\\nclass Solution {\\n    int MAX;\\n    Map<TreeNode, int []> dp;\\n    public int longestZigZag(TreeNode root) {\\n        \\n        //postorder traversal\\n        //Map stores left from node and right from node\\n        dp = new HashMap<>();\\n        dfs(root);\\n        return MAX;\\n    }\\n\\n    //returns max length from here if you go in a particular direction\\n    private void dfs(TreeNode root){\\n        if(root == null) return;\\n\\n        if(root.left == null && root.right == null){\\n            dp.put(root, new int[]{0,0});\\n            return;\\n        }\\n        //In dp value int []\\n        //index 0 represents left direction\\n        //index 1 represents right direction\\n        dfs(root.left);\\n        dfs(root.right);\\n\\n        int left = 0, right = 0;\\n\\n        if(dp.get(root.left) != null)\\n            left = 1 + dp.get(root.left)[1]; //we go right after left\\n        \\n        if(dp.get(root.right) != null)\\n            right = 1 + dp.get(root.right)[0]; //we go left after right\\n        dp.put(root, new int[]{left, right});\\n        MAX = Math.max(MAX, Math.max(left,right));\\n    }\\n}\\n```\\nC++\\n```\\n#include <iostream>\\n#include <unordered_map>\\n#include <vector>\\n\\nusing namespace std;\\n\\nstruct TreeNode {\\n    int val;\\n    TreeNode* left;\\n    TreeNode* right;\\n    TreeNode(int x) : val(x), left(NULL), right(NULL) {}\\n};\\n\\nclass Solution {\\n    int MAX;\\n    unordered_map<TreeNode*, vector<int>> dp;\\npublic:\\n    int longestZigZag(TreeNode* root) {\\n        dp.clear();\\n        dfs(root);\\n        return MAX;\\n    }\\n\\n    void dfs(TreeNode* root) {\\n        if (!root) return;\\n\\n        if (!root->left && !root->right) {\\n            dp[root] = {0, 0};\\n            return;\\n        }\\n\\n        dfs(root->left);\\n        dfs(root->right);\\n\\n        int left = 0, right = 0;\\n\\n        if (dp.find(root->left) != dp.end())\\n            left = 1 + dp[root->left][1];\\n\\n        if (dp.find(root->right) != dp.end())\\n            right = 1 + dp[root->right][0];\\n\\n        dp[root] = {left, right};\\n        MAX = max(MAX, max(left, right));\\n    }\\n};\\n\\n```\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Tree",
                    "Depth-First Search"
                ],
                "code": "```\\n\\nclass Solution {\\n    int MAX;\\n    Map<TreeNode, int []> dp;\\n    public int longestZigZag(TreeNode root) {\\n        \\n        //postorder traversal\\n        //Map stores left from node and right from node\\n        dp = new HashMap<>();\\n        dfs(root);\\n        return MAX;\\n    }\\n\\n    //returns max length from here if you go in a particular direction\\n    private void dfs(TreeNode root){\\n        if(root == null) return;\\n\\n        if(root.left == null && root.right == null){\\n            dp.put(root, new int[]{0,0});\\n            return;\\n        }\\n        //In dp value int []\\n        //index 0 represents left direction\\n        //index 1 represents right direction\\n        dfs(root.left);\\n        dfs(root.right);\\n\\n        int left = 0, right = 0;\\n\\n        if(dp.get(root.left) != null)\\n            left = 1 + dp.get(root.left)[1]; //we go right after left\\n        \\n        if(dp.get(root.right) != null)\\n            right = 1 + dp.get(root.right)[0]; //we go left after right\\n        dp.put(root, new int[]{left, right});\\n        MAX = Math.max(MAX, Math.max(left,right));\\n    }\\n}\\n```\n```\\n#include <iostream>\\n#include <unordered_map>\\n#include <vector>\\n\\nusing namespace std;\\n\\nstruct TreeNode {\\n    int val;\\n    TreeNode* left;\\n    TreeNode* right;\\n    TreeNode(int x) : val(x), left(NULL), right(NULL) {}\\n};\\n\\nclass Solution {\\n    int MAX;\\n    unordered_map<TreeNode*, vector<int>> dp;\\npublic:\\n    int longestZigZag(TreeNode* root) {\\n        dp.clear();\\n        dfs(root);\\n        return MAX;\\n    }\\n\\n    void dfs(TreeNode* root) {\\n        if (!root) return;\\n\\n        if (!root->left && !root->right) {\\n            dp[root] = {0, 0};\\n            return;\\n        }\\n\\n        dfs(root->left);\\n        dfs(root->right);\\n\\n        int left = 0, right = 0;\\n\\n        if (dp.find(root->left) != dp.end())\\n            left = 1 + dp[root->left][1];\\n\\n        if (dp.find(root->right) != dp.end())\\n            right = 1 + dp[root->right][0];\\n\\n        dp[root] = {left, right};\\n        MAX = max(MAX, max(left, right));\\n    }\\n};\\n\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2283892,
                "title": "c-easiest-solution-using-memoization",
                "content": "Explanation:- Traverse the binary tree in a postorder manner and at each node we will calculate the longest zigzag path considering that node as a root and storing the ans in a Map . At each node if the left child is not null we will pass a boolean variable to true to indicate that it should choose the next node as right and similarly if right node is not null we will pass false to indiacate that it should go to the left  and if it cannot move we will simply return 1;\\n\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    int ans=0;\\n    map<pair<TreeNode*,bool>,int>mp;\\n    int longestZigZag(TreeNode* root) {\\n      preorder(root);\\n        return ans;\\n        \\n    }\\n    void preorder(TreeNode*root){\\n        if(root!=NULL){\\n            if(root->left!=NULL){\\n                ans=max(ans,findzig(root->left,true));   // passing the left child with true so that it will move right\\n               \\n            }\\n            if(root->right!=NULL){\\n                ans=max(ans,findzig(root->right,false)); //passing the right child with false so that it will move left\\n              \\n            }\\n            preorder(root->left);  \\n            preorder(root->right);\\n        }\\n    }\\n    int findzig(TreeNode*root,bool chk){\\n        if(mp.find({root,chk})!=mp.end()) return mp[{root,chk}];   // checking if the node is already been computed \\n        if(chk){\\n            // go right\\n            if(root->right!=NULL){\\n                return mp[{root,chk}]=1+findzig(root->right,!chk); // moving left in next iteration\\n            }\\n            }else{\\n                if(root->left!=NULL){\\n                    return mp[{root,chk}]=1+findzig(root->left,!chk); // moving right in next iteration\\n                }\\n            }\\n        return mp[{root,chk}]=1;\\n    }\\n};\\n```\\nPlease upvote if U like my explanation",
                "solutionTags": [
                    "Memoization",
                    "Binary Tree"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    int ans=0;\\n    map<pair<TreeNode*,bool>,int>mp;\\n    int longestZigZag(TreeNode* root) {\\n      preorder(root);\\n        return ans;\\n        \\n    }\\n    void preorder(TreeNode*root){\\n        if(root!=NULL){\\n            if(root->left!=NULL){\\n                ans=max(ans,findzig(root->left,true));   // passing the left child with true so that it will move right\\n               \\n            }\\n            if(root->right!=NULL){\\n                ans=max(ans,findzig(root->right,false)); //passing the right child with false so that it will move left\\n              \\n            }\\n            preorder(root->left);  \\n            preorder(root->right);\\n        }\\n    }\\n    int findzig(TreeNode*root,bool chk){\\n        if(mp.find({root,chk})!=mp.end()) return mp[{root,chk}];   // checking if the node is already been computed \\n        if(chk){\\n            // go right\\n            if(root->right!=NULL){\\n                return mp[{root,chk}]=1+findzig(root->right,!chk); // moving left in next iteration\\n            }\\n            }else{\\n                if(root->left!=NULL){\\n                    return mp[{root,chk}]=1+findzig(root->left,!chk); // moving right in next iteration\\n                }\\n            }\\n        return mp[{root,chk}]=1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 682415,
                "title": "java-simple-dfs",
                "content": "```\\nclass Solution {\\n    int res = 0;\\n    public int longestZigZag(TreeNode root) {\\n        if (root == null) return 0;\\n        dfs(root.left, 1, true);\\n        dfs(root.right, 1, false);\\n        return res;\\n    }\\n    \\n    private void dfs(TreeNode node, int prev, boolean left) {\\n        if (node == null) return;\\n        res = Math.max(res, prev);\\n        dfs(node.left, 1 + (left ? 0 : prev), true);\\n        dfs(node.right,1 + (left ? prev : 0), false);\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    int res = 0;\\n    public int longestZigZag(TreeNode root) {\\n        if (root == null) return 0;\\n        dfs(root.left, 1, true);\\n        dfs(root.right, 1, false);\\n        return res;\\n    }\\n    \\n    private void dfs(TreeNode node, int prev, boolean left) {\\n        if (node == null) return;\\n        res = Math.max(res, prev);\\n        dfs(node.left, 1 + (left ? 0 : prev), true);\\n        dfs(node.right,1 + (left ? prev : 0), false);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3433664,
                "title": "java-recursion",
                "content": "```\\nclass Solution {\\n    int LongestPath = 0;\\n    public int longestZigZag(TreeNode root) {\\n        int[] a = helper(root);\\n        return LongestPath;\\n    }\\n    \\n    //  {Longest Path Ending At leftNode, Longest Path Ending At RightNode}\\n    public int[] helper(TreeNode root) {\\n        if (root == null) {\\n            return new int[]{-1, -1};\\n        }\\n        int[] left = helper(root.left);\\n        int[] right = helper(root.right);\\n        int[] answer = new int[]{left[1] + 1, right[0] + 1};\\n        LongestPath = Math.max(LongestPath, Math.max(answer[0], answer[1]));\\n        return answer;\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    int LongestPath = 0;\\n    public int longestZigZag(TreeNode root) {\\n        int[] a = helper(root);\\n        return LongestPath;\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 3434051,
                "title": "easy-js-solution",
                "content": "# Code\\n```\\nlet ans = 0;\\n\\nvar dfs = (root,left,steps) => {\\n    if(root == undefined){\\n        return \\n    }\\n\\n    ans = Math.max(ans,steps)\\n\\n    if(left){\\n        dfs(root.left, !left, steps+1)\\n        dfs(root.right, left, 1)\\n    }\\n    else{\\n        dfs(root.left, left, 1)\\n        dfs(root.right, !left, steps+1)\\n    }\\n}\\n\\nvar longestZigZag = function(root) {\\n    ans = 0\\n\\n    dfs(root,true,0)\\n    dfs(root,false,0)\\n\\n    return ans;\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Tree",
                    "Depth-First Search",
                    "Binary Tree"
                ],
                "code": "```\\nlet ans = 0;\\n\\nvar dfs = (root,left,steps) => {\\n    if(root == undefined){\\n        return \\n    }\\n\\n    ans = Math.max(ans,steps)\\n\\n    if(left){\\n        dfs(root.left, !left, steps+1)\\n        dfs(root.right, left, 1)\\n    }\\n    else{\\n        dfs(root.left, left, 1)\\n        dfs(root.right, !left, steps+1)\\n    }\\n}\\n\\nvar longestZigZag = function(root) {\\n    ans = 0\\n\\n    dfs(root,true,0)\\n    dfs(root,false,0)\\n\\n    return ans;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1878082,
                "title": "c-dfs-clean-code",
                "content": "```\\nclass Solution {\\npublic:\\n    int ans = 0;\\n    void solve(TreeNode* root , int score, int dir){\\n        if(root == NULL) return ;\\n        ans = max(ans, score);\\n        if(dir == 0)  {solve(root->right, score + 1, 1); solve(root->left, 1, 0);}\\n        else {solve(root->left, score + 1, 0); solve(root->right, 1, 1);}\\n        \\n    }\\n    int longestZigZag(TreeNode* root) {\\n           solve(root->left, 1, 0);\\n           solve(root->right, 1, 1);\\n           return ans;\\n    }\\n};",
                "solutionTags": [
                    "C",
                    "Depth-First Search"
                ],
                "code": "class Solution {\\npublic:\\n    int ans = 0;\\n    void solve(TreeNode* root , int score, int dir){\\n        if(root == NULL) return ;\\n        ans = max(ans, score);\\n        if(dir == 0)  {solve(root->right, score + 1, 1); solve(root->left, 1, 0);}",
                "codeTag": "Java"
            },
            {
                "id": 550153,
                "title": "10-lines-clean-easy-to-understand-well-explained-code",
                "content": "Recurse through the tree. Return for every node what is the max path len if we go left from current node and what is the max path len if we go right from current node. Keep track of maximum. \\n\\n```python\\nclass Solution:\\n    def longestZigZag(self, root: TreeNode) -> int:\\t\\n        self.ans = 0  # global variable to store answer\\n\\t\\t\\n        def recurse(root):\\n\\t\\t\\t# if null return -1 because length is defined \\n\\t\\t\\t# as the number of nodes visited - 1. \\n            if not root: return (-1,-1) \\n\\t\\t\\t\\n\\t\\t\\t# l1 is max path len if we go left from current node and r1 if we go right\\t\\t\\t\\t\\t\\t\\n            l1,r1 = recurse(root.left)\\n            l2,r2 = recurse(root.right)\\n\\t\\t\\t# Notice that if we go left from current node then we have no other choice but\\n\\t\\t\\t# to go right from node.left to make the path zigzag. \\n\\t\\t\\t# That is why  r1 + 1 is the max path len  if we go left from current node. \\n\\t\\t\\t# Same logic for l2 + 1\\n            self.ans = max(self.ans, max(r1 + 1, l2 + 1))\\n            return (r1 + 1, l2 + 1)\\n\\t\\t\\t\\n        recurse(root)\\n        return self.ans\\n```",
                "solutionTags": [
                    "Python",
                    "Recursion"
                ],
                "code": "```python\\nclass Solution:\\n    def longestZigZag(self, root: TreeNode) -> int:\\t\\n        self.ans = 0  # global variable to store answer\\n\\t\\t\\n        def recurse(root):\\n\\t\\t\\t# if null return -1 because length is defined \\n\\t\\t\\t# as the number of nodes visited - 1. \\n            if not root: return (-1,-1) \\n\\t\\t\\t\\n\\t\\t\\t# l1 is max path len if we go left from current node and r1 if we go right\\t\\t\\t\\t\\t\\t\\n            l1,r1 = recurse(root.left)\\n            l2,r2 = recurse(root.right)\\n\\t\\t\\t# Notice that if we go left from current node then we have no other choice but\\n\\t\\t\\t# to go right from node.left to make the path zigzag. \\n\\t\\t\\t# That is why  r1 + 1 is the max path len  if we go left from current node. \\n\\t\\t\\t# Same logic for l2 + 1\\n            self.ans = max(self.ans, max(r1 + 1, l2 + 1))\\n            return (r1 + 1, l2 + 1)\\n\\t\\t\\t\\n        recurse(root)\\n        return self.ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3433173,
                "title": "python3-solution",
                "content": "\\n```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def longestZigZag(self, root: Optional[TreeNode]) -> int:\\n        ans=0\\n        stack=[(root,0,None)]\\n        while stack:\\n            node,n,left=stack.pop()\\n            if node:\\n                ans=max(ans,n)\\n                stack.append((node.left,1 if left else n+1,1))\\n                stack.append((node.right,n+1 if left else 1,0))\\n\\n        return ans        \\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def longestZigZag(self, root: Optional[TreeNode]) -> int:\\n        ans=0\\n        stack=[(root,0,None)]\\n        while stack:\\n            node,n,left=stack.pop()\\n            if node:\\n                ans=max(ans,n)\\n                stack.append((node.left,1 if left else n+1,1))\\n                stack.append((node.right,n+1 if left else 1,0))\\n\\n        return ans        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 713290,
                "title": "clean-c-recursive-solution",
                "content": "```\\nint maxPath;\\nvoid dfs(TreeNode *root,bool goLeft, int pathCovered){\\n\\tif(!root) return;\\n\\tmaxPath = max(maxPath,pathCovered);\\n\\tif(goLeft){\\n\\t\\tdfs(root->left,false,pathCovered+1);\\n\\t\\tdfs(root->right,true,1);\\n\\t}else{\\n\\t\\tdfs(root->left,false,1);\\n\\t\\tdfs(root->right,true,pathCovered+1);\\n\\t}\\n}\\nint longestZigZag(TreeNode* root) {\\n\\tmaxPath = 0;\\n\\tdfs(root,false,0);\\n\\tdfs(root,true,0);\\n\\treturn maxPath;\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nint maxPath;\\nvoid dfs(TreeNode *root,bool goLeft, int pathCovered){\\n\\tif(!root) return;\\n\\tmaxPath = max(maxPath,pathCovered);\\n\\tif(goLeft){\\n\\t\\tdfs(root->left,false,pathCovered+1);\\n\\t\\tdfs(root->right,true,1);\\n\\t}else{\\n\\t\\tdfs(root->left,false,1);\\n\\t\\tdfs(root->right,true,pathCovered+1);\\n\\t}\\n}\\nint longestZigZag(TreeNode* root) {\\n\\tmaxPath = 0;\\n\\tdfs(root,false,0);\\n\\tdfs(root,true,0);\\n\\treturn maxPath;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3433774,
                "title": "c-solution-using-recursion-in-0-n-and-o-1",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nAlways think of the zigzag path that can be formed using current node via left subtree and right subtree and find the maximum.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nIf the current node is a null node return a pair of {0,0} denoting the zigzag path is of length 0. Now, for every node calculate maximum zigzag path using left subtree and then using right subtree and maximize the ans.\\n\\n# Complexity\\n- Time complexity: O(n) -> where n is the number of nodes in tree.\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1) -> space used + O(h) -> where h is the maximum height of tree i.e. recursion stack space.\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    pair<int,int> helper(TreeNode* root, int &ans) {\\n        if(root == NULL) return {0,0};\\n        pair<int,int> l = helper(root->left,ans);\\n        ans = max(ans,1+l.second);\\n        pair<int,int> r = helper(root->right,ans);\\n        ans = max(ans,1+r.first);\\n        return {1+l.second,1+r.first};\\n    }\\n    int longestZigZag(TreeNode* root) {\\n        int ans = 0;\\n        helper(root,ans);\\n        return ans-1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    pair<int,int> helper(TreeNode* root, int &ans) {\\n        if(root == NULL) return {0,0};\\n        pair<int,int> l = helper(root->left,ans);\\n        ans = max(ans,1+l.second);\\n        pair<int,int> r = helper(root->right,ans);\\n        ans = max(ans,1+r.first);\\n        return {1+l.second,1+r.first};\\n    }\\n    int longestZigZag(TreeNode* root) {\\n        int ans = 0;\\n        helper(root,ans);\\n        return ans-1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1777694,
                "title": "c-easy-bfs",
                "content": "```\\nclass Solution {\\npublic:\\n    int longestZigZag(TreeNode* root) {\\n        queue<pair<pair<TreeNode*,char>,int>>q;\\n        if(!root)\\n            return 0;\\n        if(root->left)\\n            q.push({{root->left,\\'L\\'},1});\\n        if(root->right)\\n            q.push({{root->right,\\'R\\'},1});\\n        int maxiLen = 0;\\n        while(!q.empty())\\n        {\\n            pair<pair<TreeNode*,char>,int> pr = q.front();q.pop();\\n            \\n            TreeNode* node = pr.first.first;\\n            char nodeDir = pr.first.second;\\n            int len = pr.second;\\n            \\n            maxiLen = max(maxiLen, len);\\n           //  cout<<node->val<< \" \"<<nodeDir<<\" \"<<len<<endl;\\n            if(node->left)\\n            {\\n                if(nodeDir == \\'L\\')\\n                    q.push({{node->left,\\'L\\'},1});\\n                else\\n                    q.push({{node->left,\\'L\\'},len+1});\\n            }\\n            if(node->right)\\n            {\\n                if(nodeDir == \\'R\\')\\n                    q.push({{node->right,\\'R\\'},1});\\n                else\\n                    q.push({{node->right,\\'R\\'},len+1});\\n            }\\n        }\\n        return maxiLen;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int longestZigZag(TreeNode* root) {\\n        queue<pair<pair<TreeNode*,char>,int>>q;\\n        if(!root)\\n            return 0;\\n        if(root->left)\\n            q.push({{root->left,\\'L\\'},1});\\n        if(root->right)\\n            q.push({{root->right,\\'R\\'},1});\\n        int maxiLen = 0;\\n        while(!q.empty())\\n        {\\n            pair<pair<TreeNode*,char>,int> pr = q.front();q.pop();\\n            \\n            TreeNode* node = pr.first.first;\\n            char nodeDir = pr.first.second;\\n            int len = pr.second;\\n            \\n            maxiLen = max(maxiLen, len);\\n           //  cout<<node->val<< \" \"<<nodeDir<<\" \"<<len<<endl;\\n            if(node->left)\\n            {\\n                if(nodeDir == \\'L\\')\\n                    q.push({{node->left,\\'L\\'},1});\\n                else\\n                    q.push({{node->left,\\'L\\'},len+1});\\n            }\\n            if(node->right)\\n            {\\n                if(nodeDir == \\'R\\')\\n                    q.push({{node->right,\\'R\\'},1});\\n                else\\n                    q.push({{node->right,\\'R\\'},len+1});\\n            }\\n        }\\n        return maxiLen;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 538986,
                "title": "the-art-of-dynamic-programming",
                "content": "[\\uD83C\\uDFA8  The ART of Dynamic Programming:](https://leetcode.com/discuss/general-discussion/712010/The-ART-of-Dynamic-Programming-An-Intuitive-Approach%3A-from-Apprentice-to-Master) Use two counters for left `L` and right `R` to track each node\\'s maximum zig-zag length, ie. similar to Kadane\\'s algorithm we track the \"best ending here\" at each `node` as we traverse the tree.\\n\\n**\\uD83E\\uDD14 Recurrence relations:** let `node` be a child of the `last` node seen during a DFS traversal of the tree\\n* if `node` is the *right* child of `last`, then `L[node] = 1 + R[last]`\\n* if `node` if the *left* child of `last`, then `R[node] = 1 + L[last]`\\n\\n\\uD83C\\uDFAF Return the maximum value of `L` and `R` minus `1`.\\n\\n---\\n\\n*Kotlin*\\n```\\nclass Solution {\\n    fun longestZigZag(root: TreeNode?): Int {\\n        var (L, R) = Pair(mutableMapOf<TreeNode?, Int>(), mutableMapOf<TreeNode?, Int>())\\n        fun go(node: TreeNode? = root, last: TreeNode? = null) {\\n            if (node == null)\\n                return\\n            L[node] = 1 + if (last != null && last.left != node) R[last] ?: 0 else 0\\n            R[node] = 1 + if (last != null && last.right != node) L[last] ?: 0 else 0\\n            go(node?.left, node)\\n            go(node?.right, node)\\n        }\\n        go()\\n        return Math.max(L.values.max()!!, R.values.max()!!) - 1\\n    }\\n}\\n```\\n\\n*Javascript*\\n```\\nlet longestZigZag = (root, L = new Map(), R = new Map()) => {\\n    let go = (node = root, last = null) => {\\n        if (!node)\\n            return;\\n        L.set(node, 1 + (last && last.left != node ? (R.get(last) || 0) : 0));\\n        R.set(node, 1 + (last && last.right != node ? (L.get(last) || 0) : 0));\\n        go(node.left, node);\\n        go(node.right, node);\\n    };\\n    go();\\n    return Math.max(...L.values(), ...R.values()) - 1;\\n};\\n```\\n\\n*Python3*\\n```\\nclass Solution:\\n    def longestZigZag(self, root: Optional[TreeNode]) -> int:\\n        L = Counter()\\n        R = Counter()\\n        def go(node = root, last = None):\\n            if not node:\\n                return\\n            L[node] = 1 + (R[last] if last and last.left != node else 0)\\n            R[node] = 1 + (L[last] if last and last.right != node else 0)\\n            go(node.left, node)\\n            go(node.right, node)\\n        go()\\n        return max(*L.values(), *R.values()) - 1\\n```\\n\\n*C++*\\n```\\nclass Solution {\\npublic:\\n    using fun = function<void(TreeNode*, TreeNode*)>;\\n    using Map = unordered_map<TreeNode*, int>;\\n    using VI = vector<int>;\\n    int longestZigZag(TreeNode* root, Map L = {}, Map R = {}, VI cands = {}) {\\n        fun go = [&](auto node, auto last) {\\n            if (!node)\\n                return;\\n            L[node] = 1 + (last && last->left != node ? R[last] : 0);\\n            R[node] = 1 + (last && last->right != node ? L[last] : 0);\\n            go(node->left, node);\\n            go(node->right, node);\\n        };\\n        go(root, nullptr);\\n        transform(L.begin(), L.end(), back_inserter(cands), [](auto& pair) { return pair.second; });\\n        transform(R.begin(), R.end(), back_inserter(cands), [](auto& pair) { return pair.second; });\\n        return *max_element(cands.begin(), cands.end()) - 1;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    fun longestZigZag(root: TreeNode?): Int {\\n        var (L, R) = Pair(mutableMapOf<TreeNode?, Int>(), mutableMapOf<TreeNode?, Int>())\\n        fun go(node: TreeNode? = root, last: TreeNode? = null) {\\n            if (node == null)\\n                return\\n            L[node] = 1 + if (last != null && last.left != node) R[last] ?: 0 else 0\\n            R[node] = 1 + if (last != null && last.right != node) L[last] ?: 0 else 0\\n            go(node?.left, node)\\n            go(node?.right, node)\\n        }\\n        go()\\n        return Math.max(L.values.max()!!, R.values.max()!!) - 1\\n    }\\n}\\n```\n```\\nlet longestZigZag = (root, L = new Map(), R = new Map()) => {\\n    let go = (node = root, last = null) => {\\n        if (!node)\\n            return;\\n        L.set(node, 1 + (last && last.left != node ? (R.get(last) || 0) : 0));\\n        R.set(node, 1 + (last && last.right != node ? (L.get(last) || 0) : 0));\\n        go(node.left, node);\\n        go(node.right, node);\\n    };\\n    go();\\n    return Math.max(...L.values(), ...R.values()) - 1;\\n};\\n```\n```\\nclass Solution:\\n    def longestZigZag(self, root: Optional[TreeNode]) -> int:\\n        L = Counter()\\n        R = Counter()\\n        def go(node = root, last = None):\\n            if not node:\\n                return\\n            L[node] = 1 + (R[last] if last and last.left != node else 0)\\n            R[node] = 1 + (L[last] if last and last.right != node else 0)\\n            go(node.left, node)\\n            go(node.right, node)\\n        go()\\n        return max(*L.values(), *R.values()) - 1\\n```\n```\\nclass Solution {\\npublic:\\n    using fun = function<void(TreeNode*, TreeNode*)>;\\n    using Map = unordered_map<TreeNode*, int>;\\n    using VI = vector<int>;\\n    int longestZigZag(TreeNode* root, Map L = {}, Map R = {}, VI cands = {}) {\\n        fun go = [&](auto node, auto last) {\\n            if (!node)\\n                return;\\n            L[node] = 1 + (last && last->left != node ? R[last] : 0);\\n            R[node] = 1 + (last && last->right != node ? L[last] : 0);\\n            go(node->left, node);\\n            go(node->right, node);\\n        };\\n        go(root, nullptr);\\n        transform(L.begin(), L.end(), back_inserter(cands), [](auto& pair) { return pair.second; });\\n        transform(R.begin(), R.end(), back_inserter(cands), [](auto& pair) { return pair.second; });\\n        return *max_element(cands.begin(), cands.end()) - 1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 531878,
                "title": "python-iterative-dfs",
                "content": "```\\n    def longestZigZag(self, root: TreeNode) -> int:\\n        ans = 0\\n        nodes = [(root, False, 0), (root, True, 0)]\\n        while nodes:\\n            node, right, length = nodes.pop()\\n            if node:\\n\\t\\t\\t\\tans = max(ans, length)\\n\\t\\t\\t\\tnodes.append((node.right if right else node.left, not right, length + 1))\\n\\t\\t\\t\\tnodes.append((node.left if right else node.right, right, 1))\\n        return ans\\n```",
                "solutionTags": [],
                "code": "```\\n    def longestZigZag(self, root: TreeNode) -> int:\\n        ans = 0\\n        nodes = [(root, False, 0), (root, True, 0)]\\n        while nodes:\\n            node, right, length = nodes.pop()\\n            if node:\\n\\t\\t\\t\\tans = max(ans, length)\\n\\t\\t\\t\\tnodes.append((node.right if right else node.left, not right, length + 1))\\n\\t\\t\\t\\tnodes.append((node.left if right else node.right, right, 1))\\n        return ans\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3435925,
                "title": "dfs-solution-java-solution-o-n",
                "content": "# Approach\\n1. The code follows a depth-first search (DFS) approach to traverse the binary tree and find the longest zigzag path. It uses a recursive helper function called dfs to perform the DFS.\\n2. The **dfs function** takes a node, a length of the path so far, and a boolean flag indicating whether the previous node traversed was a left child or a right child.\\n3. For each node, the function updates the **ans** variable if the current length is greater than the current **ans**. It then recursively calls itself on the node\\'s left and right child nodes, passing the length of the path so far incremented by 1, and the opposite of the **isLeft** flag of the current node.\\n4. By doing this, the function explores all possible zigzag paths in the binary tree and returns the length of the longest one. \\n5. The main function calls the **dfs function** twice, once for the left subtree of the root node with **isLeft** set to true and once for the right subtree of the root node with **isLeft** set to false. \\n6. Finally, it returns the value of **ans**, which holds the length of the longest zigzag path found.\\n\\n---\\n\\n- **DO NOT USE** *static int ans=0* , it will give error in the next testcase.\\n\\n# Complexity\\n- Time complexity: The time complexity of the given code is **O(n)**, where n is the number of nodes in the binary tree. \\n\\n- Space complexity: The space complexity of the code is **O(h)**, where h is the height of the binary tree.\\n\\n# Code\\n```\\nclass Solution {\\n     int ans=0;\\n    public int longestZigZag(TreeNode root) {\\n        dfs(root.left,1,true);\\n        dfs(root.right,1,false);\\n        return ans;\\n        \\n    }\\n    public void dfs(TreeNode node,int len,boolean isLeft)\\n    {\\n        if(node==null)\\n            return;\\n        ans=Math.max(len,ans);\\n        if(isLeft)\\n        {\\n            dfs(node.right,len+1,false);\\n            dfs(node.left,1,true);\\n        }\\n        else\\n        {\\n            dfs(node.right,1,false);\\n            dfs(node.left,len+1,true);\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Tree",
                    "Depth-First Search",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\n     int ans=0;\\n    public int longestZigZag(TreeNode root) {\\n        dfs(root.left,1,true);\\n        dfs(root.right,1,false);\\n        return ans;\\n        \\n    }\\n    public void dfs(TreeNode node,int len,boolean isLeft)\\n    {\\n        if(node==null)\\n            return;\\n        ans=Math.max(len,ans);\\n        if(isLeft)\\n        {\\n            dfs(node.right,len+1,false);\\n            dfs(node.left,1,true);\\n        }\\n        else\\n        {\\n            dfs(node.right,1,false);\\n            dfs(node.left,len+1,true);\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3435126,
                "title": "beginner-friendly-solution-c-solution-95-faster",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n- The idea is to get the maximum length of zigzag sequence for each node.\\n- Checking Left-Right-Left or Right-Left-Right, sequence for each node.\\n\\n# Approach\\nChoose a convention to traverse in a zigzag manner, for example\\n> 0 or false  for going left\\n>1 or true for going right\\n\\nThe idea is to traverse the tree in a zigzag manner\\n1. If node is Null, return the control back\\n2. For every node check the maximum length of \\n[left zigzag sequence(L->R->L), Right Zigzag sequence (R->L->R)]\\n3. If the sequence continue, keep increasing the length \\n4. Else, make the current node as the starting point and repeat steps 1,2,3,4\\n5. For each recursive call, keep updating the maximum length \\n\\nOnce all the nodes have been traversed, return the maximum length - 1\\n\\n# Complexity\\n- Time complexity : $$O(n)$$\\n<!-- Add your time complexity here, e.g.  -->\\n\\n- Space complexity : $$O(1)$$, Ignoring the Recursive stack that was used\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution // Direction = 0, means we went left\\n{              // Direction = 1, means we went right\\npublic:\\n    int max_len = 0; // Store the maximum length in the max_lenwer variable\\n    void Get_Maximum_Length(TreeNode *node, int direction, int curr_length)\\n    {\\n        if (node == NULL) // If Node is Null, then its an end point\\n            return;       // Just return back the control\\n\\n        max_len = max(max_len, curr_length); // Storing the maximum length so far\\n\\n        if (direction == 0) // If Direction is 0,\\n        {                   // i.e. The current Node is the left part of the sequence\\n\\n            // Now we go right and increase the current length by 1\\n            Get_Maximum_Length(node->right, 1, curr_length + 1);\\n\\n            // If we go left again, we will not be making a zigzag sequence\\n            // And so we have to neglect the current length.\\n            // And find a path with current node as the starting point\\n            // Therefore we hold the current node as centre and traverse to the left\\n            // We send curr_length as 2, because if the left exists then surely there will\\n            // At least Two nodes in this sequence, hence length = 2\\n            Get_Maximum_Length(node->left, 0, 2);\\n        }\\n        else // Direction is 1,\\n        {    // i.e. The current Node is the right part of the sequence\\n\\n            // Now we go left and increase the current length by 1\\n            Get_Maximum_Length(node->left, 0, curr_length + 1);\\n\\n            // If we go right again, we will not be making a zigzag sequence\\n            // And so we have to neglect the current length.\\n            // And find a path with current node as the starting point\\n            // Therefore we hold the current node as centre and traverse to the right\\n            // We send curr_length as 2, because if the right exists then surely there will\\n            // At least Two nodes in this sequence, and hence length = 2\\n            Get_Maximum_Length(node->right, 1, 2);\\n        }\\n    }\\n    int longestZigZag(TreeNode *root)\\n    {\\n        // Check the maximum length to the left\\n        Get_Maximum_Length(root, 0, 1);\\n        // Check the maximum length to the right\\n        Get_Maximum_Length(root, 1, 1);\\n        // Returning max_len - 1, as asked in the question\\n        return max_len - 1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Tree",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution // Direction = 0, means we went left\\n{              // Direction = 1, means we went right\\npublic:\\n    int max_len = 0; // Store the maximum length in the max_lenwer variable\\n    void Get_Maximum_Length(TreeNode *node, int direction, int curr_length)\\n    {\\n        if (node == NULL) // If Node is Null, then its an end point\\n            return;       // Just return back the control\\n\\n        max_len = max(max_len, curr_length); // Storing the maximum length so far\\n\\n        if (direction == 0) // If Direction is 0,\\n        {                   // i.e. The current Node is the left part of the sequence\\n\\n            // Now we go right and increase the current length by 1\\n            Get_Maximum_Length(node->right, 1, curr_length + 1);\\n\\n            // If we go left again, we will not be making a zigzag sequence\\n            // And so we have to neglect the current length.\\n            // And find a path with current node as the starting point\\n            // Therefore we hold the current node as centre and traverse to the left\\n            // We send curr_length as 2, because if the left exists then surely there will\\n            // At least Two nodes in this sequence, hence length = 2\\n            Get_Maximum_Length(node->left, 0, 2);\\n        }\\n        else // Direction is 1,\\n        {    // i.e. The current Node is the right part of the sequence\\n\\n            // Now we go left and increase the current length by 1\\n            Get_Maximum_Length(node->left, 0, curr_length + 1);\\n\\n            // If we go right again, we will not be making a zigzag sequence\\n            // And so we have to neglect the current length.\\n            // And find a path with current node as the starting point\\n            // Therefore we hold the current node as centre and traverse to the right\\n            // We send curr_length as 2, because if the right exists then surely there will\\n            // At least Two nodes in this sequence, and hence length = 2\\n            Get_Maximum_Length(node->right, 1, 2);\\n        }\\n    }\\n    int longestZigZag(TreeNode *root)\\n    {\\n        // Check the maximum length to the left\\n        Get_Maximum_Length(root, 0, 1);\\n        // Check the maximum length to the right\\n        Get_Maximum_Length(root, 1, 1);\\n        // Returning max_len - 1, as asked in the question\\n        return max_len - 1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3434714,
                "title": "c-solution-easy-and-explained-recursive-code-commented-and-explained",
                "content": "![20230419_121913000_iOS.jpg](https://assets.leetcode.com/users/images/e4729c9b-4349-4601-8796-45d714581655_1681907007.8512464.jpeg)\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    void zig(bool dir,int &max_len,TreeNode* node,int length){\\n        if(node == NULL){\\n            return;\\n        }\\n        max_len = max(length,max_len);\\n        zig(0,max_len,node->left,dir?length+1:1); // dir=0 i.e. 0 means left node, if dir=1 that means this node was at right side previously and if dir=0 that means that this node was at left side previously\\n        zig(1,max_len,node->right,dir?1:length+1); // dir=1 i.e. 1 means right node,  \\n    }\\n    int longestZigZag(TreeNode* root) {\\n        int max_len=0;\\n        zig(0,max_len,root,0);  // At root node, left and right both nodes qualify as the zig-zag path\\n        zig(1,max_len,root,0);  // That\\'s why we called function 2 times with different dir\\n        return max_len;        \\n    }\\n};\\n```\\n![upvote cat.jpeg](https://assets.leetcode.com/users/images/6ac9f885-df47-414d-8e35-b20f6bc3b9ed_1681906739.2323492.jpeg)\\n",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void zig(bool dir,int &max_len,TreeNode* node,int length){\\n        if(node == NULL){\\n            return;\\n        }\\n        max_len = max(length,max_len);\\n        zig(0,max_len,node->left,dir?length+1:1); // dir=0 i.e. 0 means left node, if dir=1 that means this node was at right side previously and if dir=0 that means that this node was at left side previously\\n        zig(1,max_len,node->right,dir?1:length+1); // dir=1 i.e. 1 means right node,  \\n    }\\n    int longestZigZag(TreeNode* root) {\\n        int max_len=0;\\n        zig(0,max_len,root,0);  // At root node, left and right both nodes qualify as the zig-zag path\\n        zig(1,max_len,root,0);  // That\\'s why we called function 2 times with different dir\\n        return max_len;        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3433533,
                "title": "easy-c-solution-optimized",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int longestZigZag(TreeNode* root) {\\n        int maxLen = 0;\\n        dfs(root, maxLen);\\n        return maxLen;\\n    }\\n    \\n    pair<int, int> dfs(TreeNode* node, int& maxLen) {\\n        if (!node) {\\n            return {0, 0};\\n        }\\n        \\n        auto left = dfs(node->left, maxLen);\\n        auto right = dfs(node->right, maxLen);\\n        \\n        int leftMax = left.second, rightMax = right.first;\\n        maxLen = max(maxLen, max(leftMax, rightMax));\\n        \\n        return {1 + left.second, 1 + right.first};\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int longestZigZag(TreeNode* root) {\\n        int maxLen = 0;\\n        dfs(root, maxLen);\\n        return maxLen;\\n    }\\n    \\n    pair<int, int> dfs(TreeNode* node, int& maxLen) {\\n        if (!node) {\\n            return {0, 0};\\n        }\\n        \\n        auto left = dfs(node->left, maxLen);\\n        auto right = dfs(node->right, maxLen);\\n        \\n        int leftMax = left.second, rightMax = right.first;\\n        maxLen = max(maxLen, max(leftMax, rightMax));\\n        \\n        return {1 + left.second, 1 + right.first};\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3433531,
                "title": "python3-solution-with-explanation-longest-zigzag-path-in-a-binary-tree",
                "content": "**Approach** :\\n\\nWe can use a recursive Depth First Search (DFS) approach to traverse the binary tree and keep track of the length of the longest ZigZag path seen so far.\\n\\nWe can define a helper function **dfs** that takes four arguments: the current node being visited, the length of the longest ZigZag path seen so far when the last move was to the left, the length of the longest ZigZag path seen so far when the last move was to the right, and the overall maximum length of any ZigZag path seen so far.\\n\\nIn each recursive call of the **dfs** function, we update the overall maximum length seen so far to the maximum of the current **max_len**, **left_len**, and **right_len**. We then make two recursive calls, one for the left child and one for the right child. We update the length of the ZigZag path seen so far in the left and right recursive calls based on the direction of the last move (left or right) and set the other length to zero.\\n\\nFinally, we return the updated **max_len** value after all nodes in the binary tree have been visited.\\n\\n**Time Complexity** :\\n\\nThe time complexity of this approach is **O(n)**, where **n** is the number of nodes in the binary tree. This is because we visit each node exactly once during the DFS traversal.\\n\\n**Space Complexity** :\\n\\nThe space complexity of this approach is **O(h)**, where **h** is the height of the binary tree. This is because the depth of the recursive call stack is equal to the height of the binary tree.\\n\\n**Solution** :\\n\\n```\\nclass Solution:\\n    def longestZigZag(self, root: TreeNode) -> int:\\n        def dfs(node: TreeNode, left_len: int, right_len: int, max_len: int) -> int:\\n            if not node:\\n                return max_len\\n            max_len = max(max_len, left_len, right_len)\\n            return max(\\n                dfs(node.left, 0, left_len + 1, max_len),\\n                dfs(node.right, right_len + 1, 0, max_len),\\n            )\\n        return dfs(root, 0, 0, 0)\\n````",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def longestZigZag(self, root: TreeNode) -> int:\\n        def dfs(node: TreeNode, left_len: int, right_len: int, max_len: int) -> int:\\n            if not node:\\n                return max_len\\n            max_len = max(max_len, left_len, right_len)\\n            return max(\\n                dfs(node.left, 0, left_len + 1, max_len),\\n                dfs(node.right, right_len + 1, 0, max_len),\\n            )\\n        return dfs(root, 0, 0, 0)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2974248,
                "title": "c-readable-code-using-pair-class-and-recursion-o-n-complexity",
                "content": "```\\nclass Pair {\\npublic:\\n    int forwardSlash = -1;\\n    int backwardSlash = -1;\\n    int maxZZ = 0;\\n};\\n\\nclass Solution {\\npublic:\\n    Pair findZigZag(TreeNode* root){\\n        if(!root) {\\n            Pair nodeAns;\\n            return nodeAns; //returning default values i.e., -1, -1, 0\\n        }\\n        \\n        Pair left = findZigZag(root->left);\\n        Pair right = findZigZag(root->right);\\n        \\n        Pair nodeAns;\\n        \\n\\t\\t//finding maximium ZigZag path -> [continious or past maximum path]\\n        nodeAns.maxZZ = max(max(left.maxZZ, right.maxZZ) ,max(left.backwardSlash, right.forwardSlash)+1); \\n\\t\\t\\n\\t\\t//finding current path\\n\\t\\t\\n\\t\\t//Remember we need to find Zig Zag path ->relate the following code accordingly!\\n        nodeAns.forwardSlash = left.backwardSlash +1;\\n        nodeAns.backwardSlash = right.forwardSlash +1;\\n        \\n        return nodeAns;\\n    }\\n    \\n    \\n    int longestZigZag(TreeNode* root) {\\n        Pair maxi = findZigZag(root);\\n        \\n        return maxi.maxZZ;\\n    }\\n};\\n```\\n\\n-> The code is not completely explained because I want to make sure that you\\'ll try to think on your own and understand better. This will make sure that the next time you see a similar question you can realize and apply this approach on your own.\\n\\n-> If you still cannot understand my approach feel free to ask me in comments... I\\'ll definitely try to help as soon as possible!\\n\\nThank you\\nP.S.:-  Please upvote if you like my approach!",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Pair {\\npublic:\\n    int forwardSlash = -1;\\n    int backwardSlash = -1;\\n    int maxZZ = 0;\\n};\\n\\nclass Solution {\\npublic:\\n    Pair findZigZag(TreeNode* root){\\n        if(!root) {\\n            Pair nodeAns;\\n            return nodeAns; //returning default values i.e., -1, -1, 0\\n        }\\n        \\n        Pair left = findZigZag(root->left);\\n        Pair right = findZigZag(root->right);\\n        \\n        Pair nodeAns;\\n        \\n\\t\\t//finding maximium ZigZag path -> [continious or past maximum path]\\n        nodeAns.maxZZ = max(max(left.maxZZ, right.maxZZ) ,max(left.backwardSlash, right.forwardSlash)+1); \\n\\t\\t\\n\\t\\t//finding current path\\n\\t\\t\\n\\t\\t//Remember we need to find Zig Zag path ->relate the following code accordingly!\\n        nodeAns.forwardSlash = left.backwardSlash +1;\\n        nodeAns.backwardSlash = right.forwardSlash +1;\\n        \\n        return nodeAns;\\n    }\\n    \\n    \\n    int longestZigZag(TreeNode* root) {\\n        Pair maxi = findZigZag(root);\\n        \\n        return maxi.maxZZ;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2549701,
                "title": "easy-to-understand",
                "content": "```\\nclass Solution\\n{\\npublic:\\n    int maxi = 0;\\n    pair<int, int> rec(TreeNode *root)\\n    {\\n        if (root == NULL)\\n        {\\n            return {0, 0};\\n        }\\n        pair<int, int> left = rec(root->left);\\n        pair<int, int> right = rec(root->right);\\n        maxi = max({maxi,1 + left.second,1 + right.first});\\n        return {1 + left.second, 1 + right.first};\\n    }\\n\\n    int longestZigZag(TreeNode *root)\\n    {\\n        rec(root);\\n        return maxi;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Recursion",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution\\n{\\npublic:\\n    int maxi = 0;\\n    pair<int, int> rec(TreeNode *root)\\n    {\\n        if (root == NULL)\\n        {\\n            return {0, 0};\\n        }\\n        pair<int, int> left = rec(root->left);\\n        pair<int, int> right = rec(root->right);\\n        maxi = max({maxi,1 + left.second,1 + right.first});\\n        return {1 + left.second, 1 + right.first};\\n    }\\n\\n    int longestZigZag(TreeNode *root)\\n    {\\n        rec(root);\\n        return maxi;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1794014,
                "title": "c-passing-data-from-bottom-to-up",
                "content": "**Keep in mind:-** There are always two methods to pass data from one node to another node in recursion(except global variable)\\n1. from top to bottom\\n2.  from bottom to up\\n3.  to solve any problem(specifically of tree) always think like this,it will help.\\n\\nI am returning ```{left,right}``` from every node,\\n1. left means-> length of path starting from that node and moving towards left,\\n2.  right means:- length of path starting from that node and moving towards right\\n```\\nclass Solution {\\npublic:\\n    int ans;\\n    int longestZigZag(TreeNode* root) {\\n        ans=0;\\n        find(root);\\n        return ans-1;\\n    }\\n    pair<int,int> find(TreeNode*root){\\n        if(!root)\\n            return {0,0};\\n        auto left=find(root->left);\\n        auto right=find(root->right);\\n        int leftCnt=1+left.second,rightCnt=1+right.first;\\n        ans=max(ans,max(leftCnt,rightCnt));\\n        return {leftCnt,rightCnt};\\n    }\\n};\\n```\\nDo **UPVOTE** if it helps :)",
                "solutionTags": [
                    "C"
                ],
                "code": "```{left,right}```\n```\\nclass Solution {\\npublic:\\n    int ans;\\n    int longestZigZag(TreeNode* root) {\\n        ans=0;\\n        find(root);\\n        return ans-1;\\n    }\\n    pair<int,int> find(TreeNode*root){\\n        if(!root)\\n            return {0,0};\\n        auto left=find(root->left);\\n        auto right=find(root->right);\\n        int leftCnt=1+left.second,rightCnt=1+right.first;\\n        ans=max(ans,max(leftCnt,rightCnt));\\n        return {leftCnt,rightCnt};\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1536952,
                "title": "python-recursion-sol-and-iteration-sol-easy-and-clean",
                "content": "# Iteration\\n```\\nclass Solution:\\n    def longestZigZag(self, root: Optional[TreeNode]) -> int:\\n        res = 0\\n        if not root: return res\\n        q= deque() # node, isLeft, depth\\n        if root.left: \\n            q.append((root.left,True,1))\\n        if root.right:\\n            q.append((root.right, False,1))\\n        \\n        while q:\\n            node,isleft,depth = q.popleft()\\n            res = max(res,depth)\\n            if isleft:\\n                if node.right: \\n                    q.append((node.right,False,depth+1))\\n                if node.left:\\n                    q.append((node.left,True,1))\\n                \\n            else:\\n                if node.left:\\n                    q.append((node.left,True,depth+1))\\n                if node.right:\\n                    q.append((node.right,False,1))\\n        return res\\n```\\n# Recursion\\n```\\nclass Solution:\\n    def longestZigZag(self, root: Optional[TreeNode]) -> int:\\n        self.res = 0\\n        self.dfs(root.left,True,1)\\n        self.dfs(root.right,False,1)\\n        return self.res\\n    \\n    def dfs(self,node,isLeft,depth):\\n        if not node: return\\n        self.res = max(self.res,depth)\\n        \\n        if isLeft:\\n            self.dfs(node.left,True,1)\\n            self.dfs(node.right,False,depth+1)\\n        else:\\n            self.dfs(node.left,True,depth+1)\\n            self.dfs(node.right,False,1)\\n```",
                "solutionTags": [
                    "Python",
                    "Depth-First Search",
                    "Breadth-First Search",
                    "Recursion",
                    "Iterator"
                ],
                "code": "```\\nclass Solution:\\n    def longestZigZag(self, root: Optional[TreeNode]) -> int:\\n        res = 0\\n        if not root: return res\\n        q= deque() # node, isLeft, depth\\n        if root.left: \\n            q.append((root.left,True,1))\\n        if root.right:\\n            q.append((root.right, False,1))\\n        \\n        while q:\\n            node,isleft,depth = q.popleft()\\n            res = max(res,depth)\\n            if isleft:\\n                if node.right: \\n                    q.append((node.right,False,depth+1))\\n                if node.left:\\n                    q.append((node.left,True,1))\\n                \\n            else:\\n                if node.left:\\n                    q.append((node.left,True,depth+1))\\n                if node.right:\\n                    q.append((node.right,False,1))\\n        return res\\n```\n```\\nclass Solution:\\n    def longestZigZag(self, root: Optional[TreeNode]) -> int:\\n        self.res = 0\\n        self.dfs(root.left,True,1)\\n        self.dfs(root.right,False,1)\\n        return self.res\\n    \\n    def dfs(self,node,isLeft,depth):\\n        if not node: return\\n        self.res = max(self.res,depth)\\n        \\n        if isLeft:\\n            self.dfs(node.left,True,1)\\n            self.dfs(node.right,False,depth+1)\\n        else:\\n            self.dfs(node.left,True,depth+1)\\n            self.dfs(node.right,False,1)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3436432,
                "title": "java-c-javascript-step-by-step-to-1-liner",
                "content": "# Approach\\nDo a DFS keeping track of `left` zigzag path and `right` zigzag path terminating at current `node`. They are both `0` at `root`.\\n\\n`left` zigzag path means current `node` is a left child of its parent and similar definition for `right`.\\n\\nIf we move to `node.left` (a left turn), we are able to extend `right` zigzag path by 1. Also note from `node.left`\\'s point of view, this `right + 1` is actually a *left* zigzag path (because `node.left` is a left child of its parent). *right* zigzag path however becomes `0` since `node.left` is not a right child of its parent. So `node.left` receives `left = right + 1` and `right = 0` from its parent.\\n\\nSimilar reasoning applies for `node.right`.\\n\\nOur path terminates when we reach a `null` node but by that point, we have already counted `leaf node -> null` into the path, so we just take `max(left, right) - 1`. (We are only interested in either `left` or `right` but since other would anyway be `0`, `max()` would work).\\n\\n# Code\\n\\nJava\\n```\\nclass Solution {\\n    private int dfs(TreeNode node, int left, int right) {\\n        if (node == null) return Math.max(left, right) - 1;\\n        int bestPathLeft = dfs(node.left, right + 1, 0);\\n        int bestPathRight = dfs(node.right, 0, left + 1);\\n        return Math.max(bestPathLeft, bestPathRight);\\n    }\\n    public int longestZigZag(TreeNode root) {\\n        return dfs(root, 0, 0);\\n    }\\n}\\n```\\n\\nOptimization 1: If we set initial path values as `-1`, we don\\'t need to do `max() - 1` at `null` node.\\nOptimization 2: Let\\'s use ternary operator.\\n\\n```\\nclass Solution {\\n    private int dfs(TreeNode node, int left, int right) {\\n        return node == null ? Math.max(left, right) : Math.max(dfs(node.left, right + 1, -1), dfs(node.right, -1, left + 1));\\n    }\\n    public int longestZigZag(TreeNode root) {\\n        return dfs(root, -1, -1);\\n    }\\n}\\n```\\n\\nOptimization 3: Use a language that allows default parameters. \\uD83D\\uDE09\\n\\nC++\\n```\\nclass Solution {\\npublic:\\n    int longestZigZag(TreeNode* root, int left = -1, int right = -1) {\\n        return !root ? max(left, right) : max(longestZigZag(root->left, right + 1), longestZigZag(root->right, -1, left + 1));\\n    }\\n};\\n```\\n\\nJavaScript\\n```\\nvar longestZigZag = function(root, left = -1, right = -1) {\\n    return !root ? Math.max(left, right) : Math.max(longestZigZag(root.left, right + 1), longestZigZag(root.right, -1, left + 1))\\n};\\n```\\n\\nTime complexity: $$O(n)$$\\nSpace complexity: $$O(n)$$\\n\\nP.S. Don\\'t write such code at work \\uD83D\\uDE05",
                "solutionTags": [
                    "C++",
                    "Java",
                    "JavaScript"
                ],
                "code": "```\\nclass Solution {\\n    private int dfs(TreeNode node, int left, int right) {\\n        if (node == null) return Math.max(left, right) - 1;\\n        int bestPathLeft = dfs(node.left, right + 1, 0);\\n        int bestPathRight = dfs(node.right, 0, left + 1);\\n        return Math.max(bestPathLeft, bestPathRight);\\n    }\\n    public int longestZigZag(TreeNode root) {\\n        return dfs(root, 0, 0);\\n    }\\n}\\n```\n```\\nclass Solution {\\n    private int dfs(TreeNode node, int left, int right) {\\n        return node == null ? Math.max(left, right) : Math.max(dfs(node.left, right + 1, -1), dfs(node.right, -1, left + 1));\\n    }\\n    public int longestZigZag(TreeNode root) {\\n        return dfs(root, -1, -1);\\n    }\\n}\\n```\n```\\nclass Solution {\\npublic:\\n    int longestZigZag(TreeNode* root, int left = -1, int right = -1) {\\n        return !root ? max(left, right) : max(longestZigZag(root->left, right + 1), longestZigZag(root->right, -1, left + 1));\\n    }\\n};\\n```\n```\\nvar longestZigZag = function(root, left = -1, right = -1) {\\n    return !root ? Math.max(left, right) : Math.max(longestZigZag(root.left, right + 1), longestZigZag(root.right, -1, left + 1))\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3436056,
                "title": "java-binary-tree-longest-zigzag-path",
                "content": "\\n```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n     public void dfs(AtomicInteger count, boolean right, TreeNode start, AtomicInteger maxCount)\\n     {\\n         if (start != null)\\n         {\\n             count.set(count.get() + 1);\\n             right = !right;\\n             dfs(count, right, !right ? start.right : start.left, maxCount);\\n             right = !right;\\n             count.set(count.get() + 1);\\n             dfs(count, right, right ? start.left : start.right, maxCount);\\n         }\\n         else {\\n             maxCount.set(Math.max(maxCount.get(), count.get()));\\n             count.set(-1);\\n         }\\n     }\\n     \\n    public int longestZigZag(TreeNode root) {\\n        AtomicInteger count = new AtomicInteger(-1);\\n        AtomicInteger maxCount = new AtomicInteger(0);\\n        dfs(count, true, root, maxCount);\\n         return maxCount.get();\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n     public void dfs(AtomicInteger count, boolean right, TreeNode start, AtomicInteger maxCount)\\n     {\\n         if (start != null)\\n         {\\n             count.set(count.get() + 1);\\n             right = !right;\\n             dfs(count, right, !right ? start.right : start.left, maxCount);\\n             right = !right;\\n             count.set(count.get() + 1);\\n             dfs(count, right, right ? start.left : start.right, maxCount);\\n         }\\n         else {\\n             maxCount.set(Math.max(maxCount.get(), count.get()));\\n             count.set(-1);\\n         }\\n     }\\n     \\n    public int longestZigZag(TreeNode root) {\\n        AtomicInteger count = new AtomicInteger(-1);\\n        AtomicInteger maxCount = new AtomicInteger(0);\\n        dfs(count, true, root, maxCount);\\n         return maxCount.get();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3434940,
                "title": "day-109-easy-recursion-approach-c",
                "content": "# Intuition and Approach\\nWe have to simply traverse all possible *zig-zag routes* in the tree\\nand we have condition that we have to go in left and right direction alternatively everytime , we can also start taking the path from any internal node\\n\\nSo, we have to go in all possible routes and find the max answer\\n\\nFirstly we have to make a direction factor which tells us which direction(i.e. left or right) we have to go in\\nso if we have to go right the direction : `dir = 1` and for left direction : `dir =0`\\n\\nNow we also have to create an answer(`ans`) factor which calculate our current path length  \\n\\nNow go to code section to understand question better,\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    int max_ans=0;\\n    void solve(TreeNode* root,int dir,int ans){\\n        // left = 0, right = 1  --> parameter for taking the direction\\n        //base condition\\n        if(!root){return;}\\n\\n        //updating the answer\\n        max_ans = max(max_ans,ans);\\n\\n        if(dir==0){\\n            //going in the left direction\\n            solve(root->left,1,ans+1);\\n            //going in the right direction again to see if path is possible in the right direction\\n            //ans=1 because we already started our path\\n            solve(root->right,0,1);\\n        }\\n        else{\\n            //going in the right direction\\n            solve(root->right,0,ans+1);\\n            //going in the left direction again to see if path is possible in the left direction\\n            //ans=1 because we already started our path \\n            solve(root->left,1,1);\\n        }\\n    }\\n    int longestZigZag(TreeNode* root) {\\n        //condition to go in left part\\n        solve(root,0,0);\\n        //condition to go in right part\\n        solve(root,1,0);\\n        return max_ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Tree",
                    "Recursion",
                    "Binary Tree"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    int max_ans=0;\\n    void solve(TreeNode* root,int dir,int ans){\\n        // left = 0, right = 1  --> parameter for taking the direction\\n        //base condition\\n        if(!root){return;}\\n\\n        //updating the answer\\n        max_ans = max(max_ans,ans);\\n\\n        if(dir==0){\\n            //going in the left direction\\n            solve(root->left,1,ans+1);\\n            //going in the right direction again to see if path is possible in the right direction\\n            //ans=1 because we already started our path\\n            solve(root->right,0,1);\\n        }\\n        else{\\n            //going in the right direction\\n            solve(root->right,0,ans+1);\\n            //going in the left direction again to see if path is possible in the left direction\\n            //ans=1 because we already started our path \\n            solve(root->left,1,1);\\n        }\\n    }\\n    int longestZigZag(TreeNode* root) {\\n        //condition to go in left part\\n        solve(root,0,0);\\n        //condition to go in right part\\n        solve(root,1,0);\\n        return max_ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3434260,
                "title": "java-full-explaination-comments-lbeginner-friendly",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nWe just need to keep track of previous move we took \\ni.e we took left or we took right.\\nSimultaneously we need to check the following condition and move forward :-\\nIf we took left then next step we need to take is right and If we took right then next step we need to take is left\\n**Note :-** \\nIf we took left and we dont have next step right then from left will calculate new max zig zag steps we can go and vice versa we need to check for right too. \\n\\n# Complexity\\n- Time complexity: O(N), where N is the number of nodes in the tree.\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(H), where H is the height of the tree.\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    int maxStep = 0;//to keep track of max no. of steps\\n    public int longestZigZag(TreeNode root) {\\n        if(root.left != null){\\n            helper(root.left,1,false,true);\\n        }\\n        if(root.right != null){\\n            helper(root.right,1,true,false);\\n        }\\n        return maxStep;\\n    }\\n    public void helper(TreeNode node,int step,boolean canGoLeft,boolean canGoRight){\\n        maxStep = Math.max(step,maxStep);//calculate the max at that step\\n        //it means previous step we took was right\\n        if(canGoLeft){\\n            if(node.left != null){\\n                helper(node.left,step+1,false,true);\\n            }\\n            //calculating new zigzag from here onwards\\n            if(node.right != null){\\n                helper(node.right,1,true,false);\\n            }\\n        }\\n        //it means previous step we took was left\\n        if(canGoRight){\\n            if(node.right != null){\\n                helper(node.right,step+1,true,false);\\n            }\\n            //calculating new zigzag from here onwards\\n            if(node.left != null){\\n                helper(node.left,1,false,true);\\n            }\\n        }\\n    }\\n}\\n```\\n**Please UpVote If you like it Happy Coding :)\\nIf you really found my solution helpful please upvote it, as it motivates me to post such kind of codes and help the coding community, if you have some queries or some improvements please feel free to comment and share your views.**",
                "solutionTags": [
                    "Java",
                    "Tree",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\n    int maxStep = 0;//to keep track of max no. of steps\\n    public int longestZigZag(TreeNode root) {\\n        if(root.left != null){\\n            helper(root.left,1,false,true);\\n        }\\n        if(root.right != null){\\n            helper(root.right,1,true,false);\\n        }\\n        return maxStep;\\n    }\\n    public void helper(TreeNode node,int step,boolean canGoLeft,boolean canGoRight){\\n        maxStep = Math.max(step,maxStep);//calculate the max at that step\\n        //it means previous step we took was right\\n        if(canGoLeft){\\n            if(node.left != null){\\n                helper(node.left,step+1,false,true);\\n            }\\n            //calculating new zigzag from here onwards\\n            if(node.right != null){\\n                helper(node.right,1,true,false);\\n            }\\n        }\\n        //it means previous step we took was left\\n        if(canGoRight){\\n            if(node.right != null){\\n                helper(node.right,step+1,true,false);\\n            }\\n            //calculating new zigzag from here onwards\\n            if(node.left != null){\\n                helper(node.left,1,false,true);\\n            }\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3433432,
                "title": "java-dfs-beats-99-8-lines-clean-simple",
                "content": "# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n)$$ on the stack\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n  int max = 0;\\n\\n  private int longestZigZag(TreeNode node, boolean isRight) {\\n    if (node == null) return 0;\\n\\n    var l = longestZigZag(node.left, true);\\n    var r = longestZigZag(node.right, false);\\n\\n    max = Math.max(max, 1 + (isRight ? l : r));\\n\\n    return 1 + (isRight ? r : l);\\n  }\\n\\n  public int longestZigZag(TreeNode root) {\\n    return Math.max(longestZigZag(root, true), max) - 1;\\n  }\\n}\\n```\\nIf you like my solution, please upvote it!",
                "solutionTags": [
                    "Java",
                    "Depth-First Search",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\n  int max = 0;\\n\\n  private int longestZigZag(TreeNode node, boolean isRight) {\\n    if (node == null) return 0;\\n\\n    var l = longestZigZag(node.left, true);\\n    var r = longestZigZag(node.right, false);\\n\\n    max = Math.max(max, 1 + (isRight ? l : r));\\n\\n    return 1 + (isRight ? r : l);\\n  }\\n\\n  public int longestZigZag(TreeNode root) {\\n    return Math.max(longestZigZag(root, true), max) - 1;\\n  }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3433045,
                "title": "a-simple-js-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * function TreeNode(val, left, right) {\\n *     this.val = (val===undefined ? 0 : val)\\n *     this.left = (left===undefined ? null : left)\\n *     this.right = (right===undefined ? null : right)\\n * }\\n */\\n/**\\n * @param {TreeNode} root\\n * @return {number}\\n */\\nvar longestZigZag = function(root) {\\n    let max = 0;\\n    \\n    const helper = (node, prev, length) => {\\n    \\n        if(node === null)\\n            return null;\\n        \\n        max = Math.max(max, length);\\n        \\n        helper(node.left, \"l\" , prev === \"r\" ? length + 1 : 1);\\n        helper(node.right, \"r\" , prev === \"l\" ? length + 1 : 1);\\n    }\\n    \\n    \\n    helper(root, \"l\", 0); \\n    helper(root, \"r\", 0);\\n    \\n    return max;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * function TreeNode(val, left, right) {\\n *     this.val = (val===undefined ? 0 : val)\\n *     this.left = (left===undefined ? null : left)\\n *     this.right = (right===undefined ? null : right)\\n * }\\n */\\n/**\\n * @param {TreeNode} root\\n * @return {number}\\n */\\nvar longestZigZag = function(root) {\\n    let max = 0;\\n    \\n    const helper = (node, prev, length) => {\\n    \\n        if(node === null)\\n            return null;\\n        \\n        max = Math.max(max, length);\\n        \\n        helper(node.left, \"l\" , prev === \"r\" ? length + 1 : 1);\\n        helper(node.right, \"r\" , prev === \"l\" ? length + 1 : 1);\\n    }\\n    \\n    \\n    helper(root, \"l\", 0); \\n    helper(root, \"r\", 0);\\n    \\n    return max;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1244271,
                "title": "c-simple-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int ans = 0;\\n    \\n    vector<int>postorder(TreeNode* root){\\n        \\n        if(root == NULL)\\n            return {-1, -1};\\n        \\n        int left = postorder(root->left)[1] + 1;\\n        int right = postorder(root->right)[0] + 1;\\n        \\n        ans = max({ans, left, right});\\n        return {left, right};\\n    }\\n    \\n    int longestZigZag(TreeNode* root) {\\n        \\n        postorder(root);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int ans = 0;\\n    \\n    vector<int>postorder(TreeNode* root){\\n        \\n        if(root == NULL)\\n            return {-1, -1};\\n        \\n        int left = postorder(root->left)[1] + 1;\\n        int right = postorder(root->right)[0] + 1;\\n        \\n        ans = max({ans, left, right});\\n        return {left, right};\\n    }\\n    \\n    int longestZigZag(TreeNode* root) {\\n        \\n        postorder(root);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1231674,
                "title": "c-solution-memoization-simple-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    \\n    //0->left,1->right,2->initial node ,both ways possible\\n    \\n    map< pair<TreeNode*,int>,int>mp; \\n    int recurs(TreeNode* root,int direction)\\n    {\\n        if(root==NULL)\\n        {\\n            return 0;\\n        }\\n        \\n        if(mp[{root,direction}]!=0)\\n        {\\n                return mp[{root,direction}];\\n        }\\n        \\n        if(direction==0)\\n        {\\n            return mp[{root,direction}]= recurs(root->right,1)+1;\\n        }\\n        else if(direction==1)\\n        {\\n             return mp[{root,direction}]=recurs(root->left,0)+1;\\n        }\\n        else\\n        {\\n            return mp[{root,direction}]=max(recurs(root->right,1)+1,recurs(root->left,0)+1);\\n        }\\n    }\\n    \\n    \\n    int ans=0;\\n    void pre(TreeNode* root)\\n    {\\n        if(root==NULL)\\n        {\\n            return ;\\n        }\\n        \\n        ans=max(recurs(root,2),ans);\\n        pre(root->left);\\n        pre(root->right);\\n    }\\n\\n    \\n    \\n    int longestZigZag(TreeNode* root) {\\n        pre(root);\\n        return ans-1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    //0->left,1->right,2->initial node ,both ways possible\\n    \\n    map< pair<TreeNode*,int>,int>mp; \\n    int recurs(TreeNode* root,int direction)\\n    {\\n        if(root==NULL)\\n        {\\n            return 0;\\n        }\\n        \\n        if(mp[{root,direction}]!=0)\\n        {\\n                return mp[{root,direction}];\\n        }\\n        \\n        if(direction==0)\\n        {\\n            return mp[{root,direction}]= recurs(root->right,1)+1;\\n        }\\n        else if(direction==1)\\n        {\\n             return mp[{root,direction}]=recurs(root->left,0)+1;\\n        }\\n        else\\n        {\\n            return mp[{root,direction}]=max(recurs(root->right,1)+1,recurs(root->left,0)+1);\\n        }\\n    }\\n    \\n    \\n    int ans=0;\\n    void pre(TreeNode* root)\\n    {\\n        if(root==NULL)\\n        {\\n            return ;\\n        }\\n        \\n        ans=max(recurs(root,2),ans);\\n        pre(root->left);\\n        pre(root->right);\\n    }\\n\\n    \\n    \\n    int longestZigZag(TreeNode* root) {\\n        pre(root);\\n        return ans-1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 532242,
                "title": "python-dfs-explanation",
                "content": "* Use \"check\" as a checker that come from which side (left or right)\\n* if come from root, check = 0\\n* elif come from left node, check = 1\\n* elif come from right node, check = 2 \\n* \"count\" is a number of continuous zigzag nodes\\n* \"self.res\" is keep the maximum of \"count\" \\n\\n\\'\\'\\'\\n\\n\\n\\tdef longestZigZag(self, root):\\n\\t\\t\\tcheck = 0 # left = 1, right = 2\\n\\t\\t\\tcount = 0\\n\\t\\t\\tself.res = 0\\n\\n\\t\\t\\tdef dfs(node, count, check):\\n\\t\\t\\t\\tif node:\\n\\t\\t\\t\\t\\tif check == 1: # from left                    \\n\\t\\t\\t\\t\\t\\tdfs(node.left, 0, 1)\\n\\t\\t\\t\\t\\t\\tdfs(node.right, count+1, 2)\\n\\t\\t\\t\\t\\telif check == 2: # from right\\n\\t\\t\\t\\t\\t\\tdfs(node.left, count+1, 1)\\n\\t\\t\\t\\t\\t\\tdfs(node.right, 0, 2)\\n\\t\\t\\t\\t\\telif check == 0: # from root\\n\\t\\t\\t\\t\\t\\tdfs(node.left, count, 1)\\n\\t\\t\\t\\t\\t\\tdfs(node.right, count, 2)\\n\\t\\t\\t\\tself.res = max(self.res, count)\\n\\t\\t\\tdfs(root, count, check)\\n\\t\\t\\treturn self.res\\n\\'\\'\\'",
                "solutionTags": [
                    "Python",
                    "Depth-First Search"
                ],
                "code": "* Use \"check\" as a checker that come from which side (left or right)\\n* if come from root, check = 0\\n* elif come from left node, check = 1\\n* elif come from right node, check = 2 \\n* \"count\" is a number of continuous zigzag nodes\\n* \"self.res\" is keep the maximum of \"count\" \\n\\n\\'\\'\\'\\n\\n\\n\\tdef longestZigZag(self, root):\\n\\t\\t\\tcheck = 0 # left = 1, right = 2\\n\\t\\t\\tcount = 0\\n\\t\\t\\tself.res = 0\\n\\n\\t\\t\\tdef dfs(node, count, check):\\n\\t\\t\\t\\tif node:\\n\\t\\t\\t\\t\\tif check == 1: # from left                    \\n\\t\\t\\t\\t\\t\\tdfs(node.left, 0, 1)\\n\\t\\t\\t\\t\\t\\tdfs(node.right, count+1, 2)\\n\\t\\t\\t\\t\\telif check == 2: # from right\\n\\t\\t\\t\\t\\t\\tdfs(node.left, count+1, 1)\\n\\t\\t\\t\\t\\t\\tdfs(node.right, 0, 2)\\n\\t\\t\\t\\t\\telif check == 0: # from root\\n\\t\\t\\t\\t\\t\\tdfs(node.left, count, 1)\\n\\t\\t\\t\\t\\t\\tdfs(node.right, count, 2)\\n\\t\\t\\t\\tself.res = max(self.res, count)\\n\\t\\t\\tdfs(root, count, check)\\n\\t\\t\\treturn self.res\\n\\'\\'\\'",
                "codeTag": "Python3"
            },
            {
                "id": 531819,
                "title": "c-top-down-recusrion",
                "content": "```\\n#define LEFT 0\\n#define RIGHT 1\\nclass Solution {\\npublic:\\n    int max1 = 0;\\n    void maxZigZag(TreeNode* root, int dir, int curr)\\n    {\\n        if(!root) return;\\n        \\n        //cout<<root->val<<endl;\\n        max1=max(max1,curr);\\n        if(dir==LEFT)\\n        {\\n            if(root->left)\\n            {\\n                maxZigZag(root->left, RIGHT, curr+1);\\n            }\\n            if(root->right){\\n                maxZigZag(root->right, LEFT, 1);\\n            }\\n        }\\n        else\\n        {\\n            if(root->right)\\n            {\\n                maxZigZag(root->right, LEFT, curr+1);\\n            }\\n            if(root->left)\\n            {\\n                maxZigZag(root->left, RIGHT, 1);\\n            }\\n        }\\n    }\\n    int longestZigZag(TreeNode* root) {\\n        maxZigZag(root,LEFT,0);\\n        return max1;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n#define LEFT 0\\n#define RIGHT 1\\nclass Solution {\\npublic:\\n    int max1 = 0;\\n    void maxZigZag(TreeNode* root, int dir, int curr)\\n    {\\n        if(!root) return;\\n        \\n        //cout<<root->val<<endl;\\n        max1=max(max1,curr);\\n        if(dir==LEFT)\\n        {\\n            if(root->left)\\n            {\\n                maxZigZag(root->left, RIGHT, curr+1);\\n            }\\n            if(root->right){\\n                maxZigZag(root->right, LEFT, 1);\\n            }\\n        }\\n        else\\n        {\\n            if(root->right)\\n            {\\n                maxZigZag(root->right, LEFT, curr+1);\\n            }\\n            if(root->left)\\n            {\\n                maxZigZag(root->left, RIGHT, 1);\\n            }\\n        }\\n    }\\n    int longestZigZag(TreeNode* root) {\\n        maxZigZag(root,LEFT,0);\\n        return max1;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3435726,
                "title": "c-solution-easy-approach-recursive-code",
                "content": "# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    int count(TreeNode* root,int check,int ans){\\n        if(!root)\\n          return ans;\\n        if(check==0)   //for left child\\n        {\\n            int a=0;\\n            a=count(root->left,1,ans+1);    //zigzag start from any previous node\\n            a=max(a,count(root->right,0,0)); //new zigzag from current node\\n            return a;   //maxi. length of zigzag upto current node\\n        }\\n        if(check==1)   //for right child\\n        {\\n            int b=0;\\n            b=count(root->right,0,ans+1);    //zigzag start from any previous node\\n            b=max(b,count(root->left,1,0));  //new zigzag from current node\\n            return b;   //maxi. length of zigzag upto current node\\n        }\\n        return max(count(root->left,1,0),count(root->right,0,0)); //for root( left child and right child)\\n    }\\n    int longestZigZag(TreeNode* root) {\\n       if(!root)\\n         return 0;\\n        int ans=count(root,-1,0);\\n        return ans;\\n    }\\n};\\n```\\n#Please UPVOTE if it helps \\u2764\\uFE0F\\uD83D\\uDE0A\\nThank You and Happy To Help You!!",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    int count(TreeNode* root,int check,int ans){\\n        if(!root)\\n          return ans;\\n        if(check==0)   //for left child\\n        {\\n            int a=0;\\n            a=count(root->left,1,ans+1);    //zigzag start from any previous node\\n            a=max(a,count(root->right,0,0)); //new zigzag from current node\\n            return a;   //maxi. length of zigzag upto current node\\n        }\\n        if(check==1)   //for right child\\n        {\\n            int b=0;\\n            b=count(root->right,0,ans+1);    //zigzag start from any previous node\\n            b=max(b,count(root->left,1,0));  //new zigzag from current node\\n            return b;   //maxi. length of zigzag upto current node\\n        }\\n        return max(count(root->left,1,0),count(root->right,0,0)); //for root( left child and right child)\\n    }\\n    int longestZigZag(TreeNode* root) {\\n       if(!root)\\n         return 0;\\n        int ans=count(root,-1,0);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3435693,
                "title": "accepted-swift-solution-using-dfs",
                "content": "\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     public var val: Int\\n *     public var left: TreeNode?\\n *     public var right: TreeNode?\\n *     public init() { self.val = 0; self.left = nil; self.right = nil; }\\n *     public init(_ val: Int) { self.val = val; self.left = nil; self.right = nil; }\\n *     public init(_ val: Int, _ left: TreeNode?, _ right: TreeNode?) {\\n *         self.val = val\\n *         self.left = left\\n *         self.right = right\\n *     }\\n * }\\n */\\nclass Solution {\\n    var maxSteps = 0\\n    func longestZigZag(_ root: TreeNode?) -> Int {\\n        dfs(root?.right, true, 1)\\n        dfs(root?.left, false, 1)\\n        return maxSteps\\n    }\\n\\n    func dfs(_ node: TreeNode?, _ isLeft: Bool, _ steps: Int) {\\n        if node == nil {\\n            return\\n        }\\n        maxSteps = max(maxSteps, steps)\\n        if isLeft {\\n            dfs(node?.left, false, steps+1)\\n            dfs(node?.right, true, 1)\\n        } else {\\n            dfs(node?.right, true, steps+1)\\n            dfs(node?.left, false, 1)\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     public var val: Int\\n *     public var left: TreeNode?\\n *     public var right: TreeNode?\\n *     public init() { self.val = 0; self.left = nil; self.right = nil; }\\n *     public init(_ val: Int) { self.val = val; self.left = nil; self.right = nil; }\\n *     public init(_ val: Int, _ left: TreeNode?, _ right: TreeNode?) {\\n *         self.val = val\\n *         self.left = left\\n *         self.right = right\\n *     }\\n * }\\n */\\nclass Solution {\\n    var maxSteps = 0\\n    func longestZigZag(_ root: TreeNode?) -> Int {\\n        dfs(root?.right, true, 1)\\n        dfs(root?.left, false, 1)\\n        return maxSteps\\n    }\\n\\n    func dfs(_ node: TreeNode?, _ isLeft: Bool, _ steps: Int) {\\n        if node == nil {\\n            return\\n        }\\n        maxSteps = max(maxSteps, steps)\\n        if isLeft {\\n            dfs(node?.left, false, steps+1)\\n            dfs(node?.right, true, 1)\\n        } else {\\n            dfs(node?.right, true, steps+1)\\n            dfs(node?.left, false, 1)\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3435555,
                "title": "c-easy-code-self-explanatory",
                "content": "```\\nclass Solution {\\npublic:\\n    int maxC = 0;\\n    void count(TreeNode *node, int dir, int curr)\\n    {\\n        if(node == NULL)\\n            return;\\n        maxC = max(maxC, curr);\\n\\n        if(dir == 1){\\n           count(node -> left, 0, curr + 1);\\n            count(node -> right, 1, 1);\\n        }\\n        else\\n        {\\n            count(node -> right, 1, curr + 1);\\n            count(node -> left, 0, 1);\\n        }\\n    }\\n    int longestZigZag(TreeNode* root) {\\n\\t    // 1 for left, 0 for right\\n        count(root, 1, 0);\\n        count(root, 0, 0);\\n        return maxC;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxC = 0;\\n    void count(TreeNode *node, int dir, int curr)\\n    {\\n        if(node == NULL)\\n            return;\\n        maxC = max(maxC, curr);\\n\\n        if(dir == 1){\\n           count(node -> left, 0, curr + 1);\\n            count(node -> right, 1, 1);\\n        }\\n        else\\n        {\\n            count(node -> right, 1, curr + 1);\\n            count(node -> left, 0, 1);\\n        }\\n    }\\n    int longestZigZag(TreeNode* root) {\\n\\t    // 1 for left, 0 for right\\n        count(root, 1, 0);\\n        count(root, 0, 0);\\n        return maxC;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3435338,
                "title": "solution-in-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int res = 0;\\n    void solve(TreeNode* node, bool goLeft, int currPathLen) \\n    {\\n        if (!node) return;\\n        res = max(res, currPathLen);\\n        if (goLeft) \\n        {\\n            solve(node->left, false, currPathLen + 1);\\n            solve(node->right, true, 1);\\n        }\\n         else \\n         {\\n            solve(node->right, true, currPathLen + 1);\\n            solve(node->left, false, 1);\\n        }\\n    }\\n    int longestZigZag(TreeNode* root)\\n     {\\n        solve(root, true, 0);\\n        solve(root, false, 0);\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int res = 0;\\n    void solve(TreeNode* node, bool goLeft, int currPathLen) \\n    {\\n        if (!node) return;\\n        res = max(res, currPathLen);\\n        if (goLeft) \\n        {\\n            solve(node->left, false, currPathLen + 1);\\n            solve(node->right, true, 1);\\n        }\\n         else \\n         {\\n            solve(node->right, true, currPathLen + 1);\\n            solve(node->left, false, 1);\\n        }\\n    }\\n    int longestZigZag(TreeNode* root)\\n     {\\n        solve(root, true, 0);\\n        solve(root, false, 0);\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3434952,
                "title": "time-space-98-beats-c-easy-to-understand-dfs",
                "content": "````\\nclass Solution {\\npublic:\\n    void solve(TreeNode* root,int &ans,int s,int d){\\n        if(root == NULL){\\n            return;\\n        }\\n        ans = max(ans,d);\\n        if(s==1){\\n            solve(root->left,ans,0,d+1);\\n            solve(root->right,ans,1,1);\\n        }else{\\n            solve(root->right,ans,1,d+1);\\n            solve(root->left,ans,0,1);\\n        }\\n    }\\n    int longestZigZag(TreeNode* root) {\\n        int ans = 0;\\n        solve(root->left,ans,0,1);\\n        solve(root->right,ans,1,1);\\n        return ans;\\n    }\\n};\\n````",
                "solutionTags": [
                    "C++",
                    "C",
                    "Tree",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "````\\nclass Solution {\\npublic:\\n    void solve(TreeNode* root,int &ans,int s,int d){\\n        if(root == NULL){\\n            return;\\n        }\\n        ans = max(ans,d);\\n        if(s==1){\\n            solve(root->left,ans,0,d+1);\\n            solve(root->right,ans,1,1);\\n        }else{\\n            solve(root->right,ans,1,d+1);\\n            solve(root->left,ans,0,1);\\n        }\\n    }\\n    int longestZigZag(TreeNode* root) {\\n        int ans = 0;\\n        solve(root->left,ans,0,1);\\n        solve(root->right,ans,1,1);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3434378,
                "title": "java-python-kotlin-golang-intuitive-dfs-recursive-solution",
                "content": "# Intuition\\nAt first , it looks like a DFS to calculate the height of a BST.\\nThen the zigzag forces to alternate direction (right or left). If previous node explored was `left`, then the next node must be `right` ( vice-versa). We have to keep track if the current node should explore left or right.\\n\\n# Approach\\n\\nWe have to keep track if the current node should explore left or right.\\nIn addition not to have a global variable, the level is passed in parameter to the recursive function.\\n\\n```Java []\\nclass Solution {\\n    public int longestZigZag(TreeNode root) {\\n        return Math.max(longestZigZag(root, true, 0), longestZigZag(root, false, 0));\\n    }\\n\\n    public int longestZigZag(TreeNode root, boolean isLeft, int level) {\\n        //System.out.println(\"isLeft = \" + isLeft + \" root = \" + root + \" level = \"+ level);\\n        if(root == null) return level;\\n        \\n        if(isLeft){\\n            if(root.left == null) return level;\\n            return longestZigZag(root.left, false, level + 1);\\n        }else{\\n            if(root.right == null) return level;\\n            return longestZigZag(root.right, true, level + 1);\\n        }\\n\\n    }\\n}\\n```\\n\\nAt first, my initial implementation worked on all except the first example. I assumed the longest always starts from the root node.\\n\\n\\n![leetcode_sample_1_1702.png](https://assets.leetcode.com/users/images/9ab48f18-91f7-4817-b872-cd4845763cf7_1681897926.6954088.png)\\n\\nBut example 1, the longest zig zag doesn\\'t start at the root node. But at the first right child of the root node.\\n`If direction stays the same twice, we have to reset the level to zero`. Otherwise increment the level by one.\\n\\n## Illustration from a left Node\\n```\\n    // TDLR\\n    return Math.max(longestZigZag(root.left, false, level + 1), longestZigZag(root.left, true, 0));\\n\\n    // more detail on this one line.\\n    /**\\n    *\\n    *      x\\n    *     /\\n    *    x\\n    *   /\\n    *  x\\n    *\\n    **/\\n    int leftOfLeft = longestZigZag(root.left, true, 0); // reset level to 0\\n\\n    /**\\n    *\\n    *      x\\n    *     /\\n    *    x\\n    *     \\\\\\n    *      x\\n    *\\n    **/\\n    int rightOfLeft = longestZigZag(root.left, false, level + 1); // keep the zig zag, so increment the level\\n\\n```\\n\\n# Complexity\\n\\n- Time complexity:\\nO(n) , we explore all tree nodes\\n\\n- Space complexity:\\nO(height)\\n\\n# Code\\n\\n```Java []\\nclass Solution {\\n    public int longestZigZag(TreeNode root) {\\n        return Math.max(longestZigZag(root, true, 0), longestZigZag(root, false, 0));\\n    }\\n\\n    public int longestZigZag(TreeNode root, boolean isLeft, int level) {\\n        if(root == null) return level;\\n        \\n        if(isLeft){\\n            if(root.left == null) return level;\\n            // the BST doesn\\'t have to start from the root node. If the same direction is done twice, reset the level to 0\\n            return Math.max(longestZigZag(root.left, false, level + 1), longestZigZag(root.left, true, 0));\\n        }else{\\n            if(root.right == null) return level;\\n            return Math.max(longestZigZag(root.right, true, level + 1), longestZigZag(root.right, false, 0));\\n        }\\n\\n    }\\n}\\n```\\n```python []\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def longestZigZag(self, root: Optional[TreeNode]) -> int:\\n        def longestZigZag(root: Optional[TreeNode], isLeft: bool, level: int) -> int:\\n            if root is None:\\n                return level\\n            \\n            if isLeft:\\n                if root.left is None: return level\\n                return max(longestZigZag(root.left, False, level + 1), longestZigZag(root.left, True, 0))\\n            else:\\n                if root.right is None: return level\\n                return max(longestZigZag(root.right, True, level + 1), longestZigZag(root.right, False, 0))\\n        \\n        return max(longestZigZag(root, True, 0), longestZigZag(root, False, 0))\\n```\\n```kotlin []\\n/**\\n * Example:\\n * var ti = TreeNode(5)\\n * var v = ti.`val`\\n * Definition for a binary tree node.\\n * class TreeNode(var `val`: Int) {\\n *     var left: TreeNode? = null\\n *     var right: TreeNode? = null\\n * }\\n */\\nclass Solution {\\n    fun longestZigZag(root: TreeNode?): Int {\\n        return maxOf(longestZigZag(root, true, 0),  longestZigZag(root, false, 0))\\n    }\\n\\n    fun longestZigZag(root: TreeNode?, isLeft: Boolean, level: Int): Int {\\n        if(root == null) return level\\n\\n        if(isLeft){\\n            return root?.left?.let{\\n                 maxOf(longestZigZag(it, false, level + 1), longestZigZag(it,  true, 0))\\n            } ?: level\\n        }else{\\n            return root?.right?.let{\\n                 maxOf(longestZigZag(it, true, level + 1), longestZigZag(it, false, 0))\\n            } ?: level\\n        }\\n    }\\n}\\n\\n```\\n```golang []\\n/**\\n * Definition for a binary tree node.\\n * type TreeNode struct {\\n *     Val int\\n *     Left *TreeNode\\n *     Right *TreeNode\\n * }\\n */\\nfunc longestZigZag(root *TreeNode) int {\\n\\treturn max(longestZigZagRec(root, true, 0), longestZigZagRec(root, false, 0))\\n}\\n\\nfunc longestZigZagRec(root *TreeNode, isLeft bool, level int) int {\\n\\tif root == nil {\\n\\t\\treturn level\\n\\t}\\n\\n\\tif isLeft {\\n\\t\\tleft := root.Left\\n\\t\\tif left == nil { return  level}\\n\\t\\treturn max(longestZigZagRec(left, false, level +1 ), longestZigZagRec(left, true, 0))\\n\\t}else{\\n\\t\\tright := root.Right\\n\\t\\tif right == nil {return  level}\\n\\t\\treturn max(longestZigZagRec(right, true, level+1), longestZigZagRec(right, false, 0))\\n\\t}\\n}\\n\\nfunc max(a, b int) int {\\n\\tif a > b {\\n\\t\\treturn a\\n\\t}\\n\\treturn b\\n}\\n```\\n\\nThanks for reading until the end.\\nIf some code is not fluent in their native programming language, please suggest in the comment section.\\n",
                "solutionTags": [
                    "Java",
                    "Python3",
                    "Go",
                    "Kotlin",
                    "Recursion"
                ],
                "code": "```Java []\\nclass Solution {\\n    public int longestZigZag(TreeNode root) {\\n        return Math.max(longestZigZag(root, true, 0), longestZigZag(root, false, 0));\\n    }\\n\\n    public int longestZigZag(TreeNode root, boolean isLeft, int level) {\\n        //System.out.println(\"isLeft = \" + isLeft + \" root = \" + root + \" level = \"+ level);\\n        if(root == null) return level;\\n        \\n        if(isLeft){\\n            if(root.left == null) return level;\\n            return longestZigZag(root.left, false, level + 1);\\n        }else{\\n            if(root.right == null) return level;\\n            return longestZigZag(root.right, true, level + 1);\\n        }\\n\\n    }\\n}\\n```\n```\\n    // TDLR\\n    return Math.max(longestZigZag(root.left, false, level + 1), longestZigZag(root.left, true, 0));\\n\\n    // more detail on this one line.\\n    /**\\n    *\\n    *      x\\n    *     /\\n    *    x\\n    *   /\\n    *  x\\n    *\\n    **/\\n    int leftOfLeft = longestZigZag(root.left, true, 0); // reset level to 0\\n\\n    /**\\n    *\\n    *      x\\n    *     /\\n    *    x\\n    *     \\\\\\n    *      x\\n    *\\n    **/\\n    int rightOfLeft = longestZigZag(root.left, false, level + 1); // keep the zig zag, so increment the level\\n\\n```\n```Java []\\nclass Solution {\\n    public int longestZigZag(TreeNode root) {\\n        return Math.max(longestZigZag(root, true, 0), longestZigZag(root, false, 0));\\n    }\\n\\n    public int longestZigZag(TreeNode root, boolean isLeft, int level) {\\n        if(root == null) return level;\\n        \\n        if(isLeft){\\n            if(root.left == null) return level;\\n            // the BST doesn\\'t have to start from the root node. If the same direction is done twice, reset the level to 0\\n            return Math.max(longestZigZag(root.left, false, level + 1), longestZigZag(root.left, true, 0));\\n        }else{\\n            if(root.right == null) return level;\\n            return Math.max(longestZigZag(root.right, true, level + 1), longestZigZag(root.right, false, 0));\\n        }\\n\\n    }\\n}\\n```\n```python []\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def longestZigZag(self, root: Optional[TreeNode]) -> int:\\n        def longestZigZag(root: Optional[TreeNode], isLeft: bool, level: int) -> int:\\n            if root is None:\\n                return level\\n            \\n            if isLeft:\\n                if root.left is None: return level\\n                return max(longestZigZag(root.left, False, level + 1), longestZigZag(root.left, True, 0))\\n            else:\\n                if root.right is None: return level\\n                return max(longestZigZag(root.right, True, level + 1), longestZigZag(root.right, False, 0))\\n        \\n        return max(longestZigZag(root, True, 0), longestZigZag(root, False, 0))\\n```\n```kotlin []\\n/**\\n * Example:\\n * var ti = TreeNode(5)\\n * var v = ti.`val`\\n * Definition for a binary tree node.\\n * class TreeNode(var `val`: Int) {\\n *     var left: TreeNode? = null\\n *     var right: TreeNode? = null\\n * }\\n */\\nclass Solution {\\n    fun longestZigZag(root: TreeNode?): Int {\\n        return maxOf(longestZigZag(root, true, 0),  longestZigZag(root, false, 0))\\n    }\\n\\n    fun longestZigZag(root: TreeNode?, isLeft: Boolean, level: Int): Int {\\n        if(root == null) return level\\n\\n        if(isLeft){\\n            return root?.left?.let{\\n                 maxOf(longestZigZag(it, false, level + 1), longestZigZag(it,  true, 0))\\n            } ?: level\\n        }else{\\n            return root?.right?.let{\\n                 maxOf(longestZigZag(it, true, level + 1), longestZigZag(it, false, 0))\\n            } ?: level\\n        }\\n    }\\n}\\n\\n```\n```golang []\\n/**\\n * Definition for a binary tree node.\\n * type TreeNode struct {\\n *     Val int\\n *     Left *TreeNode\\n *     Right *TreeNode\\n * }\\n */\\nfunc longestZigZag(root *TreeNode) int {\\n\\treturn max(longestZigZagRec(root, true, 0), longestZigZagRec(root, false, 0))\\n}\\n\\nfunc longestZigZagRec(root *TreeNode, isLeft bool, level int) int {\\n\\tif root == nil {\\n\\t\\treturn level\\n\\t}\\n\\n\\tif isLeft {\\n\\t\\tleft := root.Left\\n\\t\\tif left == nil { return  level}\\n\\t\\treturn max(longestZigZagRec(left, false, level +1 ), longestZigZagRec(left, true, 0))\\n\\t}else{\\n\\t\\tright := root.Right\\n\\t\\tif right == nil {return  level}\\n\\t\\treturn max(longestZigZagRec(right, true, level+1), longestZigZagRec(right, false, 0))\\n\\t}\\n}\\n\\nfunc max(a, b int) int {\\n\\tif a > b {\\n\\t\\treturn a\\n\\t}\\n\\treturn b\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3433966,
                "title": "easy-solution-in-c",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\nWe use 0 for nodes coming from the left and 1 for nodes coming from the right.\\n\\nFirstly, we declare a function that counts the zigzag path. One thing to notice is that if a node comes from the left and then goes left again, the zigzag path will be 1. If a node comes from the left and goes to the right, the zigzag path count will increase by 1 from the previous count and vice versa.\\n\\nThe \"solve\" function takes three parameters: \"root\", which is the treenode, \"dir\" which determines the direction the nodes are coming from, and \"len\" which shows the length of the zigzag path until the current node.\\n\\n\\n\\n# Complexity\\n- Time complexity: O(N), where N represents the total number of nodes in the tree. This is because we traverse each node precisely once.\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int ans=0;\\n\\n    void solve(TreeNode* root, int dir, int len){\\n        if(root==NULL)  \\n            return;\\n        ans = max(ans, len);\\n        if(dir==0){\\n            // node comes from the left and then goes left again, the zigzag path will be 1.\\n            solve(root->left, 0, 1);\\n            // node comes from the left and goes to the right, the zigzag path count will increase by 1 from the previous count.\\n            solve(root->right, 1, len+1);\\n        }else{\\n            // node comes from the right and then goes right again, the zigzag path will be 1.\\n            solve(root->left, 0, len+1);\\n            // node comes from the right and goes to the left, the zigzag path count will increase by 1 from the previous count.\\n            solve(root->right, 1, 1);\\n        }\\n    }\\n\\n    int longestZigZag(TreeNode* root) {\\n        solve(root->left, 0, 1);\\n        solve(root->right, 1, 1);\\n        return ans;\\n    }\\n};\\n```\\n\\n![images.jpg](https://assets.leetcode.com/users/images/ff765eb1-bf72-408a-a59f-828ffa968ac9_1681889626.1299875.jpeg)\\n",
                "solutionTags": [
                    "C++",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int ans=0;\\n\\n    void solve(TreeNode* root, int dir, int len){\\n        if(root==NULL)  \\n            return;\\n        ans = max(ans, len);\\n        if(dir==0){\\n            // node comes from the left and then goes left again, the zigzag path will be 1.\\n            solve(root->left, 0, 1);\\n            // node comes from the left and goes to the right, the zigzag path count will increase by 1 from the previous count.\\n            solve(root->right, 1, len+1);\\n        }else{\\n            // node comes from the right and then goes right again, the zigzag path will be 1.\\n            solve(root->left, 0, len+1);\\n            // node comes from the right and goes to the left, the zigzag path count will increase by 1 from the previous count.\\n            solve(root->right, 1, 1);\\n        }\\n    }\\n\\n    int longestZigZag(TreeNode* root) {\\n        solve(root->left, 0, 1);\\n        solve(root->right, 1, 1);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3433861,
                "title": "super-easy-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public:\\n    int maxLength=0;\\n\\n    void solve(TreeNode* root,int dir,int currLength){\\n        if(!root) return;\\n        maxLength=max(maxLength,currLength);\\n        solve(root->left,0,dir?currLength+1:1);\\n        solve(root->right,1,dir?1:currLength+1);\\n    }\\n\\n    int longestZigZag(TreeNode* root) {\\n        solve(root,0,0);\\n        solve(root,1,0);\\n        return maxLength;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\n    public:\\n    int maxLength=0;\\n\\n    void solve(TreeNode* root,int dir,int currLength){\\n        if(!root) return;\\n        maxLength=max(maxLength,currLength);\\n        solve(root->left,0,dir?currLength+1:1);\\n        solve(root->right,1,dir?1:currLength+1);\\n    }\\n\\n    int longestZigZag(TreeNode* root) {\\n        solve(root,0,0);\\n        solve(root,1,0);\\n        return maxLength;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3433693,
                "title": "post-order-dfs-c",
                "content": "```\\nclass Solution {\\n    pair<int, int> dfs(TreeNode* root, int &ans) {\\n        if(!root) return {0, 0};\\n\\n        auto l = dfs(root -> left, ans);\\n        auto r = dfs(root -> right, ans);\\n\\n        int maxLeft = 1 + l.second;\\n        int maxRight = 1 + r.first;\\n        ans = max(ans, max(maxLeft, maxRight) - 1);\\n\\n        return {maxLeft, maxRight};\\n    }\\npublic:\\n    int longestZigZag(TreeNode* root) {\\n        int ans = 0;\\n        dfs(root, ans);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\n    pair<int, int> dfs(TreeNode* root, int &ans) {\\n        if(!root) return {0, 0};\\n\\n        auto l = dfs(root -> left, ans);\\n        auto r = dfs(root -> right, ans);\\n\\n        int maxLeft = 1 + l.second;\\n        int maxRight = 1 + r.first;\\n        ans = max(ans, max(maxLeft, maxRight) - 1);\\n\\n        return {maxLeft, maxRight};\\n    }\\npublic:\\n    int longestZigZag(TreeNode* root) {\\n        int ans = 0;\\n        dfs(root, ans);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3433476,
                "title": "simple-python-solution-breadth-first-search",
                "content": "```\\nfrom collections import deque\\nclass Solution:\\n    def longestZigZag(self, root: Optional[TreeNode]) -> int:\\n        q= deque()\\n        q.append([root,\\'\\',0])\\n        ans=0\\n        while(q):\\n            u,prev_dir,cnt=q.popleft()\\n            ans= max(ans,cnt)\\n            if(u.left):\\n                if(prev_dir==\\'r\\'):\\n                    q.append([u.left,\\'l\\',cnt+1])\\n                else:\\n                    q.append([u.left,\\'l\\',1])\\n            if(u.right):\\n                if(prev_dir==\\'l\\'):\\n                    q.append([u.right,\\'r\\',cnt+1])\\n                else:\\n                    q.append([u.right,\\'r\\',1])\\n        return ans\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Breadth-First Search"
                ],
                "code": "```\\nfrom collections import deque\\nclass Solution:\\n    def longestZigZag(self, root: Optional[TreeNode]) -> int:\\n        q= deque()\\n        q.append([root,\\'\\',0])\\n        ans=0\\n        while(q):\\n            u,prev_dir,cnt=q.popleft()\\n            ans= max(ans,cnt)\\n            if(u.left):\\n                if(prev_dir==\\'r\\'):\\n                    q.append([u.left,\\'l\\',cnt+1])\\n                else:\\n                    q.append([u.left,\\'l\\',1])\\n            if(u.right):\\n                if(prev_dir==\\'l\\'):\\n                    q.append([u.right,\\'r\\',cnt+1])\\n                else:\\n                    q.append([u.right,\\'r\\',1])\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3433419,
                "title": "beats-100-c-15-lines-using-dfs",
                "content": "# Intuition\\nTo understand the intuition behind the given code, we can think of a zigzag path in a binary tree as a path that alternates between going left and going right. The length of the path is the number of edges traversed in the path. For example, in the tree below, the zigzag path with length 4 is indicated by the bold edges:\\n\\n\\n# Approach\\nThe code uses a depth-first search (DFS) approach to traverse the given binary tree. For each node, it computes three values: the length of the longest zigzag path starting from the node and going left, the length of the longest zigzag path starting from the node and going right, and the maximum length of zigzag path found so far in the tree. The maximum length of zigzag path can be obtained by taking the maximum of the three values computed for the root node.\\n\\nThe DFS function dfs takes a node as input and returns a list of three integers. If the node is None, it returns [-1, -1, -1] to indicate that there is no path. Otherwise, it recursively calls dfs on the left and right subtrees of the node and computes the three values described above using the values returned by the recursive calls.\\n\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int longestZigZag(TreeNode* root) {\\n        vector<int> res = dfs(root);\\n        return res[2];\\n    }\\nprivate:\\n    vector<int> dfs(TreeNode* node) {\\n        if (node == nullptr) return {-1, -1, -1};\\n        vector<int> lsubt = dfs(node->left);\\n        vector<int> rsubt = dfs(node->right);\\n        int llen = lsubt[1] + 1;\\n        int rlen = rsubt[0] + 1;\\n        int maxlen = max({llen, rlen, lsubt[2], rsubt[2]});\\n        return {llen, rlen, maxlen};\\n    }\\n};\\n```\\n\\nPlease Upvote",
                "solutionTags": [
                    "C++",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int longestZigZag(TreeNode* root) {\\n        vector<int> res = dfs(root);\\n        return res[2];\\n    }\\nprivate:\\n    vector<int> dfs(TreeNode* node) {\\n        if (node == nullptr) return {-1, -1, -1};\\n        vector<int> lsubt = dfs(node->left);\\n        vector<int> rsubt = dfs(node->right);\\n        int llen = lsubt[1] + 1;\\n        int rlen = rsubt[0] + 1;\\n        int maxlen = max({llen, rlen, lsubt[2], rsubt[2]});\\n        return {llen, rlen, maxlen};\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3433178,
                "title": "ruby-dfs-solution",
                "content": "# Code\\n```\\ndef dfs(root, left, count)\\n  return unless root\\n  @max = [@max, count].max\\n  dfs(root.left, false, left ? count+1 : 1)\\n  dfs(root.right, true, !left ? count+1 : 1)\\nend\\n\\ndef longest_zig_zag(root)\\n  @max = 0\\n  dfs(root, true, 0)\\n  dfs(root, false, 0)\\n  @max\\nend\\n```",
                "solutionTags": [
                    "Ruby"
                ],
                "code": "```\\ndef dfs(root, left, count)\\n  return unless root\\n  @max = [@max, count].max\\n  dfs(root.left, false, left ? count+1 : 1)\\n  dfs(root.right, true, !left ? count+1 : 1)\\nend\\n\\ndef longest_zig_zag(root)\\n  @max = 0\\n  dfs(root, true, 0)\\n  dfs(root, false, 0)\\n  @max\\nend\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3433050,
                "title": "javascript-4-lines-dfs-time-o-n-100-space-o-n",
                "content": "# Complexity\\n- Time complexity: O(n), beats 100%\\n- Space complexity: O(n), beats 80.4%\\n\\n# Code\\n```\\nconst f = ( r, p, v ) => {\\n    if ( !r ) return v - 1\\n    if ( p ) return Math.max( f( r.left, 0, v+1 ), f( r.right, 1, 1 ) )\\n    else return Math.max( f( r.right, 1, v+1 ), f( r.left, 0, 1 ) )\\n}, longestZigZag = r => Math.max( f( r.left, 0, 1 ), f( r.right, 1, 1 ) )\\n\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Dynamic Programming",
                    "Tree",
                    "Depth-First Search",
                    "Binary Tree"
                ],
                "code": "```\\nconst f = ( r, p, v ) => {\\n    if ( !r ) return v - 1\\n    if ( p ) return Math.max( f( r.left, 0, v+1 ), f( r.right, 1, 1 ) )\\n    else return Math.max( f( r.right, 1, v+1 ), f( r.left, 0, 1 ) )\\n}, longestZigZag = r => Math.max( f( r.left, 0, 1 ), f( r.right, 1, 1 ) )\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2839142,
                "title": "java-simple-solution-using-dfs",
                "content": "```\\nclass Solution {\\n    int ans = 0;\\n    public void helper(TreeNode root, int temp, String dir) {\\n        ans = Math.max(ans, temp);\\n        if(root == null)\\n            return;\\n        \\n        if(dir.equals(\"left\")) {\\n            helper(root.right, temp + 1, \"right\");\\n            helper(root.left, 1, \"left\");\\n        }\\n        if(dir.equals(\"right\")) {\\n            helper(root.right, 1, \"right\");\\n            helper(root.left, temp + 1, \"left\");\\n        }\\n    }\\n    public int longestZigZag(TreeNode root) {\\n        if(root == null | (root.left == null && root.right == null))\\n            return 0;\\n        helper(root.left, 1, \"left\");\\n        helper(root.right, 1, \"right\");\\n        return ans-1;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Depth-First Search",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\n    int ans = 0;\\n    public void helper(TreeNode root, int temp, String dir) {\\n        ans = Math.max(ans, temp);\\n        if(root == null)\\n            return;\\n        \\n        if(dir.equals(\"left\")) {\\n            helper(root.right, temp + 1, \"right\");\\n            helper(root.left, 1, \"left\");\\n        }\\n        if(dir.equals(\"right\")) {\\n            helper(root.right, 1, \"right\");\\n            helper(root.left, temp + 1, \"left\");\\n        }\\n    }\\n    public int longestZigZag(TreeNode root) {\\n        if(root == null | (root.left == null && root.right == null))\\n            return 0;\\n        helper(root.left, 1, \"left\");\\n        helper(root.right, 1, \"right\");\\n        return ans-1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1870342,
                "title": "o-n-java-solution-with-comment-explanation-easy-to-understand",
                "content": "**Logic :** \\nEvery node have two choices : \\n- Follow the parent direction what his parent want\\n- Don\\'t follow the parent given direction and go reverse direction (may be find longest path)\\n\\nThen update the `max ` accordingly `parent_direction_longest_length` and `child_own_direction_longest_length`.\\n\\n```\\nclass Solution {\\n    int max = Integer.MIN_VALUE;\\n\\n    public int longestZigZag(TreeNode root) {\\n        solve(root, false);\\n        solve(root, true);\\n        return max;\\n    }\\n\\n    // Right direction -> dir = true\\n    // Left direction -> dir = false\\n    public int solve(TreeNode node, boolean dir) {\\n        if (node == null) return -1;\\n\\n        // if we go right dir from node\\n        int right = ((node.right == null) ? -1 : solve(node.right, false)) + 1;\\n        \\n        // if we go left dir from node\\n        int left = ((node.left == null) ? -1 : solve(node.left, true)) + 1;\\n\\n        // if child is not serious about parent direction\\n        // He want to go own direction for check longest path (reverse of given parent direction)\\n        int childDirProfit = (dir) ? left : right;\\n        // if coming from right go left and vice versa for parent\\n        int parentDirProfit = (dir) ? right : left; \\n\\n        // update the max\\n        max = Math.max(max, Math.max(childDirProfit, parentDirProfit));\\n        \\n        // return what parent wanted\\n        return parentDirProfit;\\n    }\\n}\\n```\\nIt\\'s a simple DFS Solution so it will take `O(n)` times.\\nn = number of node in Tree.\\n\\n\\n**Don\\'t Forget to upvote if you found it helpful :)**",
                "solutionTags": [
                    "Java",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n    int max = Integer.MIN_VALUE;\\n\\n    public int longestZigZag(TreeNode root) {\\n        solve(root, false);\\n        solve(root, true);\\n        return max;\\n    }\\n\\n    // Right direction -> dir = true\\n    // Left direction -> dir = false\\n    public int solve(TreeNode node, boolean dir) {\\n        if (node == null) return -1;\\n\\n        // if we go right dir from node\\n        int right = ((node.right == null) ? -1 : solve(node.right, false)) + 1;\\n        \\n        // if we go left dir from node\\n        int left = ((node.left == null) ? -1 : solve(node.left, true)) + 1;\\n\\n        // if child is not serious about parent direction\\n        // He want to go own direction for check longest path (reverse of given parent direction)\\n        int childDirProfit = (dir) ? left : right;\\n        // if coming from right go left and vice versa for parent\\n        int parentDirProfit = (dir) ? right : left; \\n\\n        // update the max\\n        max = Math.max(max, Math.max(childDirProfit, parentDirProfit));\\n        \\n        // return what parent wanted\\n        return parentDirProfit;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1457821,
                "title": "c-commented-o-n-postorder-traversal",
                "content": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    // keeps track of no. of nodes in longest zig zag path\\n    int res = 0;\\n    \\n    // post order manner\\n    vector<int> traverse(TreeNode *root){\\n        if(!root) return {0, 0}; // by default NULL node returns path with 0 nodes,\\n        \\n        vector<int> leftDir = traverse(root->left);\\n        vector<int> rightDir = traverse(root->right);\\n        \\n        // currDir[0] - left side and currDir[1] - right side\\n        vector<int> currDir = {0, 0};\\n        \\n        // current\\'s node longest zig zag path in \\'left\\' will be 1 + its left child\\'s \\'right\\' path \\n        currDir[0] = leftDir[1] + 1;\\n        \\n        // current\\'s node longest zig zag path in \\'right\\' will be 1 + its right child\\'s \\'left\\' path\\n        currDir[1] = rightDir[0] + 1;\\n        \\n        // updating the answer\\n        res = max(res, max(currDir[0], currDir[1]));\\n        \\n        return currDir;\\n    }\\n    \\n    int longestZigZag(TreeNode* root) {\\n        // traverse the whole tree\\n        traverse(root);\\n        \\n        return res - 1; // -1 because we have maximum of number of nodes not path\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    // keeps track of no. of nodes in longest zig zag path\\n    int res = 0;\\n    \\n    // post order manner\\n    vector<int> traverse(TreeNode *root){\\n        if(!root) return {0, 0}; // by default NULL node returns path with 0 nodes,\\n        \\n        vector<int> leftDir = traverse(root->left);\\n        vector<int> rightDir = traverse(root->right);\\n        \\n        // currDir[0] - left side and currDir[1] - right side\\n        vector<int> currDir = {0, 0};\\n        \\n        // current\\'s node longest zig zag path in \\'left\\' will be 1 + its left child\\'s \\'right\\' path \\n        currDir[0] = leftDir[1] + 1;\\n        \\n        // current\\'s node longest zig zag path in \\'right\\' will be 1 + its right child\\'s \\'left\\' path\\n        currDir[1] = rightDir[0] + 1;\\n        \\n        // updating the answer\\n        res = max(res, max(currDir[0], currDir[1]));\\n        \\n        return currDir;\\n    }\\n    \\n    int longestZigZag(TreeNode* root) {\\n        // traverse the whole tree\\n        traverse(root);\\n        \\n        return res - 1; // -1 because we have maximum of number of nodes not path\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1414516,
                "title": "recursive-solution-beats-96-72-beginner-friendly-c",
                "content": "We have two options at a particular node.\\nOption 1. we go to same ZigZag path coming from above and add one more edge to previous value.\\nOption 2. we go to different direction than the path coming from above but from here length of path will start from one.\\nThere are two variables one is ans which store overall answer and second is currLength which stores length of path till this node.\\n\\n```\\nclass Solution {\\n    void traverse(TreeNode *root, bool leftToRight, int &ans, int currLength)\\n    {\\n        if (root == NULL)\\n        {\\n            return;\\n        }\\n\\n        ans = max(ans, currLength);\\n\\n        if (leftToRight)\\n        {\\n            traverse(root->right, !leftToRight, ans, currLength + 1);  // option 1\\n            traverse(root->left, leftToRight, ans, 1);                 // option 2\\n        }\\n        else\\n        {\\n            traverse(root->left, !leftToRight, ans, currLength + 1); // option 1\\n            traverse(root->right, leftToRight, ans, 1);              // option 2\\n        }\\n    }\\npublic:\\n    int longestZigZag(TreeNode* root) {\\n        int ans = 0;\\n        traverse(root, true, ans, 0);\\n        return ans;\\n    }\\n};\\n```\\n\\nTime complexity :-\\n\\tLet us assume that there are N nodes in tree and we are visiting each node ones so time complexity for average case and worst case both is O(N).\\n\\t\\nSpace complexity :-\\n\\tAs you might think that we are calling each node ones so N number of function calls(in funciton stack) will be stored but at any point of time function calls stored will be equal to H (Height of Tree).\\nBecause we are traversing one path at a time so average case space complexity will be O(Log(n)). Worst case will be for skewed tree O(N).\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    void traverse(TreeNode *root, bool leftToRight, int &ans, int currLength)\\n    {\\n        if (root == NULL)\\n        {\\n            return;\\n        }\\n\\n        ans = max(ans, currLength);\\n\\n        if (leftToRight)\\n        {\\n            traverse(root->right, !leftToRight, ans, currLength + 1);  // option 1\\n            traverse(root->left, leftToRight, ans, 1);                 // option 2\\n        }\\n        else\\n        {\\n            traverse(root->left, !leftToRight, ans, currLength + 1); // option 1\\n            traverse(root->right, leftToRight, ans, 1);              // option 2\\n        }\\n    }\\npublic:\\n    int longestZigZag(TreeNode* root) {\\n        int ans = 0;\\n        traverse(root, true, ans, 0);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1400458,
                "title": "smallest-and-cleanest-code-ever-dfs-98-95-c",
                "content": "We are defining direction as if its true than go to right else left \\n```\\nclass Solution {\\n    void dfs(TreeNode* root, bool direction, int &ans, int travel){\\n        if(root == NULL){\\n            return;\\n        }\\n        \\n        ans = max(ans, travel);\\n        dfs(direction ? root->right : root->left, !direction, ans, travel + 1);\\n        dfs(direction ? root->left : root->right, direction, ans, 1); //This call is to make their own path\\n    }\\npublic:\\n    int longestZigZag(TreeNode* root) {\\n        int ans = 0;\\n        dfs(root, true, ans, 0);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\n    void dfs(TreeNode* root, bool direction, int &ans, int travel){\\n        if(root == NULL){\\n            return;\\n        }\\n        \\n        ans = max(ans, travel);\\n        dfs(direction ? root->right : root->left, !direction, ans, travel + 1);\\n        dfs(direction ? root->left : root->right, direction, ans, 1); //This call is to make their own path\\n    }\\npublic:\\n    int longestZigZag(TreeNode* root) {\\n        int ans = 0;\\n        dfs(root, true, ans, 0);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1357661,
                "title": "c-solution-using-pair-left-right-and-maintaining-a-max-variable",
                "content": "```\\nclass Solution {\\npublic:\\n    pair<int,int> solve(TreeNode *root, int &max_zig){\\n        if(root==NULL){\\n            return {0,0};\\n        }\\n        \\n        // pair contain left and right info\\n        // pair<left,right>\\n        // lsub pair contain <left,right> info means if root want right info it can take right and respectively \\n        \\n        pair<int,int> lsub = solve(root->left, max_zig);\\n        pair<int,int> rsub = solve(root->right, max_zig);\\n        \\n        // if given root is right part of parent root \\n        // so left part of our given root will contain 1 + right_subtree.right part\\n        int left = 1 + rsub.second;\\n        \\n        //if root is left part of parent root\\n        int right = 1+ lsub.first;\\n        \\n        // max_zig for maintaining maximum zigzag pattern found in entire traversal\\n        max_zig = max(max_zig,max(left,right));\\n        \\n        return {left,right};\\n    }\\n    \\n    int longestZigZag(TreeNode* root) {\\n        if(root==NULL || (root->left==NULL && root->right==NULL)) return 0;\\n        int max_zig = 0;\\n        pair<int,int> res = solve(root,max_zig);\\n        return max_zig-1;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    pair<int,int> solve(TreeNode *root, int &max_zig){\\n        if(root==NULL){\\n            return {0,0};\\n        }\\n        \\n        // pair contain left and right info\\n        // pair<left,right>\\n        // lsub pair contain <left,right> info means if root want right info it can take right and respectively \\n        \\n        pair<int,int> lsub = solve(root->left, max_zig);\\n        pair<int,int> rsub = solve(root->right, max_zig);\\n        \\n        // if given root is right part of parent root \\n        // so left part of our given root will contain 1 + right_subtree.right part\\n        int left = 1 + rsub.second;\\n        \\n        //if root is left part of parent root\\n        int right = 1+ lsub.first;\\n        \\n        // max_zig for maintaining maximum zigzag pattern found in entire traversal\\n        max_zig = max(max_zig,max(left,right));\\n        \\n        return {left,right};\\n    }\\n    \\n    int longestZigZag(TreeNode* root) {\\n        if(root==NULL || (root->left==NULL && root->right==NULL)) return 0;\\n        int max_zig = 0;\\n        pair<int,int> res = solve(root,max_zig);\\n        return max_zig-1;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1246342,
                "title": "c-short-and-concise-solution-with-explanation-memoization",
                "content": "##### Hi!\\n##### I have kept my code as short as possible.\\n##### Please upvote if you like it and feel free to share your opinion.*\\n```\\nclass Solution {\\npublic:\\n\\t// pair to store the length of pattern at current node depending on the direction\\n    map<pair<TreeNode*,bool>,int>mp;\\n\\t\\n    int helper(TreeNode* root,bool isRight,int length){\\n        if(!root)\\n            return length-1; // -1 to remove the extra step taken to reach NULL node\\n\\t\\t\\t\\n        if(mp.find({root,isRight})!=mp.end()) //check memo\\n            return mp[{root,isRight}];\\n\\t\\t\\t\\n\\t\\t\\t/*   now we have two choices\\n\\t\\t\\t*    either continue the pattern or start pattern from the begining  \\n\\t\\t\\t*    or start a new pattern with length 1\\n\\t\\t\\t*    memoize and return max of both*/\\n\\t\\t\\t\\n        if(isRight)\\n            mp[{root,isRight}]= max(helper(root->left,false,length+1),helper(root->right,true,1)); \\n        else\\n            mp[{root,isRight}]= max(helper(root->right,true,length+1),helper(root->left,false,1));\\n        return mp[{root,isRight}];\\n    }\\n\\t\\n    int longestZigZag(TreeNode* root) {\\n        return max(helper(root->right,true,1),helper(root->left,false,1));\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\t// pair to store the length of pattern at current node depending on the direction\\n    map<pair<TreeNode*,bool>,int>mp;\\n\\t\\n    int helper(TreeNode* root,bool isRight,int length){\\n        if(!root)\\n            return length-1; // -1 to remove the extra step taken to reach NULL node\\n\\t\\t\\t\\n        if(mp.find({root,isRight})!=mp.end()) //check memo\\n            return mp[{root,isRight}];\\n\\t\\t\\t\\n\\t\\t\\t/*   now we have two choices\\n\\t\\t\\t*    either continue the pattern or start pattern from the begining  \\n\\t\\t\\t*    or start a new pattern with length 1\\n\\t\\t\\t*    memoize and return max of both*/\\n\\t\\t\\t\\n        if(isRight)\\n            mp[{root,isRight}]= max(helper(root->left,false,length+1),helper(root->right,true,1)); \\n        else\\n            mp[{root,isRight}]= max(helper(root->right,true,length+1),helper(root->left,false,1));\\n        return mp[{root,isRight}];\\n    }\\n\\t\\n    int longestZigZag(TreeNode* root) {\\n        return max(helper(root->right,true,1),helper(root->left,false,1));\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 888591,
                "title": "simple-java-code-with-recursion-no-arrays-used",
                "content": "There are 5 cases, \\n\\n1. The highest zig zag traversak has been reached at the current node. No more zig zag traversals can be performed, either because it is a leaf node or further traversals are all in the same direction\\n2. The highest traversal is found by continuing the current zig zag traversal in the left subtree\\n3. The highest traversal is found by continuing the current zig zag traversal in the right subtree\\n4. The highest traversal exists in left subtree, but is unconnected to the current zig zag traversal\\n5. The highest traversal exists in right subtree, but is unconnected to the current zig zag traversal\\n\\nWhen the the previous traversal is a left move and the next traversal is right move or vice versa, we increment the traversal count. This is because it is part of the same zig zag traversal. \\n\\nIf the previous traversal and next traversal are the same (i.e. left followed by left or right followed by right), then it is the start of a new zig zag traversal and the count is reset to 1. \\n\\nThe unconnected zig zag traversals in the left and right subtrees can be smaller than zig zag traversal of reaching the current node. We must get the max value of the current traversal value with the traversal values of left and right subtree.\\n\\nIf a leaf node is reached, the zig zag count are returned as is, since no more traversal can happen\\n\\n```\\n    public int longestZigZag(TreeNode root) {\\n        if (root == null) return 0;\\n        \\n        return Math.max(root.left != null ? performZigZag(root.left, 1, true) : 0, \\n                        root.right != null ? performZigZag(root.right, 1, false) : 0);\\n        \\n    }\\n    \\n    public int performZigZag(TreeNode node, int count, boolean prevLeft) {           \\n        if (node.left == null && node.right == null) {\\n            return count;\\n        }\\n        \\n        return Math.max(count, Math.max(\\n            node.left != null ? performZigZag(node.left, prevLeft ? 1 : count + 1, true) : 0, \\n            node.right != null ? performZigZag(node.right, prevLeft ? count + 1 : 1, false) : 0));\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    public int longestZigZag(TreeNode root) {\\n        if (root == null) return 0;\\n        \\n        return Math.max(root.left != null ? performZigZag(root.left, 1, true) : 0, \\n                        root.right != null ? performZigZag(root.right, 1, false) : 0);\\n        \\n    }\\n    \\n    public int performZigZag(TreeNode node, int count, boolean prevLeft) {           \\n        if (node.left == null && node.right == null) {\\n            return count;\\n        }\\n        \\n        return Math.max(count, Math.max(\\n            node.left != null ? performZigZag(node.left, prevLeft ? 1 : count + 1, true) : 0, \\n            node.right != null ? performZigZag(node.right, prevLeft ? count + 1 : 1, false) : 0));\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 837271,
                "title": "java-dfs-solution-similar-to-lc-124",
                "content": "This problem can be solved simialr to https://leetcode.com/problems/binary-tree-maximum-path-sum/\\n\\nYou can consider the individial subtree by itself or consider the parent. So, check both possibilities.\\n\\nFurther optimization include, memoization to reduce the recHelper calls.\\n```\\n    int ans = Integer.MIN_VALUE;\\n    private int dfs(TreeNode root, boolean isLeft) {\\n        if (root == null)\\n            return -1;\\n        \\n        int left = dfs(root.left, true) + 1;\\n        int right = dfs(root.right, false) + 1;\\n        \\n        ans = Math.max(ans, Math.max(left, right));\\n        \\n        if (isLeft) {\\n            return right;\\n        } else {\\n            return left;\\n        }\\n    }\\n    \\n    public int longestZigZag(TreeNode root) {\\n        if (root == null)\\n            return 0;\\n        \\n        int left = dfs(root.left, true);\\n        int right = dfs(root.right, false);\\n        ans = Math.max(ans, Math.max(left, right) + 1);\\n        return ans;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    int ans = Integer.MIN_VALUE;\\n    private int dfs(TreeNode root, boolean isLeft) {\\n        if (root == null)\\n            return -1;\\n        \\n        int left = dfs(root.left, true) + 1;\\n        int right = dfs(root.right, false) + 1;\\n        \\n        ans = Math.max(ans, Math.max(left, right));\\n        \\n        if (isLeft) {\\n            return right;\\n        } else {\\n            return left;\\n        }\\n    }\\n    \\n    public int longestZigZag(TreeNode root) {\\n        if (root == null)\\n            return 0;\\n        \\n        int left = dfs(root.left, true);\\n        int right = dfs(root.right, false);\\n        ans = Math.max(ans, Math.max(left, right) + 1);\\n        return ans;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 739536,
                "title": "python-clean-dfs",
                "content": "```\\nclass Solution:\\n    def longestZigZag(self, root):\\n\\n        self.max_length = 0\\n        self.find_path(root, root)\\n        return self.max_length-1\\n    def find_path(self, root, parent):\\n        if root is None:\\n            return 0\\n        left = self.find_path(root.left, root)\\n        right = self.find_path(root.right, root)\\n\\n        self.max_length = max(self.max_length, max(left, right)+1)\\n\\n        if root == parent.left:\\n            return right+1\\n        else:\\n            return left+1\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def longestZigZag(self, root):\\n\\n        self.max_length = 0\\n        self.find_path(root, root)\\n        return self.max_length-1\\n    def find_path(self, root, parent):\\n        if root is None:\\n            return 0\\n        left = self.find_path(root.left, root)\\n        right = self.find_path(root.right, root)\\n\\n        self.max_length = max(self.max_length, max(left, right)+1)\\n\\n        if root == parent.left:\\n            return right+1\\n        else:\\n            return left+1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 722647,
                "title": "c-postorder-traversal-o-n",
                "content": "```\\nclass Solution {\\npublic:\\n    int result=0;\\n    pair<int,int> postorder(TreeNode* root)\\n    {\\n        if(root==NULL) return {0,0};\\n        \\n        pair<int,int>curr;\\n        \\n        pair<int,int>left=postorder(root->left);\\n        pair<int,int>right=postorder(root->right);\\n        \\n        int lefttoright=1+left.second;//ZigZag path length If we take right from left child\\n        int righttoleft=1+right.first;//ZigZag path length If we take left from right child\\n        result=max(result,max(left.second,right.first));//Stores Maximum length zig zag path\\n        curr={lefttoright,righttoleft};\\n        return curr;\\n    }\\n    \\n    \\n    int longestZigZag(TreeNode* root) {\\n      postorder(root);\\n      return result;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    int result=0;\\n    pair<int,int> postorder(TreeNode* root)\\n    {\\n        if(root==NULL) return {0,0}",
                "codeTag": "Java"
            },
            {
                "id": 531859,
                "title": "python-dfs-with-direction-of-parent",
                "content": "The idea is to use DFS with direction where the node came from. If the child node has a same direction, reset the count to 1. Otherwise, keep incremeting the count.\\n\\n``` py\\n\\nclass Solution:\\n    def longestZigZag(self, root: TreeNode) -> int:\\n        def dfs(node, parent, cnt):\\n            if not node:\\n                return\\n\\t\\t\\tself.res = max(self.res, cnt)\\n            dfs(node.left, \\'left\\', (cnt + 1) if parent == \\'right\\' else 1)\\n            dfs(node.right, \\'right\\', (cnt + 1) if parent == \\'left\\' else 1)    \\n\\n        self.res = 0\\n        dfs(root, None, 0)\\n        return self.res\\n\\t\\t\\n```\\t\\t",
                "solutionTags": [],
                "code": "``` py\\n\\nclass Solution:\\n    def longestZigZag(self, root: TreeNode) -> int:\\n        def dfs(node, parent, cnt):\\n            if not node:\\n                return\\n\\t\\t\\tself.res = max(self.res, cnt)\\n            dfs(node.left, \\'left\\', (cnt + 1) if parent == \\'right\\' else 1)\\n            dfs(node.right, \\'right\\', (cnt + 1) if parent == \\'left\\' else 1)    \\n\\n        self.res = 0\\n        dfs(root, None, 0)\\n        return self.res\\n\\t\\t\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3962256,
                "title": "easy-java-dfs-with-and-without-global-variable-and-with-global-variable",
                "content": "Method 1: Using global variable\\n```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    int max = 0;\\n    public int longestZigZag(TreeNode root) {\\n        if(root==null)\\n            return -1;\\n        helper(root.right,1,true);\\n        helper(root.left,1,false);\\n        return max;\\n    }\\n    public void helper(TreeNode root,int step, boolean isright){\\n        if(root==null)\\n            return ;\\n        max = Math.max(max,step);\\n        if(isright){\\n            helper(root.left,step+1,false);\\n            helper(root.right,1,true);\\n        }\\n        else{\\n            helper(root.right,step+1,true);\\n            helper(root.left,1,false);\\n        }\\n    }\\n}\\n```\\n\\nMethod 2: Without Global variable\\n```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    public int longestZigZag(TreeNode root) {\\n        if(root==null)\\n            return -1;\\n        return Math.max(helper(root.right,1,true),\\n        helper(root.left,1,false));\\n    }\\n    public int helper(TreeNode root,int step, boolean isright){\\n        if(root==null)\\n            return 0;\\n        int left = 0;\\n        int right = 0;\\n        if(isright){\\n            left = helper(root.left,step+1,false);\\n            right = helper(root.right,1,true);\\n        }\\n        else{\\n            right = helper(root.right,step+1,true);\\n            left = helper(root.left,1,false);\\n        }\\n        return Math.max(step,Math.max(left,right));\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Depth-First Search"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    int max = 0;\\n    public int longestZigZag(TreeNode root) {\\n        if(root==null)\\n            return -1;\\n        helper(root.right,1,true);\\n        helper(root.left,1,false);\\n        return max;\\n    }\\n    public void helper(TreeNode root,int step, boolean isright){\\n        if(root==null)\\n            return ;\\n        max = Math.max(max,step);\\n        if(isright){\\n            helper(root.left,step+1,false);\\n            helper(root.right,1,true);\\n        }\\n        else{\\n            helper(root.right,step+1,true);\\n            helper(root.left,1,false);\\n        }\\n    }\\n}\\n```\n```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    public int longestZigZag(TreeNode root) {\\n        if(root==null)\\n            return -1;\\n        return Math.max(helper(root.right,1,true),\\n        helper(root.left,1,false));\\n    }\\n    public int helper(TreeNode root,int step, boolean isright){\\n        if(root==null)\\n            return 0;\\n        int left = 0;\\n        int right = 0;\\n        if(isright){\\n            left = helper(root.left,step+1,false);\\n            right = helper(root.right,1,true);\\n        }\\n        else{\\n            right = helper(root.right,step+1,true);\\n            left = helper(root.left,1,false);\\n        }\\n        return Math.max(step,Math.max(left,right));\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3598938,
                "title": "python-solution-using-recursion-and-further-memoization",
                "content": "\\n# Code\\n```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def longestZigZag(self, root: Optional[TreeNode]) -> int:\\n        dp = {}\\n\\n        def chk(node , dir):\\n            if node == None: return 0\\n\\n            if (node , dir) in dp: return dp[(node , dir)]\\n\\n            if dir == \"left\":\\n                if node.right:\\n                    dp[(node , dir)] = 1 + chk(node.right , \"right\")\\n                    return dp[(node , dir)]\\n\\n            elif dir == \"right\":\\n                if node.left:\\n                    dp[(node , dir)] = 1 + chk(node.left , \"left\")\\n                    return dp[(node , dir)]\\n            return 0\\n\\n        ans = -1\\n        def inorder(node):\\n            nonlocal ans\\n            if node == None: return \\n            inorder(node.left)\\n            ans = max( ans , chk(node , \"left\") )\\n            ans = max( ans , chk(node , \"right\"))\\n            inorder(node.right)\\n        \\n        inorder(root)\\n        return ans\\n```",
                "solutionTags": [
                    "Python3",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def longestZigZag(self, root: Optional[TreeNode]) -> int:\\n        dp = {}\\n\\n        def chk(node , dir):\\n            if node == None: return 0\\n\\n            if (node , dir) in dp: return dp[(node , dir)]\\n\\n            if dir == \"left\":\\n                if node.right:\\n                    dp[(node , dir)] = 1 + chk(node.right , \"right\")\\n                    return dp[(node , dir)]\\n\\n            elif dir == \"right\":\\n                if node.left:\\n                    dp[(node , dir)] = 1 + chk(node.left , \"left\")\\n                    return dp[(node , dir)]\\n            return 0\\n\\n        ans = -1\\n        def inorder(node):\\n            nonlocal ans\\n            if node == None: return \\n            inorder(node.left)\\n            ans = max( ans , chk(node , \"left\") )\\n            ans = max( ans , chk(node , \"right\"))\\n            inorder(node.right)\\n        \\n        inorder(root)\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3457726,
                "title": "java-dfs-no-global-variables",
                "content": "# Approach\\nDFS with in-place calculation of result. Addition of global result field can make execution faster since we will not need to make extra max comparison, but I prefer to keep the class clean, if possible.\\n\\n# Complexity\\n- Time complexity:\\n$$O(nodes)$$\\n\\n- Space complexity:\\n$$O(height)$$\\n\\n# Code\\n```\\nclass Solution {\\n    public int longestZigZag(TreeNode root) {\\n        return Math.max(helper(root, 0, true), helper(root, 0, false));\\n    }\\n\\n    private int helper(TreeNode node, int path, boolean isLeft) {\\n        if (node == null) return 0;\\n        int left = helper(node.left, isLeft ? 0 : path + 1, !isLeft);\\n        int right = helper(node.right, isLeft ? path + 1 : 0, !isLeft);\\n        return Math.max(path, Math.max(left, right));\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int longestZigZag(TreeNode root) {\\n        return Math.max(helper(root, 0, true), helper(root, 0, false));\\n    }\\n\\n    private int helper(TreeNode node, int path, boolean isLeft) {\\n        if (node == null) return 0;\\n        int left = helper(node.left, isLeft ? 0 : path + 1, !isLeft);\\n        int right = helper(node.right, isLeft ? path + 1 : 0, !isLeft);\\n        return Math.max(path, Math.max(left, right));\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3450296,
                "title": "c-find-longest-zigzag-in-binary-tree",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     struct TreeNode *left;\\n *     struct TreeNode *right;\\n * };\\n */\\n\\n#define LEFT    -1\\n#define RIGHT   1\\n#define START   0\\n\\nint max = 0;\\n\\n// Recursion to check all the ZigZag variations\\nvoid longestZigZagRecur(struct TreeNode* root, int way, int length_curr)\\n{\\n    if(length_curr > max)\\n    {\\n        max = length_curr;\\n    }\\n\\n    if((root->right == NULL) && (root->left == NULL))\\n    {\\n        return;\\n    }\\n\\n    if(root->right != NULL)\\n    {\\n        longestZigZagRecur(root->right, RIGHT, ((way == LEFT))? length_curr + 1 : 1);\\n    }\\n\\n    if(root->left != NULL)\\n    {\\n        longestZigZagRecur(root->left, LEFT, ((way == RIGHT))? length_curr + 1 : 1);\\n    }\\n}\\n\\nint longestZigZag(struct TreeNode* root)\\n{\\n    max = 0;\\n\\n    if(root->left == NULL && root->right == NULL)\\n    {\\n        return 0;\\n    }\\n\\n    longestZigZagRecur(root, START, 1);\\n\\n    return max;\\n}\\n```",
                "solutionTags": [
                    "C",
                    "Recursion"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     struct TreeNode *left;\\n *     struct TreeNode *right;\\n * };\\n */\\n\\n#define LEFT    -1\\n#define RIGHT   1\\n#define START   0\\n\\nint max = 0;\\n\\n// Recursion to check all the ZigZag variations\\nvoid longestZigZagRecur(struct TreeNode* root, int way, int length_curr)\\n{\\n    if(length_curr > max)\\n    {\\n        max = length_curr;\\n    }\\n\\n    if((root->right == NULL) && (root->left == NULL))\\n    {\\n        return;\\n    }\\n\\n    if(root->right != NULL)\\n    {\\n        longestZigZagRecur(root->right, RIGHT, ((way == LEFT))? length_curr + 1 : 1);\\n    }\\n\\n    if(root->left != NULL)\\n    {\\n        longestZigZagRecur(root->left, LEFT, ((way == RIGHT))? length_curr + 1 : 1);\\n    }\\n}\\n\\nint longestZigZag(struct TreeNode* root)\\n{\\n    max = 0;\\n\\n    if(root->left == NULL && root->right == NULL)\\n    {\\n        return 0;\\n    }\\n\\n    longestZigZagRecur(root, START, 1);\\n\\n    return max;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3440174,
                "title": "java-o-n-recursion",
                "content": "# Intuition\\nThe one way that comes to mind is to find all possible paths but with given nodes can as much as $$10 ^ 4$$ this solution goes in n$$O(n ^2)$$\\nSo intuition was to optimize this approach. \\nTo optimize we can do:\\n1. keep track of know length and calculate the max length in one traversal\\n2. reduce the unnecessary paths (as valid paths are only zigzags so we can eliminate non-zigzag paths)\\n3. eliminate the calculation of subpaths as parent paths already are bigger than subpath (implies function strictly follows zigzag path)\\n\\n# Approach\\n1. create a function that can traverse the tree in the zigZag pattern (recursive functions work in case of trees) \\n2. maintain a global variable max and update it at every end of each path (i.e. where root == null)\\n3. for every node start a new calculation for the opposite direction with length 0 (this will calculate strictly the opposite direction as a path in the same direction, starting a calculation from current node will be a subpath of the already calculated path)\\n\\n# Complexity\\n- Time complexity:\\nIn this approach each node is visited only once so time complexity $$O(n)$$\\n\\n- Space complexity:\\n$$O(n)$$\\n\\n# Code\\n```\\nclass Solution {\\n    int max = 0;\\n    public int longestZigZag(TreeNode root) {\\n       zigZag(root, 0, 0);\\n       return max;\\n    }\\n\\n    //score is current number of nodes in path\\n    //direction 0 is for left and 1 for right\\n    public void zigZag(TreeNode root, int score, int direction){\\n        if(root == null){\\n            //zigZag fuction caculates the number of nodes for max path so length will be score - 1, i.e. for 4 nodes path will be 3.\\n            max = Math.max(max, score - 1);\\n            return;\\n        }\\n\\n        if(direction == 0){\\n            zigZag(root.left, score+1, 1);\\n            //spliting into opposite possiblity with score 1 i.e. reseting score to 0 and +1 of root node\\n            zigZag(root.right, 1, 0);\\n        }else{\\n            zigZag(root.right, score+1, 0);\\n            zigZag(root.left, 1, 1);\\n        }\\n    }\\n}\\n```\\n# **Its my first solution, Please tell me if I\\'ve messed up**\\n![images.jfif](https://assets.leetcode.com/users/images/76597852-b4f1-4146-9ba1-ae0e37c73e2d_1682059638.439474.jpeg)\\n",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    int max = 0;\\n    public int longestZigZag(TreeNode root) {\\n       zigZag(root, 0, 0);\\n       return max;\\n    }\\n\\n    //score is current number of nodes in path\\n    //direction 0 is for left and 1 for right\\n    public void zigZag(TreeNode root, int score, int direction){\\n        if(root == null){\\n            //zigZag fuction caculates the number of nodes for max path so length will be score - 1, i.e. for 4 nodes path will be 3.\\n            max = Math.max(max, score - 1);\\n            return;\\n        }\\n\\n        if(direction == 0){\\n            zigZag(root.left, score+1, 1);\\n            //spliting into opposite possiblity with score 1 i.e. reseting score to 0 and +1 of root node\\n            zigZag(root.right, 1, 0);\\n        }else{\\n            zigZag(root.right, score+1, 0);\\n            zigZag(root.left, 1, 1);\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3436431,
                "title": "intuitive-python-solution-solution-blog",
                "content": "# Welcome to my Solution Blog!\\n![Copy of Copy of 617 ALG (2).png](https://assets.leetcode.com/users/images/9f9bbc79-74b6-4bb1-9383-7e44175139f7_1681946631.0889835.png)\\n\\n**Base Case:**\\nWhen you hit a leaf node -> return the depth and it\\'ll propagate up the tree and be returned!\\n\\n**Two Paths from here!**\\n\\nIf you went left previously, take the maximum of:\\n1. the current depth\\n2. now going down the right path, and incrementing the depth by 1\\n3. go down the left path AGAIN, and reset depth to 0\\n\\nThen repeat this logic (but reversed) for if you went right previously.\\n\\n\\n- Time complexity: O(N)\\n\\n- Space complexity: O(N)\\n\\n```\\nclass Solution:\\n    def longestZigZag(self, root: Optional[TreeNode]) -> int:\\n        return max(self.helper(root.left, True, 0), self.helper(root.right, False, 0))\\n    \\n    def helper(self, root, isLeft, depth):\\n        if not root: return depth\\n\\n        if isLeft:\\n            depth = max(\\n                depth,\\n                self.helper(root.right, False, depth + 1),\\n                self.helper(root.left, True, 0)\\n            )\\n        \\n        else: # otherwise we previously went\\n            depth = max(\\n                depth,\\n                self.helper(root.left, True, depth + 1),\\n                self.helper(root.right, False, 0)\\n            )\\n        return depth\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def longestZigZag(self, root: Optional[TreeNode]) -> int:\\n        return max(self.helper(root.left, True, 0), self.helper(root.right, False, 0))\\n    \\n    def helper(self, root, isLeft, depth):\\n        if not root: return depth\\n\\n        if isLeft:\\n            depth = max(\\n                depth,\\n                self.helper(root.right, False, depth + 1),\\n                self.helper(root.left, True, 0)\\n            )\\n        \\n        else: # otherwise we previously went\\n            depth = max(\\n                depth,\\n                self.helper(root.left, True, depth + 1),\\n                self.helper(root.right, False, 0)\\n            )\\n        return depth\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3436145,
                "title": "easy-c-top-down-solution",
                "content": "# Intuition\\nJust consider as waterfalling with bouncing.\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n\\n# Approach\\nTop Down \\n<!-- Describe your approach to solving the problem. -->\\n\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n\\n- Space complexity:\\n O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code \\n\\nclass Solution {\\npublic:\\n\\n    int max=0;\\n    void lng(TreeNode* root,bool dir,int ln){\\n        if(max<ln)max=ln;\\n        if(dir){//dir == 1 as root direction is right\\n            if(root->left !=nullptr) lng(root->left,0,ln+1);//right to left increase length\\n            if(root->right !=nullptr)lng(root->right,1,1);//new starting point\\n        }\\n        else{//dir == 0 as root direction is left\\n            if(root->left !=nullptr) lng(root->left,0,1);//new starting point\\n            if(root->right !=nullptr)lng(root->right,1,ln+1);//left to right increase length\\n        }\\n        return ;\\n    }\\n    int longestZigZag(TreeNode* root) {\\n        if(root)lng(root, 0, 0);\\n        return max;\\n    }\\n};\\n\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "class Solution {\\npublic:\\n\\n    int max=0;\\n    void lng(TreeNode* root,bool dir,int ln){\\n        if(max<ln)max=ln;\\n        if(dir){//dir == 1 as root direction is right\\n            if(root->left !=nullptr) lng(root->left,0,ln+1);//right to left increase length\\n            if(root->right !=nullptr)lng(root->right,1,1);//new starting point\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 3435540,
                "title": "java-recursive-solution-pre-order-traversal",
                "content": "# Intuition\\nTraverse the tree and keep a boolean to identify reft and left and keep count accordingly.\\n# Approach\\nTraverse the tree\\n    keep boolean to identify previous move\\n    increment/set count accordingly\\n    check for max and update\\nreturn max;\\n\\n# Complexity\\n- Time complexity:O(n)\\n\\n- Space complexity:O(1)\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    int max = 0;\\n    public int longestZigZag(TreeNode root) {\\n        if(root.left != null){\\n            traverse(root.left,true,1);\\n        }\\n        if(root.right != null){\\n            traverse(root.right,false,1);\\n        }\\n        return max;\\n    }\\n    public void traverse(TreeNode root,boolean left,int count){\\n        if(max < count){\\n            max = count;\\n        }\\n        if(root.left != null){\\n            traverse(root.left,true,!left?count+1:1);\\n        }\\n        if(root.right != null){\\n            traverse(root.right,false,left?count+1:1);\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Tree"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    int max = 0;\\n    public int longestZigZag(TreeNode root) {\\n        if(root.left != null){\\n            traverse(root.left,true,1);\\n        }\\n        if(root.right != null){\\n            traverse(root.right,false,1);\\n        }\\n        return max;\\n    }\\n    public void traverse(TreeNode root,boolean left,int count){\\n        if(max < count){\\n            max = count;\\n        }\\n        if(root.left != null){\\n            traverse(root.left,true,!left?count+1:1);\\n        }\\n        if(root.right != null){\\n            traverse(root.right,false,left?count+1:1);\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3435468,
                "title": "c-easy-solution-easy-recursion-solution",
                "content": "\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\nint ans=0;\\n    void dfs(TreeNode* root,bool last,int len)\\n    {\\n        if(!root) return;\\n        ans=max(ans,len);\\n        if(!last)\\n        {\\n            dfs(root->left,false,1);\\n            dfs(root->right,true,len+1);\\n        }\\n        else\\n        {\\n            dfs(root->left,false,len+1);\\n            dfs(root->right,true,1);\\n        }\\n    }\\n    int longestZigZag(TreeNode* root) {\\n        dfs(root->left,false,1);\\n        dfs(root->right,true,1);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\nint ans=0;\\n    void dfs(TreeNode* root,bool last,int len)\\n    {\\n        if(!root) return;\\n        ans=max(ans,len);\\n        if(!last)\\n        {\\n            dfs(root->left,false,1);\\n            dfs(root->right,true,len+1);\\n        }\\n        else\\n        {\\n            dfs(root->left,false,len+1);\\n            dfs(root->right,true,1);\\n        }\\n    }\\n    int longestZigZag(TreeNode* root) {\\n        dfs(root->left,false,1);\\n        dfs(root->right,true,1);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3435314,
                "title": "python3-dfs-solution",
                "content": "\\n\\n# Code\\n```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def longestZigZag(self, root: Optional[TreeNode]) -> int:\\n\\n\\n        def dfs(root,direction,depth):\\n            \\n            nonlocal res\\n            if not root:\\n                return \\n            res=max(res,depth)\\n\\n            if direction==-1:\\n                dfs(root.right,1,depth+1)\\n                dfs(root.left,-1,1)\\n\\n            else:\\n                dfs(root.left,-1,depth+1)\\n                dfs(root.right,1,1)\\n            \\n        res=0\\n        dfs(root,1,0)\\n        \\n        return res\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Depth-First Search"
                ],
                "code": "```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def longestZigZag(self, root: Optional[TreeNode]) -> int:\\n\\n\\n        def dfs(root,direction,depth):\\n            \\n            nonlocal res\\n            if not root:\\n                return \\n            res=max(res,depth)\\n\\n            if direction==-1:\\n                dfs(root.right,1,depth+1)\\n                dfs(root.left,-1,1)\\n\\n            else:\\n                dfs(root.left,-1,depth+1)\\n                dfs(root.right,1,1)\\n            \\n        res=0\\n        dfs(root,1,0)\\n        \\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3434968,
                "title": "easy-solution-in-java-recursion",
                "content": "\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    int maxLen = 0;\\n    public int longestZigZag(TreeNode root) {\\n        helper(root, 0, 0);  \\n        helper(root, 1, 0);  \\n        return maxLen;  \\n    }\\n\\n    public void helper(TreeNode root, int path, int currentLen){\\n        if(root == null)\\n            return;\\n        maxLen = Math.max(maxLen, currentLen);\\n        if(path == 1)\\n        {\\n            helper(root.left, 0, currentLen + 1);\\n            helper(root.right, 1, 1);\\n        }\\n        else\\n        {\\n            helper(root.right, 1, currentLen + 1);\\n            helper(root.left, 0, 1);\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Recursion",
                    "Binary Tree"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    int maxLen = 0;\\n    public int longestZigZag(TreeNode root) {\\n        helper(root, 0, 0);  \\n        helper(root, 1, 0);  \\n        return maxLen;  \\n    }\\n\\n    public void helper(TreeNode root, int path, int currentLen){\\n        if(root == null)\\n            return;\\n        maxLen = Math.max(maxLen, currentLen);\\n        if(path == 1)\\n        {\\n            helper(root.left, 0, currentLen + 1);\\n            helper(root.right, 1, 1);\\n        }\\n        else\\n        {\\n            helper(root.right, 1, currentLen + 1);\\n            helper(root.left, 0, 1);\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3434642,
                "title": "java-beats-100-optimal-solution-easy-explanation-beginner-friendly-dfs",
                "content": "\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n**CODE WITHOUT COMMENTS BELOW**\\n\\n**UPVOTE PLEASE !!!**\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    int max=0; // to store max\\n    public int longestZigZag(TreeNode root) {\\n        if(root.left!=null){\\n           helper(root.left,true,1);    // going left adding 1 node\\n        }\\n        if(root.right!=null){\\n            helper(root.right,false,1); // going right adding 1 node\\n        }\\n        return max;\\n        \\n    }\\n    //BOOLEAN LEFT to know if arrived at this node by traversing left or right\\n    public void helper(TreeNode root,boolean left,int val){\\n        if(root.left==null && root.right==null){\\n            //LEAF NODE return val\\n            max=Math.max(val,max);\\n            return;\\n        }\\n      \\n        if(left){  \\n            //if arrived from left then right node should be included \\n            if(root.right!=null){\\n             helper(root.right,false,val+1);  //+1 node as right node is present\\n            }else{\\n                max=Math.max(val,max);    //if right node not present compare the val to max\\n            }\\n            if(root.left!=null){\\n                helper(root.left,true,1);   // starting as 1st node as it has already arrived from left so going left would be starting a new chain\\n\\n            }\\n        }else{\\n           \\n             if(root.right!=null){\\n                 helper(root.right,false,1);\\n            }\\n             //if arrived from right then left node should be included \\n            if(root.left!=null){\\n                helper(root.left,true,val+1); //+1 node as right node is present\\n\\n            }\\n            else{\\n                max=Math.max(val,max);    //if left node not present compare the val to max\\n            }\\n\\n        }\\n        \\n    }\\n}\\n```\\n**CODE WITHOUT COMMENTS**\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    int max=0;\\n    public int longestZigZag(TreeNode root) {\\n        if(root.left!=null){\\n           helper(root.left,true,1);\\n        }\\n        if(root.right!=null){\\n            helper(root.right,false,1);\\n        }\\n        return max;\\n        \\n    }\\n    public void helper(TreeNode root,boolean left,int val){\\n        if(root.left==null && root.right==null){\\n            max=Math.max(val,max);\\n            return;\\n        }\\n        if(left){\\n            if(root.right!=null){\\n             helper(root.right,false,val+1);\\n            }else{\\n                max=Math.max(val,max);\\n            }\\n            if(root.left!=null){\\n                helper(root.left,true,1);\\n            }\\n        }else{\\n             if(root.right!=null){\\n                 helper(root.right,false,1);\\n            }\\n            if(root.left!=null){\\n                helper(root.left,true,val+1);\\n            }\\n            else{\\n                max=Math.max(val,max);\\n            }\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming",
                    "Tree",
                    "Depth-First Search",
                    "Binary Tree"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    int max=0; // to store max\\n    public int longestZigZag(TreeNode root) {\\n        if(root.left!=null){\\n           helper(root.left,true,1);    // going left adding 1 node\\n        }\\n        if(root.right!=null){\\n            helper(root.right,false,1); // going right adding 1 node\\n        }\\n        return max;\\n        \\n    }\\n    //BOOLEAN LEFT to know if arrived at this node by traversing left or right\\n    public void helper(TreeNode root,boolean left,int val){\\n        if(root.left==null && root.right==null){\\n            //LEAF NODE return val\\n            max=Math.max(val,max);\\n            return;\\n        }\\n      \\n        if(left){  \\n            //if arrived from left then right node should be included \\n            if(root.right!=null){\\n             helper(root.right,false,val+1);  //+1 node as right node is present\\n            }else{\\n                max=Math.max(val,max);    //if right node not present compare the val to max\\n            }\\n            if(root.left!=null){\\n                helper(root.left,true,1);   // starting as 1st node as it has already arrived from left so going left would be starting a new chain\\n\\n            }\\n        }else{\\n           \\n             if(root.right!=null){\\n                 helper(root.right,false,1);\\n            }\\n             //if arrived from right then left node should be included \\n            if(root.left!=null){\\n                helper(root.left,true,val+1); //+1 node as right node is present\\n\\n            }\\n            else{\\n                max=Math.max(val,max);    //if left node not present compare the val to max\\n            }\\n\\n        }\\n        \\n    }\\n}\\n```\n```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    int max=0;\\n    public int longestZigZag(TreeNode root) {\\n        if(root.left!=null){\\n           helper(root.left,true,1);\\n        }\\n        if(root.right!=null){\\n            helper(root.right,false,1);\\n        }\\n        return max;\\n        \\n    }\\n    public void helper(TreeNode root,boolean left,int val){\\n        if(root.left==null && root.right==null){\\n            max=Math.max(val,max);\\n            return;\\n        }\\n        if(left){\\n            if(root.right!=null){\\n             helper(root.right,false,val+1);\\n            }else{\\n                max=Math.max(val,max);\\n            }\\n            if(root.left!=null){\\n                helper(root.left,true,1);\\n            }\\n        }else{\\n             if(root.right!=null){\\n                 helper(root.right,false,1);\\n            }\\n            if(root.left!=null){\\n                helper(root.left,true,val+1);\\n            }\\n            else{\\n                max=Math.max(val,max);\\n            }\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3434458,
                "title": "optimised-solution-with-easy-and-complete-explanation",
                "content": "# Intuition\\nTo solve this problem, we can perform a depth-first search (DFS) on the binary tree, keeping track of the length of the longest ZigZag path seen so far. For each node, we need to check both the left and right subtrees to see if there are any ZigZag paths that pass through the node.\\n\\n# Approach\\nTo do this, we can define a helper function dfs that takes in a node and a boolean flag indicating whether we are currently traversing the left or right subtree. If we are traversing the left subtree, we update the length of the longest ZigZag path seen so far by adding the length of the longest ZigZag path in the right subtree of the current node plus 1 (for the current node). Similarly, if we are traversing the right subtree, we update the length of the longest ZigZag path seen so far by adding the length of the longest ZigZag path in the left subtree of the current node plus 1.\\n\\nWe can then call this helper function on the root node, passing in a flag indicating that we are not currently traversing any subtree (i.e., the root node is not part of any ZigZag path). Finally, we return the length of the longest ZigZag path seen so far.\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int longestZigZag(TreeNode* root) {\\n        int max_length = 0;\\n        dfs(root, false, 0, max_length); // Start with root node, not traversing any subtree\\n        dfs(root, true, 0, max_length); // Start with root node, traversing right subtree\\n        return max_length;\\n    }\\n    \\n    void dfs(TreeNode* node, bool is_right, int length, int& max_length) {\\n        if (!node) return;\\n        max_length = max(max_length, length); // Update max_length with current ZigZag path length\\n        \\n        if (is_right) { // Traversing right subtree\\n            dfs(node->right, false, length + 1, max_length); // Check left subtree\\n            dfs(node->left, true, 1, max_length); // Check right subtree\\n        } else { // Traversing left subtree\\n            dfs(node->left, true, length + 1, max_length); // Check right subtree\\n            dfs(node->right, false, 1, max_length); // Check left subtree\\n        }\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Dynamic Programming",
                    "Tree",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int longestZigZag(TreeNode* root) {\\n        int max_length = 0;\\n        dfs(root, false, 0, max_length); // Start with root node, not traversing any subtree\\n        dfs(root, true, 0, max_length); // Start with root node, traversing right subtree\\n        return max_length;\\n    }\\n    \\n    void dfs(TreeNode* node, bool is_right, int length, int& max_length) {\\n        if (!node) return;\\n        max_length = max(max_length, length); // Update max_length with current ZigZag path length\\n        \\n        if (is_right) { // Traversing right subtree\\n            dfs(node->right, false, length + 1, max_length); // Check left subtree\\n            dfs(node->left, true, 1, max_length); // Check right subtree\\n        } else { // Traversing left subtree\\n            dfs(node->left, true, length + 1, max_length); // Check right subtree\\n            dfs(node->right, false, 1, max_length); // Check left subtree\\n        }\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3434428,
                "title": "go-clean-recursive-solution",
                "content": "```\\nfunc longestZigZag(root *TreeNode) int {\\n    res := 0\\n    \\n    var walk func(*TreeNode, int, int)\\n    walk = func(root* TreeNode, l, r int) {\\n        if root != nil {\\n            res = max(res, l, r)\\n            walk(root.Left, r + 1, 0)\\n            walk(root.Right, 0, l + 1)\\n        }\\n    }\\n    \\n    walk(root, 0, 0)\\n    return res\\n}\\n\\nfunc max(a ...int) int {\\n    res := a[0]\\n    for _, v := range a {\\n        if v > res {\\n            res = v\\n        }\\n    }\\n    return res\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc longestZigZag(root *TreeNode) int {\\n    res := 0\\n    \\n    var walk func(*TreeNode, int, int)\\n    walk = func(root* TreeNode, l, r int) {\\n        if root != nil {\\n            res = max(res, l, r)\\n            walk(root.Left, r + 1, 0)\\n            walk(root.Right, 0, l + 1)\\n        }\\n    }\\n    \\n    walk(root, 0, 0)\\n    return res\\n}\\n\\nfunc max(a ...int) int {\\n    res := a[0]\\n    for _, v := range a {\\n        if v > res {\\n            res = v\\n        }\\n    }\\n    return res\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3434362,
                "title": "javascript-simple-recursive-solution",
                "content": "# Approach\\nRecursively: \\n- if root is null, return -1 to compensate the +1 from previous call to result to 0\\n- if root is left child, recursively check its right subtree and add root edge to it. Then recursively check its left subtree and assign max of these values to ans. We always want to return the right subtree max here, so we can continue to add up to that path.\\n- if root is right child, do the same, but mirrored (instead of right subtree we\\'ll return right one)\\n\\n# Complexity\\n- Time complexity:\\n$$O(n)$$\\n\\n- Space complexity:\\n$$O(n)$$\\n\\n# Code\\n```\\nconst LEFT = 0\\nconst RIGHT = 1\\nlet ans = 0\\n\\n/**\\n * @param {TreeNode} root\\n * @return {number}\\n */\\nconst longestZigZag = root => {\\n    ans = 0\\n    const left = 1 + recLongestZigZag(root.left, LEFT)\\n    const right = 1 + recLongestZigZag(root.right, RIGHT)\\n    ans = Math.max(\\n        left,\\n        right,\\n        ans,\\n    )\\n    return ans\\n}\\n\\nconst recLongestZigZag = (root, dir) => {\\n    if (root === null) return -1\\n    const left = 1 + recLongestZigZag(root.left, LEFT)\\n    const right = 1 + recLongestZigZag(root.right, RIGHT)\\n    ans = Math.max(ans, left, right)\\n    return dir === LEFT ? right : left\\n}\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Depth-First Search",
                    "Recursion",
                    "Binary Tree"
                ],
                "code": "```\\nconst LEFT = 0\\nconst RIGHT = 1\\nlet ans = 0\\n\\n/**\\n * @param {TreeNode} root\\n * @return {number}\\n */\\nconst longestZigZag = root => {\\n    ans = 0\\n    const left = 1 + recLongestZigZag(root.left, LEFT)\\n    const right = 1 + recLongestZigZag(root.right, RIGHT)\\n    ans = Math.max(\\n        left,\\n        right,\\n        ans,\\n    )\\n    return ans\\n}\\n\\nconst recLongestZigZag = (root, dir) => {\\n    if (root === null) return -1\\n    const left = 1 + recLongestZigZag(root.left, LEFT)\\n    const right = 1 + recLongestZigZag(root.right, RIGHT)\\n    ans = Math.max(ans, left, right)\\n    return dir === LEFT ? right : left\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3434187,
                "title": "tree-depth-first-search",
                "content": "<!-- # Intuition -->\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n<!-- # Approach -->\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(h)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nvar longestZigZag = function(root) {\\n    var maxZigZag = 0;\\n    function dfs(root, zig, zigzag) {\\n        if(root == null)\\n            return;\\n        maxZigZag = Math.max(maxZigZag, zigzag);\\n        dfs(root.left, -1, 1 + ((zig == 1) ? zigzag : 0));\\n        dfs(root.right, 1, 1 + ((zig == -1) ? zigzag : 0));\\n    };\\n    dfs(root, 0, 0);\\n    return maxZigZag;\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Tree",
                    "Depth-First Search"
                ],
                "code": "```\\nvar longestZigZag = function(root) {\\n    var maxZigZag = 0;\\n    function dfs(root, zig, zigzag) {\\n        if(root == null)\\n            return;\\n        maxZigZag = Math.max(maxZigZag, zigzag);\\n        dfs(root.left, -1, 1 + ((zig == 1) ? zigzag : 0));\\n        dfs(root.right, 1, 1 + ((zig == -1) ? zigzag : 0));\\n    };\\n    dfs(root, 0, 0);\\n    return maxZigZag;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3434039,
                "title": "java-dfs-explained",
                "content": "# Solution:\\n```\\nclass Solution {\\n    private int max = 0;\\n    public int longestZigZag(TreeNode root) {\\n        // we are currently standing on the root node\\n        dfs(root.left, 1, false);   // call for left\\n        dfs(root.right, 1, true);   // call for right\\n        // Why 1? Because from root to root\\'s left or right \\n        // is a distance of 1 unit\\n        return max;\\n    }\\n\\n    // the parameter boolean goRight will let us know \\n    // if we took the right direction or the left direction\\n    private void dfs(TreeNode root, int depth, boolean goRight) {\\n        if (root == null) {\\n            return;\\n        }\\n        // update max distance\\n        max = Math.max(max, depth); \\n        // if we had took right direction\\n        if (goRight) {\\n            // we have 2 options:\\n            // Go left: That\\'d be a zigzag order so distance + 1\\n            dfs(root.left, depth + 1, false);\\n            // Go right: Zigzag order is broken so distance resets to 1\\n            dfs(root.right, 1, true);\\n        } \\n        // Else if we had took a left direction\\n        else {\\n            // we have 2 options:\\n            // Go left: Zigzag order is broken so distance resets to 1\\n            dfs(root.left, 1, false);\\n            // Go right: That\\'d be a zigzag order so distance + 1\\n            dfs(root.right, depth + 1, true);\\n        }\\n        // In each call we set goRight true or false accordingly \\n        // if we are moving to left or right\\n\\n        // Also, why are we resetting the distance to 1 and not 0?\\n        // Because, from current node to next node where we are \\n        // stepping on, the distance is 1, so we set it to 1.\\n    }\\n}\\n```\\n---\\n\\nIn the above solution, we stood at the root and called our recursive method on left and right in the `longestZigZag()` method.\\n\\nWe can also call the recursive method only once in `longestZigZag()` by calling it on the root node itself, setting `goRight` parameter to anything, because we are just stepping our foot on it, it doesn\\'t matter if we came from left or right. The distance would be `0` at root because we can\\'t count our steps if we came from emptiness. We start counting after we start stepping afterwards from root node.  Everything will just be the same from there.\\n```\\ndfs(root, 0, false);\\n```\\n---\\n## Clean solution:\\n```\\nclass Solution {\\n    private int max = 0;\\n    public int longestZigZag(TreeNode root) {\\n        dfs(root, 0, false); \\n        return max;\\n    }\\n\\n    private void dfs(TreeNode root, int depth, boolean goRight) {\\n        if (root == null) \\n            return;\\n        }\\n        max = Math.max(max, depth); \\n        if (goRight) {\\n            dfs(root.left, depth + 1, false);\\n            dfs(root.right, 1, true);\\n        } else {dfs(root.left, 1, false);\\n            dfs(root.right, depth + 1, true);\\n        }\\n    }\\n}\\n```\\n---\\n### Time complexity: $$O(n)$$\\n### Space complexity: $$O(n)$$",
                "solutionTags": [
                    "Java",
                    "Tree",
                    "Depth-First Search",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\n    private int max = 0;\\n    public int longestZigZag(TreeNode root) {\\n        // we are currently standing on the root node\\n        dfs(root.left, 1, false);   // call for left\\n        dfs(root.right, 1, true);   // call for right\\n        // Why 1? Because from root to root\\'s left or right \\n        // is a distance of 1 unit\\n        return max;\\n    }\\n\\n    // the parameter boolean goRight will let us know \\n    // if we took the right direction or the left direction\\n    private void dfs(TreeNode root, int depth, boolean goRight) {\\n        if (root == null) {\\n            return;\\n        }\\n        // update max distance\\n        max = Math.max(max, depth); \\n        // if we had took right direction\\n        if (goRight) {\\n            // we have 2 options:\\n            // Go left: That\\'d be a zigzag order so distance + 1\\n            dfs(root.left, depth + 1, false);\\n            // Go right: Zigzag order is broken so distance resets to 1\\n            dfs(root.right, 1, true);\\n        } \\n        // Else if we had took a left direction\\n        else {\\n            // we have 2 options:\\n            // Go left: Zigzag order is broken so distance resets to 1\\n            dfs(root.left, 1, false);\\n            // Go right: That\\'d be a zigzag order so distance + 1\\n            dfs(root.right, depth + 1, true);\\n        }\\n        // In each call we set goRight true or false accordingly \\n        // if we are moving to left or right\\n\\n        // Also, why are we resetting the distance to 1 and not 0?\\n        // Because, from current node to next node where we are \\n        // stepping on, the distance is 1, so we set it to 1.\\n    }\\n}\\n```\n```\\ndfs(root, 0, false);\\n```\n```\\nclass Solution {\\n    private int max = 0;\\n    public int longestZigZag(TreeNode root) {\\n        dfs(root, 0, false); \\n        return max;\\n    }\\n\\n    private void dfs(TreeNode root, int depth, boolean goRight) {\\n        if (root == null) \\n            return;\\n        }\\n        max = Math.max(max, depth); \\n        if (goRight) {\\n            dfs(root.left, depth + 1, false);\\n            dfs(root.right, 1, true);\\n        } else {dfs(root.left, 1, false);\\n            dfs(root.right, depth + 1, true);\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3433906,
                "title": "java-solution",
                "content": "\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int longestZigZag(TreeNode root) {\\n        harsh(root,1,1,0);\\n        return ans;\\n    }\\n    int ans=0;\\n    public void harsh(TreeNode root,int l,int r,int s){\\n        ans=Math.max(ans,s);\\n        if(root.left!=null) harsh(root.left,0,1,s*l+1);\\n        if(root.right!=null) harsh(root.right,1,0,s*r+1);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\n    public int longestZigZag(TreeNode root) {\\n        harsh(root,1,1,0);\\n        return ans;\\n    }\\n    int ans=0;\\n    public void harsh(TreeNode root,int l,int r,int s){\\n        ans=Math.max(ans,s);\\n        if(root.left!=null) harsh(root.left,0,1,s*l+1);\\n        if(root.right!=null) harsh(root.right,1,0,s*r+1);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3433704,
                "title": "c-recursive-code-to-optimised-code",
                "content": "**Recursive Code**\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    //int cnt=0;\\n    int maxi=1;\\n    void f(TreeNode* root,string dir,int cnt)\\n    {\\n        if(root==NULL)\\n        {\\n            maxi=max(maxi,cnt);\\n            return;\\n        }\\n        if(dir==\"right\")\\n            f(root->right,\"left\",cnt+1);\\n        else\\n            f(root->left,\"right\",cnt+1);\\n    }\\n    void f1(TreeNode* root)\\n    {\\n        if(root==NULL)\\n            return;\\n            f(root,\"left\",0);\\n            f(root,\"right\",0);\\n        f1(root->left);\\n        f1(root->right);\\n    }\\n    int longestZigZag(TreeNode* root) {\\n        f1(root);\\n        return maxi-1;\\n    }\\n};\\n```\\n**Optimised Code**\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    int maxi=INT_MIN;\\n    void f(TreeNode* root,string dir,int cnt)\\n    {\\n        if(root==NULL)\\n            return;\\n        maxi=max(maxi,cnt);\\n        if(dir==\"left\")\\n        {\\n           f(root->right,\"right\",cnt+1);\\n           f(root->left,\"left\",1);\\n        }\\n        else\\n        {\\n            f(root->left,\"left\",cnt+1);\\n            f(root->right,\"right\",1);\\n        }\\n        \\n    }\\n    int longestZigZag(TreeNode* root) {\\n        f(root,\"left\",0);\\n        f(root,\"right\",0);\\n        return (maxi==INT_MIN)?0:maxi;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Depth-First Search"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    //int cnt=0;\\n    int maxi=1;\\n    void f(TreeNode* root,string dir,int cnt)\\n    {\\n        if(root==NULL)\\n        {\\n            maxi=max(maxi,cnt);\\n            return;\\n        }\\n        if(dir==\"right\")\\n            f(root->right,\"left\",cnt+1);\\n        else\\n            f(root->left,\"right\",cnt+1);\\n    }\\n    void f1(TreeNode* root)\\n    {\\n        if(root==NULL)\\n            return;\\n            f(root,\"left\",0);\\n            f(root,\"right\",0);\\n        f1(root->left);\\n        f1(root->right);\\n    }\\n    int longestZigZag(TreeNode* root) {\\n        f1(root);\\n        return maxi-1;\\n    }\\n};\\n```\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    int maxi=INT_MIN;\\n    void f(TreeNode* root,string dir,int cnt)\\n    {\\n        if(root==NULL)\\n            return;\\n        maxi=max(maxi,cnt);\\n        if(dir==\"left\")\\n        {\\n           f(root->right,\"right\",cnt+1);\\n           f(root->left,\"left\",1);\\n        }\\n        else\\n        {\\n            f(root->left,\"left\",cnt+1);\\n            f(root->right,\"right\",1);\\n        }\\n        \\n    }\\n    int longestZigZag(TreeNode* root) {\\n        f(root,\"left\",0);\\n        f(root,\"right\",0);\\n        return (maxi==INT_MIN)?0:maxi;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3433462,
                "title": "python-short-and-clean-dfs-functional-programming",
                "content": "# Approach\\n1. Define `longest_zig_zag` which takes a `node` and returns:\\n    - longest zigzig beginning from `node` and taking `left` edge.\\n    - longest zigzag beginning from `node` and taking `right` edge.\\n    - longest zigzag beginning anywhere in the subtree of `node`. (This is the desired answer)\\n\\n2. Recursively, call `longest_zig_zag` on `left` and `right` subtrees.\\n\\n3. Now, compute the result values for `node` based on the results of subtrees as shown in the code below.\\n\\n# Complexity\\n- Time complexity: $$O(n)$$\\n\\n- Space complexity: $$O(n)$$\\n\\nwhere, `n is the number of nodes in the tree`.\\n\\n# Code\\n```python\\nclass Solution:\\n    def longestZigZag(self, root: TreeNode | None) -> int:\\n        def longest_zig_zag(node: TreeNode | None) -> tuple[int, int, int]:\\n            if node is None: return -1, -1, -1\\n\\n            _, lt_node_max, lt_tree_max = longest_zig_zag(node.left)\\n            rt_node_max, _, rt_tree_max = longest_zig_zag(node.right)\\n\\n            lt, rt = lt_node_max + 1, rt_node_max + 1\\n            return lt, rt, max(lt_tree_max, rt_tree_max, lt, rt)\\n        \\n        return longest_zig_zag(root)[-1]\\n\\n\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Dynamic Programming",
                    "Depth-First Search",
                    "Binary Tree"
                ],
                "code": "```python\\nclass Solution:\\n    def longestZigZag(self, root: TreeNode | None) -> int:\\n        def longest_zig_zag(node: TreeNode | None) -> tuple[int, int, int]:\\n            if node is None: return -1, -1, -1\\n\\n            _, lt_node_max, lt_tree_max = longest_zig_zag(node.left)\\n            rt_node_max, _, rt_tree_max = longest_zig_zag(node.right)\\n\\n            lt, rt = lt_node_max + 1, rt_node_max + 1\\n            return lt, rt, max(lt_tree_max, rt_tree_max, lt, rt)\\n        \\n        return longest_zig_zag(root)[-1]\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3433449,
                "title": "python-simple-python-solution-using-dfs-recursion",
                "content": "# If You like the Solution, Don\\'t Forget To UpVote Me, Please UpVote! \\uD83D\\uDD3C\\uD83D\\uDE4F\\n# Runtime: 377 ms, faster than 83.88% of Python3 online submissions for Longest ZigZag Path in a Binary Tree.\\n# Memory Usage: 60.9 MB, less than 69.60% of Python3 online submissions for Longest ZigZag Path in a Binary Tree.\\n\\n\\tclass Solution:\\n\\t\\tdef longestZigZag(self, root: Optional[TreeNode]) -> int:\\n\\n\\t\\t\\tself.result = 0\\n\\n\\t\\t\\tdef DFS(node, current_max_path, direction):\\n\\n\\t\\t\\t\\tif node != None:\\n\\n\\t\\t\\t\\t\\tself.result = max(self.result, current_max_path)\\n\\n\\t\\t\\t\\t\\tif direction:\\n\\t\\t\\t\\t\\t\\tDFS(node.right , current_max_path + 1 , False)\\n\\t\\t\\t\\t\\t\\tDFS(node.left , 1 , True)\\n\\n\\t\\t\\t\\t\\telse:\\n\\t\\t\\t\\t\\t\\tDFS(node.left , current_max_path + 1 , True)\\n\\t\\t\\t\\t\\t\\tDFS(node.right , 1 , False)\\n\\n\\t\\t\\tif root.left:\\n\\t\\t\\t\\tDFS(root.left , 1 , True)\\n\\n\\t\\t\\tif root.right:\\n\\t\\t\\t\\tDFS(root.right , 1 , False)\\n\\n\\t\\t\\treturn self.result\\n\\t\\t\\t\\n# Thank You \\uD83E\\uDD73\\u270C\\uD83D\\uDC4D",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Tree",
                    "Depth-First Search",
                    "Recursion",
                    "Binary Tree"
                ],
                "code": "# If You like the Solution, Don\\'t Forget To UpVote Me, Please UpVote! \\uD83D\\uDD3C\\uD83D\\uDE4F\\n# Runtime: 377 ms, faster than 83.88% of Python3 online submissions for Longest ZigZag Path in a Binary Tree.\\n# Memory Usage: 60.9 MB, less than 69.60% of Python3 online submissions for Longest ZigZag Path in a Binary Tree.\\n\\n\\tclass Solution:\\n\\t\\tdef longestZigZag(self, root: Optional[TreeNode]) -> int:\\n\\n\\t\\t\\tself.result = 0\\n\\n\\t\\t\\tdef DFS(node, current_max_path, direction):\\n\\n\\t\\t\\t\\tif node != None:\\n\\n\\t\\t\\t\\t\\tself.result = max(self.result, current_max_path)\\n\\n\\t\\t\\t\\t\\tif direction:\\n\\t\\t\\t\\t\\t\\tDFS(node.right , current_max_path + 1 , False)\\n\\t\\t\\t\\t\\t\\tDFS(node.left , 1 , True)\\n\\n\\t\\t\\t\\t\\telse:\\n\\t\\t\\t\\t\\t\\tDFS(node.left , current_max_path + 1 , True)\\n\\t\\t\\t\\t\\t\\tDFS(node.right , 1 , False)\\n\\n\\t\\t\\tif root.left:\\n\\t\\t\\t\\tDFS(root.left , 1 , True)\\n\\n\\t\\t\\tif root.right:\\n\\t\\t\\t\\tDFS(root.right , 1 , False)\\n\\n\\t\\t\\treturn self.result\\n\\t\\t\\t\\n# Thank You \\uD83E\\uDD73\\u270C\\uD83D\\uDC4D",
                "codeTag": "Java"
            },
            {
                "id": 3433343,
                "title": "iterative-dfs-solution-in-rust",
                "content": "# Complexity\\n- Time complexity:\\n$$O(n)$$\\n\\n- Space complexity:\\n$$O(n)$$\\n\\n# Code\\n```\\nuse std::rc::Rc;\\nuse std::cell::RefCell;\\nimpl Solution {\\n    pub fn longest_zig_zag(root: Option<Rc<RefCell<TreeNode>>>) -> i32 {\\n        let mut max_len = 0;\\n        let mut stack = vec![(root, true, 0)];\\n        while let Some((node, is_left, len)) = stack.pop() {\\n            if let Some(node) = node {\\n                max_len = max_len.max(len);\\n                let &TreeNode { ref left, ref right, .. } = &*node.borrow();\\n                stack.push((left.as_ref().map(Rc::clone), true, if is_left { 1 } else { len + 1 }));\\n                stack.push((right.as_ref().map(Rc::clone), false, if is_left { len + 1 } else { 1 }));\\n            }\\n        }\\n        max_len\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nuse std::rc::Rc;\\nuse std::cell::RefCell;\\nimpl Solution {\\n    pub fn longest_zig_zag(root: Option<Rc<RefCell<TreeNode>>>) -> i32 {\\n        let mut max_len = 0;\\n        let mut stack = vec![(root, true, 0)];\\n        while let Some((node, is_left, len)) = stack.pop() {\\n            if let Some(node) = node {\\n                max_len = max_len.max(len);\\n                let &TreeNode { ref left, ref right, .. } = &*node.borrow();\\n                stack.push((left.as_ref().map(Rc::clone), true, if is_left { 1 } else { len + 1 }));\\n                stack.push((right.as_ref().map(Rc::clone), false, if is_left { len + 1 } else { 1 }));\\n            }\\n        }\\n        max_len\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3433226,
                "title": "easy-c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    int dfs(TreeNode* node, int dir, int len) {\\n        if (node == NULL) return len;\\n        int left = dfs(node->left, 1, (dir == 0 ? len + 1 : 0));\\n        int right = dfs(node->right, 0, (dir == 1 ? len + 1 : 0));\\n        return max(left, right);\\n    }\\n    \\n    int longestZigZag(TreeNode* root) {\\n        if (root == NULL) return 0;\\n        int left = dfs(root->left, 1, 0);\\n        int right = dfs(root->right, 0, 0);\\n        return max(left, right);\\n    }\\n};\\n\\n```\\nOther solution modified from the javascript code of comments\\n```\\nclass Solution {\\npublic:\\n    int getLength(TreeNode* root, bool flag, int& res) {\\n    if (root == nullptr) {\\n        return 0;\\n    }\\n    \\n    int left_path = getLength(root->left, true, res);\\n    int right_path = getLength(root->right, false, res);\\n    res = max(res, max(left_path, right_path));\\n    \\n    if (flag) {\\n        return 1 + right_path;\\n    } else {\\n        return 1 + left_path;\\n    }\\n}\\n\\nint longestZigZag(TreeNode* root) {\\n    int res = 0;\\n    getLength(root, true, res);\\n    getLength(root, false, res);\\n    return res;\\n}\\n\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Tree",
                    "Depth-First Search",
                    "Binary Tree"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    int dfs(TreeNode* node, int dir, int len) {\\n        if (node == NULL) return len;\\n        int left = dfs(node->left, 1, (dir == 0 ? len + 1 : 0));\\n        int right = dfs(node->right, 0, (dir == 1 ? len + 1 : 0));\\n        return max(left, right);\\n    }\\n    \\n    int longestZigZag(TreeNode* root) {\\n        if (root == NULL) return 0;\\n        int left = dfs(root->left, 1, 0);\\n        int right = dfs(root->right, 0, 0);\\n        return max(left, right);\\n    }\\n};\\n\\n```\n```\\nclass Solution {\\npublic:\\n    int getLength(TreeNode* root, bool flag, int& res) {\\n    if (root == nullptr) {\\n        return 0;\\n    }\\n    \\n    int left_path = getLength(root->left, true, res);\\n    int right_path = getLength(root->right, false, res);\\n    res = max(res, max(left_path, right_path));\\n    \\n    if (flag) {\\n        return 1 + right_path;\\n    } else {\\n        return 1 + left_path;\\n    }\\n}\\n\\nint longestZigZag(TreeNode* root) {\\n    int res = 0;\\n    getLength(root, true, res);\\n    getLength(root, false, res);\\n    return res;\\n}\\n\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3433044,
                "title": "python-readable-dfs-recursion",
                "content": "\\n# Code\\n```\\n# Definition for a binary tree node.\\n# class TreeNode(object):\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution(object):\\n    def longestZigZag(self, root):\\n        def dfsLeft(node, count):\\n            if not node:\\n                return count\\n            left, right = dfsLeft(node.left, 0), dfsRight(node.right, count + 1)\\n            return max(left, right)\\n            \\n        def dfsRight(node, count):\\n            if not node:\\n                return count\\n            left, right = dfsLeft(node.left, count + 1), dfsRight(node.right, 0)\\n            return max(left, right)\\n\\n        return max(dfsLeft(root.left, 0), dfsRight(root.right, 0))\\n```",
                "solutionTags": [
                    "Python",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```\\n# Definition for a binary tree node.\\n# class TreeNode(object):\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution(object):\\n    def longestZigZag(self, root):\\n        def dfsLeft(node, count):\\n            if not node:\\n                return count\\n            left, right = dfsLeft(node.left, 0), dfsRight(node.right, count + 1)\\n            return max(left, right)\\n            \\n        def dfsRight(node, count):\\n            if not node:\\n                return count\\n            left, right = dfsLeft(node.left, count + 1), dfsRight(node.right, 0)\\n            return max(left, right)\\n\\n        return max(dfsLeft(root.left, 0), dfsRight(root.right, 0))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3432953,
                "title": "daily-leetcoding-challenge-april-day-19",
                "content": "This problem is the Daily LeetCoding Challenge for April, Day 19.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/longest-zigzag-path-in-a-binary-tree/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 0 approach in the official solution</summary>\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>",
                "solutionTags": [],
                "code": "  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/longest-zigzag-path-in-a-binary-tree/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />",
                "codeTag": "Unknown"
            },
            {
                "id": 3310421,
                "title": "c-java-simple-dfs-solution",
                "content": "1. If the current node is a left child, \\n    - `dfs(node->right,currLen+1)` to continue the ZigZag path\\n    - `dfs(node->left,1)`- Start a new ZigZag path from current node (left direction)\\n2. If the current node is a right child,\\n    - `dfs(node->left,currLen+1)` to continue the ZigZag path\\n    - `dfs(node->right,1)` - Start a new ZigZag path from current node (right direction)\\n\\nSo we can do a DFS traversal from root in both directions and at each node update the maximum length of the path (edges in the path).\\n\\n```C++ []\\nclass Solution {\\n    public:\\n    int maxLength = 0;\\n\\n    void solve(TreeNode* root,int dir,int currLength){\\n        if(!root) return;\\n        maxLength = max(maxLength, currLength);\\n        // At each node, two choices\\n        // Continue the previous path in the alternate direction\\n        // Start a new path in the same direction\\n        solve(root->left, 0, (dir)? currLength+1 : 1);\\n        solve(root->right, 1, (dir)? 1 : currLength+1);\\n    }\\n\\n    int longestZigZag(TreeNode* root) {\\n        solve(root, 0, 0);\\n        solve(root, 1, 0);\\n        return maxLength;\\n    }\\n};\\n```\\n```Java []\\nclass Solution {\\n    public int maxLength=0;\\n    public void solve(TreeNode root,int dir,int currLength){\\n        if(root==null) return;\\n        maxLength=Math.max(maxLength,currLength);\\n        // At each node, two choices\\n        // Continue the previous path in the alternate direction\\n        // Start a new path in the same direction\\n        if(dir==1){\\n            solve(root.left,0,currLength+1);\\n            solve(root.right,1,1);\\n        }\\n        else{\\n            solve(root.right,1,currLength+1);\\n            solve(root.left,0,1);\\n        }\\n    }\\n\\n    public int longestZigZag(TreeNode root) {\\n        solve(root,0,0);\\n        solve(root,1,0);\\n        return maxLength;\\n    }\\n}\\n```\\n\\n# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Depth-First Search"
                ],
                "code": "```C++ []\\nclass Solution {\\n    public:\\n    int maxLength = 0;\\n\\n    void solve(TreeNode* root,int dir,int currLength){\\n        if(!root) return;\\n        maxLength = max(maxLength, currLength);\\n        // At each node, two choices\\n        // Continue the previous path in the alternate direction\\n        // Start a new path in the same direction\\n        solve(root->left, 0, (dir)? currLength+1 : 1);\\n        solve(root->right, 1, (dir)? 1 : currLength+1);\\n    }\\n\\n    int longestZigZag(TreeNode* root) {\\n        solve(root, 0, 0);\\n        solve(root, 1, 0);\\n        return maxLength;\\n    }\\n};\\n```\n```Java []\\nclass Solution {\\n    public int maxLength=0;\\n    public void solve(TreeNode root,int dir,int currLength){\\n        if(root==null) return;\\n        maxLength=Math.max(maxLength,currLength);\\n        // At each node, two choices\\n        // Continue the previous path in the alternate direction\\n        // Start a new path in the same direction\\n        if(dir==1){\\n            solve(root.left,0,currLength+1);\\n            solve(root.right,1,1);\\n        }\\n        else{\\n            solve(root.right,1,currLength+1);\\n            solve(root.left,0,1);\\n        }\\n    }\\n\\n    public int longestZigZag(TreeNode root) {\\n        solve(root,0,0);\\n        solve(root,1,0);\\n        return maxLength;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3070087,
                "title": "pyhon-easy-soultion-to-understand-with-explanation-beast-90",
                "content": "# Approach\\nWe want to cut zigzag. lets say we are the left son, when we want to get the lenght of left path of our right child(The opposite if we are the right son ).\\nSo for each node we call the same function to our childs. the base case is a None node and we return 0. After that we check which son are we and increase result based on the path lenght from the child.\\n\\nright[0] means go to the right child and give me the length of the left path.\\nleft[1] means go to the left child and give me the length of the right path.\\n\\n# Complexity\\n- Time complexity:\\nO(n): we are doing kind of a dfs scan , which is known for being O(n)\\n\\n- Space complexity:\\nO(1): we are not using any extra memory.\\n\\n# Code\\n```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def longestZigZag(self, root: Optional[TreeNode]) -> int:\\n\\n        result = 0\\n        def dfs(node,parent):\\n            nonlocal result \\n            if node is None:\\n                return (0,0)\\n            left = dfs(node.left,node)\\n            right = dfs(node.right,node)\\n            if parent.left==node\\n                result = max(result,right[0]+1)\\n            else:\\n                result = max(result,left[1]+1)\\n            return (left[1]+1,right[0]+1)\\n        dfs(root.left,root)\\n        dfs(root.right,root)\\n        return result\\n                \\n\\n\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Depth-First Search"
                ],
                "code": "```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def longestZigZag(self, root: Optional[TreeNode]) -> int:\\n\\n        result = 0\\n        def dfs(node,parent):\\n            nonlocal result \\n            if node is None:\\n                return (0,0)\\n            left = dfs(node.left,node)\\n            right = dfs(node.right,node)\\n            if parent.left==node\\n                result = max(result,right[0]+1)\\n            else:\\n                result = max(result,left[1]+1)\\n            return (left[1]+1,right[0]+1)\\n        dfs(root.left,root)\\n        dfs(root.right,root)\\n        return result\\n                \\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2688910,
                "title": "java-o-n-dp-solution-with-explanation-and-comments",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nIntuition 1 - We will do post order traversal as we want to use the results of the children stored in a DP natured map data structure.\\n\\nIntuition 2 - We will use 2 persistent variables namely a dp map and a MAX variable. that signify the following:\\n1. ***DP map*** -> Will store an int array of size 2 consisting of the max zigzag length if you start from this root in both left and right direction. Index 0 holds the left scenario and 1 holds the right scenario.\\n2. ***MAX*** -> used to calculate max length seen so far.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nAfter every postorder computation DP will hold <Key, Value> as <Current Node reference, Array[max distance from here if you go left, max distance from here if you go right]>\\n\\n# Complexity\\n- Time complexity: O(n) where n is the number of nodes as we go over every node just once\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n) as dp is the size of nodes as keys and values are constant of size 2\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    int MAX;\\n    Map<TreeNode, int []> dp;\\n    public int longestZigZag(TreeNode root) {\\n        \\n        //postorder traversal\\n        //Map stores left from node and right from node\\n        dp = new HashMap<>();\\n        dfs(root);\\n        return MAX;\\n    }\\n\\n    //returns max length from here if you go in a particular direction\\n    private void dfs(TreeNode root){\\n        if(root == null) return;\\n\\n        if(root.left == null && root.right == null){\\n            dp.put(root, new int[]{0,0});\\n            return;\\n        }\\n        //In dp value int []\\n        //index 0 represents left direction\\n        //index 1 represents right direction\\n        dfs(root.left);\\n        dfs(root.right);\\n\\n        int left = 0, right = 0;\\n\\n        if(dp.get(root.left) != null)\\n            left = 1 + dp.get(root.left)[1]; //we go right after left\\n        \\n        if(dp.get(root.right) != null)\\n            right = 1 + dp.get(root.right)[0]; //we go left after right\\n        dp.put(root, new int[]{left, right});\\n        MAX = Math.max(MAX, Math.max(left,right));\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming",
                    "Binary Search Tree"
                ],
                "code": "```\\nclass Solution {\\n    int MAX;\\n    Map<TreeNode, int []> dp;\\n    public int longestZigZag(TreeNode root) {\\n        \\n        //postorder traversal\\n        //Map stores left from node and right from node\\n        dp = new HashMap<>();\\n        dfs(root);\\n        return MAX;\\n    }\\n\\n    //returns max length from here if you go in a particular direction\\n    private void dfs(TreeNode root){\\n        if(root == null) return;\\n\\n        if(root.left == null && root.right == null){\\n            dp.put(root, new int[]{0,0});\\n            return;\\n        }\\n        //In dp value int []\\n        //index 0 represents left direction\\n        //index 1 represents right direction\\n        dfs(root.left);\\n        dfs(root.right);\\n\\n        int left = 0, right = 0;\\n\\n        if(dp.get(root.left) != null)\\n            left = 1 + dp.get(root.left)[1]; //we go right after left\\n        \\n        if(dp.get(root.right) != null)\\n            right = 1 + dp.get(root.right)[0]; //we go left after right\\n        dp.put(root, new int[]{left, right});\\n        MAX = Math.max(MAX, Math.max(left,right));\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2679946,
                "title": "c",
                "content": "Runtime: 125 ms, faster than 100.00% of C online submissions for Longest ZigZag Path in a Binary Tree.\\nMemory Usage: 53.5 MB, less than 28.57% of C online submissions for Longest ZigZag Path in a Binary Tree.\\n```\\ntypedef struct{\\n    int l;\\n    int r;\\n}Data;\\n\\nData process(struct TreeNode* root,int* max){\\n    Data ret;\\n    if(root == NULL){\\n        ret.l = -1;\\n        ret.r = -1;\\n        return ret;\\n    }\\n    Data dLTree = process(root->left, max);\\n    Data dRTree = process(root->right, max);\\n    \\n    ret.l = 1 + dRTree.r;\\n    ret.r = 1 + dLTree.l;\\n    *max  = fmax( fmax(ret.l, *max), ret.r);\\n    return ret;\\n}\\n\\nint longestZigZag(struct TreeNode* root){\\n    int max = 0;\\n    process(root, &max);\\n    return max;\\n}\\n```",
                "solutionTags": [
                    "Recursion"
                ],
                "code": "```\\ntypedef struct{\\n    int l;\\n    int r;\\n}Data;\\n\\nData process(struct TreeNode* root,int* max){\\n    Data ret;\\n    if(root == NULL){\\n        ret.l = -1;\\n        ret.r = -1;\\n        return ret;\\n    }\\n    Data dLTree = process(root->left, max);\\n    Data dRTree = process(root->right, max);\\n    \\n    ret.l = 1 + dRTree.r;\\n    ret.r = 1 + dLTree.l;\\n    *max  = fmax( fmax(ret.l, *max), ret.r);\\n    return ret;\\n}\\n\\nint longestZigZag(struct TreeNode* root){\\n    int max = 0;\\n    process(root, &max);\\n    return max;\\n}\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2609933,
                "title": "easy-js-beginner-solution",
                "content": "Theory:\\n\\n1. Longest zigzag path can either begin from \"left\" or \"right\" edge. Hence need to find max from these two.\\n2. When we are at root, we will start by saying that, we have taken hypothetical path \"l\" or \"r\" with length 0.\\n3. when we are at left node, we check whether the prev edge we took is \"r\". If yes increase the path length. else we need to start new journey from here because Left - > Left is not zigzag.\\n4. Similarly when we are at right node we check if the prev edge we took is \"l\". If yes, our zigzag path will increase by one. If not, then new journey will start from here because Right -> Right path is not zigzag. \\n\\n```\\nvar longestZigZag = function(root) {\\n    let max = 0;\\n    \\n    const helper = (node, prev, length) => {\\n    \\n        if(node === null)\\n            return null;\\n        \\n        max = Math.max(max, length);\\n        \\n        helper(node.left, \"l\" , prev === \"r\" ? length + 1 : 1);\\n        helper(node.right, \"r\" , prev === \"l\" ? length + 1 : 1);\\n    }\\n    \\n    \\n    helper(root, \"l\", 0); \\n    helper(root, \"r\", 0);\\n    \\n    return max;\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Depth-First Search"
                ],
                "code": "```\\nvar longestZigZag = function(root) {\\n    let max = 0;\\n    \\n    const helper = (node, prev, length) => {\\n    \\n        if(node === null)\\n            return null;\\n        \\n        max = Math.max(max, length);\\n        \\n        helper(node.left, \"l\" , prev === \"r\" ? length + 1 : 1);\\n        helper(node.right, \"r\" , prev === \"l\" ? length + 1 : 1);\\n    }\\n    \\n    \\n    helper(root, \"l\", 0); \\n    helper(root, \"r\", 0);\\n    \\n    return max;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2559539,
                "title": "python3-iterative-dfs-using-stack-99-time-91-space-o-n-time-o-n-space",
                "content": "Initialize stack with root.left and root.right because the direction when entering the root node is undefined. If you do double left or double right, restart the count.\\n```\\nclass Solution:\\n    def longestZigZag(self, root: Optional[TreeNode]) -> int:\\n        \\n        LEFT = 0\\n        RIGHT = 1\\n            \\n        stack = []\\n        if root.left:\\n            stack.append((root.left, LEFT, 1))\\n        if root.right:\\n            stack.append((root.right, RIGHT, 1))\\n            \\n        longest = 0\\n        while stack:\\n            node, direction, count = stack.pop()\\n            \\n            longest = max(longest, count)\\n            if direction == LEFT:\\n                if node.left:\\n                    stack.append((node.left, LEFT, 1))\\n                if node.right:\\n                    stack.append((node.right, RIGHT, count+1))\\n            else:\\n                if node.right:\\n                    stack.append((node.right, RIGHT, 1))\\n                if node.left:\\n                    stack.append((node.left, LEFT, count+1))\\n        return longest\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Stack",
                    "Depth-First Search",
                    "Iterator"
                ],
                "code": "```\\nclass Solution:\\n    def longestZigZag(self, root: Optional[TreeNode]) -> int:\\n        \\n        LEFT = 0\\n        RIGHT = 1\\n            \\n        stack = []\\n        if root.left:\\n            stack.append((root.left, LEFT, 1))\\n        if root.right:\\n            stack.append((root.right, RIGHT, 1))\\n            \\n        longest = 0\\n        while stack:\\n            node, direction, count = stack.pop()\\n            \\n            longest = max(longest, count)\\n            if direction == LEFT:\\n                if node.left:\\n                    stack.append((node.left, LEFT, 1))\\n                if node.right:\\n                    stack.append((node.right, RIGHT, count+1))\\n            else:\\n                if node.right:\\n                    stack.append((node.right, RIGHT, 1))\\n                if node.left:\\n                    stack.append((node.left, LEFT, count+1))\\n        return longest\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2436026,
                "title": "o-n-recursion-5-line-c-code",
                "content": "```\\nint zigzag(TreeNode* root, int dir, int val){\\n        if(root==NULL) return val;\\n        return dir==-1? max(zigzag(root->right,1,val+1),zigzag(root->left,-1,0)) : max(zigzag(root->left,-1,val+1),zigzag(root->right,1,0));\\n    }   \\n    int longestZigZag(TreeNode* root) {\\n        return max(zigzag(root->left,-1,0),zigzag(root->right,1,0));\\n    }\\n```",
                "solutionTags": [
                    "Tree",
                    "Recursion"
                ],
                "code": "```\\nint zigzag(TreeNode* root, int dir, int val){\\n        if(root==NULL) return val;\\n        return dir==-1? max(zigzag(root->right,1,val+1),zigzag(root->left,-1,0)) : max(zigzag(root->left,-1,val+1),zigzag(root->right,1,0));\\n    }   \\n    int longestZigZag(TreeNode* root) {\\n        return max(zigzag(root->left,-1,0),zigzag(root->right,1,0));\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2126462,
                "title": "java-solution-with-comments-and-clean-code",
                "content": "```\\nclass Solution {\\n\\n    int ans = 0;    //global variable ans to store and compare longest path\\n    \\n    public int longestZigZag(TreeNode root) {\\n\\t\\n\\t\\t//to keep a record of previous traversal boolean flag is used \\n        pathFinder(root.left,true,0);       //from root to left and then to right so flag is true\\n        pathFinder(root.right,false,0);     //from root to right and then  to left so flag is false\\n        return ans;\\n    }\\n    \\n    public void pathFinder(TreeNode root, boolean flag, int sum){\\n\\t\\n\\t\\t//base condition\\n        if(root==null){\\n            ans = Math.max(ans,sum);\\n            return;\\n        }\\n        \\n\\t\\t//true means we have to go right.\\n        if(flag){\\n            pathFinder(root.right,false,sum+1);  //recursive call for root.right\\n            pathFinder(root.left,true,0);        //but there can be new ZigZag path from root.left\\n        }\\n        else{\\n\\t\\t\\t//we have to go left\\n            pathFinder(root.left,true,sum+1);  //recursive call for root.left\\n            pathFinder(root.right,false,0);    //but there can be new ZigZag path from root.left\\n        }\\n    }\\n    \\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n\\n    int ans = 0;    //global variable ans to store and compare longest path\\n    \\n    public int longestZigZag(TreeNode root) {\\n\\t\\n\\t\\t//to keep a record of previous traversal boolean flag is used \\n        pathFinder(root.left,true,0);       //from root to left and then to right so flag is true\\n        pathFinder(root.right,false,0);     //from root to right and then  to left so flag is false\\n        return ans;\\n    }\\n    \\n    public void pathFinder(TreeNode root, boolean flag, int sum){\\n\\t\\n\\t\\t//base condition\\n        if(root==null){\\n            ans = Math.max(ans,sum);\\n            return;\\n        }\\n        \\n\\t\\t//true means we have to go right.\\n        if(flag){\\n            pathFinder(root.right,false,sum+1);  //recursive call for root.right\\n            pathFinder(root.left,true,0);        //but there can be new ZigZag path from root.left\\n        }\\n        else{\\n\\t\\t\\t//we have to go left\\n            pathFinder(root.left,true,sum+1);  //recursive call for root.left\\n            pathFinder(root.right,false,0);    //but there can be new ZigZag path from root.left\\n        }\\n    }\\n    \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1806903,
                "title": "c-dfs-super-simple-o-n-and-o-1",
                "content": "We use 2 variables pleft and pright which contain the length of longest zigzag path ending at the current node given the current node is a left child or a right child of its parent respectively.\\nIf the current node has a right child, the length of zigzag path ending with this right child will be pleft+1. Similarly for the case when the current node has a left child.\\n```\\nclass Solution {\\npublic:\\n    int ans=0;\\n    void dfs(TreeNode* root, int pleft, int pright){\\n        if(root==NULL) return ;\\n        if(root->right){\\n            ans = max(ans, pleft+1);\\n            fun(root->right, 0, pleft+1); //pright of the right child is the new lenght of zigzag path = pleft+1\\n        }\\n        if(root->left){\\n            ans = max(ans, pright+1);\\n            fun(root->left, pright+1, 0);\\n            \\n        }\\n    }\\n    int longestZigZag(TreeNode* root) {\\n        dfs(root, 0, 0);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int ans=0;\\n    void dfs(TreeNode* root, int pleft, int pright){\\n        if(root==NULL) return ;\\n        if(root->right){\\n            ans = max(ans, pleft+1);\\n            fun(root->right, 0, pleft+1); //pright of the right child is the new lenght of zigzag path = pleft+1\\n        }\\n        if(root->left){\\n            ans = max(ans, pright+1);\\n            fun(root->left, pright+1, 0);\\n            \\n        }\\n    }\\n    int longestZigZag(TreeNode* root) {\\n        dfs(root, 0, 0);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1791746,
                "title": "java-dfs-clean-easy-to-understand-with-explanation-solution-o-n",
                "content": "```\\nprivate enum Direction {\\n\\tRIGHT, LEFT;\\n}\\n\\npublic int longestZigZag(TreeNode root) {\\n\\treturn dfs(root, 0, null); // Start from the root no directions yet\\n}\\n\\nprivate int dfs(TreeNode node, int sum, Direction dir) {\\n\\tif (node == null) return sum - 1; // If the cur node is null just remove the plus 1 from sum\\n\\t// When going to a node if we are coming from the same direction than we would need to reset the sum to 1\\n\\tint left = dfs(node.left, dir == Direction.LEFT ? 1 : sum + 1, Direction.LEFT);\\n\\tint right = dfs(node.right, dir == Direction.RIGHT ? 1 : sum + 1, Direction.RIGHT);\\n\\n\\treturn Math.max(left, right); // Return the maximum of the left and the right\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Depth-First Search"
                ],
                "code": "```\\nprivate enum Direction {\\n\\tRIGHT, LEFT;\\n}\\n\\npublic int longestZigZag(TreeNode root) {\\n\\treturn dfs(root, 0, null); // Start from the root no directions yet\\n}\\n\\nprivate int dfs(TreeNode node, int sum, Direction dir) {\\n\\tif (node == null) return sum - 1; // If the cur node is null just remove the plus 1 from sum\\n\\t// When going to a node if we are coming from the same direction than we would need to reset the sum to 1\\n\\tint left = dfs(node.left, dir == Direction.LEFT ? 1 : sum + 1, Direction.LEFT);\\n\\tint right = dfs(node.right, dir == Direction.RIGHT ? 1 : sum + 1, Direction.RIGHT);\\n\\n\\treturn Math.max(left, right); // Return the maximum of the left and the right\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1766450,
                "title": "java-simple-approach-explained-with-comments",
                "content": "```\\nclass Solution {\\n   int max = 0;\\n\\n\\tpublic int longestZigZag(TreeNode root) {\\n\\t\\tif (root == null)\\n\\t\\t\\treturn 0;\\n        // start with depth (indicates count of nodes in zigzag path sofar) zero in both directions\\n\\t\\tpath(root.left, 0, false);\\n\\t\\tpath(root.right, 0, true);\\n        // return max zigzag path found\\n\\t\\treturn max;\\n\\t}\\n\\n\\t//using boolean value direction: false-left true-right\\n\\tpublic void path(TreeNode node, int depth, boolean direction) {\\n        // capture max depth of zigzag path captured sofar in global variable max\\n\\t\\tmax = Math.max(max, depth);\\n\\t\\tif (node == null)\\n\\t\\t\\treturn;\\n        // if previous direction is right(i.e direction is true) and we r heading towards left increment depth+1 as it counts towards valid zigzag path\\n\\t\\totherwise its important that we need to reset because current zigzag path breaks here and we need to start again to see if there is any other zigzag path from this node.\\n\\t\\tpath(node.left, direction ? depth + 1 : 0, false);\\n        // likewise if previous zigzag path is left(i.e direction is false) and we r heading towards right increment depth+1 is it counts towards valid zigzag path \\n\\t\\totherwise reset current count sofar and start again from here\\n\\t\\tpath(node.right, !direction ? depth + 1 : 0, true);\\n\\t}\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n   int max = 0;\\n\\n\\tpublic int longestZigZag(TreeNode root) {\\n\\t\\tif (root == null)\\n\\t\\t\\treturn 0;\\n        // start with depth (indicates count of nodes in zigzag path sofar) zero in both directions\\n\\t\\tpath(root.left, 0, false);\\n\\t\\tpath(root.right, 0, true);\\n        // return max zigzag path found\\n\\t\\treturn max;\\n\\t}\\n\\n\\t//using boolean value direction: false-left true-right\\n\\tpublic void path(TreeNode node, int depth, boolean direction) {\\n        // capture max depth of zigzag path captured sofar in global variable max\\n\\t\\tmax = Math.max(max, depth);\\n\\t\\tif (node == null)\\n\\t\\t\\treturn;\\n        // if previous direction is right(i.e direction is true) and we r heading towards left increment depth+1 as it counts towards valid zigzag path\\n\\t\\totherwise its important that we need to reset because current zigzag path breaks here and we need to start again to see if there is any other zigzag path from this node.\\n\\t\\tpath(node.left, direction ? depth + 1 : 0, false);\\n        // likewise if previous zigzag path is left(i.e direction is false) and we r heading towards right increment depth+1 is it counts towards valid zigzag path \\n\\t\\totherwise reset current count sofar and start again from here\\n\\t\\tpath(node.right, !direction ? depth + 1 : 0, true);\\n\\t}\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1713560,
                "title": "c-simple-dfs-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int ans = 0;\\n    \\n    int dfs(TreeNode* node, bool isLeftChild = true){\\n        if (node == nullptr) return -1;\\n        \\n        int left = dfs(node -> left, true) + 1;\\n        int right = dfs(node -> right, false) + 1;\\n        \\n        ans = max(ans, max(left, right));\\n        return (isLeftChild) ? right : left;\\n    }\\n    \\n    int longestZigZag(TreeNode* root) {\\n        dfs(root); //root has no father, therefore it could be either true or false\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int ans = 0;\\n    \\n    int dfs(TreeNode* node, bool isLeftChild = true){\\n        if (node == nullptr) return -1;\\n        \\n        int left = dfs(node -> left, true) + 1;\\n        int right = dfs(node -> right, false) + 1;\\n        \\n        ans = max(ans, max(left, right));\\n        return (isLeftChild) ? right : left;\\n    }\\n    \\n    int longestZigZag(TreeNode* root) {\\n        dfs(root); //root has no father, therefore it could be either true or false\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1637424,
                "title": "c",
                "content": "```\\n    //0->left\\n    //1->right\\n    int a = 0;\\n    int b = 0;\\n    map<pair<TreeNode*,bool>,int> mp;\\n    int solve(TreeNode* root, bool flag){\\n        if (root==NULL){\\n            return -1;\\n        }\\n        \\n        if (mp.find({root,flag})!=mp.end()){\\n            return mp[{root,flag}];\\n        }\\n        if (flag==0){\\n            return mp[{root,flag}]=1+solve(root->right,1);\\n        }\\n        else{\\n            return mp[{root,flag}]=1+solve(root->left,0);\\n        }\\n    }\\n    void dfs(TreeNode* root){\\n        if (root==NULL){\\n            return;\\n        }\\n        a  = max(a,solve(root,0));\\n        b = max(b,solve(root,1));\\n        dfs(root->left);\\n        dfs(root->right);\\n    }\\n    int longestZigZag(TreeNode* root) {\\n        dfs(root);\\n       \\n        return max(a,b);\\n    }\\n};",
                "solutionTags": [
                    "Memoization"
                ],
                "code": "```\\n    //0->left\\n    //1->right\\n    int a = 0;\\n    int b = 0;\\n    map<pair<TreeNode*,bool>,int> mp;\\n    int solve(TreeNode* root, bool flag){\\n        if (root==NULL){\\n            return -1;\\n        }\\n        \\n        if (mp.find({root,flag})!=mp.end()){\\n            return mp[{root,flag}];\\n        }\\n        if (flag==0){\\n            return mp[{root,flag}]=1+solve(root->right,1);\\n        }\\n        else{\\n            return mp[{root,flag}]=1+solve(root->left,0);\\n        }\\n    }\\n    void dfs(TreeNode* root){\\n        if (root==NULL){\\n            return;\\n        }\\n        a  = max(a,solve(root,0));\\n        b = max(b,solve(root,1));\\n        dfs(root->left);\\n        dfs(root->right);\\n    }\\n    int longestZigZag(TreeNode* root) {\\n        dfs(root);\\n       \\n        return max(a,b);\\n    }\\n};",
                "codeTag": "Unknown"
            },
            {
                "id": 1495111,
                "title": "c-inorder-traversal",
                "content": "```\\n \\nclass Solution {\\npublic:\\n    int ans;\\n    \\n    void inorder(TreeNode* root,bool dir,int len){\\n        \\n        if(root==NULL) return ;\\n         \\n        ans=max(ans,len);\\n        if(dir==0){\\n            inorder(root->left,1,len+1);\\n            inorder(root->right,0,1);\\n        }\\n        else{\\n             inorder(root->right,0,len+1);\\n             inorder(root->left,1,1);\\n        }\\n         \\n        return ;\\n       } \\n    \\n    int longestZigZag(TreeNode* root) {\\n        ans=0;\\n         inorder(root->left,1, 1);\\n         inorder(root->right,0, 1);\\n        \\n        return ans ;\\n    }\\n};\\n```\\n\\n\\n\\n\\n```\\nclass Solution {\\npublic:\\n    \\n    int ans=0; \\n    \\n    pair<int,int>  dfs(TreeNode* root){\\n        \\n        if(!root)  return {-1,-1};\\n        \\n        auto [l1,l2]= dfs(root->left);\\n        auto [r1,r2]= dfs(root->right);\\n         \\n        ans=max({ans,l2+1,r1+1});\\n        \\n        return {l2+1,r1+1};  \\n        \\n    }\\n      \\n    int longestZigZag(TreeNode* root) {\\n        \\n        dfs(root); \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Depth-First Search"
                ],
                "code": "```\\n \\nclass Solution {\\npublic:\\n    int ans;\\n    \\n    void inorder(TreeNode* root,bool dir,int len){\\n        \\n        if(root==NULL) return ;\\n         \\n        ans=max(ans,len);\\n        if(dir==0){\\n            inorder(root->left,1,len+1);\\n            inorder(root->right,0,1);\\n        }\\n        else{\\n             inorder(root->right,0,len+1);\\n             inorder(root->left,1,1);\\n        }\\n         \\n        return ;\\n       } \\n    \\n    int longestZigZag(TreeNode* root) {\\n        ans=0;\\n         inorder(root->left,1, 1);\\n         inorder(root->right,0, 1);\\n        \\n        return ans ;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    \\n    int ans=0; \\n    \\n    pair<int,int>  dfs(TreeNode* root){\\n        \\n        if(!root)  return {-1,-1};\\n        \\n        auto [l1,l2]= dfs(root->left);\\n        auto [r1,r2]= dfs(root->right);\\n         \\n        ans=max({ans,l2+1,r1+1});\\n        \\n        return {l2+1,r1+1};  \\n        \\n    }\\n      \\n    int longestZigZag(TreeNode* root) {\\n        \\n        dfs(root); \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1447927,
                "title": "simple-recursion-in-c",
                "content": "```\\n\\nclass Solution {\\npublic:\\n    int max_val=0;\\n    int fun(TreeNode* temp,bool isLeft)\\n    {\\n        if(!temp) return 0;\\n        int l = fun(temp->left,0);\\n        int r = fun(temp->right,1);\\n        max_val = max({max_val,l,r});\\n        return 1+(isLeft?l:r);\\n    }\\n    int longestZigZag(TreeNode* root) {\\n        fun(root,0);\\n        return max_val;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n\\nclass Solution {\\npublic:\\n    int max_val=0;\\n    int fun(TreeNode* temp,bool isLeft)\\n    {\\n        if(!temp) return 0;\\n        int l = fun(temp->left,0);\\n        int r = fun(temp->right,1);\\n        max_val = max({max_val,l,r});\\n        return 1+(isLeft?l:r);\\n    }\\n    int longestZigZag(TreeNode* root) {\\n        fun(root,0);\\n        return max_val;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1344683,
                "title": "dp-dfs-java-thinking-in-terms-of-subproblems",
                "content": "This solution is not a clever solution, but it shows how to think in terms of subproblems and thinking about what choices do you have at each subproblem. Always start with the base case and your initial caller because they give clues as to what your choices are. \\n\\nThe way I thought about it was: `If I\\'m at the root, then what is the longest chain I can make? I don\\'t know, so I will check my left and right`. Then I saw in the example that the longest zigzag does not necessarily need to originate from the root. That means `the longest zigzag can originate from any node`. At every node, I can choose to extend my current chain, OR I can try to act as the root of the chain. I don\\'t know which is better, so I try both of them in the recursion. If I am extending, I add 1 to the length to the next call. If I am acting as the root of the chain, the chain length is now only 1 for the next caller.\\n```\\nclass Solution {\\n  private static final int LEFT = 0;\\n  private static final int RIGHT = 1;\\n  int max = 0;\\n  public int longestZigZag(TreeNode root) {\\n    Set<TreeNode> dp = new HashSet<>();\\n    traverse(root.left, LEFT, 1, dp);\\n    traverse(root.right, RIGHT, 1, dp);\\n    return max;\\n  }\\n  \\n  public void traverse(TreeNode root, int prevDir, int length, Set<TreeNode> dp) {\\n    if(root == null) return;\\n    if(dp.contains(root)) return;\\n    \\n    // extend\\n    if(prevDir == LEFT) {\\n      traverse(root.right, RIGHT, length+1, dp);\\n    } else {\\n      traverse(root.left, LEFT, length+1, dp); \\n    }\\n    \\n    // act as source\\n    traverse(root.left, LEFT, 1, dp);\\n    traverse(root.right, RIGHT, 1, dp);\\n    max = Math.max(max, length);\\n    dp.add(root);\\n  }\\n}\\n```\\n\\nUpvote if this helped you \\uD83D\\uDC4D",
                "solutionTags": [
                    "Dynamic Programming",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\n  private static final int LEFT = 0;\\n  private static final int RIGHT = 1;\\n  int max = 0;\\n  public int longestZigZag(TreeNode root) {\\n    Set<TreeNode> dp = new HashSet<>();\\n    traverse(root.left, LEFT, 1, dp);\\n    traverse(root.right, RIGHT, 1, dp);\\n    return max;\\n  }\\n  \\n  public void traverse(TreeNode root, int prevDir, int length, Set<TreeNode> dp) {\\n    if(root == null) return;\\n    if(dp.contains(root)) return;\\n    \\n    // extend\\n    if(prevDir == LEFT) {\\n      traverse(root.right, RIGHT, length+1, dp);\\n    } else {\\n      traverse(root.left, LEFT, length+1, dp); \\n    }\\n    \\n    // act as source\\n    traverse(root.left, LEFT, 1, dp);\\n    traverse(root.right, RIGHT, 1, dp);\\n    max = Math.max(max, length);\\n    dp.add(root);\\n  }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1278621,
                "title": "c-short-and-simple-dfs-solution",
                "content": "```\\nint solve(TreeNode* root, bool isRightChild, int &ans) {\\n\\tif(!root) return 0;\\n\\tint l = solve(root->left, false, ans);\\n\\tint r = solve(root->right, true, ans);\\n\\tans = max(ans, max(l, r) + 1);\\n\\treturn isRightChild ? l+1 : r+1;\\n}\\n\\nint longestZigZag(TreeNode* root) {\\n\\tint ans = 0;\\n\\tsolve(root, false, ans);\\n\\treturn ans - 1;\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nint solve(TreeNode* root, bool isRightChild, int &ans) {\\n\\tif(!root) return 0;\\n\\tint l = solve(root->left, false, ans);\\n\\tint r = solve(root->right, true, ans);\\n\\tans = max(ans, max(l, r) + 1);\\n\\treturn isRightChild ? l+1 : r+1;\\n}\\n\\nint longestZigZag(TreeNode* root) {\\n\\tint ans = 0;\\n\\tsolve(root, false, ans);\\n\\treturn ans - 1;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 764324,
                "title": "easy-java-dfs",
                "content": "```\\nclass Solution {    \\n    public int longestZigZag(TreeNode root) {\\n        return Math.max(dfs(root, true, -1), dfs(root, false, -1));\\n    }\\n    \\n    int dfs(TreeNode node, boolean toLeft, int path) {\\n        if (node == null) {\\n            return path;\\n        }\\n        int ans = -1;\\n        if (toLeft) {\\n            ans = dfs(node.left, false, path + 1);\\n            ans = Math.max(ans, dfs(node.right, true, 0));\\n        } else {\\n            ans = dfs(node.right, true, path + 1);\\n            ans = Math.max(ans, dfs(node.left, false, 0));\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {    \\n    public int longestZigZag(TreeNode root) {\\n        return Math.max(dfs(root, true, -1), dfs(root, false, -1));\\n    }\\n    \\n    int dfs(TreeNode node, boolean toLeft, int path) {\\n        if (node == null) {\\n            return path;\\n        }\\n        int ans = -1;\\n        if (toLeft) {\\n            ans = dfs(node.left, false, path + 1);\\n            ans = Math.max(ans, dfs(node.right, true, 0));\\n        } else {\\n            ans = dfs(node.right, true, path + 1);\\n            ans = Math.max(ans, dfs(node.left, false, 0));\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 726933,
                "title": "python3-clean-bfs-solution-using-deque",
                "content": "I am using a deque for BFS in python.\\nThe node of the BFS will be **{curr_node, state(can be \\'L\\' or \\'R\\'), longestdistance}** where longest distance = longest zigzag distance so far.\\n\\nNow if your current state is \\'L\\' and a right child exist for the current node, we will extend the current longest distance by 1 (same case for state \\'R\\' and existence of a left child)\\n\\n```\\nfrom collections import deque\\n    def longestZigZag(self, root: TreeNode) -> int:\\n        # dequeu node : [curr_node, state, longestdistance]\\n        ans = 0\\n        q = deque([[root, \\'A\\', 0]])\\n        while (len(q) != 0):\\n            top, state, dist = q[0]\\n            ans = max(ans, dist)\\n            q.popleft()\\n            if state == \\'A\\':\\n                if top.left:\\n                    q.append([top.left, \\'L\\', 1])\\n                if top.right:\\n                    q.append([top.right, \\'R\\', 1])\\n            else:\\n                if state == \\'L\\':\\n                    if top.left:\\n                        q.append([top.left, \\'L\\', 1])\\n                    if top.right:\\n                        q.append([top.right, \\'R\\', dist+1])\\n                if state == \\'R\\':\\n                    if top.left:\\n                        q.append([top.left, \\'L\\', dist+1])\\n                    if top.right:\\n                        q.append([top.right, \\'R\\', 1])\\n        return ans\\n```",
                "solutionTags": [
                    "Python3",
                    "Breadth-First Search"
                ],
                "code": "```\\nfrom collections import deque\\n    def longestZigZag(self, root: TreeNode) -> int:\\n        # dequeu node : [curr_node, state, longestdistance]\\n        ans = 0\\n        q = deque([[root, \\'A\\', 0]])\\n        while (len(q) != 0):\\n            top, state, dist = q[0]\\n            ans = max(ans, dist)\\n            q.popleft()\\n            if state == \\'A\\':\\n                if top.left:\\n                    q.append([top.left, \\'L\\', 1])\\n                if top.right:\\n                    q.append([top.right, \\'R\\', 1])\\n            else:\\n                if state == \\'L\\':\\n                    if top.left:\\n                        q.append([top.left, \\'L\\', 1])\\n                    if top.right:\\n                        q.append([top.right, \\'R\\', dist+1])\\n                if state == \\'R\\':\\n                    if top.left:\\n                        q.append([top.left, \\'L\\', dist+1])\\n                    if top.right:\\n                        q.append([top.right, \\'R\\', 1])\\n        return ans\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 713022,
                "title": "java-top-down-easy-clean-solution-o-n",
                "content": "We follow a top down approach. \\nWe keep track of : \\n1. The direction we came from .\\n2. The distance of zig zag path till now.  If its a LL, RR combo, we start as new and take as the distance to be zero.\\n\\n```\\n  int gl;\\n    public int longestZigZag(TreeNode root) {\\n        if(root == null || root.left == null && root.right == null)return 0;\\n        helper(root.left,0,0);\\n        helper(root.right,1,0);\\n        return gl+1;\\n    }\\n    void helper(TreeNode root,int d,int distTillNow){\\n        if(root == null)return;\\n        gl = Math.max(distTillNow,gl);\\n     \\n        helper(root.left,0,d == 0 ? 0 : distTillNow+1);\\n        helper(root.right,1,d == 1 ? 0 : distTillNow+1);\\n    }\\n\\t\\n\\t",
                "solutionTags": [],
                "code": "We follow a top down approach. \\nWe keep track of : \\n1. The direction we came from .\\n2. The distance of zig zag path till now.  If its a LL, RR combo, we start as new and take as the distance to be zero.\\n\\n```\\n  int gl;\\n    public int longestZigZag(TreeNode root) {\\n        if(root == null || root.left == null && root.right == null)return 0;\\n        helper(root.left,0,0);\\n        helper(root.right,1,0);\\n        return gl+1;\\n    }\\n    void helper(TreeNode root,int d,int distTillNow){\\n        if(root == null)return;\\n        gl = Math.max(distTillNow,gl);\\n     \\n        helper(root.left,0,d == 0 ? 0 : distTillNow+1);\\n        helper(root.right,1,d == 1 ? 0 : distTillNow+1);\\n    }\\n\\t\\n\\t",
                "codeTag": "Unknown"
            },
            {
                "id": 614941,
                "title": "simple-recursion-c",
                "content": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    void fun(TreeNode* root,int l,int r,int &ans,int cur){\\n        if(root==NULL) return;\\n        if(root->left==NULL && root->right==NULL){\\n            ans=max(ans,cur);\\n            return;\\n        }\\n        if(l){\\n            ans=max(ans,cur);\\n            fun(root->left,1,0,ans,1);\\n            fun(root->right,0,1,ans,cur+1);\\n        }\\n        else if(r){\\n            ans=max(ans,cur);\\n            fun(root->right,0,1,ans,1);\\n            fun(root->left,1,0,ans,cur+1);\\n        }\\n        return;\\n    }\\n    int longestZigZag(TreeNode* root) {\\n        if(!root) return 0;\\n        int re=0,an=0;\\n        fun(root->left,1,0,an,re+1);\\n        fun(root->right,0,1,an,re+1);\\n        return an;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    void fun(TreeNode* root,int l,int r,int &ans,int cur){\\n        if(root==NULL) return;\\n        if(root->left==NULL && root->right==NULL){\\n            ans=max(ans,cur);\\n            return;\\n        }\\n        if(l){\\n            ans=max(ans,cur);\\n            fun(root->left,1,0,ans,1);\\n            fun(root->right,0,1,ans,cur+1);\\n        }\\n        else if(r){\\n            ans=max(ans,cur);\\n            fun(root->right,0,1,ans,1);\\n            fun(root->left,1,0,ans,cur+1);\\n        }\\n        return;\\n    }\\n    int longestZigZag(TreeNode* root) {\\n        if(!root) return 0;\\n        int re=0,an=0;\\n        fun(root->left,1,0,an,re+1);\\n        fun(root->right,0,1,an,re+1);\\n        return an;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 531828,
                "title": "java-dfs-keep-a-parameter-for-direction",
                "content": "```\\nclass Solution {\\n    static int max = 0;\\n    public static void dfs(TreeNode root, int prev, int curr) {\\n        max = Math.max(max, curr);\\n        if(root == null) return;\\n        if(prev == 1) {\\n            dfs(root.left, -1, curr + 1);\\n            dfs(root.right, 1, 0);\\n            return;\\n        } else if(prev == 0) {\\n            dfs(root.left, -1, 0);\\n            dfs(root.right, 1, 0);\\n            return;\\n        } else {\\n            dfs(root.left, -1, 0);\\n            dfs(root.right, 1, curr + 1);\\n            return;\\n        }\\n    }\\n    public int longestZigZag(TreeNode root) {\\n        max = 0;\\n        dfs(root, 0, 0);\\n        return max;\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    static int max = 0;\\n    public static void dfs(TreeNode root, int prev, int curr) {\\n        max = Math.max(max, curr);\\n        if(root == null) return;\\n        if(prev == 1) {\\n            dfs(root.left, -1, curr + 1);\\n            dfs(root.right, 1, 0);\\n            return;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 531806,
                "title": "c-recursion",
                "content": "```cpp\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    int zz(TreeNode* root, bool dir) {\\n        if (!root) return -1;\\n        return 1 + (dir ? zz(root->left, !dir) : zz(root->right, !dir));\\n    }\\n    \\n    int longestZigZag(TreeNode* root, int mark=0) {\\n        if (!root) return 0;\\n\\t\\t// we only need to go both left and right in the first step\\n\\t\\t// if we go to left, we ignore the right branch of the left node since it is already checked in the previous zig-zag\\n\\t\\t// if we go to right, we ignore the left branch of the right node since it is already checked in the previous zig-zag\\n        return  max(max(mark >= 0 ? zz(root, true) : 0, mark <= 0 ? zz(root, false) : 0),\\n                    max(longestZigZag(root->left, 1), longestZigZag(root->right, -1)));\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```cpp\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    int zz(TreeNode* root, bool dir) {\\n        if (!root) return -1;\\n        return 1 + (dir ? zz(root->left, !dir) : zz(root->right, !dir));\\n    }\\n    \\n    int longestZigZag(TreeNode* root, int mark=0) {\\n        if (!root) return 0;\\n\\t\\t// we only need to go both left and right in the first step\\n\\t\\t// if we go to left, we ignore the right branch of the left node since it is already checked in the previous zig-zag\\n\\t\\t// if we go to right, we ignore the left branch of the right node since it is already checked in the previous zig-zag\\n        return  max(max(mark >= 0 ? zz(root, true) : 0, mark <= 0 ? zz(root, false) : 0),\\n                    max(longestZigZag(root->left, 1), longestZigZag(root->right, -1)));\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4058328,
                "title": "c-beats-99-simple-recursion",
                "content": "# Intuition\\nAt each Node in the tree, you have the option to continue the pattern and go right/left accordingly or start a new path with length 1 to the opposing direction.\\n\\n# Approach\\n- The `length` argument is passed by value, and at any point in the recursion stack will contain the current maximum length of zigzag pattern.\\n- We don\\'t need to compare the recursive call answers, so just the maximum `length` at any point contains the answer.\\n- We need to start the recursion call from both left and right at the root.\\n\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(n): All nodes are visited once as the recursive call structure is unique.\\n\\n# Code\\n```\\n\\nclass Solution {\\npublic:\\n    int ans = -1;\\n    // 0 is left, 1 is right\\n    void _getLongestPath(TreeNode* curr, int direction, int length) {\\n        if(!curr) return;\\n        if(direction == 0) {\\n            _getLongestPath(curr->right, 1, length+1);\\n            _getLongestPath(curr->left, 0, 1);\\n        }\\n        else {\\n            _getLongestPath(curr->left, 0, length+1);\\n            _getLongestPath(curr->right, 1, 1);\\n        }\\n        ans = max(ans, length);\\n    }\\n\\n\\n    int longestZigZag(TreeNode* root) {\\n        unordered_map<TreeNode*, int> dp;\\n        _getLongestPath(root, 0, 0);\\n        _getLongestPath(root, 1, 0);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n\\nclass Solution {\\npublic:\\n    int ans = -1;\\n    // 0 is left, 1 is right\\n    void _getLongestPath(TreeNode* curr, int direction, int length) {\\n        if(!curr) return;\\n        if(direction == 0) {\\n            _getLongestPath(curr->right, 1, length+1);\\n            _getLongestPath(curr->left, 0, 1);\\n        }\\n        else {\\n            _getLongestPath(curr->left, 0, length+1);\\n            _getLongestPath(curr->right, 1, 1);\\n        }\\n        ans = max(ans, length);\\n    }\\n\\n\\n    int longestZigZag(TreeNode* root) {\\n        unordered_map<TreeNode*, int> dp;\\n        _getLongestPath(root, 0, 0);\\n        _getLongestPath(root, 1, 0);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3976088,
                "title": "optimized-solution",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. Definition of TreeNode: This part defines the structure of a binary tree node, including its value, left child, and right child.\\n\\n2. helper Function: This function is a recursive helper that traverses the binary tree, tracking the current zigzag length (steps) and the maximum zigzag length encountered so far (maxSum). The goLeft parameter determines whether the next move should be towards the left child (if true) or right child (if false). The base case of the recursion is when the root is nullptr, in which case the function returns.\\n\\n3. Update maxSum: Before exploring child nodes, the helper function updates maxSum with the current steps value. This is done at each node to ensure that the function keeps track of the maximum zigzag length encountered so far.\\n\\n4. Recursive Calls: Depending on the goLeft value, the function calls itself recursively for the left and right children. If moving left, it increments steps and moves to the right child, and vice versa if moving right. This alternation helps keep track of zigzag paths.\\n\\n5. longestZigZag Function: This function initializes the maxSum variable to -1 (to handle the case where there\\'s no zigzag path), and then it calls the helper function with the root of the binary tree, starting with a steps value of 0, and sets goLeft to true. It returns the final maxSum value.\\n\\n5. Null Checks: Your code includes proper null checks to handle cases where the input root is null, as well as within the recursive helper function to avoid accessing the properties of a null node.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n    O(n)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n    O(n)\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    void helper(TreeNode* root,int steps,int& maxSum,bool goLeft) {\\n        if (root == nullptr) {\\n            return; // Null check to handle base case\\n        }\\n        \\n        maxSum = max(maxSum,steps);\\n\\n        if(goLeft == true) {\\n            helper(root->left,steps+1,maxSum,false);\\n\\n            helper(root->right,1,maxSum,true);\\n        }\\n\\n        else {\\n            helper(root->left,1,maxSum,false);\\n\\n            helper(root->right,steps+1,maxSum,true);\\n        }\\n    }\\n\\n    int longestZigZag(TreeNode* root) {\\n        int maxSum = -1;\\n        if(root == NULL)\\n            return 0;\\n\\n        bool goLeft = true;\\n\\n        helper(root,0,maxSum,goLeft);\\n\\n        return maxSum;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    void helper(TreeNode* root,int steps,int& maxSum,bool goLeft) {\\n        if (root == nullptr) {\\n            return; // Null check to handle base case\\n        }\\n        \\n        maxSum = max(maxSum,steps);\\n\\n        if(goLeft == true) {\\n            helper(root->left,steps+1,maxSum,false);\\n\\n            helper(root->right,1,maxSum,true);\\n        }\\n\\n        else {\\n            helper(root->left,1,maxSum,false);\\n\\n            helper(root->right,steps+1,maxSum,true);\\n        }\\n    }\\n\\n    int longestZigZag(TreeNode* root) {\\n        int maxSum = -1;\\n        if(root == NULL)\\n            return 0;\\n\\n        bool goLeft = true;\\n\\n        helper(root,0,maxSum,goLeft);\\n\\n        return maxSum;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3954439,
                "title": "simple-traversal-o-n-with-java",
                "content": "# Complexity\\n- Time complexity: $$O(n)$$\\n\\n- Space complexity: $$O(1)$$\\n\\n# Code\\n```\\nclass Solution {\\n    private int max = 0;\\n    public int longestZigZag(TreeNode root) {\\n        foo(root.left,false,1);\\n        foo(root.right,true,1);\\n        return max;\\n    }\\n    private void foo(TreeNode node, boolean isRight, int counter){\\n        if(node==null){\\n            return;\\n        }\\n        max = Math.max(max,counter);\\n        foo(node.left, false, isRight ? counter + 1 : 1);\\n        foo(node.right, true, !isRight ? counter + 1 : 1);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    private int max = 0;\\n    public int longestZigZag(TreeNode root) {\\n        foo(root.left,false,1);\\n        foo(root.right,true,1);\\n        return max;\\n    }\\n    private void foo(TreeNode node, boolean isRight, int counter){\\n        if(node==null){\\n            return;\\n        }\\n        max = Math.max(max,counter);\\n        foo(node.left, false, isRight ? counter + 1 : 1);\\n        foo(node.right, true, !isRight ? counter + 1 : 1);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3710322,
                "title": "java-short-and-sweet-beats-99",
                "content": "```\\nclass Solution {\\n    public int longestZigZag(TreeNode root) {\\n        int l = root.left == null ? 0 : lzz(root.left, 1, false);\\n        int r = root.right == null ? 0 : lzz(root.right, 1, true);\\n        return Math.max(l, r);\\n    }\\n\\n    public int lzz(TreeNode n, int len, boolean parentLeft) {\\n        int l = n.left == null ? len : lzz(n.left, parentLeft ? len + 1 : 1, false);\\n        int r = n.right == null ? len : lzz(n.right, parentLeft ? 1 : len + 1, true);\\n        return Math.max(l, r);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int longestZigZag(TreeNode root) {\\n        int l = root.left == null ? 0 : lzz(root.left, 1, false);\\n        int r = root.right == null ? 0 : lzz(root.right, 1, true);\\n        return Math.max(l, r);\\n    }\\n\\n    public int lzz(TreeNode n, int len, boolean parentLeft) {\\n        int l = n.left == null ? len : lzz(n.left, parentLeft ? len + 1 : 1, false);\\n        int r = n.right == null ? len : lzz(n.right, parentLeft ? 1 : len + 1, true);\\n        return Math.max(l, r);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3641666,
                "title": "write-your-own-its-simple-try-harder",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\ndfs\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\ndfs\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(2^nodes)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(nodes)\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    int ans=0;\\n    void dfs(TreeNode* node,char state,int ct){\\n        cout<<endl<<state<<endl;\\n        int t;\\n        if(node->left){\\n            if(state==\\'r\\' || state==\\'o\\'){\\n                t=ct+1;\\n                // cout<<node->left->val<<state;\\n                ans=max(t,ans);\\n            }\\n            else{\\n                // cout<<endl;\\n                t=1;\\n            }\\n            dfs(node->left,\\'l\\',t);\\n        }\\n        if(node->right){\\n            if(state==\\'l\\' || state==\\'o\\'){\\n                t=ct+1;\\n                // cout<<node->right->val<<state;\\n                ans=max(t,ans);\\n            }\\n            else{\\n                // cout<<endl;\\n                t=1;\\n            }\\n            dfs(node->right,\\'r\\',t);\\n        }\\n    }\\n    int longestZigZag(TreeNode* root) {\\n        if(!root) return 0;\\n        dfs(root,\\'o\\',0);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    int ans=0;\\n    void dfs(TreeNode* node,char state,int ct){\\n        cout<<endl<<state<<endl;\\n        int t;\\n        if(node->left){\\n            if(state==\\'r\\' || state==\\'o\\'){\\n                t=ct+1;\\n                // cout<<node->left->val<<state;\\n                ans=max(t,ans);\\n            }\\n            else{\\n                // cout<<endl;\\n                t=1;\\n            }\\n            dfs(node->left,\\'l\\',t);\\n        }\\n        if(node->right){\\n            if(state==\\'l\\' || state==\\'o\\'){\\n                t=ct+1;\\n                // cout<<node->right->val<<state;\\n                ans=max(t,ans);\\n            }\\n            else{\\n                // cout<<endl;\\n                t=1;\\n            }\\n            dfs(node->right,\\'r\\',t);\\n        }\\n    }\\n    int longestZigZag(TreeNode* root) {\\n        if(!root) return 0;\\n        dfs(root,\\'o\\',0);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3615829,
                "title": "c-queue",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     public int val;\\n *     public TreeNode left;\\n *     public TreeNode right;\\n *     public TreeNode(int val=0, TreeNode left=null, TreeNode right=null) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\npublic class Solution {\\n    public int LongestZigZag(TreeNode root)\\n    {\\n        Queue<(TreeNode, string, int)> q = new Queue<(TreeNode, string, int)>();\\n        q.Enqueue((root, \"\", 0));\\n        int ans = 0;\\n\\n        while (q.Count > 0)\\n        {\\n            (TreeNode u, string prevDir, int cnt) = q.Dequeue();\\n            ans = Math.Max(ans, cnt);\\n\\n            if (u.left != null)\\n            {\\n                if (prevDir == \"r\")\\n                    q.Enqueue((u.left, \"l\", cnt + 1));\\n                else\\n                    q.Enqueue((u.left, \"l\", 1));\\n            }\\n\\n            if (u.right != null)\\n            {\\n                if (prevDir == \"l\")\\n                    q.Enqueue((u.right, \"r\", cnt + 1));\\n                else\\n                    q.Enqueue((u.right, \"r\", 1));\\n            }\\n        }\\n\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     public int val;\\n *     public TreeNode left;\\n *     public TreeNode right;\\n *     public TreeNode(int val=0, TreeNode left=null, TreeNode right=null) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\npublic class Solution {\\n    public int LongestZigZag(TreeNode root)\\n    {\\n        Queue<(TreeNode, string, int)> q = new Queue<(TreeNode, string, int)>();\\n        q.Enqueue((root, \"\", 0));\\n        int ans = 0;\\n\\n        while (q.Count > 0)\\n        {\\n            (TreeNode u, string prevDir, int cnt) = q.Dequeue();\\n            ans = Math.Max(ans, cnt);\\n\\n            if (u.left != null)\\n            {\\n                if (prevDir == \"r\")\\n                    q.Enqueue((u.left, \"l\", cnt + 1));\\n                else\\n                    q.Enqueue((u.left, \"l\", 1));\\n            }\\n\\n            if (u.right != null)\\n            {\\n                if (prevDir == \"l\")\\n                    q.Enqueue((u.right, \"r\", cnt + 1));\\n                else\\n                    q.Enqueue((u.right, \"r\", 1));\\n            }\\n        }\\n\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3581544,
                "title": "python-efficient-and-easy-depth-first-search-dfs-solution",
                "content": "# Approach\\nTo solve this problem, we can use the DFS (Depth-First Search) approach while keeping track of the previous traversal. When the previous traversal goes to the left, the next traversal to the right can make use of the previous height. However, if the next traversal goes to the left again, its height will start from 0 because it no longer follows the zigzag pattern. \\n\\n# Complexity\\n- Time complexity: $$O(n)$$\\n- Space complexity: $$O(1)$$\\n\\n# Code\\n```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\n\\nclass Solution:\\n    def dfs(self, tree, h=0, state=None):\\n        if tree is None:\\n            self.max_h = max(h, self.max_h)\\n            return\\n        \\n        self.dfs(tree.left, h+1 if state==\"right\" else 0, \"left\")\\n        self.dfs(tree.right, h+1 if state==\"left\" else 0, \"right\")\\n        \\n\\n    def longestZigZag(self, root: Optional[TreeNode]) -> int:\\n        self.max_h = 0\\n        self.dfs(root)\\n        return self.max_h\\n```",
                "solutionTags": [
                    "Python3",
                    "Tree",
                    "Depth-First Search",
                    "Binary Tree"
                ],
                "code": "```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\n\\nclass Solution:\\n    def dfs(self, tree, h=0, state=None):\\n        if tree is None:\\n            self.max_h = max(h, self.max_h)\\n            return\\n        \\n        self.dfs(tree.left, h+1 if state==\"right\" else 0, \"left\")\\n        self.dfs(tree.right, h+1 if state==\"left\" else 0, \"right\")\\n        \\n\\n    def longestZigZag(self, root: Optional[TreeNode]) -> int:\\n        self.max_h = 0\\n        self.dfs(root)\\n        return self.max_h\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3545526,
                "title": "c-hard-qn-commented",
                "content": "```\\nclass Solution {\\npublic:\\n    int maxStep=0;\\n    \\n    void helper(TreeNode* root, bool goLeft, int step){\\n        if(root==NULL){ return; }\\n        maxStep= max(maxStep, step);\\n        \\n        if(goLeft==true){ // I want to go left\\n            helper(root->left, false, step+1); // I went left, so step+1, now in the next step, I want to go right, so goLeft= false \\n            helper(root->right, true, 1); // I went right, step reseted\\n        }\\n        else if(goLeft==false){ // I want to go right\\n            helper(root->right, true, step+1); // I went right, so step+1, now In next step, I want to go left, so goLeft= true\\n            helper(root->left, false, 1); // I went left, step reseted\\n        }\\n        return;\\n    }\\n    \\n    int longestZigZag(TreeNode* root) {\\n        maxStep=0;\\n        helper(root, true, 0); // from root, we will move to left, and we have taken 0 steps till now\\n        helper(root, false, 0); // from root, we will move to right, and we have taken 0 steps till now\\n        return maxStep;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Depth-First Search",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxStep=0;\\n    \\n    void helper(TreeNode* root, bool goLeft, int step){\\n        if(root==NULL){ return; }\\n        maxStep= max(maxStep, step);\\n        \\n        if(goLeft==true){ // I want to go left\\n            helper(root->left, false, step+1); // I went left, so step+1, now in the next step, I want to go right, so goLeft= false \\n            helper(root->right, true, 1); // I went right, step reseted\\n        }\\n        else if(goLeft==false){ // I want to go right\\n            helper(root->right, true, step+1); // I went right, so step+1, now In next step, I want to go left, so goLeft= true\\n            helper(root->left, false, 1); // I went left, step reseted\\n        }\\n        return;\\n    }\\n    \\n    int longestZigZag(TreeNode* root) {\\n        maxStep=0;\\n        helper(root, true, 0); // from root, we will move to left, and we have taken 0 steps till now\\n        helper(root, false, 0); // from root, we will move to right, and we have taken 0 steps till now\\n        return maxStep;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3442431,
                "title": "binbin-is-very-close-to-cry-when-solving-this-problem-wuwuwuwu",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def longestZigZag(self, root: Optional[TreeNode]) -> int:\\n        if root.left is None and root.right is None:\\n            return 0\\n        \\n        self.maxV = 1\\n        def choosepath(node,d,n):\\n            \\n            self.maxV = max(n, self.maxV) \\n            if d == 1:\\n                if node.left is not None:\\n                    choosepath(node.left,-1,n+1)\\n                if node.right is not None:\\n                    choosepath(node.right,1,1)\\n            if d == -1:\\n                if node.right is not None:\\n                    choosepath(node.right,1,n+1)\\n                if node.left is not None:\\n                    choosepath(node.left,-1,1)\\n            \\n        \\n        choosepath(root,1,0)\\n        return self.maxV\\n      \\n       \\n\\n\\n            \\n\\n\\n\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def longestZigZag(self, root: Optional[TreeNode]) -> int:\\n        if root.left is None and root.right is None:\\n            return 0\\n        \\n        self.maxV = 1\\n        def choosepath(node,d,n):\\n            \\n            self.maxV = max(n, self.maxV) \\n            if d == 1:\\n                if node.left is not None:\\n                    choosepath(node.left,-1,n+1)\\n                if node.right is not None:\\n                    choosepath(node.right,1,1)\\n            if d == -1:\\n                if node.right is not None:\\n                    choosepath(node.right,1,n+1)\\n                if node.left is not None:\\n                    choosepath(node.left,-1,1)\\n            \\n        \\n        choosepath(root,1,0)\\n        return self.maxV\\n      \\n       \\n\\n\\n            \\n\\n\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3442310,
                "title": "scala-easy-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * class TreeNode(_value: Int = 0, _left: TreeNode = null, _right: TreeNode = null) {\\n *   var value: Int = _value\\n *   var left: TreeNode = _left\\n *   var right: TreeNode = _right\\n * }\\n */\\nobject Solution {\\n    def longestZigZag(root: TreeNode): Int = {\\n      def dfs(root: TreeNode, direction: Int, curDepth: Int, maxDepth: Int):Int = {\\n        if (root == null) {\\n          (maxDepth max curDepth) - 1\\n        } else  if (direction == 0) {\\n          dfs(root.left, 1, curDepth + 1, maxDepth max (curDepth + 1)) max dfs(root.right, 0, 1, maxDepth max (curDepth + 1))\\n        } else  {\\n          dfs(root.right, 0, curDepth + 1, maxDepth max (curDepth + 1)) max dfs(root.left, 1, 1, maxDepth max (curDepth + 1))\\n        }\\n      }\\n      dfs(root, 0, 0, 0)\\n    }\\n}\\n```",
                "solutionTags": [
                    "Scala"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * class TreeNode(_value: Int = 0, _left: TreeNode = null, _right: TreeNode = null) {\\n *   var value: Int = _value\\n *   var left: TreeNode = _left\\n *   var right: TreeNode = _right\\n * }\\n */\\nobject Solution {\\n    def longestZigZag(root: TreeNode): Int = {\\n      def dfs(root: TreeNode, direction: Int, curDepth: Int, maxDepth: Int):Int = {\\n        if (root == null) {\\n          (maxDepth max curDepth) - 1\\n        } else  if (direction == 0) {\\n          dfs(root.left, 1, curDepth + 1, maxDepth max (curDepth + 1)) max dfs(root.right, 0, 1, maxDepth max (curDepth + 1))\\n        } else  {\\n          dfs(root.right, 0, curDepth + 1, maxDepth max (curDepth + 1)) max dfs(root.left, 1, 1, maxDepth max (curDepth + 1))\\n        }\\n      }\\n      dfs(root, 0, 0, 0)\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3439359,
                "title": "map-level-order-traversal-o-n-time-and-space",
                "content": "> # ***Mastering the art of problem-solving - give my LeetCode solution an upvote if you agree!***\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nHi there! In this solution, I will explain the code that you have given me. The code is a solution to the problem of finding the longest zigzag path in a binary tree. A zigzag path is a sequence of nodes such that each node is either the left child or the right child of its parent, and the direction alternates between left and right. For example, in the following tree, the longest zigzag path is [1, 3, 2, 6, 7], which has length 4.\\n\\n   ```\\n    1\\n   / \\\\\\n  2   3\\n / \\\\ / \\\\\\n4  6 5  7\\n```\\n\\nThe code uses a map to store the length of the longest zigzag path ending at each node and each direction (left or right). The key of the map is a pair of a node pointer and a boolean value, where the boolean value indicates whether the last move was to the left (true) or to the right (false). The value of the map is an integer representing the length of the zigzag path.\\n\\nThe code also uses a recursive function called traverse to update the map for each node and each direction. The function takes two parameters: a node pointer and a boolean value indicating whether the current move is to the left or to the right. The function does the following:\\n\\n- If the node is null, return.\\n- If the current move is to the left, call traverse on the left child with false as the next move, and update the map for the current node and direction by adding one to the map value for the left child and false.\\n- If the current move is to the right, call traverse on the right child with true as the next move, and update the map for the current node and direction by adding one to the map value for the right child and true.\\n\\nThe code also uses a queue to perform a level order traversal of the tree. For each node in the queue, it checks if it has been visited by looking up in the map. If not, it calls traverse on that node with both directions (true and false). Then it adds its left and right children to the queue if they are not null.\\n\\nFinally, the code iterates over all the entries in the map and finds the maximum value among them. This is the length of the longest zigzag path in the tree. It subtracts one from this value because it counts from zero.\\n\\nI hope this solution helped you understand how this code works. If you have any questions or feedback, please leave a comment below. Thank you for reading!\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\nprivate:\\n    map<pair<TreeNode*,bool>,int> map;\\n    void traverse(TreeNode* root,bool isLeft){\\n        if(root==NULL){\\n            return;\\n        }\\n        if(isLeft){\\n            traverse(root->left,false);\\n            map[{root,true}]=map[{root->left,false}]+1;\\n        }\\n        else{\\n            traverse(root->right,true);\\n            map[{root,false}]=map[{root->right,true}]+1;\\n        }\\n    }\\npublic:\\n    int longestZigZag(TreeNode* root) {\\n        ios_base::sync_with_stdio(false);\\n        int ans = 0;\\n        queue<TreeNode*> q;\\n        q.push(root);\\n        while(!q.empty()){\\n            TreeNode* temp = q.front();\\n            q.pop();\\n            if(map.find({temp,false})==map.end()){\\n                traverse(temp,false);\\n            }\\n            if(map.find({temp,true})==map.end()){\\n                traverse(temp,true);\\n            }\\n            if(temp->left){\\n                q.push(temp->left);\\n            }\\n            if(temp->right){\\n                q.push(temp->right);\\n            }\\n        }\\n        for(auto it:map){\\n            ans=max(ans,it.second);\\n        }\\n        return ans-1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n    1\\n   / \\\\\\n  2   3\\n / \\\\ / \\\\\\n4  6 5  7\\n```\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\nprivate:\\n    map<pair<TreeNode*,bool>,int> map;\\n    void traverse(TreeNode* root,bool isLeft){\\n        if(root==NULL){\\n            return;\\n        }\\n        if(isLeft){\\n            traverse(root->left,false);\\n            map[{root,true}]=map[{root->left,false}]+1;\\n        }\\n        else{\\n            traverse(root->right,true);\\n            map[{root,false}]=map[{root->right,true}]+1;\\n        }\\n    }\\npublic:\\n    int longestZigZag(TreeNode* root) {\\n        ios_base::sync_with_stdio(false);\\n        int ans = 0;\\n        queue<TreeNode*> q;\\n        q.push(root);\\n        while(!q.empty()){\\n            TreeNode* temp = q.front();\\n            q.pop();\\n            if(map.find({temp,false})==map.end()){\\n                traverse(temp,false);\\n            }\\n            if(map.find({temp,true})==map.end()){\\n                traverse(temp,true);\\n            }\\n            if(temp->left){\\n                q.push(temp->left);\\n            }\\n            if(temp->right){\\n                q.push(temp->right);\\n            }\\n        }\\n        for(auto it:map){\\n            ans=max(ans,it.second);\\n        }\\n        return ans-1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3437219,
                "title": "easy-approach-beats-95-of-python-users",
                "content": "\\n**HELLO GUYS **\\n```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def longestZigZag(self, root: Optional[TreeNode]) -> int:\\n        self.a=0\\n        def fun(root,i,pre):\\n            if root==None:\\n                return\\n            if pre==1:\\n                fun(root.left,1,1)\\n                fun(root.right,i+1,2)\\n            elif pre==2:\\n                fun(root.left,i+1,1)\\n                fun(root.right,1,2)\\n            else:\\n                fun(root.left,i+1,1)\\n                fun(root.right,i+1,2)\\n            if self.a<i:\\n                self.a=i\\n        fun(root,0,0)\\n        return self.a\\n```\\n# **Please vote up if you like the solution**",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Tree",
                    "Depth-First Search"
                ],
                "code": "```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def longestZigZag(self, root: Optional[TreeNode]) -> int:\\n        self.a=0\\n        def fun(root,i,pre):\\n            if root==None:\\n                return\\n            if pre==1:\\n                fun(root.left,1,1)\\n                fun(root.right,i+1,2)\\n            elif pre==2:\\n                fun(root.left,i+1,1)\\n                fun(root.right,1,2)\\n            else:\\n                fun(root.left,i+1,1)\\n                fun(root.right,i+1,2)\\n            if self.a<i:\\n                self.a=i\\n        fun(root,0,0)\\n        return self.a\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3436871,
                "title": "easiest-java-solution-using-common-sense-and-memoization",
                "content": "# Intuition\\nCommon sense and Tricky memoization\\n\\n# Approach\\nEasy Recursion and Memoization!\\n\\n# Complexity\\n- Time complexity:\\nlinear time\\n\\n- Space complexity:\\nO(n) where n is the size of HashMap\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    int max_m=Integer.MIN_VALUE;\\n    public int helper(boolean left, boolean right, TreeNode root,int max,HashMap<TreeNode,Integer> dp)\\n    {\\n        if(root==null)\\n\\t        return 0;\\n\\t        if(dp.containsKey(root))\\n\\t        \\treturn dp.get(root);\\n\\t        if(left==true && root.left!=null)\\n\\t        helper(false,true,root.left,max+1,dp);\\n\\t        if(right==true && root.right!=null)\\n\\t        helper(true,false,root.right,max+1,dp);\\n\\t        max_m=Math.max(max_m,max);\\n\\t        dp.put(root, max_m);\\n\\t        max=0;\\n\\t        helper(false,true,root.left,1,dp);\\n\\t        helper(true,false,root.right,1,dp);\\n\\t        return max_m;\\n    }\\n    public int longestZigZag(TreeNode root) {\\n      if(root.left==null && root.right==null)\\n\\t        return 0;\\n\\t        HashMap<TreeNode, Integer> dp=new HashMap<>();\\n\\t        return Math.max(helper(false,true,root.left,1,dp),helper(true,false,root.right,1,dp));\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    int max_m=Integer.MIN_VALUE;\\n    public int helper(boolean left, boolean right, TreeNode root,int max,HashMap<TreeNode,Integer> dp)\\n    {\\n        if(root==null)\\n\\t        return 0;\\n\\t        if(dp.containsKey(root))\\n\\t        \\treturn dp.get(root);\\n\\t        if(left==true && root.left!=null)\\n\\t        helper(false,true,root.left,max+1,dp);\\n\\t        if(right==true && root.right!=null)\\n\\t        helper(true,false,root.right,max+1,dp);\\n\\t        max_m=Math.max(max_m,max);\\n\\t        dp.put(root, max_m);\\n\\t        max=0;\\n\\t        helper(false,true,root.left,1,dp);\\n\\t        helper(true,false,root.right,1,dp);\\n\\t        return max_m;\\n    }\\n    public int longestZigZag(TreeNode root) {\\n      if(root.left==null && root.right==null)\\n\\t        return 0;\\n\\t        HashMap<TreeNode, Integer> dp=new HashMap<>();\\n\\t        return Math.max(helper(false,true,root.left,1,dp),helper(true,false,root.right,1,dp));\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3436785,
                "title": "have-track-of-prev-direction-c-easy-concise",
                "content": "```\\nclass Solution {\\npublic:\\n    int ans = 0;\\n\\n    void dfs(TreeNode*root, char prev, int cnt)\\n    {\\n        if(!root) return;\\n        ans=max(ans,cnt);\\n        \\n\\t\\t//root node condition as there is no prev direction\\n        if(prev==\\'?\\')   \\n        {\\n            dfs(root->left,\\'l\\',1);\\n            dfs(root->right,\\'r\\',1);\\n        }                           \\n        else if(prev==\\'l\\')  //if we came to current node from left edge\\n        {\\n            dfs(root->left,\\'l\\',1);\\n            dfs(root->right,\\'r\\',cnt+1);\\n        }\\n        else if(prev==\\'r\\')  //if we came to current node by right edge\\n        {\\n            dfs(root->left,\\'l\\',cnt+1);\\n            dfs(root->right,\\'r\\',1);\\n        }\\n    }\\n    \\n    int longestZigZag(TreeNode* root) {\\n        dfs(root,\\'?\\',0);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int ans = 0;\\n\\n    void dfs(TreeNode*root, char prev, int cnt)\\n    {\\n        if(!root) return;\\n        ans=max(ans,cnt);\\n        \\n\\t\\t//root node condition as there is no prev direction\\n        if(prev==\\'?\\')   \\n        {\\n            dfs(root->left,\\'l\\',1);\\n            dfs(root->right,\\'r\\',1);\\n        }                           \\n        else if(prev==\\'l\\')  //if we came to current node from left edge\\n        {\\n            dfs(root->left,\\'l\\',1);\\n            dfs(root->right,\\'r\\',cnt+1);\\n        }\\n        else if(prev==\\'r\\')  //if we came to current node by right edge\\n        {\\n            dfs(root->left,\\'l\\',cnt+1);\\n            dfs(root->right,\\'r\\',1);\\n        }\\n    }\\n    \\n    int longestZigZag(TreeNode* root) {\\n        dfs(root,\\'?\\',0);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3436290,
                "title": "simple-c-solution-with-explanation",
                "content": "# Intuition\\n\\n# Approach\\nWe keep the state of child that it\\'s created from left or Right edge. Also, keep the total of number edges upto current node that follows the zigzag rules.\\n\\nSolved using dfs.\\nif comes from left but going to right add +1 with existing value \\nor call with 0 as zigzag len\\n\\nif comes from right but going to left add +1 with existing value\\nor call with 0 as zigzat len\\n\\n# Complexity\\n- Time complexity:\\nO(n).\\n**Explanation**\\nHere n is the total number of node in the tree. We will visit each node exactly one time.\\n\\n- Space complexity:\\n- O(1)\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\n\\nprivate:\\n    int dfs(TreeNode* cur, int state = 0, int tot = 0) {\\n        if(cur==nullptr) return (tot - 1);\\n\\n        int left = dfs(cur->left, -1, 1 + ((state!=-1)?tot:0));\\n        int right = dfs(cur->right, +1, 1 + ((state!=1)?tot:0));    \\n\\n        return max(left, right);\\n    }\\n\\npublic:\\n    int longestZigZag(TreeNode* root) {\\n        return dfs(root);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\n\\nprivate:\\n    int dfs(TreeNode* cur, int state = 0, int tot = 0) {\\n        if(cur==nullptr) return (tot - 1);\\n\\n        int left = dfs(cur->left, -1, 1 + ((state!=-1)?tot:0));\\n        int right = dfs(cur->right, +1, 1 + ((state!=1)?tot:0));    \\n\\n        return max(left, right);\\n    }\\n\\npublic:\\n    int longestZigZag(TreeNode* root) {\\n        return dfs(root);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3436266,
                "title": "90-faster-java-solution-easy-to-understand",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\n    // create maxi to compare with every len\\n    public int maxi = 0;\\n    public void helper(TreeNode root,int LorR, int len){\\n        if(root == null) return; // if we reach end of leaf node then simply return\\n        maxi = Math.max(len,maxi); // compare with maxi and len, which evere greater just store it in maxi\\n        if(LorR == 0){ // if previous node was left node, ie LorR == 0\\n            // here we have two choices \\n            helper(root.right,1,len+1); // 1. if previous was left then next will be right node, \\n            // then increase len & LorR == right == 1\\n            helper(root.left,0,1); // 2. for next node will left node, then it will node follow zig zag, then change len = 1\\n        } else{ // ifprevious node was right node ie LorR == 1\\n            helper(root.left,0,len+1);\\n            helper(root.right,1,1);\\n        }\\n    }\\n    public int longestZigZag(TreeNode root) {\\n        // LorR == 0, for left & at starting len = 1\\n        helper(root.left,0,1); // call for left part\\n        // LorR == 1, for right\\n        helper(root.right,1,1); // call fpr right part\\n        return maxi;\\n    }\\n}\\n```\\n![478xve.jpg](https://assets.leetcode.com/users/images/12f5b4ad-1d51-42a6-a0b9-0048d2afd02a_1681938100.5555906.jpeg)\\n",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    // create maxi to compare with every len\\n    public int maxi = 0;\\n    public void helper(TreeNode root,int LorR, int len){\\n        if(root == null) return; // if we reach end of leaf node then simply return\\n        maxi = Math.max(len,maxi); // compare with maxi and len, which evere greater just store it in maxi\\n        if(LorR == 0){ // if previous node was left node, ie LorR == 0\\n            // here we have two choices \\n            helper(root.right,1,len+1); // 1. if previous was left then next will be right node, \\n            // then increase len & LorR == right == 1\\n            helper(root.left,0,1); // 2. for next node will left node, then it will node follow zig zag, then change len = 1\\n        } else{ // ifprevious node was right node ie LorR == 1\\n            helper(root.left,0,len+1);\\n            helper(root.right,1,1);\\n        }\\n    }\\n    public int longestZigZag(TreeNode root) {\\n        // LorR == 0, for left & at starting len = 1\\n        helper(root.left,0,1); // call for left part\\n        // LorR == 1, for right\\n        helper(root.right,1,1); // call fpr right part\\n        return maxi;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3436142,
                "title": "c-easy-and-readable-solution-faster-than-75-less-than-50",
                "content": "![image.png](https://assets.leetcode.com/users/images/b391f1ae-9338-4294-bf54-93e5541b46b0_1681934251.1040218.png)\\n\\n**Don\\'t hesitate to suggest or ask bellow about something that you don\\'t understand**\\n\\n```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     public int val;\\n *     public TreeNode left;\\n *     public TreeNode right;\\n *     public TreeNode(int val=0, TreeNode left=null, TreeNode right=null) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\npublic class Solution {\\n    public int LongestZigZag(TreeNode root) {\\n        int left = Helper (root, true, 0);\\n        int right = Helper (root, false, 0);\\n        int ans = Math.Max(left, right);\\n        return ans - 1;\\n    }\\n\\n    int Helper (TreeNode node, bool isLeft, int length)\\n    {\\n        if(node == null)\\n            return length;\\n        int current = isLeft ?  Helper(node.right, !isLeft, length + 1) : Helper(node.left, !isLeft, length + 1);\\n        int alternate = isLeft ? Helper(node.left, isLeft, 1) : Helper(node.right, isLeft, 1);\\n        int maxLength = Math.Max(current, alternate);\\n        return maxLength;\\n    }\\n}\\n```\\n\\nIf you like it don\\'t forget to **upvote!**",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     public int val;\\n *     public TreeNode left;\\n *     public TreeNode right;\\n *     public TreeNode(int val=0, TreeNode left=null, TreeNode right=null) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\npublic class Solution {\\n    public int LongestZigZag(TreeNode root) {\\n        int left = Helper (root, true, 0);\\n        int right = Helper (root, false, 0);\\n        int ans = Math.Max(left, right);\\n        return ans - 1;\\n    }\\n\\n    int Helper (TreeNode node, bool isLeft, int length)\\n    {\\n        if(node == null)\\n            return length;\\n        int current = isLeft ?  Helper(node.right, !isLeft, length + 1) : Helper(node.left, !isLeft, length + 1);\\n        int alternate = isLeft ? Helper(node.left, isLeft, 1) : Helper(node.right, isLeft, 1);\\n        int maxLength = Math.Max(current, alternate);\\n        return maxLength;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3435870,
                "title": "java-solution-with-o-n-tc",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nOne way is to find all the zig-zag path and find the longest one. But in this approach the time complexity will O(n^2) which is not so good.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nTo optimize the algorithm for traversing a binary tree, we aim to reduce the time complexity from O(n^2) to O(n) or O(nlogn). This means that we need to traverse the tree only once. To achieve this, we should keep track of the longest path seen so far at every step of the traversal. This will allow us to determine the longest path in the tree without having to revisit any nodes, resulting in a more efficient solution with a lower time complexity. \\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n) : Because we go on every note exactly once from top to bottom.\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(h) : As we do dfs , so the recursive stack depth can be max O(depth) of nodes of tree.\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\n //dir 0 = L , 1 == R\\nclass Solution {\\npublic int maxLength=0;\\npublic void zigZagPath(TreeNode root,String dir,int currLength){\\nif(root==null) return;\\nmaxLength=Math.max(maxLength,currLength);\\nif(dir==\"R\"){\\n    zigZagPath(root.left,\"L\",currLength+1);\\n    zigZagPath(root.right,\"R\",1);\\n}\\nelse{\\n    zigZagPath(root.right,\"R\",currLength+1);\\n    zigZagPath(root.left,\"L\",1);\\n}\\n}\\npublic int longestZigZag(TreeNode root) {\\n    zigZagPath(root,\"L\",0);\\n    zigZagPath(root,\"R\",0); \\n    return maxLength;\\n}\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Tree",
                    "Recursion",
                    "Binary Tree"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\n //dir 0 = L , 1 == R\\nclass Solution {\\npublic int maxLength=0;\\npublic void zigZagPath(TreeNode root,String dir,int currLength){\\nif(root==null) return;\\nmaxLength=Math.max(maxLength,currLength);\\nif(dir==\"R\"){\\n    zigZagPath(root.left,\"L\",currLength+1);\\n    zigZagPath(root.right,\"R\",1);\\n}\\nelse{\\n    zigZagPath(root.right,\"R\",currLength+1);\\n    zigZagPath(root.left,\"L\",1);\\n}\\n}\\npublic int longestZigZag(TreeNode root) {\\n    zigZagPath(root,\"L\",0);\\n    zigZagPath(root,\"R\",0); \\n    return maxLength;\\n}\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3435744,
                "title": "c-accepted-no-dp-a-easy-approach-using-dfs",
                "content": "\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n// Direction = true   means we move to left node\\n//Direction = false   means we move to right node\\n//depth  = when we go one side down we call the function again and increase the depth by one\\n//maxdepth = we track the max depth\\nint maxdepth=0;\\n   void solve(TreeNode* root,bool Direction,int depth){\\n     if(root==NULL){\\n         return;\\n         //no icrease in depth\\n     }\\n     if(Direction){ //Direction = true   means we move to left node\\n       solve(root->left,false,depth+1);//and increase the depth by 1 and for zig zig we set the direction as false\\n          solve(root->right,true,1);//if suppose we we are not going left(as zig zig)so we put depath as 1 and start a new chain \\n     }\\n     else{\\n        solve(root->right,true,depth+1);//Direction = true   means we move to left node//and increase the depth by 1 and for zig zig we set the direction as false\\n        solve(root->left,false,1);//if suppose we we are not going right(as zig zig)so we put depath as 1 and start a new chain \\n     }\\n     maxdepth =max(maxdepth,depth);\\n   }\\n    int longestZigZag(TreeNode* root) {\\n        solve(root,true,0);\\n         solve(root,true,0);\\n         return maxdepth;\\n    }\\n};\\n\\n\\n\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n// Direction = true   means we move to left node\\n//Direction = false   means we move to right node\\n//depth  = when we go one side down we call the function again and increase the depth by one\\n//maxdepth = we track the max depth\\nint maxdepth=0;\\n   void solve(TreeNode* root,bool Direction,int depth){\\n     if(root==NULL){\\n         return;\\n         //no icrease in depth\\n     }\\n     if(Direction){ //Direction = true   means we move to left node\\n       solve(root->left,false,depth+1);//and increase the depth by 1 and for zig zig we set the direction as false\\n          solve(root->right,true,1);//if suppose we we are not going left(as zig zig)so we put depath as 1 and start a new chain \\n     }\\n     else{\\n        solve(root->right,true,depth+1);//Direction = true   means we move to left node//and increase the depth by 1 and for zig zig we set the direction as false\\n        solve(root->left,false,1);//if suppose we we are not going right(as zig zig)so we put depath as 1 and start a new chain \\n     }\\n     maxdepth =max(maxdepth,depth);\\n   }\\n    int longestZigZag(TreeNode* root) {\\n        solve(root,true,0);\\n         solve(root,true,0);\\n         return maxdepth;\\n    }\\n};\\n\\n\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3435575,
                "title": "easy-java-dfs-solution-with-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nIntuition is to solve the question using dfs keeping track of the path being zigzag or straight.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nThis question can be solved using simple DFS traversal.\\n\\nTraverse in dfs fashion (with parameters current treenode, path and count) and keep track of previous path which took us here. While calling the current path (left or right) increment the count if the paths are different. \\nExample: \\nIf the curr node is brought by path equal to left and we are going to move right, we increment count by 1\\nIf the curr node is brought by path equal to left and we are going to move left, we assign count as 1 because zigzag is interrupted by 2 lefts.\\n\\nWe use the same thought process for 2 cases of path coming from right as well.\\nThroughout the dfs traversal keep updating the max value of count which is the required answer.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n    O(n) where n is the number of TreeNodes\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    public void dfs(TreeNode curr, String path, int count){\\n        if(curr == null){\\n            return;\\n        }\\n\\n\\n        if(count > max){\\n            max = count;\\n        }\\n\\n\\n        if(path == \"right\" || path == \"\"){\\n            dfs(curr.left, \"left\", count+1);\\n        }else{\\n            dfs(curr.left, \"left\", 1);\\n        }\\n\\n\\n        if(path == \"left\" || path == \"\"){\\n            dfs(curr.right, \"right\", count + 1);\\n        }else{\\n            dfs(curr.right, \"right\", 1);\\n        }\\n        \\n    }\\n\\n    int max = 0;\\n    public int longestZigZag(TreeNode root) {\\n        String path = \"\";\\n        dfs(root, path, 0);\\n\\n        return max;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Depth-First Search",
                    "Recursion",
                    "Binary Tree"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    public void dfs(TreeNode curr, String path, int count){\\n        if(curr == null){\\n            return;\\n        }\\n\\n\\n        if(count > max){\\n            max = count;\\n        }\\n\\n\\n        if(path == \"right\" || path == \"\"){\\n            dfs(curr.left, \"left\", count+1);\\n        }else{\\n            dfs(curr.left, \"left\", 1);\\n        }\\n\\n\\n        if(path == \"left\" || path == \"\"){\\n            dfs(curr.right, \"right\", count + 1);\\n        }else{\\n            dfs(curr.right, \"right\", 1);\\n        }\\n        \\n    }\\n\\n    int max = 0;\\n    public int longestZigZag(TreeNode root) {\\n        String path = \"\";\\n        dfs(root, path, 0);\\n\\n        return max;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3435548,
                "title": "c-recursion-easy-approach",
                "content": "Here is my c++ code for thi problem.\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    int ans=0;\\n    void chk(TreeNode* root, int dir, int cnt){\\n        if(!root){return;}\\n        ans=max(ans, cnt);\\n        if(dir){\\n            chk(root->left, 0, cnt+1);\\n            chk(root->right, 1, 1);\\n        }\\n        else{\\n            chk(root->right, 1, cnt+1);\\n            chk(root->left, 0, 1);\\n        }\\n    }\\n    int longestZigZag(TreeNode* root) {\\n        if(!root){return 0;}\\n        chk(root, 1, 0);\\n        chk(root, 0, 0);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Recursion"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    int ans=0;\\n    void chk(TreeNode* root, int dir, int cnt){\\n        if(!root){return;}\\n        ans=max(ans, cnt);\\n        if(dir){\\n            chk(root->left, 0, cnt+1);\\n            chk(root->right, 1, 1);\\n        }\\n        else{\\n            chk(root->right, 1, cnt+1);\\n            chk(root->left, 0, 1);\\n        }\\n    }\\n    int longestZigZag(TreeNode* root) {\\n        if(!root){return 0;}\\n        chk(root, 1, 0);\\n        chk(root, 0, 0);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3435375,
                "title": "simple-recursion-approach-very-easy-to-understand",
                "content": "\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    int ans = 0;\\n    void helper(TreeNode* root, int dis, int dir){\\n        if(!root) return ;\\n        ans = max(ans, dis);\\n        if(dir == 1){\\n            helper(root->left, dis+1, 0);\\n            helper(root->right,1,1);\\n        }\\n        else {\\n            helper(root->right, dis+1, 1);\\n            helper(root->left,1,0);\\n        }\\n    }\\n    int longestZigZag(TreeNode* root) {\\n        helper(root,0,1);\\n        helper(root,0,0);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    int ans = 0;\\n    void helper(TreeNode* root, int dis, int dir){\\n        if(!root) return ;\\n        ans = max(ans, dis);\\n        if(dir == 1){\\n            helper(root->left, dis+1, 0);\\n            helper(root->right,1,1);\\n        }\\n        else {\\n            helper(root->right, dis+1, 1);\\n            helper(root->left,1,0);\\n        }\\n    }\\n    int longestZigZag(TreeNode* root) {\\n        helper(root,0,1);\\n        helper(root,0,0);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3435346,
                "title": "best-c-solution-one-time-traverse-the-tree",
                "content": "\\n\\n# Code\\n```\\n\\n #define pi  pair<int, int>\\n #define ppi pair<int, pi>\\nclass Solution {\\npublic:\\n    ppi solve(TreeNode* root)    {\\n        if(root == NULL)    return {0, {-1, -1}};\\n        ppi l = solve(root -> left);\\n        ppi r = solve(root -> right);\\n        ppi temp;\\n        temp.second.first = l.second.second + 1;\\n        temp.second.second = r.second.first + 1;\\n        temp.first=max(max(l.first, r.first), max(temp.second.first, temp.second.second));\\n        return temp;\\n    }\\n\\n\\n    int longestZigZag(TreeNode* root) {\\n        return solve(root).first;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Tree",
                    "Depth-First Search",
                    "Binary Tree"
                ],
                "code": "```\\n\\n #define pi  pair<int, int>\\n #define ppi pair<int, pi>\\nclass Solution {\\npublic:\\n    ppi solve(TreeNode* root)    {\\n        if(root == NULL)    return {0, {-1, -1}};\\n        ppi l = solve(root -> left);\\n        ppi r = solve(root -> right);\\n        ppi temp;\\n        temp.second.first = l.second.second + 1;\\n        temp.second.second = r.second.first + 1;\\n        temp.first=max(max(l.first, r.first), max(temp.second.first, temp.second.second));\\n        return temp;\\n    }\\n\\n\\n    int longestZigZag(TreeNode* root) {\\n        return solve(root).first;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3435317,
                "title": "scan-node-itself-and-left-and-right-for-thenode",
                "content": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    int longestZigZag(TreeNode* r) {\\n        int res = 0;\\n        bool l =true;\\n        solve(r,res,l,0);\\n        solve(r,res,!l,0);\\n        return res;\\n        \\n    }\\n    \\n    void solve(TreeNode* r,int &res, bool l, int t)\\n    {\\n        if(!r)\\n            return;\\n        res = max(res, t);\\n        if(l)\\n        {\\n            solve(r->left,res,!l,t+1);\\n            solve(r->right,res,l,1);\\n        }\\n        else\\n        {\\n            solve(r->right,res,!l,t+1);\\n            solve(r->left,res,l,1);\\n        }\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    int longestZigZag(TreeNode* r) {\\n        int res = 0;\\n        bool l =true;\\n        solve(r,res,l,0);\\n        solve(r,res,!l,0);\\n        return res;\\n        \\n    }\\n    \\n    void solve(TreeNode* r,int &res, bool l, int t)\\n    {\\n        if(!r)\\n            return;\\n        res = max(res, t);\\n        if(l)\\n        {\\n            solve(r->left,res,!l,t+1);\\n            solve(r->right,res,l,1);\\n        }\\n        else\\n        {\\n            solve(r->right,res,!l,t+1);\\n            solve(r->left,res,l,1);\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3435304,
                "title": "simple-recursive-easy-to-understand-cpp",
                "content": "# Description\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nYou are given the root of a binary tree.\\n\\nA ZigZag path for a binary tree is defined as follow:\\n\\nChoose any node in the binary tree and a direction (right or left).\\nIf the current direction is right, move to the right child of the current node; otherwise, move to the left child.\\nChange the direction from right to left or from left to right.\\nRepeat the second and third steps until you can\\'t move in the tree.\\nZigzag length is defined as the number of nodes visited - 1. (A single node has a length of 0).\\n\\nReturn the longest ZigZag path contained in that tree.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n`The solve function is a recursive helper function that calculates the zigzag length of a given subtree rooted at root. The function takes three parameters: root which is a pointer to the root node of the current subtree, isleft which is a boolean variable that indicates whether the current node is a left child or a right child of its parent, and len which is the length of the zigzag path up to the current node. If root is NULL, the function returns 0 as there is no zigzag path in that subtree.\\n\\nIn the solve function, the left and right children of the current node are recursively explored, and their respective zigzag lengths are calculated by calling solve recursively with updated parameters. The isleft parameter is used to determine the direction of the zigzag path at each node: if isleft is true, the path is going left to right, and if isleft is false, the path is going right to left. The len parameter is updated based on the direction of the zigzag path at the current node.\\n\\nOnce the zigzag lengths of the left and right children have been calculated, the solve function returns the maximum zigzag length between the left child, right child, and the current node. This is done by taking the maximum of len, lh, and rh.\\n\\nThe longestZigZag function is the main function that calculates the longest zigzag path in the binary tree. It first checks if the root is NULL and returns 0 if it is. It then calculates the zigzag lengths of the left and right children by calling solve with updated parameters. Finally, it returns the maximum zigzag length between the left child and the right child by taking the maximum of lh and rh.`\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n    O(N)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n    O(H) height of tree\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    int solve(TreeNode* root, bool isleft, int len)\\n{\\n    if(root==NULL) return 0; // If the root is NULL, return 0 as there is no zigzag path\\n\\n    int lh = solve(root->left,true, isleft?1:len+1); // Recursively calculate the zigzag length for the left child\\n    int rh = solve(root->right,false,isleft?len+1:1); // Recursively calculate the zigzag length for the right child\\n\\n    return max(len,max(lh,rh)); // Return the maximum zigzag length between the left child, right child, and the current node\\n}\\n\\nint longestZigZag(TreeNode* root) {\\n    \\n    if(root==NULL) return 0; // If the root is NULL, return 0 as there is no zigzag path\\n\\n    int lh = solve(root->left,true,1); // Calculate the zigzag length for the left child\\n    int rh = solve(root->right,false,1); // Calculate the zigzag length for the right child\\n\\n    return max(lh,rh); // Return the maximum zigzag length between the left child and the right child\\n}\\n};\\n```\\n![PLEASE UPVOTE.jpg](https://assets.leetcode.com/users/images/2edcfb93-5a2f-4695-88af-3f8a85708fc0_1681919198.8154056.jpeg)\\n",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    int solve(TreeNode* root, bool isleft, int len)\\n{\\n    if(root==NULL) return 0; // If the root is NULL, return 0 as there is no zigzag path\\n\\n    int lh = solve(root->left,true, isleft?1:len+1); // Recursively calculate the zigzag length for the left child\\n    int rh = solve(root->right,false,isleft?len+1:1); // Recursively calculate the zigzag length for the right child\\n\\n    return max(len,max(lh,rh)); // Return the maximum zigzag length between the left child, right child, and the current node\\n}\\n\\nint longestZigZag(TreeNode* root) {\\n    \\n    if(root==NULL) return 0; // If the root is NULL, return 0 as there is no zigzag path\\n\\n    int lh = solve(root->left,true,1); // Calculate the zigzag length for the left child\\n    int rh = solve(root->right,false,1); // Calculate the zigzag length for the right child\\n\\n    return max(lh,rh); // Return the maximum zigzag length between the left child and the right child\\n}\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3435283,
                "title": "runtime-100-00-faster-memory-usage-less-than-97-92",
                "content": "```\\nclass Solution {\\n    static int ct;\\n    public int longestZigZag(TreeNode root) {\\n        ct = 0;\\n        if(root.left!=null)recur(root.left,\\'l\\',1);\\n        if(root.right!=null)recur(root.right,\\'r\\',1);\\n        return ct;\\n    }\\n    private static void recur(TreeNode root, char c, int x){\\n        if(x>ct)ct = x;\\n        if(c==\\'l\\'){\\n            if(root.left!=null)recur(root.left,\\'l\\',1);\\n            if(root.right!=null)recur(root.right,\\'r\\',x+1);\\n        }else{\\n            if(root.left!=null)recur(root.left,\\'l\\',x+1);\\n            if(root.right!=null)recur(root.right,\\'r\\',1);\\n        }\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\n    static int ct;\\n    public int longestZigZag(TreeNode root) {\\n        ct = 0;\\n        if(root.left!=null)recur(root.left,\\'l\\',1);\\n        if(root.right!=null)recur(root.right,\\'r\\',1);\\n        return ct;\\n    }\\n    private static void recur(TreeNode root, char c, int x){\\n        if(x>ct)ct = x;\\n        if(c==\\'l\\'){\\n            if(root.left!=null)recur(root.left,\\'l\\',1);\\n            if(root.right!=null)recur(root.right,\\'r\\',x+1);\\n        }else{\\n            if(root.left!=null)recur(root.left,\\'l\\',x+1);\\n            if(root.right!=null)recur(root.right,\\'r\\',1);\\n        }\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3435164,
                "title": "simple-c-solution-recursion",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    \\n    int sol(TreeNode *root, bool d, int l){\\n        if(root == NULL) return l;\\n\\n        if(d == 0){\\n            return max(sol(root->left, 0, 0), sol(root->right, 1, l+1));\\n        }\\n        else{\\n            return max(sol(root->left, 0, 1+l), sol(root->right, 1, 0));\\n        }\\n    }\\n    int longestZigZag(TreeNode* root) {\\n         if(root == NULL) return 0;\\n\\n         return max(sol(root->left, 0, 0), sol(root->right, 1, 0));\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    int sol(TreeNode *root, bool d, int l){\\n        if(root == NULL) return l;\\n\\n        if(d == 0){\\n            return max(sol(root->left, 0, 0), sol(root->right, 1, l+1));\\n        }\\n        else{\\n            return max(sol(root->left, 0, 1+l), sol(root->right, 1, 0));\\n        }\\n    }\\n    int longestZigZag(TreeNode* root) {\\n         if(root == NULL) return 0;\\n\\n         return max(sol(root->left, 0, 0), sol(root->right, 1, 0));\\n    }\\n};\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1868047,
                "content": [
                    {
                        "username": "Eslam-Soliman",
                        "content": "Looks like the image representation for test case 1 in the description isn't accurate. It doesn't match the one generated under the Testcase tab"
                    },
                    {
                        "username": "prithvi91827",
                        "content": "Although, I solved this question in O(n^2) and giving me TLE but I am glad I solved this."
                    },
                    {
                        "username": "prithvi91827",
                        "content": "[@user3510p](/user3510p) \\nclass Solution {\\npublic:\\n    int maxi = 0;\\n    int f(TreeNode* root, int prevmove){\\n        if(!root) return 0;\\n        if(prevmove == -1){\\n            return max(f(root->left,0),f(root->right,1));\\n        }\\n        else{\\n            if(prevmove == 0){\\n                return 1 + f(root->right,1);\\n            }\\n            else{\\n                return 1 + f(root->left,0);\\n            }\\n        }\\n\\n    }\\n    int longestZigZag(TreeNode* root) {\\n        if(!root) return 0;\\n        int len = f(root,-1);\\n        maxi = max(len,maxi);\\n        longestZigZag(root->left);\\n        longestZigZag(root->right);\\n\\n        return maxi;\\n    }\\n};"
                    },
                    {
                        "username": "user3510p",
                        "content": "can u share the approach"
                    },
                    {
                        "username": "rajat_171",
                        "content": "In this Platform, wherever there is Coding\\u2013 there will always be DP to be found as well - Leetcode Uchiha."
                    },
                    {
                        "username": "A-V-Jagannathan",
                        "content": "[@Mek_san](/Mek_san) lol"
                    },
                    {
                        "username": "Nisarg_Pipaliya",
                        "content": "Those who forget the past, they tend to repeat it - DP Nara"
                    },
                    {
                        "username": "Mek_san",
                        "content": "As long as there is a concept of greedy, dp would also exist. Dp is born in ordered to decrease time in recursion."
                    },
                    {
                        "username": "riyaJha_3624",
                        "content": "This was a tricky one!"
                    },
                    {
                        "username": "karan_cpp_py",
                        "content": "That\\'s how my daily life look like : zig-zag"
                    },
                    {
                        "username": "AlecLC",
                        "content": "# <span style=\\'color:green\\'>Hint</span>\\nUse DFS with a variable that determines direction and flip that variable each iteration"
                    },
                    {
                        "username": "jacksonchen1998",
                        "content": "The first graph\\'s image is wrong. There has another right child."
                    },
                    {
                        "username": "Mister_CK",
                        "content": "[@vetor](/vetor) It is, it just doesn\\'t start in the rootNode"
                    },
                    {
                        "username": "BeniAc",
                        "content": "The image is correct. Take into consideration that you have to find out the longest path, given that you have to move right->left/left->right, you cannot move in the same direction twice, one after the other."
                    },
                    {
                        "username": "vetor",
                        "content": "but its not zigzag\\n"
                    },
                    {
                        "username": "himgupta2197",
                        "content": "The below test case should give 6 as the correct output, but the expected output is 5. how?\\n\\n[6,9,7,3,null,2,8,5,8,9,7,3,9,9,4,2,10,null,5,4,3,10,10,9,4,1,2,null,null,6,5,null,null,null,null,9,null,9,6,5,null,5,null,null,7,7,4,null,1,null,null,3,7,null,9,null,null,null,null,null,null,null,null,9,9,null,null,null,7,null,null,null,null,null,null,null,null,null,6,8,7,null,null,null,3,10,null,null,null,null,null,1,null,1,2]"
                    },
                    {
                        "username": "no947",
                        "content": "I had the same issue. I feel like my code is identical to the answer code. If you every figured out the question can you let me know?"
                    },
                    {
                        "username": "princepatrick",
                        "content": "I was facing the same issue for my previous submissions but rectified the test case later. The issue was let us assume we move to the current node through the left branch with a zig zag score of 3 and if we take a right branch then the score increases to 4 but if we move to the left branch again, then the score needs to reset to 1 again, but my previous code was retaining the score to 3, which was the issue.\\n\\nOn traversing the same direction in a future branch, I reset the score to 1 again. This resolved my issue. Let me know if my explanation was not clear. I will try explain again and better. "
                    },
                    {
                        "username": "mikemaximenko",
                        "content": "I having the same problem. Don\\'t understand it either"
                    },
                    {
                        "username": "malikharshit03",
                        "content": "HINT:\\nThis question can be solved using simple DFS traversal.\\n\\nTraverse in dfs fashion (with parameters current treenode, path and count) and keep track of previous path which took us here. While calling the current path (left or right) increment the count if the paths are different. \\nExample: \\nIf the curr node is brought by path equal to left and we are going to move right, we increment count by 1\\nIf the curr node is brought by path equal to left and we are going to move left, we assign count as 1 because zigzag is interrupted by 2 lefts.\\n\\nWe use the same thought process for 2 cases of path coming from right as well.\\nThroughout the dfs traversal keep updating the max value of count which is the required answer.\\n\\nFor Complete solution refer : https://leetcode.com/problems/longest-zigzag-path-in-a-binary-tree/solutions/3435575/easy-java-dfs-solution-with-explanation/\\n"
                    },
                    {
                        "username": "hosua",
                        "content": "Very helpful, thank you."
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "done so many dp problems lately that I put memoization :) When it was not really needed. \\uD83D\\uDE02"
                    }
                ]
            },
            {
                "id": 1868130,
                "content": [
                    {
                        "username": "Eslam-Soliman",
                        "content": "Looks like the image representation for test case 1 in the description isn't accurate. It doesn't match the one generated under the Testcase tab"
                    },
                    {
                        "username": "prithvi91827",
                        "content": "Although, I solved this question in O(n^2) and giving me TLE but I am glad I solved this."
                    },
                    {
                        "username": "prithvi91827",
                        "content": "[@user3510p](/user3510p) \\nclass Solution {\\npublic:\\n    int maxi = 0;\\n    int f(TreeNode* root, int prevmove){\\n        if(!root) return 0;\\n        if(prevmove == -1){\\n            return max(f(root->left,0),f(root->right,1));\\n        }\\n        else{\\n            if(prevmove == 0){\\n                return 1 + f(root->right,1);\\n            }\\n            else{\\n                return 1 + f(root->left,0);\\n            }\\n        }\\n\\n    }\\n    int longestZigZag(TreeNode* root) {\\n        if(!root) return 0;\\n        int len = f(root,-1);\\n        maxi = max(len,maxi);\\n        longestZigZag(root->left);\\n        longestZigZag(root->right);\\n\\n        return maxi;\\n    }\\n};"
                    },
                    {
                        "username": "user3510p",
                        "content": "can u share the approach"
                    },
                    {
                        "username": "rajat_171",
                        "content": "In this Platform, wherever there is Coding\\u2013 there will always be DP to be found as well - Leetcode Uchiha."
                    },
                    {
                        "username": "A-V-Jagannathan",
                        "content": "[@Mek_san](/Mek_san) lol"
                    },
                    {
                        "username": "Nisarg_Pipaliya",
                        "content": "Those who forget the past, they tend to repeat it - DP Nara"
                    },
                    {
                        "username": "Mek_san",
                        "content": "As long as there is a concept of greedy, dp would also exist. Dp is born in ordered to decrease time in recursion."
                    },
                    {
                        "username": "riyaJha_3624",
                        "content": "This was a tricky one!"
                    },
                    {
                        "username": "karan_cpp_py",
                        "content": "That\\'s how my daily life look like : zig-zag"
                    },
                    {
                        "username": "AlecLC",
                        "content": "# <span style=\\'color:green\\'>Hint</span>\\nUse DFS with a variable that determines direction and flip that variable each iteration"
                    },
                    {
                        "username": "jacksonchen1998",
                        "content": "The first graph\\'s image is wrong. There has another right child."
                    },
                    {
                        "username": "Mister_CK",
                        "content": "[@vetor](/vetor) It is, it just doesn\\'t start in the rootNode"
                    },
                    {
                        "username": "BeniAc",
                        "content": "The image is correct. Take into consideration that you have to find out the longest path, given that you have to move right->left/left->right, you cannot move in the same direction twice, one after the other."
                    },
                    {
                        "username": "vetor",
                        "content": "but its not zigzag\\n"
                    },
                    {
                        "username": "himgupta2197",
                        "content": "The below test case should give 6 as the correct output, but the expected output is 5. how?\\n\\n[6,9,7,3,null,2,8,5,8,9,7,3,9,9,4,2,10,null,5,4,3,10,10,9,4,1,2,null,null,6,5,null,null,null,null,9,null,9,6,5,null,5,null,null,7,7,4,null,1,null,null,3,7,null,9,null,null,null,null,null,null,null,null,9,9,null,null,null,7,null,null,null,null,null,null,null,null,null,6,8,7,null,null,null,3,10,null,null,null,null,null,1,null,1,2]"
                    },
                    {
                        "username": "no947",
                        "content": "I had the same issue. I feel like my code is identical to the answer code. If you every figured out the question can you let me know?"
                    },
                    {
                        "username": "princepatrick",
                        "content": "I was facing the same issue for my previous submissions but rectified the test case later. The issue was let us assume we move to the current node through the left branch with a zig zag score of 3 and if we take a right branch then the score increases to 4 but if we move to the left branch again, then the score needs to reset to 1 again, but my previous code was retaining the score to 3, which was the issue.\\n\\nOn traversing the same direction in a future branch, I reset the score to 1 again. This resolved my issue. Let me know if my explanation was not clear. I will try explain again and better. "
                    },
                    {
                        "username": "mikemaximenko",
                        "content": "I having the same problem. Don\\'t understand it either"
                    },
                    {
                        "username": "malikharshit03",
                        "content": "HINT:\\nThis question can be solved using simple DFS traversal.\\n\\nTraverse in dfs fashion (with parameters current treenode, path and count) and keep track of previous path which took us here. While calling the current path (left or right) increment the count if the paths are different. \\nExample: \\nIf the curr node is brought by path equal to left and we are going to move right, we increment count by 1\\nIf the curr node is brought by path equal to left and we are going to move left, we assign count as 1 because zigzag is interrupted by 2 lefts.\\n\\nWe use the same thought process for 2 cases of path coming from right as well.\\nThroughout the dfs traversal keep updating the max value of count which is the required answer.\\n\\nFor Complete solution refer : https://leetcode.com/problems/longest-zigzag-path-in-a-binary-tree/solutions/3435575/easy-java-dfs-solution-with-explanation/\\n"
                    },
                    {
                        "username": "hosua",
                        "content": "Very helpful, thank you."
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "done so many dp problems lately that I put memoization :) When it was not really needed. \\uD83D\\uDE02"
                    }
                ]
            },
            {
                "id": 1868023,
                "content": [
                    {
                        "username": "Eslam-Soliman",
                        "content": "Looks like the image representation for test case 1 in the description isn't accurate. It doesn't match the one generated under the Testcase tab"
                    },
                    {
                        "username": "prithvi91827",
                        "content": "Although, I solved this question in O(n^2) and giving me TLE but I am glad I solved this."
                    },
                    {
                        "username": "prithvi91827",
                        "content": "[@user3510p](/user3510p) \\nclass Solution {\\npublic:\\n    int maxi = 0;\\n    int f(TreeNode* root, int prevmove){\\n        if(!root) return 0;\\n        if(prevmove == -1){\\n            return max(f(root->left,0),f(root->right,1));\\n        }\\n        else{\\n            if(prevmove == 0){\\n                return 1 + f(root->right,1);\\n            }\\n            else{\\n                return 1 + f(root->left,0);\\n            }\\n        }\\n\\n    }\\n    int longestZigZag(TreeNode* root) {\\n        if(!root) return 0;\\n        int len = f(root,-1);\\n        maxi = max(len,maxi);\\n        longestZigZag(root->left);\\n        longestZigZag(root->right);\\n\\n        return maxi;\\n    }\\n};"
                    },
                    {
                        "username": "user3510p",
                        "content": "can u share the approach"
                    },
                    {
                        "username": "rajat_171",
                        "content": "In this Platform, wherever there is Coding\\u2013 there will always be DP to be found as well - Leetcode Uchiha."
                    },
                    {
                        "username": "A-V-Jagannathan",
                        "content": "[@Mek_san](/Mek_san) lol"
                    },
                    {
                        "username": "Nisarg_Pipaliya",
                        "content": "Those who forget the past, they tend to repeat it - DP Nara"
                    },
                    {
                        "username": "Mek_san",
                        "content": "As long as there is a concept of greedy, dp would also exist. Dp is born in ordered to decrease time in recursion."
                    },
                    {
                        "username": "riyaJha_3624",
                        "content": "This was a tricky one!"
                    },
                    {
                        "username": "karan_cpp_py",
                        "content": "That\\'s how my daily life look like : zig-zag"
                    },
                    {
                        "username": "AlecLC",
                        "content": "# <span style=\\'color:green\\'>Hint</span>\\nUse DFS with a variable that determines direction and flip that variable each iteration"
                    },
                    {
                        "username": "jacksonchen1998",
                        "content": "The first graph\\'s image is wrong. There has another right child."
                    },
                    {
                        "username": "Mister_CK",
                        "content": "[@vetor](/vetor) It is, it just doesn\\'t start in the rootNode"
                    },
                    {
                        "username": "BeniAc",
                        "content": "The image is correct. Take into consideration that you have to find out the longest path, given that you have to move right->left/left->right, you cannot move in the same direction twice, one after the other."
                    },
                    {
                        "username": "vetor",
                        "content": "but its not zigzag\\n"
                    },
                    {
                        "username": "himgupta2197",
                        "content": "The below test case should give 6 as the correct output, but the expected output is 5. how?\\n\\n[6,9,7,3,null,2,8,5,8,9,7,3,9,9,4,2,10,null,5,4,3,10,10,9,4,1,2,null,null,6,5,null,null,null,null,9,null,9,6,5,null,5,null,null,7,7,4,null,1,null,null,3,7,null,9,null,null,null,null,null,null,null,null,9,9,null,null,null,7,null,null,null,null,null,null,null,null,null,6,8,7,null,null,null,3,10,null,null,null,null,null,1,null,1,2]"
                    },
                    {
                        "username": "no947",
                        "content": "I had the same issue. I feel like my code is identical to the answer code. If you every figured out the question can you let me know?"
                    },
                    {
                        "username": "princepatrick",
                        "content": "I was facing the same issue for my previous submissions but rectified the test case later. The issue was let us assume we move to the current node through the left branch with a zig zag score of 3 and if we take a right branch then the score increases to 4 but if we move to the left branch again, then the score needs to reset to 1 again, but my previous code was retaining the score to 3, which was the issue.\\n\\nOn traversing the same direction in a future branch, I reset the score to 1 again. This resolved my issue. Let me know if my explanation was not clear. I will try explain again and better. "
                    },
                    {
                        "username": "mikemaximenko",
                        "content": "I having the same problem. Don\\'t understand it either"
                    },
                    {
                        "username": "malikharshit03",
                        "content": "HINT:\\nThis question can be solved using simple DFS traversal.\\n\\nTraverse in dfs fashion (with parameters current treenode, path and count) and keep track of previous path which took us here. While calling the current path (left or right) increment the count if the paths are different. \\nExample: \\nIf the curr node is brought by path equal to left and we are going to move right, we increment count by 1\\nIf the curr node is brought by path equal to left and we are going to move left, we assign count as 1 because zigzag is interrupted by 2 lefts.\\n\\nWe use the same thought process for 2 cases of path coming from right as well.\\nThroughout the dfs traversal keep updating the max value of count which is the required answer.\\n\\nFor Complete solution refer : https://leetcode.com/problems/longest-zigzag-path-in-a-binary-tree/solutions/3435575/easy-java-dfs-solution-with-explanation/\\n"
                    },
                    {
                        "username": "hosua",
                        "content": "Very helpful, thank you."
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "done so many dp problems lately that I put memoization :) When it was not really needed. \\uD83D\\uDE02"
                    }
                ]
            },
            {
                "id": 1868680,
                "content": [
                    {
                        "username": "Eslam-Soliman",
                        "content": "Looks like the image representation for test case 1 in the description isn't accurate. It doesn't match the one generated under the Testcase tab"
                    },
                    {
                        "username": "prithvi91827",
                        "content": "Although, I solved this question in O(n^2) and giving me TLE but I am glad I solved this."
                    },
                    {
                        "username": "prithvi91827",
                        "content": "[@user3510p](/user3510p) \\nclass Solution {\\npublic:\\n    int maxi = 0;\\n    int f(TreeNode* root, int prevmove){\\n        if(!root) return 0;\\n        if(prevmove == -1){\\n            return max(f(root->left,0),f(root->right,1));\\n        }\\n        else{\\n            if(prevmove == 0){\\n                return 1 + f(root->right,1);\\n            }\\n            else{\\n                return 1 + f(root->left,0);\\n            }\\n        }\\n\\n    }\\n    int longestZigZag(TreeNode* root) {\\n        if(!root) return 0;\\n        int len = f(root,-1);\\n        maxi = max(len,maxi);\\n        longestZigZag(root->left);\\n        longestZigZag(root->right);\\n\\n        return maxi;\\n    }\\n};"
                    },
                    {
                        "username": "user3510p",
                        "content": "can u share the approach"
                    },
                    {
                        "username": "rajat_171",
                        "content": "In this Platform, wherever there is Coding\\u2013 there will always be DP to be found as well - Leetcode Uchiha."
                    },
                    {
                        "username": "A-V-Jagannathan",
                        "content": "[@Mek_san](/Mek_san) lol"
                    },
                    {
                        "username": "Nisarg_Pipaliya",
                        "content": "Those who forget the past, they tend to repeat it - DP Nara"
                    },
                    {
                        "username": "Mek_san",
                        "content": "As long as there is a concept of greedy, dp would also exist. Dp is born in ordered to decrease time in recursion."
                    },
                    {
                        "username": "riyaJha_3624",
                        "content": "This was a tricky one!"
                    },
                    {
                        "username": "karan_cpp_py",
                        "content": "That\\'s how my daily life look like : zig-zag"
                    },
                    {
                        "username": "AlecLC",
                        "content": "# <span style=\\'color:green\\'>Hint</span>\\nUse DFS with a variable that determines direction and flip that variable each iteration"
                    },
                    {
                        "username": "jacksonchen1998",
                        "content": "The first graph\\'s image is wrong. There has another right child."
                    },
                    {
                        "username": "Mister_CK",
                        "content": "[@vetor](/vetor) It is, it just doesn\\'t start in the rootNode"
                    },
                    {
                        "username": "BeniAc",
                        "content": "The image is correct. Take into consideration that you have to find out the longest path, given that you have to move right->left/left->right, you cannot move in the same direction twice, one after the other."
                    },
                    {
                        "username": "vetor",
                        "content": "but its not zigzag\\n"
                    },
                    {
                        "username": "himgupta2197",
                        "content": "The below test case should give 6 as the correct output, but the expected output is 5. how?\\n\\n[6,9,7,3,null,2,8,5,8,9,7,3,9,9,4,2,10,null,5,4,3,10,10,9,4,1,2,null,null,6,5,null,null,null,null,9,null,9,6,5,null,5,null,null,7,7,4,null,1,null,null,3,7,null,9,null,null,null,null,null,null,null,null,9,9,null,null,null,7,null,null,null,null,null,null,null,null,null,6,8,7,null,null,null,3,10,null,null,null,null,null,1,null,1,2]"
                    },
                    {
                        "username": "no947",
                        "content": "I had the same issue. I feel like my code is identical to the answer code. If you every figured out the question can you let me know?"
                    },
                    {
                        "username": "princepatrick",
                        "content": "I was facing the same issue for my previous submissions but rectified the test case later. The issue was let us assume we move to the current node through the left branch with a zig zag score of 3 and if we take a right branch then the score increases to 4 but if we move to the left branch again, then the score needs to reset to 1 again, but my previous code was retaining the score to 3, which was the issue.\\n\\nOn traversing the same direction in a future branch, I reset the score to 1 again. This resolved my issue. Let me know if my explanation was not clear. I will try explain again and better. "
                    },
                    {
                        "username": "mikemaximenko",
                        "content": "I having the same problem. Don\\'t understand it either"
                    },
                    {
                        "username": "malikharshit03",
                        "content": "HINT:\\nThis question can be solved using simple DFS traversal.\\n\\nTraverse in dfs fashion (with parameters current treenode, path and count) and keep track of previous path which took us here. While calling the current path (left or right) increment the count if the paths are different. \\nExample: \\nIf the curr node is brought by path equal to left and we are going to move right, we increment count by 1\\nIf the curr node is brought by path equal to left and we are going to move left, we assign count as 1 because zigzag is interrupted by 2 lefts.\\n\\nWe use the same thought process for 2 cases of path coming from right as well.\\nThroughout the dfs traversal keep updating the max value of count which is the required answer.\\n\\nFor Complete solution refer : https://leetcode.com/problems/longest-zigzag-path-in-a-binary-tree/solutions/3435575/easy-java-dfs-solution-with-explanation/\\n"
                    },
                    {
                        "username": "hosua",
                        "content": "Very helpful, thank you."
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "done so many dp problems lately that I put memoization :) When it was not really needed. \\uD83D\\uDE02"
                    }
                ]
            },
            {
                "id": 1868336,
                "content": [
                    {
                        "username": "Eslam-Soliman",
                        "content": "Looks like the image representation for test case 1 in the description isn't accurate. It doesn't match the one generated under the Testcase tab"
                    },
                    {
                        "username": "prithvi91827",
                        "content": "Although, I solved this question in O(n^2) and giving me TLE but I am glad I solved this."
                    },
                    {
                        "username": "prithvi91827",
                        "content": "[@user3510p](/user3510p) \\nclass Solution {\\npublic:\\n    int maxi = 0;\\n    int f(TreeNode* root, int prevmove){\\n        if(!root) return 0;\\n        if(prevmove == -1){\\n            return max(f(root->left,0),f(root->right,1));\\n        }\\n        else{\\n            if(prevmove == 0){\\n                return 1 + f(root->right,1);\\n            }\\n            else{\\n                return 1 + f(root->left,0);\\n            }\\n        }\\n\\n    }\\n    int longestZigZag(TreeNode* root) {\\n        if(!root) return 0;\\n        int len = f(root,-1);\\n        maxi = max(len,maxi);\\n        longestZigZag(root->left);\\n        longestZigZag(root->right);\\n\\n        return maxi;\\n    }\\n};"
                    },
                    {
                        "username": "user3510p",
                        "content": "can u share the approach"
                    },
                    {
                        "username": "rajat_171",
                        "content": "In this Platform, wherever there is Coding\\u2013 there will always be DP to be found as well - Leetcode Uchiha."
                    },
                    {
                        "username": "A-V-Jagannathan",
                        "content": "[@Mek_san](/Mek_san) lol"
                    },
                    {
                        "username": "Nisarg_Pipaliya",
                        "content": "Those who forget the past, they tend to repeat it - DP Nara"
                    },
                    {
                        "username": "Mek_san",
                        "content": "As long as there is a concept of greedy, dp would also exist. Dp is born in ordered to decrease time in recursion."
                    },
                    {
                        "username": "riyaJha_3624",
                        "content": "This was a tricky one!"
                    },
                    {
                        "username": "karan_cpp_py",
                        "content": "That\\'s how my daily life look like : zig-zag"
                    },
                    {
                        "username": "AlecLC",
                        "content": "# <span style=\\'color:green\\'>Hint</span>\\nUse DFS with a variable that determines direction and flip that variable each iteration"
                    },
                    {
                        "username": "jacksonchen1998",
                        "content": "The first graph\\'s image is wrong. There has another right child."
                    },
                    {
                        "username": "Mister_CK",
                        "content": "[@vetor](/vetor) It is, it just doesn\\'t start in the rootNode"
                    },
                    {
                        "username": "BeniAc",
                        "content": "The image is correct. Take into consideration that you have to find out the longest path, given that you have to move right->left/left->right, you cannot move in the same direction twice, one after the other."
                    },
                    {
                        "username": "vetor",
                        "content": "but its not zigzag\\n"
                    },
                    {
                        "username": "himgupta2197",
                        "content": "The below test case should give 6 as the correct output, but the expected output is 5. how?\\n\\n[6,9,7,3,null,2,8,5,8,9,7,3,9,9,4,2,10,null,5,4,3,10,10,9,4,1,2,null,null,6,5,null,null,null,null,9,null,9,6,5,null,5,null,null,7,7,4,null,1,null,null,3,7,null,9,null,null,null,null,null,null,null,null,9,9,null,null,null,7,null,null,null,null,null,null,null,null,null,6,8,7,null,null,null,3,10,null,null,null,null,null,1,null,1,2]"
                    },
                    {
                        "username": "no947",
                        "content": "I had the same issue. I feel like my code is identical to the answer code. If you every figured out the question can you let me know?"
                    },
                    {
                        "username": "princepatrick",
                        "content": "I was facing the same issue for my previous submissions but rectified the test case later. The issue was let us assume we move to the current node through the left branch with a zig zag score of 3 and if we take a right branch then the score increases to 4 but if we move to the left branch again, then the score needs to reset to 1 again, but my previous code was retaining the score to 3, which was the issue.\\n\\nOn traversing the same direction in a future branch, I reset the score to 1 again. This resolved my issue. Let me know if my explanation was not clear. I will try explain again and better. "
                    },
                    {
                        "username": "mikemaximenko",
                        "content": "I having the same problem. Don\\'t understand it either"
                    },
                    {
                        "username": "malikharshit03",
                        "content": "HINT:\\nThis question can be solved using simple DFS traversal.\\n\\nTraverse in dfs fashion (with parameters current treenode, path and count) and keep track of previous path which took us here. While calling the current path (left or right) increment the count if the paths are different. \\nExample: \\nIf the curr node is brought by path equal to left and we are going to move right, we increment count by 1\\nIf the curr node is brought by path equal to left and we are going to move left, we assign count as 1 because zigzag is interrupted by 2 lefts.\\n\\nWe use the same thought process for 2 cases of path coming from right as well.\\nThroughout the dfs traversal keep updating the max value of count which is the required answer.\\n\\nFor Complete solution refer : https://leetcode.com/problems/longest-zigzag-path-in-a-binary-tree/solutions/3435575/easy-java-dfs-solution-with-explanation/\\n"
                    },
                    {
                        "username": "hosua",
                        "content": "Very helpful, thank you."
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "done so many dp problems lately that I put memoization :) When it was not really needed. \\uD83D\\uDE02"
                    }
                ]
            },
            {
                "id": 1868150,
                "content": [
                    {
                        "username": "Eslam-Soliman",
                        "content": "Looks like the image representation for test case 1 in the description isn't accurate. It doesn't match the one generated under the Testcase tab"
                    },
                    {
                        "username": "prithvi91827",
                        "content": "Although, I solved this question in O(n^2) and giving me TLE but I am glad I solved this."
                    },
                    {
                        "username": "prithvi91827",
                        "content": "[@user3510p](/user3510p) \\nclass Solution {\\npublic:\\n    int maxi = 0;\\n    int f(TreeNode* root, int prevmove){\\n        if(!root) return 0;\\n        if(prevmove == -1){\\n            return max(f(root->left,0),f(root->right,1));\\n        }\\n        else{\\n            if(prevmove == 0){\\n                return 1 + f(root->right,1);\\n            }\\n            else{\\n                return 1 + f(root->left,0);\\n            }\\n        }\\n\\n    }\\n    int longestZigZag(TreeNode* root) {\\n        if(!root) return 0;\\n        int len = f(root,-1);\\n        maxi = max(len,maxi);\\n        longestZigZag(root->left);\\n        longestZigZag(root->right);\\n\\n        return maxi;\\n    }\\n};"
                    },
                    {
                        "username": "user3510p",
                        "content": "can u share the approach"
                    },
                    {
                        "username": "rajat_171",
                        "content": "In this Platform, wherever there is Coding\\u2013 there will always be DP to be found as well - Leetcode Uchiha."
                    },
                    {
                        "username": "A-V-Jagannathan",
                        "content": "[@Mek_san](/Mek_san) lol"
                    },
                    {
                        "username": "Nisarg_Pipaliya",
                        "content": "Those who forget the past, they tend to repeat it - DP Nara"
                    },
                    {
                        "username": "Mek_san",
                        "content": "As long as there is a concept of greedy, dp would also exist. Dp is born in ordered to decrease time in recursion."
                    },
                    {
                        "username": "riyaJha_3624",
                        "content": "This was a tricky one!"
                    },
                    {
                        "username": "karan_cpp_py",
                        "content": "That\\'s how my daily life look like : zig-zag"
                    },
                    {
                        "username": "AlecLC",
                        "content": "# <span style=\\'color:green\\'>Hint</span>\\nUse DFS with a variable that determines direction and flip that variable each iteration"
                    },
                    {
                        "username": "jacksonchen1998",
                        "content": "The first graph\\'s image is wrong. There has another right child."
                    },
                    {
                        "username": "Mister_CK",
                        "content": "[@vetor](/vetor) It is, it just doesn\\'t start in the rootNode"
                    },
                    {
                        "username": "BeniAc",
                        "content": "The image is correct. Take into consideration that you have to find out the longest path, given that you have to move right->left/left->right, you cannot move in the same direction twice, one after the other."
                    },
                    {
                        "username": "vetor",
                        "content": "but its not zigzag\\n"
                    },
                    {
                        "username": "himgupta2197",
                        "content": "The below test case should give 6 as the correct output, but the expected output is 5. how?\\n\\n[6,9,7,3,null,2,8,5,8,9,7,3,9,9,4,2,10,null,5,4,3,10,10,9,4,1,2,null,null,6,5,null,null,null,null,9,null,9,6,5,null,5,null,null,7,7,4,null,1,null,null,3,7,null,9,null,null,null,null,null,null,null,null,9,9,null,null,null,7,null,null,null,null,null,null,null,null,null,6,8,7,null,null,null,3,10,null,null,null,null,null,1,null,1,2]"
                    },
                    {
                        "username": "no947",
                        "content": "I had the same issue. I feel like my code is identical to the answer code. If you every figured out the question can you let me know?"
                    },
                    {
                        "username": "princepatrick",
                        "content": "I was facing the same issue for my previous submissions but rectified the test case later. The issue was let us assume we move to the current node through the left branch with a zig zag score of 3 and if we take a right branch then the score increases to 4 but if we move to the left branch again, then the score needs to reset to 1 again, but my previous code was retaining the score to 3, which was the issue.\\n\\nOn traversing the same direction in a future branch, I reset the score to 1 again. This resolved my issue. Let me know if my explanation was not clear. I will try explain again and better. "
                    },
                    {
                        "username": "mikemaximenko",
                        "content": "I having the same problem. Don\\'t understand it either"
                    },
                    {
                        "username": "malikharshit03",
                        "content": "HINT:\\nThis question can be solved using simple DFS traversal.\\n\\nTraverse in dfs fashion (with parameters current treenode, path and count) and keep track of previous path which took us here. While calling the current path (left or right) increment the count if the paths are different. \\nExample: \\nIf the curr node is brought by path equal to left and we are going to move right, we increment count by 1\\nIf the curr node is brought by path equal to left and we are going to move left, we assign count as 1 because zigzag is interrupted by 2 lefts.\\n\\nWe use the same thought process for 2 cases of path coming from right as well.\\nThroughout the dfs traversal keep updating the max value of count which is the required answer.\\n\\nFor Complete solution refer : https://leetcode.com/problems/longest-zigzag-path-in-a-binary-tree/solutions/3435575/easy-java-dfs-solution-with-explanation/\\n"
                    },
                    {
                        "username": "hosua",
                        "content": "Very helpful, thank you."
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "done so many dp problems lately that I put memoization :) When it was not really needed. \\uD83D\\uDE02"
                    }
                ]
            },
            {
                "id": 1868053,
                "content": [
                    {
                        "username": "Eslam-Soliman",
                        "content": "Looks like the image representation for test case 1 in the description isn't accurate. It doesn't match the one generated under the Testcase tab"
                    },
                    {
                        "username": "prithvi91827",
                        "content": "Although, I solved this question in O(n^2) and giving me TLE but I am glad I solved this."
                    },
                    {
                        "username": "prithvi91827",
                        "content": "[@user3510p](/user3510p) \\nclass Solution {\\npublic:\\n    int maxi = 0;\\n    int f(TreeNode* root, int prevmove){\\n        if(!root) return 0;\\n        if(prevmove == -1){\\n            return max(f(root->left,0),f(root->right,1));\\n        }\\n        else{\\n            if(prevmove == 0){\\n                return 1 + f(root->right,1);\\n            }\\n            else{\\n                return 1 + f(root->left,0);\\n            }\\n        }\\n\\n    }\\n    int longestZigZag(TreeNode* root) {\\n        if(!root) return 0;\\n        int len = f(root,-1);\\n        maxi = max(len,maxi);\\n        longestZigZag(root->left);\\n        longestZigZag(root->right);\\n\\n        return maxi;\\n    }\\n};"
                    },
                    {
                        "username": "user3510p",
                        "content": "can u share the approach"
                    },
                    {
                        "username": "rajat_171",
                        "content": "In this Platform, wherever there is Coding\\u2013 there will always be DP to be found as well - Leetcode Uchiha."
                    },
                    {
                        "username": "A-V-Jagannathan",
                        "content": "[@Mek_san](/Mek_san) lol"
                    },
                    {
                        "username": "Nisarg_Pipaliya",
                        "content": "Those who forget the past, they tend to repeat it - DP Nara"
                    },
                    {
                        "username": "Mek_san",
                        "content": "As long as there is a concept of greedy, dp would also exist. Dp is born in ordered to decrease time in recursion."
                    },
                    {
                        "username": "riyaJha_3624",
                        "content": "This was a tricky one!"
                    },
                    {
                        "username": "karan_cpp_py",
                        "content": "That\\'s how my daily life look like : zig-zag"
                    },
                    {
                        "username": "AlecLC",
                        "content": "# <span style=\\'color:green\\'>Hint</span>\\nUse DFS with a variable that determines direction and flip that variable each iteration"
                    },
                    {
                        "username": "jacksonchen1998",
                        "content": "The first graph\\'s image is wrong. There has another right child."
                    },
                    {
                        "username": "Mister_CK",
                        "content": "[@vetor](/vetor) It is, it just doesn\\'t start in the rootNode"
                    },
                    {
                        "username": "BeniAc",
                        "content": "The image is correct. Take into consideration that you have to find out the longest path, given that you have to move right->left/left->right, you cannot move in the same direction twice, one after the other."
                    },
                    {
                        "username": "vetor",
                        "content": "but its not zigzag\\n"
                    },
                    {
                        "username": "himgupta2197",
                        "content": "The below test case should give 6 as the correct output, but the expected output is 5. how?\\n\\n[6,9,7,3,null,2,8,5,8,9,7,3,9,9,4,2,10,null,5,4,3,10,10,9,4,1,2,null,null,6,5,null,null,null,null,9,null,9,6,5,null,5,null,null,7,7,4,null,1,null,null,3,7,null,9,null,null,null,null,null,null,null,null,9,9,null,null,null,7,null,null,null,null,null,null,null,null,null,6,8,7,null,null,null,3,10,null,null,null,null,null,1,null,1,2]"
                    },
                    {
                        "username": "no947",
                        "content": "I had the same issue. I feel like my code is identical to the answer code. If you every figured out the question can you let me know?"
                    },
                    {
                        "username": "princepatrick",
                        "content": "I was facing the same issue for my previous submissions but rectified the test case later. The issue was let us assume we move to the current node through the left branch with a zig zag score of 3 and if we take a right branch then the score increases to 4 but if we move to the left branch again, then the score needs to reset to 1 again, but my previous code was retaining the score to 3, which was the issue.\\n\\nOn traversing the same direction in a future branch, I reset the score to 1 again. This resolved my issue. Let me know if my explanation was not clear. I will try explain again and better. "
                    },
                    {
                        "username": "mikemaximenko",
                        "content": "I having the same problem. Don\\'t understand it either"
                    },
                    {
                        "username": "malikharshit03",
                        "content": "HINT:\\nThis question can be solved using simple DFS traversal.\\n\\nTraverse in dfs fashion (with parameters current treenode, path and count) and keep track of previous path which took us here. While calling the current path (left or right) increment the count if the paths are different. \\nExample: \\nIf the curr node is brought by path equal to left and we are going to move right, we increment count by 1\\nIf the curr node is brought by path equal to left and we are going to move left, we assign count as 1 because zigzag is interrupted by 2 lefts.\\n\\nWe use the same thought process for 2 cases of path coming from right as well.\\nThroughout the dfs traversal keep updating the max value of count which is the required answer.\\n\\nFor Complete solution refer : https://leetcode.com/problems/longest-zigzag-path-in-a-binary-tree/solutions/3435575/easy-java-dfs-solution-with-explanation/\\n"
                    },
                    {
                        "username": "hosua",
                        "content": "Very helpful, thank you."
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "done so many dp problems lately that I put memoization :) When it was not really needed. \\uD83D\\uDE02"
                    }
                ]
            },
            {
                "id": 1868857,
                "content": [
                    {
                        "username": "Eslam-Soliman",
                        "content": "Looks like the image representation for test case 1 in the description isn't accurate. It doesn't match the one generated under the Testcase tab"
                    },
                    {
                        "username": "prithvi91827",
                        "content": "Although, I solved this question in O(n^2) and giving me TLE but I am glad I solved this."
                    },
                    {
                        "username": "prithvi91827",
                        "content": "[@user3510p](/user3510p) \\nclass Solution {\\npublic:\\n    int maxi = 0;\\n    int f(TreeNode* root, int prevmove){\\n        if(!root) return 0;\\n        if(prevmove == -1){\\n            return max(f(root->left,0),f(root->right,1));\\n        }\\n        else{\\n            if(prevmove == 0){\\n                return 1 + f(root->right,1);\\n            }\\n            else{\\n                return 1 + f(root->left,0);\\n            }\\n        }\\n\\n    }\\n    int longestZigZag(TreeNode* root) {\\n        if(!root) return 0;\\n        int len = f(root,-1);\\n        maxi = max(len,maxi);\\n        longestZigZag(root->left);\\n        longestZigZag(root->right);\\n\\n        return maxi;\\n    }\\n};"
                    },
                    {
                        "username": "user3510p",
                        "content": "can u share the approach"
                    },
                    {
                        "username": "rajat_171",
                        "content": "In this Platform, wherever there is Coding\\u2013 there will always be DP to be found as well - Leetcode Uchiha."
                    },
                    {
                        "username": "A-V-Jagannathan",
                        "content": "[@Mek_san](/Mek_san) lol"
                    },
                    {
                        "username": "Nisarg_Pipaliya",
                        "content": "Those who forget the past, they tend to repeat it - DP Nara"
                    },
                    {
                        "username": "Mek_san",
                        "content": "As long as there is a concept of greedy, dp would also exist. Dp is born in ordered to decrease time in recursion."
                    },
                    {
                        "username": "riyaJha_3624",
                        "content": "This was a tricky one!"
                    },
                    {
                        "username": "karan_cpp_py",
                        "content": "That\\'s how my daily life look like : zig-zag"
                    },
                    {
                        "username": "AlecLC",
                        "content": "# <span style=\\'color:green\\'>Hint</span>\\nUse DFS with a variable that determines direction and flip that variable each iteration"
                    },
                    {
                        "username": "jacksonchen1998",
                        "content": "The first graph\\'s image is wrong. There has another right child."
                    },
                    {
                        "username": "Mister_CK",
                        "content": "[@vetor](/vetor) It is, it just doesn\\'t start in the rootNode"
                    },
                    {
                        "username": "BeniAc",
                        "content": "The image is correct. Take into consideration that you have to find out the longest path, given that you have to move right->left/left->right, you cannot move in the same direction twice, one after the other."
                    },
                    {
                        "username": "vetor",
                        "content": "but its not zigzag\\n"
                    },
                    {
                        "username": "himgupta2197",
                        "content": "The below test case should give 6 as the correct output, but the expected output is 5. how?\\n\\n[6,9,7,3,null,2,8,5,8,9,7,3,9,9,4,2,10,null,5,4,3,10,10,9,4,1,2,null,null,6,5,null,null,null,null,9,null,9,6,5,null,5,null,null,7,7,4,null,1,null,null,3,7,null,9,null,null,null,null,null,null,null,null,9,9,null,null,null,7,null,null,null,null,null,null,null,null,null,6,8,7,null,null,null,3,10,null,null,null,null,null,1,null,1,2]"
                    },
                    {
                        "username": "no947",
                        "content": "I had the same issue. I feel like my code is identical to the answer code. If you every figured out the question can you let me know?"
                    },
                    {
                        "username": "princepatrick",
                        "content": "I was facing the same issue for my previous submissions but rectified the test case later. The issue was let us assume we move to the current node through the left branch with a zig zag score of 3 and if we take a right branch then the score increases to 4 but if we move to the left branch again, then the score needs to reset to 1 again, but my previous code was retaining the score to 3, which was the issue.\\n\\nOn traversing the same direction in a future branch, I reset the score to 1 again. This resolved my issue. Let me know if my explanation was not clear. I will try explain again and better. "
                    },
                    {
                        "username": "mikemaximenko",
                        "content": "I having the same problem. Don\\'t understand it either"
                    },
                    {
                        "username": "malikharshit03",
                        "content": "HINT:\\nThis question can be solved using simple DFS traversal.\\n\\nTraverse in dfs fashion (with parameters current treenode, path and count) and keep track of previous path which took us here. While calling the current path (left or right) increment the count if the paths are different. \\nExample: \\nIf the curr node is brought by path equal to left and we are going to move right, we increment count by 1\\nIf the curr node is brought by path equal to left and we are going to move left, we assign count as 1 because zigzag is interrupted by 2 lefts.\\n\\nWe use the same thought process for 2 cases of path coming from right as well.\\nThroughout the dfs traversal keep updating the max value of count which is the required answer.\\n\\nFor Complete solution refer : https://leetcode.com/problems/longest-zigzag-path-in-a-binary-tree/solutions/3435575/easy-java-dfs-solution-with-explanation/\\n"
                    },
                    {
                        "username": "hosua",
                        "content": "Very helpful, thank you."
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "done so many dp problems lately that I put memoization :) When it was not really needed. \\uD83D\\uDE02"
                    }
                ]
            },
            {
                "id": 1868595,
                "content": [
                    {
                        "username": "Eslam-Soliman",
                        "content": "Looks like the image representation for test case 1 in the description isn't accurate. It doesn't match the one generated under the Testcase tab"
                    },
                    {
                        "username": "prithvi91827",
                        "content": "Although, I solved this question in O(n^2) and giving me TLE but I am glad I solved this."
                    },
                    {
                        "username": "prithvi91827",
                        "content": "[@user3510p](/user3510p) \\nclass Solution {\\npublic:\\n    int maxi = 0;\\n    int f(TreeNode* root, int prevmove){\\n        if(!root) return 0;\\n        if(prevmove == -1){\\n            return max(f(root->left,0),f(root->right,1));\\n        }\\n        else{\\n            if(prevmove == 0){\\n                return 1 + f(root->right,1);\\n            }\\n            else{\\n                return 1 + f(root->left,0);\\n            }\\n        }\\n\\n    }\\n    int longestZigZag(TreeNode* root) {\\n        if(!root) return 0;\\n        int len = f(root,-1);\\n        maxi = max(len,maxi);\\n        longestZigZag(root->left);\\n        longestZigZag(root->right);\\n\\n        return maxi;\\n    }\\n};"
                    },
                    {
                        "username": "user3510p",
                        "content": "can u share the approach"
                    },
                    {
                        "username": "rajat_171",
                        "content": "In this Platform, wherever there is Coding\\u2013 there will always be DP to be found as well - Leetcode Uchiha."
                    },
                    {
                        "username": "A-V-Jagannathan",
                        "content": "[@Mek_san](/Mek_san) lol"
                    },
                    {
                        "username": "Nisarg_Pipaliya",
                        "content": "Those who forget the past, they tend to repeat it - DP Nara"
                    },
                    {
                        "username": "Mek_san",
                        "content": "As long as there is a concept of greedy, dp would also exist. Dp is born in ordered to decrease time in recursion."
                    },
                    {
                        "username": "riyaJha_3624",
                        "content": "This was a tricky one!"
                    },
                    {
                        "username": "karan_cpp_py",
                        "content": "That\\'s how my daily life look like : zig-zag"
                    },
                    {
                        "username": "AlecLC",
                        "content": "# <span style=\\'color:green\\'>Hint</span>\\nUse DFS with a variable that determines direction and flip that variable each iteration"
                    },
                    {
                        "username": "jacksonchen1998",
                        "content": "The first graph\\'s image is wrong. There has another right child."
                    },
                    {
                        "username": "Mister_CK",
                        "content": "[@vetor](/vetor) It is, it just doesn\\'t start in the rootNode"
                    },
                    {
                        "username": "BeniAc",
                        "content": "The image is correct. Take into consideration that you have to find out the longest path, given that you have to move right->left/left->right, you cannot move in the same direction twice, one after the other."
                    },
                    {
                        "username": "vetor",
                        "content": "but its not zigzag\\n"
                    },
                    {
                        "username": "himgupta2197",
                        "content": "The below test case should give 6 as the correct output, but the expected output is 5. how?\\n\\n[6,9,7,3,null,2,8,5,8,9,7,3,9,9,4,2,10,null,5,4,3,10,10,9,4,1,2,null,null,6,5,null,null,null,null,9,null,9,6,5,null,5,null,null,7,7,4,null,1,null,null,3,7,null,9,null,null,null,null,null,null,null,null,9,9,null,null,null,7,null,null,null,null,null,null,null,null,null,6,8,7,null,null,null,3,10,null,null,null,null,null,1,null,1,2]"
                    },
                    {
                        "username": "no947",
                        "content": "I had the same issue. I feel like my code is identical to the answer code. If you every figured out the question can you let me know?"
                    },
                    {
                        "username": "princepatrick",
                        "content": "I was facing the same issue for my previous submissions but rectified the test case later. The issue was let us assume we move to the current node through the left branch with a zig zag score of 3 and if we take a right branch then the score increases to 4 but if we move to the left branch again, then the score needs to reset to 1 again, but my previous code was retaining the score to 3, which was the issue.\\n\\nOn traversing the same direction in a future branch, I reset the score to 1 again. This resolved my issue. Let me know if my explanation was not clear. I will try explain again and better. "
                    },
                    {
                        "username": "mikemaximenko",
                        "content": "I having the same problem. Don\\'t understand it either"
                    },
                    {
                        "username": "malikharshit03",
                        "content": "HINT:\\nThis question can be solved using simple DFS traversal.\\n\\nTraverse in dfs fashion (with parameters current treenode, path and count) and keep track of previous path which took us here. While calling the current path (left or right) increment the count if the paths are different. \\nExample: \\nIf the curr node is brought by path equal to left and we are going to move right, we increment count by 1\\nIf the curr node is brought by path equal to left and we are going to move left, we assign count as 1 because zigzag is interrupted by 2 lefts.\\n\\nWe use the same thought process for 2 cases of path coming from right as well.\\nThroughout the dfs traversal keep updating the max value of count which is the required answer.\\n\\nFor Complete solution refer : https://leetcode.com/problems/longest-zigzag-path-in-a-binary-tree/solutions/3435575/easy-java-dfs-solution-with-explanation/\\n"
                    },
                    {
                        "username": "hosua",
                        "content": "Very helpful, thank you."
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "done so many dp problems lately that I put memoization :) When it was not really needed. \\uD83D\\uDE02"
                    }
                ]
            },
            {
                "id": 1868285,
                "content": [
                    {
                        "username": "Eslam-Soliman",
                        "content": "Looks like the image representation for test case 1 in the description isn't accurate. It doesn't match the one generated under the Testcase tab"
                    },
                    {
                        "username": "prithvi91827",
                        "content": "Although, I solved this question in O(n^2) and giving me TLE but I am glad I solved this."
                    },
                    {
                        "username": "prithvi91827",
                        "content": "[@user3510p](/user3510p) \\nclass Solution {\\npublic:\\n    int maxi = 0;\\n    int f(TreeNode* root, int prevmove){\\n        if(!root) return 0;\\n        if(prevmove == -1){\\n            return max(f(root->left,0),f(root->right,1));\\n        }\\n        else{\\n            if(prevmove == 0){\\n                return 1 + f(root->right,1);\\n            }\\n            else{\\n                return 1 + f(root->left,0);\\n            }\\n        }\\n\\n    }\\n    int longestZigZag(TreeNode* root) {\\n        if(!root) return 0;\\n        int len = f(root,-1);\\n        maxi = max(len,maxi);\\n        longestZigZag(root->left);\\n        longestZigZag(root->right);\\n\\n        return maxi;\\n    }\\n};"
                    },
                    {
                        "username": "user3510p",
                        "content": "can u share the approach"
                    },
                    {
                        "username": "rajat_171",
                        "content": "In this Platform, wherever there is Coding\\u2013 there will always be DP to be found as well - Leetcode Uchiha."
                    },
                    {
                        "username": "A-V-Jagannathan",
                        "content": "[@Mek_san](/Mek_san) lol"
                    },
                    {
                        "username": "Nisarg_Pipaliya",
                        "content": "Those who forget the past, they tend to repeat it - DP Nara"
                    },
                    {
                        "username": "Mek_san",
                        "content": "As long as there is a concept of greedy, dp would also exist. Dp is born in ordered to decrease time in recursion."
                    },
                    {
                        "username": "riyaJha_3624",
                        "content": "This was a tricky one!"
                    },
                    {
                        "username": "karan_cpp_py",
                        "content": "That\\'s how my daily life look like : zig-zag"
                    },
                    {
                        "username": "AlecLC",
                        "content": "# <span style=\\'color:green\\'>Hint</span>\\nUse DFS with a variable that determines direction and flip that variable each iteration"
                    },
                    {
                        "username": "jacksonchen1998",
                        "content": "The first graph\\'s image is wrong. There has another right child."
                    },
                    {
                        "username": "Mister_CK",
                        "content": "[@vetor](/vetor) It is, it just doesn\\'t start in the rootNode"
                    },
                    {
                        "username": "BeniAc",
                        "content": "The image is correct. Take into consideration that you have to find out the longest path, given that you have to move right->left/left->right, you cannot move in the same direction twice, one after the other."
                    },
                    {
                        "username": "vetor",
                        "content": "but its not zigzag\\n"
                    },
                    {
                        "username": "himgupta2197",
                        "content": "The below test case should give 6 as the correct output, but the expected output is 5. how?\\n\\n[6,9,7,3,null,2,8,5,8,9,7,3,9,9,4,2,10,null,5,4,3,10,10,9,4,1,2,null,null,6,5,null,null,null,null,9,null,9,6,5,null,5,null,null,7,7,4,null,1,null,null,3,7,null,9,null,null,null,null,null,null,null,null,9,9,null,null,null,7,null,null,null,null,null,null,null,null,null,6,8,7,null,null,null,3,10,null,null,null,null,null,1,null,1,2]"
                    },
                    {
                        "username": "no947",
                        "content": "I had the same issue. I feel like my code is identical to the answer code. If you every figured out the question can you let me know?"
                    },
                    {
                        "username": "princepatrick",
                        "content": "I was facing the same issue for my previous submissions but rectified the test case later. The issue was let us assume we move to the current node through the left branch with a zig zag score of 3 and if we take a right branch then the score increases to 4 but if we move to the left branch again, then the score needs to reset to 1 again, but my previous code was retaining the score to 3, which was the issue.\\n\\nOn traversing the same direction in a future branch, I reset the score to 1 again. This resolved my issue. Let me know if my explanation was not clear. I will try explain again and better. "
                    },
                    {
                        "username": "mikemaximenko",
                        "content": "I having the same problem. Don\\'t understand it either"
                    },
                    {
                        "username": "malikharshit03",
                        "content": "HINT:\\nThis question can be solved using simple DFS traversal.\\n\\nTraverse in dfs fashion (with parameters current treenode, path and count) and keep track of previous path which took us here. While calling the current path (left or right) increment the count if the paths are different. \\nExample: \\nIf the curr node is brought by path equal to left and we are going to move right, we increment count by 1\\nIf the curr node is brought by path equal to left and we are going to move left, we assign count as 1 because zigzag is interrupted by 2 lefts.\\n\\nWe use the same thought process for 2 cases of path coming from right as well.\\nThroughout the dfs traversal keep updating the max value of count which is the required answer.\\n\\nFor Complete solution refer : https://leetcode.com/problems/longest-zigzag-path-in-a-binary-tree/solutions/3435575/easy-java-dfs-solution-with-explanation/\\n"
                    },
                    {
                        "username": "hosua",
                        "content": "Very helpful, thank you."
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "done so many dp problems lately that I put memoization :) When it was not really needed. \\uD83D\\uDE02"
                    }
                ]
            },
            {
                "id": 1868047,
                "content": [
                    {
                        "username": "Eslam-Soliman",
                        "content": "Looks like the image representation for test case 1 in the description isn't accurate. It doesn't match the one generated under the Testcase tab"
                    },
                    {
                        "username": "prithvi91827",
                        "content": "Although, I solved this question in O(n^2) and giving me TLE but I am glad I solved this."
                    },
                    {
                        "username": "prithvi91827",
                        "content": "[@user3510p](/user3510p) \\nclass Solution {\\npublic:\\n    int maxi = 0;\\n    int f(TreeNode* root, int prevmove){\\n        if(!root) return 0;\\n        if(prevmove == -1){\\n            return max(f(root->left,0),f(root->right,1));\\n        }\\n        else{\\n            if(prevmove == 0){\\n                return 1 + f(root->right,1);\\n            }\\n            else{\\n                return 1 + f(root->left,0);\\n            }\\n        }\\n\\n    }\\n    int longestZigZag(TreeNode* root) {\\n        if(!root) return 0;\\n        int len = f(root,-1);\\n        maxi = max(len,maxi);\\n        longestZigZag(root->left);\\n        longestZigZag(root->right);\\n\\n        return maxi;\\n    }\\n};"
                    },
                    {
                        "username": "user3510p",
                        "content": "can u share the approach"
                    },
                    {
                        "username": "rajat_171",
                        "content": "In this Platform, wherever there is Coding\\u2013 there will always be DP to be found as well - Leetcode Uchiha."
                    },
                    {
                        "username": "A-V-Jagannathan",
                        "content": "[@Mek_san](/Mek_san) lol"
                    },
                    {
                        "username": "Nisarg_Pipaliya",
                        "content": "Those who forget the past, they tend to repeat it - DP Nara"
                    },
                    {
                        "username": "Mek_san",
                        "content": "As long as there is a concept of greedy, dp would also exist. Dp is born in ordered to decrease time in recursion."
                    },
                    {
                        "username": "riyaJha_3624",
                        "content": "This was a tricky one!"
                    },
                    {
                        "username": "karan_cpp_py",
                        "content": "That\\'s how my daily life look like : zig-zag"
                    },
                    {
                        "username": "AlecLC",
                        "content": "# <span style=\\'color:green\\'>Hint</span>\\nUse DFS with a variable that determines direction and flip that variable each iteration"
                    },
                    {
                        "username": "jacksonchen1998",
                        "content": "The first graph\\'s image is wrong. There has another right child."
                    },
                    {
                        "username": "Mister_CK",
                        "content": "[@vetor](/vetor) It is, it just doesn\\'t start in the rootNode"
                    },
                    {
                        "username": "BeniAc",
                        "content": "The image is correct. Take into consideration that you have to find out the longest path, given that you have to move right->left/left->right, you cannot move in the same direction twice, one after the other."
                    },
                    {
                        "username": "vetor",
                        "content": "but its not zigzag\\n"
                    },
                    {
                        "username": "himgupta2197",
                        "content": "The below test case should give 6 as the correct output, but the expected output is 5. how?\\n\\n[6,9,7,3,null,2,8,5,8,9,7,3,9,9,4,2,10,null,5,4,3,10,10,9,4,1,2,null,null,6,5,null,null,null,null,9,null,9,6,5,null,5,null,null,7,7,4,null,1,null,null,3,7,null,9,null,null,null,null,null,null,null,null,9,9,null,null,null,7,null,null,null,null,null,null,null,null,null,6,8,7,null,null,null,3,10,null,null,null,null,null,1,null,1,2]"
                    },
                    {
                        "username": "no947",
                        "content": "I had the same issue. I feel like my code is identical to the answer code. If you every figured out the question can you let me know?"
                    },
                    {
                        "username": "princepatrick",
                        "content": "I was facing the same issue for my previous submissions but rectified the test case later. The issue was let us assume we move to the current node through the left branch with a zig zag score of 3 and if we take a right branch then the score increases to 4 but if we move to the left branch again, then the score needs to reset to 1 again, but my previous code was retaining the score to 3, which was the issue.\\n\\nOn traversing the same direction in a future branch, I reset the score to 1 again. This resolved my issue. Let me know if my explanation was not clear. I will try explain again and better. "
                    },
                    {
                        "username": "mikemaximenko",
                        "content": "I having the same problem. Don\\'t understand it either"
                    },
                    {
                        "username": "malikharshit03",
                        "content": "HINT:\\nThis question can be solved using simple DFS traversal.\\n\\nTraverse in dfs fashion (with parameters current treenode, path and count) and keep track of previous path which took us here. While calling the current path (left or right) increment the count if the paths are different. \\nExample: \\nIf the curr node is brought by path equal to left and we are going to move right, we increment count by 1\\nIf the curr node is brought by path equal to left and we are going to move left, we assign count as 1 because zigzag is interrupted by 2 lefts.\\n\\nWe use the same thought process for 2 cases of path coming from right as well.\\nThroughout the dfs traversal keep updating the max value of count which is the required answer.\\n\\nFor Complete solution refer : https://leetcode.com/problems/longest-zigzag-path-in-a-binary-tree/solutions/3435575/easy-java-dfs-solution-with-explanation/\\n"
                    },
                    {
                        "username": "hosua",
                        "content": "Very helpful, thank you."
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "done so many dp problems lately that I put memoization :) When it was not really needed. \\uD83D\\uDE02"
                    }
                ]
            },
            {
                "id": 1868130,
                "content": [
                    {
                        "username": "Eslam-Soliman",
                        "content": "Looks like the image representation for test case 1 in the description isn't accurate. It doesn't match the one generated under the Testcase tab"
                    },
                    {
                        "username": "prithvi91827",
                        "content": "Although, I solved this question in O(n^2) and giving me TLE but I am glad I solved this."
                    },
                    {
                        "username": "prithvi91827",
                        "content": "[@user3510p](/user3510p) \\nclass Solution {\\npublic:\\n    int maxi = 0;\\n    int f(TreeNode* root, int prevmove){\\n        if(!root) return 0;\\n        if(prevmove == -1){\\n            return max(f(root->left,0),f(root->right,1));\\n        }\\n        else{\\n            if(prevmove == 0){\\n                return 1 + f(root->right,1);\\n            }\\n            else{\\n                return 1 + f(root->left,0);\\n            }\\n        }\\n\\n    }\\n    int longestZigZag(TreeNode* root) {\\n        if(!root) return 0;\\n        int len = f(root,-1);\\n        maxi = max(len,maxi);\\n        longestZigZag(root->left);\\n        longestZigZag(root->right);\\n\\n        return maxi;\\n    }\\n};"
                    },
                    {
                        "username": "user3510p",
                        "content": "can u share the approach"
                    },
                    {
                        "username": "rajat_171",
                        "content": "In this Platform, wherever there is Coding\\u2013 there will always be DP to be found as well - Leetcode Uchiha."
                    },
                    {
                        "username": "A-V-Jagannathan",
                        "content": "[@Mek_san](/Mek_san) lol"
                    },
                    {
                        "username": "Nisarg_Pipaliya",
                        "content": "Those who forget the past, they tend to repeat it - DP Nara"
                    },
                    {
                        "username": "Mek_san",
                        "content": "As long as there is a concept of greedy, dp would also exist. Dp is born in ordered to decrease time in recursion."
                    },
                    {
                        "username": "riyaJha_3624",
                        "content": "This was a tricky one!"
                    },
                    {
                        "username": "karan_cpp_py",
                        "content": "That\\'s how my daily life look like : zig-zag"
                    },
                    {
                        "username": "AlecLC",
                        "content": "# <span style=\\'color:green\\'>Hint</span>\\nUse DFS with a variable that determines direction and flip that variable each iteration"
                    },
                    {
                        "username": "jacksonchen1998",
                        "content": "The first graph\\'s image is wrong. There has another right child."
                    },
                    {
                        "username": "Mister_CK",
                        "content": "[@vetor](/vetor) It is, it just doesn\\'t start in the rootNode"
                    },
                    {
                        "username": "BeniAc",
                        "content": "The image is correct. Take into consideration that you have to find out the longest path, given that you have to move right->left/left->right, you cannot move in the same direction twice, one after the other."
                    },
                    {
                        "username": "vetor",
                        "content": "but its not zigzag\\n"
                    },
                    {
                        "username": "himgupta2197",
                        "content": "The below test case should give 6 as the correct output, but the expected output is 5. how?\\n\\n[6,9,7,3,null,2,8,5,8,9,7,3,9,9,4,2,10,null,5,4,3,10,10,9,4,1,2,null,null,6,5,null,null,null,null,9,null,9,6,5,null,5,null,null,7,7,4,null,1,null,null,3,7,null,9,null,null,null,null,null,null,null,null,9,9,null,null,null,7,null,null,null,null,null,null,null,null,null,6,8,7,null,null,null,3,10,null,null,null,null,null,1,null,1,2]"
                    },
                    {
                        "username": "no947",
                        "content": "I had the same issue. I feel like my code is identical to the answer code. If you every figured out the question can you let me know?"
                    },
                    {
                        "username": "princepatrick",
                        "content": "I was facing the same issue for my previous submissions but rectified the test case later. The issue was let us assume we move to the current node through the left branch with a zig zag score of 3 and if we take a right branch then the score increases to 4 but if we move to the left branch again, then the score needs to reset to 1 again, but my previous code was retaining the score to 3, which was the issue.\\n\\nOn traversing the same direction in a future branch, I reset the score to 1 again. This resolved my issue. Let me know if my explanation was not clear. I will try explain again and better. "
                    },
                    {
                        "username": "mikemaximenko",
                        "content": "I having the same problem. Don\\'t understand it either"
                    },
                    {
                        "username": "malikharshit03",
                        "content": "HINT:\\nThis question can be solved using simple DFS traversal.\\n\\nTraverse in dfs fashion (with parameters current treenode, path and count) and keep track of previous path which took us here. While calling the current path (left or right) increment the count if the paths are different. \\nExample: \\nIf the curr node is brought by path equal to left and we are going to move right, we increment count by 1\\nIf the curr node is brought by path equal to left and we are going to move left, we assign count as 1 because zigzag is interrupted by 2 lefts.\\n\\nWe use the same thought process for 2 cases of path coming from right as well.\\nThroughout the dfs traversal keep updating the max value of count which is the required answer.\\n\\nFor Complete solution refer : https://leetcode.com/problems/longest-zigzag-path-in-a-binary-tree/solutions/3435575/easy-java-dfs-solution-with-explanation/\\n"
                    },
                    {
                        "username": "hosua",
                        "content": "Very helpful, thank you."
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "done so many dp problems lately that I put memoization :) When it was not really needed. \\uD83D\\uDE02"
                    }
                ]
            },
            {
                "id": 1868023,
                "content": [
                    {
                        "username": "Eslam-Soliman",
                        "content": "Looks like the image representation for test case 1 in the description isn't accurate. It doesn't match the one generated under the Testcase tab"
                    },
                    {
                        "username": "prithvi91827",
                        "content": "Although, I solved this question in O(n^2) and giving me TLE but I am glad I solved this."
                    },
                    {
                        "username": "prithvi91827",
                        "content": "[@user3510p](/user3510p) \\nclass Solution {\\npublic:\\n    int maxi = 0;\\n    int f(TreeNode* root, int prevmove){\\n        if(!root) return 0;\\n        if(prevmove == -1){\\n            return max(f(root->left,0),f(root->right,1));\\n        }\\n        else{\\n            if(prevmove == 0){\\n                return 1 + f(root->right,1);\\n            }\\n            else{\\n                return 1 + f(root->left,0);\\n            }\\n        }\\n\\n    }\\n    int longestZigZag(TreeNode* root) {\\n        if(!root) return 0;\\n        int len = f(root,-1);\\n        maxi = max(len,maxi);\\n        longestZigZag(root->left);\\n        longestZigZag(root->right);\\n\\n        return maxi;\\n    }\\n};"
                    },
                    {
                        "username": "user3510p",
                        "content": "can u share the approach"
                    },
                    {
                        "username": "rajat_171",
                        "content": "In this Platform, wherever there is Coding\\u2013 there will always be DP to be found as well - Leetcode Uchiha."
                    },
                    {
                        "username": "A-V-Jagannathan",
                        "content": "[@Mek_san](/Mek_san) lol"
                    },
                    {
                        "username": "Nisarg_Pipaliya",
                        "content": "Those who forget the past, they tend to repeat it - DP Nara"
                    },
                    {
                        "username": "Mek_san",
                        "content": "As long as there is a concept of greedy, dp would also exist. Dp is born in ordered to decrease time in recursion."
                    },
                    {
                        "username": "riyaJha_3624",
                        "content": "This was a tricky one!"
                    },
                    {
                        "username": "karan_cpp_py",
                        "content": "That\\'s how my daily life look like : zig-zag"
                    },
                    {
                        "username": "AlecLC",
                        "content": "# <span style=\\'color:green\\'>Hint</span>\\nUse DFS with a variable that determines direction and flip that variable each iteration"
                    },
                    {
                        "username": "jacksonchen1998",
                        "content": "The first graph\\'s image is wrong. There has another right child."
                    },
                    {
                        "username": "Mister_CK",
                        "content": "[@vetor](/vetor) It is, it just doesn\\'t start in the rootNode"
                    },
                    {
                        "username": "BeniAc",
                        "content": "The image is correct. Take into consideration that you have to find out the longest path, given that you have to move right->left/left->right, you cannot move in the same direction twice, one after the other."
                    },
                    {
                        "username": "vetor",
                        "content": "but its not zigzag\\n"
                    },
                    {
                        "username": "himgupta2197",
                        "content": "The below test case should give 6 as the correct output, but the expected output is 5. how?\\n\\n[6,9,7,3,null,2,8,5,8,9,7,3,9,9,4,2,10,null,5,4,3,10,10,9,4,1,2,null,null,6,5,null,null,null,null,9,null,9,6,5,null,5,null,null,7,7,4,null,1,null,null,3,7,null,9,null,null,null,null,null,null,null,null,9,9,null,null,null,7,null,null,null,null,null,null,null,null,null,6,8,7,null,null,null,3,10,null,null,null,null,null,1,null,1,2]"
                    },
                    {
                        "username": "no947",
                        "content": "I had the same issue. I feel like my code is identical to the answer code. If you every figured out the question can you let me know?"
                    },
                    {
                        "username": "princepatrick",
                        "content": "I was facing the same issue for my previous submissions but rectified the test case later. The issue was let us assume we move to the current node through the left branch with a zig zag score of 3 and if we take a right branch then the score increases to 4 but if we move to the left branch again, then the score needs to reset to 1 again, but my previous code was retaining the score to 3, which was the issue.\\n\\nOn traversing the same direction in a future branch, I reset the score to 1 again. This resolved my issue. Let me know if my explanation was not clear. I will try explain again and better. "
                    },
                    {
                        "username": "mikemaximenko",
                        "content": "I having the same problem. Don\\'t understand it either"
                    },
                    {
                        "username": "malikharshit03",
                        "content": "HINT:\\nThis question can be solved using simple DFS traversal.\\n\\nTraverse in dfs fashion (with parameters current treenode, path and count) and keep track of previous path which took us here. While calling the current path (left or right) increment the count if the paths are different. \\nExample: \\nIf the curr node is brought by path equal to left and we are going to move right, we increment count by 1\\nIf the curr node is brought by path equal to left and we are going to move left, we assign count as 1 because zigzag is interrupted by 2 lefts.\\n\\nWe use the same thought process for 2 cases of path coming from right as well.\\nThroughout the dfs traversal keep updating the max value of count which is the required answer.\\n\\nFor Complete solution refer : https://leetcode.com/problems/longest-zigzag-path-in-a-binary-tree/solutions/3435575/easy-java-dfs-solution-with-explanation/\\n"
                    },
                    {
                        "username": "hosua",
                        "content": "Very helpful, thank you."
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "done so many dp problems lately that I put memoization :) When it was not really needed. \\uD83D\\uDE02"
                    }
                ]
            },
            {
                "id": 1868680,
                "content": [
                    {
                        "username": "Eslam-Soliman",
                        "content": "Looks like the image representation for test case 1 in the description isn't accurate. It doesn't match the one generated under the Testcase tab"
                    },
                    {
                        "username": "prithvi91827",
                        "content": "Although, I solved this question in O(n^2) and giving me TLE but I am glad I solved this."
                    },
                    {
                        "username": "prithvi91827",
                        "content": "[@user3510p](/user3510p) \\nclass Solution {\\npublic:\\n    int maxi = 0;\\n    int f(TreeNode* root, int prevmove){\\n        if(!root) return 0;\\n        if(prevmove == -1){\\n            return max(f(root->left,0),f(root->right,1));\\n        }\\n        else{\\n            if(prevmove == 0){\\n                return 1 + f(root->right,1);\\n            }\\n            else{\\n                return 1 + f(root->left,0);\\n            }\\n        }\\n\\n    }\\n    int longestZigZag(TreeNode* root) {\\n        if(!root) return 0;\\n        int len = f(root,-1);\\n        maxi = max(len,maxi);\\n        longestZigZag(root->left);\\n        longestZigZag(root->right);\\n\\n        return maxi;\\n    }\\n};"
                    },
                    {
                        "username": "user3510p",
                        "content": "can u share the approach"
                    },
                    {
                        "username": "rajat_171",
                        "content": "In this Platform, wherever there is Coding\\u2013 there will always be DP to be found as well - Leetcode Uchiha."
                    },
                    {
                        "username": "A-V-Jagannathan",
                        "content": "[@Mek_san](/Mek_san) lol"
                    },
                    {
                        "username": "Nisarg_Pipaliya",
                        "content": "Those who forget the past, they tend to repeat it - DP Nara"
                    },
                    {
                        "username": "Mek_san",
                        "content": "As long as there is a concept of greedy, dp would also exist. Dp is born in ordered to decrease time in recursion."
                    },
                    {
                        "username": "riyaJha_3624",
                        "content": "This was a tricky one!"
                    },
                    {
                        "username": "karan_cpp_py",
                        "content": "That\\'s how my daily life look like : zig-zag"
                    },
                    {
                        "username": "AlecLC",
                        "content": "# <span style=\\'color:green\\'>Hint</span>\\nUse DFS with a variable that determines direction and flip that variable each iteration"
                    },
                    {
                        "username": "jacksonchen1998",
                        "content": "The first graph\\'s image is wrong. There has another right child."
                    },
                    {
                        "username": "Mister_CK",
                        "content": "[@vetor](/vetor) It is, it just doesn\\'t start in the rootNode"
                    },
                    {
                        "username": "BeniAc",
                        "content": "The image is correct. Take into consideration that you have to find out the longest path, given that you have to move right->left/left->right, you cannot move in the same direction twice, one after the other."
                    },
                    {
                        "username": "vetor",
                        "content": "but its not zigzag\\n"
                    },
                    {
                        "username": "himgupta2197",
                        "content": "The below test case should give 6 as the correct output, but the expected output is 5. how?\\n\\n[6,9,7,3,null,2,8,5,8,9,7,3,9,9,4,2,10,null,5,4,3,10,10,9,4,1,2,null,null,6,5,null,null,null,null,9,null,9,6,5,null,5,null,null,7,7,4,null,1,null,null,3,7,null,9,null,null,null,null,null,null,null,null,9,9,null,null,null,7,null,null,null,null,null,null,null,null,null,6,8,7,null,null,null,3,10,null,null,null,null,null,1,null,1,2]"
                    },
                    {
                        "username": "no947",
                        "content": "I had the same issue. I feel like my code is identical to the answer code. If you every figured out the question can you let me know?"
                    },
                    {
                        "username": "princepatrick",
                        "content": "I was facing the same issue for my previous submissions but rectified the test case later. The issue was let us assume we move to the current node through the left branch with a zig zag score of 3 and if we take a right branch then the score increases to 4 but if we move to the left branch again, then the score needs to reset to 1 again, but my previous code was retaining the score to 3, which was the issue.\\n\\nOn traversing the same direction in a future branch, I reset the score to 1 again. This resolved my issue. Let me know if my explanation was not clear. I will try explain again and better. "
                    },
                    {
                        "username": "mikemaximenko",
                        "content": "I having the same problem. Don\\'t understand it either"
                    },
                    {
                        "username": "malikharshit03",
                        "content": "HINT:\\nThis question can be solved using simple DFS traversal.\\n\\nTraverse in dfs fashion (with parameters current treenode, path and count) and keep track of previous path which took us here. While calling the current path (left or right) increment the count if the paths are different. \\nExample: \\nIf the curr node is brought by path equal to left and we are going to move right, we increment count by 1\\nIf the curr node is brought by path equal to left and we are going to move left, we assign count as 1 because zigzag is interrupted by 2 lefts.\\n\\nWe use the same thought process for 2 cases of path coming from right as well.\\nThroughout the dfs traversal keep updating the max value of count which is the required answer.\\n\\nFor Complete solution refer : https://leetcode.com/problems/longest-zigzag-path-in-a-binary-tree/solutions/3435575/easy-java-dfs-solution-with-explanation/\\n"
                    },
                    {
                        "username": "hosua",
                        "content": "Very helpful, thank you."
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "done so many dp problems lately that I put memoization :) When it was not really needed. \\uD83D\\uDE02"
                    }
                ]
            },
            {
                "id": 1868336,
                "content": [
                    {
                        "username": "Eslam-Soliman",
                        "content": "Looks like the image representation for test case 1 in the description isn't accurate. It doesn't match the one generated under the Testcase tab"
                    },
                    {
                        "username": "prithvi91827",
                        "content": "Although, I solved this question in O(n^2) and giving me TLE but I am glad I solved this."
                    },
                    {
                        "username": "prithvi91827",
                        "content": "[@user3510p](/user3510p) \\nclass Solution {\\npublic:\\n    int maxi = 0;\\n    int f(TreeNode* root, int prevmove){\\n        if(!root) return 0;\\n        if(prevmove == -1){\\n            return max(f(root->left,0),f(root->right,1));\\n        }\\n        else{\\n            if(prevmove == 0){\\n                return 1 + f(root->right,1);\\n            }\\n            else{\\n                return 1 + f(root->left,0);\\n            }\\n        }\\n\\n    }\\n    int longestZigZag(TreeNode* root) {\\n        if(!root) return 0;\\n        int len = f(root,-1);\\n        maxi = max(len,maxi);\\n        longestZigZag(root->left);\\n        longestZigZag(root->right);\\n\\n        return maxi;\\n    }\\n};"
                    },
                    {
                        "username": "user3510p",
                        "content": "can u share the approach"
                    },
                    {
                        "username": "rajat_171",
                        "content": "In this Platform, wherever there is Coding\\u2013 there will always be DP to be found as well - Leetcode Uchiha."
                    },
                    {
                        "username": "A-V-Jagannathan",
                        "content": "[@Mek_san](/Mek_san) lol"
                    },
                    {
                        "username": "Nisarg_Pipaliya",
                        "content": "Those who forget the past, they tend to repeat it - DP Nara"
                    },
                    {
                        "username": "Mek_san",
                        "content": "As long as there is a concept of greedy, dp would also exist. Dp is born in ordered to decrease time in recursion."
                    },
                    {
                        "username": "riyaJha_3624",
                        "content": "This was a tricky one!"
                    },
                    {
                        "username": "karan_cpp_py",
                        "content": "That\\'s how my daily life look like : zig-zag"
                    },
                    {
                        "username": "AlecLC",
                        "content": "# <span style=\\'color:green\\'>Hint</span>\\nUse DFS with a variable that determines direction and flip that variable each iteration"
                    },
                    {
                        "username": "jacksonchen1998",
                        "content": "The first graph\\'s image is wrong. There has another right child."
                    },
                    {
                        "username": "Mister_CK",
                        "content": "[@vetor](/vetor) It is, it just doesn\\'t start in the rootNode"
                    },
                    {
                        "username": "BeniAc",
                        "content": "The image is correct. Take into consideration that you have to find out the longest path, given that you have to move right->left/left->right, you cannot move in the same direction twice, one after the other."
                    },
                    {
                        "username": "vetor",
                        "content": "but its not zigzag\\n"
                    },
                    {
                        "username": "himgupta2197",
                        "content": "The below test case should give 6 as the correct output, but the expected output is 5. how?\\n\\n[6,9,7,3,null,2,8,5,8,9,7,3,9,9,4,2,10,null,5,4,3,10,10,9,4,1,2,null,null,6,5,null,null,null,null,9,null,9,6,5,null,5,null,null,7,7,4,null,1,null,null,3,7,null,9,null,null,null,null,null,null,null,null,9,9,null,null,null,7,null,null,null,null,null,null,null,null,null,6,8,7,null,null,null,3,10,null,null,null,null,null,1,null,1,2]"
                    },
                    {
                        "username": "no947",
                        "content": "I had the same issue. I feel like my code is identical to the answer code. If you every figured out the question can you let me know?"
                    },
                    {
                        "username": "princepatrick",
                        "content": "I was facing the same issue for my previous submissions but rectified the test case later. The issue was let us assume we move to the current node through the left branch with a zig zag score of 3 and if we take a right branch then the score increases to 4 but if we move to the left branch again, then the score needs to reset to 1 again, but my previous code was retaining the score to 3, which was the issue.\\n\\nOn traversing the same direction in a future branch, I reset the score to 1 again. This resolved my issue. Let me know if my explanation was not clear. I will try explain again and better. "
                    },
                    {
                        "username": "mikemaximenko",
                        "content": "I having the same problem. Don\\'t understand it either"
                    },
                    {
                        "username": "malikharshit03",
                        "content": "HINT:\\nThis question can be solved using simple DFS traversal.\\n\\nTraverse in dfs fashion (with parameters current treenode, path and count) and keep track of previous path which took us here. While calling the current path (left or right) increment the count if the paths are different. \\nExample: \\nIf the curr node is brought by path equal to left and we are going to move right, we increment count by 1\\nIf the curr node is brought by path equal to left and we are going to move left, we assign count as 1 because zigzag is interrupted by 2 lefts.\\n\\nWe use the same thought process for 2 cases of path coming from right as well.\\nThroughout the dfs traversal keep updating the max value of count which is the required answer.\\n\\nFor Complete solution refer : https://leetcode.com/problems/longest-zigzag-path-in-a-binary-tree/solutions/3435575/easy-java-dfs-solution-with-explanation/\\n"
                    },
                    {
                        "username": "hosua",
                        "content": "Very helpful, thank you."
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "done so many dp problems lately that I put memoization :) When it was not really needed. \\uD83D\\uDE02"
                    }
                ]
            },
            {
                "id": 1868150,
                "content": [
                    {
                        "username": "Eslam-Soliman",
                        "content": "Looks like the image representation for test case 1 in the description isn't accurate. It doesn't match the one generated under the Testcase tab"
                    },
                    {
                        "username": "prithvi91827",
                        "content": "Although, I solved this question in O(n^2) and giving me TLE but I am glad I solved this."
                    },
                    {
                        "username": "prithvi91827",
                        "content": "[@user3510p](/user3510p) \\nclass Solution {\\npublic:\\n    int maxi = 0;\\n    int f(TreeNode* root, int prevmove){\\n        if(!root) return 0;\\n        if(prevmove == -1){\\n            return max(f(root->left,0),f(root->right,1));\\n        }\\n        else{\\n            if(prevmove == 0){\\n                return 1 + f(root->right,1);\\n            }\\n            else{\\n                return 1 + f(root->left,0);\\n            }\\n        }\\n\\n    }\\n    int longestZigZag(TreeNode* root) {\\n        if(!root) return 0;\\n        int len = f(root,-1);\\n        maxi = max(len,maxi);\\n        longestZigZag(root->left);\\n        longestZigZag(root->right);\\n\\n        return maxi;\\n    }\\n};"
                    },
                    {
                        "username": "user3510p",
                        "content": "can u share the approach"
                    },
                    {
                        "username": "rajat_171",
                        "content": "In this Platform, wherever there is Coding\\u2013 there will always be DP to be found as well - Leetcode Uchiha."
                    },
                    {
                        "username": "A-V-Jagannathan",
                        "content": "[@Mek_san](/Mek_san) lol"
                    },
                    {
                        "username": "Nisarg_Pipaliya",
                        "content": "Those who forget the past, they tend to repeat it - DP Nara"
                    },
                    {
                        "username": "Mek_san",
                        "content": "As long as there is a concept of greedy, dp would also exist. Dp is born in ordered to decrease time in recursion."
                    },
                    {
                        "username": "riyaJha_3624",
                        "content": "This was a tricky one!"
                    },
                    {
                        "username": "karan_cpp_py",
                        "content": "That\\'s how my daily life look like : zig-zag"
                    },
                    {
                        "username": "AlecLC",
                        "content": "# <span style=\\'color:green\\'>Hint</span>\\nUse DFS with a variable that determines direction and flip that variable each iteration"
                    },
                    {
                        "username": "jacksonchen1998",
                        "content": "The first graph\\'s image is wrong. There has another right child."
                    },
                    {
                        "username": "Mister_CK",
                        "content": "[@vetor](/vetor) It is, it just doesn\\'t start in the rootNode"
                    },
                    {
                        "username": "BeniAc",
                        "content": "The image is correct. Take into consideration that you have to find out the longest path, given that you have to move right->left/left->right, you cannot move in the same direction twice, one after the other."
                    },
                    {
                        "username": "vetor",
                        "content": "but its not zigzag\\n"
                    },
                    {
                        "username": "himgupta2197",
                        "content": "The below test case should give 6 as the correct output, but the expected output is 5. how?\\n\\n[6,9,7,3,null,2,8,5,8,9,7,3,9,9,4,2,10,null,5,4,3,10,10,9,4,1,2,null,null,6,5,null,null,null,null,9,null,9,6,5,null,5,null,null,7,7,4,null,1,null,null,3,7,null,9,null,null,null,null,null,null,null,null,9,9,null,null,null,7,null,null,null,null,null,null,null,null,null,6,8,7,null,null,null,3,10,null,null,null,null,null,1,null,1,2]"
                    },
                    {
                        "username": "no947",
                        "content": "I had the same issue. I feel like my code is identical to the answer code. If you every figured out the question can you let me know?"
                    },
                    {
                        "username": "princepatrick",
                        "content": "I was facing the same issue for my previous submissions but rectified the test case later. The issue was let us assume we move to the current node through the left branch with a zig zag score of 3 and if we take a right branch then the score increases to 4 but if we move to the left branch again, then the score needs to reset to 1 again, but my previous code was retaining the score to 3, which was the issue.\\n\\nOn traversing the same direction in a future branch, I reset the score to 1 again. This resolved my issue. Let me know if my explanation was not clear. I will try explain again and better. "
                    },
                    {
                        "username": "mikemaximenko",
                        "content": "I having the same problem. Don\\'t understand it either"
                    },
                    {
                        "username": "malikharshit03",
                        "content": "HINT:\\nThis question can be solved using simple DFS traversal.\\n\\nTraverse in dfs fashion (with parameters current treenode, path and count) and keep track of previous path which took us here. While calling the current path (left or right) increment the count if the paths are different. \\nExample: \\nIf the curr node is brought by path equal to left and we are going to move right, we increment count by 1\\nIf the curr node is brought by path equal to left and we are going to move left, we assign count as 1 because zigzag is interrupted by 2 lefts.\\n\\nWe use the same thought process for 2 cases of path coming from right as well.\\nThroughout the dfs traversal keep updating the max value of count which is the required answer.\\n\\nFor Complete solution refer : https://leetcode.com/problems/longest-zigzag-path-in-a-binary-tree/solutions/3435575/easy-java-dfs-solution-with-explanation/\\n"
                    },
                    {
                        "username": "hosua",
                        "content": "Very helpful, thank you."
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "done so many dp problems lately that I put memoization :) When it was not really needed. \\uD83D\\uDE02"
                    }
                ]
            },
            {
                "id": 1868053,
                "content": [
                    {
                        "username": "Eslam-Soliman",
                        "content": "Looks like the image representation for test case 1 in the description isn't accurate. It doesn't match the one generated under the Testcase tab"
                    },
                    {
                        "username": "prithvi91827",
                        "content": "Although, I solved this question in O(n^2) and giving me TLE but I am glad I solved this."
                    },
                    {
                        "username": "prithvi91827",
                        "content": "[@user3510p](/user3510p) \\nclass Solution {\\npublic:\\n    int maxi = 0;\\n    int f(TreeNode* root, int prevmove){\\n        if(!root) return 0;\\n        if(prevmove == -1){\\n            return max(f(root->left,0),f(root->right,1));\\n        }\\n        else{\\n            if(prevmove == 0){\\n                return 1 + f(root->right,1);\\n            }\\n            else{\\n                return 1 + f(root->left,0);\\n            }\\n        }\\n\\n    }\\n    int longestZigZag(TreeNode* root) {\\n        if(!root) return 0;\\n        int len = f(root,-1);\\n        maxi = max(len,maxi);\\n        longestZigZag(root->left);\\n        longestZigZag(root->right);\\n\\n        return maxi;\\n    }\\n};"
                    },
                    {
                        "username": "user3510p",
                        "content": "can u share the approach"
                    },
                    {
                        "username": "rajat_171",
                        "content": "In this Platform, wherever there is Coding\\u2013 there will always be DP to be found as well - Leetcode Uchiha."
                    },
                    {
                        "username": "A-V-Jagannathan",
                        "content": "[@Mek_san](/Mek_san) lol"
                    },
                    {
                        "username": "Nisarg_Pipaliya",
                        "content": "Those who forget the past, they tend to repeat it - DP Nara"
                    },
                    {
                        "username": "Mek_san",
                        "content": "As long as there is a concept of greedy, dp would also exist. Dp is born in ordered to decrease time in recursion."
                    },
                    {
                        "username": "riyaJha_3624",
                        "content": "This was a tricky one!"
                    },
                    {
                        "username": "karan_cpp_py",
                        "content": "That\\'s how my daily life look like : zig-zag"
                    },
                    {
                        "username": "AlecLC",
                        "content": "# <span style=\\'color:green\\'>Hint</span>\\nUse DFS with a variable that determines direction and flip that variable each iteration"
                    },
                    {
                        "username": "jacksonchen1998",
                        "content": "The first graph\\'s image is wrong. There has another right child."
                    },
                    {
                        "username": "Mister_CK",
                        "content": "[@vetor](/vetor) It is, it just doesn\\'t start in the rootNode"
                    },
                    {
                        "username": "BeniAc",
                        "content": "The image is correct. Take into consideration that you have to find out the longest path, given that you have to move right->left/left->right, you cannot move in the same direction twice, one after the other."
                    },
                    {
                        "username": "vetor",
                        "content": "but its not zigzag\\n"
                    },
                    {
                        "username": "himgupta2197",
                        "content": "The below test case should give 6 as the correct output, but the expected output is 5. how?\\n\\n[6,9,7,3,null,2,8,5,8,9,7,3,9,9,4,2,10,null,5,4,3,10,10,9,4,1,2,null,null,6,5,null,null,null,null,9,null,9,6,5,null,5,null,null,7,7,4,null,1,null,null,3,7,null,9,null,null,null,null,null,null,null,null,9,9,null,null,null,7,null,null,null,null,null,null,null,null,null,6,8,7,null,null,null,3,10,null,null,null,null,null,1,null,1,2]"
                    },
                    {
                        "username": "no947",
                        "content": "I had the same issue. I feel like my code is identical to the answer code. If you every figured out the question can you let me know?"
                    },
                    {
                        "username": "princepatrick",
                        "content": "I was facing the same issue for my previous submissions but rectified the test case later. The issue was let us assume we move to the current node through the left branch with a zig zag score of 3 and if we take a right branch then the score increases to 4 but if we move to the left branch again, then the score needs to reset to 1 again, but my previous code was retaining the score to 3, which was the issue.\\n\\nOn traversing the same direction in a future branch, I reset the score to 1 again. This resolved my issue. Let me know if my explanation was not clear. I will try explain again and better. "
                    },
                    {
                        "username": "mikemaximenko",
                        "content": "I having the same problem. Don\\'t understand it either"
                    },
                    {
                        "username": "malikharshit03",
                        "content": "HINT:\\nThis question can be solved using simple DFS traversal.\\n\\nTraverse in dfs fashion (with parameters current treenode, path and count) and keep track of previous path which took us here. While calling the current path (left or right) increment the count if the paths are different. \\nExample: \\nIf the curr node is brought by path equal to left and we are going to move right, we increment count by 1\\nIf the curr node is brought by path equal to left and we are going to move left, we assign count as 1 because zigzag is interrupted by 2 lefts.\\n\\nWe use the same thought process for 2 cases of path coming from right as well.\\nThroughout the dfs traversal keep updating the max value of count which is the required answer.\\n\\nFor Complete solution refer : https://leetcode.com/problems/longest-zigzag-path-in-a-binary-tree/solutions/3435575/easy-java-dfs-solution-with-explanation/\\n"
                    },
                    {
                        "username": "hosua",
                        "content": "Very helpful, thank you."
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "done so many dp problems lately that I put memoization :) When it was not really needed. \\uD83D\\uDE02"
                    }
                ]
            },
            {
                "id": 1868857,
                "content": [
                    {
                        "username": "Eslam-Soliman",
                        "content": "Looks like the image representation for test case 1 in the description isn't accurate. It doesn't match the one generated under the Testcase tab"
                    },
                    {
                        "username": "prithvi91827",
                        "content": "Although, I solved this question in O(n^2) and giving me TLE but I am glad I solved this."
                    },
                    {
                        "username": "prithvi91827",
                        "content": "[@user3510p](/user3510p) \\nclass Solution {\\npublic:\\n    int maxi = 0;\\n    int f(TreeNode* root, int prevmove){\\n        if(!root) return 0;\\n        if(prevmove == -1){\\n            return max(f(root->left,0),f(root->right,1));\\n        }\\n        else{\\n            if(prevmove == 0){\\n                return 1 + f(root->right,1);\\n            }\\n            else{\\n                return 1 + f(root->left,0);\\n            }\\n        }\\n\\n    }\\n    int longestZigZag(TreeNode* root) {\\n        if(!root) return 0;\\n        int len = f(root,-1);\\n        maxi = max(len,maxi);\\n        longestZigZag(root->left);\\n        longestZigZag(root->right);\\n\\n        return maxi;\\n    }\\n};"
                    },
                    {
                        "username": "user3510p",
                        "content": "can u share the approach"
                    },
                    {
                        "username": "rajat_171",
                        "content": "In this Platform, wherever there is Coding\\u2013 there will always be DP to be found as well - Leetcode Uchiha."
                    },
                    {
                        "username": "A-V-Jagannathan",
                        "content": "[@Mek_san](/Mek_san) lol"
                    },
                    {
                        "username": "Nisarg_Pipaliya",
                        "content": "Those who forget the past, they tend to repeat it - DP Nara"
                    },
                    {
                        "username": "Mek_san",
                        "content": "As long as there is a concept of greedy, dp would also exist. Dp is born in ordered to decrease time in recursion."
                    },
                    {
                        "username": "riyaJha_3624",
                        "content": "This was a tricky one!"
                    },
                    {
                        "username": "karan_cpp_py",
                        "content": "That\\'s how my daily life look like : zig-zag"
                    },
                    {
                        "username": "AlecLC",
                        "content": "# <span style=\\'color:green\\'>Hint</span>\\nUse DFS with a variable that determines direction and flip that variable each iteration"
                    },
                    {
                        "username": "jacksonchen1998",
                        "content": "The first graph\\'s image is wrong. There has another right child."
                    },
                    {
                        "username": "Mister_CK",
                        "content": "[@vetor](/vetor) It is, it just doesn\\'t start in the rootNode"
                    },
                    {
                        "username": "BeniAc",
                        "content": "The image is correct. Take into consideration that you have to find out the longest path, given that you have to move right->left/left->right, you cannot move in the same direction twice, one after the other."
                    },
                    {
                        "username": "vetor",
                        "content": "but its not zigzag\\n"
                    },
                    {
                        "username": "himgupta2197",
                        "content": "The below test case should give 6 as the correct output, but the expected output is 5. how?\\n\\n[6,9,7,3,null,2,8,5,8,9,7,3,9,9,4,2,10,null,5,4,3,10,10,9,4,1,2,null,null,6,5,null,null,null,null,9,null,9,6,5,null,5,null,null,7,7,4,null,1,null,null,3,7,null,9,null,null,null,null,null,null,null,null,9,9,null,null,null,7,null,null,null,null,null,null,null,null,null,6,8,7,null,null,null,3,10,null,null,null,null,null,1,null,1,2]"
                    },
                    {
                        "username": "no947",
                        "content": "I had the same issue. I feel like my code is identical to the answer code. If you every figured out the question can you let me know?"
                    },
                    {
                        "username": "princepatrick",
                        "content": "I was facing the same issue for my previous submissions but rectified the test case later. The issue was let us assume we move to the current node through the left branch with a zig zag score of 3 and if we take a right branch then the score increases to 4 but if we move to the left branch again, then the score needs to reset to 1 again, but my previous code was retaining the score to 3, which was the issue.\\n\\nOn traversing the same direction in a future branch, I reset the score to 1 again. This resolved my issue. Let me know if my explanation was not clear. I will try explain again and better. "
                    },
                    {
                        "username": "mikemaximenko",
                        "content": "I having the same problem. Don\\'t understand it either"
                    },
                    {
                        "username": "malikharshit03",
                        "content": "HINT:\\nThis question can be solved using simple DFS traversal.\\n\\nTraverse in dfs fashion (with parameters current treenode, path and count) and keep track of previous path which took us here. While calling the current path (left or right) increment the count if the paths are different. \\nExample: \\nIf the curr node is brought by path equal to left and we are going to move right, we increment count by 1\\nIf the curr node is brought by path equal to left and we are going to move left, we assign count as 1 because zigzag is interrupted by 2 lefts.\\n\\nWe use the same thought process for 2 cases of path coming from right as well.\\nThroughout the dfs traversal keep updating the max value of count which is the required answer.\\n\\nFor Complete solution refer : https://leetcode.com/problems/longest-zigzag-path-in-a-binary-tree/solutions/3435575/easy-java-dfs-solution-with-explanation/\\n"
                    },
                    {
                        "username": "hosua",
                        "content": "Very helpful, thank you."
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "done so many dp problems lately that I put memoization :) When it was not really needed. \\uD83D\\uDE02"
                    }
                ]
            },
            {
                "id": 1868595,
                "content": [
                    {
                        "username": "Eslam-Soliman",
                        "content": "Looks like the image representation for test case 1 in the description isn't accurate. It doesn't match the one generated under the Testcase tab"
                    },
                    {
                        "username": "prithvi91827",
                        "content": "Although, I solved this question in O(n^2) and giving me TLE but I am glad I solved this."
                    },
                    {
                        "username": "prithvi91827",
                        "content": "[@user3510p](/user3510p) \\nclass Solution {\\npublic:\\n    int maxi = 0;\\n    int f(TreeNode* root, int prevmove){\\n        if(!root) return 0;\\n        if(prevmove == -1){\\n            return max(f(root->left,0),f(root->right,1));\\n        }\\n        else{\\n            if(prevmove == 0){\\n                return 1 + f(root->right,1);\\n            }\\n            else{\\n                return 1 + f(root->left,0);\\n            }\\n        }\\n\\n    }\\n    int longestZigZag(TreeNode* root) {\\n        if(!root) return 0;\\n        int len = f(root,-1);\\n        maxi = max(len,maxi);\\n        longestZigZag(root->left);\\n        longestZigZag(root->right);\\n\\n        return maxi;\\n    }\\n};"
                    },
                    {
                        "username": "user3510p",
                        "content": "can u share the approach"
                    },
                    {
                        "username": "rajat_171",
                        "content": "In this Platform, wherever there is Coding\\u2013 there will always be DP to be found as well - Leetcode Uchiha."
                    },
                    {
                        "username": "A-V-Jagannathan",
                        "content": "[@Mek_san](/Mek_san) lol"
                    },
                    {
                        "username": "Nisarg_Pipaliya",
                        "content": "Those who forget the past, they tend to repeat it - DP Nara"
                    },
                    {
                        "username": "Mek_san",
                        "content": "As long as there is a concept of greedy, dp would also exist. Dp is born in ordered to decrease time in recursion."
                    },
                    {
                        "username": "riyaJha_3624",
                        "content": "This was a tricky one!"
                    },
                    {
                        "username": "karan_cpp_py",
                        "content": "That\\'s how my daily life look like : zig-zag"
                    },
                    {
                        "username": "AlecLC",
                        "content": "# <span style=\\'color:green\\'>Hint</span>\\nUse DFS with a variable that determines direction and flip that variable each iteration"
                    },
                    {
                        "username": "jacksonchen1998",
                        "content": "The first graph\\'s image is wrong. There has another right child."
                    },
                    {
                        "username": "Mister_CK",
                        "content": "[@vetor](/vetor) It is, it just doesn\\'t start in the rootNode"
                    },
                    {
                        "username": "BeniAc",
                        "content": "The image is correct. Take into consideration that you have to find out the longest path, given that you have to move right->left/left->right, you cannot move in the same direction twice, one after the other."
                    },
                    {
                        "username": "vetor",
                        "content": "but its not zigzag\\n"
                    },
                    {
                        "username": "himgupta2197",
                        "content": "The below test case should give 6 as the correct output, but the expected output is 5. how?\\n\\n[6,9,7,3,null,2,8,5,8,9,7,3,9,9,4,2,10,null,5,4,3,10,10,9,4,1,2,null,null,6,5,null,null,null,null,9,null,9,6,5,null,5,null,null,7,7,4,null,1,null,null,3,7,null,9,null,null,null,null,null,null,null,null,9,9,null,null,null,7,null,null,null,null,null,null,null,null,null,6,8,7,null,null,null,3,10,null,null,null,null,null,1,null,1,2]"
                    },
                    {
                        "username": "no947",
                        "content": "I had the same issue. I feel like my code is identical to the answer code. If you every figured out the question can you let me know?"
                    },
                    {
                        "username": "princepatrick",
                        "content": "I was facing the same issue for my previous submissions but rectified the test case later. The issue was let us assume we move to the current node through the left branch with a zig zag score of 3 and if we take a right branch then the score increases to 4 but if we move to the left branch again, then the score needs to reset to 1 again, but my previous code was retaining the score to 3, which was the issue.\\n\\nOn traversing the same direction in a future branch, I reset the score to 1 again. This resolved my issue. Let me know if my explanation was not clear. I will try explain again and better. "
                    },
                    {
                        "username": "mikemaximenko",
                        "content": "I having the same problem. Don\\'t understand it either"
                    },
                    {
                        "username": "malikharshit03",
                        "content": "HINT:\\nThis question can be solved using simple DFS traversal.\\n\\nTraverse in dfs fashion (with parameters current treenode, path and count) and keep track of previous path which took us here. While calling the current path (left or right) increment the count if the paths are different. \\nExample: \\nIf the curr node is brought by path equal to left and we are going to move right, we increment count by 1\\nIf the curr node is brought by path equal to left and we are going to move left, we assign count as 1 because zigzag is interrupted by 2 lefts.\\n\\nWe use the same thought process for 2 cases of path coming from right as well.\\nThroughout the dfs traversal keep updating the max value of count which is the required answer.\\n\\nFor Complete solution refer : https://leetcode.com/problems/longest-zigzag-path-in-a-binary-tree/solutions/3435575/easy-java-dfs-solution-with-explanation/\\n"
                    },
                    {
                        "username": "hosua",
                        "content": "Very helpful, thank you."
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "done so many dp problems lately that I put memoization :) When it was not really needed. \\uD83D\\uDE02"
                    }
                ]
            },
            {
                "id": 1868285,
                "content": [
                    {
                        "username": "Eslam-Soliman",
                        "content": "Looks like the image representation for test case 1 in the description isn't accurate. It doesn't match the one generated under the Testcase tab"
                    },
                    {
                        "username": "prithvi91827",
                        "content": "Although, I solved this question in O(n^2) and giving me TLE but I am glad I solved this."
                    },
                    {
                        "username": "prithvi91827",
                        "content": "[@user3510p](/user3510p) \\nclass Solution {\\npublic:\\n    int maxi = 0;\\n    int f(TreeNode* root, int prevmove){\\n        if(!root) return 0;\\n        if(prevmove == -1){\\n            return max(f(root->left,0),f(root->right,1));\\n        }\\n        else{\\n            if(prevmove == 0){\\n                return 1 + f(root->right,1);\\n            }\\n            else{\\n                return 1 + f(root->left,0);\\n            }\\n        }\\n\\n    }\\n    int longestZigZag(TreeNode* root) {\\n        if(!root) return 0;\\n        int len = f(root,-1);\\n        maxi = max(len,maxi);\\n        longestZigZag(root->left);\\n        longestZigZag(root->right);\\n\\n        return maxi;\\n    }\\n};"
                    },
                    {
                        "username": "user3510p",
                        "content": "can u share the approach"
                    },
                    {
                        "username": "rajat_171",
                        "content": "In this Platform, wherever there is Coding\\u2013 there will always be DP to be found as well - Leetcode Uchiha."
                    },
                    {
                        "username": "A-V-Jagannathan",
                        "content": "[@Mek_san](/Mek_san) lol"
                    },
                    {
                        "username": "Nisarg_Pipaliya",
                        "content": "Those who forget the past, they tend to repeat it - DP Nara"
                    },
                    {
                        "username": "Mek_san",
                        "content": "As long as there is a concept of greedy, dp would also exist. Dp is born in ordered to decrease time in recursion."
                    },
                    {
                        "username": "riyaJha_3624",
                        "content": "This was a tricky one!"
                    },
                    {
                        "username": "karan_cpp_py",
                        "content": "That\\'s how my daily life look like : zig-zag"
                    },
                    {
                        "username": "AlecLC",
                        "content": "# <span style=\\'color:green\\'>Hint</span>\\nUse DFS with a variable that determines direction and flip that variable each iteration"
                    },
                    {
                        "username": "jacksonchen1998",
                        "content": "The first graph\\'s image is wrong. There has another right child."
                    },
                    {
                        "username": "Mister_CK",
                        "content": "[@vetor](/vetor) It is, it just doesn\\'t start in the rootNode"
                    },
                    {
                        "username": "BeniAc",
                        "content": "The image is correct. Take into consideration that you have to find out the longest path, given that you have to move right->left/left->right, you cannot move in the same direction twice, one after the other."
                    },
                    {
                        "username": "vetor",
                        "content": "but its not zigzag\\n"
                    },
                    {
                        "username": "himgupta2197",
                        "content": "The below test case should give 6 as the correct output, but the expected output is 5. how?\\n\\n[6,9,7,3,null,2,8,5,8,9,7,3,9,9,4,2,10,null,5,4,3,10,10,9,4,1,2,null,null,6,5,null,null,null,null,9,null,9,6,5,null,5,null,null,7,7,4,null,1,null,null,3,7,null,9,null,null,null,null,null,null,null,null,9,9,null,null,null,7,null,null,null,null,null,null,null,null,null,6,8,7,null,null,null,3,10,null,null,null,null,null,1,null,1,2]"
                    },
                    {
                        "username": "no947",
                        "content": "I had the same issue. I feel like my code is identical to the answer code. If you every figured out the question can you let me know?"
                    },
                    {
                        "username": "princepatrick",
                        "content": "I was facing the same issue for my previous submissions but rectified the test case later. The issue was let us assume we move to the current node through the left branch with a zig zag score of 3 and if we take a right branch then the score increases to 4 but if we move to the left branch again, then the score needs to reset to 1 again, but my previous code was retaining the score to 3, which was the issue.\\n\\nOn traversing the same direction in a future branch, I reset the score to 1 again. This resolved my issue. Let me know if my explanation was not clear. I will try explain again and better. "
                    },
                    {
                        "username": "mikemaximenko",
                        "content": "I having the same problem. Don\\'t understand it either"
                    },
                    {
                        "username": "malikharshit03",
                        "content": "HINT:\\nThis question can be solved using simple DFS traversal.\\n\\nTraverse in dfs fashion (with parameters current treenode, path and count) and keep track of previous path which took us here. While calling the current path (left or right) increment the count if the paths are different. \\nExample: \\nIf the curr node is brought by path equal to left and we are going to move right, we increment count by 1\\nIf the curr node is brought by path equal to left and we are going to move left, we assign count as 1 because zigzag is interrupted by 2 lefts.\\n\\nWe use the same thought process for 2 cases of path coming from right as well.\\nThroughout the dfs traversal keep updating the max value of count which is the required answer.\\n\\nFor Complete solution refer : https://leetcode.com/problems/longest-zigzag-path-in-a-binary-tree/solutions/3435575/easy-java-dfs-solution-with-explanation/\\n"
                    },
                    {
                        "username": "hosua",
                        "content": "Very helpful, thank you."
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "done so many dp problems lately that I put memoization :) When it was not really needed. \\uD83D\\uDE02"
                    }
                ]
            },
            {
                "id": 1868005,
                "content": [
                    {
                        "username": "UchihaKim",
                        "content": "And the storm begin... I hope not"
                    },
                    {
                        "username": "ignorant_ppp",
                        "content": "Yeah..it is..!!"
                    },
                    {
                        "username": "iamprashantmmishra",
                        "content": "This one was really interesting. Just try with a recursive solution and maintain left and right lengths and pass it accordingly if you are going to the left side or right side and return max of the 2 calls. "
                    },
                    {
                        "username": "najwer23",
                        "content": "i hate graphs "
                    },
                    {
                        "username": "hosua",
                        "content": "This isn\\'t even a graph problem"
                    },
                    {
                        "username": "foodsnow",
                        "content": "It\\'s easier to solve it after you write simple dfs traversal "
                    },
                    {
                        "username": "anwendeng",
                        "content": "I wrote a code to find the maximal length of the tree. \nAnd I want to modify it to solve the problem. ` int pathLen=0;\n    void dfs(TreeNode* Node, int level){\n        if (Node==NULL) return ;\n        cout<<Node->val<<\",level=\"<<level<<endl;\n        pathLen=max(pathLen, level);\n        dfs(Node->left, level+1);\n        dfs(Node->right, level+1);.`  "
                    },
                    {
                        "username": "anwendeng",
                        "content": "So, the modification goes well. https://leetcode.com/problems/longest-zigzag-path-in-a-binary-tree/solutions/3433226/easy-c-solution/\\n\\nLater, I will try to optimize "
                    },
                    {
                        "username": "Kiy0taka_Ayanak0ji",
                        "content": "Maintain a boolean:\n```cpp\nint maxZig(TreeNode* root , bool isRight = true,int height)\n```"
                    },
                    {
                        "username": "breathermachine",
                        "content": "You\\'ll need to pass in the direction to your recursive call as well. \\n```\\nint longestZigZag(TreeNode *node, int direction) {\\n```"
                    },
                    {
                        "username": "Firebelias12",
                        "content": "This should be an easy."
                    },
                    {
                        "username": "Athanasios-Kataras",
                        "content": "Are you sure it wasn't one of those cases that the solution just came to you easily? It is a bit tricky to get the alternating paths when they don't just start from root. Easy are generally items with no tricky parts."
                    },
                    {
                        "username": "satyamS_71",
                        "content": "Hey there to PROs ! I was able to come up with a solution for this question which was ~ 90% correct in my first try ,under almost 10 minutes . IS THIS A WIN?  "
                    },
                    {
                        "username": "amanrushed",
                        "content": "This is tricky"
                    },
                    {
                        "username": "codetogrow",
                        "content": "This problem needs some clarification!\\nWe are not being asked the length of the longest path. We have to find the longest \"zigzag\" path!\\n\\nA zigzag path is a path where the direction between every two consecutive nodes alternates, i.e., if we went right from the current node to get to the next node, then from the next node, we should go left to get to the next node after that, and vice versa.\\n\\nThat is why the testcase\\n[1,null,1,1,1,null,null,1,1,null,1,null,null,null,1]\\n\\nmust yield the output 3 instead of 5."
                    },
                    {
                        "username": "prats02",
                        "content": "why is this wrong?\\n\\nclass Solution {\\npublic:\\n    int fn(TreeNode* root,int n){\\n        if(root==NULL) return 0;\\n        if(n==1){\\n            return max((1+fn(root->right,2)),fn(root->left,1));\\n        }\\n        else{\\n            return max((1+fn(root->left,1)),fn(root->right,2));\\n        }\\n    }\\n    int longestZigZag(TreeNode* root) {\\n        return max(fn(root->left,1),fn(root->right,2));\\n    }\\n};"
                    },
                    {
                        "username": "rawatvishal",
                        "content": "the question says \"Choose any node in the binary tree and a direction (right or left)\" \\ninside the longest-zigzag func( fo dfs). \\n\\n\\ni mean - \\nint longestZigZag(TreeNode* root) {\\nreturn max(fn(root->left,1),fn(root->right,2)); // modify this lil bit\\nlongestZigZag(root->left);\\nlongestZigZag(root->right);\\n}\\n};"
                    }
                ]
            },
            {
                "id": 2069060,
                "content": [
                    {
                        "username": "UchihaKim",
                        "content": "And the storm begin... I hope not"
                    },
                    {
                        "username": "ignorant_ppp",
                        "content": "Yeah..it is..!!"
                    },
                    {
                        "username": "iamprashantmmishra",
                        "content": "This one was really interesting. Just try with a recursive solution and maintain left and right lengths and pass it accordingly if you are going to the left side or right side and return max of the 2 calls. "
                    },
                    {
                        "username": "najwer23",
                        "content": "i hate graphs "
                    },
                    {
                        "username": "hosua",
                        "content": "This isn\\'t even a graph problem"
                    },
                    {
                        "username": "foodsnow",
                        "content": "It\\'s easier to solve it after you write simple dfs traversal "
                    },
                    {
                        "username": "anwendeng",
                        "content": "I wrote a code to find the maximal length of the tree. \nAnd I want to modify it to solve the problem. ` int pathLen=0;\n    void dfs(TreeNode* Node, int level){\n        if (Node==NULL) return ;\n        cout<<Node->val<<\",level=\"<<level<<endl;\n        pathLen=max(pathLen, level);\n        dfs(Node->left, level+1);\n        dfs(Node->right, level+1);.`  "
                    },
                    {
                        "username": "anwendeng",
                        "content": "So, the modification goes well. https://leetcode.com/problems/longest-zigzag-path-in-a-binary-tree/solutions/3433226/easy-c-solution/\\n\\nLater, I will try to optimize "
                    },
                    {
                        "username": "Kiy0taka_Ayanak0ji",
                        "content": "Maintain a boolean:\n```cpp\nint maxZig(TreeNode* root , bool isRight = true,int height)\n```"
                    },
                    {
                        "username": "breathermachine",
                        "content": "You\\'ll need to pass in the direction to your recursive call as well. \\n```\\nint longestZigZag(TreeNode *node, int direction) {\\n```"
                    },
                    {
                        "username": "Firebelias12",
                        "content": "This should be an easy."
                    },
                    {
                        "username": "Athanasios-Kataras",
                        "content": "Are you sure it wasn't one of those cases that the solution just came to you easily? It is a bit tricky to get the alternating paths when they don't just start from root. Easy are generally items with no tricky parts."
                    },
                    {
                        "username": "satyamS_71",
                        "content": "Hey there to PROs ! I was able to come up with a solution for this question which was ~ 90% correct in my first try ,under almost 10 minutes . IS THIS A WIN?  "
                    },
                    {
                        "username": "amanrushed",
                        "content": "This is tricky"
                    },
                    {
                        "username": "codetogrow",
                        "content": "This problem needs some clarification!\\nWe are not being asked the length of the longest path. We have to find the longest \"zigzag\" path!\\n\\nA zigzag path is a path where the direction between every two consecutive nodes alternates, i.e., if we went right from the current node to get to the next node, then from the next node, we should go left to get to the next node after that, and vice versa.\\n\\nThat is why the testcase\\n[1,null,1,1,1,null,null,1,1,null,1,null,null,null,1]\\n\\nmust yield the output 3 instead of 5."
                    },
                    {
                        "username": "prats02",
                        "content": "why is this wrong?\\n\\nclass Solution {\\npublic:\\n    int fn(TreeNode* root,int n){\\n        if(root==NULL) return 0;\\n        if(n==1){\\n            return max((1+fn(root->right,2)),fn(root->left,1));\\n        }\\n        else{\\n            return max((1+fn(root->left,1)),fn(root->right,2));\\n        }\\n    }\\n    int longestZigZag(TreeNode* root) {\\n        return max(fn(root->left,1),fn(root->right,2));\\n    }\\n};"
                    },
                    {
                        "username": "rawatvishal",
                        "content": "the question says \"Choose any node in the binary tree and a direction (right or left)\" \\ninside the longest-zigzag func( fo dfs). \\n\\n\\ni mean - \\nint longestZigZag(TreeNode* root) {\\nreturn max(fn(root->left,1),fn(root->right,2)); // modify this lil bit\\nlongestZigZag(root->left);\\nlongestZigZag(root->right);\\n}\\n};"
                    }
                ]
            },
            {
                "id": 1868638,
                "content": [
                    {
                        "username": "UchihaKim",
                        "content": "And the storm begin... I hope not"
                    },
                    {
                        "username": "ignorant_ppp",
                        "content": "Yeah..it is..!!"
                    },
                    {
                        "username": "iamprashantmmishra",
                        "content": "This one was really interesting. Just try with a recursive solution and maintain left and right lengths and pass it accordingly if you are going to the left side or right side and return max of the 2 calls. "
                    },
                    {
                        "username": "najwer23",
                        "content": "i hate graphs "
                    },
                    {
                        "username": "hosua",
                        "content": "This isn\\'t even a graph problem"
                    },
                    {
                        "username": "foodsnow",
                        "content": "It\\'s easier to solve it after you write simple dfs traversal "
                    },
                    {
                        "username": "anwendeng",
                        "content": "I wrote a code to find the maximal length of the tree. \nAnd I want to modify it to solve the problem. ` int pathLen=0;\n    void dfs(TreeNode* Node, int level){\n        if (Node==NULL) return ;\n        cout<<Node->val<<\",level=\"<<level<<endl;\n        pathLen=max(pathLen, level);\n        dfs(Node->left, level+1);\n        dfs(Node->right, level+1);.`  "
                    },
                    {
                        "username": "anwendeng",
                        "content": "So, the modification goes well. https://leetcode.com/problems/longest-zigzag-path-in-a-binary-tree/solutions/3433226/easy-c-solution/\\n\\nLater, I will try to optimize "
                    },
                    {
                        "username": "Kiy0taka_Ayanak0ji",
                        "content": "Maintain a boolean:\n```cpp\nint maxZig(TreeNode* root , bool isRight = true,int height)\n```"
                    },
                    {
                        "username": "breathermachine",
                        "content": "You\\'ll need to pass in the direction to your recursive call as well. \\n```\\nint longestZigZag(TreeNode *node, int direction) {\\n```"
                    },
                    {
                        "username": "Firebelias12",
                        "content": "This should be an easy."
                    },
                    {
                        "username": "Athanasios-Kataras",
                        "content": "Are you sure it wasn't one of those cases that the solution just came to you easily? It is a bit tricky to get the alternating paths when they don't just start from root. Easy are generally items with no tricky parts."
                    },
                    {
                        "username": "satyamS_71",
                        "content": "Hey there to PROs ! I was able to come up with a solution for this question which was ~ 90% correct in my first try ,under almost 10 minutes . IS THIS A WIN?  "
                    },
                    {
                        "username": "amanrushed",
                        "content": "This is tricky"
                    },
                    {
                        "username": "codetogrow",
                        "content": "This problem needs some clarification!\\nWe are not being asked the length of the longest path. We have to find the longest \"zigzag\" path!\\n\\nA zigzag path is a path where the direction between every two consecutive nodes alternates, i.e., if we went right from the current node to get to the next node, then from the next node, we should go left to get to the next node after that, and vice versa.\\n\\nThat is why the testcase\\n[1,null,1,1,1,null,null,1,1,null,1,null,null,null,1]\\n\\nmust yield the output 3 instead of 5."
                    },
                    {
                        "username": "prats02",
                        "content": "why is this wrong?\\n\\nclass Solution {\\npublic:\\n    int fn(TreeNode* root,int n){\\n        if(root==NULL) return 0;\\n        if(n==1){\\n            return max((1+fn(root->right,2)),fn(root->left,1));\\n        }\\n        else{\\n            return max((1+fn(root->left,1)),fn(root->right,2));\\n        }\\n    }\\n    int longestZigZag(TreeNode* root) {\\n        return max(fn(root->left,1),fn(root->right,2));\\n    }\\n};"
                    },
                    {
                        "username": "rawatvishal",
                        "content": "the question says \"Choose any node in the binary tree and a direction (right or left)\" \\ninside the longest-zigzag func( fo dfs). \\n\\n\\ni mean - \\nint longestZigZag(TreeNode* root) {\\nreturn max(fn(root->left,1),fn(root->right,2)); // modify this lil bit\\nlongestZigZag(root->left);\\nlongestZigZag(root->right);\\n}\\n};"
                    }
                ]
            },
            {
                "id": 1868250,
                "content": [
                    {
                        "username": "UchihaKim",
                        "content": "And the storm begin... I hope not"
                    },
                    {
                        "username": "ignorant_ppp",
                        "content": "Yeah..it is..!!"
                    },
                    {
                        "username": "iamprashantmmishra",
                        "content": "This one was really interesting. Just try with a recursive solution and maintain left and right lengths and pass it accordingly if you are going to the left side or right side and return max of the 2 calls. "
                    },
                    {
                        "username": "najwer23",
                        "content": "i hate graphs "
                    },
                    {
                        "username": "hosua",
                        "content": "This isn\\'t even a graph problem"
                    },
                    {
                        "username": "foodsnow",
                        "content": "It\\'s easier to solve it after you write simple dfs traversal "
                    },
                    {
                        "username": "anwendeng",
                        "content": "I wrote a code to find the maximal length of the tree. \nAnd I want to modify it to solve the problem. ` int pathLen=0;\n    void dfs(TreeNode* Node, int level){\n        if (Node==NULL) return ;\n        cout<<Node->val<<\",level=\"<<level<<endl;\n        pathLen=max(pathLen, level);\n        dfs(Node->left, level+1);\n        dfs(Node->right, level+1);.`  "
                    },
                    {
                        "username": "anwendeng",
                        "content": "So, the modification goes well. https://leetcode.com/problems/longest-zigzag-path-in-a-binary-tree/solutions/3433226/easy-c-solution/\\n\\nLater, I will try to optimize "
                    },
                    {
                        "username": "Kiy0taka_Ayanak0ji",
                        "content": "Maintain a boolean:\n```cpp\nint maxZig(TreeNode* root , bool isRight = true,int height)\n```"
                    },
                    {
                        "username": "breathermachine",
                        "content": "You\\'ll need to pass in the direction to your recursive call as well. \\n```\\nint longestZigZag(TreeNode *node, int direction) {\\n```"
                    },
                    {
                        "username": "Firebelias12",
                        "content": "This should be an easy."
                    },
                    {
                        "username": "Athanasios-Kataras",
                        "content": "Are you sure it wasn't one of those cases that the solution just came to you easily? It is a bit tricky to get the alternating paths when they don't just start from root. Easy are generally items with no tricky parts."
                    },
                    {
                        "username": "satyamS_71",
                        "content": "Hey there to PROs ! I was able to come up with a solution for this question which was ~ 90% correct in my first try ,under almost 10 minutes . IS THIS A WIN?  "
                    },
                    {
                        "username": "amanrushed",
                        "content": "This is tricky"
                    },
                    {
                        "username": "codetogrow",
                        "content": "This problem needs some clarification!\\nWe are not being asked the length of the longest path. We have to find the longest \"zigzag\" path!\\n\\nA zigzag path is a path where the direction between every two consecutive nodes alternates, i.e., if we went right from the current node to get to the next node, then from the next node, we should go left to get to the next node after that, and vice versa.\\n\\nThat is why the testcase\\n[1,null,1,1,1,null,null,1,1,null,1,null,null,null,1]\\n\\nmust yield the output 3 instead of 5."
                    },
                    {
                        "username": "prats02",
                        "content": "why is this wrong?\\n\\nclass Solution {\\npublic:\\n    int fn(TreeNode* root,int n){\\n        if(root==NULL) return 0;\\n        if(n==1){\\n            return max((1+fn(root->right,2)),fn(root->left,1));\\n        }\\n        else{\\n            return max((1+fn(root->left,1)),fn(root->right,2));\\n        }\\n    }\\n    int longestZigZag(TreeNode* root) {\\n        return max(fn(root->left,1),fn(root->right,2));\\n    }\\n};"
                    },
                    {
                        "username": "rawatvishal",
                        "content": "the question says \"Choose any node in the binary tree and a direction (right or left)\" \\ninside the longest-zigzag func( fo dfs). \\n\\n\\ni mean - \\nint longestZigZag(TreeNode* root) {\\nreturn max(fn(root->left,1),fn(root->right,2)); // modify this lil bit\\nlongestZigZag(root->left);\\nlongestZigZag(root->right);\\n}\\n};"
                    }
                ]
            },
            {
                "id": 1868030,
                "content": [
                    {
                        "username": "UchihaKim",
                        "content": "And the storm begin... I hope not"
                    },
                    {
                        "username": "ignorant_ppp",
                        "content": "Yeah..it is..!!"
                    },
                    {
                        "username": "iamprashantmmishra",
                        "content": "This one was really interesting. Just try with a recursive solution and maintain left and right lengths and pass it accordingly if you are going to the left side or right side and return max of the 2 calls. "
                    },
                    {
                        "username": "najwer23",
                        "content": "i hate graphs "
                    },
                    {
                        "username": "hosua",
                        "content": "This isn\\'t even a graph problem"
                    },
                    {
                        "username": "foodsnow",
                        "content": "It\\'s easier to solve it after you write simple dfs traversal "
                    },
                    {
                        "username": "anwendeng",
                        "content": "I wrote a code to find the maximal length of the tree. \nAnd I want to modify it to solve the problem. ` int pathLen=0;\n    void dfs(TreeNode* Node, int level){\n        if (Node==NULL) return ;\n        cout<<Node->val<<\",level=\"<<level<<endl;\n        pathLen=max(pathLen, level);\n        dfs(Node->left, level+1);\n        dfs(Node->right, level+1);.`  "
                    },
                    {
                        "username": "anwendeng",
                        "content": "So, the modification goes well. https://leetcode.com/problems/longest-zigzag-path-in-a-binary-tree/solutions/3433226/easy-c-solution/\\n\\nLater, I will try to optimize "
                    },
                    {
                        "username": "Kiy0taka_Ayanak0ji",
                        "content": "Maintain a boolean:\n```cpp\nint maxZig(TreeNode* root , bool isRight = true,int height)\n```"
                    },
                    {
                        "username": "breathermachine",
                        "content": "You\\'ll need to pass in the direction to your recursive call as well. \\n```\\nint longestZigZag(TreeNode *node, int direction) {\\n```"
                    },
                    {
                        "username": "Firebelias12",
                        "content": "This should be an easy."
                    },
                    {
                        "username": "Athanasios-Kataras",
                        "content": "Are you sure it wasn't one of those cases that the solution just came to you easily? It is a bit tricky to get the alternating paths when they don't just start from root. Easy are generally items with no tricky parts."
                    },
                    {
                        "username": "satyamS_71",
                        "content": "Hey there to PROs ! I was able to come up with a solution for this question which was ~ 90% correct in my first try ,under almost 10 minutes . IS THIS A WIN?  "
                    },
                    {
                        "username": "amanrushed",
                        "content": "This is tricky"
                    },
                    {
                        "username": "codetogrow",
                        "content": "This problem needs some clarification!\\nWe are not being asked the length of the longest path. We have to find the longest \"zigzag\" path!\\n\\nA zigzag path is a path where the direction between every two consecutive nodes alternates, i.e., if we went right from the current node to get to the next node, then from the next node, we should go left to get to the next node after that, and vice versa.\\n\\nThat is why the testcase\\n[1,null,1,1,1,null,null,1,1,null,1,null,null,null,1]\\n\\nmust yield the output 3 instead of 5."
                    },
                    {
                        "username": "prats02",
                        "content": "why is this wrong?\\n\\nclass Solution {\\npublic:\\n    int fn(TreeNode* root,int n){\\n        if(root==NULL) return 0;\\n        if(n==1){\\n            return max((1+fn(root->right,2)),fn(root->left,1));\\n        }\\n        else{\\n            return max((1+fn(root->left,1)),fn(root->right,2));\\n        }\\n    }\\n    int longestZigZag(TreeNode* root) {\\n        return max(fn(root->left,1),fn(root->right,2));\\n    }\\n};"
                    },
                    {
                        "username": "rawatvishal",
                        "content": "the question says \"Choose any node in the binary tree and a direction (right or left)\" \\ninside the longest-zigzag func( fo dfs). \\n\\n\\ni mean - \\nint longestZigZag(TreeNode* root) {\\nreturn max(fn(root->left,1),fn(root->right,2)); // modify this lil bit\\nlongestZigZag(root->left);\\nlongestZigZag(root->right);\\n}\\n};"
                    }
                ]
            },
            {
                "id": 1868190,
                "content": [
                    {
                        "username": "UchihaKim",
                        "content": "And the storm begin... I hope not"
                    },
                    {
                        "username": "ignorant_ppp",
                        "content": "Yeah..it is..!!"
                    },
                    {
                        "username": "iamprashantmmishra",
                        "content": "This one was really interesting. Just try with a recursive solution and maintain left and right lengths and pass it accordingly if you are going to the left side or right side and return max of the 2 calls. "
                    },
                    {
                        "username": "najwer23",
                        "content": "i hate graphs "
                    },
                    {
                        "username": "hosua",
                        "content": "This isn\\'t even a graph problem"
                    },
                    {
                        "username": "foodsnow",
                        "content": "It\\'s easier to solve it after you write simple dfs traversal "
                    },
                    {
                        "username": "anwendeng",
                        "content": "I wrote a code to find the maximal length of the tree. \nAnd I want to modify it to solve the problem. ` int pathLen=0;\n    void dfs(TreeNode* Node, int level){\n        if (Node==NULL) return ;\n        cout<<Node->val<<\",level=\"<<level<<endl;\n        pathLen=max(pathLen, level);\n        dfs(Node->left, level+1);\n        dfs(Node->right, level+1);.`  "
                    },
                    {
                        "username": "anwendeng",
                        "content": "So, the modification goes well. https://leetcode.com/problems/longest-zigzag-path-in-a-binary-tree/solutions/3433226/easy-c-solution/\\n\\nLater, I will try to optimize "
                    },
                    {
                        "username": "Kiy0taka_Ayanak0ji",
                        "content": "Maintain a boolean:\n```cpp\nint maxZig(TreeNode* root , bool isRight = true,int height)\n```"
                    },
                    {
                        "username": "breathermachine",
                        "content": "You\\'ll need to pass in the direction to your recursive call as well. \\n```\\nint longestZigZag(TreeNode *node, int direction) {\\n```"
                    },
                    {
                        "username": "Firebelias12",
                        "content": "This should be an easy."
                    },
                    {
                        "username": "Athanasios-Kataras",
                        "content": "Are you sure it wasn't one of those cases that the solution just came to you easily? It is a bit tricky to get the alternating paths when they don't just start from root. Easy are generally items with no tricky parts."
                    },
                    {
                        "username": "satyamS_71",
                        "content": "Hey there to PROs ! I was able to come up with a solution for this question which was ~ 90% correct in my first try ,under almost 10 minutes . IS THIS A WIN?  "
                    },
                    {
                        "username": "amanrushed",
                        "content": "This is tricky"
                    },
                    {
                        "username": "codetogrow",
                        "content": "This problem needs some clarification!\\nWe are not being asked the length of the longest path. We have to find the longest \"zigzag\" path!\\n\\nA zigzag path is a path where the direction between every two consecutive nodes alternates, i.e., if we went right from the current node to get to the next node, then from the next node, we should go left to get to the next node after that, and vice versa.\\n\\nThat is why the testcase\\n[1,null,1,1,1,null,null,1,1,null,1,null,null,null,1]\\n\\nmust yield the output 3 instead of 5."
                    },
                    {
                        "username": "prats02",
                        "content": "why is this wrong?\\n\\nclass Solution {\\npublic:\\n    int fn(TreeNode* root,int n){\\n        if(root==NULL) return 0;\\n        if(n==1){\\n            return max((1+fn(root->right,2)),fn(root->left,1));\\n        }\\n        else{\\n            return max((1+fn(root->left,1)),fn(root->right,2));\\n        }\\n    }\\n    int longestZigZag(TreeNode* root) {\\n        return max(fn(root->left,1),fn(root->right,2));\\n    }\\n};"
                    },
                    {
                        "username": "rawatvishal",
                        "content": "the question says \"Choose any node in the binary tree and a direction (right or left)\" \\ninside the longest-zigzag func( fo dfs). \\n\\n\\ni mean - \\nint longestZigZag(TreeNode* root) {\\nreturn max(fn(root->left,1),fn(root->right,2)); // modify this lil bit\\nlongestZigZag(root->left);\\nlongestZigZag(root->right);\\n}\\n};"
                    }
                ]
            },
            {
                "id": 2065036,
                "content": [
                    {
                        "username": "UchihaKim",
                        "content": "And the storm begin... I hope not"
                    },
                    {
                        "username": "ignorant_ppp",
                        "content": "Yeah..it is..!!"
                    },
                    {
                        "username": "iamprashantmmishra",
                        "content": "This one was really interesting. Just try with a recursive solution and maintain left and right lengths and pass it accordingly if you are going to the left side or right side and return max of the 2 calls. "
                    },
                    {
                        "username": "najwer23",
                        "content": "i hate graphs "
                    },
                    {
                        "username": "hosua",
                        "content": "This isn\\'t even a graph problem"
                    },
                    {
                        "username": "foodsnow",
                        "content": "It\\'s easier to solve it after you write simple dfs traversal "
                    },
                    {
                        "username": "anwendeng",
                        "content": "I wrote a code to find the maximal length of the tree. \nAnd I want to modify it to solve the problem. ` int pathLen=0;\n    void dfs(TreeNode* Node, int level){\n        if (Node==NULL) return ;\n        cout<<Node->val<<\",level=\"<<level<<endl;\n        pathLen=max(pathLen, level);\n        dfs(Node->left, level+1);\n        dfs(Node->right, level+1);.`  "
                    },
                    {
                        "username": "anwendeng",
                        "content": "So, the modification goes well. https://leetcode.com/problems/longest-zigzag-path-in-a-binary-tree/solutions/3433226/easy-c-solution/\\n\\nLater, I will try to optimize "
                    },
                    {
                        "username": "Kiy0taka_Ayanak0ji",
                        "content": "Maintain a boolean:\n```cpp\nint maxZig(TreeNode* root , bool isRight = true,int height)\n```"
                    },
                    {
                        "username": "breathermachine",
                        "content": "You\\'ll need to pass in the direction to your recursive call as well. \\n```\\nint longestZigZag(TreeNode *node, int direction) {\\n```"
                    },
                    {
                        "username": "Firebelias12",
                        "content": "This should be an easy."
                    },
                    {
                        "username": "Athanasios-Kataras",
                        "content": "Are you sure it wasn't one of those cases that the solution just came to you easily? It is a bit tricky to get the alternating paths when they don't just start from root. Easy are generally items with no tricky parts."
                    },
                    {
                        "username": "satyamS_71",
                        "content": "Hey there to PROs ! I was able to come up with a solution for this question which was ~ 90% correct in my first try ,under almost 10 minutes . IS THIS A WIN?  "
                    },
                    {
                        "username": "amanrushed",
                        "content": "This is tricky"
                    },
                    {
                        "username": "codetogrow",
                        "content": "This problem needs some clarification!\\nWe are not being asked the length of the longest path. We have to find the longest \"zigzag\" path!\\n\\nA zigzag path is a path where the direction between every two consecutive nodes alternates, i.e., if we went right from the current node to get to the next node, then from the next node, we should go left to get to the next node after that, and vice versa.\\n\\nThat is why the testcase\\n[1,null,1,1,1,null,null,1,1,null,1,null,null,null,1]\\n\\nmust yield the output 3 instead of 5."
                    },
                    {
                        "username": "prats02",
                        "content": "why is this wrong?\\n\\nclass Solution {\\npublic:\\n    int fn(TreeNode* root,int n){\\n        if(root==NULL) return 0;\\n        if(n==1){\\n            return max((1+fn(root->right,2)),fn(root->left,1));\\n        }\\n        else{\\n            return max((1+fn(root->left,1)),fn(root->right,2));\\n        }\\n    }\\n    int longestZigZag(TreeNode* root) {\\n        return max(fn(root->left,1),fn(root->right,2));\\n    }\\n};"
                    },
                    {
                        "username": "rawatvishal",
                        "content": "the question says \"Choose any node in the binary tree and a direction (right or left)\" \\ninside the longest-zigzag func( fo dfs). \\n\\n\\ni mean - \\nint longestZigZag(TreeNode* root) {\\nreturn max(fn(root->left,1),fn(root->right,2)); // modify this lil bit\\nlongestZigZag(root->left);\\nlongestZigZag(root->right);\\n}\\n};"
                    }
                ]
            },
            {
                "id": 2031715,
                "content": [
                    {
                        "username": "UchihaKim",
                        "content": "And the storm begin... I hope not"
                    },
                    {
                        "username": "ignorant_ppp",
                        "content": "Yeah..it is..!!"
                    },
                    {
                        "username": "iamprashantmmishra",
                        "content": "This one was really interesting. Just try with a recursive solution and maintain left and right lengths and pass it accordingly if you are going to the left side or right side and return max of the 2 calls. "
                    },
                    {
                        "username": "najwer23",
                        "content": "i hate graphs "
                    },
                    {
                        "username": "hosua",
                        "content": "This isn\\'t even a graph problem"
                    },
                    {
                        "username": "foodsnow",
                        "content": "It\\'s easier to solve it after you write simple dfs traversal "
                    },
                    {
                        "username": "anwendeng",
                        "content": "I wrote a code to find the maximal length of the tree. \nAnd I want to modify it to solve the problem. ` int pathLen=0;\n    void dfs(TreeNode* Node, int level){\n        if (Node==NULL) return ;\n        cout<<Node->val<<\",level=\"<<level<<endl;\n        pathLen=max(pathLen, level);\n        dfs(Node->left, level+1);\n        dfs(Node->right, level+1);.`  "
                    },
                    {
                        "username": "anwendeng",
                        "content": "So, the modification goes well. https://leetcode.com/problems/longest-zigzag-path-in-a-binary-tree/solutions/3433226/easy-c-solution/\\n\\nLater, I will try to optimize "
                    },
                    {
                        "username": "Kiy0taka_Ayanak0ji",
                        "content": "Maintain a boolean:\n```cpp\nint maxZig(TreeNode* root , bool isRight = true,int height)\n```"
                    },
                    {
                        "username": "breathermachine",
                        "content": "You\\'ll need to pass in the direction to your recursive call as well. \\n```\\nint longestZigZag(TreeNode *node, int direction) {\\n```"
                    },
                    {
                        "username": "Firebelias12",
                        "content": "This should be an easy."
                    },
                    {
                        "username": "Athanasios-Kataras",
                        "content": "Are you sure it wasn't one of those cases that the solution just came to you easily? It is a bit tricky to get the alternating paths when they don't just start from root. Easy are generally items with no tricky parts."
                    },
                    {
                        "username": "satyamS_71",
                        "content": "Hey there to PROs ! I was able to come up with a solution for this question which was ~ 90% correct in my first try ,under almost 10 minutes . IS THIS A WIN?  "
                    },
                    {
                        "username": "amanrushed",
                        "content": "This is tricky"
                    },
                    {
                        "username": "codetogrow",
                        "content": "This problem needs some clarification!\\nWe are not being asked the length of the longest path. We have to find the longest \"zigzag\" path!\\n\\nA zigzag path is a path where the direction between every two consecutive nodes alternates, i.e., if we went right from the current node to get to the next node, then from the next node, we should go left to get to the next node after that, and vice versa.\\n\\nThat is why the testcase\\n[1,null,1,1,1,null,null,1,1,null,1,null,null,null,1]\\n\\nmust yield the output 3 instead of 5."
                    },
                    {
                        "username": "prats02",
                        "content": "why is this wrong?\\n\\nclass Solution {\\npublic:\\n    int fn(TreeNode* root,int n){\\n        if(root==NULL) return 0;\\n        if(n==1){\\n            return max((1+fn(root->right,2)),fn(root->left,1));\\n        }\\n        else{\\n            return max((1+fn(root->left,1)),fn(root->right,2));\\n        }\\n    }\\n    int longestZigZag(TreeNode* root) {\\n        return max(fn(root->left,1),fn(root->right,2));\\n    }\\n};"
                    },
                    {
                        "username": "rawatvishal",
                        "content": "the question says \"Choose any node in the binary tree and a direction (right or left)\" \\ninside the longest-zigzag func( fo dfs). \\n\\n\\ni mean - \\nint longestZigZag(TreeNode* root) {\\nreturn max(fn(root->left,1),fn(root->right,2)); // modify this lil bit\\nlongestZigZag(root->left);\\nlongestZigZag(root->right);\\n}\\n};"
                    }
                ]
            },
            {
                "id": 1924319,
                "content": [
                    {
                        "username": "UchihaKim",
                        "content": "And the storm begin... I hope not"
                    },
                    {
                        "username": "ignorant_ppp",
                        "content": "Yeah..it is..!!"
                    },
                    {
                        "username": "iamprashantmmishra",
                        "content": "This one was really interesting. Just try with a recursive solution and maintain left and right lengths and pass it accordingly if you are going to the left side or right side and return max of the 2 calls. "
                    },
                    {
                        "username": "najwer23",
                        "content": "i hate graphs "
                    },
                    {
                        "username": "hosua",
                        "content": "This isn\\'t even a graph problem"
                    },
                    {
                        "username": "foodsnow",
                        "content": "It\\'s easier to solve it after you write simple dfs traversal "
                    },
                    {
                        "username": "anwendeng",
                        "content": "I wrote a code to find the maximal length of the tree. \nAnd I want to modify it to solve the problem. ` int pathLen=0;\n    void dfs(TreeNode* Node, int level){\n        if (Node==NULL) return ;\n        cout<<Node->val<<\",level=\"<<level<<endl;\n        pathLen=max(pathLen, level);\n        dfs(Node->left, level+1);\n        dfs(Node->right, level+1);.`  "
                    },
                    {
                        "username": "anwendeng",
                        "content": "So, the modification goes well. https://leetcode.com/problems/longest-zigzag-path-in-a-binary-tree/solutions/3433226/easy-c-solution/\\n\\nLater, I will try to optimize "
                    },
                    {
                        "username": "Kiy0taka_Ayanak0ji",
                        "content": "Maintain a boolean:\n```cpp\nint maxZig(TreeNode* root , bool isRight = true,int height)\n```"
                    },
                    {
                        "username": "breathermachine",
                        "content": "You\\'ll need to pass in the direction to your recursive call as well. \\n```\\nint longestZigZag(TreeNode *node, int direction) {\\n```"
                    },
                    {
                        "username": "Firebelias12",
                        "content": "This should be an easy."
                    },
                    {
                        "username": "Athanasios-Kataras",
                        "content": "Are you sure it wasn't one of those cases that the solution just came to you easily? It is a bit tricky to get the alternating paths when they don't just start from root. Easy are generally items with no tricky parts."
                    },
                    {
                        "username": "satyamS_71",
                        "content": "Hey there to PROs ! I was able to come up with a solution for this question which was ~ 90% correct in my first try ,under almost 10 minutes . IS THIS A WIN?  "
                    },
                    {
                        "username": "amanrushed",
                        "content": "This is tricky"
                    },
                    {
                        "username": "codetogrow",
                        "content": "This problem needs some clarification!\\nWe are not being asked the length of the longest path. We have to find the longest \"zigzag\" path!\\n\\nA zigzag path is a path where the direction between every two consecutive nodes alternates, i.e., if we went right from the current node to get to the next node, then from the next node, we should go left to get to the next node after that, and vice versa.\\n\\nThat is why the testcase\\n[1,null,1,1,1,null,null,1,1,null,1,null,null,null,1]\\n\\nmust yield the output 3 instead of 5."
                    },
                    {
                        "username": "prats02",
                        "content": "why is this wrong?\\n\\nclass Solution {\\npublic:\\n    int fn(TreeNode* root,int n){\\n        if(root==NULL) return 0;\\n        if(n==1){\\n            return max((1+fn(root->right,2)),fn(root->left,1));\\n        }\\n        else{\\n            return max((1+fn(root->left,1)),fn(root->right,2));\\n        }\\n    }\\n    int longestZigZag(TreeNode* root) {\\n        return max(fn(root->left,1),fn(root->right,2));\\n    }\\n};"
                    },
                    {
                        "username": "rawatvishal",
                        "content": "the question says \"Choose any node in the binary tree and a direction (right or left)\" \\ninside the longest-zigzag func( fo dfs). \\n\\n\\ni mean - \\nint longestZigZag(TreeNode* root) {\\nreturn max(fn(root->left,1),fn(root->right,2)); // modify this lil bit\\nlongestZigZag(root->left);\\nlongestZigZag(root->right);\\n}\\n};"
                    }
                ]
            },
            {
                "id": 1911286,
                "content": [
                    {
                        "username": "UchihaKim",
                        "content": "And the storm begin... I hope not"
                    },
                    {
                        "username": "ignorant_ppp",
                        "content": "Yeah..it is..!!"
                    },
                    {
                        "username": "iamprashantmmishra",
                        "content": "This one was really interesting. Just try with a recursive solution and maintain left and right lengths and pass it accordingly if you are going to the left side or right side and return max of the 2 calls. "
                    },
                    {
                        "username": "najwer23",
                        "content": "i hate graphs "
                    },
                    {
                        "username": "hosua",
                        "content": "This isn\\'t even a graph problem"
                    },
                    {
                        "username": "foodsnow",
                        "content": "It\\'s easier to solve it after you write simple dfs traversal "
                    },
                    {
                        "username": "anwendeng",
                        "content": "I wrote a code to find the maximal length of the tree. \nAnd I want to modify it to solve the problem. ` int pathLen=0;\n    void dfs(TreeNode* Node, int level){\n        if (Node==NULL) return ;\n        cout<<Node->val<<\",level=\"<<level<<endl;\n        pathLen=max(pathLen, level);\n        dfs(Node->left, level+1);\n        dfs(Node->right, level+1);.`  "
                    },
                    {
                        "username": "anwendeng",
                        "content": "So, the modification goes well. https://leetcode.com/problems/longest-zigzag-path-in-a-binary-tree/solutions/3433226/easy-c-solution/\\n\\nLater, I will try to optimize "
                    },
                    {
                        "username": "Kiy0taka_Ayanak0ji",
                        "content": "Maintain a boolean:\n```cpp\nint maxZig(TreeNode* root , bool isRight = true,int height)\n```"
                    },
                    {
                        "username": "breathermachine",
                        "content": "You\\'ll need to pass in the direction to your recursive call as well. \\n```\\nint longestZigZag(TreeNode *node, int direction) {\\n```"
                    },
                    {
                        "username": "Firebelias12",
                        "content": "This should be an easy."
                    },
                    {
                        "username": "Athanasios-Kataras",
                        "content": "Are you sure it wasn't one of those cases that the solution just came to you easily? It is a bit tricky to get the alternating paths when they don't just start from root. Easy are generally items with no tricky parts."
                    },
                    {
                        "username": "satyamS_71",
                        "content": "Hey there to PROs ! I was able to come up with a solution for this question which was ~ 90% correct in my first try ,under almost 10 minutes . IS THIS A WIN?  "
                    },
                    {
                        "username": "amanrushed",
                        "content": "This is tricky"
                    },
                    {
                        "username": "codetogrow",
                        "content": "This problem needs some clarification!\\nWe are not being asked the length of the longest path. We have to find the longest \"zigzag\" path!\\n\\nA zigzag path is a path where the direction between every two consecutive nodes alternates, i.e., if we went right from the current node to get to the next node, then from the next node, we should go left to get to the next node after that, and vice versa.\\n\\nThat is why the testcase\\n[1,null,1,1,1,null,null,1,1,null,1,null,null,null,1]\\n\\nmust yield the output 3 instead of 5."
                    },
                    {
                        "username": "prats02",
                        "content": "why is this wrong?\\n\\nclass Solution {\\npublic:\\n    int fn(TreeNode* root,int n){\\n        if(root==NULL) return 0;\\n        if(n==1){\\n            return max((1+fn(root->right,2)),fn(root->left,1));\\n        }\\n        else{\\n            return max((1+fn(root->left,1)),fn(root->right,2));\\n        }\\n    }\\n    int longestZigZag(TreeNode* root) {\\n        return max(fn(root->left,1),fn(root->right,2));\\n    }\\n};"
                    },
                    {
                        "username": "rawatvishal",
                        "content": "the question says \"Choose any node in the binary tree and a direction (right or left)\" \\ninside the longest-zigzag func( fo dfs). \\n\\n\\ni mean - \\nint longestZigZag(TreeNode* root) {\\nreturn max(fn(root->left,1),fn(root->right,2)); // modify this lil bit\\nlongestZigZag(root->left);\\nlongestZigZag(root->right);\\n}\\n};"
                    }
                ]
            },
            {
                "id": 1895120,
                "content": [
                    {
                        "username": "ndrwknsh",
                        "content": "If you\\'re struggling with this problem, you may want to consider the differences between top-down recursion and bottom-up recursion."
                    },
                    {
                        "username": "tsagikyan",
                        "content": "Faster than editorial | CPP | 1-liner recursion:\n```\n    int dfs(TreeNode* root, int lsum, int rsum) {\n        return root==0 ? max(lsum,rsum) : max(dfs(root->left, rsum+1, -1), dfs(root->right, -1, lsum+1));\n    }\n\n    int longestZigZag(TreeNode* root) {\n        return dfs(root, -1, -1);\n    }\n```"
                    },
                    {
                        "username": "user5742L",
                        "content": "Why it is Giving WA??\nclass Solution {\n    public int f(TreeNode root, boolean isLeft, int count) {\n        if (root == null) {\n            return count;\n        }\n        if (isLeft) {\n            return Math.max(f(root.right, false, count + 1), Math.max(f(root.left, true, 0),f(root.left, false, 0)));\n        } else {\n            return Math.max(f(root.left, true, count + 1), Math.max(f(root.right, true, 0),f(root.right, false, 0)));\n        }\n    }\n    \n    public int longestZigZag(TreeNode root) {\n        if (root == null) {\n            return 0;\n        }\n        return Math.max(f(root.left, true, 0), f(root.right, false, 0));\n    }\n}\n\n\n\n  "
                    },
                    {
                        "username": "ankeshaman333",
                        "content": "Is anyone facing version of your browser is too low to load the code-editor"
                    },
                    {
                        "username": "klaca",
                        "content": "It happened to me two days ago but now it works. I didn't do anything to fix it."
                    },
                    {
                        "username": "klaca",
                        "content": "Do you have any tips for debugging a test case with a huge tree? I fail at test case 52, my solution returns 2050 instead of 6962 and I don't have the slightest idea what the problem could be.\nmy approach is to follow a zigzag, putting unvisited nodes (with direction) on a stack, and starting a new count from the top of the stack when the current path is exhausted. It has no problem with the first 51 test cases."
                    },
                    {
                        "username": "klaca",
                        "content": "[@Mister_CK](/Mister_CK) It's not a recursion. I thought to do an incremental traversal using a stack, there is really not much difference to it. I will try recursion now that I can't see the problem with incremental. \nEdit: it was quite simple with recursion. I'm still bothered about not knowing what went wrong with my incremental solution... I guess I just have to leave it like that now..."
                    },
                    {
                        "username": "Mister_CK",
                        "content": "you could log the root in you recursive function. Not sure if that test case isn\\'t to big for even that though. \\nBut creating a stack of nodes to visit later is not a great approach. Try to do those nodes immediately. (or, well, DFS so still after the current iteration, but there is no need to store them, just call them, if you get what I mean)"
                    },
                    {
                        "username": "Mshashikanth",
                        "content": "struggled a lot to solve this one"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "me too, was trying to use dynamic programming, but couldn\\'t get it to work, wasted a lot of time on it. Doing DFS while keeping track of current path length was so much simpeler! Ended up spending more time on this medium than on Sundays hard."
                    },
                    {
                        "username": "jainams6160",
                        "content": " Can some explain me the time complexity of this solution?\\n\\n    static int ans;\\n    static void util(TreeNode root, boolean l, boolean r, int value){\\n        if(root == null){\\n            ans = Math.max(ans, value);\\n            return;\\n        }\\n        if(l)\\n            util(root.left, false, true, value + 1);\\n        if(r)\\n            util(root.right, true, false, value + 1);\\n        util(root.left, true, true, -1);\\n        util(root.right, true, true, -1);\\n    }\\n\\n    public int longestZigZag(TreeNode root) {\\n        ans = 0;\\n        util(root, true, true, -1)\\n        return ans;\\n    }`"
                    },
                    {
                        "username": "elrestbrain",
                        "content": "Example 1 doesn\\'t make any sense to me? Doesn\\'t it go right *twice* at the beginning? \\n\\nI feel like it should be right -> left -> right for a path length of 2, since we count edges not nodes"
                    },
                    {
                        "username": "elrestbrain",
                        "content": "[@pinakibanerjee2001](/pinakibanerjee2001) oh duh, thank you"
                    },
                    {
                        "username": "pinakibanerjee2001",
                        "content": "You are supposed to find maximum zigzag path starting at any node, not necessarily starting at root\n"
                    },
                    {
                        "username": "van146",
                        "content": "yeah - I was stumbled upon the same understanding spike - e.g. read the whole description - as we need to find max possible zigzag path within the tree, and this one not necessarily would start from the root of the tree, that\\'s why example one is correct and it explains the task better then description"
                    },
                    {
                        "username": "teckyshubham",
                        "content": " `yclass Solution {\\n    public int longestZigZag(TreeNode root) {\\n    return dfs(root).subtreeMax;\\n  }\\n\\n  private T dfs(TreeNode root) {\\n    if (root == null)\\n      return new T(-1, -1, -1);\\n    T left = dfs(root.left);\\n    T right = dfs(root.right);\\n    final int leftZigZag = left.rightMax + 1;\\n    final int rightZigZag = right.leftMax + 1;\\n    final int subtreeMax =\\n        Math.max(Math.max(leftZigZag, rightZigZag), Math.max(left.subtreeMax, right.subtreeMax));\\n    return new T(leftZigZag, rightZigZag, subtreeMax);\\n  }\\n}`"
                    },
                    {
                        "username": "teckyshubham",
                        "content": " `class T {\\n  public int leftMax;\\n  public int rightMax;\\n  public int subtreeMax;\\n\\n  public T(int leftMax, int rightMax, int subtreeMax) {\\n    this.leftMax = leftMax;\\n    this.rightMax = rightMax;\\n    this.subtreeMax = subtreeMax;\\n  }\\n}`"
                    }
                ]
            },
            {
                "id": 1891095,
                "content": [
                    {
                        "username": "ndrwknsh",
                        "content": "If you\\'re struggling with this problem, you may want to consider the differences between top-down recursion and bottom-up recursion."
                    },
                    {
                        "username": "tsagikyan",
                        "content": "Faster than editorial | CPP | 1-liner recursion:\n```\n    int dfs(TreeNode* root, int lsum, int rsum) {\n        return root==0 ? max(lsum,rsum) : max(dfs(root->left, rsum+1, -1), dfs(root->right, -1, lsum+1));\n    }\n\n    int longestZigZag(TreeNode* root) {\n        return dfs(root, -1, -1);\n    }\n```"
                    },
                    {
                        "username": "user5742L",
                        "content": "Why it is Giving WA??\nclass Solution {\n    public int f(TreeNode root, boolean isLeft, int count) {\n        if (root == null) {\n            return count;\n        }\n        if (isLeft) {\n            return Math.max(f(root.right, false, count + 1), Math.max(f(root.left, true, 0),f(root.left, false, 0)));\n        } else {\n            return Math.max(f(root.left, true, count + 1), Math.max(f(root.right, true, 0),f(root.right, false, 0)));\n        }\n    }\n    \n    public int longestZigZag(TreeNode root) {\n        if (root == null) {\n            return 0;\n        }\n        return Math.max(f(root.left, true, 0), f(root.right, false, 0));\n    }\n}\n\n\n\n  "
                    },
                    {
                        "username": "ankeshaman333",
                        "content": "Is anyone facing version of your browser is too low to load the code-editor"
                    },
                    {
                        "username": "klaca",
                        "content": "It happened to me two days ago but now it works. I didn't do anything to fix it."
                    },
                    {
                        "username": "klaca",
                        "content": "Do you have any tips for debugging a test case with a huge tree? I fail at test case 52, my solution returns 2050 instead of 6962 and I don't have the slightest idea what the problem could be.\nmy approach is to follow a zigzag, putting unvisited nodes (with direction) on a stack, and starting a new count from the top of the stack when the current path is exhausted. It has no problem with the first 51 test cases."
                    },
                    {
                        "username": "klaca",
                        "content": "[@Mister_CK](/Mister_CK) It's not a recursion. I thought to do an incremental traversal using a stack, there is really not much difference to it. I will try recursion now that I can't see the problem with incremental. \nEdit: it was quite simple with recursion. I'm still bothered about not knowing what went wrong with my incremental solution... I guess I just have to leave it like that now..."
                    },
                    {
                        "username": "Mister_CK",
                        "content": "you could log the root in you recursive function. Not sure if that test case isn\\'t to big for even that though. \\nBut creating a stack of nodes to visit later is not a great approach. Try to do those nodes immediately. (or, well, DFS so still after the current iteration, but there is no need to store them, just call them, if you get what I mean)"
                    },
                    {
                        "username": "Mshashikanth",
                        "content": "struggled a lot to solve this one"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "me too, was trying to use dynamic programming, but couldn\\'t get it to work, wasted a lot of time on it. Doing DFS while keeping track of current path length was so much simpeler! Ended up spending more time on this medium than on Sundays hard."
                    },
                    {
                        "username": "jainams6160",
                        "content": " Can some explain me the time complexity of this solution?\\n\\n    static int ans;\\n    static void util(TreeNode root, boolean l, boolean r, int value){\\n        if(root == null){\\n            ans = Math.max(ans, value);\\n            return;\\n        }\\n        if(l)\\n            util(root.left, false, true, value + 1);\\n        if(r)\\n            util(root.right, true, false, value + 1);\\n        util(root.left, true, true, -1);\\n        util(root.right, true, true, -1);\\n    }\\n\\n    public int longestZigZag(TreeNode root) {\\n        ans = 0;\\n        util(root, true, true, -1)\\n        return ans;\\n    }`"
                    },
                    {
                        "username": "elrestbrain",
                        "content": "Example 1 doesn\\'t make any sense to me? Doesn\\'t it go right *twice* at the beginning? \\n\\nI feel like it should be right -> left -> right for a path length of 2, since we count edges not nodes"
                    },
                    {
                        "username": "elrestbrain",
                        "content": "[@pinakibanerjee2001](/pinakibanerjee2001) oh duh, thank you"
                    },
                    {
                        "username": "pinakibanerjee2001",
                        "content": "You are supposed to find maximum zigzag path starting at any node, not necessarily starting at root\n"
                    },
                    {
                        "username": "van146",
                        "content": "yeah - I was stumbled upon the same understanding spike - e.g. read the whole description - as we need to find max possible zigzag path within the tree, and this one not necessarily would start from the root of the tree, that\\'s why example one is correct and it explains the task better then description"
                    },
                    {
                        "username": "teckyshubham",
                        "content": " `yclass Solution {\\n    public int longestZigZag(TreeNode root) {\\n    return dfs(root).subtreeMax;\\n  }\\n\\n  private T dfs(TreeNode root) {\\n    if (root == null)\\n      return new T(-1, -1, -1);\\n    T left = dfs(root.left);\\n    T right = dfs(root.right);\\n    final int leftZigZag = left.rightMax + 1;\\n    final int rightZigZag = right.leftMax + 1;\\n    final int subtreeMax =\\n        Math.max(Math.max(leftZigZag, rightZigZag), Math.max(left.subtreeMax, right.subtreeMax));\\n    return new T(leftZigZag, rightZigZag, subtreeMax);\\n  }\\n}`"
                    },
                    {
                        "username": "teckyshubham",
                        "content": " `class T {\\n  public int leftMax;\\n  public int rightMax;\\n  public int subtreeMax;\\n\\n  public T(int leftMax, int rightMax, int subtreeMax) {\\n    this.leftMax = leftMax;\\n    this.rightMax = rightMax;\\n    this.subtreeMax = subtreeMax;\\n  }\\n}`"
                    }
                ]
            },
            {
                "id": 1868753,
                "content": [
                    {
                        "username": "ndrwknsh",
                        "content": "If you\\'re struggling with this problem, you may want to consider the differences between top-down recursion and bottom-up recursion."
                    },
                    {
                        "username": "tsagikyan",
                        "content": "Faster than editorial | CPP | 1-liner recursion:\n```\n    int dfs(TreeNode* root, int lsum, int rsum) {\n        return root==0 ? max(lsum,rsum) : max(dfs(root->left, rsum+1, -1), dfs(root->right, -1, lsum+1));\n    }\n\n    int longestZigZag(TreeNode* root) {\n        return dfs(root, -1, -1);\n    }\n```"
                    },
                    {
                        "username": "user5742L",
                        "content": "Why it is Giving WA??\nclass Solution {\n    public int f(TreeNode root, boolean isLeft, int count) {\n        if (root == null) {\n            return count;\n        }\n        if (isLeft) {\n            return Math.max(f(root.right, false, count + 1), Math.max(f(root.left, true, 0),f(root.left, false, 0)));\n        } else {\n            return Math.max(f(root.left, true, count + 1), Math.max(f(root.right, true, 0),f(root.right, false, 0)));\n        }\n    }\n    \n    public int longestZigZag(TreeNode root) {\n        if (root == null) {\n            return 0;\n        }\n        return Math.max(f(root.left, true, 0), f(root.right, false, 0));\n    }\n}\n\n\n\n  "
                    },
                    {
                        "username": "ankeshaman333",
                        "content": "Is anyone facing version of your browser is too low to load the code-editor"
                    },
                    {
                        "username": "klaca",
                        "content": "It happened to me two days ago but now it works. I didn't do anything to fix it."
                    },
                    {
                        "username": "klaca",
                        "content": "Do you have any tips for debugging a test case with a huge tree? I fail at test case 52, my solution returns 2050 instead of 6962 and I don't have the slightest idea what the problem could be.\nmy approach is to follow a zigzag, putting unvisited nodes (with direction) on a stack, and starting a new count from the top of the stack when the current path is exhausted. It has no problem with the first 51 test cases."
                    },
                    {
                        "username": "klaca",
                        "content": "[@Mister_CK](/Mister_CK) It's not a recursion. I thought to do an incremental traversal using a stack, there is really not much difference to it. I will try recursion now that I can't see the problem with incremental. \nEdit: it was quite simple with recursion. I'm still bothered about not knowing what went wrong with my incremental solution... I guess I just have to leave it like that now..."
                    },
                    {
                        "username": "Mister_CK",
                        "content": "you could log the root in you recursive function. Not sure if that test case isn\\'t to big for even that though. \\nBut creating a stack of nodes to visit later is not a great approach. Try to do those nodes immediately. (or, well, DFS so still after the current iteration, but there is no need to store them, just call them, if you get what I mean)"
                    },
                    {
                        "username": "Mshashikanth",
                        "content": "struggled a lot to solve this one"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "me too, was trying to use dynamic programming, but couldn\\'t get it to work, wasted a lot of time on it. Doing DFS while keeping track of current path length was so much simpeler! Ended up spending more time on this medium than on Sundays hard."
                    },
                    {
                        "username": "jainams6160",
                        "content": " Can some explain me the time complexity of this solution?\\n\\n    static int ans;\\n    static void util(TreeNode root, boolean l, boolean r, int value){\\n        if(root == null){\\n            ans = Math.max(ans, value);\\n            return;\\n        }\\n        if(l)\\n            util(root.left, false, true, value + 1);\\n        if(r)\\n            util(root.right, true, false, value + 1);\\n        util(root.left, true, true, -1);\\n        util(root.right, true, true, -1);\\n    }\\n\\n    public int longestZigZag(TreeNode root) {\\n        ans = 0;\\n        util(root, true, true, -1)\\n        return ans;\\n    }`"
                    },
                    {
                        "username": "elrestbrain",
                        "content": "Example 1 doesn\\'t make any sense to me? Doesn\\'t it go right *twice* at the beginning? \\n\\nI feel like it should be right -> left -> right for a path length of 2, since we count edges not nodes"
                    },
                    {
                        "username": "elrestbrain",
                        "content": "[@pinakibanerjee2001](/pinakibanerjee2001) oh duh, thank you"
                    },
                    {
                        "username": "pinakibanerjee2001",
                        "content": "You are supposed to find maximum zigzag path starting at any node, not necessarily starting at root\n"
                    },
                    {
                        "username": "van146",
                        "content": "yeah - I was stumbled upon the same understanding spike - e.g. read the whole description - as we need to find max possible zigzag path within the tree, and this one not necessarily would start from the root of the tree, that\\'s why example one is correct and it explains the task better then description"
                    },
                    {
                        "username": "teckyshubham",
                        "content": " `yclass Solution {\\n    public int longestZigZag(TreeNode root) {\\n    return dfs(root).subtreeMax;\\n  }\\n\\n  private T dfs(TreeNode root) {\\n    if (root == null)\\n      return new T(-1, -1, -1);\\n    T left = dfs(root.left);\\n    T right = dfs(root.right);\\n    final int leftZigZag = left.rightMax + 1;\\n    final int rightZigZag = right.leftMax + 1;\\n    final int subtreeMax =\\n        Math.max(Math.max(leftZigZag, rightZigZag), Math.max(left.subtreeMax, right.subtreeMax));\\n    return new T(leftZigZag, rightZigZag, subtreeMax);\\n  }\\n}`"
                    },
                    {
                        "username": "teckyshubham",
                        "content": " `class T {\\n  public int leftMax;\\n  public int rightMax;\\n  public int subtreeMax;\\n\\n  public T(int leftMax, int rightMax, int subtreeMax) {\\n    this.leftMax = leftMax;\\n    this.rightMax = rightMax;\\n    this.subtreeMax = subtreeMax;\\n  }\\n}`"
                    }
                ]
            },
            {
                "id": 1868598,
                "content": [
                    {
                        "username": "ndrwknsh",
                        "content": "If you\\'re struggling with this problem, you may want to consider the differences between top-down recursion and bottom-up recursion."
                    },
                    {
                        "username": "tsagikyan",
                        "content": "Faster than editorial | CPP | 1-liner recursion:\n```\n    int dfs(TreeNode* root, int lsum, int rsum) {\n        return root==0 ? max(lsum,rsum) : max(dfs(root->left, rsum+1, -1), dfs(root->right, -1, lsum+1));\n    }\n\n    int longestZigZag(TreeNode* root) {\n        return dfs(root, -1, -1);\n    }\n```"
                    },
                    {
                        "username": "user5742L",
                        "content": "Why it is Giving WA??\nclass Solution {\n    public int f(TreeNode root, boolean isLeft, int count) {\n        if (root == null) {\n            return count;\n        }\n        if (isLeft) {\n            return Math.max(f(root.right, false, count + 1), Math.max(f(root.left, true, 0),f(root.left, false, 0)));\n        } else {\n            return Math.max(f(root.left, true, count + 1), Math.max(f(root.right, true, 0),f(root.right, false, 0)));\n        }\n    }\n    \n    public int longestZigZag(TreeNode root) {\n        if (root == null) {\n            return 0;\n        }\n        return Math.max(f(root.left, true, 0), f(root.right, false, 0));\n    }\n}\n\n\n\n  "
                    },
                    {
                        "username": "ankeshaman333",
                        "content": "Is anyone facing version of your browser is too low to load the code-editor"
                    },
                    {
                        "username": "klaca",
                        "content": "It happened to me two days ago but now it works. I didn't do anything to fix it."
                    },
                    {
                        "username": "klaca",
                        "content": "Do you have any tips for debugging a test case with a huge tree? I fail at test case 52, my solution returns 2050 instead of 6962 and I don't have the slightest idea what the problem could be.\nmy approach is to follow a zigzag, putting unvisited nodes (with direction) on a stack, and starting a new count from the top of the stack when the current path is exhausted. It has no problem with the first 51 test cases."
                    },
                    {
                        "username": "klaca",
                        "content": "[@Mister_CK](/Mister_CK) It's not a recursion. I thought to do an incremental traversal using a stack, there is really not much difference to it. I will try recursion now that I can't see the problem with incremental. \nEdit: it was quite simple with recursion. I'm still bothered about not knowing what went wrong with my incremental solution... I guess I just have to leave it like that now..."
                    },
                    {
                        "username": "Mister_CK",
                        "content": "you could log the root in you recursive function. Not sure if that test case isn\\'t to big for even that though. \\nBut creating a stack of nodes to visit later is not a great approach. Try to do those nodes immediately. (or, well, DFS so still after the current iteration, but there is no need to store them, just call them, if you get what I mean)"
                    },
                    {
                        "username": "Mshashikanth",
                        "content": "struggled a lot to solve this one"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "me too, was trying to use dynamic programming, but couldn\\'t get it to work, wasted a lot of time on it. Doing DFS while keeping track of current path length was so much simpeler! Ended up spending more time on this medium than on Sundays hard."
                    },
                    {
                        "username": "jainams6160",
                        "content": " Can some explain me the time complexity of this solution?\\n\\n    static int ans;\\n    static void util(TreeNode root, boolean l, boolean r, int value){\\n        if(root == null){\\n            ans = Math.max(ans, value);\\n            return;\\n        }\\n        if(l)\\n            util(root.left, false, true, value + 1);\\n        if(r)\\n            util(root.right, true, false, value + 1);\\n        util(root.left, true, true, -1);\\n        util(root.right, true, true, -1);\\n    }\\n\\n    public int longestZigZag(TreeNode root) {\\n        ans = 0;\\n        util(root, true, true, -1)\\n        return ans;\\n    }`"
                    },
                    {
                        "username": "elrestbrain",
                        "content": "Example 1 doesn\\'t make any sense to me? Doesn\\'t it go right *twice* at the beginning? \\n\\nI feel like it should be right -> left -> right for a path length of 2, since we count edges not nodes"
                    },
                    {
                        "username": "elrestbrain",
                        "content": "[@pinakibanerjee2001](/pinakibanerjee2001) oh duh, thank you"
                    },
                    {
                        "username": "pinakibanerjee2001",
                        "content": "You are supposed to find maximum zigzag path starting at any node, not necessarily starting at root\n"
                    },
                    {
                        "username": "van146",
                        "content": "yeah - I was stumbled upon the same understanding spike - e.g. read the whole description - as we need to find max possible zigzag path within the tree, and this one not necessarily would start from the root of the tree, that\\'s why example one is correct and it explains the task better then description"
                    },
                    {
                        "username": "teckyshubham",
                        "content": " `yclass Solution {\\n    public int longestZigZag(TreeNode root) {\\n    return dfs(root).subtreeMax;\\n  }\\n\\n  private T dfs(TreeNode root) {\\n    if (root == null)\\n      return new T(-1, -1, -1);\\n    T left = dfs(root.left);\\n    T right = dfs(root.right);\\n    final int leftZigZag = left.rightMax + 1;\\n    final int rightZigZag = right.leftMax + 1;\\n    final int subtreeMax =\\n        Math.max(Math.max(leftZigZag, rightZigZag), Math.max(left.subtreeMax, right.subtreeMax));\\n    return new T(leftZigZag, rightZigZag, subtreeMax);\\n  }\\n}`"
                    },
                    {
                        "username": "teckyshubham",
                        "content": " `class T {\\n  public int leftMax;\\n  public int rightMax;\\n  public int subtreeMax;\\n\\n  public T(int leftMax, int rightMax, int subtreeMax) {\\n    this.leftMax = leftMax;\\n    this.rightMax = rightMax;\\n    this.subtreeMax = subtreeMax;\\n  }\\n}`"
                    }
                ]
            },
            {
                "id": 1868563,
                "content": [
                    {
                        "username": "ndrwknsh",
                        "content": "If you\\'re struggling with this problem, you may want to consider the differences between top-down recursion and bottom-up recursion."
                    },
                    {
                        "username": "tsagikyan",
                        "content": "Faster than editorial | CPP | 1-liner recursion:\n```\n    int dfs(TreeNode* root, int lsum, int rsum) {\n        return root==0 ? max(lsum,rsum) : max(dfs(root->left, rsum+1, -1), dfs(root->right, -1, lsum+1));\n    }\n\n    int longestZigZag(TreeNode* root) {\n        return dfs(root, -1, -1);\n    }\n```"
                    },
                    {
                        "username": "user5742L",
                        "content": "Why it is Giving WA??\nclass Solution {\n    public int f(TreeNode root, boolean isLeft, int count) {\n        if (root == null) {\n            return count;\n        }\n        if (isLeft) {\n            return Math.max(f(root.right, false, count + 1), Math.max(f(root.left, true, 0),f(root.left, false, 0)));\n        } else {\n            return Math.max(f(root.left, true, count + 1), Math.max(f(root.right, true, 0),f(root.right, false, 0)));\n        }\n    }\n    \n    public int longestZigZag(TreeNode root) {\n        if (root == null) {\n            return 0;\n        }\n        return Math.max(f(root.left, true, 0), f(root.right, false, 0));\n    }\n}\n\n\n\n  "
                    },
                    {
                        "username": "ankeshaman333",
                        "content": "Is anyone facing version of your browser is too low to load the code-editor"
                    },
                    {
                        "username": "klaca",
                        "content": "It happened to me two days ago but now it works. I didn't do anything to fix it."
                    },
                    {
                        "username": "klaca",
                        "content": "Do you have any tips for debugging a test case with a huge tree? I fail at test case 52, my solution returns 2050 instead of 6962 and I don't have the slightest idea what the problem could be.\nmy approach is to follow a zigzag, putting unvisited nodes (with direction) on a stack, and starting a new count from the top of the stack when the current path is exhausted. It has no problem with the first 51 test cases."
                    },
                    {
                        "username": "klaca",
                        "content": "[@Mister_CK](/Mister_CK) It's not a recursion. I thought to do an incremental traversal using a stack, there is really not much difference to it. I will try recursion now that I can't see the problem with incremental. \nEdit: it was quite simple with recursion. I'm still bothered about not knowing what went wrong with my incremental solution... I guess I just have to leave it like that now..."
                    },
                    {
                        "username": "Mister_CK",
                        "content": "you could log the root in you recursive function. Not sure if that test case isn\\'t to big for even that though. \\nBut creating a stack of nodes to visit later is not a great approach. Try to do those nodes immediately. (or, well, DFS so still after the current iteration, but there is no need to store them, just call them, if you get what I mean)"
                    },
                    {
                        "username": "Mshashikanth",
                        "content": "struggled a lot to solve this one"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "me too, was trying to use dynamic programming, but couldn\\'t get it to work, wasted a lot of time on it. Doing DFS while keeping track of current path length was so much simpeler! Ended up spending more time on this medium than on Sundays hard."
                    },
                    {
                        "username": "jainams6160",
                        "content": " Can some explain me the time complexity of this solution?\\n\\n    static int ans;\\n    static void util(TreeNode root, boolean l, boolean r, int value){\\n        if(root == null){\\n            ans = Math.max(ans, value);\\n            return;\\n        }\\n        if(l)\\n            util(root.left, false, true, value + 1);\\n        if(r)\\n            util(root.right, true, false, value + 1);\\n        util(root.left, true, true, -1);\\n        util(root.right, true, true, -1);\\n    }\\n\\n    public int longestZigZag(TreeNode root) {\\n        ans = 0;\\n        util(root, true, true, -1)\\n        return ans;\\n    }`"
                    },
                    {
                        "username": "elrestbrain",
                        "content": "Example 1 doesn\\'t make any sense to me? Doesn\\'t it go right *twice* at the beginning? \\n\\nI feel like it should be right -> left -> right for a path length of 2, since we count edges not nodes"
                    },
                    {
                        "username": "elrestbrain",
                        "content": "[@pinakibanerjee2001](/pinakibanerjee2001) oh duh, thank you"
                    },
                    {
                        "username": "pinakibanerjee2001",
                        "content": "You are supposed to find maximum zigzag path starting at any node, not necessarily starting at root\n"
                    },
                    {
                        "username": "van146",
                        "content": "yeah - I was stumbled upon the same understanding spike - e.g. read the whole description - as we need to find max possible zigzag path within the tree, and this one not necessarily would start from the root of the tree, that\\'s why example one is correct and it explains the task better then description"
                    },
                    {
                        "username": "teckyshubham",
                        "content": " `yclass Solution {\\n    public int longestZigZag(TreeNode root) {\\n    return dfs(root).subtreeMax;\\n  }\\n\\n  private T dfs(TreeNode root) {\\n    if (root == null)\\n      return new T(-1, -1, -1);\\n    T left = dfs(root.left);\\n    T right = dfs(root.right);\\n    final int leftZigZag = left.rightMax + 1;\\n    final int rightZigZag = right.leftMax + 1;\\n    final int subtreeMax =\\n        Math.max(Math.max(leftZigZag, rightZigZag), Math.max(left.subtreeMax, right.subtreeMax));\\n    return new T(leftZigZag, rightZigZag, subtreeMax);\\n  }\\n}`"
                    },
                    {
                        "username": "teckyshubham",
                        "content": " `class T {\\n  public int leftMax;\\n  public int rightMax;\\n  public int subtreeMax;\\n\\n  public T(int leftMax, int rightMax, int subtreeMax) {\\n    this.leftMax = leftMax;\\n    this.rightMax = rightMax;\\n    this.subtreeMax = subtreeMax;\\n  }\\n}`"
                    }
                ]
            },
            {
                "id": 1868541,
                "content": [
                    {
                        "username": "ndrwknsh",
                        "content": "If you\\'re struggling with this problem, you may want to consider the differences between top-down recursion and bottom-up recursion."
                    },
                    {
                        "username": "tsagikyan",
                        "content": "Faster than editorial | CPP | 1-liner recursion:\n```\n    int dfs(TreeNode* root, int lsum, int rsum) {\n        return root==0 ? max(lsum,rsum) : max(dfs(root->left, rsum+1, -1), dfs(root->right, -1, lsum+1));\n    }\n\n    int longestZigZag(TreeNode* root) {\n        return dfs(root, -1, -1);\n    }\n```"
                    },
                    {
                        "username": "user5742L",
                        "content": "Why it is Giving WA??\nclass Solution {\n    public int f(TreeNode root, boolean isLeft, int count) {\n        if (root == null) {\n            return count;\n        }\n        if (isLeft) {\n            return Math.max(f(root.right, false, count + 1), Math.max(f(root.left, true, 0),f(root.left, false, 0)));\n        } else {\n            return Math.max(f(root.left, true, count + 1), Math.max(f(root.right, true, 0),f(root.right, false, 0)));\n        }\n    }\n    \n    public int longestZigZag(TreeNode root) {\n        if (root == null) {\n            return 0;\n        }\n        return Math.max(f(root.left, true, 0), f(root.right, false, 0));\n    }\n}\n\n\n\n  "
                    },
                    {
                        "username": "ankeshaman333",
                        "content": "Is anyone facing version of your browser is too low to load the code-editor"
                    },
                    {
                        "username": "klaca",
                        "content": "It happened to me two days ago but now it works. I didn't do anything to fix it."
                    },
                    {
                        "username": "klaca",
                        "content": "Do you have any tips for debugging a test case with a huge tree? I fail at test case 52, my solution returns 2050 instead of 6962 and I don't have the slightest idea what the problem could be.\nmy approach is to follow a zigzag, putting unvisited nodes (with direction) on a stack, and starting a new count from the top of the stack when the current path is exhausted. It has no problem with the first 51 test cases."
                    },
                    {
                        "username": "klaca",
                        "content": "[@Mister_CK](/Mister_CK) It's not a recursion. I thought to do an incremental traversal using a stack, there is really not much difference to it. I will try recursion now that I can't see the problem with incremental. \nEdit: it was quite simple with recursion. I'm still bothered about not knowing what went wrong with my incremental solution... I guess I just have to leave it like that now..."
                    },
                    {
                        "username": "Mister_CK",
                        "content": "you could log the root in you recursive function. Not sure if that test case isn\\'t to big for even that though. \\nBut creating a stack of nodes to visit later is not a great approach. Try to do those nodes immediately. (or, well, DFS so still after the current iteration, but there is no need to store them, just call them, if you get what I mean)"
                    },
                    {
                        "username": "Mshashikanth",
                        "content": "struggled a lot to solve this one"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "me too, was trying to use dynamic programming, but couldn\\'t get it to work, wasted a lot of time on it. Doing DFS while keeping track of current path length was so much simpeler! Ended up spending more time on this medium than on Sundays hard."
                    },
                    {
                        "username": "jainams6160",
                        "content": " Can some explain me the time complexity of this solution?\\n\\n    static int ans;\\n    static void util(TreeNode root, boolean l, boolean r, int value){\\n        if(root == null){\\n            ans = Math.max(ans, value);\\n            return;\\n        }\\n        if(l)\\n            util(root.left, false, true, value + 1);\\n        if(r)\\n            util(root.right, true, false, value + 1);\\n        util(root.left, true, true, -1);\\n        util(root.right, true, true, -1);\\n    }\\n\\n    public int longestZigZag(TreeNode root) {\\n        ans = 0;\\n        util(root, true, true, -1)\\n        return ans;\\n    }`"
                    },
                    {
                        "username": "elrestbrain",
                        "content": "Example 1 doesn\\'t make any sense to me? Doesn\\'t it go right *twice* at the beginning? \\n\\nI feel like it should be right -> left -> right for a path length of 2, since we count edges not nodes"
                    },
                    {
                        "username": "elrestbrain",
                        "content": "[@pinakibanerjee2001](/pinakibanerjee2001) oh duh, thank you"
                    },
                    {
                        "username": "pinakibanerjee2001",
                        "content": "You are supposed to find maximum zigzag path starting at any node, not necessarily starting at root\n"
                    },
                    {
                        "username": "van146",
                        "content": "yeah - I was stumbled upon the same understanding spike - e.g. read the whole description - as we need to find max possible zigzag path within the tree, and this one not necessarily would start from the root of the tree, that\\'s why example one is correct and it explains the task better then description"
                    },
                    {
                        "username": "teckyshubham",
                        "content": " `yclass Solution {\\n    public int longestZigZag(TreeNode root) {\\n    return dfs(root).subtreeMax;\\n  }\\n\\n  private T dfs(TreeNode root) {\\n    if (root == null)\\n      return new T(-1, -1, -1);\\n    T left = dfs(root.left);\\n    T right = dfs(root.right);\\n    final int leftZigZag = left.rightMax + 1;\\n    final int rightZigZag = right.leftMax + 1;\\n    final int subtreeMax =\\n        Math.max(Math.max(leftZigZag, rightZigZag), Math.max(left.subtreeMax, right.subtreeMax));\\n    return new T(leftZigZag, rightZigZag, subtreeMax);\\n  }\\n}`"
                    },
                    {
                        "username": "teckyshubham",
                        "content": " `class T {\\n  public int leftMax;\\n  public int rightMax;\\n  public int subtreeMax;\\n\\n  public T(int leftMax, int rightMax, int subtreeMax) {\\n    this.leftMax = leftMax;\\n    this.rightMax = rightMax;\\n    this.subtreeMax = subtreeMax;\\n  }\\n}`"
                    }
                ]
            },
            {
                "id": 1868522,
                "content": [
                    {
                        "username": "ndrwknsh",
                        "content": "If you\\'re struggling with this problem, you may want to consider the differences between top-down recursion and bottom-up recursion."
                    },
                    {
                        "username": "tsagikyan",
                        "content": "Faster than editorial | CPP | 1-liner recursion:\n```\n    int dfs(TreeNode* root, int lsum, int rsum) {\n        return root==0 ? max(lsum,rsum) : max(dfs(root->left, rsum+1, -1), dfs(root->right, -1, lsum+1));\n    }\n\n    int longestZigZag(TreeNode* root) {\n        return dfs(root, -1, -1);\n    }\n```"
                    },
                    {
                        "username": "user5742L",
                        "content": "Why it is Giving WA??\nclass Solution {\n    public int f(TreeNode root, boolean isLeft, int count) {\n        if (root == null) {\n            return count;\n        }\n        if (isLeft) {\n            return Math.max(f(root.right, false, count + 1), Math.max(f(root.left, true, 0),f(root.left, false, 0)));\n        } else {\n            return Math.max(f(root.left, true, count + 1), Math.max(f(root.right, true, 0),f(root.right, false, 0)));\n        }\n    }\n    \n    public int longestZigZag(TreeNode root) {\n        if (root == null) {\n            return 0;\n        }\n        return Math.max(f(root.left, true, 0), f(root.right, false, 0));\n    }\n}\n\n\n\n  "
                    },
                    {
                        "username": "ankeshaman333",
                        "content": "Is anyone facing version of your browser is too low to load the code-editor"
                    },
                    {
                        "username": "klaca",
                        "content": "It happened to me two days ago but now it works. I didn't do anything to fix it."
                    },
                    {
                        "username": "klaca",
                        "content": "Do you have any tips for debugging a test case with a huge tree? I fail at test case 52, my solution returns 2050 instead of 6962 and I don't have the slightest idea what the problem could be.\nmy approach is to follow a zigzag, putting unvisited nodes (with direction) on a stack, and starting a new count from the top of the stack when the current path is exhausted. It has no problem with the first 51 test cases."
                    },
                    {
                        "username": "klaca",
                        "content": "[@Mister_CK](/Mister_CK) It's not a recursion. I thought to do an incremental traversal using a stack, there is really not much difference to it. I will try recursion now that I can't see the problem with incremental. \nEdit: it was quite simple with recursion. I'm still bothered about not knowing what went wrong with my incremental solution... I guess I just have to leave it like that now..."
                    },
                    {
                        "username": "Mister_CK",
                        "content": "you could log the root in you recursive function. Not sure if that test case isn\\'t to big for even that though. \\nBut creating a stack of nodes to visit later is not a great approach. Try to do those nodes immediately. (or, well, DFS so still after the current iteration, but there is no need to store them, just call them, if you get what I mean)"
                    },
                    {
                        "username": "Mshashikanth",
                        "content": "struggled a lot to solve this one"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "me too, was trying to use dynamic programming, but couldn\\'t get it to work, wasted a lot of time on it. Doing DFS while keeping track of current path length was so much simpeler! Ended up spending more time on this medium than on Sundays hard."
                    },
                    {
                        "username": "jainams6160",
                        "content": " Can some explain me the time complexity of this solution?\\n\\n    static int ans;\\n    static void util(TreeNode root, boolean l, boolean r, int value){\\n        if(root == null){\\n            ans = Math.max(ans, value);\\n            return;\\n        }\\n        if(l)\\n            util(root.left, false, true, value + 1);\\n        if(r)\\n            util(root.right, true, false, value + 1);\\n        util(root.left, true, true, -1);\\n        util(root.right, true, true, -1);\\n    }\\n\\n    public int longestZigZag(TreeNode root) {\\n        ans = 0;\\n        util(root, true, true, -1)\\n        return ans;\\n    }`"
                    },
                    {
                        "username": "elrestbrain",
                        "content": "Example 1 doesn\\'t make any sense to me? Doesn\\'t it go right *twice* at the beginning? \\n\\nI feel like it should be right -> left -> right for a path length of 2, since we count edges not nodes"
                    },
                    {
                        "username": "elrestbrain",
                        "content": "[@pinakibanerjee2001](/pinakibanerjee2001) oh duh, thank you"
                    },
                    {
                        "username": "pinakibanerjee2001",
                        "content": "You are supposed to find maximum zigzag path starting at any node, not necessarily starting at root\n"
                    },
                    {
                        "username": "van146",
                        "content": "yeah - I was stumbled upon the same understanding spike - e.g. read the whole description - as we need to find max possible zigzag path within the tree, and this one not necessarily would start from the root of the tree, that\\'s why example one is correct and it explains the task better then description"
                    },
                    {
                        "username": "teckyshubham",
                        "content": " `yclass Solution {\\n    public int longestZigZag(TreeNode root) {\\n    return dfs(root).subtreeMax;\\n  }\\n\\n  private T dfs(TreeNode root) {\\n    if (root == null)\\n      return new T(-1, -1, -1);\\n    T left = dfs(root.left);\\n    T right = dfs(root.right);\\n    final int leftZigZag = left.rightMax + 1;\\n    final int rightZigZag = right.leftMax + 1;\\n    final int subtreeMax =\\n        Math.max(Math.max(leftZigZag, rightZigZag), Math.max(left.subtreeMax, right.subtreeMax));\\n    return new T(leftZigZag, rightZigZag, subtreeMax);\\n  }\\n}`"
                    },
                    {
                        "username": "teckyshubham",
                        "content": " `class T {\\n  public int leftMax;\\n  public int rightMax;\\n  public int subtreeMax;\\n\\n  public T(int leftMax, int rightMax, int subtreeMax) {\\n    this.leftMax = leftMax;\\n    this.rightMax = rightMax;\\n    this.subtreeMax = subtreeMax;\\n  }\\n}`"
                    }
                ]
            },
            {
                "id": 1868504,
                "content": [
                    {
                        "username": "ndrwknsh",
                        "content": "If you\\'re struggling with this problem, you may want to consider the differences between top-down recursion and bottom-up recursion."
                    },
                    {
                        "username": "tsagikyan",
                        "content": "Faster than editorial | CPP | 1-liner recursion:\n```\n    int dfs(TreeNode* root, int lsum, int rsum) {\n        return root==0 ? max(lsum,rsum) : max(dfs(root->left, rsum+1, -1), dfs(root->right, -1, lsum+1));\n    }\n\n    int longestZigZag(TreeNode* root) {\n        return dfs(root, -1, -1);\n    }\n```"
                    },
                    {
                        "username": "user5742L",
                        "content": "Why it is Giving WA??\nclass Solution {\n    public int f(TreeNode root, boolean isLeft, int count) {\n        if (root == null) {\n            return count;\n        }\n        if (isLeft) {\n            return Math.max(f(root.right, false, count + 1), Math.max(f(root.left, true, 0),f(root.left, false, 0)));\n        } else {\n            return Math.max(f(root.left, true, count + 1), Math.max(f(root.right, true, 0),f(root.right, false, 0)));\n        }\n    }\n    \n    public int longestZigZag(TreeNode root) {\n        if (root == null) {\n            return 0;\n        }\n        return Math.max(f(root.left, true, 0), f(root.right, false, 0));\n    }\n}\n\n\n\n  "
                    },
                    {
                        "username": "ankeshaman333",
                        "content": "Is anyone facing version of your browser is too low to load the code-editor"
                    },
                    {
                        "username": "klaca",
                        "content": "It happened to me two days ago but now it works. I didn't do anything to fix it."
                    },
                    {
                        "username": "klaca",
                        "content": "Do you have any tips for debugging a test case with a huge tree? I fail at test case 52, my solution returns 2050 instead of 6962 and I don't have the slightest idea what the problem could be.\nmy approach is to follow a zigzag, putting unvisited nodes (with direction) on a stack, and starting a new count from the top of the stack when the current path is exhausted. It has no problem with the first 51 test cases."
                    },
                    {
                        "username": "klaca",
                        "content": "[@Mister_CK](/Mister_CK) It's not a recursion. I thought to do an incremental traversal using a stack, there is really not much difference to it. I will try recursion now that I can't see the problem with incremental. \nEdit: it was quite simple with recursion. I'm still bothered about not knowing what went wrong with my incremental solution... I guess I just have to leave it like that now..."
                    },
                    {
                        "username": "Mister_CK",
                        "content": "you could log the root in you recursive function. Not sure if that test case isn\\'t to big for even that though. \\nBut creating a stack of nodes to visit later is not a great approach. Try to do those nodes immediately. (or, well, DFS so still after the current iteration, but there is no need to store them, just call them, if you get what I mean)"
                    },
                    {
                        "username": "Mshashikanth",
                        "content": "struggled a lot to solve this one"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "me too, was trying to use dynamic programming, but couldn\\'t get it to work, wasted a lot of time on it. Doing DFS while keeping track of current path length was so much simpeler! Ended up spending more time on this medium than on Sundays hard."
                    },
                    {
                        "username": "jainams6160",
                        "content": " Can some explain me the time complexity of this solution?\\n\\n    static int ans;\\n    static void util(TreeNode root, boolean l, boolean r, int value){\\n        if(root == null){\\n            ans = Math.max(ans, value);\\n            return;\\n        }\\n        if(l)\\n            util(root.left, false, true, value + 1);\\n        if(r)\\n            util(root.right, true, false, value + 1);\\n        util(root.left, true, true, -1);\\n        util(root.right, true, true, -1);\\n    }\\n\\n    public int longestZigZag(TreeNode root) {\\n        ans = 0;\\n        util(root, true, true, -1)\\n        return ans;\\n    }`"
                    },
                    {
                        "username": "elrestbrain",
                        "content": "Example 1 doesn\\'t make any sense to me? Doesn\\'t it go right *twice* at the beginning? \\n\\nI feel like it should be right -> left -> right for a path length of 2, since we count edges not nodes"
                    },
                    {
                        "username": "elrestbrain",
                        "content": "[@pinakibanerjee2001](/pinakibanerjee2001) oh duh, thank you"
                    },
                    {
                        "username": "pinakibanerjee2001",
                        "content": "You are supposed to find maximum zigzag path starting at any node, not necessarily starting at root\n"
                    },
                    {
                        "username": "van146",
                        "content": "yeah - I was stumbled upon the same understanding spike - e.g. read the whole description - as we need to find max possible zigzag path within the tree, and this one not necessarily would start from the root of the tree, that\\'s why example one is correct and it explains the task better then description"
                    },
                    {
                        "username": "teckyshubham",
                        "content": " `yclass Solution {\\n    public int longestZigZag(TreeNode root) {\\n    return dfs(root).subtreeMax;\\n  }\\n\\n  private T dfs(TreeNode root) {\\n    if (root == null)\\n      return new T(-1, -1, -1);\\n    T left = dfs(root.left);\\n    T right = dfs(root.right);\\n    final int leftZigZag = left.rightMax + 1;\\n    final int rightZigZag = right.leftMax + 1;\\n    final int subtreeMax =\\n        Math.max(Math.max(leftZigZag, rightZigZag), Math.max(left.subtreeMax, right.subtreeMax));\\n    return new T(leftZigZag, rightZigZag, subtreeMax);\\n  }\\n}`"
                    },
                    {
                        "username": "teckyshubham",
                        "content": " `class T {\\n  public int leftMax;\\n  public int rightMax;\\n  public int subtreeMax;\\n\\n  public T(int leftMax, int rightMax, int subtreeMax) {\\n    this.leftMax = leftMax;\\n    this.rightMax = rightMax;\\n    this.subtreeMax = subtreeMax;\\n  }\\n}`"
                    }
                ]
            },
            {
                "id": 1868492,
                "content": [
                    {
                        "username": "ndrwknsh",
                        "content": "If you\\'re struggling with this problem, you may want to consider the differences between top-down recursion and bottom-up recursion."
                    },
                    {
                        "username": "tsagikyan",
                        "content": "Faster than editorial | CPP | 1-liner recursion:\n```\n    int dfs(TreeNode* root, int lsum, int rsum) {\n        return root==0 ? max(lsum,rsum) : max(dfs(root->left, rsum+1, -1), dfs(root->right, -1, lsum+1));\n    }\n\n    int longestZigZag(TreeNode* root) {\n        return dfs(root, -1, -1);\n    }\n```"
                    },
                    {
                        "username": "user5742L",
                        "content": "Why it is Giving WA??\nclass Solution {\n    public int f(TreeNode root, boolean isLeft, int count) {\n        if (root == null) {\n            return count;\n        }\n        if (isLeft) {\n            return Math.max(f(root.right, false, count + 1), Math.max(f(root.left, true, 0),f(root.left, false, 0)));\n        } else {\n            return Math.max(f(root.left, true, count + 1), Math.max(f(root.right, true, 0),f(root.right, false, 0)));\n        }\n    }\n    \n    public int longestZigZag(TreeNode root) {\n        if (root == null) {\n            return 0;\n        }\n        return Math.max(f(root.left, true, 0), f(root.right, false, 0));\n    }\n}\n\n\n\n  "
                    },
                    {
                        "username": "ankeshaman333",
                        "content": "Is anyone facing version of your browser is too low to load the code-editor"
                    },
                    {
                        "username": "klaca",
                        "content": "It happened to me two days ago but now it works. I didn't do anything to fix it."
                    },
                    {
                        "username": "klaca",
                        "content": "Do you have any tips for debugging a test case with a huge tree? I fail at test case 52, my solution returns 2050 instead of 6962 and I don't have the slightest idea what the problem could be.\nmy approach is to follow a zigzag, putting unvisited nodes (with direction) on a stack, and starting a new count from the top of the stack when the current path is exhausted. It has no problem with the first 51 test cases."
                    },
                    {
                        "username": "klaca",
                        "content": "[@Mister_CK](/Mister_CK) It's not a recursion. I thought to do an incremental traversal using a stack, there is really not much difference to it. I will try recursion now that I can't see the problem with incremental. \nEdit: it was quite simple with recursion. I'm still bothered about not knowing what went wrong with my incremental solution... I guess I just have to leave it like that now..."
                    },
                    {
                        "username": "Mister_CK",
                        "content": "you could log the root in you recursive function. Not sure if that test case isn\\'t to big for even that though. \\nBut creating a stack of nodes to visit later is not a great approach. Try to do those nodes immediately. (or, well, DFS so still after the current iteration, but there is no need to store them, just call them, if you get what I mean)"
                    },
                    {
                        "username": "Mshashikanth",
                        "content": "struggled a lot to solve this one"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "me too, was trying to use dynamic programming, but couldn\\'t get it to work, wasted a lot of time on it. Doing DFS while keeping track of current path length was so much simpeler! Ended up spending more time on this medium than on Sundays hard."
                    },
                    {
                        "username": "jainams6160",
                        "content": " Can some explain me the time complexity of this solution?\\n\\n    static int ans;\\n    static void util(TreeNode root, boolean l, boolean r, int value){\\n        if(root == null){\\n            ans = Math.max(ans, value);\\n            return;\\n        }\\n        if(l)\\n            util(root.left, false, true, value + 1);\\n        if(r)\\n            util(root.right, true, false, value + 1);\\n        util(root.left, true, true, -1);\\n        util(root.right, true, true, -1);\\n    }\\n\\n    public int longestZigZag(TreeNode root) {\\n        ans = 0;\\n        util(root, true, true, -1)\\n        return ans;\\n    }`"
                    },
                    {
                        "username": "elrestbrain",
                        "content": "Example 1 doesn\\'t make any sense to me? Doesn\\'t it go right *twice* at the beginning? \\n\\nI feel like it should be right -> left -> right for a path length of 2, since we count edges not nodes"
                    },
                    {
                        "username": "elrestbrain",
                        "content": "[@pinakibanerjee2001](/pinakibanerjee2001) oh duh, thank you"
                    },
                    {
                        "username": "pinakibanerjee2001",
                        "content": "You are supposed to find maximum zigzag path starting at any node, not necessarily starting at root\n"
                    },
                    {
                        "username": "van146",
                        "content": "yeah - I was stumbled upon the same understanding spike - e.g. read the whole description - as we need to find max possible zigzag path within the tree, and this one not necessarily would start from the root of the tree, that\\'s why example one is correct and it explains the task better then description"
                    },
                    {
                        "username": "teckyshubham",
                        "content": " `yclass Solution {\\n    public int longestZigZag(TreeNode root) {\\n    return dfs(root).subtreeMax;\\n  }\\n\\n  private T dfs(TreeNode root) {\\n    if (root == null)\\n      return new T(-1, -1, -1);\\n    T left = dfs(root.left);\\n    T right = dfs(root.right);\\n    final int leftZigZag = left.rightMax + 1;\\n    final int rightZigZag = right.leftMax + 1;\\n    final int subtreeMax =\\n        Math.max(Math.max(leftZigZag, rightZigZag), Math.max(left.subtreeMax, right.subtreeMax));\\n    return new T(leftZigZag, rightZigZag, subtreeMax);\\n  }\\n}`"
                    },
                    {
                        "username": "teckyshubham",
                        "content": " `class T {\\n  public int leftMax;\\n  public int rightMax;\\n  public int subtreeMax;\\n\\n  public T(int leftMax, int rightMax, int subtreeMax) {\\n    this.leftMax = leftMax;\\n    this.rightMax = rightMax;\\n    this.subtreeMax = subtreeMax;\\n  }\\n}`"
                    }
                ]
            },
            {
                "id": 1868491,
                "content": [
                    {
                        "username": "ndrwknsh",
                        "content": "If you\\'re struggling with this problem, you may want to consider the differences between top-down recursion and bottom-up recursion."
                    },
                    {
                        "username": "tsagikyan",
                        "content": "Faster than editorial | CPP | 1-liner recursion:\n```\n    int dfs(TreeNode* root, int lsum, int rsum) {\n        return root==0 ? max(lsum,rsum) : max(dfs(root->left, rsum+1, -1), dfs(root->right, -1, lsum+1));\n    }\n\n    int longestZigZag(TreeNode* root) {\n        return dfs(root, -1, -1);\n    }\n```"
                    },
                    {
                        "username": "user5742L",
                        "content": "Why it is Giving WA??\nclass Solution {\n    public int f(TreeNode root, boolean isLeft, int count) {\n        if (root == null) {\n            return count;\n        }\n        if (isLeft) {\n            return Math.max(f(root.right, false, count + 1), Math.max(f(root.left, true, 0),f(root.left, false, 0)));\n        } else {\n            return Math.max(f(root.left, true, count + 1), Math.max(f(root.right, true, 0),f(root.right, false, 0)));\n        }\n    }\n    \n    public int longestZigZag(TreeNode root) {\n        if (root == null) {\n            return 0;\n        }\n        return Math.max(f(root.left, true, 0), f(root.right, false, 0));\n    }\n}\n\n\n\n  "
                    },
                    {
                        "username": "ankeshaman333",
                        "content": "Is anyone facing version of your browser is too low to load the code-editor"
                    },
                    {
                        "username": "klaca",
                        "content": "It happened to me two days ago but now it works. I didn't do anything to fix it."
                    },
                    {
                        "username": "klaca",
                        "content": "Do you have any tips for debugging a test case with a huge tree? I fail at test case 52, my solution returns 2050 instead of 6962 and I don't have the slightest idea what the problem could be.\nmy approach is to follow a zigzag, putting unvisited nodes (with direction) on a stack, and starting a new count from the top of the stack when the current path is exhausted. It has no problem with the first 51 test cases."
                    },
                    {
                        "username": "klaca",
                        "content": "[@Mister_CK](/Mister_CK) It's not a recursion. I thought to do an incremental traversal using a stack, there is really not much difference to it. I will try recursion now that I can't see the problem with incremental. \nEdit: it was quite simple with recursion. I'm still bothered about not knowing what went wrong with my incremental solution... I guess I just have to leave it like that now..."
                    },
                    {
                        "username": "Mister_CK",
                        "content": "you could log the root in you recursive function. Not sure if that test case isn\\'t to big for even that though. \\nBut creating a stack of nodes to visit later is not a great approach. Try to do those nodes immediately. (or, well, DFS so still after the current iteration, but there is no need to store them, just call them, if you get what I mean)"
                    },
                    {
                        "username": "Mshashikanth",
                        "content": "struggled a lot to solve this one"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "me too, was trying to use dynamic programming, but couldn\\'t get it to work, wasted a lot of time on it. Doing DFS while keeping track of current path length was so much simpeler! Ended up spending more time on this medium than on Sundays hard."
                    },
                    {
                        "username": "jainams6160",
                        "content": " Can some explain me the time complexity of this solution?\\n\\n    static int ans;\\n    static void util(TreeNode root, boolean l, boolean r, int value){\\n        if(root == null){\\n            ans = Math.max(ans, value);\\n            return;\\n        }\\n        if(l)\\n            util(root.left, false, true, value + 1);\\n        if(r)\\n            util(root.right, true, false, value + 1);\\n        util(root.left, true, true, -1);\\n        util(root.right, true, true, -1);\\n    }\\n\\n    public int longestZigZag(TreeNode root) {\\n        ans = 0;\\n        util(root, true, true, -1)\\n        return ans;\\n    }`"
                    },
                    {
                        "username": "elrestbrain",
                        "content": "Example 1 doesn\\'t make any sense to me? Doesn\\'t it go right *twice* at the beginning? \\n\\nI feel like it should be right -> left -> right for a path length of 2, since we count edges not nodes"
                    },
                    {
                        "username": "elrestbrain",
                        "content": "[@pinakibanerjee2001](/pinakibanerjee2001) oh duh, thank you"
                    },
                    {
                        "username": "pinakibanerjee2001",
                        "content": "You are supposed to find maximum zigzag path starting at any node, not necessarily starting at root\n"
                    },
                    {
                        "username": "van146",
                        "content": "yeah - I was stumbled upon the same understanding spike - e.g. read the whole description - as we need to find max possible zigzag path within the tree, and this one not necessarily would start from the root of the tree, that\\'s why example one is correct and it explains the task better then description"
                    },
                    {
                        "username": "teckyshubham",
                        "content": " `yclass Solution {\\n    public int longestZigZag(TreeNode root) {\\n    return dfs(root).subtreeMax;\\n  }\\n\\n  private T dfs(TreeNode root) {\\n    if (root == null)\\n      return new T(-1, -1, -1);\\n    T left = dfs(root.left);\\n    T right = dfs(root.right);\\n    final int leftZigZag = left.rightMax + 1;\\n    final int rightZigZag = right.leftMax + 1;\\n    final int subtreeMax =\\n        Math.max(Math.max(leftZigZag, rightZigZag), Math.max(left.subtreeMax, right.subtreeMax));\\n    return new T(leftZigZag, rightZigZag, subtreeMax);\\n  }\\n}`"
                    },
                    {
                        "username": "teckyshubham",
                        "content": " `class T {\\n  public int leftMax;\\n  public int rightMax;\\n  public int subtreeMax;\\n\\n  public T(int leftMax, int rightMax, int subtreeMax) {\\n    this.leftMax = leftMax;\\n    this.rightMax = rightMax;\\n    this.subtreeMax = subtreeMax;\\n  }\\n}`"
                    }
                ]
            }
        ]
    }
]